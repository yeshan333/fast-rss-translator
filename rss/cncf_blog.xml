<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CNCF - Blog</title>
    <link>http://rsshub.rssforever.com/cncf</link>
    <description>CNCF - Blog - Powered by RSSHub</description>
    <managingEditor>contact@rsshub.app (RSSHub)</managingEditor>
    <item>
      <title>【KubeCon + CloudNativeCon North America 2024 co-located event deep dive: Cloud Native StartupFest】KubeCon + CloudNativeCon North America 2024 同期举办活动深入探讨：Cloud Native StartupFest</title>
      <link>https://www.cncf.io/blog/2024/11/04/kubecon-cloudnativecon-north-america-2024-co-located-event-deep-dive-cloud-native-startupfest/</link>
      <description>【&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;411&#34; height=&#34;144&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2024/11/CloudNativeStartUpFest_Logo_Horizontal_Color.svg&#34; alt=&#34;Logo&#34; class=&#34;wp-image-119872&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Co-chairs: Megan Reynolds, Kelsey Hightower&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;em&gt;November 12, 2024&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Salt Lake City, Utah&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;At the &lt;a href=&#34;https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/co-located-events/cloud-native-startupfest/&#34;&gt;Cloud Native StartupFest&lt;/a&gt; expect to get inspired by hearing from successful cloud native entrepreneurs, learn about some of the most exciting cloud native and OSS startups in the space, get a glimpse into the current state of fundraising, and receive guidance on how to take your idea from community adoption to success. The Cloud Native StartupFest first happened during KubeCon + CloudNativeCon North America 2023.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Who will get the most out of attending this event?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;It’s for startup builders or anyone considering starting a company in the OSS or cloud native space&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What is new and different this year?&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Market conditions have become more challenging. Today it’s harder for any company to close customers and raise money so this year we are focusing more on how to navigate this new world as a startup builder. We have an all-star line-up of successful entrepreneurs and executives that will share their guidance.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What will the day look like?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;We have an afternoon session of talks and panels guided by our exceptional MC, Kelsey Hightower. We’ll make time for Q&amp;amp;A from the audience after every session to keep the day as interactive as possible.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Should I do any homework first?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Come prepared with any go-to-market challenges you’re facing right now to get feedback in the Q&amp;amp;A segments. It’s likely the speakers have experienced something similar and will be able to share advice.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Find your community!&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;We’re over the moon about the caliber of speakers that have given their time to join us, there will be a lot to learn from all of them and we expect some spicy discussions!&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Submitted by Megan Reynolds, who is looking forward to learning how new startups are adapting to the Generative AI wave and the impact that’s having on core enterprise infrastructure.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/register/&#34;&gt;Don’t forget to register&lt;/a&gt; for KubeCon + CloudNativeCon North America 2024.&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“411”高度=“144”src=“https://www.cncf.io/ wp-content/uploads/2024/11/CloudNativeStartUpFest_Logo_Horizo​​ntal_Color.svg&#34; alt=&#34;Logo&#34; class=&#34;wp-image-119872&#34;referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;em&gt;联合主席：Megan Reynolds、Kelsey Hightower&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;em&gt;2024 年 11 月 12 日&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;em&gt;犹他州盐湖城&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在&lt;a href=&#34;https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/co- located-events/cloud-native-startupfest/&#34;&gt;云原生启动节&lt;/a&gt;期待从成功的云原生企业家的演讲中获得灵感，了解该领域一些最令人兴奋的云原生和 OSS 初创公司，了解当前的筹款状况，并获得有关如何将您的想法从社区采用转化为实践的指导成功。云原生 StartupFest 首次在 KubeCon + CloudNativeCon North America 2023 期间举行。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;谁将从参加本次活动中获益最多？&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;它适用于初创公司构建者或任何考虑在 OSS 或云原生空间中创办公司的人&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;今年有什么新的和不同的？&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;市场状况变得更具挑战性。如今，任何公司都很难关闭客户并筹集资金，因此今年我们更多地关注如何作为初创公司建设者驾驭这个新世界。我们拥有由成功企业家和高管组成的全明星阵容，他们将分享他们的指导。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;这一天会是什么样子？&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我们在下午举行了会谈和​​小组讨论，由我们杰出的主持人凯尔西·海托尔 (Kelsey Hightower) 主持。每次会议结束后，我们都会腾出时间与观众进行问答，以尽可能保持当天的互动。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;我应该先做作业吗？&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;做好准备应对您目前面临的任何上市挑战，以便在问答环节获得反馈。演讲者很可能经历过类似的事情，并且能够分享建议。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;找到您的社区！&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我们对那些抽出时间加入我们的演讲者的才华感到欣喜若狂，从他们身上可以学到很多东西，我们期待一些激烈的讨论！&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;em&gt;由 Megan Reynolds 提交，她期待了解新的初创公司如何适应生成式 AI 浪潮及其对核心企业基础设施的影响。&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/register/&#34;&gt;不要忘记注册&lt;/a&gt;参加 KubeCon + CloudNativeCon North America 2024。&lt;/ p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Sun, 03 Nov 2024 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Get to know our new DEI Community Hub at KubeCon + CloudNativeCon North America 2024】在 KubeCon + CloudNativeCon North America 2024 上了解我们的新 DEI 社区中心</title>
      <link>https://www.cncf.io/blog/2024/11/05/get-to-know-our-new-dei-community-hub-at-kubecon-cloudnativecon-north-america-2024/</link>
      <description>【&lt;p&gt;We are delighted to announce our new &lt;a href=&#34;https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/attend/diversity-inclusion/#dei-community-hub&#34;&gt;DEI Community Hub&lt;/a&gt; at &lt;a href=&#34;https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/&#34;&gt;KubeCon + CloudNativeCon North America&lt;/a&gt;, sponsored by &lt;a href=&#34;https://cloud.google.com/&#34;&gt;Google Cloud&lt;/a&gt;, a physical space to connect, learn, and celebrate diversity, equity, and inclusion and accessibility! The DEI Hub is a great place to join community groups, participate in allyship and advocacy workshops, or simply relax in a safe space during open lounge hours.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;It is our hope that the Community Hub will not just be a place for education, networking and downtime, but also a place where people can find and make new friends.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Don’t Miss the Community Gatherings!&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&amp;nbsp;We believe strong communities foster a feeling of belonging by providing opportunities for interaction, collaboration, and shared experiences. Gatherings are planned for students, BIPOC (Black, Indigenous and People of Color), LGBTQIA+, and the broader community of attendees.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://kccncna2024.sched.com/overview/type/Diversity+%2B+Equity+%2B+Inclusion?iframe=no&#34;&gt;Search the schedule&lt;/a&gt; to find a gathering you’d like to attend.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Polish your Allyship Skills&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;From the way we conduct meetings to how we name our projects, there are countless opportunities in our day-to-day interactions to create better, more psychologically safe environments. Join Mike Bufano, Program Manager, Open Source DEI and Outreachat Google, in his session, “Be Part of the Solution: Cultivating Inclusion in Open Source” where he will share data from the field, discuss inclusion best practices, and leave attendees with actionable steps to cultivate inclusion in open source spaces.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Feel Empowered!&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Attendees who identify as women, non-binary individuals and allies are invited to start the day on a powerful note over a continental breakfast at a gathering, known as &lt;a href=&#34;https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/program/schedule/&#34;&gt;EmpowerUs&lt;/a&gt;. Network with peers, make new connections and discuss workplace issues and more before heading into the keynotes.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Explore LGBTQIA+ Advocacy and Honor Trans Awareness Week&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;To honor and celebrate &lt;a href=&#34;https://projectrainbowutah.org/taw&#34;&gt;Trans Awareness Week&lt;/a&gt;, come join this &lt;a href=&#34;https://sched.co/1qKKw&#34;&gt;fireside chat&lt;/a&gt; with Jacey Thornton from local Salt Lake City nonprofit &lt;a href=&#34;https://projectrainbowutah.org/&#34;&gt;Project Rainbow&lt;/a&gt;. Topics will include the current climate for the queer community in Salt Lake City and ways in which we can better show up for our LGBTQIA+ peers more broadly. This session will be immediately followed by the &lt;a href=&#34;https://sched.co/1pedK&#34;&gt;LGBTQIA+ Community Gathering&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Learn Sign Language (and more!)&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Help make the cloud native community more accessible by joining the Deaf + Hard of Hearing Working Group for a&lt;a href=&#34;https://sched.co/1peg2&#34;&gt; lively discussion about advocacy&lt;/a&gt; and allyship. Then stay around for a &lt;a href=&#34;https://sched.co/1pegV&#34;&gt;Sign Language Crash Course&lt;/a&gt; where you can learn how sign language works and practice some basic cloud native signs.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Meet me at the DEI Community Hub&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Use this space to meet friends, old and new, before heading to the keynotes, attending a session, going to lunch or enjoying Salt Lake City. Or, our favorite suggestion: Find (or make) a friend then head to &lt;a href=&#34;https://kccncna2024.sched.com/event/1icVN?iframe=no&#34;&gt;KubeCrawl + CloudNativeFest&lt;/a&gt;, the official launch party of KubeCon + CloudNativeCon in the Solutions Showcase.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Try Peer Group Mentoring&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This is a great &lt;a href=&#34;https://sched.co/1mSv1&#34;&gt;opportunity&lt;/a&gt; for attendees to meet with experienced open source veterans from different CNCF projects for wide-ranging conversations across technical, community, career, and certification topics. Mentors will pair with 2-8 mentees in a pod-like environment to facilitate conversation and connection.&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;p&gt;我们很高兴宣布我们新的 &lt;a href=&#34;https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/attend/diversity-inclusion/#dei-community-hub&#34;&gt;DEI 社区中心&lt;/a&gt;，&lt;a href=&#34;https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/&#34;&gt;KubeCon + CloudNativeCon 北美&lt;/a&gt;，赞助商：&lt;a href=&#34;https:/ /cloud.google.com/&#34;&gt;Google Cloud&lt;/a&gt;，一个用于联系、学习和庆祝多样性、公平性、包容性和可访问性的物理空间！ DEI 中心是加入社区团体、参加联盟和宣传研讨会或在开放休息室时间在安全空间放松身心的好地方。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我们希望社区中心不仅是一个教育、交流和休息的地方，而且还是一个人们可以找到和结交新朋友的地方。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;不要错过社区聚会！&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我们相信，强大的社区可以通过提供互动、协作和共享体验的机会来培养归属感。计划为学生、BIPOC（黑人、原住民和有色人种）、LGBTQIA+ 以及更广泛的参与者群体举办聚会。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://kccncna2024.sched.com/overview/type/Diversity+%2B+Equity+%2B+Inclusion?iframe=no&#34;&gt;搜索日程&lt;/a&gt;以查找您的聚会我想参加。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;磨练你的盟友技能&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;从我们召开会议的方式到我们如何命名项目，我们的日常互动中有无数的机会来创造更好、心理上更安全的环境。与开源 DEI 和 Outreachat Google 项目经理 Mike Bufano 一起参加“成为解决方案的一部分：培养开源包容性”的会议，他将分享现场数据、讨论包容性最佳实践，并为与会者提供可行的建议培养开源空间包容性的步骤。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;感受力量！&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;邀请女性、非二元个体和盟友的与会者在一次名为 &lt;a href=&#34;https://events.linuxfoundation.org/ 的聚会上享用欧陆式早餐，以强有力的方式开始新的一天。 kubecon-cloudnativecon-north-america/program/schedule/&#34;&gt;EmpowerUs&lt;/a&gt;。在进入主题演讲之前，与同事建立联系、建立新的联系并讨论工作场所问题等。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;探索 LGBTQIA+ 倡导和荣誉跨性别意识周&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;为了纪念和庆祝&lt;a href=&#34;https://projectrainbowutah.org/taw&#34;&gt;跨性别意识周&lt;/a&gt;，请参加这个&lt;a href=&#34;https://sched.co/1qKKw&#34;&gt;与盐湖城当地非营利组织 &lt;a href=&#34;https://projectrainbowutah.org/&#34;&gt;彩虹计划&lt;/a&gt; 的 Jacey Thornton 进行炉边聊天&lt;/a&gt;。主题将包括盐湖城酷儿社区当前的氛围以及我们如何更好地向您展示p 更广泛地为 LGBTQIA+ 群体服务。本次会议之后将立即举行&lt;a href=&#34;https://sched.co/1pedK&#34;&gt;LGBTQIA+ 社区聚会&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;学习手语（以及更多！）&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;加入聋哑人士 + 听力障碍人士工作组，进行&lt;a href=&#34;https://sched.co/1peg2&#34;&gt;有关倡导和联盟的热烈讨论&lt;/a&gt;，帮助让云原生社区变得更容易访问。然后参加&lt;a href=&#34;https://sched.co/1pegV&#34;&gt;手语速成课程&lt;/a&gt;，在这里您可以了解手语的工作原理并练习一些基本的云原生手语。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;在 DEI 社区中心与我见面&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在参加主题演讲、参加会议、共进午餐或游览盐湖城之前，请使用此空间结识新老朋友。或者，我们最喜欢的建议：找到（或结交）一个朋友，然后前往官方网站 &lt;a href=&#34;https://kccncna2024.sched.com/event/1icVN?iframe=no&#34;&gt;KubeCrawl + CloudNativeFest&lt;/a&gt;解决方案展示中的 KubeCon + CloudNativeCon 发布会。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;尝试同伴小组指导&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;对于与会者来说，这是一个很好的&lt;a href=&#34;https://sched.co/1mSv1&#34;&gt;机会&lt;/a&gt;，可以与来自不同 CNCF 项目的经验丰富的开源资深人士会面，进行跨技术、社区的广泛对话、职业和认证主题。导师将在类似 Pod 的环境中与 2-8 名学员配对，以促进对话和联系。&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Mon, 04 Nov 2024 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Kubestronaut in Orbit: Rishabh Sharma】在轨道上的 Kubetronaut：Rishabh Sharma</title>
      <link>https://www.cncf.io/blog/2024/11/05/kubestronaut-in-orbit-rishabh-sharma/</link>
      <description>【&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1500&#34; height=&#34;787&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4.jpg&#34; alt=&#34;headshot&#34; class=&#34;wp-image-119877&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4.jpg 1500w, https://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4-300x157.jpg 300w, https://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4-1024x537.jpg 1024w, https://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4-768x403.jpg 768w, https://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4-194x102.jpg 194w, https://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4-388x204.jpg 388w, https://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4-776x408.jpg 776w, https://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4-900x472.jpg 900w, https://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4-381x200.jpg 381w, https://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4-762x400.jpg 762w, https://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4-590x310.jpg 590w, https://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4-1180x620.jpg 1180w&#34; sizes=&#34;(max-width: 1500px) 100vw, 1500px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Get to know Rishabh&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This week’s Kubestronaut in Orbit, Rishabh Sharma, our first Kubestonaut from Finland, is a senior software development engineer where he manages cloud native tech solutions for Capgemini Finland Oy. He is currently responsible for implementing and managing Kubernetes solutions for 4G and 5G technologies. His other key areas of interest are Java, Spring-Boot, Containerd, Linux, Istio, Linkerd, Falco, Sysdig, CoreDNS, Helm, OPA (Open Policy Agent), Cilium, Envoy etc.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;If you’d like to be a Kubestronaut like Rishabh, get more details on the &lt;a href=&#34;https://www.cncf.io/training/kubestronaut/&#34;&gt;CNCF Kubestronaut&lt;/a&gt; page.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;When did you get started with Kubernetes and/or cloud-native? What was your first project?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In early 2017, I was a part of a DevOps bootcamp in Chennai, India. In the 7 days of bootcamp I explored GCE VMs, Docker, and Kubernetes on a high level. It was the trigger point for me to explore Kubernetes.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;My first major project in Kubernetes was a Telco Network planning application which was deployed over a Kubernetes cluster as StatefulSet/Deployment pods.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;I saw the real Kubernetes magic when we never had a single second downtime for our network planning application deployed as Kubernetes workloads. We used a multi-zone setup – two k8s clusters in two different zones.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What are the primary CNCF projects you work on or use today?&amp;nbsp; What projects have you enjoyed the most in your career?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;I use the following CNCF projects today:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;1. &lt;a href=&#34;https://www.cncf.io/projects/kubernetes/&#34;&gt;Kubernetes&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;2. &lt;a href=&#34;https://www.cncf.io/projects/cilium/&#34;&gt;Cilium&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;3. &lt;a href=&#34;https://www.cncf.io/projects/containerd/&#34;&gt;Containerd&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;4. &lt;a href=&#34;https://www.cncf.io/projects/coredns/&#34;&gt;CoreDNS&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;5. &lt;a href=&#34;https://www.cncf.io/projects/fluentd/&#34;&gt;Fluentd&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;6. &lt;a href=&#34;https://www.cncf.io/projects/prometheus/&#34;&gt;Prometheus&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;7. &lt;a href=&#34;https://www.cncf.io/projects/etcd/&#34;&gt;Etcd&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;8. &lt;a href=&#34;https://www.cncf.io/projects/helm/&#34;&gt;Helm&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;9. &lt;a href=&#34;https://www.cncf.io/projects/kyverno/&#34;&gt;Kyverno&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;10. &lt;a href=&#34;https://www.cncf.io/projects/istio/&#34;&gt;Istio&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;11. &lt;a href=&#34;https://www.cncf.io/projects/falco/&#34;&gt;Falco&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;12. &lt;a href=&#34;https://www.cncf.io/projects/open-policy-agent-opa/&#34;&gt;Open Policy Agent (OPA)&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;I love the Kubernetes project so much because I am a telco guy and I have seen how Kubernetes actually supports telco new generation technologies – 4G and 5G and more.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Kubernetes’ flexible architecture and robust cloud-native management capabilities allow telcos to rapidly develop new features while maintaining performance and reliability.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;These projects are also favorites for these reasons:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Prometheus: Truly amazing project which is a must-application to monitor cloud native workloads.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Helm: Best well-known package manager for Kubernetes.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Cilium: The most famous CNI network plugin.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Istio: My favourite service-mesh.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Kyverno:&amp;nbsp; (K for Kubernetes, K for Kyverno), Just write your policies as yaml and no need to learn any other language to develop policies,&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;containerd: Container Runtime Interface known for its scalability, performance, and stability.&amp;nbsp;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;How have the certs or CNCF helped you in your career?&amp;nbsp;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;I have completed 6 CNCF certifications as follows:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/training/certification/kcna/&#34;&gt;Kubernetes and Cloud Native Associate (KCNA)&lt;/a&gt;: The first certificate gave me confidence to take the CNCF exam and gave me high-level introductions to a lot of cloud native technologies. It motivated me for further certifications.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/training/certification/ckad/&#34;&gt;Certified Kubernetes Application Developer (CKAD)&lt;/a&gt;: To prepare for this certificate, I read the whole &lt;a href=&#34;http://k8s.io/docs/concepts&#34;&gt;k8s.io/docs/concepts &lt;/a&gt;section and studied every single concept line by line. I also took the Killercoda K8s free lab and then tried to practice Kubernetes concepts.&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/training/certification/cka/&#34;&gt;Certified Kubernetes Administrator (CKA&lt;/a&gt;): My focus for this cert was to explore and learn k8s from the administration side–Kubeadm cluster setup, etcd backup, TLS, mTLS self signed certificates. It was a wonderful journey to explore these concepts and then use in my day-to-today work in my job.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/training/certification/cks/&#34;&gt;Certified Kubernetes Security Specialist (CKS)&lt;/a&gt;: Security is the key in any industry and CKS actually motivated me to get the training I needed to add “Sec” to my job profile and become “DevSecOps”. Falco, sysdig, supply chain security, CIS standards, Kube-bench and many more security tools are also key.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/training/certification/kcsa/&#34;&gt;Kubernetes and Cloud Security Associate (KCSA)&lt;/a&gt;: This provides the basics about Kubernetes and security and the process of getting this cert was a wonderful experience in exploring security basics and standards.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/training/certification/pca/&#34;&gt;Prometheus Certified Associate (PCA)&lt;/a&gt;: I recently cracked Prometheus Certified Associate. Prometheus truly helps us in monitoring our telco cloud-native workloads to ensure their health and by alerting when there is something wrong.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What are some other books/sites/courses you recommend for people who want to work with k8s?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;To be honest the only “book” to learn Kubernetes is the from the source: &lt;a href=&#34;https://kubernetes.io/docs/concepts&#34;&gt;https://kubernetes.io/docs/concepts&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;You should read the docs thoroughly and practice with free Kubernetes clusters like on killercoda.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Apart from official docs, if you would like to learn via courses, I would suggest the following courses:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://kodekloud.com/learning-path/cka&#34;&gt;CKA&lt;/a&gt; and &lt;a href=&#34;https://kodekloud.com/learning-path/ckad&#34;&gt;CKAD&lt;/a&gt; courses from KodeKloud and &lt;a href=&#34;https://business.udemy.com/cncf-endorsed-content/&#34;&gt;Udemy &lt;/a&gt;(check out the CNCF endorsed content).&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=d9xfB5qaOfg&#34;&gt;CKS course&lt;/a&gt; by Kim Wuestkamp over Killer Shell YouTube channel.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;For practice,use the &lt;a href=&#34;https://killer.sh/&#34;&gt;Killer Shell questions labs&lt;/a&gt; (absolutely free with purchase of exam).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What do you do in your free time?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;I enjoy these things in my free time:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Exploring Kubernetes: It is bottomless, like the ocean and I am always learning new concepts.&amp;nbsp; Some concepts like Pod topology spread constraints were not part of any k8s exam but these are really magical concepts as well as other features like scheduling framework, Pod Priority, and Preemption.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Exploring other CNCF projects: Currently learning Kyverno by making live policies and deploying them to see the real admission controller magic.&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Preparing for other CNCF certifications: Now that I have PCA, my next targets are &lt;a href=&#34;https://www.cncf.io/training/certification/cca/&#34;&gt;CCA (Cilium Certified Associate)&lt;/a&gt; and &lt;a href=&#34;https://www.cncf.io/training/certification/ica/&#34;&gt;ICA (Istio Certified Associate)&lt;/a&gt;.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Contributing to various CNCF activities: I like to participate in other CNCF activities and I’m also publishing my knowledge about CNCF technologies over medium and other platforms.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Watching crime thrillers I love to watch crime thrillers in my free time.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What would you tell someone who is just starting their K8s certification journey? Any tips or tricks?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Just go through the Kubernetes docs and then practice, practice, practice over free platforms like killer shell.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Get your hands dirty with Kubernetes concepts.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Today the Cloud native ecosystem is way more than Kubernetes. Do you plan to get other cloud native certifications from the CNCF?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;I am planning to complete all cloud native certifications from the CNCF.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;I would like to complete all 10 CNCF certifications and then there will be new certifications launched soon like Kyverno, Backstage, OpenTelemetry.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;So the learning journey will continue.&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“1500”高度=“787”src=“https://www.cncf.io/ wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4.jpg&#34; alt=&#34;headshot&#34; class=&#34;wp-image-119877&#34; srcset=&#34;https://www.cncf.io/wp-content /uploads/2024/11/Kubestronaut-in-Orbit-4.jpg 1500w，https://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4-300x157.jpg 300w ，https://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4-1024x537.jpg 1024w，https://www.cncf.io/wp-content/uploads/ 2024/11/Kubestronaut-in-Orbit-4-768x403.jpg 768w，https://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4-194x102.jpg 194w， https://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4-388x204.jpg 388w，https://www.cncf.io/wp-content/uploads/2024 /11/Kubestronaut-in-Orbit-4-776x408.jpg 776w，https://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4-900x472.jpg 900w，https ://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4-381x200.jpg 381w，https://www.cncf.io/wp-content/uploads/2024/ 11/Kubestronaut-in-Orbit-4-762x400.jpg 762w，https://www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4-590x310.jpg 590w，https： //www.cncf.io/wp-content/uploads/2024/11/Kubestronaut-in-Orbit-4-1180x620.jpg 1180w&#34;sizes=&#34;(最大宽度：1500px)100vw，1500px&#34;referrerpolicy=&#34;no-推荐人&#34;&gt;&lt;/图&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;了解 Rishabh&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;本周的 Orbit Kubetronaut Rishabh Sharma 是我们第一位来自芬兰的 Kubestonaut，他是一名高级软件开发工程师，为 CapgeminiFinland Oy 管理云原生技术解决方案。他目前负责实施和管理 4G 和 5G 技术的 Kubernetes 解决方案。他感兴趣的其他主要领域包括 Java、Spring-Boot、Containerd、Linux、Istio、Linkerd、Falco、Sysdig、CoreDNS、Helm、OPA（开放策略代理）、Cilium、Envoy 等。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果您想成为像 Rishabh 一样的 Kubestronaut，请在 &lt;a href=&#34;https://www.cncf.io/training/kubestronaut/&#34;&gt;CNCF Kubestronaut&lt;/a&gt; 页面获取更多详细信息。&lt; /p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;您什么时候开始使用 Kubernetes 和/或云原生？您的第一个项目是什么？&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;2017 年初，我参加了印度钦奈的 DevOps 训练营。在 7 天的训练营中，我对 GCE VM、Docker 和 Kubernetes 进行了高水平的探索。这是我探索 Kubernetes 的触发点。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我在 Kubernetes 中的第一个主要项目是一个电信网络规划应用程序，它作为 StatefulSet/Deployment Pod 部署在 Kubernetes 集群上。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;当我们部署为 Kubernetes 工作负载的网络规划应用程序从未出现过一秒钟的停机时，我看到了真正的 Kubernetes 魔力。我们使用了多区域设置——两个不同区域中的两个 k8s 集群。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;您现在从事或使用的主要 CNCF 项目是什么？  在您的职业生涯中您最喜欢哪些项目？&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我今天使用以下 CNCF 项目：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;1. &lt;a href=&#34;https://www.cncf.io/projects/kubernetes/&#34;&gt;Kubernetes&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;2. &lt;a href=&#34;https://www.cncf.io/projects/cilium/&#34;&gt;Cilium&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;3. &lt;a href=&#34;https://www.cncf.io/projects/containerd/&#34;&gt;Containerd&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;4. &lt;a href=&#34;https://www.cncf.io/projects/coredns/&#34;&gt;CoreDNS&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;5. &lt;a href=&#34;https://www.cncf.io/projects/fluentd/&#34;&gt;Fluentd&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;6. &lt;a href=&#34;https://www.cncf.io/projects/prometheus/&#34;&gt;普罗米修斯&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;7. &lt;a href=&#34;https://www.cncf.io/projects/etcd/&#34;&gt;Etcd&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;8. &lt;a href=&#34;https://www.cncf.io/projects/helm/&#34;&gt;头盔&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;9. &lt;a href=&#34;https://www.cncf.io/projects/kyverno/&#34;&gt;Kyverno&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;10。 &lt;a href=&#34;https://www.cncf.io/projects/istio/&#34;&gt;Istio&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;11。 &lt;a href=&#34;https://www.cncf.io/projects/falco/&#34;&gt;Falco&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;12. &lt;a href=&#34;https://www.cncf.io/projects/open-policy-agent-opa/&#34;&gt;开放策略代理 (OPA)&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我非常喜欢 Kubernetes 项目，因为我是一名电信人员，并且我看到了 Kubernetes 如何实际支持电信新一代技术 - 4G 和 5G 等。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Kubernetes 灵活的架构和强大的云原生管理功能使电信公司能够快速开发新功能，同时保持性能和可靠性。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;由于以下原因，这些项目也很受欢迎：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol类=“wp-block-list”&gt;&#xA;&lt;li&gt;Prometheus：真正令人惊叹的项目，是监控云原生工作负载的必备应用程序。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Helm：最著名的 Kubernetes 包管理器。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Cilium：最著名的 CNI 网络插件。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Istio：我最喜欢的服务网格。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Kyverno：（K 代表 Kubernetes，K 代表 Kyverno），只需将您的策略​​编写为 yaml，无需学习任何其他语言来开发策略，&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;containerd：容器运行时接口，以其可扩展性、性能和稳定性而闻名。 &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;证书或 CNCF 对您的职业生涯有何帮助？ &lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我已完成以下 6 项 CNCF 认证：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol类=“wp-block-list”&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/training/certification/kcna/&#34;&gt;Kubernetes 和 Cloud Native Associate (KCNA)&lt;/a&gt;：第一个证书让我有信心参加 CNCF 考试并对我介绍了很多云原生技术。这激励我获得进一步的认证。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/training/certification/ckad/&#34;&gt;认证 Kubernetes 应用程序开发人员 (CKAD)&lt;/a&gt;：为了准备此证书，我阅读了整个 &lt;a href=&#34;http://k8s.io/docs/concepts&#34;&gt;k8s.io/docs/concepts &lt;/a&gt;部分并逐行研究了每个概念。我还参加了 Killercoda K8s 免费实验室，然后尝试练习 Kubernetes 概念。 &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/training/certification/cka/&#34;&gt;经过认证的 Kubernetes 管理员 (CKA&lt;/a&gt;)：我获得此证书的重点是从管理端 – Kubeadm 集群设置、etcd 备份、TLS、mTLS 自签名证书。探索这些概念并将其运用到我的日常工作中是一次美妙的旅程。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/training/certification/cks/&#34;&gt;认证 Kubernetes 安全专家 (CKS)&lt;/a&gt;：安全性是任何行业的关键，CKS 实际上激励了我为了获得培训，我需要将“Sec”添加到我的工作资料中并成为“DevSecOps”。 Falco、sysdig、供应链安全、CIS 标准、Kube-bench 和更多安全工具也是关键。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/training/certification/kcsa/&#34;&gt;Kubernetes 和云安全助理 (KCSA)&lt;/a&gt;：这提供了有关 Kubernetes 和安全性以及流程的基础知识获得此证书是探索安全基础知识和标准的一次美妙经历。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/training/certification/pca/&#34;&gt;Prometheus Certified Associate (PCA)&lt;/a&gt;：我最近破解了 Prometheus Certified Associate。 Prometheus 真正帮助我们监控电信云原生工作负载，以确保其运行状况，并在出现问题时发出警报。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;您为想要使用 k8s 的人推荐了哪些其他书籍/网站/课程？&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;说实话，学习 Kubernetes 的唯一“书”是来源：&lt;a href=&#34;https://kubernetes.io/docs/concepts&#34;&gt;https://kubernetes.io/docs/concepts&lt; /a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;您应该仔细阅读文档并使用免费的 Kubernetes 集群进行练习，例如在 Killercoda 上。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;除了官方文档之外，如果您想通过课程学习，我建议您选择以下课程：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://kodekloud.com/learning-path/cka&#34;&gt;CKA&lt;/a&gt; 和 &lt;a href=&#34;https://kodekloud.com/learning-path/ckad&#34;&gt;CKAD &lt;/a&gt; 来自 KodeKloud 和 &lt;a href=&#34;https://business.udemy.com/cncf-endorsed-content/&#34;&gt;Udemy &lt;/a&gt; 的课程（查看 CNCF 认可的内容）。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=d9xfB5qaOfg&#34;&gt;CKS 课程&lt;/a&gt;，由 Kim Wuestkamp 通过 Killer Shell YouTube 频道提供。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;如需练习，请使用&lt;a href=&#34;https://killer.sh/&#34;&gt;Killer Shell 问题实验室&lt;/a&gt;（购买考试后完全免费）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;你空闲时间做什么？&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我在空闲时间喜欢这些事情：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol类=“wp-block-list”&gt;&#xA;&lt;li&gt;探索 Kubernetes：它就像海洋一样​​无底，我总是在学习新概念。  Pod 拓扑扩展约束等一些概念并不是任何 k8s 考试的一部分，但这些概念以及调度框架、Pod 优先级和抢占等其他功能确实是神奇的概念。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;探索其他 CNCF 项目：目前通过制定实时策略并部署它们来学习 Kyverno，以了解真正的准入控制器魔力。 &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;准备其他 CNCF 认证：现在我已经获得了 PCA，我的下一个目标是 &lt;a href=&#34;https://www.cncf.io/training/certification/cca/&#34;&gt;CCA (Cilium认证工程师）&lt;/a&gt; 和 &lt;a href=&#34;https://www.cncf.io/training/certification/ica/&#34;&gt;ICA（Istio 认证工程师）&lt;/a&gt;。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;为各种 CNCF 活动做出贡献：我喜欢参加其他 CNCF 活动，并且还在媒体和其他平台上发布我有关 CNCF 技术的知识。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;观看犯罪惊悚片 我喜欢在空闲时间观看犯罪惊悚片。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;您会对刚刚开始 K8s 认证之旅的人说些什么？有什么提示或技巧吗？&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;只需浏览 Kubernetes 文档，然后在 Killer shell 等免费平台上练习、练习、练习。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;亲自了解 Kubernetes 概念。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;如今，云原生生态系统的意义远不止 Kubernetes。您是否计划获得 CNCF 的其他云原生认证？&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我计划完成 CNCF 的所有云原生认证。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我想完成所有 10 个 CNCF 认证，然后很快就会推出新的认证，例如 Kyverno、Backstage、OpenTelemetry。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;所以学习之旅还将继续。&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Mon, 04 Nov 2024 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【LitmusChaos is joining KubeCon + CloudNativeCon North America 2024!】LitmusChaos 即将加入 KubeCon + CloudNativeCon North America 2024！</title>
      <link>https://www.cncf.io/blog/2024/11/06/litmuschaos-is-joining-kubecon-cloudnativecon-north-america-2024/</link>
      <description>【&lt;p&gt;&lt;em&gt;Project post originally on the &lt;a href=&#34;https://litmuschaos.io/blog/litmuschaos-is-joining-kubecon-cloudnativecon-north-america-2024-3blg&#34;&gt;Litmus blog&lt;/a&gt; by Sayan Mondal, Community Manager and Maintainer&amp;nbsp;&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full is-resized&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;2400&#34; height=&#34;700&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2024/11/s752lulge3etcjshg93t.jpg&#34; alt=&#34;image&#34; class=&#34;wp-image-119930&#34; style=&#34;width:900px;height:auto&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2024/11/s752lulge3etcjshg93t.jpg 2400w, https://www.cncf.io/wp-content/uploads/2024/11/s752lulge3etcjshg93t-300x88.jpg 300w, https://www.cncf.io/wp-content/uploads/2024/11/s752lulge3etcjshg93t-1024x299.jpg 1024w, https://www.cncf.io/wp-content/uploads/2024/11/s752lulge3etcjshg93t-768x224.jpg 768w, https://www.cncf.io/wp-content/uploads/2024/11/s752lulge3etcjshg93t-900x263.jpg 900w, https://www.cncf.io/wp-content/uploads/2024/11/s752lulge3etcjshg93t-1800x525.jpg 1800w, https://www.cncf.io/wp-content/uploads/2024/11/s752lulge3etcjshg93t-600x175.jpg 600w, https://www.cncf.io/wp-content/uploads/2024/11/s752lulge3etcjshg93t-1200x350.jpg 1200w&#34; sizes=&#34;(max-width: 2400px) 100vw, 2400px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Hello LitmusChaos Community! &lt;/strong&gt;👋&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Over the past few years, LitmusChaos has evolved tremendously, becoming a leading open-source tool for Chaos Engineering within the Cloud Native ecosystem. It’s been inspiring to watch our community grow, from engineers just getting started with chaos testing to large teams running complex fault scenarios across cloud and on-prem environments.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;On behalf of the maintainers&lt;/strong&gt;, we’re deeply grateful for the energy and passion each of you brings to the project. Your contributions, ideas, and feedback have fueled LitmusChaos’ growth and helped tackle real-world resilience challenges in a collaborative, open-source environment. Whether it’s through insightful discussions in our Slack channels, pull requests on GitHub, or your experiences shared at events, it’s clear we’re building something special—together!&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Our maintainers and contributors will be on-site, eager to meet with attendees, discuss how&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;to get started with LitmusChaos, answer questions, and share opportunities to contribute to the project. We invite you to stop by, say hello, and learn more about how chaos engineering is transforming modern cloud-native applications.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1240&#34; height=&#34;1073&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2024/11/team.jpeg&#34; alt=&#34;Image&#34; class=&#34;wp-image-119931&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2024/11/team.jpeg 1240w, https://www.cncf.io/wp-content/uploads/2024/11/team-300x260.jpeg 300w, https://www.cncf.io/wp-content/uploads/2024/11/team-1024x886.jpeg 1024w, https://www.cncf.io/wp-content/uploads/2024/11/team-768x665.jpeg 768w, https://www.cncf.io/wp-content/uploads/2024/11/team-900x779.jpeg 900w, https://www.cncf.io/wp-content/uploads/2024/11/team-231x200.jpeg 231w, https://www.cncf.io/wp-content/uploads/2024/11/team-462x400.jpeg 462w&#34; sizes=&#34;(max-width: 1240px) 100vw, 1240px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Where to Find Us: &lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Project Pavilion Kiosk #16A&amp;nbsp;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Location&lt;/strong&gt;: Level 1 | Halls A-C + 1-5 | Project Pavilion (Hall 1), Kiosk #16A &lt;strong&gt;Shift&lt;/strong&gt;: Half-shift AM schedule&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Project Pavilion Hours&lt;/strong&gt;:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Wednesday, November 13: 10:45 AM – 3:15 PM&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Thursday, November 14: 10:30 AM – 1:45 PM&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Friday, November 15: 10:30 AM – 12:30 PM&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Our team will be at the &lt;strong&gt;Project Pavilion &lt;/strong&gt;ready to talk chaos engineering, share resources, and hand out some awesome LitmusChaos stickers, candies and more. No matter your experience level—whether you’re an expert or just beginning to explore chaos engineering—this is the perfect opportunity to get personalized guidance and learn best practices for using LitmusChaos.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;2330&#34; height=&#34;993&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2024/11/comp.jpg&#34; alt=&#34;Image &#34; class=&#34;wp-image-119932&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2024/11/comp.jpg 2330w, https://www.cncf.io/wp-content/uploads/2024/11/comp-300x128.jpg 300w, https://www.cncf.io/wp-content/uploads/2024/11/comp-1024x436.jpg 1024w, https://www.cncf.io/wp-content/uploads/2024/11/comp-768x327.jpg 768w, https://www.cncf.io/wp-content/uploads/2024/11/comp-900x384.jpg 900w, https://www.cncf.io/wp-content/uploads/2024/11/comp-1800x767.jpg 1800w, https://www.cncf.io/wp-content/uploads/2024/11/comp-469x200.jpg 469w, https://www.cncf.io/wp-content/uploads/2024/11/comp-939x400.jpg 939w&#34; sizes=&#34;(max-width: 2330px) 100vw, 2330px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Project Engagement Opportunities at KubeCon NA&amp;nbsp;&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;There are plenty of ways to connect with us beyond our kiosk! Here’s where you can find us around the venue:&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;Project Pavilion Lounge&lt;/strong&gt;: Located in the heart of the Pavilion, the Lounge is a welcoming spot to relax, network, and have insightful discussions with other community members in a casual setting.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Coffee Stations&lt;/strong&gt;: Fuel up and chat with us at the coffee stations on both sides of the Pavilion. Grab a coffee, and let’s discuss your ideas for chaos engineering! &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Ad-Hoc Meeting Tables&lt;/strong&gt;: Need more time to dive deeper into LitmusChaos? Ad-hoc meeting tables are available next to the Project Pavilion on a first-come, first-served basis, offering a chance for impromptu discussions.&amp;nbsp;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;If you’d like to set up a specific time to meet with us, please feel free to email &lt;strong&gt;matthew.schillerstrom@harness.io &lt;/strong&gt;or &lt;strong&gt;sayan.mondal@harness.io&lt;/strong&gt;—we’d love to connect at KubeCon NA 2024!&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;What You Can Learn at the LitmusChaos Booth&amp;nbsp;&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Our booth offers a hands-on opportunity to dive into chaos engineering, ask questions, and explore the latest developments in LitmusChaos. Here are some highlights:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Getting Started with Chaos Engineering&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Introduction to LitmusChaos: First Steps &amp;amp; Best Practices&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Adopting Chaos Engineering at Scale&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Solving Challenges &amp;amp; Troubleshooting with LitmusChaos&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Latest Updates and Enhancements in LitmusChaos&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Roadmap for LitmusChaos&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;How to Get Involved as a Contributor or Future Maintainer&amp;nbsp;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Whether you’re facing blockers, looking for experiment guidance, or curious about the project roadmap, our team is here to help you make the most of chaos engineering with LitmusChaos.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Connect with LitmusChaos Year-Round&lt;/strong&gt;&lt;strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Can’t make it to KubeCon NA? You can still stay connected with the LitmusChaos community:&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;Website&lt;/strong&gt;: Visit the LitmusChaos Website for the latest resources.&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Slack&lt;/strong&gt;: Join the conversation on &lt;strong&gt;#litmus &lt;/strong&gt;in the Kubernetes Slack to learn, ask questions, and contribute.&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Contributing Guide&lt;/strong&gt;: Get started as a contributor by checking out our Contributing Guide.&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;YouTube&lt;/strong&gt;: Subscribe to the LitmusChaos YouTube Channel for the latest demos and tutorials.&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Twitter&lt;/strong&gt;: Stay updated by following @LitmusChaos on Twitter.&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;LinkedIn&lt;/strong&gt;: Connect with @litmuschaos on LinkedIn for latest updates.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;DEV.to&lt;/strong&gt;: Share your insights on DEV.to with #litmuschaos, or check out community-written blogs to learn from other contributors.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;p&gt;&lt;em&gt;项目帖子最初发表在 &lt;a href=&#34;https://litmuschaos.io/blog/litmuschaos-is-joining-kubecon-cloudnativecon-north-america-2024-3blg&#34;&gt;Litmus 博客&lt;/a &gt; 作者：Sayan Mondal，社区经理兼维护者&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full is-resized&#34;&gt;&lt;imgloading=&#34;lazy&#34;decoding=&#34;async&#34;width=&#34;2400&#34;height=&#34;700&#34;src=&#34;https://www.cncf .io/wp-content/uploads/2024/11/s752lulge3etcjshg93t.jpg&#34; alt=&#34;image&#34; class=&#34;wp-image-119930&#34; style=&#34;width:900px;height:auto&#34; srcset=&#34;https://www .cncf.io/wp-content/uploads/2024/11/s752lulge3etcjshg93t.jpg 2400w，https://www.cncf.io/wp-content/uploads/2024/11/s752lulge3etcjshg93t-300x88.jpg 300w，https:// /www.cncf.io/wp-content/uploads/2024/11/s752lulge3etcjshg93t-1024x299.jpg 1024w，https://www.cncf.io/wp-content/uploads/2024/11/s752lulge3etcjshg93t-768x224.jpg 768w ，https://www.cncf.io/wp-content/uploads/2024/11/s752lulge3etcjshg93t-900x263.jpg 900w，https://www.cncf.io/wp-content/uploads/2024/11/s752lulge3etcjshg93t- 1800x525.jpg 1800w，https://www.cncf.io/wp-content/uploads/2024/11/s752lulge3etcjshg93t-600x175.jpg 600w，https://www.cncf.io/wp-content/uploads/2024/ 11/s752lulge3etcjshg93t-1200x350.jpg 1200w“尺寸=”（最大宽度：2400px）100vw，2400px“referrerpolicy=”no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;LitmusChaos 社区您好！ &lt;/strong&gt;👋&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在过去的几年里，LitmusChaos 取得了巨大的发展，成为云原生生态系统中领先的混沌工程开源工具。看到我们的社区不断发展，从刚刚开始混沌测试的工程师到跨云和本地环境运行复杂故障场景的大型团队，这真是令人鼓舞。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;代表维护者&lt;/strong&gt;，我们对你们每个人为该项目带来的活力和热情深表感谢。您的贡献、想法和反馈推动了 LitmusChaos 的发展，并帮助在协作、开源环境中解决现实世界的弹性挑战。无论是通过 Slack 频道中富有洞察力的讨论、GitHub 上的拉取请求，还是您在活动中分享的经验，很明显，我们正在共同打造一些特别的东西！ &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我们的维护者和贡献者将在现场，渴望与与会者会面，讨论如何进行&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;开始使用 LitmusChaos、回答问题并分享为项目做出贡献的机会。我们邀请您过来打个招呼，并详细了解混沌工程如何改变现代云原生应用程序。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“1240”高度=“1073”src=“https://www.cncf.io/ wp-content/uploads/2024/11/team.jpeg&#34; alt=&#34;图像&#34; class=&#34;wp-image-119931&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2024/11 /team.jpeg 1240w，https://www.cncf.io/wp-content/uploads/2024/11/team-300x260.jpeg 300w，https://www.cncf.io/wp-content/uploads/2024 /11/team-1024x886.jpeg 1024w，https://www.cncf.io/wp-content/uploads/2024/11/team-768x665.jpeg 768w，https://www.cncf.io/wp-content/uploads/2024/11/team -900x779.jpeg 900w, https://www.cncf.io/wp-content/uploads/2024/11/team-231x200.jpeg 231w，https://www.cncf.io/wp-content/uploads/2024/11/team-462x400 .jpeg 462w“尺寸=”（最大宽度：1240px）100vw，1240px“ referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;在哪里找到我们：&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;项目展馆信息亭#16A&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;位置&lt;/strong&gt;：1 级 | A-C 展厅 + 1-5 |项目展馆（1 号馆），Kiosk #16A &lt;strong&gt;轮班&lt;/strong&gt;：上午半班时间表&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;项目展馆开放时间&lt;/strong&gt;：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;11 月 13 日星期三：上午 10:45 至下午 3:15 &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;11 月 14 日星期四：上午 10:30 至下午 1:45 &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;11 月 15 日星期五：上午 10:30 至中午 12:30&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我们的团队将在&lt;strong&gt;项目展馆&lt;/strong&gt;准备讨论混沌工程、共享资源，并分发一些很棒的 LitmusChaos 贴纸、糖果等。无论您的经验水平如何，无论您是专家还是刚刚开始探索混沌工程，这都是获得个性化指导和学习使用 LitmusChaos 的最佳实践的绝佳机会。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“2330”高度=“993”src=“https://www.cncf.io/ wp-content/uploads/2024/11/comp.jpg&#34; alt=&#34;图像&#34; class=&#34;wp-image-119932&#34; srcset =“https://www.cncf.io/wp-content/uploads/2024/11/comp.jpg 2330w，https://www.cncf.io/wp-content/uploads/2024/11/comp- 300x128.jpg 300w, https://www.cncf.io/wp-content/uploads/2024/11/comp-1024x436.jpg 1024w，https://www.cncf.io/wp-content/uploads/2024/11/comp-768x327 .jpg 768w, https://www.cncf.io/wp-content/uploads/2024/11/comp-900x384.jpg 900w，https://www.cncf.io/wp-content/uploads/2024/11/comp-1800x767 .jpg 1800w, https://www.cncf.io/wp-content/uploads/2024/11/comp-469x200.jpg 469w，https://www.cncf.io/wp-content/uploads/2024/11/comp-939x400 .jpg 939w“尺寸=”（最大宽度：2330px）100vw，2330px“ referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;KubeCon NA 的项目参与机会&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;除了我们的信息亭之外，还有很多方式可以与我们联系！您可以在会场周围找到我们：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;Project Pavilion 休息室&lt;/strong&gt;：休息室位于 Pavilion 中心，是一个放松身心、建立联系并在休闲环境中与其他社区成员进行深入讨论的好去处。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;咖啡站&lt;/strong&gt;：在展馆两侧的咖啡站补充能量并与我们聊天。喝杯咖啡，让我们讨论一下您对混沌工程的想法！ &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;临时会议桌&lt;/strong&gt;：需要更多时间深入了解 LitmusChaos？接下来可使用临时会议桌以先到先得的方式前往项目展馆，提供即兴讨论的机会。 &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果您想安排与我们会面的具体时间，请随时发送电子邮件至&lt;strong&gt;ma​​tthew.schillerstrom@harness.io&lt;/strong&gt;或&lt;strong&gt;sayan.mondal@harness.io&lt; /strong&gt;—我们很乐意在 KubeCon NA 2024 上进行交流！ &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;您可以在 LitmusChaos 展位学到什么&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我们的展位提供了深入研究混沌工程、提出问题和探索 LitmusChaos 最新发展的实践机会。以下是一些亮点：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;混沌工程入门&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;LitmusChaos 简介：第一步和最佳实践&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;大规模采用混沌工程&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;使用 LitmusChaos 解决挑战并排除故障&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;LitmusChaos 的最新更新和增强功能&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;LitmusChaos 路线图&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;如何作为贡献者或未来维护者参与进来&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;无论您是面临阻碍、寻求实验指导，还是对项目路线图感到好奇，我们的团队都会随时帮助您利用 LitmusChaos 充分利用混沌工程。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;全年与 LitmusChaos 保持联系&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;无法参加 KubeCon NA？您仍然可以与 LitmusChaos 社区保持联系：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;网站&lt;/strong&gt;：访问 LitmusChaos 网站以获取最新资源。 &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Slack&lt;/strong&gt;：加入 Kubernetes Slack 中 &lt;strong&gt;#litmus&lt;/strong&gt; 上的对话来学习、提出问题和做出贡献。 &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;贡献指南&lt;/strong&gt;：查看我们的贡献指南，开始作为贡献者。 &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;YouTube&lt;/strong&gt;：订阅 LitmusChaos YouTube 频道以获取最新的演示和教程。 &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Twitter&lt;/strong&gt;：在 Twitter 上关注@LitmusChaos，随时了解最新动态。 &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;LinkedIn&lt;/strong&gt;：与 LinkedIn 上的@litmuschaos 联系以获取最新动态。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;DEV.to&lt;/strong&gt;：与 #litmuschaos 分享您对 DEV.to 的见解，或查看社区撰写的博客向其他贡献者学习。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Tue, 05 Nov 2024 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Why Falco’s new response engine is a game changer for open source cloud native security】为什么 Falco 的新响应引擎会改变开源云原生安全的游戏规则</title>
      <link>https://www.cncf.io/blog/2024/11/06/why-falcos-new-response-engine-is-a-game-changer-for-open-source-cloud-native-security/</link>
      <description>【&lt;p&gt;&lt;em&gt;Project post by the Falco Team and Nigel Douglas&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Falco achieved &lt;a href=&#34;https://www.cncf.io/announcements/2024/02/29/cloud-native-computing-foundation-announces-falco-graduation/&#34;&gt;&lt;strong&gt;CNCF Graduation status&lt;/strong&gt;&lt;/a&gt; on February 29, 2024. Following the celebration of this significant milestone at&amp;nbsp; KubeCon EU in Paris earlier this year, the project has seen several major highlight-worthy updates.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The Falco community’s recent development efforts have focused on enhancing performance and stability to deliver the best possible user experience for Falco adopters. Notable improvements include the integration of a new endpoint for exposing metrics in Prometheus format, automatic selection of the optimal driver for your system, a new collector that enriches captures with Kubernetes metadata, and many other exciting features.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Here are the key highlights:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Falco Talon&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://falco.org/blog/falco-talon-v0-1-0/&#34;&gt;&lt;strong&gt;Falco Talon&lt;/strong&gt;&lt;/a&gt; is officially part of the &lt;a href=&#34;https://github.com/falcosecurity/falco-talon&#34;&gt;&lt;strong&gt;falcosecurity&lt;/strong&gt;&lt;/a&gt; project in Github. Searching for Falco Talon in Helm, you can see it now officially starting off on version 0.1.1. So what is Falco Talon? It’s a dedicated response engine for Falco. Response actions are linked to Falco rules, so when a detection rule is triggered, any of the listed “&lt;a href=&#34;https://docs.falco-talon.org/docs/actionners/list/&#34;&gt;&lt;strong&gt;actionners&lt;/strong&gt;&lt;/a&gt;” can be triggered in response to that unwanted behavior.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;helm search repo falcosecurity/falco-talon&#xA;NAME                     CHART      APP VERSIONDESCRIPTION                   &#xA;falcosecurity/falco-talon0.1.1        0.1.1      React to the events from Falco&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Rethinking how organizations should respond to threats in cloud-native architectures, Talon provides an industry-first, &lt;a href=&#34;https://dzone.com/articles/rethinking-threat-detection-and-response-in-cloud&#34;&gt;&lt;strong&gt;API-driven approach&lt;/strong&gt;&lt;/a&gt; to threat mitigation directly via existing API primitives like &lt;a href=&#34;https://docs.falco-talon.org/docs/actionners/list/#ciliumnetworkpolicy&#34;&gt;&lt;strong&gt;networkpolicy&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&#34;https://docs.falco-talon.org/docs/actionners/list/#kuberneteslabel&#34;&gt;&lt;strong&gt;label&lt;/strong&gt;&lt;/a&gt; enforcement. and graceful &lt;a href=&#34;https://docs.falco-talon.org/docs/actionners/list/#kubernetesterminate&#34;&gt;&lt;strong&gt;termination&lt;/strong&gt;&lt;/a&gt;. This is a no-code implementation for threat isolation. Assign Falco rules to Falco actions in YAML, and let the automated API responses work their magic. This is the fastest, most efficient, and most reliable approach in today’s rapidly evolving Kubernetes and Cloud environments.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;New regex operator&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The new Regular Expression (RegEx) operator allows you to match patterns in string fields using the &lt;a href=&#34;https://github.com/google/re2/wiki/Syntax&#34;&gt;&lt;strong&gt;Google RE2&lt;/strong&gt;&lt;/a&gt; library. While powerful, it’s important to note that the regex operator is significantly slower — potentially up to ten times slower — than other string comparison operators, which are recommended for simpler cases. For example, to detect certain patterns in file descriptors, you could use the following: &lt;code&gt;fd.name regex [a-z]*/proc/[0-9]+/cmdline&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;It is important that users are mindful of performance impacts when opting for regex over simpler string operations.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;New Integrations and Sources&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Our community has once again played a vital role in expanding Falco’s capabilities by integrating new alerting targets, including Dynatrace, Sumo Logic, OpenTelemetry Traces, and Quickwit. These integrations provide more flexibility in how users receive and analyze security alerts, allowing Falco to seamlessly connect with existing ecosystem tools.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Additionally, Falco can now collect Kubernetes audit logs from Google Kubernetes Engine (&lt;a href=&#34;https://cloud.google.com/blog/products/identity-security/wrangle-your-alerts-with-open-source-falco-and-the-gcpaudit-plugin&#34;&gt;&lt;strong&gt;GKE&lt;/strong&gt;&lt;/a&gt;) and logs from &lt;a href=&#34;https://github.com/gnosek/falco-journald-plugin&#34;&gt;&lt;strong&gt;journald&lt;/strong&gt;&lt;/a&gt;, providing deeper visibility into cluster activities and system-level events. New data sources, such as &lt;a href=&#34;https://github.com/falcosecurity/plugins/tree/main/plugins/kafka&#34;&gt;&lt;strong&gt;Kafka&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&#34;https://github.com/mattiaforc/falco-keycloak-plugin&#34;&gt;&lt;strong&gt;Keycloak&lt;/strong&gt;&lt;/a&gt;, have also been added, broadening the scope of environments which Falco can collect events from. These enhancements further empower teams to detect threats and monitor compliance across a wider range of architectures.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Field transformers and value comparison in conditions&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This applies to the following transform operators:&lt;code&gt; toupper, tolower, b64&lt;/code&gt;, and &lt;code&gt;basename&lt;/code&gt;. Previously, it was not possible to write conditions that compared a field to another field, such as detecting when “a process deletes its own executable.” This limitation existed because field values couldn’t be used on the right-hand side of conditions. However, in this version, we’ve introduced the val() operator, which solves this issue.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;evt.type = unlink and proc.exepath = val(fs.path.name)&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This rule will only trigger if the process’s executable path (&lt;code&gt;proc.exepath&lt;/code&gt;) matches the unlink target (&lt;code&gt;fs.path.name&lt;/code&gt;), effectively detecting when a process attempts to delete its own executable. Additionally, you can apply simple transformation operators to both sides of the comparison:&lt;code&gt; toupper()&lt;/code&gt; and &lt;code&gt;tolower()&lt;/code&gt; convert the case of strings, while b64() decodes base64-encoded strings.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Stay tuned as more transformers will be introduced to support additional use cases! For more details, check the documentation on transform operators.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Automatic driver selection&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Deploying across diverse Kubernetes environments just got easier! When using the official Falco Helm chart and setting &lt;code&gt;driver.kind=auto&lt;/code&gt;, the driver loader now intelligently handles the heavy lifting for you.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Here’s how it works: the driver loader will automatically generate a new Falco configuration file and select the correct engine driver based on the specific node Falco is deployed on. This means whether you’re using eBPF, kmod, or a modern eBPF driver, Falco will configure itself dynamically depending on the environment.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In many Kubernetes clusters, nodes can differ in terms of kernel versions, capabilities, and driver compatibility. With this new auto-selection feature, you can seamlessly deploy different Falco drivers across various nodes within the same cluster.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This setup gives you flexibility and ensures that each node in your Kubernetes cluster is running Falco in the most optimized way possible, without manual configuration. Simply set driver.kind=auto in the Helm chart and let Falco do the rest.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Built-in Prometheus metrics&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;If you have been following Falco development, you probably know we are constantly improving support for metrics that tell you how the Falco engine is doing. We now have introduced &lt;a href=&#34;https://falco.org/docs/metrics/falco-metrics/#prometheus-support&#34;&gt;&lt;strong&gt;Prometheus support&lt;/strong&gt;&lt;/a&gt; so you can better integrate Falco with your existing performance monitoring infrastructure and paves the way for the community to create an official Grafana dashboard that can be integrated into users’ charts. We integrated the new endpoint to expose a lot of useful metrics in the Prometheus format, which allows for the out-of-the-box Grafana dashboard creation.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Plugins Rust SDK&amp;nbsp;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The &lt;a href=&#34;https://gnosek.github.io/falco-plugin-rs/falco_plugin/index.html&#34;&gt;&lt;strong&gt;Falco Plugin Rust SDK&lt;/strong&gt;&lt;/a&gt; is a newly developed toolkit designed to allow developers to build Falco plugins using the Rust programming language. Rust, known for its focus on safety, performance, and efficiency, is a natural fit for building high-quality plugins that interact with the Falco ecosystem.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This SDK provides a robust framework for creating Falco plugins, offering flexibility for different plugin types. Developers can create both dynamically and statically linked plugins:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;Dynamically linked plugins&lt;/strong&gt;: Built as shared libraries using &lt;code&gt;crate_type = [&#34;dylib&#34;]&lt;/code&gt;, these plugins leverage macros like plugin! to enable various plugin capabilities.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Statically linked plugins&lt;/strong&gt;: Created using &lt;code&gt;crate_type = [&#34;staticlib&#34;],&lt;/code&gt; these plugins use the &lt;code&gt;static_plugin&lt;/code&gt;! macro without needing to manage individual capabilities.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The SDK simplifies plugin development and extends Falco’s functionality, while opening doors for Rust developers to contribute and innovate within the Falco community.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Falco Growth&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;To close where we began, Falco has seen a boom in growth and usage since achieving CNCF graduation earlier this year. In total, Falco has now been downloaded 130M times, but that’s not all.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;When users deploy Falco with its default configuration, Falco checks for community rule updates four times per day. We can derive how many Falco instances run daily using rules download stats &lt;a href=&#34;https://github.com/falcosecurity/rules/pkgs/container/rules%2Ffalco-rules&#34;&gt;&lt;strong&gt;from GitHub&lt;/strong&gt;&lt;/a&gt; — in the last month, we have experienced over 120M downloads for the latest ruleset version. In short, Falco currently monitors around 1M active nodes daily using the latest ruleset and subscribed to the community rules feed. This is in addition to many millions more running previous versions.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Thank you for your continued support of the Falco project. We hope to see you at &lt;a href=&#34;https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/&#34;&gt;KubeCon + CloudNativeCon North America&lt;/a&gt; in Salt Lake City!&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;p&gt;&lt;em&gt;Falco 团队和 Nigel Douglas 发布的项目帖子&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Falco 取得&lt;a href=&#34;https://www.cncf.io/announcements/2024/02/29/cloud-native-computing-foundation-announces-falco-graduation/&#34;&gt;&lt;strong&gt;CNCF 毕业状态&lt;/strong&gt;&lt;/a&gt; 于 2024 年 2 月 29 日举行。继今年早些时候在巴黎 KubeCon EU 庆祝这一重要里程碑之后，该项目出现了几项值得关注的重大更新。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Falco 社区最近的开发工作侧重于增强性能和稳定性，以便为 Falco 采用者提供最佳的用户体验。显着的改进包括集成用于以 Prometheus 格式公开指标的新端点、自动选择适合您系统的最佳驱动程序、使用 Kubernetes 元数据丰富捕获的新收集器以及许多其他令人兴奋的功能。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;以下是主要亮点：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;隼爪&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://falco.org/blog/falco-talon-v0-1-0/&#34;&gt;&lt;strong&gt;Falco Talon&lt;/strong&gt;&lt;/a&gt; 是 &lt;a href=&#34;https://github.com/falcosecurity/falco-talon&#34;&gt;Github 中的&lt;strong&gt;falcosecurity&lt;/strong&gt;&lt;/a&gt; 项目。在Helm中搜索Falco Talon，可以看到它现在正式启动于0.1.1版本。那么Falco Talon 是什么？它是 Falco 的专用响应引擎。响应操作链接到 Falco 规则，因此当触发检测规则时，任何列出的“&lt;a href=&#34;https://docs.falco-talon.org/docs/actionners/list/&#34;&gt;&lt;strong&gt;actionners &lt;/strong&gt;&lt;/a&gt;”可以被触发以响应这种不需要的行为。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;helm 搜索仓库 falcosecurity/falco-talon&#xA;名称图表应用程序版本描述                   &#xA;falcosecurity/falco-talon0.1.1 0.1.1 对 Falco 的事件做出反应&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;重新思考组织应如何应对云原生架构中的威胁，Talon 提供了业界首创的&lt;a href=&#34;https://dzone.com/articles/rethinking-threat-detection-and-response-in- cloud&#34;&gt;&lt;strong&gt;API驱动的方法&lt;/strong&gt;&lt;/a&gt;通过现有的API原语直接缓解威胁，例如&lt;a href=&#34;https://docs.falco-talon.org/docs/actionners/list/ #ciliumnetworkpolicy&#34;&gt;&lt;strong&gt;网络策略&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&#34;https://docs.falco-talon.org/docs/actionners/list/#kuberneteslabel&#34;&gt;&lt;strong&gt;标签&lt;/强&gt;&lt;/a&gt;执行。和优雅的&lt;a href=&#34;https://docs.falco-talon.org/docs/actionners/list/#kubernetesterminate&#34;&gt;&lt;strong&gt;终止&lt;/strong&gt;&lt;/a&gt;。这是用于威胁隔离的无代码实现。在 YAML 中将 Falco 规则分配给 Falco 操作，并让自动化 API 响应发挥其魔力。在当今快速发展的 Kubernetes 和云环境中，这是最快、最高效、最可靠的方法。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;新的正则表达式运算符&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;新的正则表达式 (RegEx) 运算符允许您匹配 stri 中的模式使用 &lt;a href=&#34;https://github.com/google/re2/wiki/Syntax&#34;&gt;&lt;strong&gt;Google RE2&lt;/strong&gt;&lt;/a&gt; 库的 ng 字段。虽然功能强大，但值得注意的是，正则表达式运算符比其他字符串比较运算符要慢得多（可能慢十倍），建议将其用于更简单的情况。例如，要检测文件描述符中的某些模式，您可以使用以下命令：&lt;code&gt;fd.name regex [a-z]*/proc/[0-9]+/cmdline&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;用户在选择正则表达式而不是简单的字符串操作时要注意性能影响，这一点很重要。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;新的集成和来源&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我们的社区通过集成新的警报目标（包括 Dynatrace、Sumo Logic、OpenTelemetry Traces 和 Quickwit），在扩展 Falco 功能方面再次发挥了至关重要的作用。这些集成为用户接收和分析安全警报的方式提供了更大的灵活性，使 Falco 能够与现有的生态系统工具无缝连接。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此外，Falco 现在可以从 Google Kubernetes Engine 收集 Kubernetes 审核日志 (&lt;a href=&#34;https://cloud.google.com/blog/products/identity-security/wrangle-your-alerts-with-open- source-falco-and-the-gcpaudit-plugin&#34;&gt;&lt;strong&gt;GKE&lt;/strong&gt;&lt;/a&gt;）和来自 &lt;a href=&#34;https://github.com/gnosek/falco-journald-plugin&#34; 的日志&gt;&lt;strong&gt;日志&lt;/strong&gt;&lt;/a&gt;，提供对集群活动和系统级事件的更深入的可见性。新数据源，例如 &lt;a href=&#34;https://github.com/falcosecurity/plugins/tree/main/plugins/kafka&#34;&gt;&lt;strong&gt;Kafka&lt;/strong&gt;&lt;/a&gt; 和 &lt;a href=&#34; https://github.com/mattiaforc/falco-keycloak-plugin&#34;&gt;&lt;strong&gt;Keycloak&lt;/strong&gt;&lt;/a&gt; 也已添加，扩大了 Falco 可以收集事件的环境范围。这些增强功能进一步使团队能够检测威胁并监控更广泛架构的合规性。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;现场变压器和条件下的值比较&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这适用于以下转换运算符：&lt;code&gt; toupper、tolower、b64&lt;/code&gt; 和 &lt;code&gt;basename&lt;/code&gt;。以前，无法编写将一个字段与另一个字段进行比较的条件，例如检测“进程删除其自己的可执行文件”的时间。存在此限制是因为字段值无法在条件的右侧使用。不过，在这个版本中，我们引入了 val() 运算符，解决了这个问题。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;evt.type = unlink 和 proc.exepath = val(fs.path.name)&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;仅当进程的可执行路径 (&lt;code&gt;proc.exepath&lt;/code&gt;) 与取消链接目标 (&lt;code&gt;fs.path.name&lt;/code&gt;) 匹配时才会触发此规则，从而有效检测进程何时尝试删除它自己的可执行文件。此外，您可以对比较的两边应用简单的转换运算符：&lt;code&gt; toupper()&lt;/code&gt; 和 &lt;code&gt;tolower()&lt;/code&gt; 转换字符串的大小写，而 b64() 解码 Base64 编码的字符串。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;敬请关注，我们将引入更多变压器来支持其他用例！有关更多详细信息，请查看有关转换运算符的文档。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;自动选择驱动程序&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;跨不同 Kubernetes 环境进行部署变得更加容易！当使用官方 Falco Helm 图表并设置 &lt;code&gt;driver.kind=auto&lt;/code&gt; 时，驱动程序加载程序现在可以智能地为您处理繁重的工作。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;其工作原理如下：驱动程序加载器将自动生成新的 Falco 配置文件，并根据部署 Falco 的特定节点选择正确的引擎驱动程序。这意味着无论您使用 eBPF、kmod 还是现代 eBPF 驱动程序，Falco 都会根据环境动态配置自身。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在许多 Kubernetes 集群中，节点在内核版本、功能和驱动程序兼容性方面可能有所不同。借助这一新的自动选择功能，您可以在同一集群内的各个节点上无缝部署不同的 Falco 驱动程序。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此设置为您提供了灵活性，并确保 Kubernetes 集群中的每个节点都以最优化的方式运行 Falco，无需手动配置。只需在 Helm 图表中设置 driver.kind=auto ，然后让 Falco 完成剩下的工作。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;内置 Prometheus 指标&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果您一直关注 Falco 的开发，您可能知道我们正在不断改进对指标的支持，这些指标可以告诉您 Falco 引擎的运行情况。我们现在引入了&lt;a href=&#34;https://falco.org/docs/metrics/falco-metrics/#prometheus-support&#34;&gt;&lt;strong&gt;Prometheus 支持&lt;/strong&gt;&lt;/a&gt;，以便您可以更好地集成 Falco与您现有的性能监控基础设施相结合，并为社区创建可集成到用户图表中的官方 Grafana 仪表板铺平道路。我们集成了新端点，以 Prometheus 格式公开许多有用的指标，从而允许创建开箱即用的 Grafana 仪表板。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;插件 Rust SDK&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://gnosek.github.io/falco-plugin-rs/falco_plugin/index.html&#34;&gt;&lt;strong&gt;Falco Plugin Rust SDK&lt;/strong&gt;&lt;/a&gt; 是一个新的开发的工具包旨在允许开发人员使用 Rust 编程语言构建 Falco 插件。 Rust 以其对安全性、性能和效率的关注而闻名，非常适合构建与 Falco 生态系统交互的高质量插件。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;该 SDK 提供了用于创建 Falco 插件的强大框架，为不同插件类型提供了灵活性。开发人员可以创建动态和静态链接的插件：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;动态链接插件&lt;/strong&gt;：使用&lt;code&gt;crate_type = [&#34;dylib&#34;]&lt;/code&gt;构建为共享库，这些插件像插件一样利用宏！启用各种插件功能。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;统计专门链接的插件&lt;/strong&gt;：使用&lt;code&gt;crate_type = [&#34;staticlib&#34;]创建，&lt;/code&gt;这些插件使用&lt;code&gt;static_plugin&lt;/code&gt;！宏观，无需管理个人能力。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;该 SDK 简化了插件开发并扩展了 Falco 的功能，同时为 Rust 开发人员在 Falco 社区中做出贡献和创新打开了大门。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Falco 成长&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;最后，自今年早些时候获得 CNCF 毕业以来，Falco 的增长和使用量出现了蓬勃发展。目前，Falco 的总下载量已达到 1.3 亿次，但这还不是全部。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;当用户使用默认配置部署 Falco 时，Falco 每天检查社区规则更新四次。我们可以使用&lt;a href=&#34;https://github.com/falcosecurity/rules/pkgs/container/rules%2Ffalco-rules&#34;&gt;&lt;strong&gt;来自 GitHub&lt;/strong&gt; 的规则下载统计信息来得出每天运行的 Falco 实例数量&lt;/a&gt; — 上个月，最新规则集版本的下载量超过 1.2 亿次。简而言之，Falco 目前每天使用最新的规则集监控大约 100 万个活跃节点，并订阅社区规则源。除此之外，还有数百万人正在运行以前的版本。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;感谢您对 Falco 项目的持续支持。我们希望在盐湖城的&lt;a href=&#34;https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/&#34;&gt;KubeCon + CloudNativeCon 北美&lt;/a&gt;见到您！&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Tue, 05 Nov 2024 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Multi-cluster PKI + Istio recipe: practical example for a trusted and scalable PKI for your service mesh】多集群 PKI + Istio 秘诀：为您的服务网格提供可信且可扩展的 PKI 的实际示例</title>
      <link>https://www.cncf.io/blog/2024/11/01/multi-cluster-pki-istio-recipe-practical-example-for-a-trusted-and-scalable-pki-for-your-service-mesh/</link>
      <description>【&lt;p&gt;&lt;em&gt;&amp;nbsp;Member post originally published on &lt;a href=&#34;https://tetrate.io/blog/multi-cluster-pki-istio-recipe-practical-example-for-a-trusted-and-scalable-pki-for-your-service-mesh/&#34;&gt;Tetrate’s blog&lt;/a&gt; by Cristofer TenEyck and Jimmy Song&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;h-introduction-nbsp&#34;&gt;Introduction&amp;nbsp;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In the evolving landscape of cloud-native applications, securing service meshes across multiple clusters is crucial for ensuring both security and compliance. Istio, a leading open-source service mesh, provides tools for securing communication between microservices. However, implementing a robust and scalable Public Key Infrastructure (PKI) to manage certificates within this environment remains a significant challenge.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In this blog, we will delve into the implementation of a PKI solution using the EJBCA open-source PKI for an Istio service mesh spanning multiple clusters. We will focus on the process of setting up EJBCA, configuring the cert-manager EJBCA external issuer, and ensuring automatic certificate renewal for your Istio workloads. This guide will help you build a trusted and scalable PKI, enabling secure, compliant, and resilient service meshes.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Why multi-clusters? Multi-cluster deployments are becoming increasingly popular as organizations expand their Kubernetes infrastructure. Multi-cluster Istio setups provide enhanced availability, fault tolerance, and isolation of workloads across clusters.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;h-understanding-pki-and-its-role-in-service-meshes-nbsp&#34;&gt;Understanding PKI and its Role in Service Meshes&amp;nbsp;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;PKI is a cornerstone of modern digital security. It involves managing keys and certificates to ensure secure communication between entities, be they users, applications, or services. In the context of a service mesh like Istio, an effective PKI is essential for securing communications between microservices, especially in multi-cluster environments.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The EJBCA offers an open-source solution for managing PKI at scale. Compared to other options like OpenSSL or Istio’s built-in PKI, EJBCA provides a full-featured, enterprise-grade PKI that is well-suited for simple to more complex and multi-purpose deployments. EJBCA’s capabilities go beyond just issuing mTLS certificates, offering compliance features, secure scalability, crypto agility, and integration with a wide range of applications.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;h-istio-ejbca-and-cert-manager-nbsp-nbsp&#34;&gt;Istio, EJBCA and cert-manager&amp;nbsp;&amp;nbsp;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Setting up a PKI for a multi-cluster Istio environment using EJBCA. Here is what is included:&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;Environment Preparation&lt;/strong&gt;: We use a MicroK8s multi-cluster Istio setup, consisting of a primary and a remote cluster. Both clusters are configured to work with EJBCA as the root Certificate Authority (CA).&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;cert-manager Integration&lt;/strong&gt;: We showcase the integration of cert-manager with EJBCA, including the configuration of the EJBCA custom issuer. cert-manager will handle the issuance and renewal of certificates.&amp;nbsp;&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Automatic Certificate Renewal&lt;/strong&gt;: A key challenge in PKI management is ensuring that certificates are renewed automatically before they expire. cert-manager, with EJBCA, can achieve seamless, application-transparent certificate renewal across all clusters.&amp;nbsp;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image&#34;&gt;&lt;a href=&#34;https://tetrate.io/wp-content/uploads/2024/09/arch.svg&#34;&gt;&lt;img decoding=&#34;async&#34; src=&#34;https://tetrate.io/wp-content/uploads/2024/09/arch.svg&#34; alt=&#34;Image&#34; class=&#34;wp-image-54748&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;h-architecture-setup-with-istio-using-ejbca-as-an-external-ca-a-high-level-summary-nbsp&#34;&gt;Architecture Setup with Istio using EJBCA as an External CA, a High-Level Summary&amp;nbsp;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This section outlines the steps to set up Istio on Kubernetes clusters using EJBCA as an external Certificate Authority (CA). The setup involves configuring two MicroK8s clusters with MetalLB for load balancing, integrating EJBCA for certificate management, and installing Istio components using Helm. the complete guide can be found&amp;nbsp;&lt;a href=&#34;https://docs.keyfactor.com/ejbca/latest/tutorial-deploy-istio-service-mesh-in-a-multi&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The key steps include:&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;Install and Configure Helm Repositories&lt;/strong&gt;: Add necessary Helm repositories for Istio, cert-manager, and EJBCA.&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Deploy cert-manager and EJBCA&lt;/strong&gt;: Install cert-manager using Helm in the primary and remote clusters, followed by the deployment of the EJBCA with a custom issuer. This step also includes generating and storing necessary certificates as Kubernetes secrets.&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Configure Istio with EJBCA&lt;/strong&gt;: Create a custom Issuer in Kubernetes that points to the EJBCA instance for issuing certificates. This issuer is then integrated into the Istio configuration.&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Install Istio Components&lt;/strong&gt;: Deploy the cert-manager-istio-csr to handle Istio’s certificate signing requests, followed by the installation of Istio’s base components, Istio CNI (Container Network Interface), Istiod (Istio control plane), and the Istio ingress gateway.&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Customization and Overrides&lt;/strong&gt;: Apply custom values to tailor Istio’s behavior, such as specific cluster IDs, trust domains, and DNS configurations for secure communication between services.&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Automatic Certificate Renewal:&lt;/strong&gt;&amp;nbsp;The setup is configured so that cert-manager automatically renews certificates before they expire, with no disruption to the running applications.&amp;nbsp;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image&#34;&gt;&lt;a href=&#34;https://tetrate.io/wp-content/uploads/2024/09/Cert-renew-flow-1024x637.png&#34;&gt;&lt;img decoding=&#34;async&#34; src=&#34;https://tetrate.io/wp-content/uploads/2024/09/Cert-renew-flow-1024x637.png&#34; alt=&#34;Image&#34; class=&#34;wp-image-54749&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Above is the flow diagram representing the mTLS certificate issuance and renewal process in Istio. It illustrates the flow from the Istiod control plane pushing the Envoy config to the final certificate issuance by EJBCA.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;h-pki-best-practices-and-compliance-nbsp&#34;&gt;PKI Best Practices and Compliance&amp;nbsp;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Building a secure PKI for your Istio service mesh involves more than just setting up any PKI and starting issuing certificates. It requires adherence to best practices and compliance with regulations to stay secure and future-proof. Here are some key points to consider:&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;Compliance with Regulations&lt;/strong&gt;: Ensure your PKI implementation meets regulatory requirements such as the EU Cyber Resilience Act and the US Executive Order on Improving the Nation’s Cybersecurity. This includes implementing a resilient architecture, maintaining audit trails, and ensuring robust key management practices.&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Crypto Agility and Quantum Readiness&lt;/strong&gt;: As cryptographic standards evolve, your PKI must be agile enough to adapt to new algorithms and key lengths. With the potential advent of quantum computing, being quantum-ready is increasingly important.&amp;nbsp;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Collaboration with InfoSec&lt;/strong&gt;: Effective collaboration with your Information Security (InfoSec) team is crucial for maintaining the security and compliance of your PKI. This includes regular reviews of security policies, ongoing training, and ensuring that PKI management processes align with organizational security goals.&amp;nbsp;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Conclusion&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Implementing a PKI for an Istio service mesh in a multi-cluster environment can seem daunting, but with the right tools and practices, it can be achieved efficiently and effectively. EJBCA, combined with cert-manager, offers a solution for managing certificates at scale, ensuring that your Istio service mesh PKI is both secure and compliant.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;By following the steps outlined in this guide, you will be able to set up a trusted PKI, achieve seamless and robust certificate management, and collaborate effectively with your InfoSec team to maintain the security of your service mesh.&amp;nbsp;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;For further resources and more detailed information on the topics covered in this blog, be sure to check out the links and references provided below.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;h-resources-nbsp&#34;&gt;Resources&amp;nbsp;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.keyfactor.com/ejbca/latest/tutorial-deploy-istio-service-mesh-in-a-multi&#34;&gt;Tutorial – Deploy Istio Service Mesh in a Multi-Cluster Kubernetes Environment Using EJBCA as an External PKI provider&lt;/a&gt;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://istio.io/latest/docs/&#34;&gt;Istio documentation&lt;/a&gt;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.ejbca.org/&#34;&gt;EJBCA Community edition&lt;/a&gt;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://cert-manager.io/docs/&#34;&gt;cert-manager documentation&lt;/a&gt;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://digital-strategy.ec.europa.eu/en/policies/cyber-resilience-act&#34;&gt;EU Cyber Resilience Act&lt;/a&gt;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.whitehouse.gov/briefing-room/statements-releases/2021/05/12/executive-order-on-improving-the-nations-cybersecurity/&#34;&gt;US Executive Order on Cybersecurity&lt;/a&gt;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://tetrate.io/blog/multicluster-istio/&#34;&gt;Seamless Cross-Cluster Connectivity for Multicluster Istio Service Mesh Deployments&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;p&gt;&lt;em&gt; 会员帖子最初发布于 &lt;a href=&#34;https://tetrate.io/blog/multi-cluster-pki-istio-recipe-practical-example-for-a-trusted-and-scalable- pki-for-your-service-mesh/&#34;&gt;Tetrate 的博客&lt;/a&gt;，作者：Cristofer TenEyck 和 Jimmy Song&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;h-introduction-nbsp&#34;&gt;简介&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在云原生应用程序不断发展的环境中，保护跨多个集群的服务网格对于确保安全性和合规性至关重要。 Istio 是领先的开源服务网格，提供用于保护微服务之间通信的工具。然而，实施强大且可扩展的公钥基础设施 (PKI) 来管理此环境中的证书仍然是一项重大挑战。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在本博客中，我们将深入研究使用 EJBCA 开源 PKI 为跨多个集群的 Istio 服务网格实现 PKI 解决方案。我们将重点关注设置 EJBCA、配置证书管理器 EJBCA 外部颁发者以及确保 Istio 工作负载自动更新证书的过程。本指南将帮助您构建可信且可扩展的 PKI，从而实现安全、合规且有弹性的服务网格。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;为什么要多集群？随着组织扩展其 Kubernetes 基础设施，多集群部署变得越来越流行。多集群 Istio 设置提供了增强的可用性、容错能力以及跨集群的工作负载隔离。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;h-understanding-pki-and-its-role-in-service-meshes-nbsp&#34;&gt;了解 PKI 及其在服务网格中的作用&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;PKI 是现代数字安全的基石。它涉及管理密钥和证书，以确保实体（无论是用户、应用程序还是服务）之间的安全通信。在像 Istio 这样的服务网格环境中，有效的 PKI 对于保护微服务之间的通信至关重要，尤其是在多集群环境中。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;EJBCA 提供了用于大规模管理 PKI 的开源解决方案。与 OpenSSL 或 Istio 的内置 PKI 等其他选项相比，EJBCA 提供功能齐全的企业级 PKI，非常适合简单到更复杂的多用途部署。 EJBCA 的功能不仅仅是颁发 mTLS 证书，还提供合规性功能、安全可扩展性、加密敏捷性以及与各种应用程序的集成。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;h-istio-ejbca-and-cert-manager-nbsp-nbsp&#34;&gt;Istio、EJBCA 和证书管理器  &lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;使用 EJBCA 为多集群 Istio 环境设置 PKI。以下是其中包含的内容：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol类=“wp-block-list”&gt;&#xA;&lt;li&gt;&lt;strong&gt;环境准备&lt;/strong&gt;：我们使用 MicroK8s 多集群 Istio 设置，由主集群和远程集群组成。两个集群都配置为使用 EJBCA 作为根证书颁发机构 (CA)。 &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;cert-manager 集成&lt;/strong&gt;：我们展示了 cert-manager 与 EJBCA 的集成，包括 EJBCA 自定义颁发者的配置。 cert-manager 将处理证书的颁发和更新。  &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;自动证书续订&lt;/strong&gt;：PKI 管理中的一个关键挑战是确保证书在过期前自动续订。 cert-manager 与 EJBCA 一起可以在所有集群中实现无缝、应用程序透明的证书更新。 &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image&#34;&gt;&lt;a href=&#34;https://tetrate.io/wp-content/uploads/2024/09/arch.svg&#34;&gt;&lt;img解码=&#34;async&#34; src=&#34; https://tetrate.io/wp-content/uploads/2024/09/arch.svg&#34; alt=&#34;Image&#34; class=&#34;wp-image-54748&#34;referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/a&gt;&lt;/图&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;h-architecture-setup-with-istio-using-ejbca-as-an-external-ca-a-high-level-summary-nbsp&#34;&gt;架构设置Istio 使用 EJBCA 作为外部 CA，高级摘要&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;本节概述了使用 EJBCA 作为外部证书颁发机构 (CA) 在 Kubernetes 集群上设置 Istio 的步骤。该设置包括使用 MetalLB 配置两个 MicroK8s 集群以实现负载平衡、集成 EJBCA 以进行证书管理以及使用 Helm 安装 Istio 组件。您可以在&lt;a href=&#34;https://docs.keyfactor.com/ejbca/latest/tutorial-deploy-istio-service-mesh-in-a-multi&#34;&gt;此处&lt;/a&gt;找到完整指南。&lt;/ p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;关键步骤包括：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol类=“wp-block-list”&gt;&#xA;&lt;li&gt;&lt;strong&gt;安装和配置 Helm 存储库&lt;/strong&gt;：为 Istio、cert-manager 和 EJBCA 添加必要的 Helm 存储库。 &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;部署 cert-manager 和 EJBCA&lt;/strong&gt;：在主集群和远程集群中使用 Helm 安装 cert-manager，然后使用自定义颁发者部署 EJBCA。此步骤还包括生成必要的证书并将其存储为 Kubernetes 机密。 &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;使用 EJBCA 配置 Istio&lt;/strong&gt;：在 Kubernetes 中创建一个指向 EJBCA 实例以颁发证书的自定义颁发者。然后将该发行者集成到 Istio 配置中。 &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;安装 Istio 组件&lt;/strong&gt;：部署 cert-manager-istio-csr 来处理 Istio 的证书签名请求，然后安装 Istio 的基础组件、Istio CNI（容器网络接口）、Istiod（Istio）控制平面）和 Istio 入口网关。 &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;自定义和覆盖&lt;/strong&gt;：应用自定义值来定制 Istio 的行为，例如用于服务之间安全通信的特定集群 ID、信任域和 DNS 配置。 &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;自动证书续订&lt;/strong&gt;：该设置经过配置，以便 cert-manager 在证书过期之前自动续订证书，而不会中断正在运行的应用程序。 &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image&#34;&gt;&lt;a href=&#34;https://tetrate.io/wp-content/uploads/2024/09/Cert-renew-flow-1024x637.png&#34;&gt;&lt;img 解码=&#34;异步&#34; src=&#34;https://tetrate.io/wp-content/uploads/2024/09/Cert -renew-flow-1024x637.png&#34; alt=&#34;Image&#34; class=&#34;wp-image-54749&#34;referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;以上是 Istio 中 mTLS 证书颁发和续订流程的流程图。它说明了从 Istiod 控制平面推送 Envoy 配置到 EJBCA 最终颁发证书的流程。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;h-pki-best-practices-and-compliance-nbsp&#34;&gt;PKI 最佳实践和合规性&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;为 Istio 服务网格构建安全的 PKI 不仅仅涉及设置任何 PKI 和开始颁发证书。它需要遵守最佳实践并遵守法规，以保持安全和面向未来。以下是需要考虑的一些关键点：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol类=“wp-block-list”&gt;&#xA;&lt;li&gt;&lt;strong&gt;遵守法规&lt;/strong&gt;：确保您的 PKI 实施符合监管要求，例如《欧盟网络弹性法案》和《美国关于改善国家网络安全的行政命令》。这包括实施弹性架构、维护审计跟踪以及确保稳健的密钥管理实践。 &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;加密敏捷性和量子就绪性&lt;/strong&gt;：随着加密标准的发展，您的 PKI 必须足够敏捷，以适应新的算法和密钥长度。随着量子计算的潜在出现，做好量子准备变得越来越重要。 &lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;与 InfoSec 协作&lt;/strong&gt;：与信息安全 (InfoSec) 团队的有效协作对于维护 PKI 的安全性和合规性至关重要。这包括定期审查安全策略、持续培训以及确保 PKI 管理流程与组织安全目标保持一致。 &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;结论&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在多集群环境中为 Istio 服务网格实现 PKI 似乎令人畏惧，但通过正确的工具和实践，可以高效且有效地实现。 EJBCA 与 cert-manager 相结合，提供了大规模管理证书的解决方案，确保您的 Istio 服务网格 PKI 安全且合规。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;通过遵循本指南中概述的步骤，您将能够设置可信的 PKI，实现无缝且强大的证书管理，并与您的 InfoSec 团队有效协作以维护服务网格的安全。  &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;有关本博客所涵盖主题的更多资源和更详细信息，请务必查看下面提供的链接和参考资料。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;h-resources-nbsp&#34;&gt;资源&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.keyfactor.com/ejbca/latest/tutorial-deploy-istio-service-mesh-in-a-multi&#34;&gt;教程 – 在多集群中部署 Istio 服务网格Kubernetes 环境使用 EJBCA 作为外部 PKI 提供者&lt;/a&gt;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://istio.io/latest/docs/&#34;&gt;Istio 文档&lt;/a&gt;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.ejbca.org/&#34;&gt;EJBCA 社区版&lt;/a&gt;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://cert-manager.io/docs/&#34;&gt;cert-manager 文档&lt;/a&gt;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://digital-strategy.ec.europa.eu/en/policies/cyber-resilience-act&#34;&gt;欧盟网络弹性法案&lt;/a&gt;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.whitehouse.gov/briefing-room/statements-releases/2021/05/12/executive-order-on-improving-the-nations-cybersecurity/&#34;&gt;美国行政长官网络安全令&lt;/a&gt;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://tetrate.io/blog/multicluster-istio/&#34;&gt;多集群 Istio 服务网格部署的无缝跨集群连接&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Thu, 31 Oct 2024 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【OpenTelemetry Is expanding into CI/CD observability】OpenTelemetry 正在扩展到 CI/CD 可观察性</title>
      <link>https://www.cncf.io/blog/2024/11/04/opentelemetry-is-expanding-into-ci-cd-observability/</link>
      <description>【&lt;p&gt;&lt;em&gt;SIG post by &lt;a href=&#34;https://www.linkedin.com/in/horovits/&#34;&gt;Dotan Horovits&lt;/a&gt; and &lt;a href=&#34;https://www.linkedin.com/in/aqperkins/&#34;&gt;Adriel Perkins&lt;/a&gt;, Project Leads, SIG CI/CD Observability, OpenTelemetry&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;We’ve been talking about the need for a common “language” for reporting and observing CI/CD pipelines for years, and finally, we see the first “words” of this language entering the “dictionary” of observability – the OpenTelemetry open specification. With the recent release of OpenTelemetry’s Semantic Conventions, v1.27.0, you can find &lt;a href=&#34;https://opentelemetry.io/docs/specs/semconv/attributes-registry/cicd/&#34;&gt;designated attributes for reporting CI/CD pipelines&lt;/a&gt;.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This is the result of the hard work of the &lt;a href=&#34;https://github.com/open-telemetry/community/blob/main/projects/ci-cd.md&#34;&gt;&lt;strong&gt;CI/CD Observability Special Interest Group (SIG) within OpenTelemetry&lt;/strong&gt;&lt;/a&gt;. As we accomplish the core milestone for the first phase, we thought it’d be a good time to share it with the world.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;iframe loading=&#34;lazy&#34; title=&#34;Embedded post&#34; src=&#34;https://www.linkedin.com/embed/feed/update/urn:li:share:7226847382200565762&#34; width=&#34;504&#34; height=&#34;1126&#34; frameborder=&#34;0&#34; allowfullscreen=&#34;allowfullscreen&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/iframe&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Engineers need observability into their CI/CD pipelines&amp;nbsp;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://medium.com/@horovits/fcc6c10c4987&#34;&gt;CI/CD observability&lt;/a&gt; is essential for ensuring that software is released to production efficiently and reliably. Well-functioning CI/CD pipelines directly impact business outcomes by shortening &lt;a href=&#34;https://horovits.medium.com/improving-devops-performance-with-dora-metrics-918b9604f8e2&#34;&gt;Lead Time for Changes DORA metric&lt;/a&gt;, and enabling fast identification and resolution of broken or flaky processes. By integrating observability into CI/CD workflows, teams can monitor the health and performance of their pipelines in real-time, gaining insights into bottlenecks and areas that require improvement.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Leveraging the same well-established tools used for monitoring production environments, organizations can extend their observability capabilities to include the release cycle, fostering a holistic approach to software delivery. Whether open source or proprietary tools, there’s no need to reinvent the wheel when choosing the observability toolchain for CI/CD pipelines.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;The need for standardization&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;However, the diverse landscape of CI/CD tools creates challenges in achieving consistent end-to-end observability. With each tool having its own means, format and semantic conventions for reporting the pipeline execution status, fragmentation within the toolchain can hinder seamless monitoring. Migrating between tools becomes painful, as it requires reimplementing existing dashboards, reports and alerts.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Things become even more challenging, when needing to monitor multiple tools involved in the release pipeline in a uniform manner. This is where &lt;a href=&#34;https://horovits.medium.com/the-rise-of-open-standards-in-observability-highlights-from-kubecon-13694e732c97&#34;&gt;open standards and specifications become critical&lt;/a&gt;. They create a common uniform language, one which is tool- and vendor-agnostic, enabling cohesive observability across different tools and allowing teams to maintain a clear and comprehensive view of their CI/CD pipeline performance.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The need for standardization is relevant for creating the semantic conventions mentioned above, the language for reporting what goes on in the pipeline. Standardization is also needed for the means in which this reporting is propagated through the system, such as upon spawning processes during the pipeline execution. This led us to promote standardization for using environment variables for context and baggage propagation between processes, another important milestone that was recently approved and merged.&lt;/p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&lt;iframe loading=&#34;lazy&#34; title=&#34;Embedded post&#34; src=&#34;https://www.linkedin.com/embed/feed/update/urn:li:share:7254577377660334081&#34; width=&#34;504&#34; height=&#34;701&#34; frameborder=&#34;0&#34; allowfullscreen=&#34;allowfullscreen&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/iframe&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;OpenTelemetry: the natural home for CI/CD observability specification&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This realization drove us to look for the right way to approach creating a specification. OpenTelemetry emerges as the standard for telemetry generation and collection. The OpenTelemetry specification is tasked with exactly this problem: creating a common uniform and vendor-agnostic specification for telemetry. And housed under the Cloud Native Computing Foundation (CNCF) can ensure it remains open and vendor-neutral. As long standing advocates of OpenTelemetry, it only made sense to extend OpenTelemetry to cover this important DevOps use case.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;We started with an &lt;a href=&#34;https://github.com/open-telemetry/oteps/pull/223&#34;&gt;OpenTelemetry extension proposal (OTEP #223)&lt;/a&gt; a couple of years ago, proposing our idea to extend OpenTelemetry to cover the CI/CD observability use case. In parallel, we’ve started a slack channel on the CNCF slack to gather fellow enthusiasts behind the idea and start brainstorming what that should look like. The slack channel grew and we quickly discovered that the problem is common across many organizations.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;With the feedback from the Technical Oversight Committee and others within the CNCF, we’ve taken the path of asking the mandate to start a dedicated Working Group for the topic under OpenTelemetry’s Semantic Conventions SIG (SIG SemConv in short). With their blessing, we &lt;a href=&#34;https://github.com/open-telemetry/community/blob/main/projects/ci-cd.md&#34;&gt;launched the formal CI/CD Observability SIG&lt;/a&gt; to formalize our previous slack group discussions and goals.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&lt;iframe loading=&#34;lazy&#34; title=&#34;Embedded post&#34; src=&#34;https://www.linkedin.com/embed/feed/update/urn:li:share:7155107098903666688&#34; width=&#34;504&#34; height=&#34;961&#34; frameborder=&#34;0&#34; allowfullscreen=&#34;allowfullscreen&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/iframe&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;OpenTelemetry’s CI/CD Observability SIG&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Since November of 2023, the SIG has been actively working to develop the standard for semantics around CI/CD observability in collaboration with experts from multiple companies and Open-Source projects. At its inception, we decided to focus on a few key areas for 2024:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;An initial set of common attributes across CI/CD Systems.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Develop prototype(s) to include both holistic and signal specific attributes.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Carry forward the proposal to add environment variables as context propagators to the OpenTelemetry specification (OTEP #258)&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;A strategy for bridging OpenTelemetry conventions with &lt;a href=&#34;https://cdevents.dev/docs/&#34;&gt;CDEvents&lt;/a&gt; and &lt;a href=&#34;https://eiffel-community.github.io/&#34;&gt;Eiffel&lt;/a&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;At first, our SIG met during the larger Semantic Conventions Working Group meetings every Monday. This provided a good opportunity for us to get our bearings as we researched and discussed how we would accomplish the goals on our roadmap. This also enabled us to get to know many members of the larger OpenTelemetry community, solicit feedback on our designs, and get direction on how to proceed. The OpenTelemetry Semantic Convention Working Group has been extraordinarily supportive of the CI/CD initiative.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Upon completion and release of its initial milestone (see below), our SIG was granted its own &lt;a href=&#34;https://github.com/open-telemetry/community/pull/2293&#34;&gt;dedicated meeting slot&lt;/a&gt; on the &lt;a href=&#34;https://github.com/open-telemetry/community?tab=readme-ov-file#calendar&#34;&gt;OpenTelemetry calendar&lt;/a&gt;, every Thursday at 0600 PT. The group gets together here to discuss current and future work prior to bringing to the larger Semantic Conventions meetings on Monday. We greatly look forward to the continued support and participation of the community as we continue to drive forward this critical area of standardization.&lt;/p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&lt;iframe loading=&#34;lazy&#34; title=&#34;Embedded post&#34; src=&#34;https://www.linkedin.com/embed/feed/update/urn:li:share:7225246809189683200&#34; width=&#34;504&#34; height=&#34;1026&#34; frameborder=&#34;0&#34; allowfullscreen=&#34;allowfullscreen&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/iframe&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;CI/CD Is part of the latest OpenTelemetry Semantic Conventions&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Over the course of months of iteration and feedback, the &lt;a href=&#34;https://github.com/open-telemetry/semantic-conventions/pull/1075&#34;&gt;first set of Semantic Conventions was merged&lt;/a&gt; in for the v1.27.0 release. This change brought forth the first set of foundational semantics for CI/CD under the &lt;code&gt;CICD&lt;/code&gt;, &lt;code&gt;artifacts&lt;/code&gt;, &lt;code&gt;VCS&lt;/code&gt;, &lt;code&gt;test&lt;/code&gt;, and &lt;code&gt;deployment&lt;/code&gt; namespaces. This was a significant milestone for the CI/CD Observability SIG and industry as a whole. This creates the foundation for which all of our group’s other goals can begin to take form, and reach implementation.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;But what does that actually mean? What value does it provide? Let’s consider real world examples for two of the namespaces&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Tracking release revisions from Version Control Systems (VCS)&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/&#34;&gt;Version Control System (VCS) attributes&lt;/a&gt; cover multiple areas common in a VCS like refs and changes (pull/merge requests). The &lt;code&gt;vcs.repository.ref.revision&lt;/code&gt; attribute is a key piece of metadata. As Version Control Systems like GitHub and GitLab emit events, they can now have this semantically compliant attribute. That means when integrating code, releasing it, and deploying it to environments, systems can include this attribute and trace the code revision across bounds more easily. In the event a deployment fails, you can quickly look at the revision of code and track it back to the buggy release. This attribute is actually a key piece of metadata for&lt;a href=&#34;https://dora.dev/guides/dora-metrics-four-keys/&#34;&gt; DORA metrics&lt;/a&gt; too as you calculate Change lead time and Failed deployment recovery time.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Artifacts for supply chain security, aligned with the SLSA specification&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The &lt;a href=&#34;https://opentelemetry.io/docs/specs/semconv/attributes-registry/artifact/&#34;&gt;artifact attribute namespace&lt;/a&gt; had multiple attributes for its first implementation. One key set of attributes within this namespace cover &lt;a href=&#34;https://slsa.dev/attestation-model&#34;&gt;attestations&lt;/a&gt; that closely align with the &lt;a href=&#34;https://slsa.dev/spec/v1.0/about&#34;&gt;SLSA&lt;/a&gt; model. This is really the first time a direct connection is being made between Observability and Software Supply Chain Security. Consider the following &lt;a href=&#34;https://slsa.dev/spec/v1.0/threats&#34;&gt;supply chain threat model&lt;/a&gt; defined by SLSA:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1238&#34; height=&#34;870&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2024/11/Screenshot-2024-11-04-at-07.36.23.jpg&#34; alt=&#34;image&#34; class=&#34;wp-image-119840&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2024/11/Screenshot-2024-11-04-at-07.36.23.jpg 1238w, https://www.cncf.io/wp-content/uploads/2024/11/Screenshot-2024-11-04-at-07.36.23-300x211.jpg 300w, https://www.cncf.io/wp-content/uploads/2024/11/Screenshot-2024-11-04-at-07.36.23-1024x720.jpg 1024w, https://www.cncf.io/wp-content/uploads/2024/11/Screenshot-2024-11-04-at-07.36.23-768x540.jpg 768w, https://www.cncf.io/wp-content/uploads/2024/11/Screenshot-2024-11-04-at-07.36.23-900x632.jpg 900w, https://www.cncf.io/wp-content/uploads/2024/11/Screenshot-2024-11-04-at-07.36.23-285x200.jpg 285w, https://www.cncf.io/wp-content/uploads/2024/11/Screenshot-2024-11-04-at-07.36.23-569x400.jpg 569w&#34; sizes=&#34;(max-width: 1238px) 100vw, 1238px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;These new attributes for artifacts and attestations help observe the sequence of events modeled in the above diagram in real time. Really, the conventions that exist today and those that will be added in the future enable interoperability between core software delivery capabilities like security and platform engineering via observability semantics.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;What’s Next for CI/CD Observability Working Group&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The first major milestone we shared above, was the merge of the OTEP for extending the semantic conventions with the new attributes, which is now part of the OpenTelemetry Semantic Conventions latest release.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The other important milestone was &lt;a href=&#34;https://github.com/open-telemetry/oteps/pull/258&#34;&gt;OTEP #258&lt;/a&gt; for Environment Variable Context Propagation that was just approved and merged. This OTEP sets the ground for writing the specification.&lt;/p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&lt;iframe loading=&#34;lazy&#34; title=&#34;Embedded post&#34; src=&#34;https://www.linkedin.com/embed/feed/update/urn:li:share:7254563196093505536&#34; width=&#34;504&#34; height=&#34;1152&#34; frameborder=&#34;0&#34; allowfullscreen=&#34;allowfullscreen&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/iframe&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&lt;p&gt;Since we’ve made progress on our initial milestones, we’ve updated the &lt;a href=&#34;https://github.com/open-telemetry/community/blob/main/projects/ci-cd.md&#34;&gt;CI/CD Observability SIG milestones for the remainder of 2024&lt;/a&gt;. Our goal is to finish out as many of the defined milestones as possible by the end of the year. Notably, we’re focused on:&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Adding &lt;a href=&#34;https://github.com/open-telemetry/semantic-conventions/pull/1383&#34;&gt;metric conventions for version control systems&lt;/a&gt;.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Building tracing prototypes in CICD systems. (eg. ArgoCD, GitHub, GitLab, Jenkins)&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Getting &lt;a href=&#34;https://github.com/open-telemetry/oteps/pull/258&#34;&gt;OTEP #258&lt;/a&gt; ready for implementation for the addition to the specification.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Adding additional attributes to the registry covering more domains like:&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/open-telemetry/semantic-conventions/issues/1185&#34;&gt;Software outage incidents&lt;/a&gt;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/open-telemetry/semantic-conventions/issues/1184&#34;&gt;System attributes around CI/CD runners&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Beginning work on Trace and Event (log) signal specifics. (Building the bridge for interoperability between other specifications)&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Adopting the changes from the &lt;a href=&#34;https://github.com/open-telemetry/oteps/pull/264&#34;&gt;Entity and Resource OTEP&lt;/a&gt;.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/open-telemetry/semantic-conventions/issues/1193&#34;&gt;Enabling vendor specific extension(s)&lt;/a&gt;.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Open-source community reachout strategy for semantic adoption.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;All that has been mentioned thus far is just the beginning! We have lots of work defined on our &lt;a href=&#34;https://github.com/orgs/open-telemetry/projects/79&#34;&gt;CICD Project Board&lt;/a&gt;, and we have work in progress! We’ll continue to iterate on the above milestones that we’ve set out for the remainder of 2024. Here’s a couple things to look out for.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/open-telemetry/semantic-conventions/pull/1383&#34;&gt;Version Control System metrics&lt;/a&gt; – leading indicators for DORA.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/issues/27460#issuecomment-2302537838&#34;&gt;Traces from GitHub Actions&lt;/a&gt; and &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/issues/35015#issuecomment-2344121664&#34;&gt;Audit Logs&lt;/a&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Special thanks to the following people who are making this component possible:&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Tyler Helmuth – Honeycomb&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Andrzej Stencel – Elastic&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Curtis Robert – Splunk&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Justin Voss&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Kristof Kowalski – Anz Bank&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Mike Sarahan – Nvidia&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;A corresponding version of the GitHub Receiver Component but implemented in &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/issues/35207&#34;&gt;GitLab&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;And much more!&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;It takes a village to extend OpenTelemetry&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Woah, that’s a lot to do! Most certainly this SIG will continue beyond 2024 and through 2025. Standards are hard, but essential. And, we have some amazing folks that are part of the SIG and contributing to these standards! Who you may ask?&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Firstly we’d like to acknowledge key members of OpenTelemetry leadership committees who have heavily enabled the work we’ve done thus far, and will continue to do.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;From the OpenTelemetry Technical Committee we have two core sponsors, Carlos Alberto from Lightstep and Josh Suereth from Google. Both Carlos and Josh have been so supportive of the CICD work, really guiding us through the process and details we need to be successful.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;From the OpenTelemetry Governance Committee we’ve had Trask Stalnaker from Microsoft act as an exceptional ally, and Daniel Blanco from Skyscanner who now acts as our current Liaison. Both Trask and Daniel have been instrumental in supporting the SIG and enabling us to have our own meeting in the OpenTelemetry community.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In addition to those folks, we’ve had significant feedback, support, and contributions from the following key folks:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Yuri Shkuro – Creator of Jaeger, Co-Founder of OpenTelemetry&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Andrea Frittoli – Tekton CD Maintainer, CDEvents Co-creator, IBM&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Emil Bäckmark – CDEvents and Eiffel Maintainer, Ericsson&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Magnus Bäck – Eiffel, Axis Communications&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Liudmila Molkova – Microsoft&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Christopher Kamphaus – Jemmic, Jenkins&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Giordano Ricci – Grafana Labs&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Giovanni Liva – Dynatrace, Keptn&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Ivan Calvo – Elastic, Jenkins&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Armin Ruech – Dynatrace&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Michael Safyan – Google&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Robb Kidd – Honeycomb&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Pablo Chacin – Grafana Labs&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Alexandra Konrad – Elastic&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Alexander Wert – Elastic&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Joao Grassi – Dynatrace&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;DJ Gregor – Discover&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;That was a lot of names to name! We greatly appreciate everyone who has supported this initiative and helped bring it to fruition! It takes significant thinking ability and time to build industry wide standards. Hard problems are hard, but these folks have risen to the challenge to make the world of observability and CICD systems a better, more interoperable place!&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Join the Working Group discourse and make an impact&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Want to learn more? Want to get involved in shaping CI/CD Observability?&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;We invite developers and practitioners to participate in the discussions, contribute ideas, and help shape the future of CI/CD observability and the OpenTelemetry semantic conventions. Discussion takes place in the CNCF slack workspace under the #cicd-o11y channel, and you can chime in on GitHub and join the CICD SIG weekly calls every Thursday at 0600 PT.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;p&gt;&lt;em&gt;SIG 帖子，作者：&lt;a href=&#34;https://www.linkedin.com/in/horovits/&#34;&gt;Dotan Horovits&lt;/a&gt; 和 &lt;a href=&#34;https://www.linkedin. com/in/aqperkins/&#34;&gt;Adriel Perkins&lt;/a&gt;，SIG CI/CD 可观测性、OpenTelemetry 项目负责人&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;多年来，我们一直在讨论需要一种通用“语言”来报告和观察 CI/CD 管道，最后，我们看到这种语言的第一个“单词”进入了可观察性的“字典”—— OpenTelemetry 开放规范。通过最近发布的 OpenTelemetry 语义约定 v1.27.0，您可以找到用于报告 CI/CD 的指定属性管道&lt;/a&gt;。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这是 &lt;a href=&#34;https://github.com/open-telemetry/community/blob/main/projects/ci-cd.md&#34;&gt;&lt;strong&gt;CI/ 辛勤工作的结果OpenTelemetry 内的 CD 可观测性特别兴趣小组 (SIG)&lt;/strong&gt;&lt;/a&gt;。当我们完成第一阶段的核心里程碑时，我们认为现在是与世界分享的好时机。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;iframe loading=&#34;lazy&#34; title=&#34;嵌入帖子&#34; src=&#34;https://www.linkedin.com/embed/feed/update/urn:li:share:7226847382200565762&#34; width=&#34;504&#34; height= “1126”frameborder =“0”allowfullscreen =“allowfullscreen”referrerpolicy =“no-referrer”&gt;&lt;/iframe&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;工程师需要对其 CI/CD 管道进行可观察性&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://medium.com/@horovits/fcc6c10c4987&#34;&gt;CI/CD 可观察性&lt;/a&gt;对于确保软件高效可靠地发布到生产环境至关重要。运作良好的 CI/CD 管道可以通过缩短&lt;a href=&#34;https://horovits.medium.com/improving-devops-performance-with-dora-metrics-918b9604f8e2&#34;&gt;DORA 指标变更交付时间&lt;来直接影响业务成果/a&gt;，并能够快速识别和解决损坏或不稳定的进程。通过将可观察性集成到 CI/CD 工作流程中，团队可以实时监控管道的运行状况和性能，深入了解瓶颈和需要改进的领域。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;利用用于监控生产环境的相同成熟工具，组织可以扩展其可观察能力以包括发布周期，从而促进软件交付的整体方法。无论是开源工具还是专有工具，在为 CI/CD 管道选择可观察性工具链时都无需重新发明轮子。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;标准化的必要性&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;然而，CI/CD 工具的多样化给实现一致的端到端可观察性带来了挑战。由于每个工具都有自己的方法、格式和语义约定来报告管道执行状态，工具链内的碎片可能会阻碍无缝监控。在工具之间迁移变得很痛苦，因为它需要重新实现现有的仪表板、报告和警报。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;事情变得更糟了当需要以统一的方式监控发布管道中涉及的多个工具时，这很有挑战性。这就是&lt;a href=&#34;https://horovits.medium.com/the-rise-of-open-standards-in-observability-highlights-from-kubecon-13694e732c97&#34;&gt;开放标准和规范变得至关重要的地方&lt;/a &gt;。他们创建了一种通用的统一语言，这种语言与工具和供应商无关，从而能够跨不同工具进行一致的可观察性，并允许团队对其 CI/CD 管道性能保持清晰、全面的了解。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;标准化的需求与创建上述语义约定（用于报告管道中发生的情况的语言）相关。通过系统传播此报告的方式也需要标准化，例如在管道执行期间生成进程时。这促使我们促进使用环境变量进行流程之间的上下文和行李传播的标准化，这是最近批准和合并的另一个重要里程碑。&lt;/p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&lt;iframe loading=&#34;lazy&#34; title=&#34;嵌入帖子&#34; src=&#34;https://www.linkedin.com/embed/feed/update/urn:li:share:7254577377660334081&#34; width=&#34;504&#34; height= “701”frameborder =“0”allowfullscreen =“allowfullscreen”referrerpolicy =“no-referrer”&gt;&lt;/iframe&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;OpenTelemetry：CI/CD 可观测性规范的天然家园&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这种认识促使我们寻找创建规范的正确方法。 OpenTelemetry 成为遥测数据生成和收集的标准。 OpenTelemetry 规范的任务正是解决这个问题：为遥测创建一个通用的统一且与供应商无关的规范。并位于云原生计算基金会 (CNCF) 之下，可以确保它保持开放和供应商中立。作为 OpenTelemetry 的长期倡导者，扩展 OpenTelemetry 以覆盖这一重要的 DevOps 用例才有意义。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;几年前，我们从&lt;a href=&#34;https://github.com/open-telemetry/oteps/pull/223&#34;&gt;OpenTelemetry 扩展提案 (OTEP #223)&lt;/a&gt; 开始，提出我们的想法是扩展 OpenTelemetry 以涵盖 CI/CD 可观察性用例。与此同时，我们在 CNCF slack 上启动了一个 slack 频道，聚集这个想法背后的爱好者，并开始集思广益。 Slack 渠道不断发展，我们很快发现这个问题在许多组织中都很常见。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;根据技术监督委员会和 CNCF 内其他人员的反馈，我们采取了请求授权的方式，在 OpenTelemetry 的语义约定 SIG（简称 SIG SemConv）下针对该主题成立一个专门的工作组。在他们的支持下，我们&lt;a href=&#34;https://github.com/open-telemetry/community/blob/main/projects/ci-cd.md&#34;&gt;启动了正式的 CI/CD 可观察性 SIG&lt;/a&gt;正式确定我们之前的 Slack 小组讨论和目标。 &lt;/p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&lt;iframe 加载=“懒惰”title =“嵌入帖子”src =“https://www.linkedin.com/embed/feed/update/urn：li：share：7155107098903666688”宽度=“504”高度=“961”frameborder =“0”allowfullscreen = “allowfullscreen”referrerpolicy =“no-referrer”&gt;&lt;/iframe&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;OpenTelemetry 的 CI/CD 可观测性 SIG&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;自 2023 年 11 月以来，SIG 一直在与多家公司和开源项目的专家合作，积极致力于开发围绕 CI/CD 可观察性的语义标准。在成立之初，我们决定在 2024 年重点关注几个关键领域：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;CI/CD 系统中的一组初始通用属性。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;开发原型以包含整体属性和信号特定属性。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;推进将环境变量作为上下文传播器添加到 OpenTelemetry 规范 (OTEP #258) 的提案&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;将 OpenTelemetry 约定与 &lt;a href=&#34;https://cdevents.dev/docs/&#34;&gt;CDEvents&lt;/a&gt; 和 &lt;a href=&#34;https://eiffel-community.github.io/ 桥接的策略”埃菲尔铁塔&lt;/a&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;起初，我们的 SIG 在每周一举行的大型语义约定工作组会议上举行会议。这为我们研究和讨论如何实现路线图上的目标提供了一个了解方向的好机会。这也使我们能够认识更大的 OpenTelemetry 社区的许多成员，征求对我们设计的反馈，并获得有关如何进行的指导。 OpenTelemetry 语义约定工作组一直非常支持 CI/CD 计划。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在完成并发布其初始里程碑（见下文）后，我们的 SIG 获得了自己的&lt;a href=&#34;https://github.com/open-telemetry/community/pull/2293&#34;&gt;专用会议时段&lt; /a&gt; &lt;a href=&#34;https://github.com/open-telemetry/community?tab=readme-ov-file#calendar&#34;&gt;OpenTelemetry 日历&lt;/a&gt;，每周四 0600 PT。在周一召开更大规模的语义大会之前，该小组聚集在这里讨论当前和未来的工作。在我们继续推动标准化这一关键领域的过程中，我们非常期待社区的持续支持和参与。&lt;/p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&lt;iframe loading=&#34;lazy&#34; title=&#34;嵌入帖子&#34; src=&#34;https://www.linkedin.com/embed/feed/update/urn:li:share:7225246809189683200&#34; width=&#34;504&#34; height= “1026”frameborder =“0”allowfullscreen =“allowfullscreen”referrerpolicy =“no-referrer”&gt;&lt;/iframe&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;CI/CD 是最新 OpenTelemetry 语义约定的一部分&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;经过几个月的迭代和反馈，&lt;a href=&#34;https://github.com/open-telemetry/semantic-conventions/pull/1075&#34;&gt;第一组语义约定被合并&lt;/a &gt; 用于 v1.27.0 版本。这一变化为 CI/CD 带来了第一组基础语义，包括 CICD、artifacts、VCS、test 等。 &gt; 和&lt;code&gt;部署&lt;/code&gt; n空间。对于 CI/CD 可观测性 SIG 和整个行业来说，这是一个重要的里程碑。这为我们小组的所有其他目标开始形成并实现奠定了基础。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;但这实际上意味着什么？它提供什么价值？让我们考虑两个命名空间的现实世界示例&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;跟踪版本控制系统 (VCS) 的版本修订&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/&#34;&gt;版本控制系统 (VCS) 属性&lt;/a&gt; 涵盖 VCS 中常见的多个区域，例如 refs和更改（拉取/合并请求）。 &lt;code&gt;vcs.repository.ref.revision&lt;/code&gt; 属性是元数据的关键部分。随着 GitHub 和 GitLab 等版本控制系统发出事件，它们现在可以具有这种语义兼容的属性。这意味着在集成代码、发布代码并将其部署到环境时，系统可以包含此属性并更轻松地跨界跟踪代码修订。如果部署失败，您可以快速查看代码修订版本并将其追溯到有错误的版本。当您计算更改交付时间和失败时，此属性实际上也是 &lt;a href=&#34;https://dora.dev/guides/dora-metrics-four-keys/&#34;&gt; DORA 指标&lt;/a&gt; 的关键元数据部署恢复时间。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;供应链安全工件，符合 SLSA 规范&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://opentelemetry.io/docs/specs/semconv/attributes-registry/artifact/&#34;&gt;artifact 属性命名空间&lt;/a&gt; 的第一个实现有多个属性。此命名空间中的一组关键属性涵盖与 &lt;a href=&#34;https://slsa.dev/ 紧密结合的&lt;a href=&#34;https://slsa.dev/attestation-model&#34;&gt;证明&lt;/a&gt; spec/v1.0/about&#34;&gt;SLSA&lt;/a&gt; 模型。这确实是第一次在可观察性和软件供应链安全之间建立直接联系。考虑以下由 SLSA 定义的&lt;a href=&#34;https://slsa.dev/spec/v1.0/threats&#34;&gt;供应链威胁模型&lt;/a&gt;：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“1238”高度=“870”src=“https://www.cncf.io/ wp-content/uploads/2024/11/Screenshot-2024-11-04-at-07.36.23.jpg&#34; alt=&#34;image&#34; class=&#34;wp-image-119840&#34; srcset=&#34;https://www.cncf .io/wp-content/uploads/2024/11/Screenshot-2024-11-04-at-07.36.23.jpg 1238w，https://www.cncf.io/wp-content/uploads/2024/11/屏幕截图-2024-11-04-at-07.36.23-300x211.jpg 300w，https://www.cncf.io/wp-content/uploads/2024/11/Screenshot-2024-11-04-at-07.36 .23-1024x720.jpg 1024w，https://www.cncf.io/wp-content/uploads/2024/11/Screenshot-2024-11-04-at-07.36.23-768x540.jpg 768w，https:// /www.cncf.io/wp-content/uploads/2024/11/Screenshot-2024-11-04-at-07.36.23-900x632.jpg 900w，https://www.cncf.io/wp-content/ uploads/2024/11/Screenshot-2024-11-04-at-07.36.23-285x200.jpg 285w，https://www.cncf.io/wp-content/uploads/2024/11/Screenshot-2024-11-04-at-07.36.23-569x400.jpg 569w“尺寸=”（最大宽度：1238px）100vw，1238px“referrerpolicy=“no-referrer”&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这些工件和证明的新属性有助于实时观察上图中建模的事件序列。实际上，现在存在的约定以及将来将添加的约定通过可观察性语义实现了安全性和平台工程等核心软件交付功能之间的互操作性。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;CI/CD 可观测性工作组的下一步发展&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我们在上面分享的第一个重要里程碑是 OTEP 的合并，用于扩展语义约定与新属性，它现在是 OpenTelemetry 语义约定最新版本的一部分。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;另一个重要的里程碑是刚刚获得批准和合并的环境变量上下文传播的 &lt;a href=&#34;https://github.com/open-telemetry/oteps/pull/258&#34;&gt;OTEP #258&lt;/a&gt; 。此 OTEP 为编写规范奠定了基础。&lt;/p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&lt;iframe loading=&#34;lazy&#34; title=&#34;嵌入帖子&#34; src=&#34;https://www.linkedin.com/embed/feed/update/urn:li:share:7254563196093505536&#34; width=&#34;504&#34; height= “1152”frameborder =“0”allowfullscreen =“allowfullscreen”referrerpolicy =“no-referrer”&gt;&lt;/iframe&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&lt;p&gt;自从我们在初始里程碑上取得进展以来，我们更新了 &lt;a href=&#34;https://github.com/open-telemetry/community/blob/main/projects/ci-cd.md&#34; &gt;2024 年剩余时间内的 CI/CD 可观测性 SIG 里程碑&lt;/a&gt;。我们的目标是在年底前完成尽可能多的既定里程碑。值得注意的是，我们专注于：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;添加&lt;a href=&#34;https://github.com/open-telemetry/semantic-conventions/pull/1383&#34;&gt;版本控制系统的度量约定&lt;/a&gt;。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;在 CICD 系统中构建跟踪原型。 （例如 ArgoCD、GitHub、GitLab、Jenkins）&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;准备好 &lt;a href=&#34;https://github.com/open-telemetry/oteps/pull/258&#34;&gt;OTEP #258&lt;/a&gt; 为实施添加规范做好准备。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;向注册表添加更多属性，涵盖更多域，例如：&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/open-telemetry/semantic-conventions/issues/1185&#34;&gt;软件中断事件&lt;/a&gt;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/open-telemetry/semantic-conventions/issues/1184&#34;&gt;CI/CD 运行程序的系统属性&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;开始研究跟踪和事件（日志）信号细节。 （为其他规范之间的互操作性搭建桥梁）&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;采用&lt;a href=&#34;https://github.com/open-telemetry/oteps/pull/264&#34;&gt;实体和资源 OTEP&lt;/a&gt; 中的更改。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/open-telemetry/semantic-conventions/issues/1193&#34;&gt;启用供应商特定扩展&lt;/a&gt;。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;语义采用的开源社区接触策略。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;到目前为止所提到的一切仅仅是开始！我们在 &lt;a href=&#34;https://github.com/orgs/open-telemetry/projects/79&#34;&gt;CICD 项目委员会&lt;/a&gt;上定义了很多工作，并且我们正在进行中！我们将继续迭代我们在 2024 年剩余时间内设定的上述里程碑。以下是一些需要注意的事项。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/open-telemetry/semantic-conventions/pull/1383&#34;&gt;版本控制系统指标&lt;/a&gt; – DORA 的领先指标。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/issues/27460#issuecomment-2302537838&#34;&gt;来自 GitHub 操作的跟踪&lt;/a&gt; 和 &lt;a href=&#34;https ://github.com/open-telemetry/opentelemetry-collector-contrib/issues/35015#issuecomment-2344121664&#34;&gt;审核日志&lt;/a&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;特别感谢以下人员使该组件成为可能：&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;泰勒·赫尔穆斯 (Tyler Helmuth) – 蜂巢&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Andrzej Stencel – 弹性&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;柯蒂斯·罗伯特 - Splunk&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;贾斯汀·沃斯&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Kristof Kowalski – 澳新银行&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Mike Sarahan - Nvidia&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;GitHub Receiver 组件的相应版本，但在 &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/issues/35207&#34;&gt;GitLab&lt;/a&gt; 中实现&lt;/li &gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;还有更多！&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;需要一个村庄来扩展 OpenTelemetry&lt;/h2​​&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;哇哦，要做的事情太多了！毫无疑问，这个 SIG 将持续到 2024 年之后并一直持续到 2025 年。标准很严格，但很重要。而且，我们有一些了不起的人，他们是 SIG 的一部分，并为这些标准做出了贡献！你可能会问谁？ &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;首先，我们要感谢 OpenTelemetry 领导委员会的主要成员，他们为我们迄今为止所做的工作以及将继续做的工作提供了大力支持。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;OpenTelemetry 技术委员会有两位核心赞助商，来自 Lightstep 的 Carlos Alberto 和来自 Google 的 Josh Suereth。卡洛斯和乔什都非常支持 CICD 的工作，真正指导我们完成成功所需的流程和细节。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在 OpenTelemetry 治理委员会中，我们邀请了来自 Microsoft 的 Trask Stalnaker 作为特殊盟友，以及来自 Skyscanner 的 Daniel Blanco，他现在担任我们的现任联络人。 Trask 和 Daniel 在支持 SIG 并使我们能够在 OpenTelemetry 社区中召开自己的会议方面发挥了重要作用。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;除了这些人之外，我们还得到了以下关键人员的重要反馈、支持和贡献：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Yuri Shkuro – Jaeger 的创建者、OpenTelemetry 的联合创始人&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Andrea Frittoli – IBM Tekton CD 维护者、CDEvents 联合创始人&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Emil Bäckmark – 爱立信 CDEvents 和 Eiffel 维护人员&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Magnus Bäck – 艾菲尔铁塔、安讯士通讯&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Liudmila Molkova - 微软&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;克里斯托弗·坎普豪斯 �� 杰米克，詹金斯&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;佐丹奴·里奇 – Grafana Labs&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Giovanni Liva – Dynatrace、Keptn&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Ivan Calvo – 弹性、Jenkins&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Armin Ruech – Dynatrace&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;迈克尔·萨夫扬 - Google&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;罗伯·基德 - 蜂巢&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Pablo Chacin – Grafana 实验室&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;亚历山德拉·康拉德 (Alexandra Konrad) – 弹性&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Alexander Wert – 弹性&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;若昂·格拉西 (Joao Grassi) – Dynatrace&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;DJ Gregor – 发现&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;有很多名字要命名！我们非常感谢所有支持这一倡议并帮助其实现的人！建立行业范围的标准需要大量的思维能力和时间。困难的问题很难，但这些人已经迎接挑战，让可观察性和 CICD 系统的世界变得更好、更具互操作性！&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;加入工作组讨论并产生影响&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;想了解更多吗？想要参与塑造 CI/CD 可观察性吗？ &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我们邀请开发者和从业者参与讨论、贡献想法并帮助塑造 CI/CD 可观察性和 OpenTelemetry 语义约定的未来。讨论在 #cicd-o11y 频道下的 CNCF slack 工作区中进行，您可以在 GitHub 上插话并参加每周四太平洋时间 0600 点举行的 CICD SIG 每周电话会议。 &lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Sun, 03 Nov 2024 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Mastering Argo CD image updater with Helm: a complete configuration guide】使用 Helm 掌握 Argo CD 映像更新程序：完整的配置指南</title>
      <link>https://www.cncf.io/blog/2024/11/05/mastering-argo-cd-image-updater-with-helm-a-complete-configuration-guide/</link>
      <description>【&lt;p&gt;&lt;em&gt;Member post by Stanislava Racheva, DevOps &amp;amp; Cloud engineer at &lt;a href=&#34;https://itgix.com/kubernetes-services/&#34;&gt;ITGix&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Understanding Argo CD Image Updater&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In modern Kubernetes environments, managing container images and ensuring that applications are always running the latest, most secure versions can be daunting. Argo CD Image Updater simplifies this process by automatically checking for new container image versions and updating your applications accordingly. Integrating seamlessly with Argo CD enables fully automated updates to Kubernetes workloads.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The beauty of Argo CD Image Updater lies in its simplicity and flexibility. By annotating your Argo CD application resources with a list of images and defining version constraints, the Image Updater takes over the heavy lifting. It regularly polls for new image versions from your container registry, checks if they meet the specified constraints, and updates your applications automatically.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Argo CD Image Updater also offers a range of advanced features, such as support for Helm and Kustomize-based applications, various update strategies (like semver, latest, name, and digest), and seamless integration with private container registries. Additionally, it allows parallel updates and supports filtering tags with custom matchers, making it highly customizable and suitable for both small and large-scale Kubernetes environments.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Use Cases and Problems Solved&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;Keeping Images Up-to-Date Automatically&lt;/strong&gt;: For teams deploying frequently updated images, manually tracking and updating these images can lead to inefficiencies and downtime. Argo CD Image Updater solves this by automating the entire image update process.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Version Control and Stability&lt;/strong&gt;: Sometimes teams want to stick to a specific versioning pattern like semver or ensure they only pick stable releases. With Argo CD Image Updater’s configurable strategies, it’s easy to enforce such policies and ensure the application is always running on the desired version.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Efficient GitOps Workflow&lt;/strong&gt;: By integrating with Argo CD, changes can be written back to Git, maintaining the declarative model central to GitOps and ensuring that the application state and versioning are always in sync with the source of truth.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Whether you’re running a simple workload or managing complex deployments across multiple environments, Argo CD Image Updater provides a streamlined way to automate image updates, reduce operational overhead, and ensure that your applications are always running with the latest and most secure versions.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Configuration and Setup&lt;br&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In this example implementation, we are using the official argocd-image-updater helm chart, available at: &lt;a href=&#34;https://github.com/argoproj/argo-helm/tree/main/charts/argocd-image-updater&#34;&gt;https://github.com/argoproj/argo-helm/tree/main/charts/argocd-image-updater&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;It is deployed as an argocd application in the same cluster and namespace as Argo CD:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;apiVersion: argoproj.io/v1alpha1&#xA;kind: Application&#xA;metadata:&#xA;&amp;nbsp; name: argocd-image-updater&#xA;&amp;nbsp; namespace: argocd&#xA;spec:&#xA;&amp;nbsp; destination:&#xA;&amp;nbsp; &amp;nbsp; namespace: argocd&#xA;&amp;nbsp; &amp;nbsp; server: https://kubernetes.default.svc&#xA;&amp;nbsp; project: &#39;applications&#39;&#xA;&amp;nbsp; source:&#xA;&amp;nbsp; &amp;nbsp; helm:&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; valueFiles:&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; - ../argocd-image-updater/values.yaml&#xA;&amp;nbsp; &amp;nbsp; path: helm/argocd-image-updater&#xA;&amp;nbsp; &amp;nbsp; repoURL: https://gitlab.org.com/demo.git&#xA;&amp;nbsp; &amp;nbsp; targetRevision: HEAD&#xA;&amp;nbsp; syncPolicy:&#xA;&amp;nbsp; &amp;nbsp; automated:&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; prune: true&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; selfHeal: true&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; allowEmpty: false&#xA;&amp;nbsp; &amp;nbsp; syncOptions:&#xA;&amp;nbsp; revisionHistoryLimit: 3&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Let’s review the values file, where we’ll explore some of the essential configuration options required. These options are critical to ensuring proper functionality and deployment of the service.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Registries&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Here we will configure the container registries that we are using. Argo CD Image Updater supports the majority of container registries (public and private), that implement Docker registry v2 API and has been tested against registries such as Docker Hub, Docker Registry v2 reference implementation (on-premise), Red Had Quay, Jfrog Artifactory, Github Container Registry, GitHub Packages Registry, GitLab Container Registry and Google Container Registry.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In the following examples, we will configure two of the most widely used container registries – Amazon Elastic Container Registry (ECR) and GitHub Container Registry (GHCR). In our case, we are working with private registries to ensure secure storage and access control for container images.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Amazon Elastic Container Registry (ECR) configuration:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;registries:&#xA;&amp;nbsp; - name: ECR&#xA;&amp;nbsp; &amp;nbsp; api_url: https://000000000000.dkr.ecr.eu-west-1.amazonaws.com&#xA;&amp;nbsp; &amp;nbsp; prefix: 000000000000.dkr.ecr.eu-west-1.amazonaws.com&#xA;&amp;nbsp; &amp;nbsp; ping: yes&#xA;&amp;nbsp; &amp;nbsp; insecure: false&#xA;&amp;nbsp; &amp;nbsp; credentials: ext:/scripts/login.sh&#xA;&amp;nbsp; &amp;nbsp; credsexpire: 10h&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;For Amazon Elastic Container Registry, authentication is possible through a script that executes an API call to retrieve the necessary credentials. In the values file, we can include this script in the authScripts section:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;authScripts:&#xA;  # -- Whether to mount the defined scripts that can be used to authenticate with a registry, the scripts will be mounted at `/scripts`&#xA;  enabled: true&#xA;  # -- Map of key-value pairs where the key consists of the name of the script and the value the contents&#xA;  scripts:&#xA;    login.sh: |&#xA;      #!/bin/sh&#xA;      aws ecr --region &#34;eu-west-1&#34; get-authorization-token --output text --query &#39;authorizationData[].authorizationToken&#39; | base64 -d&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The script is executed by the pod and is responsible for obtaining the ECR authorization token. We use a role attached to our EKS node group, which includes the AWS-managed policy AmazonEC2ContainerRegistryReadOnly. This policy permits the GetAuthorizationToken API call:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;{&#xA;&amp;nbsp; &amp;nbsp; &#34;Version&#34;: &#34;2012-10-17&#34;,&#xA;&amp;nbsp; &amp;nbsp; &#34;Statement&#34;: [&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &#34;Effect&#34;: &#34;Allow&#34;,&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &#34;Action&#34;: [&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &#34;ecr:GetAuthorizationToken&#34;,&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &#34;ecr:BatchCheckLayerAvailability&#34;,&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &#34;ecr:GetDownloadUrlForLayer&#34;,&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &#34;ecr:GetRepositoryPolicy&#34;,&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &#34;ecr:DescribeRepositories&#34;,&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &#34;ecr:ListImages&#34;,&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &#34;ecr:DescribeImages&#34;,&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &#34;ecr:BatchGetImage&#34;,&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &#34;ecr:GetLifecyclePolicy&#34;,&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &#34;ecr:GetLifecyclePolicyPreview&#34;,&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &#34;ecr:ListTagsForResource&#34;,&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &#34;ecr:DescribeImageScanFindings&#34;&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ],&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &#34;Resource&#34;: &#34;*&#34;&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;GitHub Container Registry configuration:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;registries:&#xA;&amp;nbsp; - name: GitHub Container Registry&#xA;&amp;nbsp; &amp;nbsp; api_url: https://ghcr.io&#xA;&amp;nbsp; &amp;nbsp; prefix: ghcr.io&#xA;&amp;nbsp; &amp;nbsp; ping: yes&#xA;&amp;nbsp; &amp;nbsp; credentials: secret:argocd/ghcr-secret#token&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;For registry authentication, in the credentials section, we are using Kubernetes secret. The #token part refers to the specific key (usually containing a personal access token or authentication token) inside the secret. The token must have at least read:packages permissions. Here is a manifest of the Kubernetes secret which has to be applied in the argocd namespace:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;apiVersion: v1&#xA;kind: Secret&#xA;metadata:&#xA;  name: ghcr-secret3&#xA;  namespace: argocd&#xA;stringData:&#xA;  token: user_name:access_token&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Enabling the service account and RBAC creation:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;rbac:&#xA;&amp;nbsp; &lt;em&gt;# -- Enable RBAC creation&lt;/em&gt;&#xA;&amp;nbsp; enabled: true&#xA;&#xA;serviceAccount:&#xA;&amp;nbsp; &lt;em&gt;# -- Specifies whether a service account should be created&lt;/em&gt;&#xA;&amp;nbsp; create: true&#xA;&amp;nbsp; &lt;em&gt;# -- Annotations to add to the service account&lt;/em&gt;&#xA;&amp;nbsp; annotations: {}&#xA;&amp;nbsp; &lt;em&gt;# -- Labels to add to the service account&lt;/em&gt;&#xA;&amp;nbsp; labels: {}&#xA;&amp;nbsp; &lt;em&gt;# -- The name of the service account to use.&lt;/em&gt;&#xA;&amp;nbsp; &lt;em&gt;# If not set and create is true, a name is generated using the fullname template&lt;/em&gt;&#xA;&amp;nbsp; name: &#34;&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;ServiceAccount provides the necessary identity for ArgoCD Image Updater to authenticate and interact with the Kubernetes API in order to perform updates on deployment manifests or Helm charts (e.g., changing container image tags).&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;rbac ensures that ArgoCD Image Updater is granted only the permissions it needs, helping to secure your cluster by restricting its access and reducing the attack surface.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Without enabling both, the ArgoCD Image Updater would either lack the permissions to modify Kubernetes resources (failing to update your applications) or could have overly broad permissions, which could be a security risk.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In the default installation scenario, i.e. Argo CD Image Updater installed to the argocd namespace, no further configuration has to be done for Argo CD Image Updater to access the Kubernetes API. If your Argo CD installation is in a different namespace than argocd, you would have to adapt the RoleBinding to bind to the ServiceAccount in the correct namespace.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Log Level:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;&lt;em&gt;# -- Argo CD Image Update log level&lt;/em&gt;&#xA;&amp;nbsp; logLevel: &#34;debug&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Changing the log level from “info” to “debug” in the Argo CD Image Updater values file can be beneficial in certain scenarios where you need deeper insights into the system’s behavior.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Argo CD Image Updater binary:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The argocd-image-updater binary and specifically the test subcommand provides a variety of test options including testing registry access, multi-arch images, semver constrains, update strategies, and credentials before configuring annotations on your Argo CD applications. It is available in the argocd-image-updater pod or you can install it locally. Here are the argocd-image-updater test command options:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;Flags:&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; --allow-tags string &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; only consider tags &lt;strong&gt;in&lt;/strong&gt; registry that satisfy the match &lt;strong&gt;function&lt;/strong&gt;&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; --credentials string&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; the credentials definition &lt;strong&gt;for&lt;/strong&gt; the test (overrides registry config)&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; --disable-kubernetes&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; whether to disable the Kubernetes client&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; --disable-kubernetes-events &amp;nbsp; &amp;nbsp; Disable kubernetes events&#xA;&amp;nbsp; -h, --help&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; help &lt;strong&gt;for&lt;/strong&gt; test&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; --ignore-tags stringArray &amp;nbsp; &amp;nbsp; &amp;nbsp; ignore tags &lt;strong&gt;in&lt;/strong&gt; registry that match given glob pattern&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; --kubeconfig string &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; path to your Kubernetes client configuration&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; --loglevel string &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log level to use (one of trace, debug, info, warn, error) (default &#34;debug&#34;)&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; --platforms strings &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; limit images to given platforms (default [linux/amd64])&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; --rate-limit int&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; specificy registry rate limit (overrides registry.conf) (default 20)&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; --registries-conf-path string &amp;nbsp; path to registries configuration&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; --semver-constraint string&amp;nbsp; &amp;nbsp; &amp;nbsp; only consider tags matching semantic version constraint&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; --update-strategy string&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; update strategy to use, one of: semver, latest) (default &#34;semver&#34;)&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Update methods&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Argo CD Image Updater supports two write-back methods for propagating new image versions to Argo CD:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;argocd : Directly modifies the Argo CD application resource via Kubernetes or the Argo CD API, depending on the configuration.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;git : Creates a Git commit in the application’s repository with the updated image information.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The write-back method and its configuration are set per application, with further configuration options available depending on the method used.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In this article, the examples are applied using the argocd update method, which is the default update method and does not need further configuration. For production environments, it is recommended to use the git update method to persist the changes made by Argo CD Image Updater in your git repository.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Update strategies&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;An update strategy specifies how Argo CD Image Updater identifies new image versions for updates. It supports various strategies for tracking and updating configured images. Each image can have its update strategy, with the default being the semver strategy.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The currently supported update strategies are:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;• semver: Updates based on semantic versioning.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;• latest: Updates to the most recently built image in the registry.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;• digest: Updates to the latest version of a tag using its SHA digest.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;• name: Sorts tags alphabetically and updates to the highest version&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In the examples below we show how to annotate our argocd applications in order to enable Argo CD Image Updater, setting up all update strategies. We are using an umbrella helm chart to deploy our sample application. For Helm applications with multiple images in the manifest or when parameters other than image.name and image.tag are used to define images, you need to configure an &amp;lt;image_alias&amp;gt; in the image specification. This alias helps identify the image and enables the Ago CD Image Updater:&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;argocd-image-updater.argoproj.io/image-list: &#34;&amp;lt;image_alias&amp;gt;=&amp;lt;some/image&amp;gt;&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;semver update strategy :&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This is the default update strategy. Via semver strategy Argo CD Image Updater operates with images tagged in semantic versioning format. Tags should include semver-compatible identifiers in the structure X.Y.Z, where X, Y, and Z are whole numbers. An optional prefix of “v” (for example, vX.Y.Z) can be used, and both formats are considered equivalent. In this first example each annotation is specifically explained because we are using some of the annotations for semver update strategy in all examples.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Example annotations:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;apiVersion: argoproj.io/v1alpha1&#xA;kind: Application&#xA;metadata:&#xA;&amp;nbsp; name: sampleapp&#xA;&amp;nbsp; namespace: argocd&#xA;&amp;nbsp; annotations:&#xA;&amp;nbsp; &amp;nbsp; argocd-image-updater.argoproj.io/image-list: &#34;sampleapp=0.dkr.ecr.eu-west-1.amazonaws.com/sampleapp:v1.2.x&#34;&#xA;&amp;nbsp; &amp;nbsp; argocd-image-updater.argoproj.io/sampleapp.helm.image-name: &#34;sampleapp.deployment.image.repository&#34;&#xA;&amp;nbsp; &amp;nbsp; argocd-image-updater.argoproj.io/sampleapp.helm.image-tag: &#34;sampleapp.deployment.image.tag&#34;&#xA;&amp;nbsp; &amp;nbsp; argocd-image-updater.argoproj.io/sampleapp.update-strategy: &#34;semver&#34;&#xA;&amp;nbsp; &amp;nbsp; argocd-image-updater.argoproj.io/pull-policy: Always&#xA;&amp;nbsp; &amp;nbsp; argocd-image-updater.argoproj.io/write-back-method: argocd&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;image-list – as we explained earlier, the image-list annotation enables Argo CD Image Updater to operate with the application – for the value we are using sampleapp as alias and we are specifying the image and its tag.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;image-name – we are specifying the image name via its helm values path, where we are defining the image repository&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;image-tag – defines the image tag via its helm values path&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;update-strategy – here we are declaring the desired update strategy&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;pull-policy – specifying the pull-policy, in this case we are always getting the latest version.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;write-back-method – specifying the Argo CD Image Updater write-back-method&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In this scenario, we are using a semantic versioning constraint with the tag v1.2.x. This means that Argo CD Image Updater will look for any image tag that matches the v1.2.x pattern. The x in semantic versioning acts as a wildcard, so the updater will accept any patch-level version within the v1.2 series (e.g., v1.2.1, v1.2.5, v1.2.9, etc.).&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Here is part of the helm values file that we are using for the sampleapp which is connected to the annotations:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;sampleapp:&#xA;&amp;nbsp; appId: sampleapp&#xA;&amp;nbsp; deployment:&#xA;&amp;nbsp; &amp;nbsp; enabled: true&#xA;&amp;nbsp; &amp;nbsp; image:&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; repository: &#34;000000000000.dkr.ecr.eu-west-1.amazonaws.com/sampleapp&#34;&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; tag: &#34;v1.2&#34;&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; digest: true&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; pullPolicy: &#34;Always&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;latest update strategy:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Argo CD Image Updater can update the image with the most recent build date, even if the tag is arbitrary (like a Git commit SHA or random string). It focuses on the build date, not when the image was tagged or pushed to the registry. If multiple tags share the same build date, the updater sorts the tags in descending lexical order and selects the last one.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Example annotations:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;apiVersion: argoproj.io/v1alpha1&#xA;kind: Application&#xA;metadata:&#xA;  name: sampleapp&#xA;  namespace: argocd&#xA;  annotations:&#xA;    argocd-image-updater.argoproj.io/image-list: &#34;sampleapp=0.dkr.ecr.eu-west-1.amazonaws.com/sampleapp&#34;&#xA;    argocd-image-updater.argoproj.io/sampleapp.helm.image-name: &#34;sampleapp.deployment.image.repository&#34;&#xA;    argocd-image-updater.argoproj.io/sampleapp.update-strategy: &#34;latest&#34;&#xA;    argocd-image-updater.argoproj.io/pull-policy: Always&#xA;    argocd-image-updater.argoproj.io/write-back-method: argocd&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In this scenario, we don’t have to specify image-tag. But if we want to allow only particular tags for update we can use the argocd-image-updater.argoproj.io/myimage.allow-tags: annotation, for example with latest and master tags:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;argocd-image-updater.argoproj.io/myimage.allow-tags: latest, master&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;or we can ignore them with the ignore-tags annotation:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;argocd-image-updater.argoproj.io/myimage.ignore-tags: latest, master&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Here is part of the helm values file that we are using for the sampleapp which is connected to the annotations:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;sampleapp:&#xA;&amp;nbsp; appId: sampleapp&#xA;&amp;nbsp; deployment:&#xA;&amp;nbsp; &amp;nbsp; enabled: true&#xA;&amp;nbsp; &amp;nbsp; image:&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; repository: &#34;000000000000.dkr.ecr.eu-west-1.amazonaws.com/sampleapp&#34;&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; tag: &#34;latest&#34; &lt;em&gt;#in this case tag will be ignored&lt;/em&gt;&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; digest: true&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; pullPolicy: &#34;Always&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;digest update strategy:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This update strategy monitors a specified tag in the registry for any changes and updates the image when a difference from the previous state is detected using the image SHA digest. The tag must be defined as a version constraint in the image list. It’s ideal for tracking mutable tags like the latest or environment-specific tags (e.g., dev, stage, prod) generated by a CI system.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Example annotations:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;apiVersion: argoproj.io/v1alpha1&#xA;kind: Application&#xA;metadata:&#xA;&amp;nbsp; name: sampleapp&#xA;&amp;nbsp; namespace: argocd&#xA;&amp;nbsp; annotations:&#xA;&amp;nbsp; &amp;nbsp; argocd-image-updater.argoproj.io/image-list: &#34;sampleapp=0.dkr.ecr.eu-west-1.amazonaws.com/sampleapp:latest&#34;&#xA;&amp;nbsp; &amp;nbsp; argocd-image-updater.argoproj.io/sampleapp.helm.image-name: &#34;sampleapp.deployment.image.repository&#34;&#xA;&amp;nbsp; &amp;nbsp; argocd-image-updater.argoproj.io/sampleapp.helm.image-tag: &#34;sampleapp.deployment.image.tag&#34;&#xA;&amp;nbsp; &amp;nbsp; argocd-image-updater.argoproj.io/sampleapp.update-strategy: &#34;digest&#34;&#xA;&amp;nbsp; &amp;nbsp; argocd-image-updater.argoproj.io/pull-policy: Always&#xA;&amp;nbsp; &amp;nbsp; argocd-image-updater.argoproj.io/write-back-method: argocd&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Here is part of the helm values file that we are using for the sampleapp which is connected to the annotations – the important thing here is to specify the image tag in the format –&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;tag: “tag_name@sha256” :&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;sampleapp:&#xA;&amp;nbsp; appId: sampleapp&#xA;&amp;nbsp; deployment:&#xA;&amp;nbsp; &amp;nbsp; enabled: true&#xA;&amp;nbsp; &amp;nbsp; image:&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; repository: &#34;000000000000.dkr.ecr.eu-west-1.amazonaws.com/sampleapp&#34;&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; tag: &#34;latest@sha256:ef8049179764ee395542a9895dbc3e326b6526116672aea568cfb0a33c0912af&#34;&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; digest: true&#xA;&amp;nbsp; &amp;nbsp; &amp;nbsp; pullPolicy: &#34;Always&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;name update strategy:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This updated strategy sorts image tags lexically in descending order and selects the last tag for updating. It’s useful for tracking images using calver versioning (e.g., YYYY-MM-DD) or similar tags. By default, all tags in the repository are considered, but you can configure it to limit which tags are eligible for updates.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Example annotations:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;apiVersion: argoproj.io/v1alpha1&#xA;kind: Application&#xA;metadata:&#xA;&amp;nbsp; name: sampleapp&#xA;&amp;nbsp; namespace: argocd&#xA;&amp;nbsp; annotations:&#xA;&amp;nbsp; &amp;nbsp; argocd-image-updater.argoproj.io/image-list: &#34;sampleapp=0.dkr.ecr.eu-west-1.amazonaws.com/sampleapp:latest&#34;&#xA;&amp;nbsp; &amp;nbsp; argocd-image-updater.argoproj.io/sampleapp.helm.image-name: &#34;sampleapp.deployment.image.repository&#34;&#xA;&amp;nbsp; &amp;nbsp; argocd-image-updater.argoproj.io/sampleapp.update-strategy: &#34;name&#34;&#xA;&amp;nbsp; &amp;nbsp; argocd-image-updater.argoproj.io/myapp.allow-tags: regexp:^[0-9]{4}-[0-9]{2}-[0-9]{2}-stable$&#xA;&amp;nbsp; &amp;nbsp; argocd-image-updater.argoproj.io/pull-policy: &#34;Always&#34;&#xA;&amp;nbsp; &amp;nbsp; argocd-image-updater.argoproj.io/write-back-method: &#34;argocd&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In this case, if we have tags such as: 2024-09-30-stable, 2024-09-30-beta, 2024-10-01-beta, 2024-10-01-stable, master, latest – Argo CD Image Updater will consider only the “-stable” ending tags, sort them lexically and choose the 2024-10-01-stable tag for the update.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Here is part of the helm values file that we are using for the sampleapp which is connected to the annotations:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;sampleapp:&#xA;  appId: sampleapp&#xA;  deployment:&#xA;    enabled: true&#xA;    image:&#xA;      repository: &#34;000000000000.dkr.ecr.eu-west-1.amazonaws.com/sampleapp&#34;&#xA;      tag: &#34;2024-09-30-stable&#34; #will be ignored in this case&#xA;      digest: true&#xA;      pullPolicy: &#34;Always&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;After we’ve made the needed configurations and selected the most suitable update strategy we can check the Argo CD application’s parameters through the UI:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1249&#34; height=&#34;539&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2024/11/1000014427.jpg&#34; alt=&#34;image&#34; class=&#34;wp-image-120062&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2024/11/1000014427.jpg 1249w, https://www.cncf.io/wp-content/uploads/2024/11/1000014427-300x129.jpg 300w, https://www.cncf.io/wp-content/uploads/2024/11/1000014427-1024x442.jpg 1024w, https://www.cncf.io/wp-content/uploads/2024/11/1000014427-768x331.jpg 768w, https://www.cncf.io/wp-content/uploads/2024/11/1000014427-900x388.jpg 900w, https://www.cncf.io/wp-content/uploads/2024/11/1000014427-463x200.jpg 463w, https://www.cncf.io/wp-content/uploads/2024/11/1000014427-927x400.jpg 927w&#34; sizes=&#34;(max-width: 1249px) 100vw, 1249px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;As we can see, after the new image version was pushed in ECR, the original value of the image tag was changed by the Argo CD image updater, and the new image was deployed!&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In conclusion, the Argo CD Image Updater is a powerful tool that enhances the continuous delivery process in Kubernetes environments. Automating the process of updating container images, not only streamlines deployments but also reduces the risk of human error associated with manual updates.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Moreover, its flexibility allows developers to tailor the update policies to suit their specific workflows, ensuring that only the necessary updates are applied. This ultimately leads to improved application reliability and performance.&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Reference: https://argocd-image-updater.readthedocs.io/en/stable/&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;p&gt;&lt;em&gt;&lt;a href=&#34;https://itgix.com/kubernetes-services/&#34;&gt;ITGix&lt;/a&gt; 的 DevOps 和云工程师 Stanislava Racheva 的成员帖子&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;了解 Argo CD 映像更新程序&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在现代 Kubernetes 环境中，管理容器映像并确保应用程序始终运行最新、最安全的版本可能是一项艰巨的任务。 Argo CD Image Updater 通过自动检查新的容器映像版本并相应地更新您的应用程序来简化此过程。与 Argo CD 无缝集成，可实现 Kubernetes 工作负载的全自动更新。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Argo CD Image Updater 的优点在于它的简单性和灵活性。通过使用映像列表注释您的 Argo CD 应用程序资源并定义版本约束，映像更新程序将接管繁重的工作。它会定期从容器注册表中轮询新的映像版本，检查它们是否满足指定的约束，并自动更新您的应用程序。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Argo CD Image Updater 还提供一系列高级功能，例如对基于 Helm 和 Kustomize 的应用程序的支持、各种更新策略（如 semver、latest、name 和digest）以及与私有容器注册表的无缝集成。此外，它允许并行更新并支持使用自定义匹配器过滤标签，使其高度可定制，并且适用于小型和大型 Kubernetes 环境。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;用例和解决的问题&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;自动保持映像最新&lt;/strong&gt;：对于部署频繁更新映像的团队来说，手动跟踪和更新这些映像可能会导致效率低下和停机。 Argo CD Image Updater 通过自动化整个映像更新过程解决了这个问题。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;版本控制和稳定性&lt;/strong&gt;：有时团队希望坚持特定的版本控制模式（例如 semver）或确保他们只选择稳定的版本。借助 Argo CD Image Updater 的可配置策略，可以轻松执行此类策略并确保应用程序始终在所需版本上运行。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;高效的 GitOps 工作流程&lt;/strong&gt;：通过与 Argo CD 集成，可以将更改写回到 Git，维护 GitOps 核心的声明性模型，并确保应用程序状态和版本控制始终与源同步真理。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;无论您是运行简单的工作负载还是管理跨多个环境的复杂部署，Argo CD Image Updater 都提供了一种简化的方法来自动执行映像更新、减少运营开销并确保您的应用程序始终以最新、最安全的版本运行版本。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;配置和设置&lt;br&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在此示例实现中，我们使用官方 argocd-image-updater helm 图表，可从以下位置获取：&lt;a href=&#34;https://github.com/argoproj/argo-helm/tree/main/charts/argocd-image-updater&#34;&gt;https://github.com/argoproj/argo-helm/tree/main/charts/argocd-image-updater&lt;/a&gt;&lt;/ p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;它作为 argocd 应用程序部署在与 Argo CD 相同的集群和命名空间中：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;api版本：argoproj.io/v1alpha1&#xA;种类： 应用&#xA;元数据：&#xA;  名称： argocd-image-updater&#xA;  命名空间：argocd&#xA;规格：&#xA;  目的地：&#xA;    命名空间：argocd&#xA;    服务器：https://kubernetes.default.svc&#xA;  项目：“应用程序”&#xA;  来源：&#xA;    舵：&#xA;      值文件：&#xA;      - ../argocd-image-updater/values.yaml&#xA;    路径：helm/argocd-image-updater&#xA;    仓库地址：https://gitlab.org.com/demo.git&#xA;    目标修订：HEAD&#xA;  同步策略：&#xA;    自动化：&#xA;      修剪：真实&#xA;      自我修复：正确&#xA;      允许空：假&#xA;    同步选项：&#xA;  revisionHistoryLimit: 3 &lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;让我们回顾一下值文件，我们将在其中探索一些所需的基本配置选项。这些选项对于确保服务的正常功能和部署至关重要。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;注册表&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在这里，我们将配置我们正在使用的容器注册表。 Argo CD Image Updater 支持大多数容器注册表（公共和私有），这些注册表实现了 Docker 注册表 v2 API，并已针对 Docker Hub、Docker 注册表 v2 参考实现（本地）、Red Had Quay、Jfrog Artifactory 等注册表进行了测试、Github 容器注册表、GitHub 包注册表、GitLab 容器注册表和 Google 容器注册表。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在以下示例中，我们将配置两个最广泛使用的容器注册表 - Amazon Elastic ContainerRegistry (ECR) 和 GitHub ContainerRegistry (GHCR)。就我们而言，我们正在与私有注册表合作，以确保容器映像的安全存储和访问控制。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Amazon Elastic Container Registry (ECR) 配置：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;注册表：&#xA;  - 名称：ECR&#xA;    api_url：https://000000000000.dkr.ecr.eu-west-1.amazonaws.com&#xA;    前缀：000000000000.dkr.ecr.eu-west-1.amazonaws.com&#xA;    平：是的&#xA;    不安全：假&#xA;    凭据： ext:/scripts/login.sh&#xA;    凭证过期：10h&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;对于 Amazon Elastic Container Registry，可以通过执行 API 调用来检索必要凭证的脚本进行身份验证。在值文件中，我们可以将此脚本包含在 authScripts 部分中：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;authScripts：&#xA;  # -- 是否挂载定义的可用于注册中心认证的脚本，脚本将挂载在 `/scripts`&#xA;  启用：真&#xA;  # -- 键值对映射，其中键由脚本名称组成以及内容的价值&#xA;  脚本：&#xA;    登录.sh: |&#xA;      #!/bin/sh&#xA;      aws ecr --region &#34;eu-west-1&#34; get-authorization-token --output text --query &#39;authorizationData[].authorizationToken&#39; | base64 -d&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;该脚本由 pod 执行，负责获取 ECR 授权令牌。我们使用附加到 EKS 节点组的角色，其中包括 AWS 托管策略 AmazonEC2ContainerRegistryReadOnly。此策略允许 GetAuthorizationToken API 调用：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;{&#xA;    &#34;版本&#34;: &#34;2012-10-17&#34;,&#xA;    “陈述”： [&#xA;        {&#xA;            &#34;效果&#34;: &#34;允许&#34;,&#xA;            “行动”： [&#xA;                “ecr：获取授权令牌”，&#xA;                “ecr：批量检查图层可用性”，&#xA;                “ecr：GetDownloadUrlForLayer”，&#xA;                “ecr：获取存储库策略”，&#xA;                “ecr：描述存储库”，&#xA;                “ecr：列表图像”，&#xA;                “ecr：描述图像”，&#xA;                “ecr：批量获取图像”，&#xA;                “ecr：获取生命周期策略”，&#xA;                “ecr：获取生命周期策略预览”，&#xA;                “ecr：ListTagsForResource”，&#xA;                “ecr：描述图像扫描结果”&#xA;            ],&#xA;            “资源”：“*”&#xA;        }&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;GitHub 容器注册表配置：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;注册表：&#xA;  - 名称：GitHub 容器注册表&#xA;    api_url：https://ghcr.io&#xA;    前缀：ghcr.io&#xA;    平：是的&#xA;    凭据：秘密：argocd/ghcr-secret#token&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;对于注册表身份验证，在凭据部分，我们使用 Kubernetes 密钥。 #token 部分指的是机密内的特定密钥（通常包含个人访问令牌或身份验证令牌）。该令牌必须至少具有 read:packages 权限。以下是必须在 argocd 命名空间中应用的 Kubernetes 秘密的清单：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;api版本：v1&#xA;种类：秘密&#xA;元数据：&#xA;  名称：ghcr-secret3&#xA;  命名空间：argocd&#xA;字符串数据：&#xA;  令牌：用户名：access_token&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;启用服务帐户和 RBAC 创建：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;rbac：&#xA;  &lt;em&gt;# -- 启用 RBAC 创建&lt;/em&gt;&#xA;  启用：真&#xA;&#xA;服务帐号：&#xA;  &lt;em&gt;# --指定是否应创建服务帐户&lt;/em&gt;&#xA;  创建：真实&#xA;  &lt;em&gt;# -- 添加到服务帐户的注释&lt;/em&gt;&#xA;  注释：{}&#xA;  &lt;em&gt;# -- 添加到服务帐户的标签&lt;/em&gt;&#xA;  标签：{}&#xA;  &lt;em&gt;# -- 要使用的服务帐户的名称。&lt;/em&gt;&#xA;  &lt;em&gt;# 如果未设置且 create 为 true，则使用全名模板生成名称&lt;/em&gt;&#xA;  名称：“”&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;ServiceAccount 为 ArgoCD 映像更新程序提供必要的身份，以进行身份​​验证并与 Kubernetes API 交互，以便对部署清单或 Helm 图表执行更新（例如，更改容器映像标签）。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;rbac 确保 ArgoCD Image Updater 仅被授予其所需的权限，从而通过限制其访问并减少攻击面来帮助保护您的集群。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果不启用两者，ArgoCD 映像更新程序将缺乏修改 Kubernetes 资源的权限（无法更新应用程序），或者可能拥有过于广泛的权限，这可能会带来安全风险。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在默认安装场景中，即 Argo CD Image Updater 安装到 argocd 命名空间，Argo CD Image Updater 无需进行进一步配置即可访问 Kubernetes API。如果您的 Argo CD 安装与 argocd 位于不同的命名空间中，则必须调整 RoleBinding 以绑定到正确命名空间中的 ServiceAccount。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;日志级别：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;&lt;em&gt;# -- Argo CD 镜像更新日志级别&lt;/em&gt;&#xA;  日志级别：“调试”&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在某些需要更深入了解系统行为的情况下，将 Argo CD 映像更新程序值文件中的日志级别从“信息”更改为“调试”可能会很有帮助。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Argo CD 映像更新程序二进制文件：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;argocd-image-updater 二进制文件，特别是 test 子命令提供了各种测试选项，包括在 Argo CD 应用程序上配置注释之前测试注册表访问、多架构映像、semver 约束、更新策略和凭据。它可以在 argocd-image-updater pod 中找到，也可以在本地安装。以下是 argocd-image-updater 测试命令选项：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;标志：&#xA;      --allow-tags string             只考虑注册表中满足匹配&lt;strong&gt;函数&lt;/strong&gt;的标签&#xA;      --credentials string            测试的凭证定义（覆盖注册表配置）&#xA;      --disable-kubernetes            是否禁用 Kubernetes 客户端&#xA;      --disable-kubernetes-events 禁用 kubernetes 事件&#xA;  -h, --help                   &amp;nbsp;       帮助&lt;strong&gt;用于&lt;/strong&gt;测试&#xA;      --ignore-tags stringArray       忽略注册表中与给定 glob 模式匹配的标签&#xA;      --kubeconfig string             Kubernetes 客户端配置的路径&#xA;      --loglevel string               使用的日志级别（跟踪、调试、信息、警告、错误之一）（默认“调试”）&#xA;      --platforms strings             将图像限制为给定平台（默认 [linux/amd64]）&#xA;      --rate-limit int                特定注册表速率限制（覆盖registry.conf）（默认 20）&#xA;      --registries-conf-path string 注册表配置的路径&#xA;      --semver-constraint string 只考虑与语义版本约束匹配的标签&#xA;      --update-strategy string        更新要使用的策略，其中之一：semver、latest）（默认“semver”）&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;更新方法&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Argo CD 映像更新程序支持两种回写方法，用于将新映像版本传播到 Argo CD：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;argocd：根据配置，通过 Kubernetes 或 Argo CD API 直接修改 Argo CD 应用程序资源。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;git：使用更新的图像信息在应用程序的存储库中创建 Git 提交。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;回写方法及其配置是根据应用程序设置的，根据所使用的方法，可以使用更多配置选项。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;本文中的示例使用argocd更新方法进行应用，该方法是默认的更新方法，不需要进一步配置。对于生产环境，建议使用 git update 方法将 Argo CD Image Updater 所做的更改保存到 git 存储库中。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;更新策略&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;更新策略指定 Argo CD Image Updater 如何识别新的映像版本以进行更新。它支持跟踪和更新配置图像的各种策略。每个镜像都可以有自己的更新策略，默认是semver策略。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;当前支持的更新策略有：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;    • semver：基于语义版本控制的更新。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;    • 最新：更新到注册表中最新构建的映像。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;    • 摘要：使用 SHA 摘要更新到标签的最新版本。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;    • name：按字母顺序对标签进行排序并更新到最高版本&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在下面的示例中，我们展示了如何注释我们的 argocd 应用程序，以启用 Argo CD 映像更新程序，设置所有更新策略。我们正在使用伞式 Helm Chart 来部署我们的示例应用程序。对于清单中包含多个镜像的 Helm 应用，或者使用除 image.name 和 image.tag 以外的参数来定义镜像时，您需要在镜像规范中配置 &lt;image_alias&gt;。此别名有助于识别映像并启用 Ago CD 映像更新程序：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;argocd-image-updater.argoproj.io/image-list：“&lt;image_alias&gt;=&lt;some/image&gt;”&lt;/code&gt;&lt;/上一篇&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;semver更新策略：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这是默认的更新策略。通过 semver 策略，Argo CD Image Updater 使用以语义版本控制格式标记的图像进行操作。标签应在 X.Y.Z 结构中包含与 semver 兼容的标识符，其中 X、Y 和 Z 是整数。可以使用可选的前缀“v”（例如，vX.Y.Z），并且两种格式被认为是等效的。在第一个示例中，每个注释都得到了具体解释，因为我们在所有示例中都使用了 semver 更新策略的一些注释。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;注释示例：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;api版本：argoproj.io/v1alpha1&#xA;种类： 应用&#xA;元数据：&#xA;  名称：示例应用程序&#xA;  命名空间：argocd&#xA;  注释：&#xA;    argocd-image-updater.argoproj.io/image-list：“sampleapp=0.dkr.ecr.eu-west-1.amazonaws.com/sampleapp:v1.2.x”&#xA;    argocd-image-updater.argoproj.io/sampleapp.helm.image-name：“sampleapp.deployment.image.repository”&#xA;    argocd-image-updater.argoproj.io/sampleapp.helm.image-tag：“sampleapp.deployment.image.tag”&#xA;    argocd-image-updater.argoproj.io/sampleapp.update-strategy：“semver”&#xA;    argocd-image-updater.argoproj.io/pull-policy：始终&#xA;    argocd-image-updater.argoproj.io/write-back-method：argocd&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;image-list - 正如我们之前所解释的，image-list 注释使 Argo CD Image Updater 能够与应用程序一起操作 - 对于我们使用 exampleapp 作为别名的值，我们指定图像及其标签。&lt;/p &gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;image-name – 我们通过其 helm 值路径指定图像名称，我们在其中定义图像存储库&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;image-tag – 通过其 helm 值路径定义图像标签&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;更新策略 - 在这里我们声明所需的更新策略&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;pull-policy – 指定pull-policy，在这种情况下我们总是获得最新版本。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;回写方法 – 指定 Argo CD 映像更新程序回写方法&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在此场景中，我们使用带有标签 v1.2.x 的语义版本控制约束。这意味着 Argo CD 映像更新程序将查找与 v1.2.x 模式匹配的任何映像标签。语义版本控制中的 x 充当通配符，因此更新程序将接受 v1.2 系列中的任何补丁级别版本（例如 v1.2.1、v1.2.5、v1.2.9 等）。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这是我们用于示例应用程序的 helm 值文件的一部分，它是 c连接到注释：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;示例应用程序：&#xA;  应用程序 ID：示例应用程序&#xA;  部署：&#xA;    启用：真&#xA;    图像：&#xA;      存储库：“000000000000.dkr.ecr.eu-west-1.amazonaws.com/sampleapp”&#xA;      标签：“v1.2”&#xA;      摘要：真实&#xA;      pullPolicy：“始终”&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;最新更新策略：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Argo CD 映像更新程序可以使用最新的构建日期更新映像，即使标记是任意的（例如 Git 提交 SHA 或随机字符串）。它关注的是构建日期，而不是图像被标记或推送到注册表的时间。如果多个标签共享相同的构建日期，更新程序将按词汇降序对标签进行排序并选择最后一个。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;注释示例：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;api版本：argoproj.io/v1alpha1&#xA;种类： 应用&#xA;元数据：&#xA;  名称：示例应用程序&#xA;  命名空间：argocd&#xA;  注释：&#xA;    argocd-image-updater.argoproj.io/image-list：“sampleapp=0.dkr.ecr.eu-west-1.amazonaws.com/sampleapp”&#xA;    argocd-image-updater.argoproj.io/sampleapp.helm.image-name：“sampleapp.deployment.image.repository”&#xA;    argocd-image-updater.argoproj.io/sampleapp.update-strategy：“最新”&#xA;    argocd-image-updater.argoproj.io/pull-policy：始终&#xA;    argocd-image-updater.argoproj.io/write-back-method：argocd&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在这种情况下，我们不必指定图像标签。但是，如果我们只想允许特定标签进行更新，我们可以使用 argocd-image-updater.argoproj.io/myimage.allow-tags: 注释，例如使用最新标签和主标签：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;argocd-image-updater.argoproj.io/myimage.allow-tags：最新，主&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;或者我们可以使用ignore-tags注释忽略它们：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;argocd-image-updater.argoproj.io/myimage.ignore-tags：最新，主&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这是我们用于连接到注释的示例应用程序的 helm 值文件的一部分：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;示例应用程序：&#xA;  应用程序 ID：示例应用程序&#xA;  部署：&#xA;    启用：真&#xA;    图像：&#xA;      存储库：“000000000000.dkr.ecr.eu-west-1.amazonaws.com/sampleapp”&#xA;      标签：“最新”&lt;em&gt;#在这种情况下标签将被忽略&lt;/em&gt;&#xA;      摘要：真实&#xA;      pullPolicy：“始终”&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;摘要更新策略：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此更新策略监视注册表中指定标记的任何更改，并在使用映像 SHA 摘要检测到与先前状态的差异时更新映像。该标签必须定义为图像列表中的版本约束。它非常适合跟踪 CI 系统生成的可变标签，例如最新的或特定于环境的标签（例如 dev、stage、prod）。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;注释示例：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;apiVers离子：argoproj.io/v1alpha1&#xA;种类： 应用&#xA;元数据：&#xA;  名称：示例应用程序&#xA;  命名空间：argocd&#xA;  注释：&#xA;    argocd-image-updater.argoproj.io/image-list：“sampleapp=0.dkr.ecr.eu-west-1.amazonaws.com/sampleapp:latest”&#xA;    argocd-image-updater.argoproj.io/sampleapp.helm.image-name：“sampleapp.deployment.image.repository”&#xA;    argocd-image-updater.argoproj.io/sampleapp.helm.image-tag：“sampleapp.deployment.image.tag”&#xA;    argocd-image-updater.argoproj.io/sampleapp.update-strategy：“摘要”&#xA;    argocd-image-updater.argoproj.io/pull-policy：始终&#xA;    argocd-image-updater.argoproj.io/write-back-method：argocd&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这是我们用于连接到注释的示例应用程序的 helm 值文件的一部分 - 这里重要的是以格式指定图像标签 - &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;标签：“tag_name@sha256”：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;示例应用程序：&#xA;  应用程序 ID：示例应用程序&#xA;  部署：&#xA;    启用：真&#xA;    图像：&#xA;      存储库：“000000000000.dkr.ecr.eu-west-1.amazonaws.com/sampleapp”&#xA;      标签：“最新@sha256：ef8049179764ee395542a9895dbc3e326b6526116672aea568cfb0a33c0912af”&#xA;      摘要：真实&#xA;      pullPolicy：“始终”&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;名称更新策略：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此更新策略按词法降序对图像标签进行排序，并选择最后一个标签进行更新。它对于使用 calver 版本控制（例如，YYYY-MM-DD）或类似标签来跟踪图像非常有用。默认情况下，会考虑存储库中的所有标签，但您可以将其配置为限制哪些标签有资格更新。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;注释示例：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;api版本：argoproj.io/v1alpha1&#xA;种类： 应用&#xA;元数据：&#xA;  名称：示例应用程序&#xA;  命名空间：argocd&#xA;  注释：&#xA;    argocd-image-updater.argoproj.io/image-list：“sampleapp=0.dkr.ecr.eu-west-1.amazonaws.com/sampleapp:latest”&#xA;    argocd-image-updater.argoproj.io/sampleapp.helm.image-name：“sampleapp.deployment.image.repository”&#xA;    argocd-image-updater.argoproj.io/sampleapp.update-strategy：“名称”&#xA;    argocd-image-updater.argoproj.io/myapp.allow-tags：正则表达式：^[0-9]{4}-[0-9]{2}-[0-9]{2}-stable$&#xA;    argocd-image-updater.argoproj.io/pull-policy：“始终”&#xA;    argocd-image-updater.argoproj.io/write-back-method: &#34;argocd&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在这种情况下，如果我们有以下标签：2024-09-30-stable、2024-09-30-beta、2024-10-01-beta、2024-10-01-stable、master、latest – Argo CD 映像更新程序将仅考虑“-stable”结束标签，按词法对它们进行排序，并选择 2024-10-01-stable 标签进行更新。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这是我们用于连接到注释的示例应用程序的 helm 值文件的一部分：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;示例应用程序：&#xA;  应用程序ID： 示例应用程序&#xA;  部署：&#xA;    启用：真&#xA;    图像：&#xA;      存储库：“000000000000.dkr.ecr.eu-west-1.amazonaws.com/sampleapp”&#xA;      tag: &#34;2024-09-30-stable&#34; #在这种情况下将被忽略&#xA;      摘要：真实&#xA;      pullPolicy：“始终”&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;完成所需的配置并选择最合适的更新策略后，我们可以通过 UI 检查 Argo CD 应用程序的参数：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“1249”高度=“539”src=“https://www.cncf.io/ wp-content/uploads/2024/11/1000014427.jpg&#34; alt=&#34;image&#34; class=&#34;wp-image-120062&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2024/11 /1000014427.jpg 1249w，https://www.cncf.io/wp-content/uploads/2024/11/1000014427-300x129.jpg 300w，https://www.cncf.io/wp-content/uploads/2024 /11/1000014427-1024x442.jpg 1024w，https://www.cncf.io/wp-content/uploads/2024/11/1000014427-768x331.jpg 768w，https://www.cncf.io/wp-content /uploads/2024/11/1000014427-900x388.jpg 900w，https://www.cncf.io/wp-content/uploads/2024/11/1000014427-463x200.jpg 463w，https://www.cncf.io /wp-content/uploads/2024/11/1000014427-927x400.jpg 927w”尺寸=“（最大宽度：1249px）100vw，1249px”referrerpolicy=“no-referrer”&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我们可以看到，在ECR中推送新的镜像版本后，Argo CD镜像更新程序更改了镜像标签的原始值，并部署了新镜像！&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;总而言之，Argo CD Image Updater 是一个强大的工具，可以增强 Kubernetes 环境中的持续交付流程。自动化更新容器映像的过程不仅简化了部署，还降低了与手动更新相关的人为错误风险。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此外，它的灵活性允许开发人员定制更新策略以适应其特定的工作流程，确保仅应用必要的更新。这最终会提高应用程序的可靠性和性能。   &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;参考：https://argocd-image-updater.readthedocs.io/en/stable/                                     &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Mon, 04 Nov 2024 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【What Karpenter v1.0.0 means for Kubernetes autoscaling】Karpenter v1.0.0 对 Kubernetes 自动缩放意味着什么</title>
      <link>https://www.cncf.io/blog/2024/11/06/karpenter-v1-0-0-beta/</link>
      <description>【&lt;p&gt;&lt;em&gt;Member post by Rajdeep Saha, Principal Solutions Architect, AWS and Praseeda Sathaye, Principal SA, Containers &amp;amp; OSS, AWS&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Introduction&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;br&gt;&lt;a href=&#34;https://karpenter.sh/&#34;&gt;Karpenter&lt;/a&gt;&amp;nbsp;is an&amp;nbsp;open-source project that provides node lifecycle management to optimize the efficiency and cost of running workloads on Kubernetes clusters. &amp;nbsp;AWS created and open sourced Karpenter in 2021 to help automate how customers select, provision, and scale infrastructure in their clusters and provide more flexibility for Kubernetes users to take full advantage of unique infrastructure offerings across different cloud providers.&amp;nbsp;In 2023, the &lt;a href=&#34;https://aws.amazon.com/blogs/containers/karpenter-graduates-to-beta/&#34;&gt;project graduated to beta&lt;/a&gt;, and AWS &lt;a href=&#34;https://github.com/kubernetes/org/issues/4258&#34;&gt;contributed&lt;/a&gt; the vendor-neutral core of the project to the Cloud Native Computing Foundation (CNCF) through the Kubernetes Autoscaling Special Interest Group&amp;nbsp;(SIG). In 2024, AWS &lt;a href=&#34;https://aws.amazon.com/blogs/containers/announcing-karpenter-1-0/&#34;&gt;released Karpenter version 1.0.0&lt;/a&gt; that marks the final milestone in the project’s maturity. With this release, all Karpenter APIs will remain available in future 1.0 minor versions and will not be modified in ways that results in breaking changes. &lt;a href=&#34;https://github.com/kubernetes-sigs/karpenter&#34;&gt;Karpenter is available as open-source&lt;/a&gt; software (OSS) under an Apache 2.0 license. It separates the generic logic for Kubernetes application-awareness and workload binpacking from the creation and running of API requests to launch or terminate compute resources for a given cloud provider.&amp;nbsp;By developing cloud provider-specific integrations that interact with their respective compute APIs, Karpenter enables individual cloud providers such as AWS, Azure, GCP, and others to leverage its capabilities within their respective environments. In 2023&amp;nbsp;Microsoft released&amp;nbsp;&lt;a href=&#34;https://github.com/Azure/karpenter-provider-azure&#34;&gt;Karpenter Provider&lt;/a&gt; for running Karpenter on Azure Kubernetes Service (AKS).&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Today, Karpenter has gained widespread popularity within the Kubernetes community, with a diverse range of organizations and enterprises using its capabilities to help improve application availability, lower operational overhead, and increase cost-efficiency.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;How Karpenter works&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;br&gt;Karpenter’s job in a Kubernetes cluster is to make application and Kubernetes-aware compute capacity decisions. It is built as a Kubernetes Operator, runs in the Kubernetes cluster, and manages cluster compute infrastructure. There are two kinds of decisions Karpenter makes: to provision new compute and to deprovision that compute when it’s no longer needed.&amp;nbsp;Karpenter works by watching for pods that the Kubernetes scheduler has marked as unschedulable, evaluating scheduling constraints (resource requests, node-selectors, affinities, tolerations, and topology spread constraints) requested by the pods, provisioning nodes that meet the requirements of the pods, and deprovisioning&amp;nbsp;the nodes when the nodes are no longer needed.&amp;nbsp;Karpenter’s workload consolidation feature proactively identifies and reschedules underused workloads onto a more cost-efficient set of instances, either by reusing existing instances within the cluster or by launching new, optimized instances, thereby maximizing resource usage and minimizing operational costs.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;844&#34; height=&#34;406&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2024/10/Picture-1.jpg&#34; alt=&#34;Figure 1: Karpenter provisions node(s) in response to pending unschedulable pods&#34; class=&#34;wp-image-119446&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2024/10/Picture-1.jpg 844w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-1-300x144.jpg 300w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-1-768x369.jpg 768w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-1-416x200.jpg 416w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-1-832x400.jpg 832w&#34; sizes=&#34;(max-width: 844px) 100vw, 844px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;figcaption class=&#34;wp-element-caption&#34;&gt;Figure 1: Karpenter provisions node(s) in response to pending unschedulable pods&lt;/figcaption&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karpenter scaling is controlled using Kubernetes native YAMLs, specifically through the use of &lt;a href=&#34;https://karpenter.sh/docs/concepts/nodepools/&#34;&gt;NodePool&lt;/a&gt; and &lt;a href=&#34;https://karpenter.sh/docs/concepts/nodeclasses/&#34;&gt;NodeClass&lt;/a&gt; custom Kubernetes resources.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;NodePools set&amp;nbsp;constraints on the&amp;nbsp;nodes that Karpenter provisions in the Kubernetes cluster. Each NodePool defines requirements such as instance types, availability zones, architectures (for example AMD64 or ARM64), capacity types (spot or on-demand), and other node settings that apply to all the nodes launched in the NodePool. It also allows setting limits on total resources such as CPU, memory, and GPUs that the NodePool can consume. The following is an example of NodePool configuration.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;apiVersion: karpenter.sh/v1beta1&lt;br&gt;kind: NodePool&lt;br&gt;metadata:&lt;br&gt;&amp;nbsp;&amp;nbsp;name: default&lt;br&gt;spec:&lt;br&gt;&amp;nbsp;&amp;nbsp;template:&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;spec:&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp;requirements:&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp;- key: karpenter.k8s.aws/instance-category&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;operator: In&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;values: [&#34;c&#34;,&#34;m&#34;,&#34;r&#34;,&#34;t&#34;]&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;-&amp;nbsp;key:&amp;nbsp;&#34;karpenter.k8s.aws/instance-family&#34;&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; operator:&amp;nbsp;In&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;values:&amp;nbsp;[&#34;m5&#34;,&#34;m5d&#34;,&#34;c5&#34;,&#34;c5d&#34;,&#34;c4&#34;,&#34;r4&#34;]&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp;- key: karpenter.k8s.aws/instance-size&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;operator: NotIn&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;values: [&#34;nano&#34;,&#34;micro&#34;,&#34;small&#34;,&#34;medium&#34;]&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp;- key: topology.kubernetes.io/zone&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;operator: In&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;values: [&#34;us-west-2a&#34;,&#34;us-west-2b&#34;]&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp;- key: kubernetes.io/arch&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;operator: In&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;values: [&#34;amd64&#34;,&#34;arm64&#34;]&lt;br&gt;&amp;nbsp;&amp;nbsp;limits:&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;cpu: 100&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Refer to the &lt;a href=&#34;https://karpenter.sh/docs/concepts/nodepools/&#34;&gt;Karpenter documentation&lt;/a&gt; for the complete list of fields for NodePool requirement.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The following is the example of NodePool with taints, user-defined labels and annotations that are added to all the nodes provisioned by Karpenter.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;apiVersion: karpenter.sh/v1beta1&lt;br&gt;kind: NodePool&lt;br&gt;spec:&lt;br&gt;&amp;nbsp;&amp;nbsp;template:&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;metadata:&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp;annotations:&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;application/name: &#34;app-a&#34;&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp;labels:&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;team: team-a&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp;spec:&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp;taints:&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp;- key: example.com/special-taint&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;value: &#34;true&#34;&lt;br&gt;&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;effect: NoSchedule&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;apiVersion: apps/v1&lt;br&gt;kind: Deployment&lt;br&gt;metadata:&lt;br&gt;&amp;nbsp;name:&lt;br&gt;spec: myapp&lt;br&gt;&amp;nbsp;&amp;nbsp; nodeSelector:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; team: team-a&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karpenter supports all standard Kubernetes scheduling constraints,&amp;nbsp;such as node selectors, node affinity, taints/tolerations, and topology spread constraints. This allows applications to use these constraints when scheduling pods on the nodes provisioned by Karpenter.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;NodeClasses in Karpenter allow you to configure&amp;nbsp;cloud provider-specific settings for your nodes in Kubernetes cluster. Each NodePool references a NodeClass that determines the specific configuration of nodes that Karpenter provisions.&amp;nbsp;For example, you can specify settings such as the &lt;a href=&#34;https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AMIs.html&#34;&gt;Amazon Machine Image (AMI)&lt;/a&gt; family, subnet and security group selectors, &lt;a href=&#34;https://aws.amazon.com/iam/&#34;&gt;AWS Identity and Access Management (IAM)&lt;/a&gt; role/instance profile, node labels, and various Kubelet configurations in AWS &lt;a href=&#34;https://karpenter.sh/docs/concepts/nodeclasses/&#34;&gt;EC2NodeClass&lt;/a&gt;&amp;nbsp;and similarly for Azure &lt;a href=&#34;https://learn.microsoft.com/en-gb/azure/aks/node-autoprovision?tabs=azure-cli#node-image-updates&#34;&gt;AKSNodeClass&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Beyond scaling&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;br&gt;Karpenter is more than an efficient cluster autoscaler for Kubernetes. Karpenter optimizes compute costs, helps upgrade and patch data plane worker nodes, and delivers powerful and explorative use cases by pairing with other CNCF tools.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Cost optimization&amp;nbsp;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;br&gt;In the previous section, we saw how Karpenter provisions appropriate worker virtual machines (VMs) based on pod resource requests. As the workloads in a Kubernetes cluster change and scale, it can be necessary to launch new instances to make sure they have the compute resources they need. Over time, those instances can become under-used as some workloads scale down or are removed from the cluster. Workload consolidation for Karpenter automatically looks for opportunities to reschedule these workloads onto a set of more cost-efficient instances, whether they are already in the cluster or need to be launched.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;844&#34; height=&#34;410&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2024/10/Picture-2.jpg&#34; alt=&#34;Figure 2: Worker nodes with varying degree of usage &#34; class=&#34;wp-image-119447&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2024/10/Picture-2.jpg 844w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-2-300x146.jpg 300w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-2-768x373.jpg 768w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-2-412x200.jpg 412w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-2-823x400.jpg 823w&#34; sizes=&#34;(max-width: 844px) 100vw, 844px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;figcaption class=&#34;wp-element-caption&#34;&gt;Figure 2: Worker nodes with varying degree of usage &lt;br&gt;&lt;/figcaption&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In the preceding diagram, the first node is highly used&amp;nbsp;but the others aren’t used as well as they could be.&amp;nbsp;With Karpenter, you can enable the consolidation feature in the NodePool YAML:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;apiVersion: karpenter.sh/v1&lt;br&gt;kind: NodePool&lt;br&gt;metadata:&lt;br&gt;&amp;nbsp; name: default&lt;br&gt;spec:&lt;br&gt;&amp;nbsp; disruption:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; consolidationPolicy: WhenEmptyOrUnderutilized&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karpenter is always evaluating and working to reduce the cluster cost. Karpenter consolidates workloads onto the&amp;nbsp;fewest, lowest-cost instances, while still respecting the pod’s resource and scheduling constraints. With the preceding scenario, Karpenter moves the pods from the last two nodes into the second node, and terminates the resultant empty nodes:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full is-resized&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;844&#34; height=&#34;356&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2024/10/Picture-3.jpg&#34; alt=&#34;Figure 3: Karpenter binpacks pods into existing nodes with consolidation &#34; class=&#34;wp-image-119448&#34; style=&#34;width:901px;height:auto&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2024/10/Picture-3.jpg 844w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-3-300x127.jpg 300w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-3-768x324.jpg 768w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-3-474x200.jpg 474w&#34; sizes=&#34;(max-width: 844px) 100vw, 844px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;figcaption class=&#34;wp-element-caption&#34;&gt;Figure 3: Karpenter binpacks pods into existing nodes with consolidation &lt;/figcaption&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karpenter prioritizes nodes to consolidate based on the least number of pods scheduled. For users with workloads that experience sudden spikes in demand or interruptible jobs, frequent pod creation and deletion (pod churn) might be a concern. Karpenter offers a&amp;nbsp;consolidateAfter setting to control how quickly it attempts to consolidate nodes to maintain optimal capacity and minimize node churn. By specifying a value in hours, minutes, or seconds, users can determine the delay before Karpenter initiates consolidation actions in response to pod additions or removals.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt; apiVersion: karpenter.sh/v1&#xA;kind: NodePool&#xA;metadata:&#xA;&amp;nbsp; name: default&#xA;spec:&#xA;&amp;nbsp; disruption:&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp; consolidationPolicy: WhenEmptyOrUnderutilized&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp; consolidateAfter: 1h &amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&amp;nbsp;With consolidation, Karpenter also rightsizes the worker nodes. For example, in the following case, if Karpenter consolidates the pod from the third node to the second (m5.xlarge), then there is still underusage. Karpenter instead provisions a smaller node (m5.large) and consolidates the pods, resulting in lower cost.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;844&#34; height=&#34;470&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2024/10/Picture-4.jpg&#34; alt=&#34;Figure 4: Karpenter rightsizes node with consolidation&#34; class=&#34;wp-image-119449&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2024/10/Picture-4.jpg 844w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-4-300x167.jpg 300w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-4-768x428.jpg 768w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-4-359x200.jpg 359w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-4-718x400.jpg 718w&#34; sizes=&#34;(max-width: 844px) 100vw, 844px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;figcaption class=&#34;wp-element-caption&#34;&gt;Figure 4: Karpenter rightsizes node with consolidation&lt;/figcaption&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;To know more about consolidation, refer to &lt;a href=&#34;https://karpenter.sh/docs/concepts/disruption/&#34;&gt;this official documentation&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;Lifecycle Management of Worker Nodes&lt;br&gt;&lt;br&gt;Karpenter can make sure your worker nodes always run with the latest node image/Amazon Machine Image (AMI).&amp;nbsp;In the NodeClass YAML, you can specify the AMI family and version as follows:&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;apiVersion: karpenter.k8s.aws/v1&lt;br&gt;kind: EC2NodeClass&lt;br&gt;metadata:&lt;br&gt;&amp;nbsp; name: default&lt;br&gt;spec:&lt;br&gt;&amp;nbsp; amiSelectorTerms:&lt;br&gt;&amp;nbsp; - alias: bottlerocket@latest&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;code&gt;amiSelectorTerms&lt;/code&gt; is a necessary field of the NodeClass and a new term, &lt;code&gt;alias&lt;/code&gt;, has been introduced with version 1.0, which consists of an AMI family and a version (family@version). If an alias exists in the NodeClass, then Karpenter selects the AMI supplied by the cloud provider for that family. With this new feature, users can also pin to a specific version of an AMI. For AWS, the following &lt;a href=&#34;https://aws.amazon.com/eks/&#34;&gt;Amazon Elastic Kubernetes Service (Amazon EKS)&lt;/a&gt; optimized AMI families can be configured: al2, al2023, bottlerocket, windows2019, and windows2022&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;All the nodes provisioned by this NodeClass, will have the latest &lt;a href=&#34;https://aws.amazon.com/bottlerocket/&#34;&gt;bottlerocket&lt;/a&gt; AMI. Because this alias uses &lt;code&gt;@latest&lt;/code&gt; version, when the cloud provider releases a new optimized AMI for the Kubernetes version cluster is running with, then Karpenter updates the worker node AMIs automatically, respecting the Kubernetes scheduling constraints. Worker nodes are upgraded in a rolling deployment fashion. If the cluster is upgraded to a newer version, then Karpenter automatically upgrades the worker nodes with the latest AMI for this new version, automatically and without manual intervention. This takes away management overhead and lets you always run with the latest and most secure AMI.&amp;nbsp;This works well in pre-production environments where it’s nice to be auto-upgraded to the latest version for testing, but more control over AMI versions is recommended in production environments.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Alternatively, you can also pin your worker nodes to a specific version of the AMI as follows:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;apiVersion: karpenter.k8s.aws/v1&lt;br&gt;kind: EC2NodeClass&lt;br&gt;metadata:&lt;br&gt;&amp;nbsp; name: default&lt;br&gt;spec:&lt;br&gt;&amp;nbsp; amiSelectorTerms:&lt;br&gt;&amp;nbsp; - alias: bottlerocket@v1.20.3&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In this case, if the cloud provider releases new bottlerocket AMI, Karpenter doesn’t drift the worker nodes.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karpenter also supports custom AMIs. You can use the existing tags, name, or ID field in amiSelectorTerms to select an AMI. In the following case, the AMI with ID ami-123 is selected to provision the nodes. The amiFamily Bottlerocket injects pre-generated user data into the provisioned node.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;apiVersion: karpenter.k8s.aws/v1&lt;br&gt;kind: EC2NodeClass&lt;br&gt;metadata:&lt;br&gt;&amp;nbsp; name: default&lt;br&gt;spec:&lt;br&gt;...&lt;br&gt;&amp;nbsp; amiFamily: Bottlerocket&lt;br&gt;&amp;nbsp; amiSelectorTerms:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; - id: ami-123&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;To upgrade the worker nodes, change the &lt;code&gt;amiSelectorTerms&lt;/code&gt; to select a different AMI, and nodes drift and upgrade to the assigned AMI.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Karpenter Working with Other CNCF projects&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karpenter can be used with other CNCF projects to deliver powerful solutions for common use cases. One prominent example of this is using Kubernetes Event Driven Autoscaling (KEDA) with Karpenter to implement event driven workloads. With KEDA, you can drive the scaling of any container in Kubernetes based on the number of events needing to be processed. One popular implementation is to scale up worker nodes to accommodate pods that process messages coming into a queue:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;844&#34; height=&#34;344&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2024/10/Picture-5.jpg&#34; alt=&#34;Figure 5: Karpenter provisions node(s) in response to messages in queue with KEDA &#34; class=&#34;wp-image-119450&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2024/10/Picture-5.jpg 844w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-5-300x122.jpg 300w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-5-768x313.jpg 768w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-5-491x200.jpg 491w&#34; sizes=&#34;(max-width: 844px) 100vw, 844px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;figcaption class=&#34;wp-element-caption&#34;&gt;Figure 5: Karpenter provisions node(s) in response to messages in queue with KEDA &lt;/figcaption&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Often users want to scale down the number of worker nodes during off hours. KEDA and Karpenter can support this use case:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;844&#34; height=&#34;350&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2024/10/Picture-6.jpg&#34; alt=&#34;Figure 6: Karpenter provisions node(s) in response to Cron schedule with KEDA &#34; class=&#34;wp-image-119451&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2024/10/Picture-6.jpg 844w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-6-300x124.jpg 300w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-6-768x318.jpg 768w, https://www.cncf.io/wp-content/uploads/2024/10/Picture-6-482x200.jpg 482w&#34; sizes=&#34;(max-width: 844px) 100vw, 844px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;figcaption class=&#34;wp-element-caption&#34;&gt;Figure 6: Karpenter provisions node(s) in response to Cron schedule with KEDA &lt;/figcaption&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karpenter can be combined with other CNCF projects such as Prometheus, Argo Workflows, Grafana to achieve diverse use cases. Check out &lt;a href=&#34;https://www.youtube.com/watch?v=rq57liGu0H4&#34;&gt;this previous talk&lt;/a&gt; from Kubecon EU 2024 how Argo Workflows can be combined with Karpenter to migrate from Cluster Autoscaler.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Adopting Karpenter&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;br&gt;To get started with Karpenter, you can follow the official &lt;a href=&#34;https://karpenter.sh/docs/getting-started/getting-started-with-karpenter/&#34;&gt;Getting Started with Karpenter&lt;/a&gt; guide, which provides a step-by-step procedure for creating an EKS cluster using &lt;a href=&#34;https://eksctl.io/&#34;&gt;eksctl&lt;/a&gt; and adding Karpenter to it. Alternatively, if you prefer using Terraform, then you can use the &lt;a href=&#34;https://aws-ia.github.io/terraform-aws-eks-blueprints/getting-started/&#34;&gt;Amazon EKS Blueprints for Terraform&lt;/a&gt;, which includes a Karpenter module, thus streamlining the process of setting up Karpenter alongside your EKS cluster. Furthermore, there are guides available for setting up Karpenter with other Kubernetes distributions such as &lt;a href=&#34;https://kops.sigs.k8s.io/operations/karpenter/&#34;&gt;kOps&lt;/a&gt; on AWS. And if you want to migrate from Kubernetes Cluster Autoscaler to Karpenter for automatic node provisioning on an existing EKS cluster, then you can refer &lt;a href=&#34;https://karpenter.sh/docs/getting-started/migrating-from-cas/&#34;&gt;this guide&lt;/a&gt; for the detailed steps.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;What’s next&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;br&gt;Karpenter has evolved far beyond being a tool for autoscaling, showcasing its versatility and deeper integration within the cloud-native ecosystem. Karpenter not only scales worker nodes but also drives cost efficiencies, seamlessly managing diverse workloads such as generative AI, facilitating data plane upgrades with precision, and more.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;br&gt;Looking ahead, the possibilities for Karpenter are endless, especially as organizations explore groundbreaking use cases. We are only beginning to scratch the surface of what Karpenter can achieve when combined with other CNCF projects. The potential for Karpenter to contribute to next-generation infrastructure is immense, and we can’t wait to observe the inventive and powerful use cases users come up with, making their cloud operations more efficient, scalable, and intelligent.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;To shape the future of Karpenter, let us know what features we should work on by upvoting and commenting &lt;a href=&#34;https://github.com/aws/karpenter-provider-aws&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;If you are attending KubeCon NA 2024, then you can meet with us at the AWS Booth F1, or attend our Karpenter workshop &lt;a href=&#34;https://sched.co/1i7n3&#34;&gt;Tutorial: Kubernetes Smart Scaling: Getting Started with Karpenter&lt;/a&gt;&amp;nbsp;to learn more.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Authors&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Rajdeep Saha, Principal Solutions Architect, AWS&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Raj is the Principal Specialist SA for Containers, and Serverless at AWS. Rajdeep has architected high profile AWS applications serving millions of users. He is a published instructor on Kubernetes, Serverless, DevOps, and System Design, has published blogs, and presented well-received talks at major events, such as AWS Re:Invent, Kubecon, AWS Summits.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full is-resized&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;182&#34; height=&#34;176&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2024/10/headshot-1.png&#34; alt=&#34;Rajdeep&#34; class=&#34;wp-image-119452&#34; style=&#34;width:277px;height:auto&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Praseeda Sathaye, Principal SA, Containers &amp;amp; OSS&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Praseeda Sathaye is a Principal Specialist for App Modernization and Containers at Amazon Web Services, based in the Bay Area in California. She has been focused on helping customers accelerate their cloud-native adoption journey by modernizing their platform infrastructure and internal architecture using microservices strategies, containerization, platform engineering, GitOps, Kubernetes and service mesh. Praseeda is an ardent advocate for leveraging Generative AI (GenAI) on Amazon Elastic Kubernetes Service (EKS) to unlock the full potential of cutting-edge technologies, enabling the development of AI-powered applications.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full is-resized&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;421&#34; height=&#34;348&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2024/10/Headshot-2.jpg&#34; alt=&#34;Praseeda&#34; class=&#34;wp-image-119453&#34; style=&#34;width:282px;height:auto&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2024/10/Headshot-2.jpg 421w, https://www.cncf.io/wp-content/uploads/2024/10/Headshot-2-300x248.jpg 300w, https://www.cncf.io/wp-content/uploads/2024/10/Headshot-2-242x200.jpg 242w&#34; sizes=&#34;(max-width: 421px) 100vw, 421px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;p&gt;&lt;em&gt;成员帖子，作者：AWS 首席解决方案架构师 Rajdeep Saha 和 AWS 容器和 OSS 首席 SA 负责人 Praseeda Sathaye&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;简介&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;br&gt;&lt;a href=&#34;https://karpenter.sh/&#34;&gt;Karpenter&lt;/a&gt; 是一个开源项目，提供节点生命周期管理，以优化 Kubernetes 集群上运行工作负载的效率和成本。  AWS 于 2021 年创建并开源了 Karpenter，以帮助客户自动化选择、配置和扩展集群中的基础设施，并为 Kubernetes 用户提供更大的灵活性，以充分利用不同云提供商的独特基础设施产品。 2023 年，&lt;a href=&#34;https://aws.amazon.com/blogs/containers/karpenter-graduates-to-beta/&#34;&gt;项目升级为测试版&lt;/a&gt;，AWS &lt;a href=&#34;https ://github.com/kubernetes/org/issues/4258&#34;&gt;通过 Kubernetes 自动扩展特别兴趣小组 (SIG) 向云原生计算基金会 (CNCF) 贡献了&lt;/a&gt;该项目的供应商中立核心。 2024 年，AWS &lt;a href=&#34;https://aws.amazon.com/blogs/containers/announcing-karpenter-1-0/&#34;&gt;发布了 Karpenter 版本 1.0.0&lt;/a&gt;，这标志着该领域的最后一个里程碑项目的成熟度。在此版本中，所有 Karpenter API 将在未来的 1.0 小版本中保持可用，并且不会以导致重大更改的方式进行修改。 &lt;a href=&#34;https://github.com/kubernetes-sigs/karpenter&#34;&gt;Karpenter 在 Apache 2.0 许可证下作为开源&lt;/a&gt;软件 (OSS) 提供。它将 Kubernetes 应用程序感知和工作负载装箱的通用逻辑与 API 请求的创建和运行分开，以启动或终止给定云提供商的计算资源。 通过开发与各自计算 API 交互的特定于云提供商的集成，Karpenter 使 AWS、Azure、GCP 等各个云提供商能够在各自的环境中利用其功能。 2023 年，Microsoft 发布了 &lt;a href=&#34;https://github.com/Azure/karpenter-provider-azure&#34;&gt;Karpenter Provider&lt;/a&gt;，用于在 Azure Kubernetes 服务 (AKS) 上运行 Karpenter。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如今，Karpenter 在 Kubernetes 社区中获得了广泛的欢迎，各种组织和企业都在利用其功能来帮助提高应用程序可用性、降低运营开销并提高成本效率。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Karpenter 的工作原理&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;br&gt;Karpenter 在 Kubernetes 集群中的工作是制定应用程序和 Kubernetes 感知的计算容量决策。它被构建为 Kubernetes Operator，在 Kubernetes 集群中运行，并管理集群计算基础设施。卡彭特做出两种决策：配置新的计算，以及在不再需要时取消配置该计算。 Karpenter 的工作原理是监视 Kubernetes 调度程序标记为不可调度的 pod，并对其进行评估Pod 请求的调度约束（资源请求、节点选择器、关联性、容忍度和拓扑扩展约束）、配置满足 Pod 要求的节点，以及在不再需要节点时取消配置节点。 Karpenter 的工作负载整合功能可以通过重用集群内的现有实例或启动新的优化实例，主动识别未充分利用的工作负载并将其重新安排到更具成本效益的实例集上，从而最大限度地提高资源利用率并最大限度地降低运营成本。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“844”高度=“406”src=“https://www.cncf.io/ wp-content/uploads/2024/10/Picture-1.jpg&#34; alt=&#34;图 1：Karpenter 提供节点以响应待处理的不可调度 pod&#34; class=&#34;wp-image-119446&#34; srcset=&#34;https:/ /www.cncf.io/wp-content/uploads/2024/10/Picture-1.jpg 844w，https://www.cncf.io/wp-content/uploads/2024/10/Picture-1-300x144。 jpg 300w，https://www.cncf.io/wp-content/uploads/2024/10/Picture-1-768x369.jpg 768w，https://www.cncf.io/wp-content/uploads/2024/ 10/Picture-1-416x200.jpg 416w，https://www.cncf.io/wp-content/uploads/2024/10/Picture-1-832x400.jpg 832w“尺寸=”（最大宽度：844px） 100vw, 844px&#34;referrerpolicy=&#34;no-referrer&#34;&gt;&lt;figcaption class=&#34;wp-element-caption&#34;&gt;图 1：Karpenter 配置节点以响应待处理的不可调度 Pod&lt;/figcaption&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karpenter 扩展是使用 Kubernetes 本机 YAML 控制的，特别是通过使用 &lt;a href=&#34;https://karpenter.sh/docs/concepts/nodepools/&#34;&gt;NodePool&lt;/a&gt; 和 &lt;a href=&#34;https ://karpenter.sh/docs/concepts/nodeclasses/&#34;&gt;NodeClass&lt;/a&gt; 自定义 Kubernetes 资源。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;NodePools 对 Karpenter 在 Kubernetes 集群中配置的节点设置约束。每个 NodePool 定义了一些要求，例如实例类型、可用区、架构（例如 AMD64 或 ARM64）、容量类型（现货或按需）以及适用于 NodePool 中启动的所有节点的其他节点设置。它还允许对 NodePool 可以消耗的总资源（例如 CPU、内存和 GPU）设置限制。以下是NodePool配置示例。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;api版本：karpenter.sh/v1beta1&lt;br&gt;种类：NodePool&lt;br&gt;元数据：&lt;br&gt;  名称：默认&lt;br&gt;规格：&lt;br &gt;  模板：&lt;br&gt;    规范：&lt;br&gt;      要求：&lt;br&gt;      - 键：karpenter.k8s.aws/instance-category&lt;br&gt;        运算符：In&lt;br&gt;        值：[&#34;c&#34;,&#34;m&#34;,&#34;r &#34;,&#34;t&#34;]&lt;br&gt;      - 键：“karpenter.k8s.aws/instance-family”&lt;br&gt;        运算符：In&lt;br&gt;         值：[&#34;m5&#34;,&#34;m5d&#34;,&#34;c5&#34;,&#34;c5d&#34; ,&#34;c4&#34;,&#34;r4&#34;]&lt;br&gt;      - 键：karpenter.k8s.aws/instance-size&lt;br&gt;       &amp;nbsp;运算符：NotIn&lt;br&gt;        值：[&#34;nano&#34;,&#34;micro&#34;,&#34;small&#34;,&#34;medium&#34;]&lt;br&gt;      - 键：topology.kubernetes.io/zone&lt;br&gt;        运算符：In&lt;br&gt;        值: [&#34;us-west-2a&#34;,&#34;us-west-2b&#34;]&lt;br&gt;      - 键：kubernetes.io/arch&lt;br&gt;        运算符：In&lt;br&gt;        值：[&#34;amd64&#34;,&#34;arm64&#34;]&lt; br&gt;  限制：&lt;br&gt;    CPU：100&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;请参阅 &lt;a href=&#34;https://karpenter.sh/docs/concepts/nodepools/&#34;&gt;Karpenter 文档&lt;/a&gt;，了解 NodePool 要求的完整字段列表。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;以下是 NodePool 的示例，其中包含添加到 Karpenter 配置的所有节点中的污点、用户定义的标签和注释。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;api版本：karpenter.sh/v1beta1&lt;br&gt;种类：NodePool&lt;br&gt;规格：&lt;br&gt;  模板：&lt;br&gt;    元数据：&lt;br&gt;注释：&lt;br&gt;        应用程序/名称：“app-a”&lt;br&gt;      标签：&lt;br&gt;        团队：team-a&lt;br&gt;    规格：&lt;br&gt;      污点：&lt;br&gt;      - key: example.com/special-taint &lt;br&gt;        值：“true”&lt;br&gt;        效果：NoSchedule&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;apiVersion: apps/v1&lt;br&gt;种类：部署&lt;br&gt;元数据：&lt;br&gt; 名称：&lt;br&gt;规范：myapp&lt;br&gt;   nodeSelector :&lt;br&gt;    团队：团队-a&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karpenter 支持所有标准 Kubernetes 调度约束，例如节点选择器、节点关联性、污点/容忍和拓扑传播约束。这允许应用程序在 Karpenter 配置的节点上调度 pod 时使用这些约束。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karpenter 中的 NodeClass 允许您为 Kubernetes 集群中的节点配置特定于云提供商的设置。每个 NodePool 引用一个 NodeClass，该 NodeClass 确定 Karpenter 提供的节点的具体配置。 例如，您可以指定 &lt;a href=&#34;https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AMIs.html&#34;&gt;Amazon 系统映像 (AMI)&lt;/a&gt; 系列等设置，子网和安全组选择器、&lt;a href=&#34;https://aws.amazon.com/iam/&#34;&gt;AWS Identity and Access Management (IAM)&lt;/a&gt; 角色/实例配置文件、节点标签以及各种 Kubelet 配置AWS &lt;a href=&#34;https://karpenter.sh/docs/concepts/nodeclasses/&#34;&gt;EC2NodeClass&lt;/a&gt; 以及 Azure &lt;a href=&#34;https://learn.microsoft.com/en-gb/ 类似azure/aks/node-autoprovision?tabs=azure-cli#node-image-updates&#34;&gt;AKSNodeClass&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;超越缩放&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;br&gt;Karpenter 不仅仅是 Kubernetes 的高效集群自动缩放器。 Karpenter 优化计算成本，帮助升级和修补数据平面工作节点，并删除通过与其他 CNCF 工具配合使用，可以提供强大且具有探索性的用例。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;成本优化&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;br&gt;在上一节中，我们了解了 Karpenter 如何根据 Pod 资源请求配置适当的工作虚拟机 (VM)。随着 Kubernetes 集群中的工作负载发生变化和扩展，可能有必要启动新实例以确保它们拥有所需的计算资源。随着时间的推移，由于某些工作负载缩小或从集群中删除，这些实例可能会变得利用率不足。 Karpenter 的工作负载整合会自动寻找机会将这些工作负载重新安排到一组更具成本效益的实例上，无论它们已经在集群中还是需要启动。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;imgloading=&#34;lazy&#34;decoding=&#34;async&#34;width=&#34;844&#34;height=&#34;410&#34;src=&#34;https://www.cncf.io/ wp-content/uploads/2024/10/Picture-2.jpg&#34; alt=&#34;图 2：不同使用程度的工作节点 &#34; class=&#34;wp-image-119447&#34; srcset=&#34;https://www.cncf. io/wp-content/uploads/2024/10/Picture-2.jpg 844w，https://www.cncf.io/wp-content/uploads/2024/10/Picture-2-300x146.jpg 300w，https： //www.cncf.io/wp-content/uploads/2024/10/Picture-2-768x373.jpg 768w，https://www.cncf.io/wp-content/uploads/2024/10/Picture-2 -412x200.jpg 412w，https://www.cncf.io/wp-content/uploads/2024/10/Picture-2-823x400.jpg 823w“尺寸=”（最大宽度：844px）100vw，844px“引用策略=&#34;no-referrer&#34;&gt;&lt;figcaption class=&#34;wp-element-caption&#34;&gt;图 2：不同使用程度的工作节点 &lt;br&gt;&lt;/figcaption&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在上图中，第一个节点的使用率很高，但其他节点的使用率并未达到应有的水平。 使用 Karpenter，您可以在 NodePool YAML 中启用合并功能：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;api版本：karpenter.sh/v1&lt;br&gt;种类：NodePool&lt;br&gt;元数据：&lt;br&gt; 名称：默认&lt;br&gt;规格：&lt;br &gt;  中断：&lt;br&gt;    整合策略：WhenEmptyOrUnderutilized&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karpenter 始终在评估并努力降低集群成本。 Karpenter 将工作负载整合到最少、成本最低的实例上，同时仍然尊重 Pod 的资源和调度限制。对于前面的场景，Karpenter 将 Pod 从最后两个节点移动到第二个节点，并终止生成的空节点：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full is-resized&#34;&gt;&lt;imgloading=&#34;lazy&#34;decoding=&#34;async&#34;width=&#34;844&#34;height=&#34;356&#34;src=&#34;https://www.cncf .io/wp-content/uploads/2024/10/Picture-3.jpg&#34; alt=&#34;图 3：Karpenter 将 pod 打包到现有节点中并进行整合&#34; class=&#34;wp-image-119448&#34; style=&#34;width:901px;高度：自动” srcset =“https://www.cncf.io/wp-content/uploads/2024/10/Picture-3.jpg 844w，https://www.cncf.io/wp-content/uploads/ 2024/10/Picture-3-300x127.jpg 300w，https://www.cncf.io/wp-content/uploads/2024/10/Picture-3-768x324.jpg 768w，https://www.cncf。 io/wp-内容/上传/2024/10/Picture-3-474x200.jpg 474w&#34;sizes=&#34;(max-width: 844px) 100vw, 844px&#34;referrerpolicy=&#34;no-referrer&#34;&gt;&lt;figcaption class=&#34;wp-element-caption&#34;&gt;图 3: Karpenter 通过整合将 Pod 打包到现有节点中&lt;/figcaption&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karpenter 根据调度的最少 Pod 数量来确定要整合的节点的优先级。对于工作负载遇到需求突然激增或作业中断的用户来说，频繁创建和删除 Pod（Pod 流失）可能会成为问题。 Karpenter 提供了 consolidateAfter 设置来控制尝试合并节点的速度，以保持最佳容量并最大限度地减少节点流失。通过指定以小时、分钟或秒为单位的值，用户可以确定 Karpenter 启动整合操作以响应 Pod 添加或删除之前的延迟。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt; api版本：karpenter.sh/v1&#xA;种类：节点池&#xA;元数据：&#xA;  名称：默认&#xA;规格：&#xA;  中断：&#xA;    整合策略：当空或未充分利用时&#xA;    巩固后：1小时   &lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt; 通过整合，Karpenter 还调整了工作节点的大小。例如，在以下情况下，如果 Karpenter 将 pod 从第三个节点合并到第二个节点 (m5.xlarge)，则仍然存在未充分利用的情况。相反，Karpenter 提供了一个较小的节点 (m5.large) 并整合了 Pod，从而降低了成本。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“844”高度=“470”src=“https://www.cncf.io/wp-content” /uploads/2024/10/Picture-4.jpg&#34; alt=&#34;图 4：Karpenter 通过合并调整节点大小&#34; class=&#34;wp-image-119449&#34; srcset=&#34;https://www.cncf.io/wp-content /uploads/2024/10/Picture-4.jpg 844w，https://www.cncf.io/wp-content/uploads/2024/10/Picture-4-300x167.jpg 300w，https://www.cncf .io/wp-content/uploads/2024/10/Picture-4-768x428.jpg 768w，https://www.cncf.io/wp-content/uploads/2024/10/Picture-4-359x200.jpg 359w ，https://www.cncf.io/wp-content/uploads/2024/10/Picture-4-718x400.jpg 718w“尺寸=”（最大宽度：844px）100vw，844px“referrerpolicy=”no-referrer &#34;&gt;&lt;figcaption class=&#34;wp-element-caption&#34;&gt;图 4：Karpenter 通过合并调整节点大小&lt;/figcaption&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;要了解有关整合的更多信息，请参阅&lt;a href=&#34;https://karpenter.sh/docs/concepts/disruption/&#34;&gt;此官方文档&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;工作节点的生命周期管理&lt;br&gt;&lt;br&gt;Karpenter 可以确保您的工作节点始终使用最新的节点映像/Amazon 系统映像 (AMI) 运行。 在 NodeClass YAML 中，您可以指定 AMI 系列和版本，如下所示：&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;api版本：karpenter.k8s.aws/v1&lt;br&gt;种类：EC2NodeClass&lt;br&gt;元数据：&lt;br&gt; 名称：默认&lt;br&gt;规格： &lt;br&gt;  amiSelectorTerms：&lt;br&gt;  - 别名：bottlerocket@latest&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;code&gt;amiSelectorTerms&lt;/code&gt; 是 NodeClass 的必要字段，并且有一个新术语 &lt;code&gt;alias&lt;/code&gt;1.0 版中引入，由 AMI 系列和版本 (family@version) 组成。如果 NodeClass 中存在别名，则 Karpenter 会选择云提供商为该系列提供的 AMI。借助这一新功能，用户还可以固定到 AMI 的特定版本。对于 AWS，可以配置以下 &lt;a href=&#34;https://aws.amazon.com/eks/&#34;&gt;Amazon Elastic Kubernetes Service (Amazon EKS)&lt;/a&gt; 优化的 AMI 系列：al2、al2023、bottlerocket、windows2019 ，和windows2022&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此 NodeClass 配置的所有节点都将具有最新的 &lt;a href=&#34;https://aws.amazon.com/bottlerocket/&#34;&gt;bottlerocket&lt;/a&gt; AMI。由于此别名使用 &lt;code&gt;@latest&lt;/code&gt; 版本，因此当云提供商为运行的 Kubernetes 版本集群发布新的优化 AMI 时，Karpenter 会自动更新工作节点 AMI，同时遵守 Kubernetes 调度约束。工作节点以滚动部署方式升级。如果集群升级到较新的版本，那么 Karpenter 会自动使用该新版本的最新 AMI 升级工作节点，无需手动干预。这消除了管理开销，让您始终使用最新、最安全的 AMI 运行。 这在预生产环境中效果很好，可以自动升级到最新版本进行测试，但建议在生产环境中对 AMI 版本进行更多控制。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;或者，您也可以将工作线程节点固定到特定版本的 AMI，如下所示：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;api版本：karpenter.k8s.aws/v1&lt;br&gt;种类：EC2NodeClass&lt;br&gt;元数据：&lt;br&gt; 名称：默认&lt;br&gt;规格： &lt;br&gt;  amiSelectorTerms：&lt;br&gt;  - 别名：bottlerocket@v1.20.3&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在这种情况下，如果云提供商发布新的 Bottlerocket AMI，Karpenter 不会漂移工作节点。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karpenter 还支持自定义 AMI。您可以使用 amiSelectorTerms 中的现有标签、名称或 ID 字段来选择 AMI。在以下情况下，选择 ID 为 ami-123 的 AMI 来配置节点。 amiFamily Bottlerocket 将预先生成的用户数据注入到配置的节点中。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;api版本：karpenter.k8s.aws/v1&lt;br&gt;种类：EC2NodeClass&lt;br&gt;元数据：&lt;br&gt; 名称：默认&lt;br&gt;规格： &lt;br&gt;...&lt;br&gt;  amiFamily：Bottlerocket&lt;br&gt;  amiSelectorTerms：&lt;br&gt;    - id：ami-123&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;要升级工作线程节点，请更改 &lt;code&gt;amiSelectorTerms&lt;/code&gt; 以选择不同的 AMI，然后节点会漂移并升级到分配的 AMI。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Karpenter 与其他 CNCF 项目合作&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karpenter 可以与其他 CNCF 项目结合使用，为常见用例提供强大的解决方案。一个突出的例子是使用 Kubernetes 事件驱动自动扩展 (KEDA) 和 Karpenter 来实现事件驱动的工作负载。借助 KEDA，您可以推动任何业务的扩展Kubernetes 中的容器基于需要处理的事件数量。一种流行的实现是扩展工作节点以容纳处理进入队列的消息的 pod：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“844”高度=“344”src=“https://www.cncf.io/ wp-content/uploads/2024/10/Picture-5.jpg&#34; alt=&#34;图 5：Karpenter 使用 KEDA 提供节点来响应队列中的消息 &#34; class=&#34;wp-image-119450&#34; srcset=&#34;https ://www.cncf.io/wp-content/uploads/2024/10/Picture-5.jpg 844w，https://www.cncf.io/wp-content/uploads/2024/10/Picture-5- 300x122.jpg 300w，https://www.cncf.io/wp-content/uploads/2024/10/Picture-5-768x313.jpg 768w，https://www.cncf.io/wp-content/uploads/ 2024/10/Picture-5-491x200.jpg 491w&#34;sizes=&#34;(max-width: 844px) 100vw, 844px&#34;referrerpolicy=&#34;no-referrer&#34;&gt;&lt;figcaption class=&#34;wp-element-caption&#34;&gt;图 5: Karpenter 使用 KEDA 提供节点来响应队列中的消息&lt;/figcaption&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;用户通常希望在下班时间减少工作节点的数量。 KEDA 和 Karpenter 可以支持此用例：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“844”高度=“350”src=“https://www.cncf.io/ wp-content/uploads/2024/10/Picture-6.jpg&#34; alt=&#34;图 6：Karpenter 使用 KEDA 响应 Cron 计划来配置节点&#34; class=&#34;wp-image-119451&#34; srcset=&#34;https: //www.cncf.io/wp-content/uploads/2024/10/Picture-6.jpg 844w，https://www.cncf.io/wp-content/uploads/2024/10/Picture-6-300x124 .jpg 300w，https://www.cncf.io/wp-content/uploads/2024/10/Picture-6-768x318.jpg 768w，https://www.cncf.io/wp-content/uploads/2024 /10/Picture-6-482x200.jpg 482w&#34;sizes=&#34;(max-width: 844px) 100vw, 844px&#34;referrerpolicy=&#34;no-referrer&#34;&gt;&lt;figcaption class=&#34;wp-element-caption&#34;&gt;图 6：卡彭特使用 KEDA 响应 Cron 计划来配置节点 &lt;/figcaption&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karpenter 可以与 Prometheus、Argo Workflows、Grafana 等其他 CNCF 项目相结合，以实现多样化的用例。查看 Kubecon EU 2024 的&lt;a href=&#34;https://www.youtube.com/watch?v=rq57liGu0H4&#34;&gt;之前的演讲&lt;/a&gt;如何将 Argo 工作流与 Karpenter 结合起来从 Cluster Autoscaler 迁移。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;采用卡彭特&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;br&gt;要开始使用 Karpenter，您可以按照官方 &lt;a href=&#34;https://karpenter.sh/docs/getting-started/getting-started-with-karpenter/&#34;&gt;Karpenter 入门&lt;/a&gt; 指南，它提供了使用 &lt;a href=&#34;https://eksctl.io/&#34;&gt;eksctl&lt;/a&gt; 创建 EKS 集群并向其中添加 Karpenter 的分步过程。或者，如果您更喜欢使用 Terraform，则可以使用 &lt;a href=&#34;https://aws-ia.github.io/terraform-aws-eks-blueprints/getting-started/&#34;&gt;适用于 Terraform 的 Amazon EKS 蓝图&lt; /a&gt;，其中包含 Karpenter 模块，从而简化了在 EKS 集群中设置 Karpenter 的过程。此外，还有可用的指南r 将 Karpenter 与其他 Kubernetes 发行版一起设置，例如 AWS 上的 &lt;a href=&#34;https://kops.sigs.k8s.io/operations/karpenter/&#34;&gt;kOps&lt;/a&gt;。如果您想从 Kubernetes Cluster Autoscaler 迁移到 Karpenter，以便在现有 EKS 集群上自动配置节点，那么您可以参考 &lt;a href=&#34;https://karpenter.sh/docs/getting-started/migration-from-cas /&#34;&gt;本指南&lt;/a&gt;了解详细步骤。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;下一步是什么&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;br&gt;Karpenter 的发展已经远远超出了自动扩展工具的范畴，展示了其多功能性以及在云原生生态系统中更深入的集成。 Karpenter 不仅可以扩展工作节点，还可以提高成本效率，无缝管理生成式 AI 等各种工作负载，促进精确的数据平面升级等等。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;br&gt;展望未来，Karpenter 的可能性是无限的，特别是当组织探索突破性的用例时。我们才刚刚开始了解 Karpenter 与其他 CNCF 项目结合时所能实现的目标。 Karpenter 为下一代基础设施做出贡献的潜力是巨大的，我们迫不及待地想观察用户提出的创造性和强大的用例，使他们的云运营更加高效、可扩展和智能。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;为了塑造 Karpenter 的未来，请在&lt;a href=&#34;https://github.com/aws/karpenter-provider-aws&#34;&gt;此处&lt;/a&gt;点赞和评论，让我们了解应该开发哪些功能.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果您要参加 KubeCon NA 2024，那么您可以在 AWS F1 展位与我们会面，或参加我们的 Karpenter 研讨会&lt;a href=&#34;https://sched.co/1i7n3&#34;&gt;教程：Kubernetes 智能扩展： Karpenter 入门&lt;/a&gt;了解更多信息。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;作者&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Rajdeep Saha，AWS 首席解决方案架构师&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol类=“wp-block-list”&gt;&#xA;&lt;li&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Raj 是 AWS 容器和无服务器首席专家 SA。 Rajdeep 构建了备受瞩目的 AWS 应用程序，为数百万用户提供服务。他是 Kubernetes、无服务器、DevOps 和系统设计方面的讲师，发表过博客，并在 AWS Re:Invent、Kubecon、AWS 峰会等重大活动中发表了广受好评的演讲。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full is-resized&#34;&gt;&lt;imgloading=&#34;lazy&#34;decoding=&#34;async&#34;width=&#34;182&#34;height=&#34;176&#34;src=&#34;https://www.cncf .io/wp-content/uploads/2024/10/headshot-1.png&#34; alt=&#34;Rajdeep&#34; class=&#34;wp-image-119452&#34; style=&#34;width:277px;height:auto&#34;referrerpolicy=&#34;no-referrer &#34;&gt;&lt;/图&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Praseda Sathaye，容器和 OSS 负责人 SA&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Praseeda Sathaye 是 Amazon Web Services 应用现代化和容器方面的首席专家，总部位于加利福尼亚州湾区。她一直专注于通过使用微服务策略实现平台基础设施和内部架构现代化来帮助客户加快云原生采用之旅，续ainerization、平台工程、GitOps、Kubernetes 和服务网格。 Praseeda 热心倡导利用 Amazon Elastic Kubernetes Service (EKS) 上的生成式 AI (GenAI) 来释放尖端技术的全部潜力，从而实现 AI 支持的应用程序的开发。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full is-resized&#34;&gt;&lt;imgloading=&#34;lazy&#34;decoding=&#34;async&#34;width=&#34;421&#34;height=&#34;348&#34;src=&#34;https://www.cncf .io/wp-content/uploads/2024/10/Headshot-2.jpg&#34; alt=&#34;Praseeda&#34; class=&#34;wp-image-119453&#34; style=&#34;width:282px;height:auto&#34; srcset=&#34;https:// /www.cncf.io/wp-content/uploads/2024/10/Headshot-2.jpg 421w，https://www.cncf.io/wp-content/uploads/2024/10/Headshot-2-300x248。 jpg 300w，https://www.cncf.io/wp-content/uploads/2024/10/Headshot-2-242x200.jpg 242w“尺寸=”（最大宽度：421px）100vw，421px“referrerpolicy=”否-引用者&#34;&gt;&lt;/图&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Tue, 05 Nov 2024 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Kubectl logs tail: a guide to tailing Kubernetes logs】Kubectl Logs tail：跟踪 Kubernetes 日志的指南</title>
      <link>https://www.cncf.io/blog/2024/11/01/kubectl-logs-tail-a-guide-to-tailing-kubernetes-logs/</link>
      <description>【&lt;p&gt;&lt;em&gt;Member post originally published on &lt;a href=&#34;https://middleware.io/blog/kubectl-logs-tail/&#34;&gt;Middleware’s blog&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In the world of cloud-native applications,&amp;nbsp;&lt;a href=&#34;https://middleware.io/blog/kubernetes-observability/&#34;&gt;Kubernetes&lt;/a&gt;&amp;nbsp;stands as the go-to platform for container orchestration (the automated process of managing, scaling, and maintaining containerized applications across multiple hosts). As applications grow in scale and complexity, effective logging becomes crucial for monitoring, troubleshooting, and maintaining smooth operations.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This guide explores the intricacies of&amp;nbsp;&lt;a href=&#34;https://middleware.io/blog/kubernetes-logging/&#34;&gt;Kubernetes logging&lt;/a&gt;, its significance, and the common commands one may encounter in their monitoring activities. We’ll also dive into the various logging sources within a Kubernetes environment, accompanied by code examples to illustrate key concepts.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;overview-of-kubernetes-logging&#34;&gt;Overview of Kubernetes logging&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Kubernetes log monitoring involves collecting and analyzing log data from various sources within a Kubernetes cluster. Logs provide valuable insights into the state of your applications, nodes, and the cluster itself. They help identify issues,&amp;nbsp;&lt;a href=&#34;https://middleware.io/blog/what-is-application-performance-monitoring/&#34;&gt;understand application behavior&lt;/a&gt;, and maintain overall system health.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;importance-of-logging-in-kubernetes&#34;&gt;Importance of logging in Kubernetes&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;Troubleshooting:&amp;nbsp;&lt;/strong&gt;Logs help diagnose and resolve issues by providing a detailed record of events.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Monitoring:&lt;/strong&gt;&amp;nbsp;Continuous&amp;nbsp;&lt;a href=&#34;https://middleware.io/blog/what-is-log-monitoring/&#34;&gt;log monitoring&lt;/a&gt;&amp;nbsp;ensures that applications run smoothly and helps detect anomalies.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Compliance:&lt;/strong&gt;&amp;nbsp;Logs can be used to maintain compliance with industry standards and regulations.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Performance Optimization:&amp;nbsp;&lt;/strong&gt;Analyzing logs can reveal performance bottlenecks and opportunities for optimization.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;common-logging-challenges-in-kubernetes-environments&#34;&gt;Common logging challenges in Kubernetes environments&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;Volume of Logs:&lt;/strong&gt;&amp;nbsp;Kubernetes’ dynamic and scalable nature can generate massive amounts of log data, making it difficult to manage and analyze.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Log Retention:&amp;nbsp;&lt;/strong&gt;Determining how long to retain logs and ensuring they are stored efficiently.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Log Aggregation:&amp;nbsp;&lt;/strong&gt;Collecting logs from multiple sources and aggregating them in a centralized location.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Log Correlation:&amp;nbsp;&lt;/strong&gt;Correlating logs from different system parts to get a complete picture of events.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;understanding-kubernetes-logging&#34;&gt;Understanding Kubernetes logging&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;h-1-logging-architecture&#34;&gt;1. Logging architecture&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;i. How logging works in Kubernetes&lt;/strong&gt;?&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In Kubernetes, logs are typically generated by applications running in containers, the nodes on which these containers run, and the cluster components. Kubernetes does not handle log storage and analysis directly but allows integration with various logging solutions.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;When a container writes logs, they are captured by the container runtime and can be accessed using commands like `&lt;a href=&#34;https://middleware.io/blog/kubectl-cheat-sheet/&#34;&gt;kubectl logs&lt;/a&gt;`. These logs can then be shipped to external logging systems for further analysis.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;ii. Logging drivers and options&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;A logging driver is a component in containerized environments that manages how and where logs are stored and processed. It defines the mechanism by which logs from containers are collected, formatted, and sent to a specific logging backend or storage system. By configuring logging drivers, you can control the&amp;nbsp;&lt;a href=&#34;https://middleware.io/blog/what-is-structured-logging/&#34;&gt;flow of log data&lt;/a&gt;, making it easier to monitor, troubleshoot, and analyze the performance and behavior of your applications.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Kubernetes supports various logging drivers and options to suit different needs.&amp;nbsp;&lt;a href=&#34;https://middleware.io/blog/understanding-the-docker-ecosystem/&#34;&gt;Docker&lt;/a&gt;, which is often used in Kubernetes clusters, offers multiple logging drivers such as json-file, syslog,&amp;nbsp;&lt;strong&gt;journald, fluentd,&amp;nbsp;&lt;/strong&gt;and&lt;strong&gt;&amp;nbsp;gelf&lt;/strong&gt;. Each driver has its own features and configuration options.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;You can also integrate your logs with the Middleware. Simply&amp;nbsp;&lt;/em&gt;&lt;/strong&gt;&lt;a href=&#34;https://docs.middleware.io/agent-installation/kubernetes&#34;&gt;&lt;strong&gt;&lt;em&gt;click here&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;&amp;nbsp;to know more. You can also use this guide to set up monitoring with&amp;nbsp;&lt;/em&gt;&lt;/strong&gt;&lt;a href=&#34;https://docs.middleware.io/apm-configuration/node-js&#34;&gt;&lt;strong&gt;&lt;em&gt;Node.js&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;h-2-kubernetes-logging-sources&#34;&gt;2. Kubernetes logging sources&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;i. Application logs&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Application logs are generated by the applications running inside&amp;nbsp;&lt;a href=&#34;https://middleware.io/blog/containerization/&#34;&gt;containers&lt;/a&gt;. These logs are essential for understanding application-specific events and behaviors.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;To access application logs, you can use the `kubectl logs` command:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl logs &amp;lt;pod-name&amp;gt;&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;ii. Node Logs&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Node logs are generated by the Kubernetes nodes and include logs from the kubelet, container runtime, and other node-level components. These logs help monitor the health and performance of individual nodes.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;To access node logs, you can use SSH to connect to the node and view logs stored in the `/var/log` directory:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;ssh user@node-ip&#xA;&#xA;sudo tail -f /var/log/kubelet.log&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;iii. Cluster Logs&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Cluster logs encompass logs from the entire Kubernetes cluster, including logs from the control plane components like the API server, scheduler, and controller manager. These logs are crucial for understanding the cluster’s overall health and performance.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;To access cluster logs, you can use the `kubectl` command with the appropriate component:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl logs &amp;lt;pod-name&amp;gt; -n kube-system&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Here, kube-system is a namespace in Kubernetes used to host the core infrastructure components and system services that are essential for running and managing the cluster. It is a predefined namespace that comes with every Kubernetes installation.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;setting-the-stage&#34;&gt;Setting the stage&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;h-using-a-demo-microservice-to-explain-logging-monitoring-and-debugging&#34;&gt;Using a demo microservice to explain logging, monitoring, and debugging&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;To understand the intricacies of logging in Kubernetes, we’ll use a demo&amp;nbsp;&lt;a href=&#34;https://middleware.io/blog/microservices-architecture/&#34;&gt;microservice&lt;/a&gt;. This simple project will help us explore how to set up logging, monitor logs, and debug issues within a production-like Kubernetes environment.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;h-basics-of-the-project&#34;&gt;Basics of the project&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The demo microservice is a Node.js application with basic functionalities like user authentication, transactions, and payments. It includes several endpoints to simulate different scenarios and log relevant events.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Here’s the basic structure of the project:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;1.&amp;nbsp;&lt;strong&gt;app.js&lt;/strong&gt;: The main application file.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;2.&amp;nbsp;&lt;strong&gt;Dockerfile&lt;/strong&gt;: Used to containerize the application.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;3.&amp;nbsp;&lt;strong&gt;deployment.yaml&lt;/strong&gt;: Kubernetes deployment configuration.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;4.&amp;nbsp;&lt;strong&gt;service.yaml&lt;/strong&gt;: Kubernetes service configuration.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;5.&amp;nbsp;&lt;strong&gt;simulate_requests.sh&lt;/strong&gt;: Script to simulate various user interactions.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;h-setting-up-the-project&#34;&gt;Setting up the project&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;1. Create the Application File (`app.js`)&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;First create the project directory and initialize an empty node project. Then install&amp;nbsp;&lt;a href=&#34;https://expressjs.com/&#34;&gt;ExpressJS&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```&#xA;mkdir kubernetes-logging-demo&#xA;cd kubernetes-logging-demo&#xA;npm init -y&#xA;npm install express&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The application handles user authentication, transactions, and payments, and includes logging for different events. Here’s the complete code for `app.js` file.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```javascript&#xA;const express = require(&#39;express&#39;);&#xA;const app = express();&#xA;const port = 3000;&#xA;&#xA;app.use(express.json());&#xA;&#xA;// Simulated database&#xA;const users = {&#xA;    &#34;john_doe&#34;: { password: &#34;12345&#34;, balance: 100 },&#xA;    &#34;jane_doe&#34;: { password: &#34;67890&#34;, balance: 200 }&#xA;};&#xA;&#xA;// Helper function for logging&#xA;const log = (level, message) =&amp;gt; {&#xA;    const timestamp = new Date().toLocaleString();&#xA;    console.log(`${timestamp} - ${level} - ${message}`);&#xA;};  &#xA;&#xA;// Middleware to log requests&#xA;app.use((req, res, next) =&amp;gt; {&#xA;    log(&#39;info&#39;, `Request received: ${req.method} ${req.originalUrl}`);&#xA;    next();&#xA;});&#xA;&#xA;// Endpoint for user authentication&#xA;app.post(&#39;/login&#39;, (req, res) =&amp;gt; {&#xA;    const { username, password } = req.body;&#xA;    if (users[username] &amp;amp;&amp;amp; users[username].password === password) {&#xA;        log(&#39;info&#39;, `User login successful: ${username}`);&#xA;        res.status(200).send(&#39;Login successful&#39;);&#xA;    } else {&#xA;        log(&#39;warn&#39;, `User login failed: ${username}`);&#xA;        res.status(401).send(&#39;Login failed&#39;);&#xA;    }&#xA;});&#xA;&#xA;// Endpoint for logging user transactions&#xA;app.post(&#39;/transaction&#39;, (req, res) =&amp;gt; {&#xA;    const { username, amount } = req.body;&#xA;    if (users[username]) {&#xA;        users[username].balance += amount;&#xA;        log(&#39;info&#39;, `Transaction successful: ${username} new balance: ${users[username].balance}`);&#xA;        res.status(200).send(&#39;Transaction successful&#39;);&#xA;    } else {&#xA;        log(&#39;warn&#39;, `Transaction failed: User not found - ${username}`);&#xA;        res.status(404).send(&#39;User not found&#39;);&#xA;    }&#xA;});&#xA;&#xA;// Endpoint for simulating payment processing&#xA;app.post(&#39;/payment&#39;, (req, res) =&amp;gt; {&#xA;    const { username, amount } = req.body;&#xA;    if (users[username]) {&#xA;        if (users[username].balance &amp;gt;= amount) {&#xA;            users[username].balance -= amount;&#xA;            log(&#39;info&#39;, `Payment successful: ${username} amount: ${amount}`);&#xA;            res.status(200).send(&#39;Payment successful&#39;);&#xA;        } else {&#xA;            log(&#39;warn&#39;, `Payment failed: Insufficient funds - ${username}`);&#xA;            res.status(400).send(&#39;Insufficient funds&#39;);&#xA;        }&#xA;    } else {&#xA;        log(&#39;warn&#39;, `Payment failed: User not found - ${username}`);&#xA;        res.status(404).send(&#39;User not found&#39;);&#xA;    }&#xA;});&#xA;&#xA;// Endpoint for simulating security incident&#xA;app.post(&#39;/admin&#39;, (req, res) =&amp;gt; {&#xA;    const { username } = req.body;&#xA;    if (username === &#39;admin&#39;) {&#xA;        log(&#39;error&#39;, `Unauthorized access attempt by user: ${username}`);&#xA;        res.status(403).send(&#39;Unauthorized access&#39;);&#xA;    } else {&#xA;        res.status(200).send(&#39;Welcome&#39;);&#xA;    }&#xA;});&#xA;&#xA;app.listen(port, () =&amp;gt; {&#xA;    log(&#39;info&#39;, `Dummy microservice listening at http://localhost:${port}`);&#xA;});&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;2. Create the Dockerfile&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This file is used to build a Docker image of the application.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```Dockerfile&#xA;FROM node:18&#xA;&#xA;WORKDIR /usr/src/app&#xA;&#xA;COPY package*.json ./&#xA;RUN npm install&#xA;&#xA;COPY . .&#xA;&#xA;EXPOSE 3000&#xA;CMD [&#34;node&#34;, &#34;app.js&#34;]&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;3. Create the Kubernetes Deployment Configuration (`deployment.yaml`)&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This file defines how the application will be deployed on Kubernetes.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```yaml&#xA;apiVersion: apps/v1&#xA;kind: Deployment&#xA;metadata:&#xA;  name: logging-demo&#xA;spec:&#xA;  replicas: 1&#xA;  selector:&#xA;    matchLabels:&#xA;      app: logging-demo&#xA;  template:&#xA;    metadata:&#xA;      labels:&#xA;        app: logging-demo&#xA;    spec:&#xA;      containers:&#xA;      - name: logging-demo&#xA;        image: kubernetes-logging-demo:latest&#xA;        imagePullPolicy: Never&#xA;        ports:&#xA;        - containerPort: 3000&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;4. Create the Kubernetes Service Configuration (`service.yaml`)&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This file defines the service that will expose the application within the Kubernetes cluster.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```yaml&#xA;apiVersion: v1&#xA;kind: Service&#xA;metadata:&#xA;  name: logging-demo-service&#xA;spec:&#xA;  selector:&#xA;    app: logging-demo&#xA;  ports:&#xA;    - protocol: TCP&#xA;      port: 80&#xA;      targetPort: 3000&#xA;      nodePort: 30001&#xA;  type: NodePort&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;5. Simulate User Interactions (`simulate_requests.sh`)&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This script sends various requests to the application to simulate different scenarios and trigger logs. Note that this is an infinite loop until terminated.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;&#xA;```bash&#xA;#!/bin/bash&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Define the base URL for the application&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;BASE_URL=&#34;http://localhost:30001&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Define an array of curl commands to simulate different scenarios&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;curl_commands=(&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;# Successful login&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#34;curl -i -X POST $BASE_URL/login -H &#39;Content-Type: application/json&#39; -d &#39;{\&#34;username\&#34;:\&#34;john_doe\&#34;,\&#34;password\&#34;:\&#34;12345\&#34;}&#39;&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Failed login due to wrong password&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;&#34;curl -i -X POST $BASE_URL/login -H &#39;Content-Type: application/json&#39; -d &#39;{\&#34;username\&#34;:\&#34;john_doe\&#34;,\&#34;password\&#34;:\&#34;wrong_password\&#34;}&#39;&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Successful transaction&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;&#34;curl -i -X POST $BASE_URL/transaction -H &#39;Content-Type: application/json&#39; -d &#39;{\&#34;username\&#34;:\&#34;john_doe\&#34;,\&#34;amount\&#34;:50}&#39;&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Failed transaction because the user is not found&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;&#34;curl -i -X POST $BASE_URL/transaction -H &#39;Content-Type: application/json&#39; -d &#39;{\&#34;username\&#34;:\&#34;unknown_user\&#34;,\&#34;amount\&#34;:50}&#39;&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Successful payment&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;&#34;curl -i -X POST $BASE_URL/payment -H &#39;Content-Type: application/json&#39; -d &#39;{\&#34;username\&#34;:\&#34;jane_doe\&#34;,\&#34;amount\&#34;:50}&#39;&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Failed payment due to insufficient funds&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;&#34;curl -i -X POST $BASE_URL/payment -H &#39;Content-Type: application/json&#39; -d &#39;{\&#34;username\&#34;:\&#34;john_doe\&#34;,\&#34;amount\&#34;:200}&#39;&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Unauthorized access attempt&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;&#34;curl -i -X POST $BASE_URL/admin -H &#39;Content-Type: application/json&#39; -d &#39;{\&#34;username\&#34;:\&#34;admin\&#34;}&#39;&#34;&#xA;&#xA;)&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Infinite loop to continuously execute curl requests&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;while true; do&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;Select a random curl command from the array&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;cmd=${curl_commands[$RANDOM % ${#curl_commands[@]}]}&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol start=&#34;2&#34; class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;Print the command being executed (for debugging/visibility)&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;echo &#34; Executing: $cmd&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol start=&#34;3&#34; class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;Execute the selected curl command&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;eval $cmd&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Optional: Add a short sleep to mimic real user behavior&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This adds a delay of 1 second between requests&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;sleep 1&#xA;&#xA;done&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;h-running-the-project-as-a-kubernetes-pod-locally&#34;&gt;Running the project as a Kubernetes pod locally&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;1. Build the docker image&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;docker build -t kubernetes-logging-demo:latest .&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;2. Deploy to Kubernetes&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;kubectl apply -f deployment.yaml&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;kubectl apply -f service.yaml&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;3. Simulate User Interactions (this will make our app generate the logs)&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Use a dedicated bash terminal to keep this simulation running as required.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;./simulate_requests.sh&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;With this, your local setup is ready and you can test out different `kubectl` commands in real time. This setup helps us understand how to collect, monitor, and analyze logs, which is crucial for maintaining the health and performance of our applications.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;scenarios-where-logging-is-crucial&#34;&gt;Scenarios where logging is crucial&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;1. Tracking user activity&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Monitoring user activity is essential for understanding user behavior, identifying trends, and detecting unusual patterns that might indicate security issues.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;2. Debugging payment issues&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Payment-related logs are critical for resolving transaction failures, identifying bugs in the payment processing logic, and ensuring that financial operations are secure and reliable.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;basics-of-kubectl-logs-command&#34;&gt;Basics of kubectl logs Command&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The `kubectl logs` command is a powerful tool for accessing the logs of containers running in your Kubernetes cluster.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Syntax and Basic Usage&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl logs [OPTIONS] POD_NAME [-c CONTAINER_NAME]&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;– `POD_NAME`: The name of the pod whose logs you want to view.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;– `-c CONTAINER_NAME`: (Optional) Specifies the container within the pod. Useful if the pod has multiple containers.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Here’s a simple example to get logs from a pod:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl logs my-pod&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;If the pod contains multiple containers, specify the container name:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl logs my-pod -c my-container&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;If you have properly setup the demo project, you should be able to access your pod name by using this command:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl get pods&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Your terminal might output something like this:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;NAME&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; READY &amp;nbsp; STATUS&amp;nbsp; &amp;nbsp; RESTARTS &amp;nbsp; AGE&#xA;&#xA;logging-demo-6cf76dcb4c-mz7bv &amp;nbsp; 1/1 &amp;nbsp; &amp;nbsp; Running &amp;nbsp; 0&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 69m&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Now, to access the logs of this pod, you just have to run this command:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl logs logging-demo-6cf76dcb4c-mz7bv&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The corresponding output will look something like this:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;6/29/2024, 11:24:52 AM - info - Dummy microservice listening at http://localhost:3000&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Let’s use our `simulate_requests` script to send requests to our pod and try to monitor the logs generated. To do this, simply keep running the script in a dedicated terminal.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Filtering and Viewing Logs by Pod and Container&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;You can filter and view logs for specific pods and containers to narrow down your troubleshooting efforts.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Viewing Logs for a Specific Pod&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;To view logs for a specific pod:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl logs my-pod&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Viewing Logs for a Specific Container in a Pod&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;As explained above, if the pod has multiple containers, specify the container name:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl logs my-pod -c my-container&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Viewing Logs with a Label Selector&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;You can also use label selectors to filter logs from pods that match specific labels:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl logs -l app=my-app&#xA;&#xA;```&#xA;&#xA;For our example project, this would look something like this:&#xA;&#xA;```sh&#xA;&#xA;kubectl logs -l app=logging-demo&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Note that the app name label is configured in the `deployment.yaml` file.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Analyzing Startup and Runtime Logs&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Startup logs are crucial for identifying issues that occur during the initialization phase of your containers, while runtime logs help monitor the ongoing operations.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Viewing Startup Logs&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;To analyze logs from the startup phase of a pod, you can specify the time range from the pod’s creation using the –since flag with the kubectl logs command. This flag allows you to retrieve logs starting from a specified duration in the past, which is particularly useful for investigating recent startups.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl logs --since=5m my-pod&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Viewing Runtime Logs&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;For continuous monitoring of runtime logs, you can use this command:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl logs my-pod --follow&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The `–follow` option streams the logs in real-time, allowing you to monitor the container’s activities as they happen.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;deep-dive-into-kubectl-logs-–tail-command&#34;&gt;Deep Dive into kubectl logs –tail Command&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The `kubectl logs –tail` command is particularly useful for real-time log monitoring and debugging. It helps you view the most recent log entries without having to go through the entire log history.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;How Does It Work, and How Does It Differ from Other Log Options?&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The `–tail` option with `kubectl logs` fetches the last few lines of logs from a pod or container.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Basic syntax:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl logs my-pod --tail=50&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This command retrieves the last 50 lines of logs from `my-pod`.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Differences from Other Log Options&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;–since: Retrieves logs from a specific time period.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;–follow: Stream logs in real-time.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;–tail: Fetches a specified number of recent log lines.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Practical Use Cases&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;How to Tail Logs for Real-Time Monitoring?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;To tail logs for real-time monitoring of a pod, use this command:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl logs my-pod --follow --tail=50&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This streams the last 50 lines of logs and continues to stream new log entries in real-time.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;How to Tail Logs for a Specific Component in the Project&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;For tailing logs of a specific component, specify the container name:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl logs my-pod -c my-container --tail=50&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This command fetches the last 50 lines of logs from the `my-container` container within `my-pod`.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;For our demo project, to get the container details within a pod, you can use the below command.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl describe pod logging-demo-6cf76dcb4c-mz7bv -n default&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;advanced-techniques&#34;&gt;Advanced Techniques&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Combining –tail with Other Flags&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Combining the `–tail` option with other flags in `kubectl logs` can enhance your logging capabilities and provide more detailed insights.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;#### Examples: -f (follow), –since, –timestamps&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Follow (`-f`):&lt;/strong&gt;&amp;nbsp;Combines real-time streaming with tailing the logs.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;&amp;nbsp;&amp;nbsp;kubectl logs my-pod --tail=50 -f&#xA;&#xA;&amp;nbsp;&amp;nbsp;```&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This command fetches the last 50 lines and streams new logs in real-time.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Since (`–since`):&lt;/strong&gt;&amp;nbsp;Retrieves logs from a specific time period.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;&amp;nbsp;&amp;nbsp;kubectl logs my-pod --tail=50 --since=1h&#xA;&#xA;&amp;nbsp;&amp;nbsp;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&amp;nbsp;This command fetches the last 50 lines of logs from the past hour.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Timestamps (`–timestamps`)&lt;/strong&gt;: Adds timestamps to each log entry.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;&amp;nbsp;&amp;nbsp;kubectl logs my-pod --tail=50 --timestamps&#xA;&#xA;&amp;nbsp;&amp;nbsp;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This command includes timestamps for the last 50 log lines, useful for chronological analysis if the component logs do not have timestamps of their own.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Real-World Examples Where These Combinations Are Useful&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;1. Debugging a Deployment Issue:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;kubectl logs my-pod --tail=100 -f --since=10m&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;```&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;This command is useful to debug recent issues by streaming the last 100 lines of logs from the past 10 minutes.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;2. Performance Monitoring:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;kubectl logs my-pod --tail=200 --timestamps -f&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Use this command to monitor performance metrics in real-time with precise timestamps.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;If you use it with our demo project, here’s the output that you may see. Note that the logs generated are due to the simulated requests we are sending.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;kubectl logs logging-demo-6cf76dcb4c-mz7bv --tail=200 --timestamps -f&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2024-06-29T12:45:42.618459492Z 6/29/2024, 12:45:42 PM - info - Request received: POST /payment&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2024-06-29T12:45:42.618497775Z 6/29/2024, 12:45:42 PM - warn - Payment failed: Insufficient funds - jane_doe&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2024-06-29T12:45:43.695529512Z 6/29/2024, 12:45:43 PM - info - Request received: POST /transaction&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2024-06-29T12:45:43.695560010Z 6/29/2024, 12:45:43 PM - info - Transaction successful: john_doe new balance: 200&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2024-06-29T12:45:44.766836119Z 6/29/2024, 12:45:44 PM - info - Request received: POST /login&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2024-06-29T12:45:44.766874021Z 6/29/2024, 12:45:44 PM - warn - User login failed: john_doe&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Using Labels and Selectors&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Filtering logs using labels and selectors helps you focus on specific parts of your application, especially in large clusters.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Filtering Logs Using Labels and Selectors&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;To filter logs by labels:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl logs -l app=my-app --tail=50&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This command fetches the last 50 lines of logs from all pods labeled `app=my-app`.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;h-examples-to-illustrate-the-usage&#34;&gt;&lt;strong&gt;Examples to Illustrate the Usage&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;1. Filtering Logs for the `frontend` Component:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;kubectl logs -l component=frontend --tail=100 -f&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;```&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This command fetches and streams the last 100 lines of logs from all frontend components.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;2. Filtering Logs for Pods Running on a Specific Node:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;kubectl logs -l node=worker-node1 --tail=50&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Use this command to fetch logs from pods running on `worker-node1`.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;You can fetch the list of nodes in your environment using the `kubectl get nodes` command.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Component names are generally configured in your deployment or pod configs, similar to app labels, for better identification.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;scripting-and-automation&#34;&gt;Scripting and automation&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Automating log tailing with scripts and integrating with CI/CD pipelines can enhance continuous monitoring and streamline troubleshooting.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;h-automating-log-tailing-with-scripts&#34;&gt;&lt;strong&gt;Automating log tailing with scripts&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;You can create scripts to automate the process of tailing logs. Here’s an example script:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;#!/bin/bash&#xA;&#xA;# Script to tail logs from all pods with label app=my-app&#xA;&#xA;kubectl logs -l app=logging-demo --tail=100 -f&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Save this script as `tail_logs.sh` and run it to automate log tailing.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;h-integration-with-ci-cd-pipelines-for-continuous-monitoring&#34;&gt;&lt;strong&gt;Integration with CI/CD pipelines for continuous monitoring&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Here’s how you can integrate log tailing in your CI/CD pipelines to monitor deployments and application health continuously.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```yaml&#xA;&#xA;# Example Jenkinsfile&#xA;&#xA;pipeline {&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;agent any&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stages {&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stage(&#39;Deploy&#39;) {&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;steps {&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sh &#39;kubectl apply -f deployment.yaml&#39;&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stage(&#39;Monitor Logs&#39;) {&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;steps {&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sh &#39;./tail_logs.sh&#39;&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&#xA;&#xA;}&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This Jenkins pipeline deploys your application and then tails the logs.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;scenario-based-exploration&#34;&gt;Scenario-Based Exploration&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Once we have run the `simulate_requests.sh` file for sometime, we would have generated a lot of logs in our pod. We have simulated many different positive and negative requests. How do we actually analyze these logs in a production environment? Let’s explore some operations with our project.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Scenario 1: Monitoring Application Performance&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Using tail logs to monitor key performance metrics helps understand your&amp;nbsp;&lt;a href=&#34;https://middleware.io/blog/why-is-monitoring-your-application-important/&#34;&gt;application’s behavior&amp;nbsp;&lt;/a&gt;and performance under load. Here’s how you can effectively monitor and compute these metrics in real-time. You can run these commands in a bash terminal.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Using Tail Logs to Monitor Key Performance Metrics&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;You can create custom scripts to store your logic to measure specific things based on your logs.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl logs -l app=logging-demo --tail=100 | awk &#39;&#xA;&#xA;function parseTime(ts, &amp;nbsp; date, time, ampm, h, m, s) {&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;split(ts, datetime, &#34;, &#34;)&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;date = datetime[1]&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;time = datetime[2]&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ampm = datetime[3]&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;split(date, date_parts, &#34;/&#34;)&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;split(time, time_parts, &#34;:&#34;)&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;h = time_parts[1]&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m = time_parts[2]&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;s = time_parts[3]&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (ampm == &#34;PM&#34; &amp;amp;&amp;amp; h &amp;lt; 12) h += 12&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (ampm == &#34;AM&#34; &amp;amp;&amp;amp; h == 12) h = 0&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return (h * 3600) + (m * 60) + s&#xA;&#xA;}&#xA;&#xA;/-/ {&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;curr_time = parseTime($1 &#34; &#34; $2 &#34; &#34; $3)&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (prev_time &amp;gt; 0) {&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;response_time = curr_time - prev_time&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sum += response_time&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;count += 1&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (response_time &amp;gt; max || count == 1) max = response_time&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (response_time &amp;lt; min || count == 1) min = response_time&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;prev_time = curr_time&#xA;&#xA;}&#xA;&#xA;END {&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (count &amp;gt; 0) {&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printf &#34;Average Response Time: %.2f seconds\nMax Response Time: %d seconds\nMin Response Time: %d seconds\n&#34;, sum/count, max, min&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else {&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print &#34;No response times calculated.&#34;&#xA;&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&#xA;&#xA;}&#39;&#xA;&#xA;```&#xA;&#xA;Output:&#xA;&#xA;```sh&#xA;&#xA;Average Response Time: 0.54 seconds&#xA;&#xA;Max Response Time: 2 seconds&#xA;&#xA;Min Response Time: 0 seconds&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This command fetches the last 100 log lines from all pods labeled `app=logging-demo` in real-time, and uses `awk` to compute key metrics:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Average Response Time&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Max Response Time&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Min Response Time&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Scenario 2: Investigating Security Incidents&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Tail logs are essential for identifying and analyzing suspicious activities, enabling a quick response to security incidents. Here’s how you can filter logs specific to such activity.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Tail Logs for Identifying and Analyzing Suspicious Activities&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl logs -l app=logging-demo --tail=200 | grep -i &#39;error\|failed\|unauthorized&#39; | awk &#39;{count += 1} END {print &#34;Total Security Incidents Detected:&#34;, count}&#39;&#xA;&#xA;```&#xA;&#xA;Output:&#xA;&#xA;```sh&#xA;&#xA;Total Security Incidents Detected: 63&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This command retrieves the last 200 log lines and filters for keywords such as “error,” “failed,” and “unauthorized,” which can help in identifying potential security breach attempts. It uses `awk` to count the number of incidents detected. The `awk` command is a versatile tool for text processing in Unix-like systems. It excels in pattern matching, field manipulation, and generating reports using custom logic as per your application needs.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;By running such commands and scripts, you can directly compute and track essential metrics, enabling real-time monitoring and swift response to any issues.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;By mastering these logging techniques, you can significantly enhance your ability to monitor, troubleshoot, and secure your Kubernetes applications. Start implementing these strategies today to maintain robust and reliable cloud-native applications.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Want to use Middleware for log monitoring? Check out our detailed&amp;nbsp;&lt;a href=&#34;https://docs.middleware.io/workflow/log-monitoring/overview&#34;&gt;documentation here&lt;/a&gt;.&amp;nbsp;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;p&gt;&lt;em&gt;成员帖子最初发布于&lt;a href=&#34;https://middleware.io/blog/kubectl-logs-tail/&#34;&gt;中间件博客&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在云原生应用程序领域，&lt;a href=&#34;https://middleware.io/blog/kubernetes-observability/&#34;&gt;Kubernetes&lt;/a&gt; 是容器编排的首选平台（跨多个主机管理、扩展和维护容器化应用程序的自动化流程）。随着应用程序规模和复杂性的增长，有效的日志记录对于监控、故障排除和维护平稳运行变得至关重要。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;本指南探讨了&lt;a href=&#34;https://middleware.io/blog/kubernetes-logging/&#34;&gt;Kubernetes 日志记录&lt;/a&gt;的复杂性、其重要性以及人们在监控中可能遇到的常见命令活动。我们还将深入研究 Kubernetes 环境中的各种日志记录源，并附上代码示例来说明关键概念。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;overview-of-kubernetes-logging&#34;&gt;Kubernetes 日志记录概述&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Kubernetes 日志监控涉及收集和分析 Kubernetes 集群内各种来源的日志数据。日志提供了有关应用程序、节点和集群本身状态的宝贵见解。它们有助于识别问题、&lt;a href=&#34;https://middleware.io/blog/what-is-application-performance-monitoring/&#34;&gt;了解应用程序行为&lt;/a&gt;以及维护整体系统运行状况。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;importance-of-logging-in-kubernetes&#34;&gt;Kubernetes 中日志记录的重要性&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;问题排查：&lt;/strong&gt;日志通过提供详细的事件记录来帮助诊断和解决问题。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;监控：&lt;/strong&gt;持续&lt;a href=&#34;https://middleware.io/blog/what-is-log-monitoring/&#34;&gt;日志监控&lt;/a&gt;确保应用程序平稳运行帮助检测异常情况。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;合规性&lt;/strong&gt;：日志可用于保持对行业标准和法规的合规性。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;性能优化：&lt;/strong&gt;分析日志可以揭示性能瓶颈和优化机会。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;common-logging-challenges-in-kubernetes-environments&#34;&gt;Kubernetes 环境中的常见日志记录挑战&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;日志量&lt;/strong&gt;：Kubernetes 的动态和可扩展特性会生成大量日志数据，导致管理和分析变得困难。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;日志保留：&lt;/strong&gt;确定保留日志的时间并确保日志得到有效存储。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;日志聚合：&lt;/strong&gt;从多个来源收集日志并将其聚合到一个集中位置。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;日志关联：&lt;/strong&gt;关联来自不同系统部分的日志以全面了解事件。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;understanding-kubernetes-logging&#34;&gt;了解 Kubernetes 日志记录&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;h-1-logging-architecture&#34;&gt;1.日志架构&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;我。 Kubernetes 中的日志记录如何工作&lt;/strong&gt;？&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在 Kubernetes 中，日志通常由容器中运行的应用程序、运行这些容器的节点以及集群组件生成。 Kubernetes 不直接处理日志存储和分析，但允许与各种日志解决方案集成。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;当容器写入日志时，它们会被容器运行时捕获，并且可以使用“&lt;a href=&#34;https://middleware.io/blog/kubectl-cheat-sheet/&#34;&gt;kubectl messages&lt;”等命令进行访问/a&gt;`。然后可以将这些日志发送到外部日志系统进行进一步分析。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;ii.记录驱动程序和选项&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;日志记录驱动程序是容器化环境中的一个组件，用于管理日志的存储和处理方式以及位置。它定义了收集、格式化容器日志并将其发送到特定日志后端或存储系统的机制。通过配置日志记录驱动程序，您可以控制&lt;a href=&#34;https://middleware.io/blog/what-is-structed-logging/&#34;&gt;日志数据流&lt;/a&gt;，从而更轻松地进行监控和故障排除，并分析应用程序的性能和行为。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Kubernetes 支持各种日志记录驱动程序和选项以满足不同的需求。 &lt;a href=&#34;https://middleware.io/blog/understanding-the-docker-ecosystem/&#34;&gt;Docker&lt;/a&gt;，常用于 Kubernetes 集群，提供多种日志驱动，如 json-file、syslog 、&lt;strong&gt;journald、&lt;/strong&gt;和&lt;strong&gt;gelf&lt;/strong&gt;。每个驱动程序都有自己的功能和配置选项。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;您还可以将日志与中间件集成。只需&lt;/em&gt;&lt;/strong&gt;&lt;a href=&#34;https://docs.middleware.io/agent-installation/kubernetes&#34;&gt;&lt;strong&gt;&lt;em&gt;点击此处&lt;/em&gt;&lt;/strong&gt;&lt;/a &gt;&lt;strong&gt;&lt;em&gt; 了解更多信息。您还可以使用本指南使用 Node 设置监控&lt;/em&gt;&lt;/strong&gt;&lt;a href=&#34;https://docs.middleware.io/apm-configuration/node-js&#34;&gt;&lt;strong&gt;&lt;em&gt;Node .js&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;h-2-kubernetes-logging-sources&#34;&gt;2. Kubernetes 日志源&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;我。应用程序日志&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;应用程序日志由&lt;a href=&#34;https://middleware.io/blog/containerization/&#34;&gt;容器&lt;/a&gt;内运行的应用程序生成。这些日志对于理解特定于应用程序的事件和行为至关重要。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;要访问应用程序日志，您可以使用“kubectl messages”命令：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl 日志 &lt;pod 名称&gt;&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;ii.节点日志&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;节点日志由 Kubernetes 节点生成，包括来自 kubelet、容器运行时和其他节点级组件的日志内容。这些日志有助于监控各个节点的运行状况和性能。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;要访问节点日志，您可以使用 SSH 连接到节点并查看存储在 `/var/log` 目录中的日志：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;ssh 用户@节点IP&#xA;&#xA;sudo tail -f /var/log/kubelet.log&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;iii.集群日志&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;集群日志包含来自整个 Kubernetes 集群的日志，包括来自 API 服务器、调度程序和控制器管理器等控制平面组件的日志。这些日志对于了解集群的整体运行状况和性能至关重要。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;要访问集群日志，您可以使用“kubectl”命令和适当的组件：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl 日志 &lt;pod-name&gt; -n kube-system&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这里，kube-system是Kubernetes中的一个命名空间，用于托管运行和管理集群所必需的核心基础设施组件和系统服务。它是每个 Kubernetes 安装附带的预定义命名空间。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;setting-the-stage&#34;&gt;设置舞台&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;h-using-a-demo-microservice-to-explain-logging-monitoring-and-debugging&#34;&gt;使用演示微服务来解释日志记录、监控和调试&lt; /h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;为了了解 Kubernetes 中日志记录的复杂性，我们将使用一个演示&lt;a href=&#34;https://middleware.io/blog/microservices-architecture/&#34;&gt;微服务&lt;/a&gt;。这个简单的项目将帮助我们探索如何在类似生产的 Kubernetes 环境中设置日志记录、监控日志和调试问题。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;h-basics-of-the-project&#34;&gt;项目基础&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;演示微服务是一个 Node.js 应用程序，具有用户身份验证、交易和支付等基本功能。它包括多个端点来模拟不同的场景并记录相关事件。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;以下是该项目的基本结构：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;1. &lt;strong&gt;app.js&lt;/strong&gt;：主应用程序文件。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;2. &lt;strong&gt;Dockerfile&lt;/strong&gt;：用于容器化应用程序。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;3. &lt;strong&gt;deployment.yaml&lt;/strong&gt;：Kubernetes 部署配置。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;4. &lt;strong&gt;service.yaml&lt;/strong&gt;：Kubernetes 服务配置。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;5. &lt;strong&gt;simulate_requests.sh&lt;/strong&gt;：模拟各种用户交互的脚本。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;h-setting-up-the-project&#34;&gt;设置项目&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;强&gt;1。创建应用程序文件（`app.js`）&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;首先创建项目目录并初始化一个空节点项目。然后安装&lt;a href=&#34;https://expressjs.com/&#34;&gt;ExpressJS&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```&#xA;mkdir kubernetes-logging-demo&#xA;cd kubernetes-logging-demo&#xA;npm 初始化 -y&#xA;npm 安装快速&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;应用程序处理用户身份验证离子、交易和支付，并包括不同事件的日志记录。这是“app.js”文件的完整代码。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```javascript&#xA;const express = require(&#39;express&#39;);&#xA;常量应用程序 = Express();&#xA;常量端口= 3000；&#xA;&#xA;app.use(express.json());&#xA;&#xA;// 模拟数据库&#xA;常量用户 = {&#xA;    &#34;john_doe&#34;: { 密码: &#34;12345&#34;, 余额: 100 },&#xA;    &#34;jane_doe&#34;: { 密码: &#34;67890&#34;, 余额: 200 }&#xA;};&#xA;&#xA;// 用于记录日志的辅助函数&#xA;const log = (级别, 消息) =&gt; {&#xA;    const 时间戳 = new Date().toLocaleString();&#xA;    console.log(`${timestamp} - ${level} - ${message}`);&#xA;};  &#xA;&#xA;// 记录请求的中间件&#xA;app.use((req, res, 下一个) =&gt; {&#xA;    log(&#39;info&#39;, `收到请求：${req.method} ${req.originalUrl}`);&#xA;    下一个（）;&#xA;});&#xA;&#xA;// 用户认证的端点&#xA;app.post(&#39;/login&#39;, (req, res) =&gt; {&#xA;    const { 用户名, 密码 } = req.body;&#xA;    if (users[用户名] &amp;&amp; users[用户名].password === 密码) {&#xA;        log(&#39;info&#39;, `用户登录成功：${用户名}`);&#xA;        res.status(200).send(&#39;登录成功&#39;);&#xA;    } 别的 {&#xA;        log(&#39;warn&#39;, `用户登录失败：${用户名}`);&#xA;        res.status(401).send(&#39;登录失败&#39;);&#xA;    }&#xA;});&#xA;&#xA;// 记录用户交易的端点&#xA;app.post(&#39;/transaction&#39;, (req, res) =&gt; {&#xA;    const { 用户名, 金额 } = req.body;&#xA;    if (用户[用户名]) {&#xA;        users[用户名].balance += 金额；&#xA;        log(&#39;info&#39;, `交易成功: ${username} 新余额: ${users[username].balance}`);&#xA;        res.status(200).send(&#39;交易成功&#39;);&#xA;    } 别的 {&#xA;        log(&#39;warn&#39;, `交易失败: 未找到用户 - ${username}`);&#xA;        res.status(404).send(&#39;未找到用户&#39;);&#xA;    }&#xA;});&#xA;&#xA;// 模拟支付处理的端点&#xA;app.post(&#39;/付款&#39;, (req, res) =&gt; {&#xA;    const { 用户名, 金额 } = req.body;&#xA;    if (用户[用户名]) {&#xA;        if (用户[用户名].balance &gt;= 金额) {&#xA;            users[用户名].balance -= 金额；&#xA;            log(&#39;info&#39;, `支付成功：${用户名} 金额：${金额}`);&#xA;            res.status(200).send(&#39;支付成功&#39;);&#xA;        } 别的 {&#xA;            log(&#39;warn&#39;, `支付失败：资金不足 - ${username}`);&#xA;            res.status(400).send(&#39;资金不足&#39;);&#xA;        }&#xA;    } 别的 {&#xA;        log(&#39;warn&#39;, `付款失败: 未找到用户 - ${username}`);&#xA;        res.status(404).send(&#39;未找到用户&#39;);&#xA;    }&#xA;});&#xA;&#xA;// 模拟安全事件的端点&#xA;app.post(&#39;/admin&#39;, (req, res) =&gt; {&#xA;    const { 用户名 } = req.body;&#xA;    if (用户名 === &#39;admin&#39;) {&#xA;        log(&#39;error&#39;, `用户未经授权的访问尝试：${username}`);&#xA;        res.status(403).send(&#39;未经授权的访问&#39;);&#xA;    } 别的 {&#xA;        res.status(200).send(&#39;欢迎&#39;);&#xA;    }&#xA;});&#xA;&#xA;app.listen(端口, () =&gt; {&#xA;    log(&#39;info&#39;, `在 http://localhost:${port} 监听的虚拟微服务`);&#xA;});&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;强&gt;2。创建 Dockerfile&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此文件用于构建应用程序的 Docker 映像。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```Dockerfile&#xA;来自节点：18&#xA;&#xA;工作目录 /usr/src/app&#xA;&#xA;复制包*.json ./&#xA;运行 npm 安装&#xA;&#xA;复制 。 。&#xA;&#xA;曝光 3000&#xA;CMD [“节点”，“app.js”]&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;强&gt;3。创建 Kubernetes 部署配置 (`deployment.yaml`)&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此文件定义如何在 Kubernetes 上部署应用程序。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```yaml&#xA;api版本：apps/v1&#xA;种类：部署&#xA;元数据：&#xA;  名称：日志记录演示&#xA;规格：&#xA;  副本：1&#xA;  选择器：&#xA;    匹配标签：&#xA;      应用程序：日志记录演示&#xA;  模板：&#xA;    元数据：&#xA;      标签：&#xA;        应用程序：日志记录演示&#xA;    规格：&#xA;      容器：&#xA;      - 名称：日志记录演示&#xA;        图片：kubernetes-logging-demo：最新&#xA;        imagePullPolicy：从不&#xA;        端口：&#xA;        - 集装箱端口：3000&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;强&gt;4。创建 Kubernetes 服务配置 (`service.yaml`)&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此文件定义将在 Kubernetes 集群中公开应用程序的服务。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```yaml&#xA;api版本：v1&#xA;种类： 服务&#xA;元数据：&#xA;  名称：日志记录演示服务&#xA;规格：&#xA;  选择器：&#xA;    应用程序：日志记录演示&#xA;  端口：&#xA;    - 协议：TCP&#xA;      端口：80&#xA;      目标端口：3000&#xA;      节点端口：30001&#xA;  类型：节点端口&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;强&gt;5。模拟用户交互（`simulate_requests.sh`）&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;该脚本向应用程序发送各种请求来模拟不同的场景并触发日志。请注意，这是一个无限循环，直到终止。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;&#xA;````bash&#xA;#!/bin/bash&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;定义应用程序的基本 URL&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;BASE_URL=&#34;http://localhost:30001&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;定义一系列curl命令来模拟不同的场景&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;curl_commands=(&#xA;&#xA;    # 登录成功&#xA;&#xA;    “curl -i -X POST $BASE_URL/login -H &#39;内容类型：application/json&#39; -d &#39;{\“用户名\”：\“john_doe \”，\“密码\”：\“12345 \”} &#39;&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;密码错误导致登录失败&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;&#34;curl -i -X POST $BASE_URL/login -H &#39;内容类型：application/json&#39; -d &#39;{\&#34;用户名\&#34; :\&#34;john_doe\&#34;,\&#34;密码\&#34;:\&#34;错误的_密码\&#34;}&#39;&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;交易成功&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;&#34;curl -i -X POST $BASE_URL/transaction -H &#39;内容类型：application/json&#39; -d &#39;{\&#34;用户名\&#34; :\&#34;john_doe\&#34;,\&#34;金额\&#34;:50}&#39;&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;由于找不到用户，交易失败&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;&#34;curl -i -X POST $BASE_URL/transaction -H &#39;内容类型：application/json&#39; -d &#39;{\&#34;用户名\&#34; :\&#34;unknown_user\&#34;,\&#34;金额\&#34;:50}&#39;&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;支付成功&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;&#34;curl -i -X POST $BASE_URL/payment -H &#39;内容类型：application/json&#39; -d &#39;{\&#34;用户名\&#34;:\&#34;jane_doe\&#34;,\&#34;金额\&#34;:50}&#39;&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;资金不足，支付失败&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;&#34;curl -i -X POST $BASE_URL/ payment -H &#39;内容类型：application/json&#39; -d &#39;{\&#34;用户名\&#34; :\&#34;john_doe\&#34;,\&#34;金额\&#34;:200}&#39;&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;未经授权的访问尝试&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;&#34;curl -i -X POST $BASE_URL/admin -H &#39;内容类型：application/json&#39; -d &#39;{\&#34;用户名\&#34; ：\“行政\”}&#39;”&#xA;&#xA;）&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;无限循环不断执行curl请求&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;虽然正确；做&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol类=“wp-block-list”&gt;&#xA;&lt;li&gt;&lt;strong&gt;从数组中选择随机curl命令&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;cmd=${curl_commands[$RANDOM % ${#curl_commands[@]}]}&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol start=&#34;2&#34; class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;打印正在执行的命令（用于调试/可见性）&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;echo &#34;正在执行：$cmd&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol start=&#34;3&#34; class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;执行所选的curl命令&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;eval $cmd&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;可选：添加短暂睡眠以模仿真实用户行为&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这会在请求之间增加 1 秒的延迟&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;睡眠 1&#xA;&#xA;完毕&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;h-running-the-project-as-a-kubernetes-pod-locally&#34;&gt;在本地将项目作为 Kubernetes Pod 运行&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;强&gt;1。构建docker镜像&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;    docker build -t kubernetes-logging-demo:latest 。&#xA;&#xA;    ```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;强&gt;2。部署到 Kubernetes&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;    kubectl apply -f 部署.yaml&#xA;&#xA;    kubectl apply -f service.yaml&#xA;&#xA;    ```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;强&gt;3。模拟用户交互（这将使我们的应用程序生成日志）&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;    使用专用的 bash 终端来保持此模拟按要求运行。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;    ./simulate_requests.sh&#xA;&#xA;    ```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这样，您的本地设置就已准备就绪，您可以实时测试不同的“kubectl”命令。此设置帮助我们了解如何收集、监控和分析日志，这对于维护应用程序的健康和性能至关重要。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;scenarios-where-logging-is-crucial&#34;&gt;日志记录至关重要的场景&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;强&gt;1。跟踪用户活动&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;监控用户活动对于了解用户行为、识别趋势和检测用户行为至关重要g 可能表明安全问题的异常模式。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;强&gt;2。调试支付问题&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;支付相关日志对于解决交易失败、识别支付处理逻辑中的错误以及确保财务运营安全可靠至关重要。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;basics-of-kubectl-logs-command&#34;&gt;kubectl 日志命令基础知识&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;“kubectl messages”命令是一个强大的工具，用于访问 Kubernetes 集群中运行的容器的日志。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;语法和基本用法&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl 日志 [选项] POD_NAME [-c CONTAINER_NAME]&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;– `POD_NAME`：您要查看其日志的 pod 的名称。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;– `-c CONTAINER_NAME`：（可选）指定 pod 内的容器。如果 Pod 有多个容器，则很有用。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这是一个从 Pod 获取日志的简单示例：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl 记录 my-pod&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果 Pod 包含多个容器，请指定容器名称：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl 记录 my-pod -c my-container&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果您已正确设置演示项目，您应该能够使用以下命令访问您的 Pod 名称：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl 获取 Pod&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;您的终端可能会输出如下内容：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;姓名                            准备状态    重新开始 年龄&#xA;&#xA;logging-demo-6cf76dcb4c-mz7bv 1/1 运行 0 0 69m&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;现在，要访问此 Pod 的日志，您只需运行以下命令：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl 日志记录-demo-6cf76dcb4c-mz7bv&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;相应的输出将如下所示：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;2024 年 6 月 29 日，上午 11:24:52 - 信息 - 虚拟微服务监听 http://localhost:3000&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;让我们使用“simulate_requests”脚本将请求发送到我们的 Pod 并尝试监控生成的日志。为此，只需在专用终端中继续运行脚本即可。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;按 Pod 和容器过滤和查看日志&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;您可以过滤和查看特定 Pod 和容器的日志，以缩小故障排除范围。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;查看特定 Pod 的日志&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;查看特定 Pod 的日志：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl 记录 my-pod&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;查看 Pod 中特定容器的日志&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如上所述，如果 Pod 有多个容器，指定容器名称：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl 记录 my-pod -c my-container&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;使用标签选择器查看日志&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;您还可以使用标签选择器来过滤来自与特定标签匹配的 Pod 的日志：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl 日志 -l app=my-app&#xA;&#xA;````&#xA;&#xA;对于我们的示例项目，这看起来像这样：&#xA;&#xA;````嘘&#xA;&#xA;kubectl 日志 -l app=logging-demo&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;请注意，应用程序名称标签是在“deployment.yaml”文件中配置的。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;分析启动和运行时日志&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;启动日志对于识别容器初始化阶段发生的问题至关重要，而运行时日志有助于监控正在进行的操作。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;查看启动日志&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;要分析 Pod 启动阶段的日志，您可以使用 kubectl logs 命令的 –since 标志指定从 Pod 创建开始的时间范围。此标志允许您检索从过去指定持续时间开始的日志，这对于调查最近的启动特别有用。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl 日志 --since=5m my-pod&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;查看运行时日志&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;要持续监控运行时日志，可以使用以下命令：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl 记录 my-pod --follow&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;“--follow”选项实时传输日志，让您可以监控容器的活动发生情况。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;deep-dive-into-kubectl-logs-–tail-command&#34;&gt;深入研究 kubectl 日志 –tail 命令&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;“kubectl messages –tail”命令对于实时日志监控和调试特别有用。它可以帮助您查看最新的日志条目，而无需浏览整个日志历史记录。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;它是如何工作的，与其他日志选项有何不同？&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;带有“kubectl messages”的“-tail”选项从 Pod 或容器中获取最后几行日志。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;基本语法：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl 记录 my-pod --tail=50&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此命令从“my-pod”检索最后 50 行日志。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;与其他日志选项的差异&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;--since：检索特定时间段内的日志。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;-follow：实时流式传输日志。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;--tail：获取指定数量的最近日志行。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;实际用例&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;如何跟踪日志以进行实时监控？&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;要跟踪日志以实时监控 Pod，请使用以下命令：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl 记录 my-pod --follow --tail=50&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这将流式传输最后 50 升日志并继续实时传输新的日志条目。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;如何跟踪项目中特定组件的日志&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;对于特定组件的尾部日志，请指定容器名称：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl 记录 my-pod -c my-container --tail=50&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此命令从“my-pod”内的“my-container”容器中获取最后 50 行日志。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;对于我们的演示项目，要获取 Pod 中的容器详细信息，您可以使用以下命令。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl 描述 podlogging-demo-6cf76dcb4c-mz7bv -n 默认&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;advanced-techniques&#34;&gt;高级技术&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;将 –tail 与其他标志组合&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;将“--tail”选项与“kubectl日志”中的其他标志相结合可以增强您的日志记录功能并提供更详细的见解。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;#### 示例：-f（跟随）、–since、–timestamps&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;跟随 (`-f`)：&lt;/strong&gt; 将实时流式传输与跟踪日志相结合。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;  kubectl 记录 my-pod --tail=50 -f&#xA;&#xA;  ```  &lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此命令获取最后 50 行并实时传输新日志。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;自 (`–since`)：&lt;/strong&gt; 检索特定时间段内的日志。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;  kubectl 记录 my-pod --tail=50 --since=1h&#xA;&#xA;  ```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt; 此命令获取过去一小时的最后 50 行日志。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;时间戳 (`–timestamps`)&lt;/strong&gt;：向每个日志条目添加时间戳。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;  kubectl 记录 my-pod --tail=50 --timestamps&#xA;&#xA;  ```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此命令包括最后 50 条日志行的时间戳，如果组件日志没有自己的时间戳，则对于按时间顺序分析非常有用。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;这些组合有用的真实示例&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;强&gt;1。调试部署问题：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;   kubectl 记录 my-pod --tail=100 -f --since=10m&#xA;&#xA;   ```   &lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;   此命令可用于通过流式传输过去 10 分钟的最后 100 行日志来调试最近的问题。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;强&gt;2。性能监控：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;    kubectl 记录 my-pod --tail=200 --timestamps -f&#xA;&#xA;    ```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;使用此命令可以通过精确的时间戳实时监控性能指标。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果您在我们的演示项目中使用它，您可能会看到以下输出。请注意，生成的日志是由于模拟我们正在发送 ted 请求。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;    kubectl 日志记录-demo-6cf76dcb4c-mz7bv --tail=200 --timestamps -f&#xA;&#xA;    2024-06-29T12:45:42.618459492Z 6/29/2024, 12:45:42 PM - 信息 - 收到请求：POST /付款&#xA;&#xA;    2024-06-29T12:45:42.618497775Z 6/29/2024, 12:45:42 PM - 警告 - 付款失败：资金不足 - jane_doe&#xA;&#xA;    2024-06-29T12:45:43.695529512Z 6/29/2024, 12:45:43 PM - 信息 - 收到请求：POST /交易&#xA;&#xA;    2024-06-29T12:45:43.695560010Z 6/29/2024, 12:45:43 PM - 信息 - 交易成功：john_doe 新余额：200&#xA;&#xA;    2024-06-29T12:45:44.766836119Z 6/29/2024, 12:45:44 PM - 信息 - 收到请求：POST /登录&#xA;&#xA;    2024-06-29T12:45:44.766874021Z 6/29/2024, 12:45:44 PM - 警告 - 用户登录失败：john_doe&#xA;&#xA;    。&#xA;&#xA;    。&#xA;&#xA;    。&#xA;&#xA;    ```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;使用标签和选择器&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;使用标签和选择器过滤日志可以帮助您专注于应用程序的特定部分，尤其是在大型集群中。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;使用标签和选择器过滤日志&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;按标签过滤日志：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl 日志 -l app=my-app --tail=50&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此命令从所有标记为“app=my-app”的 pod 中获取最后 50 行日志。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;h-examples-to-illustrate-the-usage&#34;&gt;&lt;strong&gt;说明用法的示例&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;强&gt;1。过滤“前端”组件的日志：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;   kubectl 日志 -l 组件=前端 --tail=100 -f&#xA;&#xA;   ```   &lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此命令从所有前端组件获取并流式传输最后 100 行日志。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;强&gt;2。过滤特定节点上运行的 Pod 的日志：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;   kubectl 日志 -l 节点=worker-node1 --tail=50&#xA;&#xA;   ```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;使用此命令从“worker-node1”上运行的 Pod 获取日志。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;您可以使用“kubectl getnodes”命令获取环境中的节点列表。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;组件名称通常在部署或 Pod 配置中配置，类似于应用标签，以便更好地识别。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;scripting-and-automation&#34;&gt;脚本和自动化&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;使用脚本自动进行日志跟踪并与 CI/CD 管道集成可以增强持续监控并简化故障排除。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;h-automating-log-tailing-with-scripts&#34;&gt;&lt;strong&gt;使用脚本自动进行日志尾随&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;您可以创建脚本来自动执行 p尾矿原木的处理过程。这是一个示例脚本：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;#!/bin/bash&#xA;&#xA;# 用于跟踪所有带有标签 app=my-app 的 pod 的日志的脚本&#xA;&#xA;kubectl 日志 -l app=logging-demo --tail=100 -f&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;将此脚本保存为“tail_logs.sh”并运行它以自动进行日志尾随。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34; id=&#34;h-integration-with-ci-cd-pipelines-for-continuous-monitoring&#34;&gt;&lt;strong&gt;与 CI/CD 管道集成以进行持续监控&lt;/strong&gt;&lt; /h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;以下介绍了如何将日志跟踪集成到 CI/CD 管道中，以持续监控部署和应用程序运行状况。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```yaml&#xA;&#xA;# Jenkins 文件示例&#xA;&#xA;管道{&#xA;&#xA;    代理任何&#xA;&#xA;    阶段{&#xA;&#xA;        阶段（&#39;部署&#39;）{&#xA;&#xA;            步骤{&#xA;&#xA;                sh &#39;kubectl apply -f deployment.yaml&#39;&#xA;&#xA;            }&#xA;&#xA;        }&#xA;&#xA;        阶段（&#39;监控日志&#39;）{&#xA;&#xA;            步骤{&#xA;&#xA;                sh &#39;./tail_logs.sh&#39;&#xA;&#xA;            }&#xA;&#xA;        }&#xA;&#xA;    }&#xA;&#xA;}&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此 Jenkins 管道部署您的应用程序，然后跟踪日志。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;scenario-based-exploration&#34;&gt;基于场景的探索&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;一旦我们运行“simulate_requests.sh”文件一段时间，我们就会在 Pod 中生成大量日志。我们模拟了许多不同的正面和负面请求。我们如何在生产环境中实际分析这些日志？让我们通过我们的项目探索一些操作。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;场景 1：监控应用程序性能&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;使用尾部日志监控关键性能指标有助于了解您的&lt;a href=&#34;https://middleware.io/blog/why-is-monitoring-your-application-important/&#34;&gt;应用的行为&lt;/a&gt;和负载下的性能。以下是如何有效地实时监控和计算这些指标。您可以在 bash 终端中运行这些命令。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;使用尾日志监控关键性能指标&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;您可以创建自定义脚本来存储逻辑，以根据日志测量特定事物。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl 日志 -l app=logging-demo --tail=100 | awk&#39;&#xA;&#xA;函数 parseTime(ts, 日期, 时间, ampm, h, m, s) {&#xA;&#xA;    分割（ts，日期时间，“，”）&#xA;&#xA;    日期 = 日期时间[1]&#xA;&#xA;    时间 = 日期时间[2]&#xA;&#xA;    ampm = 日期时间[3]&#xA;&#xA;    分割（日期，日期部分，“/”）&#xA;&#xA;    分割（时间，time_parts，“：”）&#xA;&#xA;    h = 时间部分[1]&#xA;&#xA;    m = 时间_部分[2]&#xA;&#xA;    s = 时间_部分[3]&#xA;&#xA;    if (ampm == &#34;PM&#34; &amp;&amp; h &lt; 12) h += 12&#xA;&#xA;    if (ampm == &#34;AM&#34; &amp;&amp; h == 12) h = 0&#xA;&#xA;    返回 (h * 3600) + (m * 60) + s&#xA;&#xA;}&#xA;&#xA;/-/ {&#xA;&#xA;    curr_time = parseTime($1 &#34; &#34; $2 &#34; &#34; $3)&#xA;&#xA;    if (prev_time &gt; 0) {&#xA;&#xA;        响应时间 = 当前时间 - 先前时间&#xA;&#xA;        总和 += 响应时间&#xA;&#xA;        计数 += 1&#xA;&#xA;        if (响应时间 &gt; 最大 || 计数 == 1) 最大 = 响应时间&#xA;&#xA;        if (响应时间 &lt; 分钟 || 计数 == 1) 分钟 = 响应时间&#xA;&#xA;    }&#xA;&#xA;    上一个时间 = 当前时间&#xA;&#xA;}&#xA;&#xA;结尾 {&#xA;&#xA;    如果（计数&gt; 0）{&#xA;&#xA;        printf &#34;平均响应时间: %.2f 秒\n最大响应时间: %d 秒\n最小响应时间: %d 秒\n&#34;, 总和/计数、最大值、最小值&#xA;&#xA;    } 别的 {&#xA;&#xA;        打印“未计算响应时间。”&#xA;&#xA;    }&#xA;&#xA;}&#39;&#xA;&#xA;````&#xA;&#xA;输出：&#xA;&#xA;````嘘&#xA;&#xA;平均响应时间：0.54秒&#xA;&#xA;最大响应时间：2秒&#xA;&#xA;最短响应时间：0 秒&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此命令从所有标记为“app=logging-demo”的 Pod 中实时获取最后 100 条日志行，并使用“awk”来计算关键指标：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;平均响应时间&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;最长响应时间&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;最短响应时间&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;场景 2：调查安全事件&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;尾部日志对于识别和分析可疑活动至关重要，从而能够快速响应安全事件。以下是您可以如何过滤特定于此类活动的日志。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;用于识别和分析可疑活动的尾部日志&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;```sh&#xA;&#xA;kubectl 日志 -l app=logging-demo --tail=200 | grep -i &#39;错误\|失败\|未经授权&#39; | awk &#39;{count += 1} END {print &#34;检测到的安全事件总数：&#34;, count}&#39;&#xA;&#xA;````&#xA;&#xA;输出：&#xA;&#xA;````嘘&#xA;&#xA;检测到的安全事件总数：63&#xA;&#xA;```&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此命令检索最后 200 行日志并过滤“错误”、“失败”和“未经授权”等关键字，这有助于识别潜在的安全漏洞尝试。它使用“awk”来计算检测到的事件数量。 `awk` 命令是类 Unix 系统中用于文本处理的多功能工具。它在图案方面表现出色根据您的应用程序需求使用自定义逻辑进行匹配、字段操作和生成报告。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;通过运行此类命令和脚本，您可以直接计算和跟踪基本指标，从而实现实时监控并快速响应任何问题。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34; id=&#34;conclusion&#34;&gt;结论&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;通过掌握这些日志记录技术，您可以显着增强监控、排除故障和保护 Kubernetes 应用程序的能力。立即开始实施这些策略，以维护健壮且可靠的云原生应用程序。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;想使用中间件进行日志监控？请&lt;a href=&#34;https://docs.middleware.io/workflow/log-monitoring/overview&#34;&gt;此处查看我们的详细文档&lt;/a&gt;。  &lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Thu, 31 Oct 2024 16:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>