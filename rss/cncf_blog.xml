<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CNCF - Blog</title>
    <link>http://cloudys-rsshub-ab061133bcab.herokuapp.com/cncf</link>
    <description>CNCF - Blog - Powered by RSSHub</description>
    <managingEditor>contact@rsshub.app (RSSHub)</managingEditor>
    <item>
      <title>【Automating stateful apps with Kubernetes Operators】使用 Kubernetes Operators 自动化有状态应用程序</title>
      <link>https://www.cncf.io/blog/2025/10/15/automating-stateful-apps-with-kubernetes-operators/</link>
      <description>【&lt;p&gt;&lt;em&gt;Member post originally published on the &lt;/em&gt;&lt;a href=&#34;https://middleware.io/&#34;&gt;&lt;strong&gt;&lt;em&gt;Middleware&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt; &lt;/em&gt;&lt;/strong&gt;&lt;em&gt;blog by &lt;/em&gt;&lt;a href=&#34;https://middleware.io/blog/authors/keval/&#34;&gt;&lt;strong&gt;&lt;em&gt;Keval Bhogayata&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;, covering &lt;a href=&#34;https://middleware.io/blog/kubernetes-operator/&#34;&gt;&lt;strong&gt;&lt;em&gt;Automating Stateful Apps with Kubernetes Operators.&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;If you’ve ever had issues with scaling databases or automating upgrades in Kubernetes, Operators can help by saving you time and effort. Handling complex Kubernetes applications like databases, message queues, and &lt;a href=&#34;https://middleware.io/blog/what-is-distributed-tracing/&#34;&gt;distributed systems&lt;/a&gt; can be really difficult. Kubernetes handles simple workloads well, while big apps suffer with failover, scaling, backups, and automated updates. These activities often demand operational expertise.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;If you’re new to container orchestration, you may want to start by understanding the difference between &lt;a href=&#34;https://middleware.io/blog/kubernetes-vs-docker/&#34;&gt;Kubernetes vs Docker&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This is where you need Kubernetes Operators, which we’ll cover in this article. You’ll learn what these Operators are, how they work, and why you need them.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Let’s get to it.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;What are Kubernetes Operators?&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Operators are extra tools that help you manage complex or stateful applications in Kubernetes. It is a combination of Controllers and Custom Resource Definitions (CRDs).&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Controllers are the rules for deploying, setting up, scaling, healing, and updating resources. CRDs let you add a new object type to Kubernetes. CRDs also allow you to describe the type of object you want to manage, after which you proceed to create a Custom Resource (CR), which is an instance of the object type you have made.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;637&#34; height=&#34;450&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.16.40-PM.jpg&#34; alt=&#34;Kubernetes Operator Architecture&#34; class=&#34;wp-image-149577&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.16.40-PM.jpg 637w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.16.40-PM-300x212.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.16.40-PM-283x200.jpg 283w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.16.40-PM-566x400.jpg 566w&#34; sizes=&#34;auto, (max-width: 637px) 100vw, 637px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The primary purpose of operators is to simplify the management of complex Kubernetes applications, enabling tasks such as upgrades, failover management, backups, and scalability to be performed automatically.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Difference between traditional Kubernetes Controllers and Operators&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Here’s a breakdown of the difference between the Kubernetes Controller and Operators:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;644&#34; height=&#34;424&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.17.57-PM.jpg&#34; alt=&#34;Breakdown of the difference between the Kubernetes Controller and Operators&#34; class=&#34;wp-image-149578&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.17.57-PM.jpg 644w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.17.57-PM-300x198.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.17.57-PM-304x200.jpg 304w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.17.57-PM-608x400.jpg 608w&#34; sizes=&#34;auto, (max-width: 644px) 100vw, 644px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;How Kubernetes Operators work&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Assuming you have your app ready, a basic Kubernetes setup, and a working deployment. Without Operators, you’ll have to install and manage the app yourself manually. But with Operators, you can run these processes automatically. Here’s how it works:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;1. Set up a Custom Resource&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;A Custom Resource (CR) is an object you make to control a particular aspect of your application. You need to declare a CRD before you can create a CR. CRD tells Kubernetes about the new type of object you are making.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Here’s an example of a CRD that defines a CR called “MyAPP”:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;329&#34; height=&#34;530&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.19.23-PM.jpg&#34; alt=&#34;example of a CRD that defines a CR called “MyAPP”&#34; class=&#34;wp-image-149579&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.19.23-PM.jpg 329w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.19.23-PM-186x300.jpg 186w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.19.23-PM-124x200.jpg 124w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.19.23-PM-248x400.jpg 248w&#34; sizes=&#34;auto, (max-width: 329px) 100vw, 329px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This CRD defines a custom resource called “MyApp.” It has two major fields under spec: size and version.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Once the CRD is applied to the cluster, you can go ahead to create instances of “MyApp,” which represent your app configuration:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;272&#34; height=&#34;160&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.20.19-PM.jpg&#34; alt=&#34;image of instance of “MyApp,” which represent your app configuration&#34; class=&#34;wp-image-149580&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This CR declares that you want 3 replicas of example-app (an instance of MyApp) running with version 1.0.0. The Operator will then watch this resource and make sure your app matches what you declared.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;2. Deploy the Operator into the Kubernetes cluster&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;After defining your CR, the next thing is to deploy the Operator itself. This will monitor CR changes and ensure the cluster status matches your declaration.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;You usually use a set of Kubernetes configuration files (YAML files) to notify the cluster to run the Operator as a Pod. This includes setting up permissions so the Operator can watch and manage resources.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Example:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full is-resized&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;392&#34; height=&#34;34&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.21.16-PM.jpg&#34; alt=&#34;example of setting up permissions so the Operator can watch and manage resources&#34; class=&#34;wp-image-149581&#34; style=&#34;width:392px;height:auto&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.21.16-PM.jpg 392w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.21.16-PM-300x26.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.21.16-PM-388x34.jpg 388w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.21.16-PM-380x34.jpg 380w&#34; sizes=&#34;auto, (max-width: 392px) 100vw, 392px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;3. Continuous monitoring of CR by the Operator.&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;After deployment, the Operator will constantly monitor changes in the CRs it manages. This monitoring can be done using Kubernetes API. It watches for events such as creation, updates, or deletions of these CRs.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The Operator looks out for real-time changes to ensure it can react as soon as something happens. With Kubernetes client, you can set up a watch on your CR like this:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;619&#34; height=&#34;574&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.22.30-PM.jpg&#34; alt=&#34;example of how to set up a watch on your CR&#34; class=&#34;wp-image-149582&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.22.30-PM.jpg 619w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.22.30-PM-300x278.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.22.30-PM-216x200.jpg 216w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.22.30-PM-431x400.jpg 431w&#34; sizes=&#34;auto, (max-width: 619px) 100vw, 619px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This code monitors the “MyApp” CRs in the specified namespace. The Operator will get an event with details when you add, change, or delete a CR. This lets it react fast and keep the app’s state in line with the specified setup.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;4. Reconciliation loop: Operator compares desired vs actual state&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The reconciliation loop is the main idea behind Operators. It makes sure that the actual state of your app matches the desired state you defined in the Custom Resource by re-running the whole process if it fails.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;648&#34; height=&#34;568&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.23.24-PM.jpg&#34; alt=&#34;Reconciliation Loop&#34; class=&#34;wp-image-149583&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.23.24-PM.jpg 648w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.23.24-PM-300x263.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.23.24-PM-228x200.jpg 228w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.23.24-PM-456x400.jpg 456w&#34; sizes=&#34;auto, (max-width: 648px) 100vw, 648px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Here’s how it works:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;The Operator reads the desired state of your CR.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Then it checks the actual state of the cluster.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;If they don’t match, it acts to fix it.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;It repeats this process continuously.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This reconciliation logic can be triggered by the watch events we set up earlier.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;625&#34; height=&#34;305&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.24.08-PM.jpg&#34; alt=&#34;example of reconciliation logic can be triggered by the watch events we set up earlier&#34; class=&#34;wp-image-149584&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.24.08-PM.jpg 625w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.24.08-PM-300x146.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.24.08-PM-410x200.jpg 410w&#34; sizes=&#34;auto, (max-width: 625px) 100vw, 625px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The reconciliation function guarantees your application works as expected.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;5. Error handling&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;One way or the other, you’ll still encounter problems when working with Operators. When issues come up, the Operator won’t just stop. They keep trying until they get the correct result.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;For example, learn about diagnosing and fixing &lt;a href=&#34;https://middleware.io/blog/exit-code-137-in-kubernetes-causes-diagnosis-fixes/&#34;&gt;Exit Code 137 in Kubernetes&lt;/a&gt;, a common error when pods are OOMKilled.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Here’s the idea:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;The operator tries to make the actual state equal to the desired state&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;It logs an error if it fails&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;The reconciliation loop runs again after a while&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;The Operator tries again until it works.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Use cases of Kubernetes Operators&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Operators are mostly helpful when working with complex or stateful apps. Here are some practical scenarios where Operators provide great value and how Middleware helps teams get more visibility out of them:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Handling stateful apps&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Stateful workloads, such as databases, can be challenging to manage because data recovery is crucial. Operators help to manage these workloads even when a container or pod stops. It automatically does backups, restores, scaling, and upgrades. A good example is the Postgres and MySQL Operators.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Postgres Operator allows you to automate backups, failover, and scaling of PostgreSQL clusters. The Operator will automatically configure replicas or restore from snapshots, instead of SREs doing it manually.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Messaging systems&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Messaging platforms like Kafka require careful tuning and scaling, particularly under high traffic loads. The Strimzi Kafka Operator simplifies this by provisioning brokers, handling configuration, and managing users. This removes the stress of manually scaling and restarting on the &lt;a href=&#34;https://middleware.io/blog/what-is-devops/&#34;&gt;DevOps&lt;/a&gt; teams.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Monitoring and logging stacks&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Tools for monitoring and &lt;a href=&#34;https://middleware.io/blog/what-is-log-monitoring/&#34;&gt;logging&lt;/a&gt;, such as &lt;a href=&#34;https://middleware.io/blog/what-is-prometheus/&#34;&gt;Prometheus&lt;/a&gt; or ELK, must always be available and scalable to collect data effectively. Prometheus Operators automate upgrades, scaling, and configuration management. This makes sure that the monitoring pipeline is stable without human intervention.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Automating infrastructure&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Operators are not limited to apps; they can also automate repetitive infrastructure tasks, such as provisioning storage, configuring network policies, or managing certificates. This helps ensure consistency and security while reducing the risk of errors associated with manual processes.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Again, Middleware displays these invisible tasks, which allows SREs to audit changes, track automation workflows, and &lt;a href=&#34;https://docs.middleware.io/workflow/alerting/setup-alert&#34;&gt;set up alerts&lt;/a&gt; when infrastructure doesn’t match the expected state.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Why do we need Operators?&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Kubernetes controllers are mostly applicable when it comes to managing simple apps. But when dealing with complex or stateful apps, they have limitations. These native controllers cannot automate application-specific operations and workflows, making it difficult to manage tasks like database provisioning, upgrades, and failover reliably.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Without Operators, manual database recovery can lead to hours of &lt;a href=&#34;https://middleware.io/blog/observability-in-action-reducing-downtime-with-middleware/&#34;&gt;downtime&lt;/a&gt;. Kubernetes Operators automate these tasks, and Middleware real-time alerts ensure you catch issues early.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Challenges without Operators&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Without Operators, you will face these challenges:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Manual database setup and recovery: You have to create and fix databases yourself, which takes time and can cause mistakes.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Hard upgrades: Updating apps will require many steps and careful timing to avoid breaking things.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;No app-specific knowledge: Built-in controllers are unaware of your app’s unique rules, so they can’t fully automate it.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Explore common &lt;/em&gt;&lt;a href=&#34;https://middleware.io/blog/kubernetes-challenges-and-solutions/&#34;&gt;&lt;em&gt;Kubernetes challenges and solutions&lt;/em&gt;&lt;/a&gt;&lt;em&gt; that teams face without automation.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Kubernetes Operators benefits&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;These are some of the benefits of using Operators:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Automating app lifecycle: Operators automate critical operations, such as installation, backup, upgrade, and failover, tailored to the application’s specific needs.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Enforcing consistency at scale: Operators ensure that the desired state is consistently maintained across multiple instances or clusters, simplifying large-scale management.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Reducing human error: Operators minimize manual interventions and reduce human error by applying expert operational knowledge.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Automate app lifecycle: Operators can reduce failover downtime by recovering stateful apps automatically. This will improve availability and reliability.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Operators automate management, but visibility is key. Discover the top &lt;/em&gt;&lt;a href=&#34;https://middleware.io/blog/kubernetes-monitoring/tools/&#34;&gt;&lt;em&gt;Kubernetes monitoring tools&lt;/em&gt;&lt;/a&gt;&lt;em&gt; that help you track app performance, spot issues early, and maintain cluster stability effortlessly.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Conclusion&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Operators are a powerful addition to Kubernetes because they make it easier to handle stateful and complex tasks, which seem to be difficult for built-in controllers. While Operators make work easier inside Kubernetes, teams still need a way to monitor and make sure their app is working as expected.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Observability through metrics, logs, and traces becomes the bridge between automation and assurance. By integrating robust monitoring and alerting with your Operators, teams can quickly detect anomalies, validate desired states, and ensure that self-healing mechanisms are actually working as intended. In the end, Operators simplify the &lt;em&gt;how&lt;/em&gt; of running applications, but observability provides confidence in the &lt;em&gt;why&lt;/em&gt; and &lt;em&gt;when,&lt;/em&gt; turning Kubernetes into a truly resilient platform.&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;p&gt;&lt;em&gt;最初在 &lt;/em&gt;&lt;a href=&#34;https://middleware.io/&#34;&gt;&lt;strong&gt;&lt;em&gt;中间件&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt; &lt;/em&gt;&lt;/strong&gt;&lt;em&gt;博客上发布的成员帖子&lt;/em&gt;&lt;a href=&#34;https://middleware.io/blog/authors/keval/&#34;&gt;&lt;strong&gt;&lt;em&gt;Keval Bhogayata&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;，涵盖&lt;a href=&#34;https://middleware.io/blog/authors/keval/&#34;&gt;&lt;strong&gt;&lt;em&gt;自动化有状态应用 Kubernetes 操作员。&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果您在 Kubernetes 中扩展数据库或自动升级方面遇到过问题，Operators 可以帮助您节省时间和精力。处理复杂的 Kubernetes 应用程序（例如数据库、消息队列和分布式系统）可能非常困难。 Kubernetes 可以很好地处理简单的工作负载，而大型应用程序则受到故障转移、扩展、备份和自动更新的困扰。这些活动通常需要运营专业知识。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果您不熟悉容器编排，您可能需要首先了解 &lt;a href=&#34;https://middleware.io/blog/kubernetes-vs-docker/&#34;&gt;Kubernetes 与 Docker&lt;/a&gt;&lt;/p&gt; 之间的区别&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这就是您需要 Kubernetes Operator 的地方，我们将在本文中介绍。您将了解这些 Operator 是什么、它们如何工作以及为什么需要它们。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;让我们开始吧。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;什么是 Kubernetes Operator？&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;运算符是额外的工具，可帮助您管理 Kubernetes 中的复杂或有状态应用程序。它是控制器和自定义资源定义 (CRD) 的组合。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;控制器是部署、设置、扩展、修复和更新资源的规则。 CRD 允许您向 Kubernetes 添加新的对象类型。 CRD 还允许您描述要管理的对象类型，然后您可以继续创建自定义资源 (CR)，它是您创建的对象类型的实例。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“637”高度=“450” src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.16.40-PM.jpg&#34; alt=&#34;Kubernetes 操作架构&#34; class=&#34;wp-image-149577&#34; srcset =“https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.16.40-PM.jpg 637w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.16.40-PM-300x212.jpg 300w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.16.40-PM-283x200.jpg 283w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.16.40-PM-566x400.jpg 566w“尺寸=”自动，（最大宽度：637px）100vw，637px“ referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Operator 的主要目的是简化复杂 Kubernetes 应用程序的管理，使升级、故障转移管理、备份和可扩展性等任务能够自动执行。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;传统 Kubernetes Controller 和 Operator 的区别&lt;/h3&gt;&lt;p&gt;以下是 Kubernetes 控制器和操作员之间差异的详细说明：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“644”高度=“424” src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.17.57-PM.jpg&#34; alt=&#34;Kubernetes Controller 和 Operator 之间的差异细分&#34; class=&#34;wp-image-149578&#34; srcset =“https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.17.57-PM.jpg 644w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.17.57-PM-300x198.jpg 300w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.17.57-PM-304x200.jpg 304w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.17.57-PM-608x400.jpg 608w“尺寸=”自动，（最大宽度：644px）100vw，644px“ referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Kubernetes Operator 的工作原理&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;假设您已准备好应用程序、基本的 Kubernetes 设置和有效的部署。如果没有 Operator，您将必须手动安装和管理应用程序。但使用 Operators，您可以自动运行这些流程。其工作原理如下：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;1.设置自定义资源&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;自定义资源 (CR) 是您为控制应用程序的特定方面而创建的对象。您需要先声明 CRD，然后才能创建 CR。 CRD 告诉 Kubernetes 您正在创建的新对象类型。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;以下是定义名为“MyAPP”的 CR 的 CRD 示例：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“329”高度=“530” src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.19.23-PM.jpg&#34; alt=&#34;定义名为“MyAPP”的 CR 的 CRD 示例&#34; class=&#34;wp-image-149579&#34; srcset =“https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.19.23-PM.jpg 329w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.19.23-PM-186x300.jpg 186w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.19.23-PM-124x200.jpg 124w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.19.23-PM-248x400.jpg 248w“尺寸=”自动，（最大宽度：329px）100vw，329px“ referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此 CRD 定义了一个名为“MyApp”的自定义资源。它在规格下有两个主要字段：尺寸和版本。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;将 CRD 应用到集群后，您可以继续创建“MyApp”实例，它代表您的应用配置：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“272”高度=“160” src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.20.19-PM.jpg&#34; alt=&#34;“MyApp”实例的图像，代表您的应用程序配置&#34; class=&#34;wp-image-149580&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此 CR 声明您你想要 3 个运行版本 1.0.0 的 example-app 副本（MyApp 的一个实例）。然后，运营商将监视此资源并确保您的应用与您声明的内容相符。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;2.将Operator部署到Kubernetes集群&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;定义 CR 后，下一步是部署 Operator 本身。这将监控 CR 更改并确保集群状态与您的声明相符。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;您通常使用一组 Kubernetes 配置文件（YAML 文件）来通知集群将 Operator 作为 Pod 运行。这包括设置权限，以便操作员可以监视和管理资源。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;示例：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full is-resized”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“392”高度=“34” src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.21.16-PM.jpg&#34; alt=&#34;设置权限的示例，以便操作员可以监视和管理资源&#34; class=&#34;wp-image-149581&#34; 样式=“宽度：392px；高度：自动”srcset=“https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.21.16-PM.jpg 392w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.21.16-PM-300x26.jpg 300w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.21.16-PM-388x34.jpg 388w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.21.16-PM-380x34.jpg 380w“尺寸=”自动，（最大宽度：392px）100vw，392px“ referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;3.运营商持续监控 CR。&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;部署后，Operator 将持续监控其管理的 CR 的变化。这种监控可以使用 Kubernetes API 来完成。它监视这些 CR 的创建、更新或删除等事件。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;操作员会留意实时变化，以确保在发生情况时能够立即做出反应。使用 Kubernetes 客户端，您可以在 CR 上设置监视，如下所示：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“619”高度=“574” src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.22.30-PM.jpg&#34; alt=&#34;如何在 CR 上设置手表的示例&#34; class=&#34;wp-image-149582&#34; srcset =“https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.22.30-PM.jpg 619w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.22.30-PM-300x278.jpg 300w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.22.30-PM-216x200.jpg 216w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.22.30-PM-431x400.jpg 431w“尺寸=”自动，（最大宽度：619px）100vw，619px“ referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此代码监视指定命名空间中的“MyApp”CR。当您添加、更改或删除 CR 时，操作员将收到包含详细信息的事件。这使其能够快速反应并使应用程序的状态与指定的设置保持一致。&lt;/p&gt;&lt;h3 class=&#34;wp-block-heading&#34;&gt;4.协调循环：操作员比较期望状态与实际状态&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;协调循环是 Operators 背后的主要思想。它通过在失败时重新运行整个过程来确保应用程序的实际状态与您在自定义资源中定义的所需状态相匹配。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“648”高度=“568” src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.23.24-PM.jpg&#34; alt=&#34;协调循环&#34; class=&#34;wp-image-149583&#34; srcset =“https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.23.24-PM.jpg 648w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.23.24-PM-300x263.jpg 300w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.23.24-PM-228x200.jpg 228w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.23.24-PM-456x400.jpg 456w“尺寸=”自动，（最大宽度：648px）100vw，648px“ referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;它的工作原理如下：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;操作员读取您所需的 CR 状态。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;然后它会检查集群的实际状态。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;如果它们不匹配，它就会修复它。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;它不断重复这个过程。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这个协调逻辑可以由我们之前设置的监视事件触发。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“625”高度=“305” src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.24.08-PM.jpg&#34; alt=&#34;协调逻辑示例可以由我们之前设置的监视事件触发&#34; class=&#34;wp-image-149584&#34; srcset =“https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.24.08-PM.jpg 625w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.24.08-PM-300x146.jpg 300w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-14-at-1.24.08-PM-410x200.jpg 410w“尺寸=”自动，（最大宽度：625px）100vw，625px“ referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;协调功能保证您的应用程序按预期工作。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;5.错误处理&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;无论怎样，在与 Operator 合作时您仍然会遇到问题。当问题出现时，操作员不会停下来。他们不断尝试，直到得到正确的结果。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;例如，了解如何诊断和修复 &lt;a href=&#34;https://middleware.io/blog/exit-code-137-in-kubernetes-causes-diagnosis-fixes/&#34;&gt;Kubernetes 中的退出代码 137&lt;/a&gt;，这是 pod OOMKilled 时的常见错误。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这个想法是这样的：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;操作员试图使实际状态等于期望状态&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;如果失败，它会记录错误&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;调节循环在一段时间后再次运行&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;操作员会再次尝试，直到成功为止。&lt;/李&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Kubernetes Operator 的用例&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;操作员在处理复杂或有状态的应用程序时最有帮助。以下是一些运营商提供巨大价值的实际场景，以及中间件如何帮助团队获得更多可见性：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;处理有状态应用&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;有状态工作负载（例如数据库）可能难以管理，因为数据恢复至关重要。即使容器或 Pod 停止，操作员也可以帮助管理这些工作负载。它自动执行备份、恢复、扩展和升级。 Postgres 和 MySQL Operators 就是一个很好的例子。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Postgres Operator 允许您自动执行 PostgreSQL 集群的备份、故障转移和扩展。 Operator 将自动配置副本或从快照恢复，而不是 SRE 手动执行。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;消息系统&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;像 Kafka 这样的消息平台需要仔细调整和扩展，特别是在高流量负载下。 Strimzi Kafka Operator 通过配置代理、处理配置和管理用户来简化这一过程。这消除了 &lt;a href=&#34;https://middleware.io/blog/what-is-devops/&#34;&gt;DevOps&lt;/a&gt; 团队手动扩展和重新启动的压力。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;监控和记录堆栈&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;监控和日志记录工具（例如 Prometheus 或 ELK）必须始终可用且可扩展，才能有效收集数据。 Prometheus Operators 可自动执行升级、扩展和配置管理。这确保了监控管道在无需人工干预的情况下稳定。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;自动化基础设施&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;运营商不限于应用程序；他们还可以自动执行重复的基础设施任务，例如配置存储、配置网络策略或管理证书。这有助于确保一致性和安全性，同时降低与手动流程相关的错误风险。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;同样，中间件会显示这些不可见的任务，从而允许 SRE 审核更改、跟踪自动化工作流程，并在基础设施与预期状态不匹配时&lt;a href=&#34;https://docs.middleware.io/workflow/alerting/setup-alert&#34;&gt;设置警报&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;为什么我们需要 Operator？&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Kubernetes 控制器主要适用于管理简单的应用程序。但在处理复杂或有状态的应用程序时，它们有局限性。这些本机控制器无法自动执行特定于应用程序的操作和工作流程，从而难以可靠地管理数据库配置、升级和故障转移等任务。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果没有 Operator，手动数据库恢复可能会导致数小时的&lt;a href=&#34;https://middleware.io/blog/observability-in-action-reducing-downtime-with-middleware/&#34;&gt;停机&lt;/a&gt;。Kubernetes Operator 可以自动执行这些任务，中间件实时警报可确保您及早发现问题。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;没有操作员的挑战&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果没有 Operator，您将面临以下挑战：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;手动数据库设置和恢复：您必须自己创建和修复数据库，这需要时间并且可能会导致错误。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;硬升级：更新应用需要执行许多步骤并仔细安排时间，以避免造成破坏。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;没有特定于应用的知识：内置控制器不知道您的应用的独特规则，因此无法完全自动化。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;em&gt;探索团队在没有自动化的情况下面临的常见&lt;/em&gt;&lt;a href=&#34;https://middleware.io/blog/kubernetes-challenges-and-solutions/&#34;&gt;&lt;em&gt;Kubernetes 挑战和解决方案&lt;/em&gt;&lt;/a&gt;&lt;em&gt;。&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Kubernetes Operator 的优势&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;以下是使用 Operator 的一些好处：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;自动化应用生命周期：运营商可根据应用的特定需求自动执行关键操作，例如安装、备份、升级和故障转移。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;大规模实施一致性：运营商确保在多个实例或集群中一致维护所需的状态，从而简化大规模管理。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;减少人为错误：操作员通过运用专业操作知识，最大限度地减少人工干预并减少人为错误。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;自动化应用生命周期：运营商可以通过自动恢复有状态应用来减少故障转移停机时间。这将提高可用性和可靠性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;em&gt;运营商实现管理自动化，但可见性是关键。探索顶级 &lt;/em&gt;&lt;a href=&#34;https://middleware.io/blog/kubernetes-monitoring/tools/&#34;&gt;&lt;em&gt;Kubernetes 监控工具&lt;/em&gt;&lt;/a&gt;&lt;em&gt;帮助您轻松跟踪应用性能、及早发现问题并维护集群稳定性。&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;结论&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;操作符是 Kubernetes 的强大补充，因为它们使处理有状态和复杂的任务变得更容易，而这对于内置控制器来说似乎很困难。虽然 Operator 使 Kubernetes 内的工作变得更加轻松，但团队仍然需要一种方法来监控并确保他们的应用程序按预期运行。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;通过指标、日志和跟踪的可观察性成为自动化和保证之间的桥梁。通过将强大的监控和警报与操作员集成，团队可以快速检测异常，验证所需状态，并确保自我修复机制实际上按预期工作。最后，Operator 简化了运行应用程序的&lt;em&gt;方式&lt;/em&gt;，但可观察性提供了&lt;em&gt;为什么&lt;/em&gt;和&lt;em&gt;何时&lt;/em&gt;的信心，将 Kubernetes 变成一个真正有弹性的平台。&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div样式=”高度：80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Tue, 14 Oct 2025 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【The tools for overcoming the top 10 DevOps challenges】克服十大 DevOps 挑战的工具</title>
      <link>https://www.cncf.io/blog/2025/10/14/the-tools-for-overcoming-the-top-10-devops-challenges/</link>
      <description>【&lt;p&gt;DevOps is a way of working that reduces waste. It uses smart tools and practices to build, test, and ship software faster. It makes teams quicker, systems stronger and problems smaller when done right. It’s not just one thing – it’s about making the whole machine run better. But this means that DevOps is not just a toolset or process. It’s a way of thinking and a culture born from the need to fix something broken: the wall between developers and operations.&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Companies understand the value DevOps brings to projects – which explains why its market value is growing so fast. In 2020, it was worth about &lt;strong&gt;$4.3 billion&lt;/strong&gt;. A year later, its value rose to &lt;strong&gt;$5.1 billion&lt;/strong&gt;.&lt;a href=&#34;https://www.strongdm.com/blog/devops-statistics#:~:text=DevOps%20Growth%20Statistics,USD%2012%2C215.54%20million%20by%202026.%22%20HYPERLINK%20%22https://www.strongdm.com/blog/devops-statistics#:~:text=DevOps%20Growth%20Statistics,USD%2012%2C215.54%20million%20by%202026.&#34;&gt; If the pace holds, it will hit &lt;strong&gt;$12.2 billion by 2026&lt;/strong&gt;&lt;/a&gt;. That’s almost tripled in six years. Teams understand what DevOps brings to projects .&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;But DevOps lives and dies on communication. Without it, even the best tools fail. With it, teams can spot issues sooner, fix them faster and deliver software that works. Read on to learn how communication drives DevOps and helps teams overcome challenges.&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;The DevOps infinity loop&amp;nbsp;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;DevOps is not a straight line. It moves in a loop – constant, connected, never done. The stages are simple: &lt;strong&gt;Plan. Develop. Test. Release. Deploy. Operate. Monitor. Feedback.&lt;/strong&gt; Then it begins again. Each stage feeds the next, and every one depends on the last. Like gears in a watch, the whole thing stutters if one slips.&amp;nbsp;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This loop is not just about speed. It’s about rhythm, about teams working as one. If they stop talking – if planning doesn’t match the build, if operations don’t hear from developers – things break. Bugs hide. Releases fail. Customers leave. The loop is only strong when people speak up, listen and fix what needs fixing. Tools help, but communication keeps it turning.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;There are a number of CNCF tools for enhancing the loop:&lt;/strong&gt; &lt;strong&gt;Kubernetes (Graduated)&lt;/strong&gt; for orchestration, &lt;strong&gt;Argo and Flux (Incubating/Graduated)&lt;/strong&gt; for GitOps-driven CI/CD, &lt;strong&gt;Prometheus (Graduated)&lt;/strong&gt; and &lt;strong&gt;OpenTelemetry (Incubating)&lt;/strong&gt; for monitoring and observability, &lt;strong&gt;Jaeger (Graduated)&lt;/strong&gt; for tracing, and &lt;strong&gt;Linkerd (Graduated)&lt;/strong&gt; for secure service mesh communication.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Top challenges in DevOps&amp;nbsp;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Even the best tools can’t fix a broken culture. DevOps is built on people, not just pipelines. It needs teams to move together. But too often, things fall apart. Here are the most common ways the work gets stuck:&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Environment inconsistencies&amp;nbsp;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;When the development, test and production environments don’t match, nothing behaves as expected. Bugs appear in one place but not the other, and time is wasted chasing ghosts. The problem isn’t always the code – it’s where the code runs. &lt;strong&gt;Use CNCF tools like Kubernetes and Helm (Graduated) to standardize environments.&lt;/strong&gt;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Team silos &amp;amp; skill gaps&amp;nbsp;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Developers and operations folks often speak different languages. One moves fast; the other keeps things steady. Without shared knowledge or cross-training, they pull in opposite directions, slowing progress and building tension. &lt;strong&gt;Adopting GitOps with Argo or Flux aligns both teams to a shared workflow.&lt;/strong&gt;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Outdated practices&amp;nbsp;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Some teams still use old methods – manual processes, long release cycles and slow approvals. This is like trying to win a race in a rusted car. It stalls innovation and keeps teams from moving at DevOps speed. &lt;strong&gt;CNCF CI/CD tools like Argo Workflows can help modernize releases.&lt;/strong&gt;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Monitoring blind spots&amp;nbsp;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;If you don’t see the problem, you can’t fix it. Teams without proper monitoring react too late – or not at all. Downtime drags on, and customers feel it before the team does. &lt;strong&gt;Prometheus, Grafana, OpenTelemetry and Jaeger provide full-stack observability.&lt;/strong&gt;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;CI/CD performance bottlenecks&amp;nbsp;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Builds fail, tests drag on, deployments choke on pipeline bugs and poorly tuned CI/CD setups turn fast releases into gridlock. The system slows, and so does the team. &lt;strong&gt;Use Argo CD or Flux for cloud-native pipelines that scale.&lt;/strong&gt;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Automation compatibility issues&amp;nbsp;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Not all tools play nice – one version conflicts with another, updates crash the system and automation breaks the flow instead of saving time. &lt;strong&gt;Crossplane (Incubating) enables consistent multi-cloud automation through Kubernetes-native infrastructure management.&amp;nbsp;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Security vulnerabilities&amp;nbsp;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;When security is an afterthought, cracks appear. One breach can undo everything. It’s not just a tech risk – it’s a trust risk. &lt;strong&gt;Falco (Incubating) provides runtime threat detection, and cert-manager (Graduated) automates certificate management.&lt;/strong&gt;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Test infrastructure scalability&amp;nbsp;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;As users grow, tests must grow, too. But many teams hit the ceiling. The test setup can’t keep up and bugs sneak through the cracks. &lt;strong&gt;Running tests on Kubernetes and leveraging KubeVirt (Incubating) for VM-based workloads scales test environments.&lt;/strong&gt;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Unclear debugging reports&amp;nbsp;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Long log. Cryptic errors. No one knows what broke or why. When reports confuse more than they clarify, bugs linger – and tempers rise. &lt;strong&gt;Jaeger and OpenTelemetry improve debugging and trace visibility.&lt;/strong&gt;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Decision-making bottlenecks&amp;nbsp;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;There is no clear owner, no fast, no, or yes, and teams stall waiting for permission. Work halts and releases lag. In the end, nobody is really in charge. &lt;strong&gt;Prometheus and Grafana dashboards provide clear metrics for faster decisions.&lt;/strong&gt;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;How to overcome DevOps challenges (and why communication is key)&amp;nbsp;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;No magic tool fixes DevOps. But there is something that works: people talking to each other. Clear goals. Fewer silos. Shared work. Here’s a checklist of what helps and why it matters.&amp;nbsp;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Create a shared language and shared goals&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Teams can’t build the same thing if they don’t speak the same language. Use common metrics – &lt;strong&gt;MTTR&lt;/strong&gt;, &lt;strong&gt;lead time&lt;/strong&gt;, &lt;strong&gt;error rate – &lt;/strong&gt;to anchor the work. These numbers keep everyone honest. Those goals clash when one team pushes features and the other patches fire. Don’t let teams optimize in isolation. Make them share the finish line.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Build cross-functional pods&amp;nbsp;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Teams work better when they sit together and solve problems side by side. Form &lt;strong&gt;pods&lt;/strong&gt;—stable groups of developers, ops, QA and product team members. It’s hard to stay siloed when you share a stand-up. Proximity builds trust. And trust moves code.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Foster psychological safety&amp;nbsp;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;People make mistakes. That’s how systems improve. But if people are afraid to speak up, problems stay buried. When teams feel safe raising concerns or admitting failure, they recover faster and learn more. Real incident reports don’t hide blame. They show the truth, so the next time is better.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Standardize environments&amp;nbsp;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;“It worked on my machine” means nothing if it breaks down in production. Use &lt;strong&gt;infrastructure-as-code&lt;/strong&gt; and cloud tooling to keep dev, test and prod consistent. When the environment is the same everywhere, surprises are fewer. &lt;strong&gt;Kubernetes and Helm (Graduated) simplify this.&lt;/strong&gt;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Tune CI/CD and testing for performance&amp;nbsp;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;A slow pipeline drags everyone down. Speed it up with tools that test on &lt;strong&gt;real devices&lt;/strong&gt;, measure &lt;strong&gt;browser performance&lt;/strong&gt; and automate the most critical paths. This isn’t about testing more – it’s about testing smart. &lt;strong&gt;Argo CD and Flux improve performance.&lt;/strong&gt;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Ensure continuous monitoring &amp;amp; security&amp;nbsp;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;You can’t fix what you don’t see. Use tools like &lt;strong&gt;Nagios&lt;/strong&gt; or &lt;strong&gt;Prometheus&lt;/strong&gt; to monitor the system. Bake security into every step – use scanners, audits and static code analysis. Security is not the last step – it’s every step. &lt;strong&gt;Falco and cert-manager ensure security at runtime and in transport.&lt;/strong&gt;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Improve report readability&amp;nbsp;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Long logs and cluttered dashboards don’t help. Use &lt;strong&gt;clear charts&lt;/strong&gt;, &lt;strong&gt;visual dashboards&lt;/strong&gt; and tools like &lt;strong&gt;BrowserStack Test Insights&lt;/strong&gt; to make results obvious – even to non-tech teams. When everyone can read the data, everyone can act. &lt;strong&gt;Jaeger and Grafana dashboards help here too.&lt;/strong&gt;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;What a successful DevOps culture looks like&amp;nbsp;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Want to see DevOps done right? Look at Netflix. They had a simple problem: scale fast, don’t break. So, they changed how their teams worked. No more silos. They built cross-functional squads – developers, ops, QA all in one crew. They didn’t just work near each other. They worked together.&amp;nbsp;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;They talked every day. They ran retrospectives. When something broke, they didn’t hide it – they wrote it down, studied it and ensured it didn’t happen again. They used tools like Slack to talk, Jira to track and GitHub to ship. These tools matter. But the fundamental shift came from trust, feedback and shared purpose.&amp;nbsp;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Netflix didn’t win by building the perfect pipeline. They won by creating a culture where communication was constant and feedback wasn’t feared. The result? Fewer failures, faster deployments, better uptime – and a team that knew what winning looked like.&amp;nbsp;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;DevOps doesn’t succeed because of tools. It succeeds because people talk, listen and own the work.&amp;nbsp;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;That’s what an authentic DevOps culture looks like.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;The bottom line: talk is DevOps’ greatest strength&amp;nbsp;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;DevOps isn’t just built-in code. It’s a built-in routine. The best teams don’t wait for problems – they meet daily to talk. They look back after every sprint. They write down what broke, why and how to ensure it won’t break again.&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;DevOps lives and dies by how well teams talk to each other – not just when something breaks. The best teams don’t just move fast – they move together. They share the same goal, speak the same language and fix things before they fall apart. Pipelines help. Tools help. But when DevOps fails, it fails at the level of &lt;strong&gt;alignment&lt;/strong&gt;, not automation.&amp;nbsp;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;So, ask yourself:&amp;nbsp;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Are we talking enough?&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Are we listening well?&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Do we share the exact definition of success?&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;If you’re not sure, that’s where the work begins. Communication isn’t just nice-to-have – it’s essential. Building an effective DevOps culture takes continuous alignment between people, processes, and platforms. By focusing on communication, collaboration, and shared accountability, teams can ensure their DevOps practices not only function, but thrive.&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;p&gt;DevOps 是一种减少浪费的工作方式。它使用智能工具和实践来更快地构建、测试和交付软件。如果做得正确，它可以使团队更快、系统更强大、问题更小。这不仅仅是一件事——而是让整个机器运行得更好。但这意味着 DevOps 不仅仅是一个工具集或流程。这是一种思维方式和文化，源于修复损坏的东西的需要：开发人员和运营人员之间的墙。   &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;公司了解 DevOps 为项目带来的价值 - 这解释了为什么其市场价值增长如此之快。 2020 年，其价值约为&lt;strong&gt;43 亿美元&lt;/strong&gt;。一年后，其价值升至&lt;strong&gt;51 亿美元&lt;/strong&gt;。&lt;a href=&#34;https://www.strongdm.com/blog/devops-statistics#:~:text=DevOps%20Growth%20Statistics,USD%2012%2C215.54%20million%20by%202026.%22%20HY PERLINK%20%22https://www.strongdm.com/blog/devops-statistics#:~:text=DevOps%20Growth%20Statistics,USD%2012%2C215.54%20million%20by%202026。&#34;&gt; 如果保持这一速度，到 2026 年，这一数字将达到 122 亿美元&lt;/strong&gt;&lt;/a&gt;。六年内几乎增加了两倍。团队了解 DevOps 给项目带来了什么。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;但是 DevOps 的生死存亡取决于沟通。没有它，即使是最好的工具也会失败。有了它，团队可以更快地发现问题、更快地解决问题并交付有效的软件。继续阅读，了解沟通如何推动 DevOps 并帮助团队克服挑战。   &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;DevOps 无限循环&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;DevOps 不是一条直线。它循环移动——持续不断、相互连接、永无止境。这些阶段很简单：&lt;strong&gt;计划。发展。测试。发布。部署。操作。监视器。反馈。&lt;/strong&gt;然后又开始。每个阶段都为下一个阶段提供支持，每个阶段都依赖于最后一个阶段。就像手表中的齿轮一样，如果有一个滑倒，整个装置就会卡顿。  &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这个循环不仅仅与速度有关。这关乎节奏，关乎团队团结一致。如果他们停止说话——如果规划与构建不匹配，如果运营部门没有收到开发人员的消息——事情就会崩溃。虫子隐藏起来。发布失败。顾客离开。只有当人们畅所欲言、倾听并解决需要解决的问题时，这种循环才会牢固。工具有帮助，但沟通可以推动事情的发展。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;有许多 CNCF 工具可用于增强循环：&lt;/strong&gt; 用于编排的 &lt;strong&gt;Kubernetes（已毕业）&lt;/strong&gt;、用于 GitOps 驱动的 CI/CD 的 &lt;strong&gt;Argo 和 Flux（孵化/已毕业）&lt;/strong&gt;、用于监控的 &lt;strong&gt;Prometheus（已毕业）&lt;/strong&gt; 和 &lt;strong&gt;OpenTelemetry（孵化）&lt;/strong&gt; 和可观察性，&lt;strong&gt;Jaeger（已毕业）&lt;/strong&gt; 用于跟踪，&lt;strong&gt;Linkerd（已毕业）&lt;/strong&gt; 用于安全服务网格通信。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;DevOps 中的主要挑战&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;即使是最好的工具也无法修复破碎的文化。 DevOps 是建立在人的基础上的，而不仅仅是管道。它需要团队一起行动。但太频繁了，事情崩溃了。以下是工作陷入困境的最常见原因：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;环境不一致&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;当开发、测试和生产环境不匹配时，一切都不会按预期运行。虫子出现在一个地方，但没有出现在另一个地方，而时间都浪费在追鬼上了。问题并不总是出在代码上——而是出在代码运行的地方。 &lt;strong&gt;使用 Kubernetes 和 Helm（已毕业）等 CNCF 工具来标准化环境。&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;团队孤岛和技能差距&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;开发人员和运营人员经常使用不同的语言。一个动作快；一个动作快。另一个使事情保持稳定。如果没有共享知识或交叉培训，他们就会朝相反的方向发展，从而减缓进展并加剧紧张。 &lt;strong&gt;将 GitOps 与 Argo 或 Flux 结合使用可以使两个团队保持共享工作流程。&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;过时的做法&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;一些团队仍然使用旧方法——手动流程、发布周期长且审批缓慢。这就像试图驾驶一辆生锈的汽车赢得比赛一样。它阻碍了创新并阻碍团队以 DevOps 的速度前进。 &lt;strong&gt;Argo Workflows 等 CNCF CI/CD 工具可以帮助实现版本现代化。&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;监控盲点&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果您看不到问题，则无法解决它。没有适当监控的团队反应太晚——或者根本不反应。停机时间很长，客户比团队更早感受到。 &lt;strong&gt;Prometheus、Grafana、OpenTelemetry 和 Jaeger 提供全栈可观察性。&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;CI/CD 性能瓶颈&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;构建失败、测试拖延、部署因管道错误而停滞，以及调整不当的 CI/CD 设置将快速发布变成僵局。系统变慢了，团队也变慢了。 &lt;strong&gt;使用 Argo CD 或 Flux 实现可扩展的云原生管道。&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;自动化兼容性问题&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;并非所有工具都能很好地发挥作用 - 一个版本与另一个版本冲突，更新使系统崩溃，自动化破坏了流程而不是节省时间。 &lt;strong&gt;Crossplane（孵化）通过 Kubernetes 原生基础设施管理实现一致的多云自动化。 &lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;安全漏洞&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;当安全问题被忽视时，就会出现裂缝。一次突破就可以毁掉一切。这不仅仅是技术风险，更是信任风险。 &lt;strong&gt;Falco（孵化）提供运行时威胁检测，cert-manager（已毕业）自动执行证书管理。&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;测试基础架构可扩展性&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;随着用户的增长，测试也必须增长。但很多球队都遇到了天花板。测试设置无法跟上，错误会从裂缝中溜走。 &lt;strong&gt;在 Kubernetes 上运行测试并利用 KubeVirt（孵化）进行基于虚拟机的工作负载可扩展测试环境。&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;不清楚的调试报告&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;长日志。隐秘的错误。没有人知道是什么原因造成的。当报告令人困惑的程度多于澄清的程度时，错误就会挥之不去，脾气就会上升。 &lt;strong&gt;Jaeger 和 OpenTelemetry 改进了调试和跟踪可见性。&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;决策瓶颈&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;没有明确的所有者，没有快速、否或是，团队拖延等待许可。工作停止，发布滞后。最终，没有人真正负责。 &lt;strong&gt;Prometheus 和 Grafana 仪表板提供了清晰的指标，有助于更快地做出决策。&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;如何克服 DevOps 挑战（以及为何沟通至关重要）&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;没有什么神奇的工具可以修复 DevOps。但有一种东西是有效的：人们互相交谈。明确的目标。更少的孤岛。共同工作。以下是一份清单，列出了哪些内容有帮助以及为何重要。  &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;创建共同语言和共同目标&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果团队不使用相同的语言，他们就无法构建相同的东西。使用通用指标 - &lt;strong&gt;MTTR&lt;/strong&gt;、&lt;strong&gt;交付周期&lt;/strong&gt;、&lt;strong&gt;错误率&lt;/strong&gt;来锚定工作。这些数字让每个人都保持诚实。当一个团队推出功能而其他团队发布补丁时，这些目标就会发生冲突。不要让团队孤立地进行优化。让他们共享终点线。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;构建跨职能 Pod&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;当团队坐在一起并肩解决问题时，团队会工作得更好。形成&lt;strong&gt;pods&lt;/strong&gt;——由开发人员、运维人员、QA 和产品团队成员组成的稳定群体。当你分享脱口秀时，很难保持沉默。近距离建立信任。信任会移动代码。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;促进心理安全&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;人都会犯错误。这就是系统改进的方式。但如果人们不敢说出来，问题就会被埋没。当团队感到安全地提出疑虑或承认失败时，他们会更快恢复并了解更多信息。真实的事件报告不会掩盖责任。他们展示了真相，所以下次会更好。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;标准化环境&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果在生产中出现故障，“它可以在我的机器上运行”就毫无意义。使用&lt;strong&gt;基础设施即代码&lt;/strong&gt;和云工具来保持开发、测试和生产的一致性。当各地的环境都一样时，惊喜就会减少。 &lt;strong&gt;Kubernetes 和 Helm（已毕业）简化了这一过程。&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;调整 CI/CD 和测试以提高性能&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;缓慢的管道会拖累每个人。使用在&lt;strong&gt;真实设备&lt;/strong&gt;上进行测试、测量&lt;strong&gt;浏览器性能&lt;/strong&gt;以及自动化最关键路径的工具来加快速度。这不是要进行更多测试，而是要进行智能测试。 &lt;strong&gt;Argo CD 和 Flux 提高了性能。&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;确保持续监控和安全&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;你无法修复你看不到的东西。使用&lt;strong&gt;Nagios&lt;/strong&gt;或&lt;strong&gt;Prometheus&lt;/strong&gt;等工具来监控系统。将安全融入每一步——使用扫描仪、审计和静态代码分析。安全不是最后一步，而是每一步。 &lt;strong&gt;Falco 和 cert-manager 确保运行时和传输过程中的安全性。&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;提高报告可读性&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;长日志和混乱的仪表板没有帮助。使用&lt;strong&gt;清晰的图表&lt;/strong&gt;、&lt;strong&gt;可视化仪表板&lt;/strong&gt;和&lt;strong&gt;BrowserStack Test Insights&lt;/strong&gt;等工具使结果显而易见 - 即使对于非技术团队也是如此。当每个人都可以读取数据时，每个人都可以采取行动。 &lt;strong&gt;Jaeger 和 Grafana 仪表板在这方面也能提供帮助。&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;成功的 DevOps 文化是什么样的&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;想要看到 DevOps 正确完成吗？看看Netflix。他们有一个简单的问题：快速扩展，不要崩溃。因此，他们改变了团队的工作方式。不再有孤岛。他们建立了跨职能团队——开发人员、运营人员、质量检查人员都在一个团队中。他们不仅仅是在附近工作。他们一起工作。  &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;他们每天都会说话。他们进行了回顾。当出现问题时，他们不会隐藏它 - 他们把它写下来，研究它并确保它不会再次发生。他们使用 Slack 等工具进行交谈，使用 Jira 进行跟踪，使用 GitHub 进行发布。这些工具很重要。但根本性的转变来自信任、反馈和共同目标。  &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Netflix 并不是通过建立完美的管道而获胜的。他们通过创造一种持续沟通且不畏惧反馈的文化而获胜。结果呢？更少的故障、更快的部署、更好的正常运行时间 - 以及一支知道胜利是什么样子的团队。  &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;DevOps 的成功并不是因为工具。它之所以成功，是因为人们谈论、倾听并拥有自己的作品。  &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这就是真正的 DevOps 文化。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;底线：讨论是 DevOps 的最大优势&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;DevOps 不仅仅是内置代码。这是一个内置的例程。最好的团队不会等到问题出现，他们每天都会开会讨论。他们在每次冲刺后都会回顾。他们写下损坏的原因、原因以及如何确保它不会再次损坏。   &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;DevOps 的生死取决于团队之间的沟通程度，而不仅仅是出现问题时。最好的团队不仅行动迅速，而且还一起行动。他们有着相同的目标，说着相同的语言，并在事情崩溃之前解决问题。管道有帮助。工具有帮助。但是，当 DevOps 失败时，它会在&lt;strong&gt;对齐&lt;/strong&gt;层面失败，而不是在自动化层面失败。  &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;所以，问问自己：  &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;我们说得够多了吗？&lt;/strong&gt;  &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;斯特罗ng&gt;我们听得好吗？&lt;/strong&gt;  &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;我们对成功的确切定义认同吗？&lt;/strong&gt;  &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果您不确定，那就从这里开始工作。沟通不仅是可有可无的，而且是必不可少的。构建有效的 DevOps 文化需要人员、流程和平台之间的持续协调。通过关注沟通、协作和共同责任，团队可以确保他们的 DevOps 实践不仅发挥作用，而且蓬勃发展。&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Mon, 13 Oct 2025 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【KubeCon + CloudNativeCon North America 2025 Co-Located Event Deep Dive: Cloud Native + Kubernetes AI Day】KubeCon + CloudNativeCon 北美 2025 同期活动深度探讨：云原生 + Kubernetes AI Day</title>
      <link>https://www.cncf.io/blog/2025/10/13/kubecon-cloudnativecon-north-america-2025-co-located-event-deep-dive-cloud-native-kubernetes-ai-day/</link>
      <description>【&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1600&#34; height=&#34;356&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2-1.jpg&#34; alt=&#34;Graphic for K8s + AI Day at KubeCon NA 2025&#34; class=&#34;wp-image-149003&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2-1.jpg 1600w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-1-300x67.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-1-1024x228.jpg 1024w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-1-768x171.jpg 768w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-1-900x200.jpg 900w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-1-600x134.jpg 600w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-1-1200x267.jpg 1200w&#34; sizes=&#34;auto, (max-width: 1600px) 100vw, 1600px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Cloud Native &amp;amp; Kubernetes AI Day is welcoming the AI/ML and High Performance Computing (HPC) communities. Since 2022 there have been multiple dedicated events (Batch / HPC and Cloud Native AI days) but given the overlap in requirements, projects and end user interests it became clear we all fit better together.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Cloud Native &amp;amp; Kubernetes AI Day brings together a diverse range of technical enthusiasts, open source contributors, practitioners, researchers and end users. All united in a common goal: enhancing Kubernetes as the ultimate infrastructure management tool for research and AI/ML workloads.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Who will get the most out of attending this event?&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The Cloud Native &amp;amp; Kubernetes AI Day is aimed at seasoned practitioners as well as those new to the batch computing and MLOps worlds. Anyone looking for solutions and best practices to provide cost effective and efficient infrastructure to scale out batch computing, training and inference workloads, make the best use of scarce and expensive hardware accelerators and efficiently manage LLMs and agentic infrastructure. This event will also help practitioners of MLOps interact with maintainers of Cloud Native AI projects and foster collaboration between the two worlds.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;What is new and different this year?&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The theme this year is ‘agent,’ with multiple references and reports on Agentic AI and the cloud native infrastructure supporting it. This event will be a unique opportunity to connect and network with people driving this new generation infrastructure.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;What will the day look like?&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;We will have a full day with 10 full sessions and 4 lightning talks and enough time for questions during the sessions and discussion in the break outs. We will be hearing from researchers, project maintainers and many end users reporting on successes and challenges of running AI/ML workloads on top of cloud native infrastructure. While the sessions will be engaging, there will be ample time during coffee breaks and lunch for hallway tracks and networking sessions, helping attendees engage with speakers, maintainers of projects and end users.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Should I do any homework first?&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;No formal prep is required, but consider going through the schedule in advance so you can prepare to ask or raise particular topics of interest to you or your organization. This is a unique opportunity to meet and learn from some of the industry’s best practitioners and a good chance to also raise your particular requirements and help set the path for our community.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;A special note from the program chairs&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;New tools supporting Agentic AI infrastructure:&lt;/strong&gt; The last few months have been unique in the number and quality of tools supporting LLMs and Agentic AI infrastructure. This will be a great opportunity to hear more details about the current status and where the community is heading.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Real-world use cases and success stories:&lt;/strong&gt; In the fast-moving area of AI/ML, listening to end user stories (both challenges and successes) is extremely important to understand what works and for which use cases.&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;figure class =“wp-block-image size-full”&gt; &lt;img loading =“lazy”decoding =“async”width =“1600”height =“356”src =“https://www.cncf.io/wp-content/uploads/2025/10/image-2-1.jpg”alt =“K8s + AI日图形” KubeCon NA 2025&#34; class=&#34;wp-image-149003&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2-1.jpg 1600w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-1-300x67.jpg 300w，https://www.cncf.io/wp-content/uploads/2025/10/image-2-1-1024x228.jpg 1024w， https://www.cncf.io/wp-content/uploads/2025/10/image-2-1-768x171.jpg 768w，https://www.cncf.io/wp-content/uploads/2025/10/image-2-1-900x200.jpg 900w， https://www.cncf.io/wp-content/uploads/2025/10/image-2-1-600x134.jpg 600w，https://www.cncf.io/wp-content/uploads/2025/10/image-2-1-1200x267.jpg 1200w“尺寸=”自动， （最大宽度：1600px）100vw，1600px“referrerpolicy =“no-referrer”&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;云原生和 Kubernetes AI Day 欢迎 AI/ML 和高性能计算 (HPC) 社区。自 2022 年以来，已经举办了多个专门活动（批处理/HPC 和云原生 AI 日），但考虑到需求、项目和最终用户兴趣的重叠，很明显我们都更适合在一起。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;云原生和 Kubernetes AI Day 汇聚了各类技术爱好者、开源贡献者、从业者、研究人员和最终用户。大家团结在一个共同的目标：增强 Kubernetes 作为研究和 AI/ML 工作负载的终极基础设施管理工具。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;谁将从参加本次活动中获益最多？&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;云原生和 Kubernetes AI 日面向经验丰富的从业者以及批处理计算和 MLOps 领域的新手。任何寻求解决方案和最佳实践来提供具有成本效益和高效基础设施的人，以扩展批量计算、训练和推理工作负载，充分利用稀缺且昂贵的硬件加速器，并有效管理法学硕士和代理基础设施。此次活动还将帮助 MLOps 的从业者与云原生 AI 项目的维护者进行互动，并促进两个世界之间的合作。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;今年有什么新的和不同的？&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;今年的主题是“代理”，有关于 Agentic AI 和支持它的云原生基础设施的多个参考和报告。此次活动将是与推动新一代基础设施的人们建立联系和建立联系的独特机会。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;这一天会是什么样子？&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我们将有一整天的时间，包括 10 场完整会议和 4 场闪电演讲，并有足够的时间在会议期间提问和在分组讨论中进行讨论。我们将听到研究人员、项目维护人员和许多最终用户报告在云原生基础设施上运行 AI/ML 工作负载的成功和挑战。虽然会议会很吸引人，但茶歇和学习期间会有充足的时间unch 用于走廊轨道和网络会议，帮助与会者与演讲者、项目维护者和最终用户互动。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;我应该先做作业吗？&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;不需要正式准备，但请考虑提前查看时间表，以便您可以准备询问或提出您或您的组织感兴趣的特定主题。这是一个与业界最优秀的从业者见面并向他们学习的独特机会，也是提出您的特殊要求并帮助为我们的社区设定道路的好机会。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;程序主席的特别说明&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;支持 Agentic AI 基础设施的新工具：&lt;/strong&gt;过去几个月，支持 LLM 和 Agentic AI 基础设施的工具的数量和质量都是独一无二的。这将是了解有关当前状态和社区发展方向的更多详细信息的绝佳机会。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;现实世界的用例和成功案例：&lt;/strong&gt;在快速发展的 AI/ML 领域，聆听最终用户的故事（挑战和成功）对于了解哪些方法有效以及哪些用例适用非常重要。&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Sun, 12 Oct 2025 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【KubeCon + CloudNativeCon North America 2025 Co-Located Event Deep Dive: Data on Kubernetes Day】KubeCon + CloudNativeCon 北美 2025 同期活动深度探究：Kubernetes Day 数据</title>
      <link>https://www.cncf.io/blog/2025/10/10/kubecon-cloudnativecon-north-america-2025-co-located-event-deep-dive-data-on-kubernetes-day/</link>
      <description>【&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1734&#34; height=&#34;322&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-1.jpg&#34; alt=&#34;DoKC co-located event graphic for KC+CNC NA 2025&#34; class=&#34;wp-image-148687&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-1.jpg 1734w, https://www.cncf.io/wp-content/uploads/2025/10/image-1-300x56.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/image-1-1024x190.jpg 1024w, https://www.cncf.io/wp-content/uploads/2025/10/image-1-768x143.jpg 768w, https://www.cncf.io/wp-content/uploads/2025/10/image-1-900x167.jpg 900w, https://www.cncf.io/wp-content/uploads/2025/10/image-1-600x111.jpg 600w, https://www.cncf.io/wp-content/uploads/2025/10/image-1-1200x223.jpg 1200w&#34; sizes=&#34;auto, (max-width: 1734px) 100vw, 1734px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Data on Kubernetes Day (DoK Day) began as a virtual event in 2021 and became an official co-located event for KubeCon + Cloud Native Con in 2023. Since then, it has been a staple at both the European and North American events, so we’re excited to bring it back for our community in Atlanta.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Running stateful workloads like databases, streaming, AI/ML, and analytics on Kubernetes is no longer a fringe practice—it’s becoming the standard for modern infrastructure. Organizations like Etsy, Grab, and Chick-fil-A have demonstrated what’s possible. Our goal for DoK Day is to provide you with the real-world resources, best practices, and use cases you need to confidently run data workloads on Kubernetes and accelerate your journey.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;What is new and different this year?&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This year, we have seen a significant increase in content submissions focusing on AI and LLMs, reflecting the industry trend of Kubernetes becoming the foundation for AI infrastructure. Our schedule will feature several new talks on this topic, from leveraging GPUs to managing AI data pipelines on Kubernetes. We are also proud to have our most diverse group of speakers and submissions to date, representing a wide range of backgrounds and experiences from the community.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;What will the day look like?&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;DoK Day is for practitioners and decision-makers who are pushing Kubernetes beyond stateless applications. Platform engineers, SREs, data engineers, architects, and CTOs who want to understand how to run stateful workloads at scale will find immense value. Whether you’re just starting to explore running DoK or are already operating mission-critical workloads in production, you’ll walk away with practical knowledge and a stronger network of peers facing similar challenges.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Should I do any homework first?&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;No formal prep is required, but we recommend attendees familiarize themselves with the Data on Kubernetes Community (DoKC) resources—such as our white papers, recorded talks, and Slack discussions. If you already run workloads on Kubernetes, bring your questions and challenges; if you’re new, come ready to absorb and connect. The more you engage with the community beforehand, the more you’ll get out of the event.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Find your community!&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The Data on Kubernetes Community is an open and inclusive community. Whether you’re a seasoned expert or just starting, we welcome you to join our Slack channel, attend our monthly virtual meetups, and contribute to our projects. This event is a celebration of the community’s hard work and a chance to connect face-to-face.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;A note from the program chairs&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;We’re most excited about the energy of bringing thousands of cloud native practitioners together under one roof. For us, the highlight is seeing how data has become central to Kubernetes conversations—whether through AI/ML use cases, next-gen databases, or streaming workloads. Beyond the talks, we’re looking forward to the serendipitous hallway chats, reconnecting with old friends in the community, and welcoming new faces into the DoK ecosystem.&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; Decoding=&#34;async&#34; width=&#34;1734&#34; height=&#34;322&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-1.jpg&#34; alt=&#34;DoKC 共置事件图形 KC+CNC NA 2025&#34; class=&#34;wp-image-148687&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-1.jpg 1734w, https://www.cncf.io/wp-content/uploads/2025/10/image-1-300x56.jpg 300w，https://www.cncf.io/wp-content/uploads/2025/10/image-1-1024x190.jpg 1024w， https://www.cncf.io/wp-content/uploads/2025/10/image-1-768x143.jpg 768w，https://www.cncf.io/wp-content/uploads/2025/10/image-1-900x167.jpg 900w， https://www.cncf.io/wp-content/uploads/2025/10/image-1-600x111.jpg 600w，https://www.cncf.io/wp-content/uploads/2025/10/image-1-1200x223.jpg 1200w“尺寸=”自动， （最大宽度：1734px）100vw，1734px“referrerpolicy =“no-referrer”&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Kubernetes Day (DoK Day) 数据于 2021 年开始作为虚拟活动，并于 2023 年成为 KubeCon + Cloud Native Con 的官方同地活动。从那时起，它一直是欧洲和北美活动的主要活动，因此我们很高兴能将其带回亚特兰大社区。&lt;/​​p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在 Kubernetes 上运行数据库、流媒体、AI/ML 和分析等有状态工作负载不再是一种边缘实践，它正在成为现代基础设施的标准。 Etsy、Grab 和 Chick-fil-A 等组织已经证明了一切皆有可能。我们 DoK Day 的目标是为您提供所需的实际资源、最佳实践和用例，以便您自信地在 Kubernetes 上运行数据工作负载并加速您的旅程。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;今年有什么新的和不同的？&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;今年，我们看到关注 AI 和 LLM 的内容提交大幅增加，反映了 Kubernetes 成为 AI 基础设施基础的行业趋势。我们的日程安排将包括有关该主题的几场新演讲，从利用 GPU 到管理 Kubernetes 上的 AI 数据管道。我们还很自豪拥有迄今为止最多元化的演讲者和意见书，代表了社区的广泛背景和经验。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;这一天会是什么样子？&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;DoK Day 是为推动 Kubernetes 超越无状态应用程序的从业者和决策者举办的。想要了解如何大规模运行有状态工作负载的平台工程师、SRE、数据工程师、架构师和 CTO 将会发现巨大的价值。无论您是刚刚开始探索运行 DoK 还是已经在生产中运行任务关键型工作负载，您都将获得实用知识和面临类似挑战的更强大的同行网络。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;我应该先做作业吗？&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;不需要正式准备，但我们建议与会者熟悉 Kubernetes Comm 上的数据unity (DoKC) 资源——例如我们的白皮书、演讲录音和 Slack 讨论。如果您已经在 Kubernetes 上运行工作负载，请提出您的问题和挑战；如果您是新人，请准备好吸收和联系。您事先与社区互动越多，您从活动中获得的收获就越多。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;找到您的社区！&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Kubernetes 数据社区是一个开放、包容的社区。无论您是经验丰富的专家还是新手，我们都欢迎您加入我们的 Slack 频道，参加我们每月的虚拟聚会，并为我们的项目做出贡献。这次活动是对社区辛勤工作的庆祝，也是一次面对面交流的机会。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;程序主席的说明&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我们对将数千名云原生从业者聚集在一个屋檐下所产生的能量感到非常兴奋。对我们来说，重点是了解数据如何成为 Kubernetes 对话的核心——无论是通过 AI/ML 用例、下一代数据库还是流工作负载。除了会谈之外，我们还期待着偶然的走廊聊天、与社区中的老朋友重新联系，并欢迎新面孔加入 DoK 生态系统。&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Thu, 09 Oct 2025 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【A blueprint for zero-trust AI on Kubernetes】Kubernetes 上的零信任人工智能蓝图</title>
      <link>https://www.cncf.io/blog/2025/10/10/a-blueprint-for-zero-trust-ai-on-kubernetes/</link>
      <description>【&lt;p&gt;LLMs and AI are everywhere these days. Everyone wants to build the next big thing, ship it fast, and maybe even cash out and chill for the rest of their lives. The problem? Most open source AI projects are shared &lt;em&gt;as is&lt;/em&gt;. They’re created with the best intentions, but their developers aren’t losing sleep over things like security guardrails or production hardening, that part is left for you to figure out.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;If that sounds like the boat you’re in, you’re in the right place. In this blog, we’ll look at how running AI on Kubernetes introduces some very real networking and security challenges, and what you can do about them before your experiment turns into a liability.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Because here’s the thing: AI systems are complicated, sometimes even the people building them admit they don’t fully know why a model makes the decision it does. But at the end of the day, it’s still just bits moving around computers and network cables, and securing those bits, whether they’re API keys, training data, or model endpoints, is easier than you might think if you know the right patterns.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Are these AI security challenges unique?&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Yes and no. On the one hand, the issues AI workloads face, unrestricted network traffic, exposed endpoints, leaked credentials, are the same classic security problems we’ve been wrestling with in IT for decades. On the other hand, they don’t just move data around, they handle sensitive training datasets, expensive inference workloads, and powerful APIs that can be abused in seconds. A stolen API key doesn’t just mean a small breach; it could mean thousands of dollars in cloud bills or a model that starts spilling the beans for the wrong confidant. A compromised pod doesn’t just leak logs; it could expose proprietary datasets you spent months fine-tuning, erasing your competitive edge overnight.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;So while the problems aren’t entirely new, the stakes are a lot higher. It’s like the difference between leaving your bike unlocked outside a café versus leaving a sports car running with the keys in the ignition. Both are risky, but one is going to attract trouble a lot faster. “Reverse the order if you are living in Amsterdam, or Vancouver its the bike right ;)”&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Securing an AI system can feel like taming a “complex beast.” While developers focus on model training and application logic, critical security considerations are often overlooked. This is partly because open source AI projects are typically presented “as is,” or because the pace of change in these frameworks are faster than the speed of light, and that is why we get frameworks with no or limited built-in security guardrails for production environments.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;When deployed in a default Kubernetes cluster, these AI workloads face significant risks:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Uncontrolled Network Traffic: By default, all pods in a Kubernetes cluster can communicate freely with each other. This creates an open environment where a single compromised component can lead to lateral movement and wider system breaches.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Sensitive Data Leakage: AI applications frequently handle sensitive API keys to connect with external services. Without proper handling, these keys can be “transferred between your users and platform” over unencrypted channels, vulnerable to eavesdropping.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Unsecured Network Exposure: Exposing AI endpoints to users or other services without robust ingress security leaves them open to unauthorized access and potential attacks.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;A blueprint for securing AI on Kubernetes&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Securing AI on Kubernetes does not require reinventing the wheel. Instead, it involves applying “well known security best practices” from the cloud-native ecosystem using a purpose-built toolset. Examples in this blog reference common CNI implementations (such as Calico or Cilium) that provide frameworks to address the unique security challenges of AI workloads.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Securing ingress to your endpoints (secure the front door)&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The first step in preventing API key eavesdropping is to lock down the entrypoint to your AI workloads. Many frameworks like Ollama, vLLM, or LiteLLM ship with a plain HTTP server out of the box, which means anyone in the path can snoop on your traffic if you’re not careful. When these frameworks run inside Kubernetes, securing their API endpoints with certificates is your first line of defense.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;br&gt;The good news? Kubernetes makes this easy. Using the `Gateway API` standard, you can create a gateway, attach certificates, and ensure your traffic is encrypted end-to-end. That way, sensitive keys and requests don’t travel in the clear text format.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;If you’d like to dive deeper into secure gateways, &lt;a href=&#34;https://github.com/frozenprocess/calico-gateway-api-examples&#34;&gt;click here&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Control the traffic (Sorry this cluster is RSVP only)&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Next, think about what happens inside the cluster. By default, all pods can talk to each other, like an open office. One compromised pod, and attackers can roam freely. To fix this you need to use Kubernetes network policies, a standard way to secure namespaced resources within your cluster. But there is a catch, Kubernetes on its own doesn’t enforce these policies it relies on your CNI (policy engine) to enforce them. Keep in mind that each CNI will also come with some “unique sauce” that allows you to go beyond what standard network policy providers.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;For example, some CNIs support Global Network Policies that secure both namespaced and non-namespaced resources. By implementing such policies suddenly, your cluster has a VIP list, and lateral movement is blocked.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;If you’d like to learn more about securing your entire cluster, &lt;a href=&#34;https://github.com/frozenprocess/Tigera-Presentations/tree/master/2023-03-30.container-and-Kubernetes-security-policy-design/04.best-practices-for-securing-a-Kubernetes-environment&#34;&gt;click here&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;&lt;em&gt;Cloud AI providers (watch the other doors)&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In some cases it might be “cheaper” to use Cloud providers instead of building your own AI apparatus, in such cases you should make sure that your API keys from these providers are not loosely configured and are actually tied to an identity that is only accessible to you. The easiest form of Identity that you can manage without having your developers to touch the code is IP address restrictions.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1262&#34; height=&#34;568&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-3.21.11-PM.jpg&#34; alt=&#34;Cloud AI providers (watch the other doors)&#34; class=&#34;wp-image-149207&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-3.21.11-PM.jpg 1262w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-3.21.11-PM-300x135.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-3.21.11-PM-1024x461.jpg 1024w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-3.21.11-PM-768x346.jpg 768w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-3.21.11-PM-900x405.jpg 900w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-3.21.11-PM-444x200.jpg 444w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-3.21.11-PM-889x400.jpg 889w&#34; sizes=&#34;auto, (max-width: 1262px) 100vw, 1262px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;&lt;em&gt;Managing outgoing traffic ( Network Address Translation )&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;At this point, you might be wondering, with Kubernetes pods having ephemeral IPs, how can you ensure your workloads present a consistent IP to cloud providers?&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The answer comes down to your CNI of choice.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Depending on your CNI, you can configure Network Address Translation (NAT) to ensure workloads maintain stable, predictable IPs. You can even get granular with inclusions and exclusions, specifying exactly which interfaces or pods should use certain IPs. This gives you a reliable identity for external communications, critical for enforcing API key restrictions or ensuring cloud services recognize your workloads correctly.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;&lt;em&gt;Managing outgoing traffic ( Egress Gateways )&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Egress gateways are another way to make sure which Identities should be used when communicating to an endpoint. An egress gateway is a configurable Pod, or node workload (depending on the CNCF based solution you have chosen) that gives you a more granular way to control your NATs.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;br&gt;For example, Calico Egress Gateway allows you to run pods that become an immediate gateway for your workloads and can be managed via independent policies and routes. This allows you to achieve&amp;nbsp; routing isolation for pods that need to talk to AI providers and deny or redirect other pods to other gateways.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;If you’d like to learn more about egress access within kubernetes, click &lt;a href=&#34;https://docs.tigera.io/calico/latest/about/kubernetes-training/about-kubernetes-egress&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;Observability (What is actually happening inside the house)&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In the cloud, observability is everything. Traditional logging and perimeter security just don’t cut it anymore, they can’t explain why Kubernetes does what it does. Workloads in a distributed system can be running on different nodes, across clusters, or even in different regions. Without context, you’re basically flying blind, and that’s where traditional logging falls short and that is why the hottest topic in cloud native &lt;a href=&#34;https://www.cncf.io/blog/2025/07/18/a-mid-year-2025-look-at-cncf-linux-foundation-and-the-top-30-open-source-projects/&#34;&gt;right now is OpenTelemetry&lt;/a&gt;, a free, open-source framework/standard that helps capture, logs traces, metrics from distributed systems&amp;nbsp; and present it in a human readable way.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Modern CNI tools include observability features such as flow logs, service graphs, and context-aware visibility that show exactly how traffic flows between workloads, which policies are applied, and why. When combined with Grafana and Prometheus, these insights create a clear view into your Kubernetes cluster—turning “mystery connections” into actionable data and enabling a true zero-trust approach for AI workloads.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;If you’d like to learn more about observability, click &lt;a href=&#34;https://www.tigera.io/learn/guides/observability/&#34;&gt;here&lt;/a&gt;.&amp;nbsp;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;The bottom line&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;While at the moment, AI can seem a new frontier, running into it without proper security is both dangerous and expensive. In this blog post we’ve gone through some simple security adjustments that can help you to secure your next bright idea in Kubernetes.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;p&gt;如今，法学硕士和人工智能无处不在。每个人都想打造下一个大产品，快速交付，甚至可能兑现并度过余生。问题？大多数开源人工智能项目都是按原样共享的。它们的创建是出于最好的意图，但它们的开发人员不会因为安全护栏或生产强化等问题而失眠，这部分留给您来解决。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果这听起来像您所在的船，那么您来对地方了。在本博客中，我们将了解在 Kubernetes 上运行 AI 如何引入一些非常现实的网络和安全挑战，以及在您的实验变成负担之前您可以采取哪些措施。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;因为事情是这样的：人工智能系统很复杂，有时甚至构建它们的人也承认他们并不完全知道模型为何做出这样的决定。但归根结底，它仍然只是在计算机和网络电缆周围移动的数据，并且如果您知道正确的模式，那么保护这些数据（无论是 API 密钥、训练数据还是模型端点）比您想象的要容易。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;这些人工智能安全挑战是否独特？&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;是和否。一方面，人工智能工作负载面临的问题、不受限制的网络流量、暴露的端点、泄露的凭证，都是我们几十年来一直在 IT 领域努力解决的经典安全问题。另一方面，它们不仅仅移动数据，还处理敏感的训练数据集、昂贵的推理工作负载以及可能在几秒钟内被滥用的强大 API。 API 密钥被盗并不仅仅意味着轻微的违规行为；这可能意味着数千美元的云账单，或者一个开始向错误的知己泄露秘密的模型。受损的 Pod 不仅会泄露日志，还会泄露日志。它可能会暴露您花费数月时间微调的专有数据集，一夜之间消除您的竞争优势。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;因此，虽然问题并不是全新的，但风险却要高得多。这就像将自行车锁在咖啡馆外与将跑车钥匙插在点火开关上运行之间的区别一样。两者都有风险，但其中一个会更快地招来麻烦。 “如果您住在阿姆斯特丹或温哥华，则相反的顺序是正确的自行车；）”&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;保护人工智能系统的安全就像驯服一头“复杂的野兽”。虽然开发人员专注于模型训练和应用程序逻辑，但关键的安全考虑因素往往被忽视。部分原因是开源人工智能项目通常“按原样”呈现，或者因为这些框架的变化速度比光速更快，这就是为什么我们为生产环境提供的框架没有或有限的内置安全护栏。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;当部署在默认 Kubernetes 集群中时，这些 AI 工作负载面临重大风险：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;不受控制的网络流量：默认情况下，Kubernetes 集群中的所有 Pod他们可以自由地相互交流。这创建了一个开放的环境，其中单个受损组件可能导致横向移动和更广泛的系统漏洞。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;敏感数据泄露：AI 应用程序经常处理敏感 API 密钥以与外部服务连接。如果没有适当的处理，这些密钥可以通过未加密的渠道“在您的用户和平台之间传输”，很容易被窃听。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;不安全的网络暴露：在没有强大的入口安全性的情况下，将 AI 端点暴露给用户或其他服务会使它们容易遭受未经授权的访问和潜在的攻击。&lt;​​/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;在 Kubernetes 上保护 AI 的蓝图&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在 Kubernetes 上保护 AI 的安全不需要重新发明轮子。相反，它涉及使用专用工具集应用云原生生态系统中的“众所周知的安全最佳实践”。本博客中的示例引用了常见的 CNI 实现（例如 Calico 或 Cilium），这些实现提供了解决 AI 工作负载的独特安全挑战的框架。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;保护端点的入口安全（保护前门）&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;防止 API 密钥窃听的第一步是锁定 AI 工作负载的入口点。 Ollama、vLLM 或 LiteLLM 等许多框架都附带一个开箱即用的普通 HTTP 服务器，这意味着如果您不小心，路径中的任何人都可以窥探您的流量。当这些框架在 Kubernetes 内运行时，使用证书保护其 API 端点是您的第一道防线。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;br&gt;好消息？ Kubernetes 让这一切变得简单。使用“网关 API”标准，您可以创建网关、附加证书并确保您的流量进行端到端加密。这样，敏感密钥和请求就不会以明文格式传输。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果您想深入了解安全网关，&lt;a href=&#34;https://github.com/frozenprocess/calico-gateway-api-examples&#34;&gt;点击此处&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;控制流量（抱歉，此集群仅支持 RSVP）&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;接下来，考虑一下集群内部会发生什么。默认情况下，所有 Pod 都可以相互通信，就像开放式办公室一样。一个被入侵的 Pod，攻击者就可以自由漫游。要解决此问题，您需要使用 Kubernetes 网络策略，这是保护集群内命名空间资源的标准方法。但有一个问题，Kubernetes 本身并不强制执行这些策略，它依赖于 CNI（策略引擎）来强制执行它们。请记住，每个 CNI 还将附带一些“独特的酱汁”，使您能够超越标准网络策略提供商。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;例如，某些 CNI 支持保护命名空间和非命名空间资源的全局网络策略。通过突然实施此类策略，您的集群将拥有 VIP 列表，横向移动将被阻止。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果您想了解有关保护整个集群的更多信息，&lt;a href=&#34;https://github.com/frozenprocess/Tigera-Presentations/tree/master/2023-03-30.container-and-Kubernetes-security-policy-design/04.best-practices-for-secure-a-Kubernetes-environment&#34;&gt;点击此处&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;&lt;em&gt;云人工智能提供商（留意其他门）&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在某些情况下，使用云提供商而不是构建自己的人工智能设备可能会“更便宜”，在这种情况下，您应该确保来自这些提供商的 API 密钥配置不松散，并且实际上与只有您可以访问的身份绑定。 IP 地址限制是您无需开发人员接触代码即可管理的最简单的身份验证形式。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“1262”高度=“568” src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-3.21.11-PM.jpg&#34; alt=&#34;云人工智能提供商（注意其他门）&#34; class=&#34;wp-image-149207&#34; srcset =“https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-3.21.11-PM.jpg 1262w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-3.21.11-PM-300x135.jpg 300w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-3.21.11-PM-1024x461.jpg 1024w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-3.21.11-PM-768x346.jpg 768w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-3.21.11-PM-900x405.jpg 900w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-3.21.11-PM-444x200.jpg 444w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-3.21.11-PM-889x400.jpg 889w“尺寸=”自动，（最大宽度：1262px）100vw，1262px“ referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;&lt;em&gt;管理传出流量（网络地址转换）&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此时，您可能想知道，由于 Kubernetes Pod 具有临时 IP，如何确保您的工作负载向云提供商提供一致的 IP？&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;答案取决于您选择的 CNI。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;根据您的 CNI，您可以配置网络地址转换 (NAT) 以确保工作负载保持稳定、可预测的 IP。您甚至可以细化包含和排除项，准确指定哪些接口或 Pod 应使用某些 IP。这为您提供了外部通信的可靠身份，对于执行 API 密钥限制或确保云服务正确识别您的工作负载至关重要。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;&lt;em&gt;管理传出流量（出口网关）&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;出口网关是确保与端点通信时应使用哪些身份的另一种方法。出口网关是一个可配置的 Pod 或节点工作负载（取决于您选择的基于 CNCF 的解决方案），它为您提供更精细的方式来控制 NAT。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;br&gt;例如，印花布Egress Gateway 允许您运行 Pod，这些 Pod 成为工作负载的直接网关，并且可以通过独立的策略和路由进行管理。这使您可以为需要与 AI 提供商通信的 Pod 实现路由隔离，并拒绝或将其他 Pod 重定向到其他网关。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果您想了解有关 kubernetes 中出口访问的更多信息，请点击&lt;a href=&#34;https://docs.tigera.io/calico/latest/about/kubernetes-training/about-kubernetes-egress&#34;&gt;此处&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;可观察性（房子内实际发生的情况）&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在云中，可观察性就是一切。传统的日志记录和外围安全已经不再有效，它们无法解释 Kubernetes 为何这么做。分布式系统中的工作负载可以运行在不同节点、跨集群、甚至不同区域。如果没有上下文，你基本上是盲目的，这就是传统日志记录的不足之处，这就是为什么云原生&lt;a href=&#34;https://www.cncf.io/blog/2025/07/18/a-mid-year-2025-look-at-cncf-linux-foundation-and-the-top-30-open-source-projects/&#34;&gt;现在最热门的话题是 OpenTelemetry&lt;/a&gt;，一个免费的开源框架/标准，有助于捕获、记录来自分布式系统的跟踪和指标，并以人类可读的方式呈现。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;现代 CNI 工具包括可观察性功能，例如流日志、服务图和上下文感知可见性，这些功能可以准确显示流量在工作负载之间的流动方式、应用了哪些策略以及原因。与 Grafana 和 Prometheus 结合使用时，这些见解可以为您的 Kubernetes 集群提供清晰的视图，将“神秘连接”转化为可操作的数据，并为 AI 工作负载提供真正的零信任方法。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;如果您想了解有关可观察性的更多信息，请点击&lt;a href=&#34;https://www.tigera.io/learn/guides/observability/&#34;&gt;此处&lt;/a&gt;。  &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;底线&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;目前，人工智能似乎是一个新领域，但在没有适当安全措施的情况下进入它既危险又昂贵。在这篇博文中，我们完成了一些简单的安全调整，可以帮助您确保 Kubernetes 中的下一个好主意。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Thu, 09 Oct 2025 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Testing asynchronous workflows using OpenTelemetry and Istio】使用 OpenTelemetry 和 Istio 测试异步工作流程</title>
      <link>https://www.cncf.io/blog/2025/10/09/testing-asynchronous-workflows-using-opentelemetry-and-istio/</link>
      <description>【&lt;p&gt;&lt;em&gt;Learn how to test complex asynchronous workflows in cloud native applications using OpenTelemetry for context propagation and Istio for traffic routing. Explore cost-effective approaches to isolate test environments without duplicating infrastructure.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Introduction&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Asynchronous architectures have become a cornerstone of modern cloud native applications, enabling services to operate independently while maintaining system resilience and scalability. These architectures typically rely on message queues and event-driven communication patterns to decouple services, allowing them to handle varying loads and failures gracefully.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Popular message systems in the cloud native ecosystem include Apache Kafka, RabbitMQ, Redis Streams, Google Cloud Pub/Sub, AWS SQS, and Azure Service Bus. Each offers unique capabilities for different use cases, from high-throughput streaming to reliable message delivery. Regardless of which system you choose, testing end-to-end workflows that span multiple services and asynchronous boundaries presents unique challenges that traditional testing approaches struggle to address effectively.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This article explores how two CNCF projects—OpenTelemetry for distributed tracing and context propagation, and Istio for traffic management—can work together to create cost-effective, scalable testing environments for asynchronous workflows without the overhead of duplicating entire infrastructure stacks.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Challenges in testing asynchronous systems&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Testing asynchronous systems introduces several complex challenges not found in synchronous, request-response architectures:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;Environment setup complexity&lt;/strong&gt;: Asynchronous systems require multiple coordinated components—brokers, producers, consumers, and often additional infrastructure like schema registries or monitoring tools. Setting up these components correctly with proper security, replication, and partitioning requires significant expertise and time.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Test isolation&lt;/strong&gt;: Unlike synchronous calls where requests can be easily isolated, asynchronous messages in shared systems can interfere with each other. Ensuring that test data from one scenario doesn’t impact another requires careful coordination.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Resource costs&lt;/strong&gt;: Traditional approaches often require duplicating entire message infrastructure for each test environment, leading to exponential cost growth as teams scale their testing practices.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Timing and ordering&lt;/strong&gt;: Asynchronous systems introduce timing dependencies and message ordering considerations that make tests more complex to design and more prone to flaky behavior.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Environment drift&lt;/strong&gt;: Maintaining multiple isolated environments often leads to configuration drift, where test environments diverge from production, reducing test confidence.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In this context, we define a &lt;em&gt;test tenant&lt;/em&gt; as an isolated testing context that needs to run test scenarios without interfering with other concurrent tests or production traffic.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Three approaches to test environment isolation&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;There are three primary approaches to achieving test isolation in asynchronous systems, each with different trade-offs in terms of cost, complexity, and isolation guarantees:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;1. Infrastructure-level isolation&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The most straightforward approach is to create completely separate infrastructure for each test tenant. This means deploying independent instances of message brokers, databases, and all supporting services for every test scenario.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;640&#34; height=&#34;220&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/isol1.png&#34; alt=&#34;Infrastructure-level isolation&#34; class=&#34;wp-image-149193&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/isol1.png 640w, https://www.cncf.io/wp-content/uploads/2025/10/isol1-300x103.png 300w, https://www.cncf.io/wp-content/uploads/2025/10/isol1-582x200.png 582w&#34; sizes=&#34;auto, (max-width: 640px) 100vw, 640px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Advantages:&lt;/strong&gt; Complete isolation between test environments with no risk of cross-tenant interference. Tests can modify any infrastructure configuration without affecting others.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Considerations:&lt;/strong&gt; This approach becomes prohibitively expensive as the number of concurrent tests grows. Managing numerous independent environments creates significant operational overhead. Without automation, environments quickly become stale and drift from production configurations, reducing test reliability.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;2. Resource-level isolation&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This approach shares core infrastructure (like message brokers) between tenants but creates isolated resources within that infrastructure. For example, using dedicated topics in Kafka, separate queues in RabbitMQ, or isolated namespaces in Redis for each test tenant.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;640&#34; height=&#34;302&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/isol2.png&#34; alt=&#34;Resource-level isolation&#34; class=&#34;wp-image-149194&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/isol2.png 640w, https://www.cncf.io/wp-content/uploads/2025/10/isol2-300x142.png 300w, https://www.cncf.io/wp-content/uploads/2025/10/isol2-424x200.png 424w&#34; sizes=&#34;auto, (max-width: 640px) 100vw, 640px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Advantages:&lt;/strong&gt; Significant cost savings compared to full duplication while maintaining good isolation. Shared infrastructure components reduce operational complexity.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Considerations:&lt;/strong&gt; Still requires duplicating and reconfiguring all producer and consumer services for each tenant. Complex automation is needed to create and tear down resources dynamically. Configuration management becomes challenging as the number of tenants grows.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;3. Request-level isolation&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The most cost-effective approach establishes a shared baseline environment with all infrastructure and services running in production-like configurations. Test isolation is achieved through dynamic routing of requests and messages based on tenant context, rather than physical resource separation.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In this model, each test tenant has a unique identifier that gets propagated through all synchronous and asynchronous communication. Services use this identifier to determine whether they should process a given request or message. When testing specific service versions, only those services under test are deployed as separate instances—everything else uses the shared baseline.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;517&#34; height=&#34;421&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/isol3.png&#34; alt=&#34;Request-level isolation&#34; class=&#34;wp-image-149195&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/isol3.png 517w, https://www.cncf.io/wp-content/uploads/2025/10/isol3-300x244.png 300w, https://www.cncf.io/wp-content/uploads/2025/10/isol3-246x200.png 246w, https://www.cncf.io/wp-content/uploads/2025/10/isol3-491x400.png 491w&#34; sizes=&#34;auto, (max-width: 517px) 100vw, 517px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Advantages:&lt;/strong&gt; Minimal infrastructure duplication leads to dramatic cost savings (often 85%+ reduction). No environment drift since the baseline is continuously updated through existing CI/CD pipelines. Fastest environment creation (seconds vs. minutes/hours). Lowest operational overhead.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Considerations:&lt;/strong&gt; Requires instrumenting services for context propagation and implementing selective message processing. May not be suitable for scenarios requiring infrastructure-level isolation or testing infrastructure changes themselves.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The remainder of this article focuses on implementing this request-level isolation approach using OpenTelemetry and Istio.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Implementing request-level isolation&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Implementing request-level isolation requires two key capabilities: propagating tenant context across service boundaries, and routing traffic based on that context. OpenTelemetry and Istio provide complementary solutions to these challenges.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The architecture works by assigning each test tenant a unique identifier with mappings to specific service versions being tested. This tenant ID gets propagated through both synchronous (HTTP/gRPC) and asynchronous (message queue) communication paths, enabling dynamic routing decisions at every hop.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Central RouteService for tenant mapping&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;A critical component in this architecture is a central RouteService that maintains the authoritative mapping of tenant IDs to specific service versions under test. This service acts as the source of truth that all consumers consult to determine whether they should process a given message.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;When multiple versions of a consumer service are running (baseline and under-test versions), each instance receives all messages from the shared message queue. However, only one consumer should process each message based on the tenant context. The RouteService solves this consumer contention problem by providing a centralized decision point:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;Centralized configuration:&lt;/strong&gt; All tenant-to-service mappings are stored in one place, making it easy to create, modify, and delete test scenarios without coordinating across multiple services.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Consumer coordination:&lt;/strong&gt; Multiple consumer instances can safely coexist, with each consulting the RouteService to determine if they should process a message based on the tenant ID and their own service version.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Dynamic updates:&lt;/strong&gt; Test scenarios can be created and destroyed without restarting consumers—they simply get updated routing information from the RouteService.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1288&#34; height=&#34;724&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.01.05-PM.jpg&#34; alt=&#34;Code&#34; class=&#34;wp-image-149196&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.01.05-PM.jpg 1288w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.01.05-PM-300x169.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.01.05-PM-1024x576.jpg 1024w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.01.05-PM-768x432.jpg 768w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.01.05-PM-900x506.jpg 900w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.01.05-PM-356x200.jpg 356w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.01.05-PM-712x400.jpg 712w&#34; sizes=&#34;auto, (max-width: 1288px) 100vw, 1288px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Using OpenTelemetry for context propagation&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://opentelemetry.io/&#34;&gt;OpenTelemetry&lt;/a&gt; provides the foundation for propagating tenant context across service boundaries through its powerful context propagation capabilities. The key mechanisms are:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Baggage for custom context:&lt;/strong&gt; OpenTelemetry’s&lt;a href=&#34;https://opentelemetry.io/docs/concepts/signals/baggage/&#34;&gt; Baggage&lt;/a&gt; feature allows you to attach custom key-value pairs (like tenant IDs) to traces that automatically propagate across service calls. This works for both HTTP/gRPC requests and can be extended to asynchronous messaging systems.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Automatic header propagation:&lt;/strong&gt; OpenTelemetry’s auto-instrumentation libraries for languages like Java, Node.js, Python, and Go automatically handle header propagation for popular frameworks, reducing the implementation burden on development teams.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Message queue integration:&lt;/strong&gt; OpenTelemetry provides specific guidance and libraries for propagating context through message queues. For example, when publishing messages to Kafka, producers automatically inject trace context (including baggage) into message headers. Consumers can then extract this context to make routing decisions.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1292&#34; height=&#34;576&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.03.00-PM.jpg&#34; alt=&#34;Code - adding tenant ID to OTel baggage&#34; class=&#34;wp-image-149197&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.03.00-PM.jpg 1292w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.03.00-PM-300x134.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.03.00-PM-1024x457.jpg 1024w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.03.00-PM-768x342.jpg 768w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.03.00-PM-900x401.jpg 900w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.03.00-PM-449x200.jpg 449w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.03.00-PM-897x400.jpg 897w&#34; sizes=&#34;auto, (max-width: 1292px) 100vw, 1292px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;On the consumer side, services can extract the tenant ID from the propagated context and decide whether to process the message based on their tenant mappings:&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1274&#34; height=&#34;502&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.36-PM.jpg&#34; alt=&#34;Code - Consumer side&#34; class=&#34;wp-image-149202&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.36-PM.jpg 1274w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.36-PM-300x118.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.36-PM-1024x403.jpg 1024w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.36-PM-768x303.jpg 768w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.36-PM-900x355.jpg 900w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.36-PM-508x200.jpg 508w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.36-PM-1015x400.jpg 1015w&#34; sizes=&#34;auto, (max-width: 1274px) 100vw, 1274px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Leveraging Istio for traffic routing&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;While OpenTelemetry handles context propagation,&lt;a href=&#34;https://istio.io/&#34;&gt; Istio&lt;/a&gt; provides sophisticated traffic routing capabilities that complement this by enabling dynamic routing of HTTP/gRPC requests based on headers, including the tenant context propagated by OpenTelemetry.&lt;strong&gt;Virtual services for header-based routing:&lt;/strong&gt; Istio Virtual Services can route requests to different service versions based on header values. This allows you to direct traffic from specific tenants to the service versions under test while sending all other traffic to the baseline services.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1270&#34; height=&#34;1066&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.08-PM.jpg&#34; alt=&#34;Code - Istio VirtualService&#34; class=&#34;wp-image-149201&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.08-PM.jpg 1270w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.08-PM-300x252.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.08-PM-1024x860.jpg 1024w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.08-PM-768x645.jpg 768w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.08-PM-900x755.jpg 900w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.08-PM-238x200.jpg 238w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.08-PM-477x400.jpg 477w&#34; sizes=&#34;auto, (max-width: 1270px) 100vw, 1270px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Destination rules for service subsets:&lt;/strong&gt; Istio Destination Rules define the different versions of services (baseline vs. under-test) and their load balancing policies:&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1270&#34; height=&#34;764&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.11.08-PM.jpg&#34; alt=&#34;Code - Destination Rule&#34; class=&#34;wp-image-149203&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.11.08-PM.jpg 1270w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.11.08-PM-300x180.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.11.08-PM-1024x616.jpg 1024w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.11.08-PM-768x462.jpg 768w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.11.08-PM-900x541.jpg 900w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.11.08-PM-332x200.jpg 332w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.11.08-PM-665x400.jpg 665w&#34; sizes=&#34;auto, (max-width: 1270px) 100vw, 1270px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Key benefits of Istio integration:&lt;/strong&gt; Transparent routing without application code changes, sophisticated traffic shaping capabilities (weighted routing, fault injection, timeouts), and comprehensive observability of routing decisions through built-in metrics and tracing integration.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Implementation considerations&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;While this approach offers significant benefits, there are several important considerations for successful implementation:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Non-request-scoped workflows:&lt;/strong&gt; Some asynchronous workflows aren’t triggered by external requests—batch jobs, scheduled tasks, or event-driven processes that start from database changes or time-based triggers. These scenarios require alternative approaches, such as embedding tenant context in data sources or using separate scheduling mechanisms for test scenarios.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Distributed cache management:&lt;/strong&gt; When services cache tenant mappings for performance, cache invalidation becomes critical. Implementing proper cache coherence mechanisms (like Redis pub/sub notifications or short TTL values) ensures that services quickly recognize new tenants or mapping changes.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Consumer group lifecycle:&lt;/strong&gt; Message queue consumer groups require careful lifecycle management. Create unique consumer group names for test services, ensure proper offset handling (often starting from the baseline consumer’s current offset), and clean up consumer groups when tests complete to avoid resource leaks.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Data isolation strategies:&lt;/strong&gt; Different levels of data isolation may be needed depending on your use case. Options include tenant-prefixed keys in databases, separate database schemas, or carefully designed test data that doesn’t conflict with baseline data.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Observability and debugging:&lt;/strong&gt; Implement comprehensive logging and metrics around tenant routing decisions. OpenTelemetry’s distributed tracing helps track how tenant context flows through the system and identify where routing decisions are made.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Security considerations:&lt;/strong&gt; Ensure tenant IDs can’t be spoofed or manipulated by unauthorized actors. Consider using signed tokens or validating tenant context against authorized test scenarios to prevent accidental or malicious cross-tenant access.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Conclusion&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Testing asynchronous workflows in cloud native applications presents unique challenges that traditional testing approaches struggle to address cost-effectively. The combination of OpenTelemetry for context propagation and Istio for traffic routing provides a powerful foundation for implementing request-level isolation that dramatically reduces infrastructure costs while maintaining high-quality testing practices.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The vendor-neutral nature of both OpenTelemetry and Istio makes this solution broadly applicable across different cloud providers, message systems, and application architectures. Success with this approach requires careful planning for edge cases, such as batch workflows, and proper lifecycle management of shared resources, but the benefits—reduced costs, faster feedback loops, and elimination of environment drift—make it a compelling choice for teams serious about scaling their testing practices in cloud native environments.&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;p&gt;&lt;em&gt;了解如何使用 OpenTelemetry 进行上下文传播，使用 Istio 进行流量路由，在云原生应用程序中测试复杂的异步工作流程。探索经济高效的方法来隔离测试环境，而无需重复基础设施。&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;简介&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;异步架构已成为现代云原生应用程序的基石，使服务能够独立运行，同时保持系统弹性和可扩展性。这些架构通常依赖消息队列和事件驱动的通信模式来解耦服务，从而使它们能够优雅地处理变化的负载和故障。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;云原生生态系统中流行的消息系统包括 Apache Kafka、RabbitMQ、Redis Streams、Google Cloud Pub/Sub、AWS SQS 和 Azure Service Bus。每个都为不同的用例提供了独特的功能，从高吞吐量流到可靠的消息传递。无论您选择哪种系统，测试跨越多个服务和异步边界的端到端工作流程都会带来传统测试方法难以有效解决的独特挑战。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;本文探讨了两个 CNCF 项目（用于分布式跟踪和上下文传播的 OpenTelemetry 以及用于流量管理的 Istio）如何协同工作，为异步工作流程创建经济高效、可扩展的测试环境，而无需复制整个基础设施堆栈的开销。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;测试异步系统的挑战&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;测试异步系统引入了同步请求响应架构中未发现的几个复杂挑战：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;环境设置复杂性&lt;/strong&gt;：异步系统需要多个协调组件——代理、生产者、消费者，通常还需要额外的基础设施，例如模式注册表或监控工具。通过适当的安全性、复制和分区来正确设置这些组件需要大量的专业知识和时间。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;测试隔离&lt;/strong&gt;：与可以轻松隔离请求的同步调用不同，共享系统中的异步消息可能会相互干扰。确保一种场景的测试数据不会影响另一种场景需要仔细协调。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;资源成本&lt;/strong&gt;：传统方法通常需要为每个测试环境复制整个消息基础架构，导致随着团队扩展测试实践，成本呈指数级增长。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;计时和排序&lt;/strong&gt;：异步系统引入了计时依赖性和消息排序注意事项，使测试设计更加复杂，并且更容易出现不稳定的行为。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;环境漂移&lt;/strong&gt;：维护多个隔离环境通常会导致配置漂移，即测试环境与产品环境不同行动，降低测试信心。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在这种情况下，我们将&lt;em&gt;测试租户&lt;/em&gt;定义为一个独立的测试上下文，需要运行测试场景而不干扰其他并发测试或生产流量。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;测试环境隔离的三种方法&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在异步系统中实现测试隔离有三种主要方法，每种方法在成本、复杂性和隔离保证方面都有不同的权衡：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;1.基础设施级隔离&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;最直接的方法是为每个测试租户创建完全独立的基础架构。这意味着为每个测试场景部署消息代理、数据库和所有支持服务的独立实例。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34;解码=&#34;async&#34; width=&#34;640&#34; height=&#34;220&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/isol1.png&#34; alt=&#34;基础设施级隔离&#34; class =“wp-image-149193”srcset =“https://www.cncf.io/wp-content/uploads/2025/10/isol1.png 640w，https://www.cncf.io/wp-content/uploads/2025/10/isol1-300x103.png 300w，https://www.cncf.io/wp-content/uploads/2025/10/isol1-582x200.png 582w“尺寸=”自动，（最大宽度：640px）100vw，640px“referrerpolicy=“no-referrer”&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;测试环境之间完全隔离，没有跨租户干扰的风险。测试可以修改任何基础设施配置而不影响其他配置。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;随着并发测试数量的增加，这种方法的成本变得异常昂贵。管理众多独立环境会产生巨大的运营开销。如果没有自动化，环境很快就会变得陈旧并偏离生产配置，从而降低测试可靠性。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;2.资源级隔离&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此方法在租户之间共享核心基础设施（如消息代理），但在该基础设施内创建隔离的资源。例如，为每个测试租户使用 Kafka 中的专用主题、RabbitMQ 中的单独队列或 Redis 中的隔离命名空间。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34;解码=&#34;async&#34; width=&#34;640&#34; height=&#34;302&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/isol2.png&#34; alt=&#34;资源级隔离&#34; 类=“wp-image-149194”srcset=“https://www.cncf.io/wp-content/uploads/2025/10/isol2.png 640w，https://www.cncf.io/wp-content/uploads/2025/10/isol2-300x142.png 300w，https://www.cncf.io/wp-content/uploads/2025/10/isol2-424x200.png 424w“尺寸=”自动，（最大宽度：640px）100vw，640px“referrerpolicy=“no-referrer”&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;与完全复制相比，可显着节省成本，同时保持良好的隔离性。共享基础架构组件降低了运营复杂性。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;考虑口粮：仍然需要为每个租户复制和重新配置所有生产者和消费者服务。动态创建和拆除资源需要复杂的自动化。随着租户数量的增长，配置管理变得具有挑战性。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;3.请求级隔离&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;最具成本效益的方法是建立一个共享基线环境，所有基础设施和服务都在类似生产的配置中运行。测试隔离是通过基于租户上下文动态路由请求和消息来实现的，而不是物理资源分离。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在此模型中，每个测试租户都有一个唯一的标识符，该标识符通过所有同步和异步通信进行传播。服务使用此标识符来确定它们是否应该处理给定的请求或消息。测试特定服务版本时，只有那些被测试的服务才会部署为单独的实例，其他所有服务都使用共享基线。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;imgloading=&#34;lazy&#34;decoding=&#34;async&#34;width=&#34;517&#34;height=&#34;421&#34;src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/isol3.png&#34;alt=&#34;请求级隔离&#34; class =“wp-image-149195”srcset =“https://www.cncf.io/wp-content/uploads/2025/10/isol3.png 517w，https://www.cncf.io/wp-content/uploads/2025/10/isol3-300x244.png 300w，https://www.cncf.io/wp-content/uploads/2025/10/isol3-246x200.png 246w，https://www.cncf.io/wp-content/uploads/2025/10/isol3-491x400.png 491w&#34; 尺寸=“自动，（最大宽度：517px）100vw，517px”referrerpolicy=“no-referrer”&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;最少的基础设施重复可以显着节省成本（通常减少 85% 以上）。由于基线通过现有 CI/CD 管道不断更新，因此没有环境漂移。最快的环境创建（秒与分钟/小时）。最低的运营开销。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;需要用于上下文传播和实现选择性消息处理的检测服务。可能不适合需要基础设施级隔离或测试基础设施变更本身的场景。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;本文的其余部分重点介绍使用 OpenTelemetry 和 Istio 实现这种请求级隔离方法。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;实现请求级隔离&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;实现请求级隔离需要两个关键功能：跨服务边界传播租户上下文，以及基于该上下文路由流量。 OpenTelemetry 和 Istio 为这些挑战提供了补充解决方案。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;该架构的工作原理是为每个测试租户分配一个唯一标识符，并映射到正在测试的特定服务版本。此租户 ID 通过同步 (HTTP/gRPC) 和异步（消息队列）通信路径传播，从而在每一跳实现动态路由决策。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;用于租户映射的中央 RouteService&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此架构中的一个关键组件是中央 RouteService，它维护租户 ID 到正在测试的特定服务版本的权威映射。该服务充当所有消费者参考以确定是否应该处理给定消息的事实来源。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;当消费者服务的多个版本运行时（基准版本和测试版本），每个实例都会接收来自共享消息队列的所有消息。但是，只有一个消费者应该根据租户上下文处理每条消息。 RouteService 通过提供集中决策点解决了消费者争用问题：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;集中配置&lt;/strong&gt;：所有租户到服务的映射都存储在一个位置，从而可以轻松创建、修改和删除测试场景，而无需跨多个服务进行协调。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;消费者协调：&lt;/strong&gt;多个消费者实例可以安全地共存，每个实例都会咨询 RouteService 以确定它们是否应该根据租户 ID 和自己的服务版本处理消息。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;动态更新：&lt;/strong&gt;无需重新启动消费者即可创建和销毁测试场景 - 它们只需从 RouteService 获取更新的路由信息​​即可。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“1288”高度=“724” src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.01.05-PM.jpg&#34; alt=&#34;代码&#34; class=&#34;wp-image-149196&#34; srcset =“https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.01.05-PM.jpg 1288w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.01.05-PM-300x169.jpg 300w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.01.05-PM-1024x576.jpg 1024w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.01.05-PM-768x432.jpg 768w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.01.05-PM-900x506.jpg 900w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.01.05-PM-356x200.jpg 356w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.01.05-PM-712x400.jpg 712w“尺寸=”自动，（最大宽度：1288px）100vw，1288px“ referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;使用 OpenTelemetry 进行上下文传播&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://opentelemetry.io/&#34;&gt;OpenTelemetry&lt;/a&gt; 通过其强大的上下文传播功能，为跨服务边界传播租户上下文提供了基础。关键机制是：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;自定义上下文的 Baggage：&lt;/strong&gt;OpenTelemetry 的&lt;a href=&#34;https://opentelemetry.io/docs/concepts/signals/baggage/&#34;&gt; Baggage&lt;/a&gt; 功能允许您将自定义键值对（例如租户 ID）附加到自动传播 acros 的跟踪的服务电话。这适用于 HTTP/gRPC 请求，并且可以扩展到异步消息系统。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;自动标头传播：&lt;/strong&gt;OpenTelemetry 针对 Java、Node.js、Python 和 Go 等语言的自动检测库可自动处理流行框架的标头传播，从而减轻开发团队的实施负担。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;消息队列集成：&lt;/strong&gt;OpenTelemetry 提供了通过消息队列传播上下文的具体指南和库。例如，当向 Kafka 发布消息时，生产者会自动将跟踪上下文（包括行李）注入到消息标头中。然后，消费者可以提取此上下文来做出路由决策。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“1292”高度=“576” src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.03.00-PM.jpg&#34; alt=&#34;代码 - 将租户 ID 添加到 OTel 行李&#34; class=&#34;wp-image-149197&#34; srcset =“https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.03.00-PM.jpg 1292w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.03.00-PM-300x134.jpg 300w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.03.00-PM-1024x457.jpg 1024w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.03.00-PM-768x342.jpg 768w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.03.00-PM-900x401.jpg 900w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.03.00-PM-449x200.jpg 449w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.03.00-PM-897x400.jpg 897w“尺寸=”自动，（最大宽度：1292px）100vw，1292px“ referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在消费者方面，服务可以从传播的上下文中提取租户 ID，并根据其租户映射决定是否处理消息：&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“1274”高度=“502” src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.36-PM.jpg&#34; alt=&#34;代码-消费者端&#34; class=&#34;wp-image-149202&#34; srcset =“https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.36-PM.jpg 1274w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.36-PM-300x118.jpg 300w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.36-PM-1024x403.jpg 1024w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.36-PM-768x303.jpg 768w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.36-PM-900x355.jpg 900w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.36-PM-508x200.jpg 508w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.36-PM-1015x400.jpg 1015w“尺寸=”自动，（最大宽度：1274px）100vw，1274px“referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;利用 Istio 进行流量路由&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;虽然 OpenTelemetry 处理上下文传播，&lt;a href=&#34;https://istio.io/&#34;&gt;Istio&lt;/a&gt; 提供了复杂的流量路由功能，通过基于标头（包括 OpenTelemetry 传播的租户上下文）启用 HTTP/gRPC 请求的动态路由来补充这一功能。&lt;strong&gt;基于标头路由的虚拟服务：&lt;/strong&gt; Istio 虚拟服务可以根据标头值将请求路由到不同的服务版本。这使您可以将特定租户的流量引导至正在测试的服务版本，同时将所有其他流量发送至基准服务。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“1270”高度=“1066” src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.08-PM.jpg&#34; alt=&#34;代码 - Istio VirtualService&#34; class=&#34;wp-image-149201&#34; srcset =“https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.08-PM.jpg 1270w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.08-PM-300x252.jpg 300w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.08-PM-1024x860.jpg 1024w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.08-PM-768x645.jpg 768w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.08-PM-900x755.jpg 900w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.08-PM-238x200.jpg 238w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.09.08-PM-477x400.jpg 477w“尺寸=”自动，（最大宽度：1270px）100vw，1270px“ referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;服务子集的目标规则：&lt;/strong&gt; Istio 目标规则定义不同版本的服务（基准与测试中）及其负载平衡策略：&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“1270”高度=“764” src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.11.08-PM.jpg&#34; alt=&#34;代码 - 目标规则&#34; class=&#34;wp-image-149203&#34; srcset =“https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.11.08-PM.jpg 1270w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.11.08-PM-300x180.jpg 300w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.11.08-PM-1024x616.jpg 1024w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.11.08-PM-768x462.jpg 768w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.11.08-PM-900x541.jpg 900w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.11.08-PM-332x200.jpg 332w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-08-at-1.11.08-PM-665x400.jpg 665w“尺寸=”自动，（最大宽度：1270px）100vw，1270px“referrerpolicy=”无-re费雷尔&#34;&gt;&lt;/图&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Istio 集成的主要优势：&lt;/strong&gt;无需更改应用程序代码即可实现透明路由、复杂的流量整形功能（加权路由、故障注入、超时）以及通过内置指标和跟踪集成实现路由决策的全面可观察性。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;实施注意事项&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;虽然这种方法具有显着的优势，但成功实施有几个重要的考虑因素：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;非请求范围的工作流：&lt;/strong&gt;某些异步工作流不是由外部请求触发的 - 批处理作业、计划任务或从数据库更改或基于时间的触发器开始的事件驱动流程。这些场景需要替代方法，例如在数据源中嵌入租户上下文或针对测试场景使用单独的调度机制。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;分布式缓存管理：&lt;/strong&gt;当服务缓存租户映射以提高性能时，缓存失效变得至关重要。实施适当的缓存一致性机制（例如 Redis 发布/订阅通知或短 TTL 值）可确保服务快速识别新租户或映射更改。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;消费者组生命周期：&lt;/strong&gt;消息队列消费者组需要仔细的生命周期管理。为测试服务创建唯一的消费者组名称，确保正确的偏移量处理（通常从基线消费者的当前偏移量开始），并在测试完成时清理消费者组以避免资源泄漏。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;数据隔离策略：&lt;/strong&gt;根据您的使用案例，可能需要不同级别的数据隔离。选项包括数据库中的租户前缀密钥、单独的数据库架构或精心设计的不与基线数据冲突的测试数据。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;可观察性和调试&lt;/strong&gt;：围绕租户路由决策实施全面的日志记录和指标。 OpenTelemetry 的分布式跟踪有助于跟踪租户上下文如何流经系统并确定路由决策的位置。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;安全注意事项&lt;/strong&gt;：确保租户 ID 不会被未经授权的行为者欺骗或操纵。考虑使用签名令牌或根据授权测试场景验证租户上下文，以防止意外或恶意的跨租户访问。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;结论&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在云原生应用程序中测试异步工作流程带来了传统测试方法难以经济有效地解决的独特挑战。用于上下文传播的 OpenTelemetry 和用于流量路由的 Istio 相结合，为实现请求级隔离提供了强大的基础，从而显着降低基础设施成本，同时保持高质量的测试实践。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;OpenTelemetry 和 Istio 的供应商中立性质使得该解决方案具有广泛的适用性跨不同的云提供商、消息系统和应用程序架构。这种方法的成功需要对边缘情况进行仔细规划，例如批处理工作流程和共享资源的适当生命周期管理，但它的好处——降低成本、更快的反馈循环和消除环境漂移——使其成为认真考虑在云原生环境中扩展测试实践的团队的一个令人信服的选择。&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Wed, 08 Oct 2025 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【A TPM-based combined remote attestation method for confidential computing】一种基于TPM的机密计算组合远程认证方法</title>
      <link>https://www.cncf.io/blog/2025/10/08/a-tpm-based-combined-remote-attestation-method-for-confidential-computing/</link>
      <description>【&lt;h3 class=&#34;wp-block-heading&#34;&gt;Problem statement&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Confidential computing technologies such as Intel TDX and AMD SNP rely on hardware-controlled Roots of Trust (RoT), inherently binding remote attestation to specific CPU vendors. While these solutions offer strong security guarantees, they also introduce challenges for enterprises seeking compliance, transparency, and independence in managing their Trusted Execution Environments (TEEs). This raises key questions:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;How can organizations leverage TEE security features (e.g., memory encryption, attestation) without being fully dependent on vendor-controlled RoT?&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Is it possible to partially decouple the RoT while maintaining robust security guarantees?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Scenario&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Consider a large enterprise deploying Intel TDX or AMD SNP servers, but with a requirement that the Root of Trust (RoT) be shared with a third-party authority—such as an internal certificate authority (CA) or an industry-wide trust anchor—to enable independent verification and operational flexibility. The goal is to retain the security benefits of TEEs while mitigating vendor lock-in.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Representative existing approaches&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;1.&lt;a href=&#34;https://www.usenix.org/conference/atc22/presentation/jia-yuekai&#34;&gt;&lt;strong&gt; HyperEnclave&lt;/strong&gt;&lt;/a&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;em&gt;Strengths:&lt;/em&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Fully vendor-agnostic and open-source.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Utilizes TPM for attestation, minimizing reliance on CPU vendors.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;em&gt;Considerations:&lt;/em&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Adopts an SGX-like, process-based isolation model, which, as of the time of this blog, may present compatibility challenges for integration with TDX/SNP ecosystems. (It is possible that HyperEnclave may support TDX in the future or may already have added support since the time of writing.)&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;May require additional adaptation efforts for existing TEE workloads to leverage its architecture.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;2.&lt;a href=&#34;https://learn.microsoft.com/en-us/azure/confidential-computing/how-to-leverage-virtual-tpms-in-azure-confidential-vms&#34;&gt;&lt;strong&gt; Azure vTPM&lt;/strong&gt;&lt;/a&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;em&gt;Strengths:&lt;/em&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Facilitates partial decoupling of attestation through virtual TPMs in confidential VMs.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Seamlessly integrates with mainstream confidential computing (CoCo) platforms.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;em&gt;Considerations:&lt;/em&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Relies on Azure’s proprietary hypervisor and vTPM implementation, which may affect transparency and portability across different environments.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Our solution: Hybrid attestation with TPM and TEE integration&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;We propose a unified attestation framework that combines TEE-native reports (e.g., TDX/SNP attestation) with TPM-based quotes, enabling a shared RoT between hardware and third-party authorities.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1318&#34; height=&#34;878&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-8.59.09-AM.jpg&#34; alt=&#34;unified attestation framework&#34; class=&#34;wp-image-148995&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-8.59.09-AM.jpg 1318w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-8.59.09-AM-300x200.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-8.59.09-AM-1024x682.jpg 1024w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-8.59.09-AM-768x512.jpg 768w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-8.59.09-AM-900x600.jpg 900w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-8.59.09-AM-600x400.jpg 600w&#34; sizes=&#34;auto, (max-width: 1318px) 100vw, 1318px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This solution presents a hybrid root-of-trust attestation framework for confidential computing environments, integrating both hardware-based Trusted Execution Environments (TEEs) and Trusted Platform Modules (TPMs), while supporting flexible certificate authority (CA) management.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Workflow overview&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;1. Deployment (registration) phase&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;The physical TPM generates an Attestation Identity Key (AIK), which is securely stored within the TPM.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;The AIK private key remains protected and cannot be extracted from the TPM; only the public key is exported.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;The AIK public key is submitted to a Privacy CA, which issues an AIK certificate, establishing a trust anchor for subsequent attestations.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;2. Runtime phase&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Each time a new Confidential VM (CVM) is launched, the vTPM instance running within the Secure Virtual Machine Monitor (SVSM) requests a certificate for its virtual AIK (vAIK) via a custom hypercall provided by the KVM hypervisor. This request is forwarded to the physical TPM, which collaborates with the Privacy CA to issue the vAIK certificate.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;The vTPM is responsible for trusted boot and integrity measurement of the CVM.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Applications running inside the CVM obtain the vTPM Attestation Report through the/dev/tpm-guestinterface provided by the guest kernel.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;The guest kernel requests the vTPM to generate and return a vTPM Attestation Report for the CVM. This report is signed by the vAIK, providing cryptographic assurance of its origin and integrity.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;vTPM Integration:&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;The virtual TPMs (vTPMs) run inside secure partitions:&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;em&gt;AMD SNP&lt;/em&gt;: Utilizes VMPL0 (highest privilege level) for isolation.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;em&gt;Intel TDX&lt;/em&gt;: Leverages TD partitions for secure execution.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;3. Verification phase&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;The verifier checks the certificate chain: CA certificate → AIK certificate → vAIK certificate → vTPM Attestation Report.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;If the vTPM Attestation Report is valid and correctly signed, the verifier extracts the measurement values contained within the report.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;These measurements are compared against baseline images to confirm the integrity and expected state of the software environment.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;4. Combined attestation approach&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;TPM-based attestation and TEE-native attestation coexist within the architecture and do not conflict with each other.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;This joint attestation mechanism allows both TPM and TEE evidence to be collected, verified, and combined, providing enhanced security guarantees for both the hardware and software layers.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;The combined attestation report offers a comprehensive trust foundation, leveraging the strengths of both TPM and TEE technologies.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The architecture supports aggregation of TEE and TPM attestation evidence into a combined attestation report, providing comprehensive trust guarantees for both hardware and software integrity. This hybrid approach enables enterprises to flexibly manage root-of-trust anchors, enhance transparency, and support independent verification by trusted third-party CAs.In addition, our solution offers significant cost advantages. The TPM hardware modules required are highly standardized, modular, and inexpensive, making our architecture both practical and economical for large-scale deployment.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Implementation with Hygon CSV&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1390&#34; height=&#34;720&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-9.01.45-AM.jpg&#34; alt=&#34;Implementation with Hygon CSV&#34; class=&#34;wp-image-148997&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-9.01.45-AM.jpg 1390w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-9.01.45-AM-300x155.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-9.01.45-AM-1024x530.jpg 1024w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-9.01.45-AM-768x398.jpg 768w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-9.01.45-AM-900x466.jpg 900w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-9.01.45-AM-386x200.jpg 386w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-9.01.45-AM-772x400.jpg 772w&#34; sizes=&#34;auto, (max-width: 1390px) 100vw, 1390px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The current solution has been successfully developed and deployed in production on the Hygon CSV platform, where the first version is already supporting real-world applications. This implementation is based on the CoCo/trustee remote attestation framework, which provides the foundation for secure attestation and trust management. In addition, development efforts are underway to extend support to AMD SNP and Intel TDX platforms, further enhancing the versatility and coverage of this hybrid attestation architecture.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;Advantages of the combined approach&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;Vendor neutrality:&lt;/strong&gt; RoT is shared between TEE hardware and a third-party TPM, reducing vendor lock-in.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Customizable trust architecture: &lt;/strong&gt;Provides organizations with the ability to define and manage their own TEE trust anchors and attestation mechanisms.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Flexibility &amp;amp; scalability:&lt;/strong&gt;The architecture is highly flexible and easily extensible, supporting integration with multiple hardware platforms and evolving security needs.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Cost-effectiveness &amp;amp; large-scale deployment:&lt;/strong&gt;By leveraging standardized and modular TPM hardware, the solution is low-cost and well-suited for economical, large-scale deployments.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;h3 class=&#34;wp-block-heading&#34;&gt;问题陈述&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Intel TDX 和 AMD SNP 等机密计算技术依赖于硬件控制的信任根 (RoT)，本质上将远程认证绑定到特定的 CPU 供应商。虽然这些解决方案提供了强大的安全保证，但它们也给在管理可信执行环境 (TEE) 方面寻求合规性、透明度和独立性的企业带来了挑战。这就提出了关键问题：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;组织如何在不完全依赖供应商控制的 RoT 的情况下利用 TEE 安全功能（例如内存加密、证明）？&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;是否可以部分解耦 RoT，同时保持强大的安全保证？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;场景&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;假设一家大型企业部署了 Intel TDX 或 AMD SNP 服务器，但要求与第三方机构（例如内部证书颁发机构 (CA) 或行业范围的信任锚）共享信任根 (RoT)，以实现独立验证和操作灵活性。目标是保留 TEE 的安全优势，同时减少供应商锁定。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;代表性的现有方法&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;1.&lt;a href=&#34;https://www.usenix.org/conference/atc22/presentation/jia-yuekai&#34;&gt;&lt;strong&gt;超飞地&lt;/strong&gt;&lt;/a&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;em&gt;优势：&lt;/em&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;完全与供应商无关且开源。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;利用 TPM 进行证明，最大限度地减少对 CPU 供应商的依赖。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;em&gt;注意事项：&lt;/em&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;采用类似 SGX、基于流程的隔离模型，截至本博客发表时，该模型可能会对与 TDX/SNP 生态系统的集成带来兼容性挑战。 （HyperEnclave 将来可能支持 TDX，或者自撰写本文以来可能已经添加了支持。）&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;可能需要对现有 TEE 工作负载进行额外的调整才能利用其架构。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;2.&lt;a href=&#34;https://learn.microsoft.com/en-us/azure/confidential-computing/how-to-leverage-virtual-tpms-in-azure-confidential-vms&#34;&gt;&lt;strong&gt;Azure vTPM&lt;/strong&gt;&lt;/a&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;em&gt;优势：&lt;/em&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;通过机密虚拟机中的虚拟 TPM 促进证明的部分解耦。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;与主流机密计算 (CoCo) 平台无缝集成。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;em&gt;注意事项：&lt;/em&gt;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;依赖 Azure 专有的虚拟机管理程序和 vTPM 实施，这可能会影响不同环境之间的透明度和可移植性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;我们的解决方案：TPM 和 TEE 集成的混合证明&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我们提出统一认证该框架将 TEE 原生报告（例如 TDX/SNP 证明）与基于 TPM 的报价相结合，从而在硬件和第三方权威机构之间实现共享 RoT。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“1318”高度=“878” src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-8.59.09-AM.jpg&#34; alt=&#34;统一认证框架&#34; class=&#34;wp-image-148995&#34; srcset =“https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-8.59.09-AM.jpg 1318w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-8.59.09-AM-300x200.jpg 300w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-8.59.09-AM-1024x682.jpg 1024w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-8.59.09-AM-768x512.jpg 768w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-8.59.09-AM-900x600.jpg 900w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-8.59.09-AM-600x400.jpg 600w“尺寸=”自动，（最大宽度：1318px）100vw，1318px“ referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;该解决方案为机密计算环境提供了混合信任根证明框架，集成了基于硬件的可信执行环境 (TEE) 和可信平台模块 (TPM)，同时支持灵活的证书颁发机构 (CA) 管理。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;工作流程概述&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;1.部署（注册）阶段&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;物理 TPM 生成证明身份密钥 (AIK)，该密钥安全地存储在 TPM 中。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;AIK 私钥仍然受到保护，无法从 TPM 中提取；仅导出公钥。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;AIK 公钥被提交给隐私 CA，该 CA 会颁发 AIK 证书，为后续证明建立信任锚。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;2.运行时阶段&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;每次启动新的机密虚拟机 (CVM) 时，安全虚拟机监视器 (SVSM) 中运行的 vTPM 实例都会通过 KVM 虚拟机管理程序提供的自定义超级调用为其虚拟 AIK (vAIK) 请求证书。该请求将转发到物理 TPM，该 TPM 与隐私 CA 合作颁发 vAIK 证书。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;vTPM 负责 CVM 的可信启动和完整性测量。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;CVM 内运行的应用程序通过来宾内核提供的 /dev/tpm-guest 接口获取 vTPM 证明报告。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;来宾内核请求 vTPM 生成并返回 CVM 的 vTPM 证明报告。该报告由 vAIK 签署，提供其来源和完整性的加密保证。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;vTPM 集成：&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;虚拟 TPM (vTPM) 在安全分区内运行：&#xA;&lt;ul 类s=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;em&gt;AMD SNP&lt;/em&gt;：利用 VMPL0（最高权限级别）进行隔离。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;em&gt;Intel TDX&lt;/em&gt;：利用 TD 分区实现安全执行。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;3.验证阶段&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;验证者检查证书链：CA 证书 → AIK 证书 → vAIK 证书 → vTPM 证明报告。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;如果 vTPM 证明报告有效且签名正确，验证者将提取报告中包含的测量值。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;将这些测量结果与基线图像进行比较，以确认软件环境的完整性和预期状态。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h4 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;4。组合证明方法&lt;/strong&gt;&lt;/h4&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;基于 TPM 的证明和 TEE 原生证明在架构中共存，并且不会相互冲突。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;这种联合证明机制可以收集、验证和组合 TPM 和 TEE 证据，为硬件和软件层提供增强的安全保证。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;综合认证报告利用 TPM 和 TEE 技术的优势，提供全面的信任基础。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;该架构支持将 TEE 和 TPM 证明证据聚合为组合证明报告，为硬件和软件完整性提供全面的信任保证。这种混合方法使企业能够灵活管理信任根锚点、增强透明度并支持受信任的第三方 CA 进行独立验证。此外，我们的解决方案还具有显着的成本优势。所需的TPM硬件模块高度标准化、模块化且价格低廉，使得我们的架构对于大规模部署来说既实用又经济。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;使用 Hygon CSV 实施&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt;&lt;img加载=“lazy”解码=“异步”宽度=“1390”高度=“720” src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-9.01.45-AM.jpg&#34; alt=&#34;使用 Hygon CSV 实现&#34; class=&#34;wp-image-148997&#34; srcset =“https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-9.01.45-AM.jpg 1390w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-9.01.45-AM-300x155.jpg 300w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-9.01.45-AM-1024x530.jpg 1024w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-9.01.45-AM-768x398.jpg 768w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-9.01.45-AM-900x466.jpg 900w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-9.01.45-AM-386x200.jpg 386w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-9.01.45-AM-772x400.jpg 772w“尺寸=”自动，（最大-width: 1390px) 100vw, 1390px&#34;referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;当前的解决方案已在 Hygon CSV 平台上成功开发并部署在生产中，其中第一个版本已经支持实际应用程序。该实现基于CoCo/受托人远程证明框架，该框架为安全证明和信任管理提供了基础。此外，我们正在努力扩展对 AMD SNP 和 Intel TDX 平台的支持，进一步增强这种混合认证架构的多功能性和覆盖范围。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;组合方法的优点&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;供应商中立性&lt;/strong&gt;：RoT 在 TEE 硬件和第三方 TPM 之间共享，从而减少供应商锁定。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;可定制的信任架构：&lt;/strong&gt;使组织能够定义和管理自己的 TEE 信任锚和证明机制。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;灵活性和可扩展性：&lt;/strong&gt;该架构高度灵活且易于扩展，支持与多个硬件平台集成并满足不断变化的安全需求。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;成本效益和大规模部署：&lt;/strong&gt;通过利用标准化和模块化 TPM 硬件，该解决方案成本低廉，非常适合经济的大规模部署。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Tue, 07 Oct 2025 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Auditing user activity in pods and nodes with the Security-Profiles-Operator】使用 Security-Profiles-Operator 审核 pod 和节点中的用户活动</title>
      <link>https://www.cncf.io/blog/2025/10/07/auditing-user-activity-in-pods-and-nodes-with-the-security-profiles-operator/</link>
      <description>【&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/tasks/debug/debug-cluster/audit/&#34;&gt;Kubernetes’ native audit logs&lt;/a&gt; are essential for tracking control plane activities, but they fail to capture what happens &lt;em&gt;inside&lt;/em&gt; a container or on the host node itself during kubectl debugging sessions. This creates a security and compliance gap, as malicious or unauthorized actions within a pod or on the node go unrecorded. Without this visibility, it’s impossible to fully understand user actions, conduct an incident investigation, or meet regulatory compliance requirements. The newly added audit logging feature in &lt;strong&gt;Security-Profiles-Operator (SPO)&lt;/strong&gt; addresses this by enabling detailed, server-side logging of user activity at the node level.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Let’s imagine a scenario: A team of engineers is responsible for maintaining an application that processes financial transactions. The application is deployed on Kubernetes, with various containers (in pods) running different workloads. When a customer reports a bug, an engineer is granted access to the pod via &lt;strong&gt;kubectl exec&lt;/strong&gt; to debug the issue (also kubectl debug node). However, during the session, they accidentally delete/modify a crucial configuration file. The application fails, leading to financial losses and business disruption.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;During a post-incident audit, the security team can see from the Kubernetes control plane logs that the engineer initiated a kubectl exec session. But the logs don’t reveal &lt;em&gt;what&lt;/em&gt; commands were run inside the container. It’s an operational black box. The engineer could have accidentally deleted the file, or a malicious actor could have used their credentials to intentionally cause harm. Since client-side logging can be easily manipulated or faked, it’s not a reliable solution. This is where the audit logging feature of SPO comes in. It provides the crucial, unalterable record of actions taken inside the container, closing this critical security gap.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Other scenarios include tracking the syscalls made by the containers themselves, the processes/executables invoked by container images when deployed on kubernetes.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;How the audit logging feature in SPO works&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The&lt;a href=&#34;https://github.com/kubernetes-sigs/security-profiles-operator&#34;&gt; Security-Profiles-Operator (SPO)&lt;/a&gt; provides a new&lt;a href=&#34;https://github.com/kubernetes-sigs/security-profiles-operator/blob/main/installation-usage.md#audit-json-log-enricher&#34;&gt; JSON audit logging feature&lt;/a&gt; that generates detailed, structured logs of user activity. Similar to how Kubernetes records its own API server audit logs, this feature generates logs in a JSON Lines format, making them easy to parse and analyze. This process provides a powerful, server-side solution for granularly logging user activity, effectively closing the node-level security gap.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1326&#34; height=&#34;860&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-10.18.59-AM.jpg&#34; alt=&#34;closing the node-level security gap&#34; class=&#34;wp-image-149026&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-10.18.59-AM.jpg 1326w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-10.18.59-AM-300x195.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-10.18.59-AM-1024x664.jpg 1024w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-10.18.59-AM-768x498.jpg 768w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-10.18.59-AM-900x584.jpg 900w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-10.18.59-AM-308x200.jpg 308w, https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-10.18.59-AM-617x400.jpg 617w&#34; sizes=&#34;auto, (max-width: 1326px) 100vw, 1326px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;SPO enables easier distribution of seccomp profiles to the Kubernetes nodes. Here the main source of information is the audit log generated by configuring seccomp profiles to log (not restrict) process creations. When an auditor configures both Kubernetes control plane and SPO audit logging, the &lt;strong&gt;json-audit-log enricher&lt;/strong&gt; container starts within the SPO DaemonSet. This container watches for logs in the host’s audit log (/var/log/audit/audit.log). For each log statement, it fetches command-line/environment information from /proc/&amp;lt;pid&amp;gt; and, optionally, from eBPF. It then filters the log based on your configuration and sends the output to either a file or standard output.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;By default, &lt;strong&gt;kubectl exec&lt;/strong&gt; doesn’t pass user authentication (user) details into the exec session on the container, making it hard to audit user-specific actions. The audit logger in SPO addresses this with &lt;strong&gt;mutating webhooks&lt;/strong&gt; that inject the &lt;strong&gt;request UID&lt;/strong&gt; from the Kubernetes API server as an environment variable into the session. Every request to the API server including the request to start a new exec session contains a request UID. This request ID is then logged by SPO’s audit log enricher and can be used to correlate the activity with the API server’s audit logs (&lt;a href=&#34;https://kubernetes.io/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event&#34;&gt;annotations&lt;/a&gt;), providing a complete trail of who did what.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This feature introduces&lt;a href=&#34;https://github.com/kubernetes-sigs/security-profiles-operator/blob/main/installation-usage.md#filtering-logs&#34;&gt; &lt;strong&gt;advanced log filtering&lt;/strong&gt;&lt;/a&gt; through an array of filter rules. These rules, defined on the SPOD resource, allow users to control which log statements are emitted (“Metadata”) and which are dropped (“None”). Rules are evaluated in ascending order of their &lt;strong&gt;priority&lt;/strong&gt;, and the first matching rule determines the action. A rule is a match if all specified &lt;strong&gt;matchKeys&lt;/strong&gt; are present in the log statement. If &lt;strong&gt;matchValues&lt;/strong&gt; are also provided, at least one of the values must match. This system provides granular control, ensuring only relevant security events are logged, and a default behavior of logging is applied if no rules match. When auditing user actions, the filters are configured to log only those that contain the requested UID.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Each log line includes critical information about an event: Timestamp, Executable Name, Command Line Arguments, User and Group IDs, and System Calls (syscalls). This granular logging is particularly useful for:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Seeing what users and automated processes are doing inside a pod.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Tracking when someone uses commands like kubectl exec to run commands or scripts within a container.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Monitoring activities in debug containers where users might run various tools.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;How to enable it&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;To enable this auditing with SPO, you first install &lt;strong&gt;cert-manager &lt;/strong&gt;(optional in some environments) and the &lt;strong&gt;SPO&lt;/strong&gt; itself. Next, you configure the operator to store its logs locally on the host, external volume or output to standard output. You then enable the &lt;strong&gt;JSON Enricher&lt;/strong&gt; and specify a set of filters to only log user activity. Finally, you create a &lt;strong&gt;SeccompProfile&lt;/strong&gt; to log specific syscalls like execve and clone, and a &lt;strong&gt;ProfileBinding&lt;/strong&gt; to automatically apply this profile to pods in a target namespace.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Detailed instructions are available in the&lt;a href=&#34;https://github.com/kubernetes-sigs/security-profiles-operator/blob/main/doc/audit-logging-guide.md&#34;&gt; user guide&lt;/a&gt; and the&lt;a href=&#34;https://github.com/kubernetes-sigs/security-profiles-operator/blob/main/installation-usage.md&#34;&gt; documentation&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Considerations while using privileged containers&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;When using &lt;strong&gt;kubectl debug&lt;/strong&gt; for node debugging, a privileged pod may be created for host file system access, which can introduce differences in behavior based on the container runtime. For the &lt;strong&gt;CRI-O&lt;/strong&gt; runtime, a specific feature is needed to apply a seccomp profile to a privileged container.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;With CRI-O versions 1.33 and newer, a feature was introduced to “&lt;a href=&#34;https://github.com/cri-o/cri-o/pull/9190&#34;&gt;allow seccomp profiles for privileged containers&lt;/a&gt;.” This allows you to apply the secomp profile we created to the cri-o configuration. The key is to configure the CRI-O runtime to use the profile by passing an additional flag.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;To do this, you must add the flag &lt;strong&gt;–privileged-seccomp-profile &lt;/strong&gt;to the CRI-O runtime configuration. This step ensures that even privileged debugging pods are subject to the secomp profile’s logging, maintaining complete audit coverage.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Performance considerations&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;It’s important to acknowledge the performance implications of using seccomp profiles for extensive logging. The SPO is designed to minimize this impact by primarily logging only process creations and handling them asynchronously. This approach helps prevent logging from becoming a bottleneck on your nodes.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The feature uses eBPF as a supplemental data source. While it’s possible for eBPF to be used as a primary data source for this type of logging, that functionality isn’t currently a configurable feature within the operator. For most use cases, the default asynchronous, process-creation-focused logging approach provides an excellent balance between security visibility and cluster performance.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;By leveraging the &lt;strong&gt;Security-Profiles-Operator&lt;/strong&gt;, you can overcome the limitations of standard Kubernetes audit logs and gain complete visibility into user actions within your pods and on the host nodes. This solution is a powerful and necessary tool for any organization that requires comprehensive security monitoring, threat detection, and compliance for its containerized environments.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/tasks/debug/debug-cluster/audit/&#34;&gt;Kubernetes 的本机审核日志&lt;/a&gt;对于跟踪控制平面活动至关重要，但它们无法捕获 kubectl 调试会话期间容器内部或主机节点本身发生的情况。这会造成安全性和合规性差距，因为 Pod 内或节点上的恶意或未经授权的操作不会被记录。如果没有这种可见性，就不可能完全了解用户操作、进行事件调查或满足法规遵从性要求。 &lt;strong&gt;Security-Profiles-Operator (SPO)&lt;/strong&gt; 中新添加的审核日志记录功能通过在节点级别启用详细的服务器端用户活动日志记录来解决此问题。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;让我们想象一个场景：一个工程师团队负责维护一个处理金融交易的应用程序。该应用程序部署在 Kubernetes 上，各种容器（在 Pod 中）运行不同的工作负载。当客户报告错误时，工程师将被授予通过 kubectl exec 访问 pod 的权限来调试问题（也是 kubectl 调试节点）。然而，在会话期间，他们不小心删除/修改了一个关键的配置文件。应用程序失败，导致财务损失和业务中断。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在事件后审核期间，安全团队可以从 Kubernetes 控制平面日志中看到工程师启动了 kubectl exec 会话。但日志并没有透露容器内运行的命令。这是一个可操作的黑匣子。工程师可能意外删除了该文件，或者恶意行为者可能使用其凭据故意造成伤害。由于客户端日志记录很容易被操纵或伪造，因此它不是一个可靠的解决方案。这就是 SPO 的审核日志记录功能的用武之地。它提供了容器内所采取操作的关键且不可更改的记录，从而弥补了这一关键的安全漏洞。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;其他场景包括跟踪容器本身进行的系统调用、部署在 kubernetes 上时由容器映像调用的进程/可执行文件。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;SPO 中的审核日志记录功能如何工作&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes-sigs/security-profiles-operator&#34;&gt;Security-Profiles-Operator (SPO)&lt;/a&gt; 提供了新的&lt;a href=&#34;https://github.com/kubernetes-sigs/security-profiles-operator/blob/main/installation-usage.md#audit-json-log-enricher&#34;&gt; JSON 审核日志记录功能&lt;/a&gt;，可生成用户活动的详细结构化日志。与 Kubernetes 记录自己的 API 服务器审核日志的方式类似，此功能以 JSON Lines 格式生成日志，使其易于解析和分析。此过程提供了强大的服务器端解决方案，用于精细记录用户活动，有效缩小节点级安全漏洞。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; 装饰ding=&#34;async&#34; width=&#34;1326&#34; height=&#34;860&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-10.18.59-AM.jpg&#34; alt=&#34;缩小节点级安全漏洞&#34; 类=“wp-image-149026”srcset=“https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-10.18.59-AM.jpg 1326w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-10.18.59-AM-300x195.jpg 300w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-10.18.59-AM-1024x664.jpg 1024w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-10.18.59-AM-768x498.jpg 768w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-10.18.59-AM-900x584.jpg 900w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-10.18.59-AM-308x200.jpg 308w， https://www.cncf.io/wp-content/uploads/2025/10/Screenshot-2025-10-07-at-10.18.59-AM-617x400.jpg 617w“尺寸=”自动，（最大宽度：1326px）100vw，1326px“ referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;SPO 可以更轻松地将 seccomp 配置文件分发到 Kubernetes 节点。这里的主要信息来源是通过配置 seccomp 配置文件来记录（而不是限制）进程创建而生成的审核日志。当审核员配置 Kubernetes 控制平面和 SPO 审核日志记录时，&lt;strong&gt;json-audit-log richer&lt;/strong&gt; 容器会在 SPO DaemonSet 中启动。此容器监视主机审核日志 (/var/log/audit/audit.log) 中的日志。对于每个日志语句，它从 /proc/&lt;pid&gt; 以及（可选）eBPF 中获取命令行/环境信息。然后，它根据您的配置过滤日志，并将输出发送到文件或标准输出。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;默认情况下，&lt;strong&gt;kubectl exec&lt;/strong&gt; 不会将用户身份验证（用户）详细信息传递到容器上的 exec 会话中，这使得审核特定于用户的操作变得困难。 SPO 中的审核记录器通过&lt;strong&gt;变异 Webhook&lt;/strong&gt; 解决了这个问题，这些 Webhook 将来自 Kubernetes API 服务器的&lt;strong&gt;请求 UID&lt;/strong&gt; 作为环境变量注入到会话中。对 API 服务器的每个请求（包括启动新执行会话的请求）都包含一个请求 UID。然后，SPO 的审核日志丰富器会记录此请求 ID，并可用于将活动与 API 服务器的审核日志（&lt;a href=&#34;https://kubernetes.io/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event&#34;&gt;注释&lt;/a&gt;）关联起来，从而提供完整的跟踪 谁做了什么。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此功能通过一系列过滤规则引入了&lt;a href=&#34;https://github.com/kubernetes-sigs/security-profiles-operator/blob/main/installation-usage.md#filtering-logs&#34;&gt;&lt;strong&gt;高级日志过滤&lt;/strong&gt;&lt;/a&gt;。这些在 SPOD 资源上定义的规则允许用户控制发出哪些日志语句（“元数据”）和删除哪些日志语句（“无”）。规则按其&lt;strong&gt;优先级&lt;/strong&gt;的升序进行评估，第一个匹配的规则确定是行动。如果日志语句中存在所有指定的 &lt;strong&gt;ma​​tchKey&lt;/strong&gt;，则规则是匹配的。如果还提供了 &lt;strong&gt;ma​​tchValues&lt;/strong&gt;，则至少有一个值必须匹配。该系统提供精细控制，确保仅记录相关的安全事件，并且如果没有规则匹配，则应用默认的日志记录行为。审核用户操作时，过滤器配置为仅记录包含所请求的 UID 的操作。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;每个日志行都包含有关事件的关键信息：时间戳、可执行文件名称、命令行参数、用户和组 ID 以及系统调用 (syscall)。这种精细的日志记录对于以下方面特别有用：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;查看用户和自动化流程在 Pod 内执行的操作。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;跟踪某人何时使用 kubectl exec 等命令在容器内运行命令或脚本。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;监控调试容器中用户可能运行各种工具的活动。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;如何启用&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;要使用 SPO 启用此审核，您首先要安装 &lt;strong&gt;cert-manager &lt;/strong&gt;（在某些环境中可选）和 &lt;strong&gt;SPO&lt;/strong&gt; 本身。接下来，您将操作员配置为将其日志本地存储在主机、外部卷或输出到标准输出上。然后，您启用 &lt;strong&gt;JSON Enricher&lt;/strong&gt; 并指定一组过滤器以仅记录用户活动。最后，您创建一个 &lt;strong&gt;SeccompProfile&lt;/strong&gt; 来记录特定的系统调用（例如 execve 和 clone），并创建一个 &lt;strong&gt;ProfileBinding&lt;/strong&gt; 来自动将此配置文件应用到目标命名空间中的 pod。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;详细说明请参阅&lt;a href=&#34;https://github.com/kubernetes-sigs/security-profiles-operator/blob/main/doc/audit-logging-guide.md&#34;&gt;用户指南&lt;/a&gt;和&lt;a href=&#34;https://github.com/kubernetes-sigs/security-profiles-operator/blob/main/installation-usage.md&#34;&gt;文档&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;使用特权容器时的注意事项&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;使用&lt;strong&gt;kubectl debug&lt;/strong&gt;进行节点调试时，可能会创建一个特权 Pod 来访问主机文件系统，这可能会根据容器运行时引入行为差异。对于 &lt;strong&gt;CRI-O&lt;/strong&gt; 运行时，需要特定功能才能将 seccomp 配置文件应用到特权容器。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在 CRI-O 1.33 及更高版本中，引入了一项功能“&lt;a href=&#34;https://github.com/cri-o/cri-o/pull/9190&#34;&gt;允许特权容器使用 seccomp 配置文件&lt;/a&gt;”。这允许您将我们创建的 secomp 配置文件应用到 cri-o 配置。关键是通过传递附加标志来配置 CRI-O 运行时以使用配置文件。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;为此，您必须将标志&lt;strong&gt;–privileged-seccomp-profile &lt;/strong&gt;添加到 CRI-O 运行时配置中。此步骤确保即使是特权调试 Pod 也受到 secomp 配置文件的日志记录的约束，main获得完整的审计覆盖范围。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;性能注意事项&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;认识到使用 seccomp 配置文件进行大量日志记录的性能影响非常重要。 SPO 旨在通过主要仅记录流程创建并异步处理它们来最大程度地减少这种影响。这种方法有助于防止日志记录成为节点上的瓶颈。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;该功能使用 eBPF 作为补充数据源。虽然 eBPF 可以用作此类日志记录的主要数据源，但该功能目前不是操作员内的可配置功能。对于大多数用例，默认的异步、以流程创建为中心的日志记录方法在安全可见性和集群性能之间提供了良好的平衡。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;通过利用&lt;strong&gt;Security-Profiles-Operator&lt;/strong&gt;，您可以克服标准 Kubernetes 审核日志的限制，并全面了解 Pod 内和主机节点上的用户操作。对于任何需要对其容器化环境进行全面安全监控、威胁检测和合规性的组织来说，该解决方案都是一个强大且必要的工具。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Mon, 06 Oct 2025 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Managing Kubernetes Workloads Using the App of Apps Pattern in ArgoCD-2】使用 ArgoCD-2 中的 App of Apps 模式管理 Kubernetes 工作负载</title>
      <link>https://www.cncf.io/blog/2025/10/07/managing-kubernetes-workloads-using-the-app-of-apps-pattern-in-argocd-2/</link>
      <description>【&lt;p&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Managing a cloud native infrastructure at scale is no longer just about deploying single applications – it’s about organizing environments, defining clear boundaries and keeping everything version-controlled, consistent, automated and easily managed within a simple and clear lifecycle process. This is where GitOps practices – tools like&amp;nbsp;&lt;strong&gt;ArgoCD –&lt;/strong&gt;&amp;nbsp;truly shine.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;One of ArgoCD’s most powerful patterns is called&amp;nbsp;&lt;strong&gt;App of Apps&lt;/strong&gt;&amp;nbsp;– a design where a&amp;nbsp;&lt;em&gt;single parent ArgoCD Application&lt;/em&gt;&amp;nbsp;manages and deploys multiple&amp;nbsp;&lt;em&gt;child ArgoCD Applications&lt;/em&gt;. It brings order to potentially chaotic deployments, improves observability and aligns perfectly with GitOps methodologies.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In this article, we’ll explore the&amp;nbsp;&lt;strong&gt;App of Apps&lt;/strong&gt;&amp;nbsp;pattern in ArgoCD, including its concept, structure, pros and cons, as well as a production-grade way to configure child applications via dedicated&amp;nbsp;&lt;strong&gt;values files&lt;/strong&gt;. You’ll learn how to build a reusable, scalable pattern by deploying two example applications:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;NGINX Ingress Controller&lt;/strong&gt;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Cert-Manager&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Let’s dive in.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What Is the App of Apps Pattern in ArgoCD?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;span style=&#34;text-decoration: underline;&#34;&gt;Concept&lt;/span&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The&amp;nbsp;&lt;strong&gt;App of Apps&lt;/strong&gt;&amp;nbsp;pattern is an ArgoCD deployment strategy where one central ArgoCD&amp;nbsp;Application&amp;nbsp;(the “parent”) is responsible for managing and deploying several other&amp;nbsp;Applications&amp;nbsp;(the “children”). Each child application corresponds to a logical unit (e.g., a microservice, controller, or platform component) and is fully managed by ArgoCD.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This enables a modular, hierarchical structure – especially useful in environments where infrastructure is composed of many separate but related components.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;647&#34; height=&#34;412&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2-3.jpg&#34; alt=&#34;Hierarchical applications graphic&#34; class=&#34;wp-image-149098&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2-3.jpg 647w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-3-300x191.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-3-314x200.jpg 314w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-3-628x400.jpg 628w&#34; sizes=&#34;auto, (max-width: 647px) 100vw, 647px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Real-World Analogy&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Think of the parent app as a&amp;nbsp;&lt;strong&gt;conductor of an orchestra&lt;/strong&gt;. Each instrument (child app) has its own sheet music (Helm chart or manifest) but plays in harmony through coordination by the conductor.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-table&#34;&gt;&lt;table class=&#34;has-fixed-layout&#34;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;Environment&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;Suitability&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Development&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;✅ Great for modular test setups&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Staging/UAT&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;✅ Ideal for environment replication and control&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Production&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;✅ Yes — with clearly defined sync policies, health checks and RBAC&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Benefits&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;✅&amp;nbsp;&lt;strong&gt;Modular Management&lt;/strong&gt;: Each application is independently versioned and controlled.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;✅&amp;nbsp;&lt;strong&gt;Reusability&lt;/strong&gt;: Easily clone environments by reapplying the App of Apps.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;✅&amp;nbsp;&lt;strong&gt;Central Visibility&lt;/strong&gt;: One view to manage all applications.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;✅&amp;nbsp;&lt;strong&gt;GitOps-Driven&lt;/strong&gt;: Every change is tracked via Git, allowing for auditability and rollback.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Drawbacks&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;⚠️&amp;nbsp;&lt;strong&gt;Complexity Overhead&lt;/strong&gt;: Initial learning curve and additional manifests.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;⚠️&amp;nbsp;&lt;strong&gt;Drift Risks&lt;/strong&gt;: Improper sync policies may result in applications going out of sync.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;⚠️&amp;nbsp;&lt;strong&gt;Too Many Levels&lt;/strong&gt;: Avoid deeply nested Apps of Apps, which can lead to confusion and debugging difficulty.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Prerequisites&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Before proceeding, ensure you have the following:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;A running Kubernetes cluster.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;ArgoCD installed and configured in your cluster.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;kubectl&amp;nbsp;and&amp;nbsp;helm&amp;nbsp;installed on your local machine.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;A Git repository to store your ArgoCD application manifests.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 1: Create Directory Structure&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Let’s build a structure where we have a main app of apps YAML definition. I store it only as a reference as I will create that main app manually in ArgoCD. Each child application uses a dedicated Helm Chart with&amp;nbsp;values.yaml&amp;nbsp;file for configuration. Apps folder will keep all my applications defined as separate applications in ArgoCD. For reference you can refer to my repository URL:&amp;nbsp;&lt;a href=&#34;https://github.com/mariano-italiano/argocd-apps.git&#34;&gt;https://github.com/mariano-italiano/argocd-apps.git&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1526&#34; height=&#34;816&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-3-2.jpg&#34; alt=&#34;Indented code example&#34; class=&#34;wp-image-149092&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-3-2.jpg 1526w, https://www.cncf.io/wp-content/uploads/2025/10/image-3-2-300x160.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/image-3-2-1024x548.jpg 1024w, https://www.cncf.io/wp-content/uploads/2025/10/image-3-2-768x411.jpg 768w, https://www.cncf.io/wp-content/uploads/2025/10/image-3-2-900x481.jpg 900w, https://www.cncf.io/wp-content/uploads/2025/10/image-3-2-374x200.jpg 374w, https://www.cncf.io/wp-content/uploads/2025/10/image-3-2-748x400.jpg 748w&#34; sizes=&#34;auto, (max-width: 1526px) 100vw, 1526px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 2: Define Child Applications&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Once you have created the structure,&amp;nbsp; you need to create the manifests for the child applications. Each&amp;nbsp;Application&amp;nbsp;points to the Helm chart in our Git repo. In my case, as mentioned above, I will create NGINX Ingress as well as Cert-Manager applications. Here you have both files:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;apiVersion: argoproj.io/v1alpha1&#xA;kind: Application&#xA;metadata:&#xA;&amp;nbsp;&amp;nbsp;name: nginx-ingress&#xA;&amp;nbsp;&amp;nbsp;namespace: argocd&#xA;spec:&#xA;&amp;nbsp;&amp;nbsp;project: default&#xA;&amp;nbsp;&amp;nbsp;source:&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;repoURL: https://github.com/mariano-italiano/argocd-apps&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;targetRevision: HEAD&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;path: charts/nginx-ingress&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;helm:&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;valueFiles:&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- values.yaml&#xA;&amp;nbsp;&amp;nbsp;destination:&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;server: https://kubernetes.default.svc&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;namespace: ingress-nginx&#xA;&amp;nbsp;&amp;nbsp;syncPolicy:&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;automated:&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;prune: true&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;selfHeal: true&#xA;apiVersion: argoproj.io/v1alpha1&#xA;kind: Application&#xA;metadata:&#xA;&amp;nbsp;&amp;nbsp;name: cert-manager&#xA;&amp;nbsp;&amp;nbsp;namespace: argocd&#xA;spec:&#xA;&amp;nbsp;&amp;nbsp;project: default&#xA;&amp;nbsp;&amp;nbsp;source:&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;repoURL: https://github.com/mariano-italiano/argocd-apps&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;targetRevision: HEAD&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;path: charts/cert-manager&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;helm:&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;valueFiles:&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- values.yaml&#xA;&amp;nbsp;&amp;nbsp;destination:&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;server: https://kubernetes.default.svc&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;namespace: cert-manager&#xA;&amp;nbsp;&amp;nbsp;syncPolicy:&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;automated:&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;prune: true&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;selfHeal: true&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 3: Define the Parent App (App of Apps)&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Let’s create the main app now. Login to ArgoCD and click on the&amp;nbsp;&lt;strong&gt;Create Application&lt;/strong&gt;&amp;nbsp;button. Next, click on&amp;nbsp;&lt;strong&gt;Edit as YAML&lt;/strong&gt;&amp;nbsp;on the right hand site and paste a main app with the following content:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;apiVersion: argoproj.io/v1alpha1&#xA;kind: Application&#xA;metadata:&#xA;&amp;nbsp;&amp;nbsp;name: app-of-apps&#xA;&amp;nbsp;&amp;nbsp;namespace: argocd&#xA;spec:&#xA;&amp;nbsp;&amp;nbsp;project: default&#xA;&amp;nbsp;&amp;nbsp;source:&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;repoURL: https://github.com/mariano-italiano/argocd-apps&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;targetRevision: HEAD&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;path: apps&#xA;&amp;nbsp;&amp;nbsp;destination:&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;server: https://kubernetes.default.svc&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;namespace: argocd&#xA;&amp;nbsp;&amp;nbsp;syncPolicy:&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;automated: null&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Click&amp;nbsp;&lt;strong&gt;Save&lt;/strong&gt;&amp;nbsp;and then&amp;nbsp;&lt;strong&gt;Create&lt;/strong&gt;&amp;nbsp;on top to create the main application.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Once you have done that, you should have a similar state as the one presented in the picture below.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;300&#34; height=&#34;261&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2-4.jpg&#34; alt=&#34;App-of-Apps Graphic&#34; class=&#34;wp-image-149101&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2-4.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-4-230x200.jpg 230w&#34; sizes=&#34;auto, (max-width: 300px) 100vw, 300px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;It is ok to have “OutOfSync” status as we intentionally chosen Manual sync policy in the definition. This&amp;nbsp; is a safe option and gives you full control of everything is deployed or updated in the cluster.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Click on this item and navigate inside the apps. You will see the definitions of the two applications that are missing. This is exactly the mirror of our apps directory. Two applications that are missing from our cluster.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;415&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2-5.jpg&#34; alt=&#34;Dashboard graphic&#34; class=&#34;wp-image-149103&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2-5.jpg 1024w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-5-300x122.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-5-768x311.jpg 768w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-5-900x365.jpg 900w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-5-493x200.jpg 493w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-5-987x400.jpg 987w&#34; sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Click&amp;nbsp;&lt;strong&gt;Sync&amp;nbsp;&lt;/strong&gt;button and then select all out-of-sync applications and finally click&amp;nbsp;&lt;strong&gt;Synchronize&lt;/strong&gt;.&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;390&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2-6.jpg&#34; alt=&#34;Dashboard graphic after clicking Synchronize&#34; class=&#34;wp-image-149105&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2-6.jpg 1024w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-6-300x114.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-6-768x293.jpg 768w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-6-900x343.jpg 900w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-6-525x200.jpg 525w&#34; sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The missing applications should start a creation process. In a few seconds you should see that the applications are synced and two additional items have been created.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;444&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2-7.jpg&#34; alt=&#34;Healthy dashboard graphic&#34; class=&#34;wp-image-149106&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2-7.jpg 1024w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-7-300x130.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-7-768x333.jpg 768w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-7-900x390.jpg 900w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-7-461x200.jpg 461w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-7-923x400.jpg 923w&#34; sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;402&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2.jpg&#34; alt=&#34;Image of application dashboard&#34; class=&#34;wp-image-148993&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2.jpg 1024w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-300x118.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-768x302.jpg 768w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-900x353.jpg 900w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-509x200.jpg 509w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-1019x400.jpg 1019w&#34; sizes=&#34;auto, (max-width: 1024px) 100vw, 1024px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 4: Verify the Deployment&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Just to double check all is set and deployed fine, login to your Kubernetes cluster and validate all applications.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;$ kubectl get all -n ingress-nginx&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;$ kubectl get all -n cert-manager&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;758&#34; height=&#34;195&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Picture7.png&#34; alt=&#34;Student Ubuntu code graphic&#34; class=&#34;wp-image-149109&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Picture7.png 758w, https://www.cncf.io/wp-content/uploads/2025/10/Picture7-300x77.png 300w, https://www.cncf.io/wp-content/uploads/2025/10/Picture7-600x154.png 600w&#34; sizes=&#34;auto, (max-width: 758px) 100vw, 758px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;758&#34; height=&#34;250&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Picture8.png&#34; alt=&#34;Student Ubuntu code graphic example&#34; class=&#34;wp-image-149111&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Picture8.png 758w, https://www.cncf.io/wp-content/uploads/2025/10/Picture8-300x99.png 300w, https://www.cncf.io/wp-content/uploads/2025/10/Picture8-600x198.png 600w&#34; sizes=&#34;auto, (max-width: 758px) 100vw, 758px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;All looks good, the application’s pods are running and the final check is done.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The&amp;nbsp;&lt;strong&gt;App of Apps&lt;/strong&gt;&amp;nbsp;pattern in ArgoCD is a production-ready, scalable and modular approach to managing multi-component Kubernetes environments. By structuring your deployments this way and using dedicated&amp;nbsp;values.yaml&amp;nbsp;files, you gain flexibility, reusability and clarity across environments. You can monitor any changes in YAML files that are stored in Git and track all changes made into them. It’s an ideal solution for platform teams, GitOps advocates and anyone managing more than one service in Kubernetes.&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;p&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;大规模管理云原生基础设施不再只是部署单个应用程序，而是组织环境、定义清晰的边界，并在简单而清晰的生命周期流程中保持所有内容的版本控制、一致、自动化和轻松管理。这就是 GitOps 实践（例如 &lt;strong&gt;ArgoCD&lt;/strong&gt;）真正发挥作用的地方。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;ArgoCD 最强大的模式之一称为&lt;strong&gt;App of Apps&lt;/strong&gt;，这是一种单父 ArgoCD 应用程序管理和部署多个子 ArgoCD 应用程序的设计。它为潜在混乱的部署带来了秩序，提高了可观察性并与 GitOps 方法完美契合。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在本文中，我们将探讨 ArgoCD 中的&lt;strong&gt;应用的应用&lt;/strong&gt;模式，包括其概念、结构、优缺点，以及通过专用&lt;strong&gt;值文件&lt;/strong&gt;配置子应用程序的生产级方法。您将通过部署两个示例应用程序来学习如何构建可重用、可扩展的模式：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;NGINX 入口控制器&lt;/strong&gt;&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;证书管理器&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;让我们深入了解一下。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;ArgoCD中的App of Apps模式是什么？&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;span style=&#34;text-decoration: underline;&#34;&gt;概念&lt;/span&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;应用中的应用&lt;/strong&gt;模式是一种 ArgoCD 部署策略，其中一个中央 ArgoCD 应用程序（“父应用程序”）负责管理和部署多个其他应用程序（“子应用程序”）。每个子应用程序对应一个逻辑单元（例如微服务、控制器或平台组件），并由 ArgoCD 完全管理。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这实现了模块化、分层结构——在基础设施由许多独立但相关的组件组成的环境中特别有用。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt; &lt;img loading =“lazy”decoding =“async”width =“647”height =“412”src =“https://www.cncf.io/wp-content/uploads/2025/10/image-2-3.jpg”alt =“分层应用程序图形” 类=“wp-image-149098”srcset=“https://www.cncf.io/wp-content/uploads/2025/10/image-2-3.jpg 647w， https://www.cncf.io/wp-content/uploads/2025/10/image-2-3-300x191.jpg 300w，https://www.cncf.io/wp-content/uploads/2025/10/image-2-3-314x200.jpg 314w， https://www.cncf.io/wp-content/uploads/2025/10/image-2-3-628x400.jpg 628w“尺寸=”自动，（最大宽度：647px）100vw，647px“referrerpolicy=“no-referrer”&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;现实世界的类比&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;将父应用视为&lt;strong&gt;管弦乐队的指挥&lt;/strong&gt;。每个乐器（子应用程序）都有自己的乐谱（Helm 图表或清单），但通过指挥的协调可以和谐地演奏。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-table&#34;&gt;&lt;table class=&#34;has-fixed-layout&#34;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;Environment&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;适用性&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;开发&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;✅非常适合模块化测试设置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;登台/UAT&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;✅非常适合环境复制 和控制&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;生产&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;✅ 是的 - 具有明确定义的同步策略、运行状况检查和 RBAC&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;好处&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;✅&lt;strong&gt;模块化管理&lt;/strong&gt;：每个应用程序都独立进行版本控制和控制。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;✅&lt;strong&gt;可重用性&lt;/strong&gt;：通过重新应用应用中的应用轻松克隆环境。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;✅&lt;strong&gt;集中可见性&lt;/strong&gt;：一个视图即可管理所有应用程序。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;✅&lt;strong&gt;GitOps 驱动&lt;/strong&gt;：每个更改都通过 Git 进行跟踪，从而实现审核和回滚。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;⚠️ &lt;strong&gt;复杂性开销&lt;/strong&gt;：初始学习曲线和其他清单。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;⚠️ &lt;strong&gt;偏差风险&lt;/strong&gt;：不正确的同步策略可能会导致应用程序不同步。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;⚠️ &lt;strong&gt;级别太多&lt;/strong&gt;：避免应用程序的深层嵌套，这可能会导致混乱和调试困难。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;先决条件&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在继续之前，请确保您具备以下条件：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;正在运行的 Kubernetes 集群。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;在您的集群中安装并配置了 ArgoCD。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;kubectl 和 helm 安装在您的本地计算机上。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;用于存储 ArgoCD 应用程序清单的 Git 存储库。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;第 1 步：创建目录结构&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;让我们构建一个结构，其中有应用程序 YAML 定义的主应用程序。我仅将其存储作为参考，因为我将在 ArgoCD 中手动创建该主应用程序。每个子应用程序都使用专用的 Helm Chart 和 value.yaml 文件进行配置。 Apps 文件夹将保留我在 ArgoCD 中定义为单独应用程序的所有应用程序。作为参考，您可以参考我的存储库网址：&lt;a href=&#34;https://github.com/mariano-italiano/argocd-apps.git&#34;&gt;https://github.com/mariano-italiano/argocd-apps.git&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt; &lt;img loading =“lazy”decoding =“async”width =“1526”height =“816”src =“https://www.cncf.io/wp-content/uploads/2025/10/image-3-2.jpg”alt =“缩进代码示例” 类=“wp-image-149092”srcset=“https://www.cncf.io/wp-content/uploads/2025/10/image-3-2.jpg 1526w， https://www.cncf.io/wp-content/uploads/2025/10/image-3-2-300x160.jpg 300w，https://www.cncf.io/wp-content/uploads/2025/10/image-3-2-1024x548.jpg 1024w， https://www.cncf.io/wp-content/uploads/2025/10/image-3-2-768x411.jpg 768w，https://www.cncf.io/wp-content/uploads/2025/10/image-3-2-900x481.jpg 900w， https://www.cncf.io/wp-content/up加载/2025/10/image-3-2-374x200.jpg 374w，https://www.cncf.io/wp-content/uploads/2025/10/image-3-2-748x400.jpg 748w“尺寸=”自动，（最大宽度：1526px）100vw，1526px“ referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;第 2 步：定义子应用程序&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;创建结构后，您需要为子应用创建清单。每个应用程序都指向我们的 Git 存储库中的 Helm 图表。就我而言，如上所述，我将创建 NGINX Ingress 以及 Cert-Manager 应用程序。这里有两个文件：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;api版本：argoproj.io/v1alpha1&#xA;种类： 应用&#xA;元数据：&#xA;  名称：nginx-ingress&#xA;  命名空间：argocd&#xA;规格：&#xA;  项目：默认&#xA;  来源：&#xA;    仓库地址：https://github.com/mariano-italiano/argocd-apps&#xA;    目标修订版：HEAD&#xA;    路径：charts/nginx-ingress&#xA;    舵：&#xA;      值文件：&#xA;        - 值.yaml&#xA;  目的地：&#xA;    服务器：https://kubernetes.default.svc&#xA;    命名空间：ingress-nginx&#xA;  同步策略：&#xA;    自动化：&#xA;      修剪：真实&#xA;      自我修复：正确&#xA;api版本：argoproj.io/v1alpha1&#xA;种类： 应用&#xA;元数据：&#xA;  姓名： 证书经理&#xA;  命名空间：argocd&#xA;规格：&#xA;  项目：默认&#xA;  来源：&#xA;    仓库地址：https://github.com/mariano-italiano/argocd-apps&#xA;    目标修订版：HEAD&#xA;    路径：图表/证书管理器&#xA;    舵：&#xA;      值文件：&#xA;        - 值.yaml&#xA;  目的地：&#xA;    服务器：https://kubernetes.default.svc&#xA;    命名空间：证书管理器&#xA;  同步策略：&#xA;    自动化：&#xA;      修剪：真实&#xA;      selfHeal：true&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;第 3 步：定义父应用（应用中的应用）&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;现在让我们创建主应用程序。登录 ArgoCD 并点击&lt;strong&gt;创建应用程序&lt;/strong&gt;按钮。接下来，点击右侧网站上的&lt;strong&gt;编辑为 YAML&lt;/strong&gt;，并粘贴包含以下内容的主应用：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre class=&#34;wp-block-code&#34;&gt;&lt;code class=&#34;&#34;&gt;api版本：argoproj.io/v1alpha1&#xA;种类： 应用&#xA;元数据：&#xA;  名称：应用程序中的应用程序&#xA;  命名空间：argocd&#xA;规格：&#xA;  项目：默认&#xA;  来源：&#xA;    仓库地址：https://github.com/mariano-italiano/argocd-apps&#xA;    目标修订版：HEAD&#xA;    路径：应用程序&#xA;  目的地：&#xA;    服务器：https://kubernetes.default.svc&#xA;    命名空间：argocd&#xA;  同步策略：&#xA;    自动：空&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;点击&lt;strong&gt;保存&lt;/strong&gt;，然后点击顶部的&lt;strong&gt;创建&lt;/strong&gt;来创建主应用程序。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;完成此操作后，您应该具有与下图所示类似的状态。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt; &lt;img loading =“lazy”decoding =“async”width =“300”height =“261”src =“https://www.cncf.io/wp-content/uploads/2025/10/image-2-4.jpg”alt =“App-of-Apps Graphic” class =“wp-image-149101”srcset =“https://www.cncf.io/wp-content/uploads/2025/10/image-2-4.jpg 300w，https://www.cncf.io/wp-content/uploads/2025/10/image-2-4-230x200.jpg 230w“尺寸=”自动，（最大宽度：300px）100vw，300px“referrerpolicy=“no-referrer”&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;出现“OutOfSync”状态是可以的，因为我们在定义中特意选择了手动同步策略。这是一个安全的选项，让您可以完全控制集群中部署或更新的所有内容。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;单击此项目并在应用程序内导航。您将看到缺少的两个应用程序的定义。这正是我们的应用程序目录的镜像。我们的集群中缺少两个应用程序。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt; &lt;img loading =“lazy”decoding =“async”width =“1024”height =“415”src =“https://www.cncf.io/wp-content/uploads/2025/10/image-2-5.jpg”alt =“仪表板图形” 类=“wp-image-149103”srcset=“https://www.cncf.io/wp-content/uploads/2025/10/image-2-5.jpg 1024w， https://www.cncf.io/wp-content/uploads/2025/10/image-2-5-300x122.jpg 300w，https://www.cncf.io/wp-content/uploads/2025/10/image-2-5-768x311.jpg 768w， https://www.cncf.io/wp-content/uploads/2025/10/image-2-5-900x365.jpg 900w，https://www.cncf.io/wp-content/uploads/2025/10/image-2-5-493x200.jpg 493w， https://www.cncf.io/wp-content/uploads/2025/10/image-2-5-987x400.jpg 987w“尺寸=”自动，（最大宽度：1024像素）100vw，1024像素“referrerpolicy=“no-referrer”&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;点击&lt;strong&gt;同步&lt;/strong&gt;按钮，然后选择所有不同步的应用程序，最后点击&lt;strong&gt;同步&lt;/strong&gt;。 &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; Decoding=&#34;async&#34; width=&#34;1024&#34; height=&#34;390&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2-6.jpg&#34; alt=&#34;点击后的仪表板图形 同步&#34; class=&#34;wp-image-149105&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2-6.jpg 1024w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-6-300x114.jpg 300w，https://www.cncf.io/wp-content/uploads/2025/10/image-2-6-768x293.jpg 768w， https://www.cncf.io/wp-content/uploads/2025/10/image-2-6-900x343.jpg 900w，https://www.cncf.io/wp-content/uploads/2025/10/image-2-6-525x200.jpg 525w&#34; 尺寸=“自动，（最大宽度：1024px）100vw，1024px”referrerpolicy=“no-referrer”&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;丢失的应用程序应该启动创建过程。几秒钟后你应该看到应用程序已同步并且已创建两个附加项目。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt; &lt;img loading =“lazy”decoding =“async”width =“1024”height =“444”src =“https://www.cncf.io/wp-content/uploads/2025/10/image-2-7.jpg”alt =“健康仪表板图形” 类=“wp-image-149106”srcset=“https://www.cncf.io/wp-content/uploads/2025/10/image-2-7.jpg 1024w， https://www.cncf.io/wp-content/uploads/2025/10/image-2-7-300x130.jpg 300w，https://www.cncf.io/wp-content/uploads/2025/10/image-2-7-768x333.jpg 768w， https://www.cncf.io/wp-content/uploads/2025/10/image-2-7-900x390.jpg 900w，https://www.cncf.io/wp-content/uploads/2025/10/image-2-7-461x200.jpg 461w， https://www.cncf.io/wp-content/uploads/2025/10/image-2-7-923x400.jpg 923w&#34;sizes=&#34;auto,(最大宽度:1024px)100vw,1024px&#34;referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;imgloading=&#34;lazy&#34;decoding=&#34;async&#34;width=&#34;1024&#34;height=&#34;402&#34;src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2.jpg&#34;alt=&#34;应用程序仪表板的图像&#34; class =“wp-image-148993”srcset =“https://www.cncf.io/wp-content/uploads/2025/10/image-2.jpg 1024w，https://www.cncf.io/wp-content/uploads/2025/10/image-2-300x118.jpg 300w，https://www.cncf.io/wp-content/uploads/2025/10/image-2-768x302.jpg 768w，https://www.cncf.io/wp-content/uploads/2025/10/image-2-900x353.jpg 900w， https://www.cncf.io/wp-content/uploads/2025/10/image-2-509x200.jpg 509w，https://www.cncf.io/wp-content/uploads/2025/10/image-2-1019x400.jpg 1019w“尺寸=”自动， （最大宽度：1024px）100vw，1024px“referrerpolicy =“no-referrer”&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;第 4 步：验证部署&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;为了仔细检查所有设置和部署是否正常，请登录到您的 Kubernetes 集群并验证所有应用程序。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;$ kubectl 获取所有 -n ingress-nginx&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;$ kubectl 获取所有 -n 证书管理器&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt; &lt;img loading =“lazy”decoding =“async”width =“758”height =“195”src =“https://www.cncf.io/wp-content/uploads/2025/10/Picture7.png”alt =“学生Ubuntu代码图形” 类=“wp-image-149109”srcset=“https://www.cncf.io/wp-content/uploads/2025/10/Picture7.png 758w， https://www.cncf.io/wp-content/uploads/2025/10/Picture7-300x77.png 300w，https://www.cncf.io/wp-content/uploads/2025/10/Picture7-600x154.png 600w“尺寸=”自动， （最大宽度：758px）100vw，758px“referrerpolicy =“no-referrer”&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; Decoding=&#34;async&#34; width=&#34;758&#34; height=&#34;250&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/Picture8.png&#34; alt=&#34;学生 Ubuntu 代码图形示例&#34; class =“wp-image-149111”srcset =“https://www.cncf.io/wp-content/uploads/2025/10/Picture8.png 758w，https://www.cncf.io/wp-content/uploads/2025/10/Picture8-300x99.png 300w，https://www.cncf.io/wp-content/uploads/2025/10/Picture8-600x198.png 600w“尺寸=”自动，（最大宽度：758px）100vw，758px“referrerpolicy=“no-referrer”&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;一切看起来都不错，应用程序on 的 Pod 正在运行，最终检查已完成。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;ArgoCD 中的&lt;strong&gt;应用中的应用&lt;/strong&gt;模式是一种用于管理多组件 Kubernetes 环境的生产就绪型、可扩展且模块化的方法。通过以这种方式构建部署并使用专用的 value.yaml 文件，您可以跨环境获得灵活性、可重用性和清晰度。您可以监视存储在 Git 中的 YAML 文件中的任何更改，并跟踪对这些文件所做的所有更改。对于平台团队、GitOps 倡导者以及在 Kubernetes 中管理多个服务的任何人来说，这是一种理想的解决方案。&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Mon, 06 Oct 2025 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Karmada v1.15 Released! Enhanced Resource Awareness for Multi-Template Workloads】Karmada v1.15 发布！增强多模板工作负载的资源感知</title>
      <link>https://www.cncf.io/blog/2025/10/07/karmada-v1-15-released-enhanced-resource-awareness-for-multi-template-workloads/</link>
      <description>【&lt;p&gt;Karmada is an open multi-cloud and multi-cluster container orchestration engine designed to help users deploy and operate business applications in a multi-cloud environment. With its compatibility with the native Kubernetes API, &lt;a href=&#34;https://karmada.io/&#34;&gt;Karmada&lt;/a&gt; can smoothly migrate single-cluster workloads while still maintaining coordination with the surrounding Kubernetes ecosystem tools.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;1600&#34; height=&#34;752&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-3-1.jpg&#34; alt=&#34;Karmada release enhancements graphic&#34; class=&#34;wp-image-149039&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-3-1.jpg 1600w, https://www.cncf.io/wp-content/uploads/2025/10/image-3-1-300x141.jpg 300w, https://www.cncf.io/wp-content/uploads/2025/10/image-3-1-1024x481.jpg 1024w, https://www.cncf.io/wp-content/uploads/2025/10/image-3-1-768x361.jpg 768w, https://www.cncf.io/wp-content/uploads/2025/10/image-3-1-900x423.jpg 900w, https://www.cncf.io/wp-content/uploads/2025/10/image-3-1-426x200.jpg 426w, https://www.cncf.io/wp-content/uploads/2025/10/image-3-1-851x400.jpg 851w&#34; sizes=&#34;auto, (max-width: 1600px) 100vw, 1600px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/karmada-io/karmada/releases/tag/v1.15.0&#34;&gt;Karmada v1.15&lt;/a&gt; has been released, this version includes the following new features:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Precise resource awareness for multi-template workloads&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Enhanced cluster-level failover functionality&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Structured logging&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Significant performance improvements for Karmada controllers and schedulers&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Overview of New Features&lt;/strong&gt;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Precise Resource Awareness for Multi-Template Workloads&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karmada utilizes a resource interpreter to retrieve the replica count and resource requests of workloads. Based on this data, it calculates the total resource requirements of the workloads, thereby enabling advanced capabilities such as resource-aware scheduling and federated quota management. This mechanism works well for traditional single-template workloads. However, many AI and big data application workloads (e.g., FlinkDeployments, PyTorchJobs, and RayJobs) consist of multiple Pod templates or components, each with unique resource demands. Since the resource interpreter can only process resource requests from a single template and fails to accurately reflect differences between multiple templates, the resource calculation for multi-template workloads is not precise enough.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In this version, Karmada has strengthened its resource awareness for multi-template workloads. By extending the resource interpreter, Karmada can now obtain the replica count and resource requests of different templates within the same workload, ensuring data accuracy. This improvement also provides more reliable and granular data support for federated quota management of multi-template workloads.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Suppose you deploy a FlinkDeployment with the following resource-related configuration:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-table&#34;&gt;&lt;table class=&#34;has-fixed-layout&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;spec:&amp;nbsp;&amp;nbsp;jobManager:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;replicas: 1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;resource:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;cpu: 1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;memory: 1024m&amp;nbsp;&amp;nbsp;taskManager:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;replicas: 1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;resource:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;cpu: 2&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;memory: 2048m&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Through ResourceBinding, you can view the replica count and resource requests of each template in the FlinkDeployment parsed by the resource interpreter.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-table&#34;&gt;&lt;table class=&#34;has-fixed-layout&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;spec:&amp;nbsp;&amp;nbsp;components:&amp;nbsp;&amp;nbsp;– name: jobmanager&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;replicaRequirements:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;resourceRequest:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;cpu: “1”&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;memory: “1.024”&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;replicas: 1&amp;nbsp;&amp;nbsp;– name: taskmanager&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;replicaRequirements:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;resourceRequest:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;cpu: “2”&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;memory: “2.048”&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;replicas: 1&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;At this point, the resource usage of the FlinkDeployment calculated by FederatedResourceQuota is as follows:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-table&#34;&gt;&lt;table class=&#34;has-fixed-layout&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;status:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;overallUsed:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;cpu: “3”&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;memory: 3072m&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Note: &lt;/strong&gt;This feature is currently in the Alpha stage and requires enabling the MultiplePodTemplatesScheduling feature gate to use.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;As multi-template workloads are widely adopted in cloud-native environments, Karmada is committed to providing stronger support for them. In upcoming versions, we will further enhance scheduling support for multi-template workloads based on this feature and offer more granular resource-aware scheduling—stay tuned for more updates!&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;For more information about this feature, please refer to: &lt;a href=&#34;https://github.com/karmada-io/karmada/tree/master/docs/proposals/scheduling/multi-podtemplate-support&#34;&gt;Multi-Pod Template Support&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Enhanced Cluster-Level Failover Functionality&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In previous versions, Karmada provided basic cluster-level failover capabilities, allowing cluster-level application migration to be triggered through custom failure conditions. To meet the requirement of preserving the running state of stateful applications during cluster failover, Karmada v1.15 supports an application state preservation policy for cluster failover. For big data processing applications (e.g., Flink), this capability enables restarting from the pre-failure checkpoint and seamlessly resuming data processing to the state before the restart, thus avoiding duplicate data processing.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The community has introduced a new StatePreservation field under .spec.failover.cluster in the PropagationPolicy/ClusterPropagationPolicy API. This field is used to define policies for preserving and restoring state data of stateful applications during failover. Combined with this policy, when an application is migrated from a failed cluster to another cluster, key data can be extracted from the original resource configuration.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The state preservation policy StatePreservation includes a series of StatePreservationRule configurations. It uses JSONPath to specify the segments of state data that need to be preserved and leverages the associated AliasLabelName to pass the data to the migrated cluster.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Taking a Flink application as an example: in a Flink application, jobID is a unique identifier used to distinguish and manage different Flink jobs. When a cluster fails, the Flink application can use jobID to restore the state of the job before the failure and continue execution from the failure point. The specific configuration and steps are as follows:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-table&#34;&gt;&lt;table class=&#34;has-fixed-layout&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;apiVersion: policy.karmada.io/v1alpha1&lt;br&gt;kind: PropagationPolicy&lt;br&gt;metadata:&lt;br&gt;&amp;nbsp; name: foo&lt;br&gt;spec:&lt;br&gt;&amp;nbsp; #…&lt;br&gt;&amp;nbsp; failover:&lt;br&gt;&amp;nbsp; &amp;nbsp; cluster:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; purgeMode: Directly&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; statePreservation:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; rules:&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; – aliasLabelName: application.karmada.io/cluster-failover-jobid&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; jsonPath: “{ .jobStatus.jobID }”&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;Before migration, the Karmada controller extracts the job ID according to the path configured by the user.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;During migration, the Karmada controller injects the extracted job ID into the Flink application configuration in the form of a label, such as application.karmada.io/cluster-failover-jobid: &amp;lt;jobID&amp;gt;.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Kyverno running in the member cluster intercepts the Flink application creation request, obtains the checkpoint data storage path of the job based on the jobID (e.g., /&amp;lt;shared-path&amp;gt;/&amp;lt;job-namespace&amp;gt;/&amp;lt;jobId&amp;gt;/checkpoints/xxx), and then configures initialSavepointPath to indicate starting from the savepoint.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;The Flink application starts based on the checkpoint data under initialSavepointPath, thereby inheriting the final state saved before migration.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;This capability is widely applicable to stateful applications that can start from a specific savepoint. These applications can follow the above process to implement state persistence and restoration for cluster-level failover.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Note: This feature is currently in the Alpha stage and requires enabling the StatefulFailoverInjection feature gate to use.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Function Constraints&lt;/strong&gt;:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;The application must be restricted to run in a single cluster.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;The migration cleanup policy (PurgeMode) is limited to Directly—this means ensuring that the failed application is deleted from the old cluster before being restored in the new cluster to guarantee data consistency.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Structured Logging&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Logs are critical tools for recording events, states, and behaviors during system operation, and are widely used for troubleshooting, performance monitoring, and security auditing. Karmada components provide rich runtime logs to help users quickly locate issues and trace execution scenarios. In previous versions, Karmada only supported unstructured text logs, which were difficult to parse and query efficiently, limiting its integration capabilities in modern observability systems.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karmada v1.15 introduces support for structured logging, which can be configured to output in JSON format using the –logging-format=json startup flag. An example of structured logging is as follows:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-table&#34;&gt;&lt;table class=&#34;has-fixed-layout&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;{&amp;nbsp;&amp;nbsp;“ts”:“日志时间戳”,&amp;nbsp;&amp;nbsp;“logger”:”cluster_status_controller”,&amp;nbsp;&amp;nbsp;“level”: “info”,&amp;nbsp;&amp;nbsp;“msg”:”Syncing cluster status”,&amp;nbsp;&amp;nbsp;“clusterName”:”member1″}&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The introduction of structured logging significantly improves the usability and observability of logs:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;Efficient Integration&lt;/strong&gt;:&amp;nbsp; Integration with mainstream logging systems such as Elastic, Loki, and Splunk, without relying on complex regular expressions or log parsers.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Efficient Query&lt;/strong&gt;: Structured fields support fast retrieval and analysis, significantly improving troubleshooting efficiency.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Enhanced Observability&lt;/strong&gt;: Key context information (e.g., cluster name, log level) is presented as structured fields, facilitating cross-component and cross-time event correlation for accurate issue localization.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;Maintainability&lt;/strong&gt;: Structured logging makes it easier for developers and operators to maintain, parse, and evolve log formats as the system changes.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Significant Performance Improvements for Karmada Controllers and Schedulers&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;In this version, the Karmada performance optimization team has continued to focus on improving the performance of Karmada’s key components, achieving significant progress in both controllers and schedulers.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;In terms of the controller&lt;/strong&gt;, by introducing &lt;a href=&#34;https://github.com/kubernetes-sigs/controller-runtime/issues/2374&#34;&gt;controller-runtime priority queue&lt;/a&gt;, the controller can give priority to responding to user-triggered resource changes after a restart or leader transition, thereby significantly reducing the downtime during service restart and failover processes.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The test environment included 5,000 Deployments, 2,500 Policies, and 5,000 ResourceBindings. The Deployment and Policy were updated when the controller restarted with a large number of pending events still in the work queue. Test results showed that &lt;strong&gt;the controller could immediately respond to and prioritize processing these update events, verifying the effectiveness of this optimization&lt;/strong&gt;.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Note: &lt;/strong&gt;This feature is currently in the Alpha stage and requires enabling the ControllerPriorityQueue feature gate to use.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;In terms of the scheduler&lt;/strong&gt;, by reducing redundant computations in the scheduling process and decreasing the number of remote call requests, the scheduling efficiency of the Karmada scheduler has been significantly improved.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Tests were conducted to record the time taken to schedule 5,000 ResourceBindings with the precise scheduling component karmada-scheduler-estimator enabled. The results are as follows:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;The scheduler throughput QPS increased from approximately 15 to about 22, representing a 46% performance improvement.&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;The number of gRPC requests decreased from approximately 10,000 to around 5,000, a reduction of 50%.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;These tests confirm that the performance of Karmada controllers and schedulers has been greatly improved in version 1.15. In the future, we will continue to conduct systematic performance optimizations for controllers and schedulers.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;For the detailed test report, please refer to &lt;a href=&#34;https://github.com/karmada-io/karmada/issues/6516&#34;&gt;[Performance] Overview of performance improvements for v1.15&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Acknowledging Our Contributors&lt;/strong&gt;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;The Karmada v1.15 release includes 269 code commits from 39 contributors. We would like to extend our sincere gratitude to all the contributors:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-table&#34;&gt;&lt;table class=&#34;has-fixed-layout&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;@abhi0324&lt;/td&gt;&lt;td&gt;@abhinav-1305&lt;/td&gt;&lt;td&gt;@Arhell&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Bhaumik10&lt;/td&gt;&lt;td&gt;@CaesarTY&lt;/td&gt;&lt;td&gt;@cbaenziger&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@deefreak&lt;/td&gt;&lt;td&gt;@dekaihu&lt;/td&gt;&lt;td&gt;@devarsh10&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@greenmoon55&lt;/td&gt;&lt;td&gt;@iawia002&lt;/td&gt;&lt;td&gt;@jabellard&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@jennryaz&lt;/td&gt;&lt;td&gt;@liaolecheng&lt;/td&gt;&lt;td&gt;@linyao22&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@LivingCcj&lt;/td&gt;&lt;td&gt;@liwang0513&lt;/td&gt;&lt;td&gt;@mohamedawnallah&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@mohit-nagaraj&lt;/td&gt;&lt;td&gt;@mszacillo&lt;/td&gt;&lt;td&gt;@RainbowMango&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@ritzdevp&lt;/td&gt;&lt;td&gt;@ryanwuer&lt;/td&gt;&lt;td&gt;@samzong&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@seanlaii&lt;/td&gt;&lt;td&gt;@SunsetB612&lt;/td&gt;&lt;td&gt;@tessapham&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@wangbowen1401&lt;/td&gt;&lt;td&gt;@warjiang&lt;/td&gt;&lt;td&gt;@wenhuwang&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@whitewindmills&lt;/td&gt;&lt;td&gt;@whosefriendA&lt;/td&gt;&lt;td&gt;@XiShanYongYe-Chang&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@zach593&lt;/td&gt;&lt;td&gt;@zclyne&lt;/td&gt;&lt;td&gt;@zhangsquared&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@zhuyulicfc49&lt;/td&gt;&lt;td&gt;@zhzhuang-zju&lt;/td&gt;&lt;td&gt;@zzklachlan&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34; decoding=&#34;async&#34; width=&#34;601&#34; height=&#34;750&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2-2.jpg&#34; alt=&#34;Contributor collage&#34; class=&#34;wp-image-149038&#34; srcset=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-2-2.jpg 601w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-2-240x300.jpg 240w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-2-160x200.jpg 160w, https://www.cncf.io/wp-content/uploads/2025/10/image-2-2-321x400.jpg 321w&#34; sizes=&#34;auto, (max-width: 601px) 100vw, 601px&#34; referrerpolicy=&#34;no-referrer&#34;&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;References：&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;[1] Karmada: &lt;a href=&#34;https://karmada.io/&#34;&gt;&lt;em&gt;https://karmada.io/&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;[2] Karmada v1.15: &lt;a href=&#34;https://github.com/karmada-io/karmada/releases/tag/v1.15.0&#34;&gt;&lt;em&gt;https://github.com/karmada-io/karmada/releases/tag/v1.15.0&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;[3] Multi-Pod Template Support: &lt;a href=&#34;https://github.com/karmada-io/karmada/tree/master/docs/proposals/scheduling/multi-podtemplate-support&#34;&gt;&lt;em&gt;https://github.com/karmada-io/karmada/tree/master/docs/proposals/scheduling/multi-podtemplate-support&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;[4] [Performance] Overview of performance improvements for v1.15: &lt;a href=&#34;https://github.com/karmada-io/karmada/issues/6516&#34;&gt;&lt;em&gt;https://github.com/karmada-io/karmada/issues/6516&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;[5] Karmada GitHub：&lt;a href=&#34;https://github.com/karmada-io/karmada&#34;&gt;&lt;em&gt;https://github.com/karmada-io/karmada&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;】&lt;p&gt;Karmada 是一个开放的多云和多集群容器编排引擎，旨在帮助用户在多云环境中部署和运营业务应用程序。凭借与原生 Kubernetes API 的兼容性，&lt;a href=&#34;https://karmada.io/&#34;&gt;Karmada&lt;/a&gt; 可以平滑迁移单集群工作负载，同时仍保持与周围 Kubernetes 生态系统工具的协调。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-image size-full&#34;&gt;&lt;img loading=&#34;lazy&#34;解码=&#34;async&#34; width=&#34;1600&#34; height=&#34;752&#34; src=&#34;https://www.cncf.io/wp-content/uploads/2025/10/image-3-1.jpg&#34; alt=&#34;Karmada 版本增强图形&#34; 类=“wp-image-149039”srcset=“https://www.cncf.io/wp-content/uploads/2025/10/image-3-1.jpg 1600w， https://www.cncf.io/wp-content/uploads/2025/10/image-3-1-300x141.jpg 300w，https://www.cncf.io/wp-content/uploads/2025/10/image-3-1-1024x481.jpg 1024w， https://www.cncf.io/wp-content/uploads/2025/10/image-3-1-768x361.jpg 768w，https://www.cncf.io/wp-content/uploads/2025/10/image-3-1-900x423.jpg 900w， https://www.cncf.io/wp-content/uploads/2025/10/image-3-1-426x200.jpg 426w，https://www.cncf.io/wp-content/uploads/2025/10/image-3-1-851x400.jpg 851w&#34; 尺寸=“自动，（最大宽度：1600px）100vw，1600px”referrerpolicy=“no-referrer”&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/karmada-io/karmada/releases/tag/v1.15.0&#34;&gt;Karmada v1.15&lt;/a&gt;已发布，该版本包含以下新功能：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;针对多模板工作负载的精确资源感知&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;增强的集群级故障转移功能&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;结构化日志记录&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Karmada 控制器和调度程序的性能显着提升&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;新功能概述&lt;/strong&gt;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;多模板工作负载的精确资源感知&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karmada 利用资源解释器来检索工作负载的副本计数和资源请求。根据这些数据，它可以计算工作负载的总资源需求，从而实现资源感知调度和联合配额管理等高级功能。此机制非常适合传统的单模板工作负载。然而，许多 AI 和大数据应用程序工作负载（例如 FlinkDeployments、PyTorchJobs 和 RayJobs）由多个 Pod 模板或组件组成，每个模板或组件都有独特的资源需求。由于资源解释器只能处理单个模板的资源请求，无法准确反映多个模板之间的差异，因此多模板工作负载的资源计算不够精确。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在此版本中，Karmada 增强了对多模板工作负载的资源感知。通过扩展资源解释器，Karmada 现在可以获取同一工作负载内不同模板的副本数量和资源请求，确保数据准确性。这一改进也证明为多模板工作负载的联合配额管理提供更可靠、更精细的数据支持。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;假设您使用以下资源相关配置部署 FlinkDeployment：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-table&#34;&gt;&lt;table class=&#34;has-fixed-layout&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;规格：  jobManager：    副本：1    资源：      cpu：1      内存：1024m  taskManager：    副本：1    资源：      cpu： 2      内存：2048m&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;通过ResourceBinding，可以查看资源解释器解析出的FlinkDeployment中各个模板的副本数量和资源请求情况。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-table&#34;&gt;&lt;table class=&#34;has-fixed-layout&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;规格：  组件：  – 名称：jobmanager    replicaRequirements：      resourceRequest：        cpu：“1”        内存：“1.024”    副本：1  – 名称：任务管理器    副本要求：      资源请求：        CPU：“2”        内存： “2.048”    副本：1&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此时FederatedResourceQuota计算出的FlinkDeployment的资源使用情况如下：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-table&#34;&gt;&lt;table class=&#34;has-fixed-layout&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;状态：    总体已使用：      cpu：“3”      内存：3072m&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;此功能目前处于 Alpha 阶段，需要启用 MultiplePodTemplatesScheduling 功能门才能使用。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;随着多模板工作负载在云原生环境中的广泛采用，Karmada 致力于为其提供更强大的支持。在即将推出的版本中，我们将基于此功能进一步增强对多模板工作负载的调度支持，并提供更细粒度的资源感知调度——更多更新敬请期待！&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;有关此功能的更多信息，请参阅：&lt;a href=&#34;https://github.com/karmada-io/karmada/tree/master/docs/proposals/scheduling/multi-podtemplate-support&#34;&gt;多 Pod 模板支持&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;增强的集群级故障转移功能&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在之前的版本中，Karmada 提供了基本的集群级故障转移功能，允许通过自定义故障条件触发集群级应用程序迁移。满足保存r的要求在集群故障转移期间取消有状态应用程序的状态，Karmada v1.15 支持集群故障转移的应用程序状态保存策略。对于大数据处理应用（例如Flink），该能力可以从故障前的检查点重新启动，并无缝地将数据处理恢复到重新启动前的状态，从而避免重复的数据处理。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;社区在 PropagationPolicy/ClusterPropagationPolicy API 的 .spec.failover.cluster 下引入了新的 StatePreservation 字段。该字段用于定义在故障转移期间保留和恢复有状态应用程序的状态数据的策略。结合此策略，当应用程序从故障集群迁移到另一个集群时，可以从原始资源配置中提取关键数据。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;状态保存策略StatePreservation包含一系列StatePreservationRule配置。它使用 JSONPath 指定需要保留的状态数据段，并利用关联的 AliasLabelName 将数据传递到迁移的集群。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;以Flink应用为例：在Flink应用中，jobID是唯一的标识符，用于区分和管理不同的Flink作业。当集群发生故障时，Flink应用程序可以通过jobID将作业恢复到故障前的状态，并从故障点继续执行。具体配置及步骤如下：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-table&#34;&gt;&lt;table class=&#34;has-fixed-layout&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;apiVersion：policy.karmada.io/v1alpha1&lt;br&gt;kind：PropagationPolicy&lt;br&gt;元数据：&lt;br&gt;  name：foo&lt;br&gt;spec：&lt;br&gt;  #…&lt;br&gt;  故障转移：&lt;br&gt;    cluster：&lt;br&gt;      purgeMode：直接&lt;br&gt;      statePreservation：&lt;br&gt;        规则：&lt;br&gt;          – aliasLabelName：application.karmada.io/cluster-failover-jobid&lt;br&gt;            jsonPath：“{ .jobStatus.jobID }”&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol类=“wp-block-list”&gt;&#xA;&lt;li&gt;迁移之前，Karmada 控制器会根据用户配置的路径提取作业 ID。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;在迁移过程中，Karmada 控制器会将提取的作业 ID 以标签的形式注入到 Flink 应用程序配置中，例如 application.karmada.io/cluster-failover-jobid: &lt;jobID&gt;。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;成员集群中运行的Kyverno拦截Flink应用创建请求，根据jobID获取作业的checkpoint数据存储路径（例如/&lt;shared-path&gt;/&lt;job-namespace&gt;/&lt;jobId&gt;/checkpoints/xxx），然后配置initialSavepointPath表示从savepoint开始。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;Flink应用程序根据initialSavepointPath下的检查点数据启动，从而继承迁移前保存的最终状态。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;此功能广泛适用于有状态应用程序可以从特定保存点开始的离子。这些应用可以按照上述流程实现集群级故障切换的状态持久和恢复。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;注意：此功能目前处于 Alpha 阶段，需要启用 StatefulFailoverInjection 功能门才能使用。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;功能限制&lt;/strong&gt;：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ol类=“wp-block-list”&gt;&#xA;&lt;li&gt;应用程序必须限制为在单个集群中运行。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;迁移清理策略 (PurgeMode) 仅限于“直接”，这意味着确保故障应用程序先从旧集群中删除，然后再在新集群中恢复，以保证数据一致性。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;结构化日志记录&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;日志是记录系统运行过程中的事件、状态和行为的重要工具，广泛用于故障排除、性能监控和安全审计。 Karmada组件提供丰富的运行时日志，帮助用户快速定位问题、追踪执行场景。在之前的版本中，Karmada仅支持非结构化文本日志，难以高效解析和查询，限制了其在现代可观测系统中的集成能力。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karmada v1.15 引入了对结构化日志记录的支持，可以使用 –logging-format=json 启动标志将其配置为以 JSON 格式输出。结构化日志记录的示例如下：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-table&#34;&gt;&lt;table class=&#34;has-fixed-layout&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;{  “ts”:“日志时钟”,  “logger”:”cluster_status_controller”,  “level”: “info”,  “msg”:”正在同步集群 status”,  “clusterName”:“member1”}&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;结构化日志记录的引入显着提高了日志的可用性和可观察性：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;高效集成&lt;/strong&gt;：与 Elastic、Loki 和 Splunk 等主流日志记录系统集成，无需依赖复杂的正则表达式或日志解析器。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;高效查询&lt;/strong&gt;：结构化字段支持快速检索和分析，大幅提升排查效率。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;增强的可观察性&lt;/strong&gt;：关键上下文信息（例如集群名称、日志级别）以结构化字段的形式呈现，促进跨组件和跨时间事件关联，从而实现准确的问题定位。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;&lt;strong&gt;可维护性&lt;/strong&gt;：结构化日志记录使开发人员和运维人员可以更轻松地在系统发生变化时维护、解析和改进日志格式。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;h3 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;Karmada 控制器和调度程序的性能显着提升&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;在这个版本中，Karmada性能优化团队继续专注于提高Karmada的性能关键组件，在控制器和调度器方面取得了重大进展。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;控制器方面&lt;/strong&gt;，通过引入&lt;a href=&#34;https://github.com/kubernetes-sigs/controller-runtime/issues/2374&#34;&gt;controller-runtime优先级队列&lt;/a&gt;，控制器可以在重启或leader过渡后优先响应用户触发的资源变化，从而显着降低 服务重启和故障转移过程中的停机时间。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;测试环境包括 5,000 个部署、2,500 个策略和 5,000 个资源绑定。当控制器重新启动且工作队列中仍有大量待处理事件时，部署和策略已更新。测试结果表明，&lt;strong&gt;控制器能够立即响应并优先处理这些更新事件，验证了本次优化的有效性&lt;/strong&gt;。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;此功能目前处于 Alpha 阶段，需要启用 ControllerPriorityQueue 功能门才能使用。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;在调度器方面&lt;/strong&gt;，通过减少调度过程中的冗余计算，减少远程调用请求的数量，Karmada调度器的调度效率得到了显着提升。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;我们进行了测试，记录在启用精确调度组件 karmada-scheduler-estimator 的情况下调度 5,000 个资源绑定所需的时间。结果如下：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;ul class=&#34;wp-block-list&#34;&gt;&#xA;&lt;li&gt;调度程序吞吐量 QPS 从大约 15 增加到大约 22，性能提高了 46%。&lt;/li&gt;&#xA;&#xA;&#xA;&#xA;&lt;li&gt;gRPC 请求数量从大约 10,000 减少到大约 5,000，减少了 50%。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;这些测试证实 Karmada 控制器和调度器的性能在 1.15 版本中得到了极大的提高。未来我们将继续对控制器和调度器进行系统性的性能优化。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;详细测试报告请参考&lt;a href=&#34;https://github.com/karmada-io/karmada/issues/6516&#34;&gt;【性能】v1.15性能改进概览&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;&lt;strong&gt;感谢我们的贡献者&lt;/strong&gt;&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;Karmada v1.15 版本包含来自 39 位贡献者的 269 项代码提交。我们向所有贡献者致以诚挚的谢意：&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class=&#34;wp-block-table&#34;&gt;&lt;表 class=&#34;has-fixed-layout&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;@abhi0324&lt;/td&gt;&lt;td&gt;@abhinav-1305&lt;/td&gt;&lt;td&gt;@Arhell&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Bhaumik10&lt;/td&gt;&lt;td&gt;@Caesa rTY&lt;/td&gt;&lt;td&gt;@cbaenziger&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@deefreak&lt;/td&gt;&lt;td&gt;@dekaihu&lt;/td&gt;&lt;td&gt;@devarsh10&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@greenmoon55&lt;/td&gt;&lt;td&gt;@iawia 002&lt;/td&gt;&lt;td&gt;@jabellard&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@jennryaz&lt;/td&gt;&lt;td&gt;@liaole Cheng&lt;/​​td&gt;&lt;td&gt;@linyao22&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@LivingCcj&lt;/td&gt;&lt;td&gt;@liwan g0513&lt;/td&gt;&lt;td&gt;@mohamedawnallah&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@mohit-nagaraj&lt;/td&gt;&lt;td&gt;@mszacillo&lt;/td&gt;&lt;td&gt;@RainbowMango&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@ritzdevp&lt;/td&gt;&lt;td&gt;@ryanwuer&lt;/td&gt;&lt;td&gt;@samzong&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@seanlaii&lt;/td&gt;&lt;td&gt;@SunsetB612&lt;/td&gt;&lt;td&gt;@tessapham&lt;/td&gt;&lt; /tr&gt;&lt;tr&gt;&lt;td&gt;@wangbowen1401&lt;/td&gt;&lt;td&gt;@war Jiang&lt;/td&gt;&lt;td&gt;@wenhuwang&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@whitewindmills&lt;/td&gt;&lt;td&gt;@ whofriendA&lt;/td&gt;&lt;td&gt;@XiShanYongYe-Chang&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@zach593&lt;/td&gt;&lt;td&gt;@zclyne&lt;/td&gt;&lt;td&gt;@zhangsquared&lt;/td&gt; td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@zhuyulicfc49&lt;/td&gt;&lt;td&gt;@zhzhuang-zju&lt;/td&gt;&lt;td&gt;@zzklachlan&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;figure class =“wp-block-image size-full”&gt; &lt;img loading =“lazy”decoding =“async”width =“601”height =“750”src =“https://www.cncf.io/wp-content/uploads/2025/10/image-2-2.jpg”alt =“贡献者拼贴” 类=“wp-image-149038”srcset=“https://www.cncf.io/wp-content/uploads/2025/10/image-2-2.jpg 601w， https://www.cncf.io/wp-content/uploads/2025/10/image-2-2-240x300.jpg 240w，https://www.cncf.io/wp-content/uploads/2025/10/image-2-2-160x200.jpg 160w， https://www.cncf.io/wp-content/uploads/2025/10/image-2-2-321x400.jpg 321w“尺寸=”自动，（最大宽度：601px）100vw，601px“referrerpolicy=“no-referrer”&gt;&lt;/figure&gt;&#xA;&#xA;&#xA;&#xA;&lt;h2 class=&#34;wp-block-heading&#34;&gt;参考文献：&lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;[1] Karmada：&lt;a href=&#34;https://karmada.io/&#34;&gt;&lt;em&gt;https://karmada.io/&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;[2] Karmada v1.15：&lt;a href=&#34;https://github.com/karmada-io/karmada/releases/tag/v1.15.0&#34;&gt;&lt;em&gt;https://github.com/karmada-io/karmada/releases/tag/v1.15.0&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;[3] 多 Pod 模板支持：&lt;a href=&#34;https://github.com/karmada-io/karmada/tree/master/docs/proposals/scheduling/multi-podtemplate-support&#34;&gt;&lt;em&gt; https://github.com/karmada-io/karmada/tree/master/docs/proposals/scheduling/multi-podtemplate-support&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;[4] [性能] v1.15 性能改进概述：&lt;a href=&#34;https://github.com/karmada-io/karmada/issues/6516&#34;&gt;&lt;em&gt;https://github.com/karmada-io/karmada/issues/6516&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;[5] Karmada GitHub：&lt;a href=&#34;https://github.com/karmada-io/karmada&#34;&gt;&lt;em&gt;https://github.com/karmada-io/karmada&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div style=&#34;height:80px&#34; aria-hidden=&#34;true&#34; class=&#34;wp-block-spacer is-style-80-120&#34;&gt;&#xA;&lt;/div&gt;</description>
      <pubDate>Mon, 06 Oct 2025 16:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>