<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DZone.com Feed</title>
    <link>https://feeds.dzone.com/home</link>
    <description>Recent posts on DZone.com</description>
    <item>
      <title>【Why Replace External Database Caches?】为什么要更换外部数据库缓存？</title>
      <link>https://dzone.com/articles/why-replace-external-database-caches</link>
      <description>【&lt;p&gt;Teams often consider external caches when the existing database cannot meet the required service-level agreement (SLA). This is a clear performance-oriented decision. Putting an external cache in front of the database is commonly used to compensate for subpar latency stemming from various factors, such as inefficient database internals, driver usage, infrastructure choices, traffic spikes, and so on.&lt;/p&gt;&#xA;&lt;p&gt;Caching might seem like a fast and easy solution because the deployment can be implemented without tremendous hassle and without incurring the significant cost of database scaling, database schema redesign, or even a deeper technology transformation. However, external caches are not as simple as they are often made out to be. In fact, they can be one of the more problematic components of a distributed application architecture.&lt;/p&gt;】&lt;p&gt;当现有数据库无法满足所需的服务级别协议 (SLA) 时，团队通常会考虑外部缓存。这是一个明确的以绩效为导向的决定。在数据库前面放置外部缓存通常用于补偿由于各种因素造成的低于标准的延迟，例如低效的数据库内部结构、驱动程序使用、基础设施选择、流量峰值等。&lt;/p&gt;&#xA;&lt;p&gt;缓存似乎是一种快速而简单的解决方案，因为部署的实施不会带来巨大的麻烦，也不会产生数据库扩展、数据库架构重新设计甚至更深层次的技术转型的巨大成本。然而，外部缓存并不像人们通常想象的那么简单。事实上，它们可能是分布式应用程序架构中问题较多的组件之一。&lt;/p&gt;</description>
      <pubDate>Wed, 28 Aug 2024 14:00:08 +0000</pubDate>
    </item>
    <item>
      <title>【Enhancing Accuracy in AI-Driven Mobile Applications: Tackling Hallucinations in Large Language Models】提高人工智能驱动的移动应用程序的准确性：解决大型语言模型中的幻觉</title>
      <link>https://dzone.com/articles/tackling-hallucinations-in-large-language-models</link>
      <description>【&lt;p&gt;In recent discussions around AI, hallucinations in &lt;a href=&#34;https://dzone.com/refcardz/getting-started-with-large-language-models&#34;&gt;Large Language Models (LLMs)&lt;/a&gt; have become a focal point. These hallucinations manifest when an LLM generates outputs that, while coherent and contextually appropriate, are factually incorrect. For instance, in a mobile app that provides technical support, an LLM might confidently assert that a certain deprecated API can still be used in a current version of Android, leading to potential application errors. This issue is particularly critical in my work, where precision in mobile app development is non-negotiable.&lt;/p&gt;&#xA;&lt;p&gt;Understanding why LLMs produce such hallucinations is essential, especially when deploying them in scenarios that require high trust and accuracy. It&#39;s important to recognize that an LLM is not a structured database; it functions more like a predictive text engine, generating content based on probabilistic patterns rather than factual data.&lt;/p&gt;】&lt;p&gt;在最近围绕人工智能的讨论中，&lt;a href=&#34;https://dzone.com/refcardz/getting-started-with-large-language-models&#34;&gt;大型语言模型 (LLM)&lt;/a&gt; 中出现了幻觉成为焦点。当法学硕士生成的输出虽然连贯且符合上下文，但实际上是不正确的时，这些幻觉就会显现出来。例如，在提供技术支持的移动应用程序中，法学硕士可能会自信地断言某个已弃用的 API 仍然可以在当前版本的 Android 中使用，从而导致潜在的应用程序错误。这个问题在我的工作中尤其重要，因为移动应用程序开发的精度是不容妥协的。&lt;/p&gt;&#xA;&lt;p&gt;了解法学硕士为何产生此类幻觉至关重要，尤其是在需要高信任度和准确性的场景中部署它们时。重要的是要认识到法学硕士不是一个结构化数据库；它是一个结构化的数据库。它的功能更像是一个预测文本引擎，根据概率模式而不是事实数据生成内容。&lt;/p&gt;</description>
      <pubDate>Tue, 27 Aug 2024 20:00:04 +0000</pubDate>
    </item>
    <item>
      <title>【Documenting a Java WebSocket API Using Smart-Doc】使用 Smart-Doc 记录 Java WebSocket API</title>
      <link>https://dzone.com/articles/generate-java-websocket-api-documentation-using-smart-doc</link>
      <description>【&lt;p&gt;Smart-Doc is a powerful documentation generation tool that helps developers easily create clear and detailed API documentation for Java projects. With the growing popularity of &lt;span spellcheck=&#34;false&#34;&gt;&lt;code&gt;WebSocket&lt;/code&gt;&lt;/span&gt; technology, Smart-Doc has added support for &lt;span spellcheck=&#34;false&#34;&gt;&lt;code&gt;WebSocket&lt;/code&gt;&lt;/span&gt; interfaces starting from version 3.0.7. This article will detail how to use Smart-Doc to generate Java WebSocket interface documentation and provide a complete example of a WebSocket server.&lt;/p&gt;&#xA;&lt;h2&gt;Overview of WebSocket Technology&lt;/h2&gt;&#xA;&lt;p&gt;First, let&#39;s briefly understand WebSocket technology. The WebSocket protocol provides a full-duplex communication channel, making data exchange between the client and server simpler and more efficient. In Java, developers can easily implement WebSocket servers and clients using &lt;span spellcheck=&#34;false&#34;&gt;&lt;code&gt;JSR 356: Java API for WebSocket&lt;/code&gt;&lt;/span&gt;.&lt;/p&gt;】&lt;p&gt;Smart-Doc是一款功能强大的文档生成工具，可以帮助开发人员轻松为Java项目创建清晰详细的API文档。随着 &lt;spanpellcheck=&#34;false&#34;&gt;&lt;code&gt;WebSocket&lt;/code&gt;&lt;/span&gt; 技术的日益普及，Smart-Doc 增加了对 &lt;spanpellcheck=&#34;false&#34;&gt;&lt;code&gt;WebSocket&lt;/code&gt; 的支持&lt;/span&gt; 接口从3.0.7版本开始。本文将详细介绍如何使用Smart-Doc生成Java WebSocket接口文档，并提供一个完整的WebSocket服务器示例。&lt;/p&gt;&#xA;&lt;h2&gt;WebSocket 技术概述&lt;/h2&gt;&#xA;&lt;p&gt;首先我们简单了解一下WebSocket技术。 WebSocket协议提供了全双工的通信通道，使得客户端和服务器之间的数据交换更加简单、高效。在 Java 中，开发人员可以使用 &lt;spanpellcheck=&#34;false&#34;&gt;&lt;code&gt;JSR 356：Java API for WebSocket&lt;/code&gt;&lt;/span&gt; 轻松实现 WebSocket 服务器和客户端。&lt;/p&gt;</description>
      <pubDate>Wed, 28 Aug 2024 13:00:07 +0000</pubDate>
    </item>
    <item>
      <title>【Java Concurrency: Visibility and Synchronized】Java 并发：可见性和同步</title>
      <link>https://dzone.com/articles/java-concurrency-visibility-and-synchronized</link>
      <description>【&lt;p&gt;Previously, we examined the &lt;a href=&#34;https://dzone.com/articles/java-concurrency-the-happens-before-guarantee&#34;&gt;happens before&lt;/a&gt; guarantee in Java. This guarantee gives us confidence when we write multithreaded programs with regard to the re-ordering of statements that can happen. In this post, we shall focus on variable visibility between two threads and what happens when we change a variable that is shared.&lt;/p&gt;&#xA;&lt;h2&gt;Code Examination&lt;/h2&gt;&#xA;&lt;p&gt;Let’s examine the following code snippet:&lt;/p&gt;】&lt;p&gt;之前，我们检查了 Java 中的&lt;a href=&#34;https://dzone.com/articles/java-concurrency-the-happens-before-guarantee&#34;&gt;发生在&lt;/a&gt;之前的保证。当我们编写多线程程序时，这种保证使我们对可能发生的语句重新排序充满信心。在这篇文章中，我们将重点关注两个线程之间的变量可见性以及更改共享变量时会发生什么。&lt;/p&gt;&#xA;&lt;h2&gt;代码检查&lt;/h2&gt;&#xA;&lt;p&gt;让我们检查以下代码片段：&lt;/p&gt;</description>
      <pubDate>Wed, 28 Aug 2024 18:00:08 +0000</pubDate>
    </item>
    <item>
      <title>【Advanced Techniques in Automated Threat Detection】自动威胁检测的先进技术</title>
      <link>https://dzone.com/articles/advanced-techniques-in-automated-threat-detection</link>
      <description>【&lt;p dir=&#34;ltr&#34;&gt;In the fast-paced and constantly evolving digital landscape of today, bad actors are always looking for newer and better methods to launch their attacks. As cybercriminal tactics evolve, they develop more sophisticated malware, more convincing scams, and attacks that are designed specifically to evade known security measures.&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;With this in mind, it is vital for organizations to invest in more advanced automated tools and solutions to go “from threat identification to eradication and remediation with as few humans in the loop as possible.” Taking advantage of emerging technologies and sophisticated measures can aid organizations in automating these processes to an extent and saving time, labor, and other resources that can run thin when relying solely on humans to handle threats.&lt;/p&gt;】&lt;p dir=&#34;ltr&#34;&gt;在当今快节奏且不断发展的数字环境中，不良行为者总是在寻找更新、更好的方法来发起攻击。随着网络犯罪策略的发展，他们开发出更复杂的恶意软件、更有说服力的骗局以及专门为逃避已知安全措施而设计的攻击。&lt;​​/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;考虑到这一点，组织投资更先进的自动化工具和解决方案至关重要，以“从威胁识别到消除和补救，并以尽可能少的人员参与”。利用新兴技术和复杂的措施可以帮助组织在一定程度上实现这些流程的自动化，并节省时间、劳动力和其他在仅依靠人类来处理威胁时可能会耗尽的资源。&lt;/p&gt;</description>
      <pubDate>Wed, 28 Aug 2024 16:00:06 +0000</pubDate>
    </item>
    <item>
      <title>【Effortless Concurrency: Leveraging the Actor Model in Financial Transaction Systems】轻松并发：在金融交易系统中利用参与者模型</title>
      <link>https://dzone.com/articles/concurrency-in-financial-transaction-systems</link>
      <description>【&lt;h2 dir=&#34;ltr&#34;&gt;Introduction to the Problem&lt;/h2&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;Managing concurrency in financial transaction systems is one of the most complex challenges faced by developers and system architects. Concurrency issues arise when multiple transactions are processed simultaneously, which can lead to potential conflicts and data inconsistencies. These issues manifest in various forms, such as overdrawn accounts, duplicate transactions, or mismatched records, all of which can severely undermine the system&#39;s reliability and trustworthiness.&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;In the financial world, where the stakes are exceptionally high, even a single error can result in significant financial losses, regulatory violations, and reputational damage to the organization. Consequently, it is critical to implement robust mechanisms to handle concurrency effectively, ensuring the system&#39;s integrity and reliability.&lt;/p&gt;】&lt;h2 dir=&#34;ltr&#34;&gt;问题简介&lt;/h2&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;管理金融交易系统中的并发性是开发人员和系统架构师面临的最复杂的挑战之一。当同时处理多个事务时，就会出现并发问题，这可能会导致潜在的冲突和数据不一致。这些问题以多种形式表现出来，例如透支账户、重复交易或不匹配的记录，所有这些都会严重损害系统的可靠性和可信度。&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;在风险极高的金融领域，即使是一个错误也可能导致重大财务损失、违反监管规定以及组织声誉受损。因此，实施稳健的机制来有效处理并发、确保系统的完整性和可靠性至关重要。&lt;/p&gt;</description>
      <pubDate>Wed, 28 Aug 2024 12:00:15 +0000</pubDate>
    </item>
    <item>
      <title>【How to Setup Multi-Primary Istio in EKS and AKS for Production】如何在 EKS 和 AKS 中设置多主 Istio 以进行生产</title>
      <link>https://dzone.com/articles/setup-multi-primary-istio-in-eks-and-aks-for-production</link>
      <description>【&lt;p dir=&#34;ltr&#34;&gt;Many large enterprises like retail and banks are adopting open-source Istio service mesh to abstract and better manage the security and network of microservices. To either tackle cost, achieve HA/DR, or improve latency, they apply multi-cloud and multi-cluster strategies in their production system.&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;Implementing Istio in a multi-cloud environment can be tricky, and architects often take time for experimentation. In this blog, we will discuss various ways to achieve multi-cloud and multicluster configuration for Istio implementation and also guide you through the steps to set up primary-primary multicluster Istio in EKS and AKS&lt;/p&gt;】&lt;p dir=&#34;ltr&#34;&gt;零售和银行等许多大型企业正在采用开源 Istio 服务网格来抽象和更好地管理微服务的安全性和网络。为了解决成本问题、实现 HA/DR 或改善延迟，他们在生产系统中应用多云和多集群策略。&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;在多云环境中实施 Istio 可能很棘手，架构师通常需要时间进行试验。在本博客中，我们将讨论实现 Istio 实施的多云和多集群配置的各种方法，并指导您完成在 EKS 和 AKS 中设置主-主多集群 Istio 的步骤&lt;/p&gt;</description>
      <pubDate>Tue, 27 Aug 2024 21:00:05 +0000</pubDate>
    </item>
    <item>
      <title>【Enhancing Software Quality with Checkstyle and PMD: A Practical Guide】使用 Checkstyle 和 PMD 提高软件质量：实用指南</title>
      <link>https://dzone.com/articles/enhancing-software-quality-with-checkstyle-and-pmd</link>
      <description>【&lt;p data-line-end=&#34;3&#34; data-line-start=&#34;2&#34;&gt;It is widely agreed that maintaining a high-quality standard in software development is crucial for any project. However, the approach to achieving this level of quality needs further discussion. One highly effective method for ensuring quality is through software design or &lt;a href=&#34;https://dzone.com/articles/enterprise-architecture-governance-a-holistic-view&#34;&gt;architecture governance&lt;/a&gt;. In this article, I will explain how you can use two powerful tools — Checkstyle and PMD — to establish and enforce coding standards, thus improving your project’s overall code quality and maintainability.&lt;/p&gt;&#xA;&lt;h2 data-line-end=&#34;5&#34; data-line-start=&#34;4&#34;&gt;&lt;a&gt;&lt;/a&gt;Understanding Checkstyle and PMD&lt;/h2&gt;&#xA;&lt;p data-line-end=&#34;7&#34; data-line-start=&#34;6&#34;&gt;&lt;strong&gt;Checkstyle&lt;/strong&gt; is a development tool that helps you and your team establish a consistent code style standard across your project. By setting rules for code formatting, naming conventions, and other stylistic aspects, Checkstyle enforces a baseline for code quality that all team members must adhere to. This consistency is crucial, especially in large teams or projects with multiple contributors.&lt;/p&gt;】&lt;p data-line-end=&#34;3&#34; data-line-start=&#34;2&#34;&gt;人们普遍认为，保持软件开发的高质量标准对于任何项目都至关重要。然而，实现这种质量水平的方法需要进一步讨论。确保质量的一种高效方法是通过软件设计或&lt;a href=&#34;https://dzone.com/articles/enterprise-architecture-governance-a-holistic-view&#34;&gt;架构治理&lt;/a&gt;。在本文中，我将解释如何使用两个强大的工具（Checkstyle 和 PMD）来建立和执行编码标准，从而提高项目的整体代码质量和可维护性。&lt;/p&gt;&#xA;&lt;h2 data-line-end=&#34;5&#34; data-line-start=&#34;4&#34;&gt;&lt;a&gt;&lt;/a&gt;了解 Checkstyle 和 PMD&lt;/h2&gt;&#xA;&lt;p data-line-end=&#34;7&#34; data-line-start=&#34;6&#34;&gt;&lt;strong&gt;Checkstyle&lt;/strong&gt; 是一款开发工具，可帮助您和您的团队在整个项目中建立一致的代码样式标准。通过设置代码格式、命名约定和其他风格方面的规则，Checkstyle 强制执行所有团队成员都必须遵守的代码质量基线。这种一致性至关重要，尤其是在大型团队或具有多个贡献者的项目中。&lt;/p&gt;</description>
      <pubDate>Wed, 28 Aug 2024 11:00:10 +0000</pubDate>
    </item>
    <item>
      <title>【How to Dockerize a React App With Vite: Step-by-Step Guide】如何使用 Vite 对 React 应用进行 Docker 化：分步指南</title>
      <link>https://dzone.com/articles/how-to-dockerize-a-react-app-with-vite</link>
      <description>【&lt;p&gt;In this article, I’ll show you how to Dockerize a React application built with Vite. We’ll go through:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA; &lt;li data-selectable-paragraph=&#34;&#34;&gt;Configuring Vite for Docker&lt;/li&gt;&#xA; &lt;li data-selectable-paragraph=&#34;&#34;&gt;Creating the Dockerfile&lt;/li&gt;&#xA; &lt;li data-selectable-paragraph=&#34;&#34;&gt;Creating the Docker Compose file&lt;/li&gt;&#xA; &lt;li data-selectable-paragraph=&#34;&#34;&gt;Building and running the Docker Container&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;By the end of this article, you’ll have a portable React app ready to deploy in any environment.&lt;/p&gt;】&lt;p&gt;在本文中，我将向您展示如何 Dockerize 使用 Vite 构建的 React 应用程序。我们将介绍：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA; &lt;li data-selectable-paragraph=&#34;&#34;&gt;为 Docker 配置 Vite&lt;/li&gt;&#xA; &lt;li data-selectable-paragraph=&#34;&#34;&gt;创建 Dockerfile&lt;/li&gt;&#xA; &lt;li data-selectable-paragraph=&#34;&#34;&gt;创建 Docker Compose 文件&lt;/li&gt;&#xA; &lt;li data-selectable-paragraph=&#34;&#34;&gt;构建并运行 Docker 容器&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;读完本文后，您将拥有一个可在任何环境中部署的便携式 React 应用。&lt;/p&gt;</description>
      <pubDate>Wed, 28 Aug 2024 17:00:08 +0000</pubDate>
    </item>
    <item>
      <title>【The Evolution of Conversational AI: Blending Determinism With Dynamism】对话式人工智能的演变：将决定论与动态相结合</title>
      <link>https://dzone.com/articles/conversational-ai-blending-determinism-with-dynamism</link>
      <description>【&lt;p&gt;Conversational AI agents have come a long way from their early days of simple, scripted interactions. With the explosion of large language models (LLMs) like GPT-3, Gemini, and beyond, the landscape of human-computer interaction is undergoing a significant transformation.&lt;/p&gt;&#xA;&lt;p&gt;These AI agents are increasingly expected to mimic human-like interactions, which demands a delicate balance between deterministic (convergent) workflows and dynamic, creative responses (divergent). This dual approach is redefining how these agents function across various domains, including education, customer service, and personal assistance.&lt;/p&gt;】&lt;p&gt;对话式 AI 代理与早期的简单脚本交互相比已经取得了长足的进步。随着 GPT-3、Gemini 等大型语言模型 (LLM) 的爆炸式增长，人机交互的格局正在发生重大转变。&lt;/p&gt;&#xA;&lt;p&gt;人们越来越期望这些人工智能代理能够模仿类人交互，这需要确定性（收敛）工作流程与动态、创造性响应（发散）之间的微妙平衡。这种双重方法正在重新定义这些代理在各个领域的运作方式，包括教育、客户服务和个人协助。&lt;/p&gt;</description>
      <pubDate>Wed, 28 Aug 2024 15:00:07 +0000</pubDate>
    </item>
  </channel>
</rss>