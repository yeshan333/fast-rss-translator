<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DZone.com Feed</title>
    <link>https://feeds.dzone.com/home</link>
    <description>Recent posts on DZone.com</description>
    <item>
      <title>【GraphQL vs REST — Which Is Better?】GraphQL 与 REST — 哪个更好？</title>
      <link>https://dzone.com/articles/graphql-vs-rest-which-is-better</link>
      <description>【&lt;p data-selectable-paragraph=&#34;&#34;&gt;GraphQL and REST are two of the most popular API frameworks currently in use, with GraphQL seeing increasing adoption. GraphQL was developed by Facebook to address key challenges in REST APIs, particularly in reducing latency for mobile applications. The debate over which is better continues within the developer community, with strong arguments on both sides.&lt;/p&gt;&#xA;&lt;p data-selectable-paragraph=&#34;&#34;&gt;The choice between GraphQL or REST depends on the type of application being built. &lt;a href=&#34;https://dzone.com/articles/understanding-graphql-an-introduction&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;GraphQL&lt;/a&gt; addresses latency issues caused by over-fetching and under-fetching, and provides built-in support for real-time updates. On the other hand, &lt;a href=&#34;https://dzone.com/articles/when-its-time-to-give-rest-a-rest&#34;&gt;REST&lt;/a&gt; leverages HTTP constructs for caching, rate control, and telemetry, allowing these concerns to be handled at the platform layer rather than the application layer.&lt;/p&gt;】&lt;p data-selectable-paragraph=&#34;&#34;&gt;GraphQL 和 REST 是当前使用的两种最流行的 API 框架，其中 GraphQL 的采用率越来越高。 GraphQL 由 Facebook 开发，旨在解决 REST API 中的关键挑战，特别是在减少移动应用程序的延迟方面。关于哪一个更好的争论在开发者社区中仍在继续，双方都有激烈的争论。&lt;/p&gt;&#xA;&lt;p data-selectable-paragraph=&#34;&#34;&gt;GraphQL 或 REST 之间的选择取决于正在构建的应用程序的类型。 &lt;a href=&#34;https://dzone.com/articles/understand-graphql-an-introduction&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;GraphQL&lt;/a&gt; 解决了过度获取和获取不足导致的延迟问题，并提供了对实时更新的内置支持。另一方面，&lt;a href=&#34;https://dzone.com/articles/when-its-time-to-give-rest-a-rest&#34;&gt;REST&lt;/a&gt; 利用 HTTP 结构进行缓存、速率控制和遥测，从而允许在平台层而不是应用程序层处理这些问题。&lt;/p&gt;</description>
      <pubDate>Tue, 27 Jan 2026 20:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Building an Internal Document Search Tool with Retrieval-Augmented Generation (RAG)】使用检索增强生成 (RAG) 构建内部文档搜索工具</title>
      <link>https://dzone.com/articles/building-an-internal-document-search-tool-with-ret</link>
      <description>【&lt;h2 data-end=&#34;253&#34; data-start=&#34;216&#34;&gt;Why RAG Matters Now&lt;/h2&gt;&#xA;&lt;p data-end=&#34;678&#34; data-start=&#34;255&#34;&gt;&lt;a href=&#34;https://dzone.com/articles/navigating-the-llm-landscape-a-comparative-analysi&#34;&gt;Large language models (LLMs)&lt;/a&gt; have shown how far generative systems can go. They draft text, answer questions, and even support software development. Yet they have a clear weakness. Models trained on public data often hallucinate and almost always lack access to company-specific knowledge (Ji et al., 2023). Relying only on pre-trained knowledge is risky when answers must be exact, such as in finance, healthcare, or HR policies.&lt;/p&gt;&#xA;&lt;p data-end=&#34;1214&#34; data-start=&#34;680&#34;&gt;&lt;a href=&#34;https://dzone.com/articles/mastering-retrieval-augmented-generation&#34;&gt;Retrieval-Augmented Generation, or RAG&lt;/a&gt;, has emerged as a practical solution. Instead of expecting the model to know everything, RAG connects the model to external sources of truth (Lewis et al., 2020). A user query is matched with relevant documents, and the model generates a response grounded in those documents. This approach closes the gap between general intelligence and domain expertise. The open question for many developers is whether RAG is just a patch for hallucination, or if it is the foundation for enterprise-ready AI.&lt;/p&gt;】&lt;h2 data-end=&#34;253&#34; data-start=&#34;216&#34;&gt;为什么 RAG 现在很重要&lt;/h2&gt;&#xA;&lt;p data-end=&#34;678&#34; data-start=&#34;255&#34;&gt;&lt;a href=&#34;https://dzone.com/articles/navigating-the-llm-landscape-a-comparative-analysi&#34;&gt;大型语言模型 (LLM)&lt;/a&gt; 已经展示了生成系统可以走多远。他们起草文本、回答问题，甚至支持软件开发。但他们有一个明显的弱点。根据公共数据训练的模型经常产生幻觉，并且几乎总是无法获取公司特定的知识（Ji 等人，2023）。当答案必须准确时，例如在金融、医疗保健或人力资源政策中，仅依赖预先训练的知识是有风险的。&lt;/p&gt;&#xA;&lt;p data-end=&#34;1214&#34; data-start=&#34;680&#34;&gt;&lt;a href=&#34;https://dzone.com/articles/mastering-retrieval-augmented- Generation&#34;&gt;检索增强生成 (RAG)&lt;/a&gt; 已成为一种实用的解决方案。 RAG 并没有期望模型了解一切，而是将模型与外部事实来源联系起来（Lewis 等人，2020）。用户查询与相关文档相匹配，模型生成基于这些文档的响应。这种方法缩小了一般情报和领域专业知识之间的差距。对于许多开发人员来说，一个悬而未决的问题是，RAG 是否只是一个幻觉补丁，或者它是否是企业级人工智能的基础。&lt;/p&gt;</description>
      <pubDate>Tue, 27 Jan 2026 19:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Cost-Aware GenAI Architecture: Caching, Model Routing, and Token Budgets That Don’t Explode】具有成本意识的 GenAI 架构：缓存、模型路由和不会爆炸的代币预算</title>
      <link>https://dzone.com/articles/cost-aware-genai-architecture</link>
      <description>【&lt;p data-end=&#34;287&#34; data-start=&#34;137&#34;&gt;Shipping GenAI is easy. Shipping it without a surprise bill, latency spikes, and “why did it call the big model for that?” incidents is the hard part.&lt;/p&gt;&#xA;&lt;p data-end=&#34;417&#34; data-start=&#34;289&#34;&gt;This article is a practical architecture pattern for cost control as a first-class system requirement — built around three levers:&lt;/p&gt;】&lt;p data-end=&#34;287&#34; data-start=&#34;137&#34;&gt;运送 GenAI 非常简单。运送它时没有意外的账单，延迟峰值，以及“为什么它为此调用大模型？”事件是最困难的部分。&lt;/p&gt;&#xA;&lt;p data-end=&#34;417&#34; data-start=&#34;289&#34;&gt;本文是一种实用的架构模式，将成本控制作为一流的系统需求 - 围绕三个杠杆构建：&lt;/p&gt;</description>
      <pubDate>Tue, 27 Jan 2026 18:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Designing Mathematical Software for Humans】为人类设计数学软件</title>
      <link>https://dzone.com/articles/designing-mathematical-software-for-humans</link>
      <description>【&lt;p&gt;When we build developer tools, we tend to optimize for performance and API consistency. When we build mathematical tools, we have to optimize for something rarer: &lt;em&gt;clarity of reasoning&lt;/em&gt;. Writing software for mathematicians, researchers, and educators requires a different mindset. It’s not just about whether the code runs fast; it’s about whether the code &lt;em&gt;thinks&lt;/em&gt; the way the user does.&lt;/p&gt;&#xA;&lt;p&gt;This realization struck me while designing a &lt;a href=&#34;https://dzone.com/articles/python-packages-for-validating-database-migration&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;Python package&lt;/a&gt; for combinatorial graph theory called &lt;a href=&#34;https://pypi.org/project/chipfiring/&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;&lt;code&gt;chipfiring&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;. What began as a niche research tool soon became an exercise in human-centered software design. The lessons, however, apply far beyond graph theory. Whether you’re writing a symbolic algebra engine, a geometry toolkit, or a probability simulator, the same principles can help you craft mathematical software that people actually &lt;em&gt;understand&lt;/em&gt;.&lt;/p&gt;】&lt;p&gt;当我们构建开发人员工具时，我们倾向于针对性能和 API 一致性进行优化。当我们构建数学工具时，我们必须针对更罕见的东西进行优化：&lt;em&gt;推理的清晰度&lt;/em&gt;。为数学家、研究人员和教育工作者编写软件需要不同的思维方式。这不仅仅是代码运行速度是否快的问题；而是代码运行速度是否快的问题。关键在于代码是否按照用户的方式思考。&lt;/p&gt;&#xA;&lt;p&gt;在为组合图论设计一个名为&lt;a href=&#34;https://pypi.org/project/chipfiring/&#34; rel=&#34;noopener noreferrer&#34;的&lt;a href=&#34;https://dzone.com/articles/python-packages-for-validating-database-migration&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;Python包&lt;/a&gt;时，我突然意识到这一点target=&#34;_blank&#34;&gt;&lt;strong&gt;&lt;code&gt;芯片点火&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;。最初只是一种利基研究工具，很快就成为以人为本的软件设计的一种实践。然而，这些教训的适用范围远远超出了图论。无论您是在编写符号代数引擎、几何工具包还是概率模拟器，相同的原理都可以帮助您制作人们实际上&lt;em&gt;理解&lt;/em&gt;的数学软件。&lt;/p&gt;</description>
      <pubDate>Tue, 27 Jan 2026 17:00:08 +0000</pubDate>
    </item>
    <item>
      <title>【Implementing HTTPS Two-Way Authentication in Android Using Delphi XE10.x】使用Delphi XE10.x在Android中实现HTTPS双向身份验证</title>
      <link>https://dzone.com/articles/implementing-https-two-way-authentication-in-andro</link>
      <description>【&lt;p&gt;I have an HTTPS cloud server. After a mobile app sends a request, it receives the content returned by the server. The server stores a self-made CA and a server certificate.&lt;/p&gt;&#xA;&lt;div class=&#34;codeMirror-wrapper newest&#34; contenteditable=&#34;false&#34;&gt;&#xA; &lt;div contenteditable=&#34;false&#34;&gt;&#xA;  &lt;div class=&#34;codeHeader&#34;&gt;&#xA;   &lt;div class=&#34;nameLanguage&#34;&gt;&#xA;    Vue.js Component&#xA;   &lt;/div&gt;&lt;i class=&#34;icon-cancel-circled-1 cm-remove&#34;&gt;&amp;nbsp;&lt;/i&gt;&#xA;  &lt;/div&gt;&#xA;  &lt;div class=&#34;codeMirror-code--wrapper&#34; data-code=&#34;const https = require(&#39;https&#39;);&#xA;var fs = require(&#39;fs&#39;);&#xA;var options = {&#xA;key: fs.readFileSync(&amp;quot;./myserver.key&amp;quot;),&#xA;    cert: fs.readFileSync(&#39;./myserver.crt&#39;),&#xA;ca: fs.readFileSync(&#39;./MyCARoot.crt&#39;), &#xA;    requestCert: true,&#xA;rejectUnauthorized:true&#xA; &#xA;};&#34; data-lang=&#34;script/x-vue&#34;&gt;&#xA;   &lt;pre&gt;&lt;code lang=&#34;script/x-vue&#34;&gt;const https = require(&#39;https&#39;);&#xA;var fs = require(&#39;fs&#39;);&#xA;var options = {&#xA;key: fs.readFileSync(&#34;./myserver.key&#34;),&#xA;    cert: fs.readFileSync(&#39;./myserver.crt&#39;),&#xA;ca: fs.readFileSync(&#39;./MyCARoot.crt&#39;), &#xA;    requestCert: true,&#xA;rejectUnauthorized:true&#xA; &#xA;};&lt;/code&gt;&lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA; &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;&lt;br&gt;&lt;/p&gt;】&lt;p&gt;我有一个 HTTPS 云服务器。移动应用发送请求后，会接收服务器返回的内容。服务器端保存了一个自制的CA和服务器证书。&lt;/p&gt;&#xA;&lt;div class=&#34;codeMirror-wrapper 最新&#34; contenteditable=&#34;false&#34;&gt;&#xA; &lt;div contenteditable=&#34;false&#34;&gt;&#xA;  &lt;div 类=“codeHeader”&gt;&#xA;   &lt;div class=&#34;nameLanguage&#34;&gt;&#xA;    Vue.js 组件&#xA;   &lt;/div&gt;&lt;i class=&#34;icon-cancel-circled-1 cm-remove&#34;&gt; &lt;/i&gt;&#xA;  &lt;/div&gt;&#xA;  &lt;div class=&#34;codeMirror-code--wrapper&#34; data-code=&#34;const https = require(&#39;https&#39;);&#xA;var fs = require(&#39;fs&#39;);&#xA;变量选项= {&#xA;键： fs.readFileSync(&#34;./myserver.key&#34;),&#xA;    证书： fs.readFileSync(&#39;./myserver.crt&#39;),&#xA;ca: fs.readFileSync(&#39;./MyCARoot.crt&#39;), &#xA;    请求证书：真实，&#xA;拒绝未经授权：true&#xA; &#xA;};”数据-lang =“脚本/x-vue”&gt;&#xA;   &lt;pre&gt;&lt;code lang=&#34;script/x-vue&#34;&gt;const https = require(&#39;https&#39;);&#xA;var fs = require(&#39;fs&#39;);&#xA;变量选项= {&#xA;键： fs.readFileSync(&#34;./myserver.key&#34;),&#xA;    证书： fs.readFileSync(&#39;./myserver.crt&#39;),&#xA;ca: fs.readFileSync(&#39;./MyCARoot.crt&#39;), &#xA;    请求证书：真实，&#xA;拒绝未经授权：true&#xA; &#xA;};&lt;/code&gt;&lt;/pre&gt;&#xA;  &lt;/div&gt;&#xA; &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;&lt;br&gt;&lt;/p&gt;</description>
      <pubDate>Tue, 27 Jan 2026 16:00:11 +0000</pubDate>
    </item>
    <item>
      <title>【Versioning Lies: A Date Contract Is a Promise That Never Breaks】版本控制谎言：日期合同是永不违背的承诺</title>
      <link>https://dzone.com/articles/date-based-api-versioning-contract</link>
      <description>【&lt;p dir=&#34;ltr&#34;&gt;URI versioning, such as /v1/foo, is one of the most used methods for versioning APIs. Clients can easily comprehend it, but as your API develops, it may become challenging to manage. However, a date versioned header-based API versioning can be a little more opaque for clients, but when done properly, it provides flexibility and maintainability.&amp;nbsp;&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;Let’s get a gist of both approaches.&lt;/p&gt;】&lt;p dir=&#34;ltr&#34;&gt;URI 版本控制（例如 /v1/foo）是最常用的 API 版本控制方法之一。客户可以轻松理解它，但随着 API 的开发，管理可能会变得困难。然而，基于日期版本的基于标头的 API 版本控制对于客户端来说可能有点不透明，但如果做得正确，它可以提供灵活性和可维护性。 &lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;让我们了解一下这两种方法的要点。&lt;/p&gt;</description>
      <pubDate>Tue, 27 Jan 2026 15:00:09 +0000</pubDate>
    </item>
    <item>
      <title>【Edge-First AI Architecture: Designing Low-Latency, Offline-Capable Intelligence】边缘优先人工智能架构：设计低延迟、离线智能</title>
      <link>https://dzone.com/articles/edge-first-ai-low-latency-offline-capable-intelligence</link>
      <description>【&lt;p data-end=&#34;317&#34; data-start=&#34;201&#34;&gt;Most &lt;a href=&#34;https://dzone.com/articles/what-makes-ai-powered-mobile-apps-stand-out-in-tod&#34;&gt;mobile AI features&lt;/a&gt; silently depend on a “good enough” network. That’s fine on your office Wi-Fi. It’s not fine:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA; &lt;li data-end=&#34;335&#34; data-start=&#34;321&#34;&gt;On spotty 3G&lt;/li&gt;&#xA; &lt;li data-end=&#34;353&#34; data-start=&#34;338&#34;&gt;In the subway&lt;/li&gt;&#xA; &lt;li data-end=&#34;395&#34; data-start=&#34;356&#34;&gt;In a warehouse with terrible coverage&lt;/li&gt;&#xA; &lt;li data-end=&#34;445&#34; data-start=&#34;398&#34;&gt;When your cloud endpoint is down or throttled&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p data-end=&#34;554&#34; data-start=&#34;447&#34;&gt;If your “AI feature” turns into a spinner or a generic error in those cases, users will stop trusting it.&lt;/p&gt;】&lt;p data-end=&#34;317&#34; data-start=&#34;201&#34;&gt;大多数&lt;a href=&#34;https://dzone.com/articles/what-makes-ai-powered-mobile-apps-stand-out-in-tod&#34;&gt;移动人工智能功能&lt;/a&gt;默默地依赖于“足够好”的网络。这对于您办公室的 Wi-Fi 来说没问题。这不太好：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA; &lt;li data-end=&#34;335&#34; data-start=&#34;321&#34;&gt;不稳定的 3G&lt;/li&gt;&#xA; &lt;li data-end=&#34;353&#34; data-start=&#34;338&#34;&gt;在地铁里&lt;/li&gt;&#xA; &lt;li data-end=&#34;395&#34; data-start=&#34;356&#34;&gt;位于覆盖范围极差的仓库中&lt;/li&gt;&#xA; &lt;li data-end=&#34;445&#34; data-start=&#34;398&#34;&gt;当您的云端点关闭或受到限制时&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p data-end=&#34;554&#34; data-start=&#34;447&#34;&gt;如果您的“人工智能功能”在这些情况下变成了旋转或一般错误，用户将不再信任它。&lt;/p&gt;</description>
      <pubDate>Tue, 27 Jan 2026 14:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【The Rise of Platform Engineering: How Internal Developer Platforms Are Replacing Traditional DevOps】平台工程的兴起：内部开发人员平台如何取代传统的 DevOps</title>
      <link>https://dzone.com/articles/rise-of-platform-engineering-how-internal-dev-platforms</link>
      <description>【&lt;p data-end=&#34;732&#34; data-start=&#34;201&#34;&gt;Platform engineering has shed its experimental veneer. What began as isolated attempts by infrastructure teams to tame cloud sprawl — ServiceNow tickets piling up, Terraform modules copy-pasted across repositories, engineers slacking each other at 11 PM about which IAM role grants ECR access — has calcified into something defensible, something you can budget for. Internal Developer Platforms aren’t theoretical anymore. They’re the substrate on which organizations either scale gracefully or collapse under their own tooling weight.&lt;/p&gt;&#xA;&lt;p data-end=&#34;1090&#34; data-start=&#34;734&#34;&gt;The shift feels less like a revolution and more like exhausted pragmatism. You build platforms because the alternative — letting every squad maintain its own Jenkins pipeline, its own Ansible playbooks, its own mental model of how secrets propagate from Vault to pods — becomes untenable somewhere between your third acquisition and your fiftieth microservice.&lt;/p&gt;】&lt;p data-end=&#34;732&#34; data-start=&#34;201&#34;&gt;平台工程已经褪去了其实验性的外表。最初是基础设施团队为遏制云蔓延而进行的孤立尝试——ServiceNow 票证堆积、Terraform 模块在存储库中复制粘贴、工程师在晚上 11 点就哪个 IAM 角色授予 ECR 访问权限互相偷懒——现在已经变成了可以防御的、可以预算的东西。内部开发者平台不再是理论上的。它们是组织要么优雅地扩展，要么因自身工具的重量而崩溃的基础。&lt;/p&gt;&#xA;&lt;p data-end=&#34;1090&#34; data-start=&#34;734&#34;&gt;这种转变感觉不像一场革命，而更像是疲惫不堪的实用主义。您构建平台是因为替代方案（让每个团队维护自己的 Jenkins 管道、自己的 Ansible 剧本以及秘密如何从 Vault 传播到 pod 的心智模型）在您的第三次收购和第 50 个微服务之间变得站不住脚。&lt;/p&gt;</description>
      <pubDate>Tue, 27 Jan 2026 13:00:13 +0000</pubDate>
    </item>
    <item>
      <title>【An Introduction to the Four Pillars of Observability】可观察性的四大支柱简介</title>
      <link>https://dzone.com/articles/introduction-to-the-four-pillars-of-observability</link>
      <description>【&lt;p data-end=&#34;596&#34; data-start=&#34;199&#34;&gt;It is a quiet Tuesday afternoon until the latency spikes begin. In the world of modern software engineering, we have moved far beyond the era of simple server monitoring. We no longer just “build and hope.” Instead, we strive for &lt;strong data-end=&#34;455&#34; data-start=&#34;429&#34;&gt;Continuous Reliability&lt;/strong&gt;, a state where our systems are designed to be interrogated, understood, and improved in real time. This is the essence of &lt;strong data-end=&#34;595&#34; data-start=&#34;578&#34;&gt;Observability&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;p data-end=&#34;873&#34; data-start=&#34;598&#34;&gt;To truly master a running system, we must look through four distinct lenses, often called &lt;a href=&#34;https://dzone.com/articles/opentelemetry-moves-past-the-three-pillars&#34;&gt;the pillars of telemetry&lt;/a&gt;. Each provides a different chapter of the story, and together, they offer a level of visibility that transforms production from a “black box” into an open book.&lt;/p&gt;】&lt;p data-end=&#34;596&#34; data-start=&#34;199&#34;&gt;这是一个安静的周二下午，直到延迟高峰开始。在现代软件工程的世界中，我们已经远远超出了简单服务器监控的时代。我们不再只是“建设和希望”。相反，我们努力追求&lt;strong data-end=&#34;455&#34; data-start=&#34;429&#34;&gt;持续可靠性&lt;/strong&gt;，在这种状态下，我们的系统旨在被实时询问、理解和改进。这是&lt;strong data-end=&#34;595&#34; data-start=&#34;578&#34;&gt;可观察性&lt;/strong&gt;的本质。&lt;/p&gt;&#xA;&lt;p data-end=&#34;873&#34; data-start=&#34;598&#34;&gt;要真正掌握跑步系统，我们必须审视四个不同的视角，通常称为&lt;a href=&#34;https://dzone.com/articles/opentelemetry-moves-past-the- Three-pillars&#34;&gt;遥测的支柱&lt;/a&gt;。每个都提供了故事的不同章节，并且它们一起提供了一定程度的可见性，将生产从“黑匣子”转变为一本开放的书。&lt;/p&gt;</description>
      <pubDate>Tue, 27 Jan 2026 12:00:09 +0000</pubDate>
    </item>
    <item>
      <title>【Building an AI Agent Traffic Management Platform: APISIX AI Gateway in Practice】构建AI代理流量管理平台：APISIX AI网关实践</title>
      <link>https://dzone.com/articles/building-ai-agent-traffic-management-apisix-ai-gateway</link>
      <description>【&lt;h2&gt;Introduction: The Turning Point from Dispersed Traffic to Intelligent Governance&lt;/h2&gt;&#xA;&lt;p&gt;Since early 2025, within a leading global appliance giant, multiple business lines have introduced numerous large language models (LLMs). The R&amp;amp;D department needed coding assistants to improve efficiency, the marketing team focused on content generation, and the smart product team aimed to integrate conversational capabilities into home appliances. The variety of models rapidly expanded to include both self-built solutions like DeepSeek and Qwen, as well as proprietary models from multiple cloud service providers.&lt;/p&gt;&#xA;&lt;p&gt;However, this rapid expansion soon exposed new bottlenecks: &lt;strong&gt;fragmented inference traffic&lt;/strong&gt;, &lt;strong&gt;chaotic scheduling&lt;/strong&gt;, &lt;strong&gt;rising operational costs&lt;/strong&gt;, and &lt;strong&gt;uncontrollable stability issues&lt;/strong&gt;.&lt;/p&gt;】&lt;h2&gt;简介：从分散交通到智能治理的转折点&lt;/h2&gt;&#xA;&lt;p&gt;自 2025 年初以来，一家全球领先的家电巨头的多个业务线引入了众多大型语言模型 (LLM)。研发部门需要编码助手来提高效率，营销团队专注于内容生成，智能产品团队的目标是将对话功能集成到家电中。模型的种类迅速扩展，包括 DeepSeek 和 Qwen 等自建解决方案，以及来自多个云服务提供商的专有模型。&lt;/p&gt;&#xA;&lt;p&gt;然而，这种快速扩张很快就暴露出新的瓶颈：&lt;strong&gt;推理流量碎片化&lt;/strong&gt;、&lt;strong&gt;调度混乱&lt;/strong&gt;、&lt;strong&gt;运营成本上升&lt;/strong&gt;以及&lt;strong&gt;稳定性问题不可控&lt;/strong&gt;。&lt;/p&gt;</description>
      <pubDate>Mon, 26 Jan 2026 20:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>