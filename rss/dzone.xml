<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DZone.com Feed</title>
    <link>https://feeds.dzone.com/home</link>
    <description>Recent posts on DZone.com</description>
    <item>
      <title>【Secure AI Architecture for Payments: From Risk Signals to Real-Time Decisions】安全支付人工智能架构：从风险信号到实时决策</title>
      <link>https://dzone.com/articles/secure-ai-architecture-for-payments</link>
      <description>【&lt;p data-end=&#34;514&#34; data-start=&#34;289&#34;&gt;Most users tap &lt;strong data-end=&#34;311&#34; data-start=&#34;304&#34;&gt;Pay&lt;/strong&gt; on Android and assume it’s simple. Behind that one tap, your app is juggling PCI rules, &lt;a href=&#34;https://dzone.com/articles/iot-needs-to-get-serious-about-security&#34;&gt;device security&lt;/a&gt;, fraud checks, and 3DS — usually inside a tight latency budget measured in hundreds of milliseconds.&lt;/p&gt;&#xA;&lt;p data-end=&#34;669&#34; data-start=&#34;516&#34;&gt;If all of that logic lives in scattered checks, random API calls, and duplicated business rules, it will eventually break in subtle (and expensive) ways.&lt;/p&gt;】&lt;p data-end=&#34;514&#34; data-start=&#34;289&#34;&gt;大多数用户在 Android 上点击&lt;strong data-end=&#34;311&#34; data-start=&#34;304&#34;&gt;支付&lt;/strong&gt;并认为这很简单。在这一次点击之后，您的应用程序正在处理 PCI 规则、&lt;a href=&#34;https://dzone.com/articles/iot-needs-to-get-serious-about-security&#34;&gt;设备安全&lt;/a&gt;、欺诈检查和 3DS - 通常在以数百毫秒为单位的严格延迟预算内。&lt;/p&gt;&#xA;&lt;p data-end=&#34;669&#34; data-start=&#34;516&#34;&gt;如果所有逻辑都存在于分散的检查、随机的 API 调用和重复的业务规则中，它最终会以微妙（且昂贵）的方式出现故障。&lt;/p&gt;</description>
      <pubDate>Fri, 23 Jan 2026 20:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【PostgreSQL Trigram Similarity vs. Pattern Matching: A Performance Comparison】PostgreSQL 三元组相似度与模式匹配：性能比较</title>
      <link>https://dzone.com/articles/postgresql-trigram-similarity-vs-pattern-matching</link>
      <description>【&lt;p data-end=&#34;685&#34; data-start=&#34;285&#34;&gt;A &lt;a href=&#34;https://dzone.com/articles/postgresql-full-text-search-vs-pattern-matching&#34;&gt;previous article&lt;/a&gt; presented a performance comparison between PostgreSQL Full-Text Search (FTS) and plain pattern matching, especially in cases where a given piece of text is searched across multiple attributes of multiple entities. In brief, the conclusion was that FTS is significantly faster, while pattern matching offers greater flexibility, a wider range of applicability, and higher precision.&lt;/p&gt;&#xA;&lt;p data-end=&#34;938&#34; data-start=&#34;687&#34;&gt;The present article aims to continue this analysis, which is worthwhile when implementing global search solutions, in order to increase objectivity regarding the applicability of these methods and to help programmers make informed choices more easily.&lt;/p&gt;】&lt;p data-end=&#34;685&#34; data-start=&#34;285&#34;&gt;&lt;a href=&#34;https://dzone.com/articles/postgresql-full-text-search-vs-pattern-matching&#34;&gt;上一篇文章&lt;/a&gt;介绍了 PostgreSQL 全文搜索 (FTS) 和纯模式匹配之间的性能比较，特别是在跨多个实体的多个属性搜索给定文本片段的情况下。简而言之，结论是 FTS 速度明显更快，而模式匹配提供了更大的灵活性、更广泛的适用性和更高的精度。&lt;/p&gt;&#xA;&lt;p data-end=&#34;938&#34; data-start=&#34;687&#34;&gt;本文旨在继续这种分析，这在实现全局搜索解决方案时是值得的，以提高这些方法的适用性的客观性，并帮助程序员更轻松地做出明智的选择。&lt;/p&gt;</description>
      <pubDate>Fri, 23 Jan 2026 19:00:15 +0000</pubDate>
    </item>
    <item>
      <title>【Reimagining Innovation: How Citizen Application Development is Reshaping the Modern Enterprise】重新构想创新：公民应用程序开发如何重塑现代企业</title>
      <link>https://dzone.com/articles/how-citizen-application-development-reshapes-modern-enterprise</link>
      <description>【&lt;p&gt;&lt;span data-contrast=&#34;auto&#34; lang=&#34;EN-US&#34;&gt;Enterprise technology is shifting faster than ever. Innovation used to live behind a ticket. Business ideas waited in line while central teams balanced priorities, budgets, and release windows. Citizen application development changes that rhythm. With&amp;nbsp;&lt;/span&gt;&lt;a href=&#34;https://qentelli.com/thought-leadership/insights/the-fusion-of-ai-and-low-code&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;span data-contrast=&#34;none&#34; lang=&#34;EN-US&#34;&gt;&lt;span data-ccp-charstyle=&#34;Hyperlink&#34;&gt;modern low-code and no-code platforms&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-contrast=&#34;auto&#34; lang=&#34;EN-US&#34;&gt;, people closest to the problem can create secure, integrated apps and automations that move work forward. The result is faster cycles, clearer ownership, and a pipeline of improvements that does not stall when bandwidth is tight.&amp;nbsp;&lt;/span&gt;&lt;span data-ccp-props=&#34;{&amp;quot;335551550&amp;quot;:6,&amp;quot;335551620&amp;quot;:6}&#34;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;span data-contrast=&#34;auto&#34; lang=&#34;EN-US&#34;&gt;According to&amp;nbsp;&lt;/span&gt;&lt;a href=&#34;https://www.gartner.com/en/documents/6379243&#34; rel=&#34;noreferrer noopener&#34; target=&#34;_blank&#34;&gt;&lt;span data-contrast=&#34;none&#34; lang=&#34;EN-US&#34;&gt;&lt;span data-ccp-charstyle=&#34;Hyperlink&#34;&gt;Gartner&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-contrast=&#34;auto&#34; lang=&#34;EN-US&#34;&gt;, citizen application development platforms accelerate digital transformation by empowering business users to independently build applications beyond traditional IT boundaries.&amp;nbsp;&lt;/span&gt;&lt;span data-ccp-props=&#34;{&amp;quot;335551550&amp;quot;:6,&amp;quot;335551620&amp;quot;:6}&#34;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;】&lt;p&gt;&lt;span data-contrast=&#34;auto&#34; lang=&#34;EN-US&#34;&gt;企业技术的变化速度比以往任何时候都快。创新曾经是靠门票来实现的。商业想法排队等待，而中央团队平衡优先级、预算和发布窗口。公民应用程序的开发改变了这种节奏。 &lt;/span&gt;&lt;a href=&#34;https://qentelli.com/thought-leadership/insights/the-fusion-of-ai-and-low-code&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;span data-contrast=&#34;none&#34; lang=&#34;EN-US&#34;&gt;&lt;span data-ccp-charstyle=&#34;Hyperlink&#34;&gt;现代低代码和无代码平台&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-contrast=&#34;auto&#34; lang=&#34;EN-US&#34;&gt;，最接近问题的人可以创建安全、集成的应用程序和自动化，从而推动工作向前发展。其结果是更快的周期、更清晰的所有权以及在带宽紧张时不会停滞的改进管道。 &lt;/span&gt;&lt;span data-ccp-props=&#34;{&#34;335551550&#34;:6,&#34;335551620&#34;:6}&#34;&gt; &lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;span data-contrast=&#34;auto&#34; lang=&#34;EN-US&#34;&gt;根据&lt;/span&gt;&lt;a href=&#34;https://www.gartner.com/en/documents/6379243&#34; rel=&#34;noreferrer noopener&#34; target=&#34;_blank&#34;&gt;&lt;span data-contrast=&#34;none&#34; lang=&#34;EN-US&#34;&gt;&lt;span data-ccp-charstyle=&#34;Hyperlink&#34;&gt;Gartner&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-contrast=&#34;auto&#34; lang=&#34;EN-US&#34;&gt;公民应用程序开发平台使业务用户能够超越传统 IT 边界独立构建应用程序，从而加速数字化转型。 &lt;/span&gt;&lt;span data-ccp-props=&#34;{&#34;335551550&#34;:6,&#34;335551620&#34;:6}&#34;&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <pubDate>Fri, 23 Jan 2026 18:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Vibe Coding Part 3 — Building a Data Quality Framework in Scala and PySpark】Vibe 编码第 3 部分 — 在 Scala 和 PySpark 中构建数据质量框架</title>
      <link>https://dzone.com/articles/vibe-coding-data-quality-framework-scala-pyspark</link>
      <description>【&lt;p data-end=&#34;692&#34; data-start=&#34;223&#34;&gt;A couple of years ago, I developed a class-based &lt;a href=&#34;https://dzone.com/articles/build-data-quality-framework&#34;&gt;Data Quality (DQ) framework &lt;/a&gt;in Scala. After some time, I became part of an accelerator framework that dealt with many data engineering tasks, with data quality being one set of activities. After considering multiple factors, it was decided that the framework would be built using Python. Given that we wanted to &lt;a href=&#34;https://dzone.com/articles/ultimate-database-scaling-cheatsheet&#34;&gt;handle large datasets and ensure scalability&lt;/a&gt;, we decided to implement the data quality framework in PySpark.&lt;/p&gt;&#xA;&lt;p data-end=&#34;928&#34; data-start=&#34;694&#34;&gt;Using the Scala-based DQ framework as a stepping stone and foundation, I developed an equivalent DQ framework in PySpark. The framework was successful, with the DQ functionality implemented as a Python library and packaged as a wheel.&lt;/p&gt;】&lt;p data-end=&#34;692&#34; data-start=&#34;223&#34;&gt;几年前，我在 Scala 中开发了一个基于类的&lt;a href=&#34;https://dzone.com/articles/build-data-quality-framework&#34;&gt;数据质量 (DQ) 框架&lt;/a&gt;。一段时间后，我成为了处理许多数据工程任务的加速器框架的一部分，其中数据质量是一组活动。经过多方面考虑，最终决定使用Python来构建该框架。鉴于我们希望&lt;a href=&#34;https://dzone.com/articles/ultimate-database-scaling-cheatsheet&#34;&gt;处理大型数据集并确保可扩展性&lt;/a&gt;，我们决定在 PySpark 中实现数据质量框架。&lt;/p&gt;&#xA;&lt;p data-end=&#34;928&#34; data-start=&#34;694&#34;&gt;使用基于 Scala 的 DQ 框架作为踏脚石和基础，我在 PySpark 中开发了一个等效的 DQ 框架。该框架取得了成功，DQ 功能作为 Python 库实现并打包为轮子。&lt;/p&gt;</description>
      <pubDate>Fri, 23 Jan 2026 17:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【How a Standardized Logistics Protocol Can Unlock AI&#39;s Full Potential in Supply Chain】标准化物流协议如何释放人工智能在供应链中的全部潜力</title>
      <link>https://dzone.com/articles/standardized-logistics-protocol-ai-supply-chain</link>
      <description>【&lt;p&gt;&lt;strong&gt;The logistics industry stands at an inflection point.&lt;/strong&gt; While artificial intelligence promises to revolutionize supply chain operations — from real-time route optimization to autonomous fleet coordination — a fundamental bottleneck prevents these innovations from reaching their full potential: &lt;strong&gt;the lack of a standardized protocol for logistics providers to communicate.&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2&gt;The NxM Problem in Modern Logistics&lt;/h2&gt;&#xA;&lt;p&gt;Consider this scenario:&lt;/p&gt;】&lt;p&gt;&lt;strong&gt;物流行业正处于拐点。&lt;/strong&gt;虽然人工智能有望彻底改变供应链运营（从实时路线优化到自主车队协调），但一个根本瓶颈阻碍了这些创新充分发挥潜力：&lt;strong&gt;缺乏供物流提供商通信的标准化协议。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;小时&gt;&#xA;&lt;h2&gt;现代物流中的 NxM 问题&lt;/h2&gt;&#xA;&lt;p&gt;考虑这种情况：&lt;/p&gt;</description>
      <pubDate>Fri, 23 Jan 2026 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Securing AI/ML Workloads in the Cloud: Integrating DevSecOps with MLOps】保护云中 AI/ML 工作负载的安全：将 DevSecOps 与 MLOps 集成</title>
      <link>https://dzone.com/articles/securing-aiml-workloads-in-the-cloud-integrating-d</link>
      <description>【&lt;p&gt;The security engineer&#39;s face went pale when she pulled up the access logs. Her team had deployed a &lt;a href=&#34;https://dzone.com/articles/real-time-fraud-detection-using-ai-and-ml&#34;&gt;fraud detection model&lt;/a&gt; to production three weeks earlier — standard stuff, containerized inference running on Kubernetes. Except someone had been quietly exfiltrating the model weights for the past eleven days through an API endpoint they&#39;d forgotten to lock down. The attacker got everything: training architecture, parameter files, even the feature engineering pipeline. Six months of competitive advantage, gone.&lt;/p&gt;&#xA;&lt;p&gt;This happened at a Series C fintech in San Francisco last April. I know because I helped them write the incident report.&lt;/p&gt;】&lt;p&gt;当安全工程师调出访问日志时，脸色变得苍白。她的团队三周前就将&lt;a href=&#34;https://dzone.com/articles/real-time-fraud-detection-using-ai-and-ml&#34;&gt;欺诈检测模型&lt;/a&gt;部署到生产环境中——标准的东西，在 Kubernetes 上运行的容器化推理。除了有人在过去 11 天里通过他们忘记锁定的 API 端点悄悄泄露模型权重之外。攻击者获得了一切：训练架构、参数文件，甚至特征工程管道。六个月的竞争优势消失了。&lt;/p&gt;&#xA;&lt;p&gt;去年四月，这件事发生在旧金山的一家 C 轮金融科技公司。我知道，因为我帮他们写了事件报告。&lt;/p&gt;</description>
      <pubDate>Fri, 23 Jan 2026 15:00:09 +0000</pubDate>
    </item>
    <item>
      <title>【Docker Runtime Escape: Why Mounting docker.sock Is Worse Than Running Privileged Containers】Docker 运行时逃逸：为什么挂载 docker.sock 比运行特权容器更糟糕</title>
      <link>https://dzone.com/articles/docker-runtime-escape-docker-sock</link>
      <description>【&lt;p&gt;Most DevOps engineers know that running containers with the privileged flag is dangerous. It&#39;s one of those things we all learn early on - never use privileged mode in production unless you absolutely have to. Security teams flag it, auditors complain about it, and for good reason.&lt;/p&gt;&#xA;&lt;p&gt;But here&#39;s what scared me recently: there&#39;s something much worse that&#39;s being mounted into production containers every single day, and most teams don&#39;t realize the risk. I&#39;m talking about mounting the Docker socket into containers.&lt;/p&gt;】&lt;p&gt;大多数 DevOps 工程师都知道使用特权标志运行容器是危险的。这是我们很早就学到的事情之一——除非绝对必要，否则永远不要在生产中使用特权模式。安全团队标记它，审计员抱怨它，并且有充分的理由。&lt;/p&gt;&#xA;&lt;p&gt;但最近让我害怕的是：每天都有一些更糟糕的东西被安装到生产容器中，而大多数团队没有意识到其中的风险。我正在谈论将 Docker 套接字安装到容器中。&lt;/p&gt;</description>
      <pubDate>Fri, 23 Jan 2026 14:00:08 +0000</pubDate>
    </item>
    <item>
      <title>【Design and Implementation of Cloud-Native Microservice Architectures for Scalable Insurance Analytics Platforms】可扩展保险分析平台的云原生微服务架构的设计和实现</title>
      <link>https://dzone.com/articles/cloud-native-microservice-architectures-for-scalable-insurance-analytics</link>
      <description>【&lt;h2&gt;&lt;strong&gt;Objective Statement&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;This study proposes a scalable, modular, and cloud-native microservice architecture tailored for the insurance industry. The goal is to enable rapid enterprise-wide analytics adoption, seamless AI integration, and real-time data processing through containerization, orchestration, and service-based deployment models that enhance scalability, agility, and system resilience.&lt;/p&gt;&#xA;&lt;h2&gt;&lt;strong&gt;Problem Context&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;Although insurers are among the earliest adopters of artificial intelligence, fewer than 10% have successfully scaled AI initiatives beyond pilot programs.&amp;nbsp;&lt;/p&gt;】&lt;h2&gt;&lt;strong&gt;目标陈述&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;这项研究提出了一种专为保险行业量身定制的可扩展、模块化和云原生微服务架构。目标是通过容器化、编排和基于服务的部署模型来实现企业范围内的快速分析采用、无缝人工智能集成和实时数据处理，从而增强可扩展性、敏捷性和系统弹性。&lt;/p&gt;&#xA;&lt;h2&gt;&lt;strong&gt;问题背景&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;尽管保险公司是最早采用人工智能的公司之一，但只有不到 10% 的保险公司成功地将人工智能计划扩展到试点项目之外。 &lt;/p&gt;</description>
      <pubDate>Fri, 23 Jan 2026 13:00:07 +0000</pubDate>
    </item>
    <item>
      <title>【The Future of AI Integration: Why Model Context Protocol Is the New API】AI 集成的未来：为什么模型上下文协议是新的 API</title>
      <link>https://dzone.com/articles/future-of-ai-integration-why-mcp-is-the-new-api</link>
      <description>【&lt;h2&gt;&lt;strong&gt;&lt;img style=&#34;width: 808px;&#34; class=&#34;fr-fic fr-dib lazyload&#34; data-image=&#34;true&#34; data-new=&#34;false&#34; data-sizeformatted=&#34;921.4 kB&#34; data-mimetype=&#34;image/png&#34; data-creationdate=&#34;1762864860796&#34; data-creationdateformatted=&#34;11/11/2025 12:41 PM&#34; data-type=&#34;temp&#34; data-url=&#34;https://dz2cdn1.dzone.com/storage/temp/18743055-1762864861299.png&#34; data-modificationdate=&#34;null&#34; data-size=&#34;921414&#34; data-name=&#34;1762864861299.png&#34; data-id=&#34;18743055&#34; data-src=&#34;https://dz2cdn1.dzone.com/storage/temp/18743055-1762864861299.png&#34; alt=&#34;Infographic of MCP and its integration relationships &#34;&gt;Introduction: From Custom-Code Chaos to Connection Harmony&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;For decades, connecting software systems meant one thing: &lt;strong&gt;custom code&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Every new integration required a new connector, another adapter, and a fresh set of maintenance nightmares. The same pain has now reached the world of AI. Developers are writing endless glue code to make large language models (LLMs) talk to databases, APIs, and business tools, and every integration is slightly different.&lt;/p&gt;】&lt;h2&gt;&lt;strong&gt;&lt;img style=&#34;宽度：808px;&#34; class =“fr-fic fr-dib lazyload”data-image =“true”data-new =“false”data-sizeformatted =“921.4 kB”data-mimetype =“image/png”data-creationdate =“1762864860796”data-creationdateformatted =“11/11/2025 12:41 PM”data-type =“temp” data-url =“https://dz2cdn1.dzone.com/storage/temp/18743055-1762864861299.png”data-modificationdate =“null”data-size =“921414”data-name =“1762864861299.png”data-id =“18743055” data-src=&#34;https://dz2cdn1.dzone.com/storage/temp/18743055-1762864861299.png&#34; alt=&#34;MCP 及其集成关系信息图&#34;&gt;简介：从自定义代码混乱到连接和谐&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;几十年来，连接软件系统意味着一件事：&lt;strong&gt;自定义代码&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;每个新的集成都需要一个新的连接器、另一个适配器和一系列新的维护噩梦。如今，同样的痛苦也降临到了人工智能领域。开发人员正在编写无尽的粘合代码，以使大型语言模型 (LLM) 与数据库、API 和业务工具对话，并且每次集成都略有不同。&lt;/p&gt;</description>
      <pubDate>Fri, 23 Jan 2026 12:00:08 +0000</pubDate>
    </item>
    <item>
      <title>【Scaling PostgreSQL Reads: Implementing Read-Your-Write Consistency Using WAL-Based Replica Routing】扩展 PostgreSQL 读取：使用基于 WAL 的副本路由实现读你写的一致性</title>
      <link>https://dzone.com/articles/postgresql-read-your-write-wal-replica-routing</link>
      <description>【&lt;p data-end=&#34;735&#34; data-start=&#34;325&#34;&gt;At a previous company, we hit a point where our PostgreSQL database was clearly becoming a bottleneck. The primary instance was responsible for every user-facing search request, including some heavy queries from long-time users with years of historical data. CPU usage kept climbing, and before long, we were already running on the largest instance size available. Vertical scaling had officially hit its limit.&lt;/p&gt;&#xA;&lt;p data-end=&#34;854&#34; data-start=&#34;737&#34;&gt;Naturally, the next step was to introduce read replicas. On paper, it sounded straightforward. In reality, it wasn’t.&lt;/p&gt;】&lt;p data-end=&#34;735&#34; data-start=&#34;325&#34;&gt;在之前的一家公司，我们遇到了 PostgreSQL 数据库明显成为瓶颈的问题。主实例负责每个面向用户的搜索请求，包括来自具有多年历史数据的长期用户的一些繁重查询。 CPU 使用率持续攀升，不久之后，我们就已经在可用的最大实例大小上运行。垂直缩放正式达到极限。&lt;/p&gt;&#xA;&lt;p data-end=&#34;854&#34; data-start=&#34;737&#34;&gt;自然，下一步就是引入只读副本。从纸面上看，这听起来很简单。事实上，事实并非如此。&lt;/p&gt;</description>
      <pubDate>Thu, 22 Jan 2026 20:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>