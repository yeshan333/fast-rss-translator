<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DZone.com Feed</title>
    <link>https://feeds.dzone.com/home</link>
    <description>Recent posts on DZone.com</description>
    <item>
      <title>【When Coalesce Is Slower Than Repartition: A Spark Performance Paradox】当合并慢于重新分区时：Spark 性能悖论</title>
      <link>https://dzone.com/articles/spark-coalesce-vs-repartition-performance</link>
      <description>【&lt;p&gt;If you&#39;ve worked with Apache Spark, you&#39;ve probably heard the conventional wisdom: &#34;Use &lt;code&gt;coalesce()&lt;/code&gt; instead of &lt;code&gt;repartition()&lt;/code&gt; when reducing partitions — it&#39;s faster because it avoids a shuffle.&#34; This advice appears in documentation, blog posts, and is repeated across Stack Overflow threads. But what if I told you this isn&#39;t always true?&lt;/p&gt;&#xA;&lt;p&gt;In a recent production workload, I discovered that using &lt;code&gt;repartition()&lt;/code&gt; instead of &lt;code&gt;coalesce()&lt;/code&gt; resulted in a &lt;strong&gt;33% performance improvement&lt;/strong&gt; (16 minutes vs. 23 minutes) when writing data to fewer partitions. This counterintuitive result reveals an important lesson about Spark&#39;s Catalyst optimizer that every Spark developer should understand.&lt;/p&gt;】&lt;p&gt;如果您使用过 Apache Spark，您可能听说过这样的传统观点：“减少分区时使用 &lt;code&gt;coalesce()&lt;/code&gt; 而不是 &lt;code&gt;repartition()&lt;/code&gt; — 它更快，因为它避免了洗牌。”此建议出现在文档、博客文章中，并且在 Stack Overflow 线程中重复出现。但如果我告诉你这并不总是正确的呢？&lt;/p&gt;&#xA;&lt;p&gt;在最近的生产工作负载中，我发现在将数据写入较少的分区时，使用 &lt;code&gt;repartition()&lt;/code&gt; 而不是 &lt;code&gt;coalesce()&lt;/code&gt; 可以实现&lt;strong&gt;33% 的性能提升&lt;/strong&gt;（分别为 16 分钟和 23 分钟）。这个违反直觉的结果揭示了每个 Spark 开发人员都应该了解的有关 Spark Catalyst 优化器的重要教训。&lt;/p&gt;</description>
      <pubDate>Thu, 30 Oct 2025 19:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【SQL Ledger in SQL Server 2022: Tamper-Evident Audit Trails and Immutable Ledger Tables】SQL Server 2022 中的 SQL Ledger：防篡改审计跟踪和不可变的 Ledger 表</title>
      <link>https://dzone.com/articles/sql-server-ledger-tamper-evident-audit-trails</link>
      <description>【&lt;p&gt;SQL Server 2022 introduced the &lt;strong&gt;Ledger feature&lt;/strong&gt; to meet the growing need for tamper-evident audit trails in regulated and audit-heavy industries such as finance, healthcare, and supply chains. One of the most notable implementations of this feature is the &lt;strong&gt;append-only ledger table&lt;/strong&gt;, which ensures that sensitive data is immutable once added, providing stronger guarantees of integrity and compliance.&amp;nbsp;&lt;/p&gt;&#xA;&lt;p&gt;Below, we incorporate and expand on the example and details from Microsoft&#39;s official article on creating and using append-only ledger tables, showcasing its capabilities to preserve data integrity and support audit scenarios.&lt;/p&gt;】&lt;p&gt;SQL Server 2022 引入了&lt;strong&gt;Ledger 功能&lt;/strong&gt;，以满足金融、医疗保健和供应链等受监管和审计密集型行业对防篡改审计跟踪日益增长的需求。此功能最显着的实现之一是&lt;strong&gt;仅附加账本表&lt;/strong&gt;，它确保敏感数据一旦添加就不可变，从而为完整性和合规性提供更有力的保证。 &lt;/p&gt;&#xA;&lt;p&gt;下面，我们合并并扩展了 Microsoft 官方文章中有关创建和使用仅附加账本表的示例和详细信息，展示了其保持数据完整性和支持审计场景的功能。&lt;/p&gt;</description>
      <pubDate>Thu, 30 Oct 2025 18:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【A Comprehensive Analysis of Async Communication in Microservice Architecture】微服务架构中异步通信全面解析</title>
      <link>https://dzone.com/articles/async-communication-in-microservice-architecture</link>
      <description>【&lt;p data-pm-slice=&#34;1 1 []&#34;&gt;Microservice architecture has become a standard practice for companies, small and large. One of the challenges is communication between different services. I’ve worked with microservices for a decade now, and I’ve seen a lot of people struggle to understand how to implement a proper communication protocol.&amp;nbsp;&lt;/p&gt;&#xA;&lt;p data-pm-slice=&#34;1 1 []&#34;&gt;In this series of articles, I’ll share my knowledge and expertise on async communication in microservices.&lt;/p&gt;】&lt;p data-pm-slice=&#34;1 1 []&#34;&gt;微服务架构已成为大小公司的标准实践。挑战之一是不同服务之间的通信。我已经使用微服务十年了，我看到很多人都在努力理解如何实现正确的通信协议。 &lt;/p&gt;&#xA;&lt;p data-pm-slice=&#34;1 1 []&#34;&gt;在本系列文章中，我将分享我在微服务异步通信方面的知识和专业知识。&lt;/p&gt;</description>
      <pubDate>Thu, 30 Oct 2025 17:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【From Model to Microservice: A Practical Guide to Deploying ML Models as APIs】从模型到微服务：将 ML 模型部署为 API 的实用指南</title>
      <link>https://dzone.com/articles/deploying-ml-models-as-apis</link>
      <description>【&lt;p&gt;You’ve done it. You’ve spent weeks cleaning data, feature engineering, and hyperparameter tuning. You have a Jupyter Notebook showing a beautiful &lt;code&gt;.fit()&lt;/code&gt; and a &lt;code&gt;.predict()&lt;/code&gt; that works perfectly. The model accuracy is 99%. Victory!&lt;/p&gt;&#xA;&lt;p&gt;But now comes the hard part. Your stakeholder asks, &#34;That&#39;s great, but how do we get this into the new mobile app?&#34; Suddenly, the reality hits: a model in a notebook delivers zero business value. To be truly useful, your machine learning model needs to be integrated into applications, and the most robust, scalable way to do so is to deploy it as a Microservice API.&lt;/p&gt;】&lt;p&gt;你已经做到了。您花了数周时间清理数据、特征工程和超参数调整。您有一个 Jupyter Notebook，其中显示了漂亮的 &lt;code&gt;.fit()&lt;/code&gt; 和完美运行的 &lt;code&gt;.predict()&lt;/code&gt;。模型准确率为99%。胜利！&lt;/p&gt;&#xA;&lt;p&gt;但现在困难的部分来了。您的利益相关者会问：“这很好，但是我们如何将其纳入新的移动应用程序中？”突然间，现实袭来：笔记本电脑中的模型带来的商业价值为零。要真正有用，您的机器学习模型需要集成到应用程序中，而最强大、可扩展的方法是将其部署为微服务 API。&lt;/p&gt;</description>
      <pubDate>Thu, 30 Oct 2025 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Keyword vs Semantic Search With AI】关键字与人工智能语义搜索</title>
      <link>https://dzone.com/articles/keyword-vs-semantic-search-with-ai</link>
      <description>【&lt;p&gt;When building a search for an application, you typically face two &lt;strong&gt;broad&lt;/strong&gt; approaches:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA; &lt;li&gt;Traditional keyword-based search — match words exactly or with simple variants.&lt;/li&gt;&#xA; &lt;li&gt;Semantic (or vector) search — match meaning or context using AI embeddings.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;There’s also a hybrid approach, but I will leave that for a future article. Instead, in this post, I’ll walk you through how the two broad approaches work in Python using &lt;a href=&#34;https://mariadb.com/database-topics/ai/&#34; target=&#34;_blank&#34;&gt;MariaDB&lt;/a&gt; and an AI embedding model, highlight where they differ, and show code that you can adapt.&lt;/p&gt;】&lt;p&gt;在构建应用程序搜索时，您通常会面临两种&lt;strong&gt;广泛&lt;/strong&gt;方法：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA; &lt;li&gt;传统的基于关键字的搜索 - 完全匹配单词或简单变体。&lt;/li&gt;&#xA; &lt;li&gt;语义（或矢量）搜索 - 使用 AI 嵌入匹配含义或上下文。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;还有一种混合方法，但我会将其留到以后的文章中。相反，在这篇文章中，我将引导您了解这两种主要方法如何使用 &lt;a href=&#34;https://mariadb.com/database-topics/ai/&#34; target=&#34;_blank&#34;&gt;MariaDB&lt;/a&gt; 和 AI 嵌入模型在 Python 中工作，突出显示它们的不同之处，并显示您可以适应的代码。&lt;/p&gt;</description>
      <pubDate>Thu, 30 Oct 2025 15:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Building Reactive Microservices With Spring WebFlux on Kubernetes】在 Kubernetes 上使用 Spring WebFlux 构建响应式微服务</title>
      <link>https://dzone.com/articles/building-reactive-microservices-with-spring-webflu</link>
      <description>【&lt;p&gt;Migrating from a monolithic Java 8 system to a reactive microservice architecture on Kubernetes allowed us to dramatically improve performance and maintainability. In this article, I’ll share our journey, key Spring Cloud Kubernetes features we adopted, the challenges we faced during development, and the lessons we learned along the way.&lt;/p&gt;&#xA;&lt;h2&gt;Business Logic&lt;/h2&gt;&#xA;&lt;p&gt;We have a data processing logic that streams information into S3 storage using Kafka, Spark Streaming, and Iceberg. Initially, we encountered multiple challenges, such as file optimization issues and Spark’s unpredictable memory behavior. After addressing these issues, we achieved significant cost savings. Once the insert service was completed, we needed to select an appropriate search engine service. We chose Trino as it fulfilled the needs of our data science department. We also serve customers who perform operations on our S3 data, which can result in high system load. Before this modernization, our platform ran on an old monolithic architecture built with Java 8, which created several performance and maintenance challenges.&lt;/p&gt;】&lt;p&gt;从单体 Java 8 系统迁移到 Kubernetes 上的反应式微服务架构使我们能够显着提高性能和可维护性。在这篇文章中，我将分享我们的历程、我们采用的关键 Spring Cloud Kubernetes 功能、我们在开发过程中面临的挑战以及我们在此过程中学到的经验教训。&lt;/p&gt;&#xA;&lt;h2&gt;业务逻辑&lt;/h2&gt;&#xA;&lt;p&gt;我们有一个数据处理逻辑，可以使用 Kafka、Spark Streaming 和 Iceberg 将信息流式传输到 S3 存储中。最初，我们遇到了多种挑战，例如文件优化问题和 Spark 不可预测的内存行为。解决这些问题后，我们实现了显着的成本节省。插入服务完成后，我们需要选择合适的搜索引擎服务。我们选择 Trino 是因为它满足了我们数据科学部门的需求。我们还为对 S3 数据执行操作的客户提供服务，这可能会导致系统负载较高。在这次现代化之前，我们的平台运行在使用 Java 8 构建的旧的整体架构上，这带来了一些性能和维护方面的挑战。&lt;/p&gt;</description>
      <pubDate>Thu, 30 Oct 2025 14:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Improving Developer Productivity With End-to-End GenAI Enablement】通过端到端 GenAI 支持提高开发人员生产力</title>
      <link>https://dzone.com/articles/improving-developer-productivity-genai-enablement</link>
      <description>【&lt;p&gt;This is a very common scenario that every developer can relate to — I am focused on a feature, and suddenly my project buddy requests a PR review or asks for help when a test case is failing. Now, I need to context-switch to help my buddy, or the code review will be delayed.&amp;nbsp;&lt;/p&gt;&#xA;&lt;p&gt;Every engineering team faces the same bottlenecks — context switching, boilerplate work, delayed code reviews, and slow onboarding. The goal is to improve developer enablement and boost productivity through automation. Generative AI amplifies that goal. From writing user stories to generating test cases, GenAI can automate repetitive tasks and provide real-time guidance. But the challenge is to connect all those capabilities cohesively rather than treat them as isolated tools.&lt;/p&gt;】&lt;p&gt;这是每个开发人员都会遇到的一个非常常见的场景 - 我专注于某个功能，突然我的项目伙伴请求 PR 审查或在测试用例失败时寻求帮助。现在，我需要上下文切换来帮助我的伙伴，否则代码审查将被延迟。 &lt;/p&gt;&#xA;&lt;p&gt;每个工程团队都面临着相同的瓶颈——上下文切换、样板工作、延迟的代码审查和缓慢的入职。目标是通过自动化提高开发人员支持并提高生产力。生成式人工智能放大了这一目标。从编写用户故事到生成测试用例，GenAI 可以自动执行重复性任务并提供实时指导。但挑战是将所有这些功能紧密地联系起来，而不是将它们视为孤立的工具。&lt;/p&gt;</description>
      <pubDate>Thu, 30 Oct 2025 13:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【How to Get a Frequency Table of a Categorical Variable as a Data Frame】如何获取分类变量的频率表作为数据框</title>
      <link>https://dzone.com/articles/get-frequency-table-categorical-variable-data-frame</link>
      <description>【&lt;p&gt;Categorical data is data with a predefined set of values. Using “Child,” “Adult,” or “Senior” instead of a person&#39;s age as a number is one example of age categorization. However, before using categorical data, one must know about various forms of categorical data&lt;/p&gt;&#xA;&lt;p&gt;First of all, categorical data may or may not be defined in an order. To say that the size of a box is small, medium, or large means that there is an order described as small &amp;lt; medium &amp;lt; large. The same does not hold for, say, sports equipment, which could also be categorial data, but differentiated by names like dumbbell, grippers, or gloves; that is, you can order the items on any basis. Those that can be ordered are known as “ordinal” while those where there is no such ordering are “nominal” in nature.&lt;/p&gt;】&lt;p&gt;分类数据是具有一组预定义值的数据。使用“儿童”、“成人”或“老年人”代替人的年龄作为数字是年龄分类的一个例子。然而，在使用分类数据之前，必须了解分类数据的各种形式&lt;/p&gt;&#xA;&lt;p&gt;首先，分类数据可能会也可能不会按顺序定义。说盒子的大小是小、中或大意味着存在一个描述为小 &lt; 中 &lt; 大的顺序。对于运动器材来说，情况并非如此，它们也可以是分类数据，但可以通过哑铃、夹具或手套等名称进行区分；也就是说，您可以在任何基础上订购商品。那些可以排序的被称为“序数”，而那些没有这种排序的则本质上是“名义的”。&lt;/p&gt;</description>
      <pubDate>Thu, 30 Oct 2025 12:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Building a New Testing Mindset for AI-Powered Web Apps】为 AI 支持的 Web 应用程序构建新的测试思维</title>
      <link>https://dzone.com/articles/ai-powered-testing-for-web-apps</link>
      <description>【&lt;p&gt;The technology landscape is undergoing a profound transformation. For decades, businesses have relied on traditional web-based software to enhance user experiences and streamline operations. Today, a new wave of innovation is redefining how applications are built, powered by the rise of AI-driven development.&lt;/p&gt;&#xA;&lt;p&gt;However, as leaders adopt AI, a key challenge has emerged: ensuring its quality, trust, and reliability. Unlike traditional systems with clear requirements and predictable outputs, AI introduces complexity and unpredictability, making quality assurance (QA) both more challenging and more critical. Business decision-makers must now rethink their QA strategy and investments to safeguard reputation, reduce risk, and unlock the full potential of intelligent solutions.&lt;/p&gt;】&lt;p&gt;技术格局正在经历深刻的变革。几十年来，企业一直依赖传统的基于网络的软件来增强用户体验并简化运营。如今，在人工智能驱动开发兴起的推动下，新一波创新浪潮正在重新定义应用程序的构建方式。&lt;/p&gt;&#xA;&lt;p&gt;然而，随着领导者采用人工智能，一个关键挑战出现了：确保其质量、信任和可靠性。与具有明确需求和可预测输出的传统系统不同，人工智能引入了复杂性和不可预测性，使得质量保证 (QA) 更具挑战性和更关键。业务决策者现在必须重新考虑他们的质量保证策略和投资，以维护声誉、降低风险并释放智能解决方案的全部潜力。&lt;/p&gt;</description>
      <pubDate>Thu, 30 Oct 2025 11:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【From Autocomplete to Co-Creation: How AI Changes Developing/Debugging Workflows in Engineering】从自动完成到共同创造：人工智能如何改变工程中的开发/调试工作流程</title>
      <link>https://dzone.com/articles/ai-cocreation-developer-debugging-workflows</link>
      <description>【&lt;h2 data-end=&#34;567&#34; data-start=&#34;511&#34;&gt;&lt;strong data-end=&#34;933&#34; data-start=&#34;881&#34;&gt;The Shift to Co-Creation&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;We are in the middle of a new era of software engineering, where AI coding assistants are no longer just autocomplete helpers but valuable collaborators in the development and debugging process. These tools can speed up the creation of scripts, help navigate unfamiliar languages, and reduce the time spent on repetitive tasks. Yet, the engineer’s role remains central: applying expertise, understanding the problem space, and ensuring solutions are accurate, secure, and effective. AI acts as a helping hand that makes the process of creation faster.&lt;/p&gt;&#xA;&lt;p&gt;In this article, I will share several real-time examples to show how AI assistants are changing development and debugging workflows, from scripting with unfamiliar languages to working with complex APIs and debugging.&lt;/p&gt;】&lt;h2 data-end=&#34;567&#34; data-start=&#34;511&#34;&gt;&lt;strong data-end=&#34;933&#34; data-start=&#34;881&#34;&gt;向共同创造的转变&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;我们正处于软件工程的新时代，人工智能编码助手不再只是自动完成助手，而是开发和调试过程中的宝贵合作者。这些工具可以加快脚本的创建速度，帮助导航不熟悉的语言，并减少花在重复性任务上的时间。然而，工程师的角色仍然是核心：应用专业知识、了解问题空间并确保解决方案准确、安全和有效。人工智能充当助力，使创作过程更快。&lt;/p&gt;&#xA;&lt;p&gt;在本文中，我将分享几个实时示例，展示 AI 助手如何改变开发和调试工作流程，从使用不熟悉的语言编写脚本到使用复杂的 API 和调试。&lt;/p&gt;</description>
      <pubDate>Wed, 29 Oct 2025 19:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>