<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DZone.com Feed</title>
    <link>https://feeds.dzone.com/home</link>
    <description>Recent posts on DZone.com</description>
    <item>
      <title>【Facilitate AI-Human Architectural Thinking】促进人工智能-人类建筑思维</title>
      <link>https://dzone.com/articles/facilitate-ai-human-architectural-thinking</link>
      <description>【&lt;p&gt;Architectural thinking or modeling will only be effective when it involves a landscape, decisional, and structural view. People talk a lot about systems thinking, but to ensure a viable architectural model, systems thinking must approach it from the three pillars of thinking.&lt;img data-new=&#34;false&#34; data-mimetype=&#34;image/png&#34; data-creationdateformatted=&#34;08/14/2025 10:25 AM&#34; data-url=&#34;https://dz2cdn1.dzone.com/storage/temp/18584737-1755167110245.png&#34; data-size=&#34;225249&#34; data-id=&#34;18584737&#34; class=&#34;fr-fic fr-dib lazyload&#34; style=&#34;width: 642px;&#34; data-image=&#34;true&#34; data-sizeformatted=&#34;225.2 kB&#34; data-creationdate=&#34;1755167123109&#34; data-type=&#34;temp&#34; data-modificationdate=&#34;null&#34; data-name=&#34;1755167110245.png&#34; data-src=&#34;https://dz2cdn1.dzone.com/storage/temp/18584737-1755167110245.png&#34; alt=&#34;AI-human thinking&#34;&gt;&lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;AI-powered architectural thinking or modeling also requires these three pillars of thinking. Let’s briefly look at each of these from a perspective of &lt;em&gt;enterprise solution architecture&lt;/em&gt; (ESA), which falls somewhere between &lt;em&gt;enterprise architecture&lt;/em&gt; (EA) and &lt;em&gt;solution architecture&lt;/em&gt; (SA).&amp;nbsp;&lt;/p&gt;】&lt;p&gt;架构思维或建模只有在涉及景观、决策和结构视图时才会有效。人们经常谈论系统思维，但为了确保可行的架构模型，系统思维必须从思维的三大支柱出发。&lt;img data-new=&#34;false&#34; data-mimetype=&#34;image/png&#34; data-creationdateformatted=&#34;08/14/2025 10:25 AM&#34; data-url =“https://dz2cdn1.dzone.com/storage/temp/18584737-1755167110245.png”data-size =“225249”data-id =“18584737”class =“fr-fic fr-diblazyload”style =“宽度：642px;” data-image=&#34;true&#34; data-sizeformatted=&#34;225.2 kB&#34; data-creationdate=&#34;1755167123109&#34; data-type=&#34;temp&#34; data-modificationdate=&#34;null&#34; data-name=&#34;1755167110245.png&#34; data-src=&#34;https://dz2cdn1.dzone.com/storage/temp/18584737-1755167110245.png&#34; alt=&#34;AI-人类思维&#34;&gt;&lt;br&gt;&lt;/p&gt;&#xA;&lt;p&gt;人工智能驱动的架构思维或建模也需要这三大思维支柱。让我们从&lt;em&gt;企业解决方案架构&lt;/em&gt; (ESA) 的角度简要地看一下其中的每一个，它介于&lt;em&gt;企业架构&lt;/em&gt; (EA) 和&lt;em&gt;解决方案架构&lt;/em&gt; (SA) 之间。 &lt;/p&gt;</description>
      <pubDate>Wed, 12 Nov 2025 20:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【The Terraform State Locking Migration You Need to Know About: Moving Beyond DynamoDB】您需要了解的 Terraform 状态锁定迁移：超越 DynamoDB</title>
      <link>https://dzone.com/articles/terraform-state-locking-migration-dynamodb</link>
      <description>【&lt;p&gt;If you&#39;ve been working with Terraform for a while, you probably have backend configurations that look something like this scattered across your infrastructure repositories. I know I did. And if you&#39;re like me, you might have missed a pretty significant announcement from HashiCorp that&#39;s going to affect how we handle state locking going forward.&amp;nbsp;&lt;/p&gt;&#xA;&lt;p&gt;Let me save you some future headaches: DynamoDB-based state locking is being deprecated.&lt;/p&gt;】&lt;p&gt;如果您使用 Terraform 一段时间，您的后端配置可能看起来像这样分散在您的基础设施存储库中。我知道我做到了。如果您像我一样，您可能错过了 HashiCorp 的一项非常重要的公告，该公告将影响我们未来处理状态锁定的方式。 &lt;/p&gt;&#xA;&lt;p&gt;让我为您解决一些未来的麻烦：基于 DynamoDB 的状态锁定已被弃用。&lt;/p&gt;</description>
      <pubDate>Wed, 12 Nov 2025 19:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Compose Architecture, Done Right: MVI’s Unidirectional State vs. MVVM】正确组合架构：MVI 的单向状态与 MVVM</title>
      <link>https://dzone.com/articles/compose-architecture-mvi-vs-mvvm</link>
      <description>【&lt;h2&gt;Why MVVM Feels Clunky With Compose&lt;/h2&gt;&#xA;&lt;p&gt;MVVM grew up with XML and two-way data binding. Compose flipped the model: the UI is a function of state. That mismatch shows up in common pain points:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA; &lt;li&gt;&lt;strong&gt;Scattered state&lt;/strong&gt;. Multiple &lt;code&gt;LiveData&lt;/code&gt;/&lt;code&gt;Flows&lt;/code&gt; (loading, items, error, searchQuery, pagination…) mutate independently. Compose recomposes at odd times, and you start sprinkling &lt;code&gt;remember { mutableStateOf(...) }&lt;/code&gt; to “patch” glitches.&lt;/li&gt;&#xA; &lt;li&gt;&lt;strong&gt;The “SingleLiveEvent” saga&lt;/strong&gt;. One-off actions (toasts, navigation, snackbars) don’t belong in your steady UI state, so teams hack in special event wrappers that break on configuration change or process death.&lt;/li&gt;&#xA; &lt;li&gt;&lt;strong&gt;Implicit writes&lt;/strong&gt;. With two-way binding (or eager observers), it’s not obvious who changed what. You hunt bugs by grepping for setters.&lt;/li&gt;&#xA; &lt;li&gt;&lt;strong&gt;Brittle tests&lt;/strong&gt;. It’s hard to reproduce a bug when the state can be mutated from multiple pathways and observer races.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2&gt;What MVI Brings to the Table&lt;/h2&gt;&#xA;&lt;p&gt;Model-View-Intent (MVI) is just a strict recipe for &lt;strong&gt;unidirectional data flow&lt;/strong&gt;:&lt;/p&gt;】&lt;h2&gt;为什么 MVVM 使用 Compose 感觉很笨拙&lt;/h2&gt;&#xA;&lt;p&gt;MVVM 伴随着 XML 和双向数据绑定而成长。 Compose 翻转了模型：UI 是状态的函数。这种不匹配表现在常见的痛点上：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA; &lt;li&gt;&lt;strong&gt;分散状态&lt;/strong&gt;。多个 LiveData/Flows（加载、项目、错误、searchQuery、分页...）独立变化。 Compose 会在奇怪的时间重新组合，然后您开始使用 &lt;code&gt;remember { mutableStateOf(...) }&lt;/code&gt; 来“修补”故障。&lt;/li&gt;&#xA; &lt;li&gt;&lt;strong&gt;“SingleLiveEvent”传奇&lt;/strong&gt;。一次性操作（Toast、导航、小吃栏）不属于稳定的 UI 状态，因此团队会侵入特殊事件包装器，这些包装器会在配置更改或进程死亡时中断。&lt;/li&gt;&#xA; &lt;li&gt;&lt;strong&gt;隐式写入&lt;/strong&gt;。通过双向绑定（或热切的观察者），谁改变了什么并不明显。您可以通过 grep 寻找 setter 来寻找 bug。&lt;/li&gt;&#xA; &lt;li&gt;&lt;strong&gt;脆性测试&lt;/strong&gt;。当状态可以从多个路径和观察者种族中突变时，很难重现错误。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2&gt;MVI 带来什么&lt;/h2&gt;&#xA;&lt;p&gt;模型-视图-意图 (MVI) 只是&lt;strong&gt;单向数据流&lt;/strong&gt;的严格配方：&lt;/p&gt;</description>
      <pubDate>Wed, 12 Nov 2025 18:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【How to Map PostgreSQL JSON Data Types in Java Using asentinel-orm】如何使用 asentinel-orm 在 Java 中映射 PostgreSQL JSON 数据类型</title>
      <link>https://dzone.com/articles/postgresql-json-mapping-java-asentinel-orm</link>
      <description>【&lt;p&gt;It isn’t seldom when software products need to easily and efficiently manage the direct storage and handling of JSON content directly into the underlying database. The purpose of this article is to exemplify how such tasks can be conveniently accomplished via the &lt;code&gt;asentinel-orm&lt;/code&gt;, a lightweight ORM tool built on top of Spring JDBC, which possesses most of the features one would expect from such a project.&lt;/p&gt;&#xA;&lt;p&gt;We will start by defining a simple entity that contains a JSONB column. Then, we will configure a sample application that uses the &lt;code&gt;asentinel-orm&lt;/code&gt; to handle its data access towards a PostgreSQL database that stores such entities. Lastly, we will exemplify and emphasize how the actual JSON data can be queried and stored properly.&lt;/p&gt;】&lt;p&gt;软件产品需要轻松高效地管理 JSON 内容直接存储和处理到底层数据库的情况并不罕见。本文的目的是举例说明如何通过 asentinel-orm 方便地完成此类任务，asentinel-orm 是一种构建在 Spring JDBC 之上的轻量级 ORM 工具，它拥有人们期望从此类项目中获得的大部分功能。&lt;/p&gt;&#xA;&lt;p&gt;我们将首先定义一个包含 JSONB 列的简单实体。然后，我们将配置一个示例应用程序，该应用程序使用 asentinel-orm 来处理对存储此类实体的 PostgreSQL 数据库的数据访问。最后，我们将举例并强调如何正确查询和存储实际的 JSON 数据。&lt;/p&gt;</description>
      <pubDate>Wed, 12 Nov 2025 17:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【From Developer to AI Teammate: Building an Agentic Automation Prototype】从开发人员到 AI 队友：构建代理自动化原型</title>
      <link>https://dzone.com/articles/from-developer-to-ai-teammate-building-an-agentic</link>
      <description>【&lt;h2&gt;&lt;strong&gt;&lt;span&gt;The Problem: Developer Workflows Are Still Too Manual&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;Despite CI/CD, containerization, and mature DevOps practices, developers still spend hours on repetitive, low-value tasks — restarting services, parsing logs, or cross-checking configurations.&lt;/p&gt;&#xA;&lt;p&gt;Common examples include:&lt;/p&gt;】&lt;h2&gt;&lt;strong&gt;&lt;span&gt;问题：开发人员工作流程仍然过于手动&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;尽管有 CI/CD、容器化和成熟的 DevOps 实践，开发人员仍然花费大量时间执行重复性低价值任务 - 重新启动服务、解析日志或交叉检查配置。&lt;/p&gt;&#xA;&lt;p&gt;常见示例包括：&lt;/p&gt;</description>
      <pubDate>Wed, 12 Nov 2025 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【A Developer&#39;s Guide to Mastering Docker Networking Concepts】掌握 Docker 网络概念的开发人员指南</title>
      <link>https://dzone.com/articles/docker-networking-guide-for-developers</link>
      <description>【&lt;p&gt;As developers, our first success with Docker is typically running a single container and accessing it through localhost. While this is a solid beginning, the true strength of containers emerges when you start running multi-container applications. This is also where most developers face challenges.&lt;/p&gt;&#xA;&lt;p&gt;You have a web application in one container and a database in another. How do they communicate?&lt;/p&gt;】&lt;p&gt;作为开发人员，我们使用 Docker 的第一次成功通常是运行单个容器并通过本地主机访问它。虽然这是一个坚实的开始，但当您开始运行多容器应用程序时，容器的真正优势就会显现出来。这也是大多数开发者面临挑战的地方。&lt;/p&gt;&#xA;&lt;p&gt;您在一个容器中有一个 Web 应用程序，在另一个容器中有一个数据库。他们如何沟通？&lt;/p&gt;</description>
      <pubDate>Wed, 12 Nov 2025 15:00:01 +0000</pubDate>
    </item>
    <item>
      <title>【GitLab CI/CD for Tenant-Specific ML Governance: Automating Model Registries in Databricks Unity Catalog on AWS】用于特定于租户的 ML 治理的 GitLab CI/CD：在 AWS 上的 Databricks Unity Catalog 中自动化模型注册表</title>
      <link>https://dzone.com/articles/gitlab-mlops-databricks-unity-catalog</link>
      <description>【&lt;p style=&#34;text-align: left;&#34;&gt;To bring automation to machine learning operations (MLOps) in the &lt;a href=&#34;https://docs.databricks.com/aws/en/data-governance/unity-catalog/&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;Databricks Unity Catalog&lt;/a&gt;, linking up GitLab CI/CD pipelines is revolutionizing the way we govern our data. As of September 2025, the community-driven examples and updates from Databricks show that companies can use GitLab to create isolated model registries for individual tenants, run compliance checks, and deploy ML workflows in a declarative style.&amp;nbsp;&lt;/p&gt;&#xA;&lt;p style=&#34;text-align: left;&#34;&gt;By bridging gaps in traditional data platform operations, this setup brings us one step closer to scalable, secure ML deployments with much less manual intervention.&lt;/p&gt;】&lt;p style=&#34;text-align: left;&#34;&gt;为了在 &lt;a href=&#34;https://docs.databricks.com/aws/en/data-governance/unity-catalog/&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;Databricks Unity Catalog&lt;/a&gt; 中实现机器学习操作 (MLOps) 自动化，连接 GitLab CI/CD 管道正在彻底改变我们管理数据的方式。截至 2025 年 9 月，社区驱动的示例和 Databricks 的更新表明，公司可以使用 GitLab 为各个租户创建隔离的模型注册表、运行合规性检查并以声明式方式部署 ML 工作流程。 &lt;/p&gt;&#xA;&lt;p style=&#34;text-align: left;&#34;&gt;通过弥合传统数据平台操作中的差距，这一设置使我们更接近于可扩展、安全的机器学习部署，并且需要更少的手动干预。&lt;/p&gt;</description>
      <pubDate>Wed, 12 Nov 2025 14:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【AI Code Refactoring: Principles, Techniques, and Benefits】AI 代码重构：原理、技术和好处</title>
      <link>https://dzone.com/articles/ai-code-refactoring-principles-techniques-and-benefits</link>
      <description>【&lt;p dir=&#34;ltr&#34;&gt;Coders will tell you that dealing with messy code is a pain. But starting over is even more of a headache. Luckily, AI can help clean up your code, making it easier to read, faster, and ready for updates. It utilizes machine learning to identify errors, remove unnecessary code, and update your code to the latest standards. This saves time and helps you avoid errors. So, whether you&#39;re fixing old systems or just dealing with tech debt, AI can help.&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;Let&#39;s explore how AI refactors code, the primary methods the employ, and the benefits they offers to coders and companies.&lt;/p&gt;】&lt;p dir=&#34;ltr&#34;&gt;程序员会告诉您，处理混乱的代码是一件痛苦的事情。但重新开始就更让人头疼了。幸运的是，人工智能可以帮助清理你的代码，使其更容易阅读、更快并为更新做好准备。它利用机器学习来识别错误、删除不必要的代码并将代码更新到最新标准。这可以节省时间并帮助您避免错误。因此，无论您是要修复旧系统还是只是处理技术债务，人工智能都可以提供帮助。&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;让我们探讨人工智能如何重构代码、采用的主要方法以及它们为程序员和公司带来的好处。&lt;/p&gt;</description>
      <pubDate>Wed, 12 Nov 2025 13:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【The DSPM Paradox: Perceived Controls for an Uncontrollable Data Landscape】DSPM 悖论：对不可控数据环境的感知控制</title>
      <link>https://dzone.com/articles/the-dspm-paradox-perceived-controls-for-an-uncontrollable-data-landscape</link>
      <description>【&lt;p&gt;Data is always on the move. Data flows across multiple interconnected systems, creating an expanded attack surface that spans Slack messages, browser-based AI tools, cache folders, and distributed cloud workloads.&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;Security teams have long tried to keep up. While traditional tools, such as firewalls, SIEMs, and DLPs, have evolved to address dynamic data flows, they face challenges in environments where data constantly moves across platforms. These tools look at networks. They watch for strange logins. They inspect files as they are being sent in and out of a system. However, the core challenge remains: effectively monitoring and protecting data that is distributed across numerous touchpoints.&lt;/p&gt;】&lt;p&gt;数据始终在移动。数据流经多个互连系统，形成了一个涵盖 Slack 消息、基于浏览器的 AI 工具、缓存文件夹和分布式云工作负载的扩展攻击面。&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;安全团队长期以来一直努力跟上。虽然防火墙、SIEM 和 DLP 等传统工具已经发展到可以解决动态数据流的问题，但它们在数据不断跨平台移动的环境中面临着挑战。这些工具着眼于网络。他们监视奇怪的登录。他们在文件传入和传出系统时检查文件。然而，核心挑战仍然存在：有效监控和保护分布在众多接触点的数据。&lt;/p&gt;</description>
      <pubDate>Wed, 12 Nov 2025 12:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【A Growing Security Concern: Prompt Injection Vulnerabilities in Model Context Protocol Systems】日益严重的安全问题：模型上下文协议系统中的即时注入漏洞</title>
      <link>https://dzone.com/articles/prompt-injection-vulnerabilities-in-mcp-systems</link>
      <description>【&lt;p&gt;Most companies set up their AI document assistant the same way: give it access to the repository, then rely on it to filter results based on user permissions. When someone asks:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA; &lt;p&gt;&#34;&lt;strong&gt;For the security audit, list all documents containing &#39;confidential&#39; in the title&lt;/strong&gt;.&#34;&lt;/p&gt;】&lt;p&gt;大多数公司都以相同的方式设置人工智能文档助手：授予其访问存储库的权限，然后依靠它根据用户权限过滤结果。当有人问：&lt;/p&gt;&#xA;&lt;块引用&gt;&#xA; &lt;p&gt;“&lt;strong&gt;为了进行安全审核，请列出标题中包含“机密”的所有文档&lt;/strong&gt;。”&lt;/p&gt;</description>
      <pubDate>Tue, 11 Nov 2025 20:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>