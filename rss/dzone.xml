<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DZone.com Feed</title>
    <link>https://feeds.dzone.com/home</link>
    <description>Recent posts on DZone.com</description>
    <item>
      <title>【Infusing AI into Your Java Applications】将 AI 融入您的 Java 应用程序</title>
      <link>https://dzone.com/articles/infusing-ai-into-your-java-applications</link>
      <description>【&lt;p&gt;Artificial intelligence (AI) is becoming increasingly pervasive. As an Enterprise Java developer, you might be wondering what value AI can add to your business applications, what tools Java provides to easily do that, and what skills and knowledge you might need to learn. In this article, we equip you with the basic knowledge and skills that you need to start exploring the capabilities of AI to build intelligent and responsive Enterprise Java applications.&lt;/p&gt;&#xA;&lt;p&gt;When we talk about AI in this article, we mean getting responses from a large language model (LLM) based on a request that the Java application sends to the LLM. In our article’s example, we create a simple chatbot that customers can ask for planetary tourist destination recommendations, and then use to book a spaceship to visit them. We demonstrate using Java frameworks like &lt;a href=&#34;https://docs.quarkiverse.io/quarkus-langchain4j/dev/index.html?cid=infoq:press:AW:ai-java-intro&#34;&gt;LangChain4j with Quarkus&lt;/a&gt; to efficiently interact with LLMs and create satisfying applications for end-users.&lt;/p&gt;】&lt;p&gt;人工智能 (AI) 正变得越来越普遍。作为一名企业 Java 开发人员，您可能想知道 AI 可以为您的业务应用程序添加哪些价值、Java 提供哪些工具可以轻松实现这一点，以及您可能需要学习哪些技能和知识。在本文中，我们将为您提供开始探索 AI 功能以构建智能且响应迅速的企业 Java 应用程序所需的基本知识和技能。&lt;/p&gt;&#xA;&lt;p&gt;当我们在本文中讨论 AI 时，我们的意思是根据 Java 应用程序发送到 LLM 的请求从大型语言模型 (LLM) 获取响应。在我们文章的示例中，我们创建了一个简单的聊天机器人，客户可以询问行星旅游目的地的建议，然后用来预订一艘宇宙飞船来参观它们。我们演示了如何使用 &lt;a href=&#34;https://docs.quarkiverse.io/quarkus-langchain4j/dev/index.html?cid=infoq:press:AW:ai-java-intro&#34;&gt;LangChain4j 与 Quarkus&lt;/a&gt; 等 Java 框架与 LLM 进行高效交互，并创建令人满意的应用程序 最终用户。&lt;/p&gt;</description>
      <pubDate>Fri, 10 Oct 2025 19:00:09 +0000</pubDate>
    </item>
    <item>
      <title>【Diving into JNI: My Messy Adventures With C++ in Android】深入 JNI：我在 Android 中使用 C++ 的混乱冒险</title>
      <link>https://dzone.com/articles/diving-into-jni-my-messy-adventures-with-c-in-andr</link>
      <description>【&lt;p&gt;So, I&#39;ve been deep in the trenches with JNI lately (yeah, that Java Native Interface stuff) while working on a project where we had to plug a C++ AI assistant into our Android app. At first, it felt like stepping into a weird twilight zone — half Java, half C++, and all these random edge cases you never think about until you hit them. I remember staring at the stack trace for what felt like hours, realizing that one tiny missed &lt;code&gt;DeleteLocalRef&lt;/code&gt; was enough to crash the whole app. Thought I&#39;d share what actually tripped me up, what worked, and some ways to make life a little less miserable if you ever have to do this.&lt;/p&gt;&#xA;&lt;h2&gt;&lt;strong&gt;What the Hell Is JNI Anyway?&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;JNI is basically the bridge that lets Java (or Kotlin) talk to C/C++ code and vice versa. On Android, it’s the only real way to get heavy lifting done efficiently or access low-level APIs that Java/Kotlin just can&#39;t reach. Honestly, the first time I tried to wrap my head around it, I felt like I was learning a new language on top of Java and C++ at the same time.&lt;/p&gt;】&lt;p&gt;所以，我最近在开发一个项目时深入研究了 JNI（是的，Java Native Interface 的东西），在这个项目中我们必须将 C++ AI 助手插入到我们的 Android 应用程序中。一开始，感觉就像步入了一个奇怪的暮光地带——一半是 Java，一半是 C++，以及所有这些随机的边缘情况，直到你遇到它们为止。我记得盯着堆栈跟踪看了好几个小时，意识到一个微小的错过 &lt;code&gt;DeleteLocalRef&lt;/code&gt; 就足以导致整个应用程序崩溃。我想我应该分享一下到底是什么让我绊倒了，什么是有效的，以及一些让生活变得不那么痛苦的方法（如果你不得不这样做的话）。&lt;/p&gt;&#xA;&lt;h2&gt;&lt;strong&gt;JNI 到底是什么？&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;JNI 基本上是让 Java（或 Kotlin）与 C/C++ 代码对话的桥梁，反之亦然。在 Android 上，这是高效完成繁重工作或访问 Java/Kotlin 无法访问的低级 API 的唯一真正方法。老实说，当我第一次尝试理解它时，我感觉自己正在同时学习 Java 和 C++ 之上的一门新语言。&lt;/p&gt;</description>
      <pubDate>Fri, 10 Oct 2025 18:00:12 +0000</pubDate>
    </item>
    <item>
      <title>【Long-Running Durable Agents With Spring AI and Dapr Workflows】具有 Spring AI 和 Dapr 工作流程的长期运行的持久代理</title>
      <link>https://dzone.com/articles/durable-agents-with-spring-ai-and-dapr</link>
      <description>【&lt;p&gt;Over the last year, we have seen a rise in various patterns and usages that combine popular frameworks, such as Spring AI and LLM interactions. In January this year, Christian from the Spring AI team published &lt;a href=&#34;https://spring.io/blog/2025/01/21/spring-ai-agentic-patterns&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;Building Effective Agents with Spring AI&lt;/em&gt;&lt;/a&gt;, covering common agentic patterns described in the Anthropic paper titled &lt;a href=&#34;https://www.anthropic.com/engineering/building-effective-agents&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;Building Effective Agents&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;I strongly recommend both of these blog posts to gain a good understanding of how these concepts are shaping up and the tools needed to implement the patterns suggested in these two articles.&amp;nbsp;&lt;/p&gt;】&lt;p&gt;在过去的一年里，我们看到结合流行框架的各种模式和用法有所增加，例如 Spring AI 和 LLM 交互。今年 1 月，Spring AI 团队的 Christian 发表了&lt;a href=&#34;https://spring.io/blog/2025/01/21/spring-ai-agentic-patterns&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;使用 Spring AI 构建有效代理&lt;/em&gt;&lt;/a&gt;，涵盖了 Anthropic 论文中描述的常见代理模式 标题为&lt;a href=&#34;https://www.anthropic.com/engineering/building- effective-agents&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;构建有效的代理&lt;/em&gt;&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;我强烈推荐这两篇博客文章，以便更好地理解这些概念是如何形成的，以及实现这两篇文章中建议的模式所需的工具。 &lt;/p&gt;</description>
      <pubDate>Fri, 10 Oct 2025 17:01:04 +0000</pubDate>
    </item>
    <item>
      <title>【Introduction to Spring Data Elasticsearch 5.5】Spring Data Elasticsearch 5.5 简介</title>
      <link>https://dzone.com/articles/guide-to-spring-data-elasticsearch-upgrade</link>
      <description>【&lt;p&gt;It&#39;s been a while since my first article dedicated to Spring Data Elasticsearch usage as a NoSQL database was published. A couple of articles with configuration changes or hints followed the first article. Therefore, the main goal of this article is to define a new baseline for the full Elasticsearch setup.&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;Note: All previous articles are listed at the end.&lt;/em&gt;&lt;/p&gt;】&lt;p&gt;距离我的第一篇专门介绍 Spring Data Elasticsearch 作为 NoSQL 数据库的使用的文章发布已经有一段时间了。第一篇文章之后还有几篇包含配置更改或提示的文章。因此，本文的主要目标是为完整的 Elasticsearch 设置定义一个新的基线。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;注意：所有以前的文章都列在最后。&lt;/em&gt;&lt;/p&gt;</description>
      <pubDate>Fri, 10 Oct 2025 16:00:08 +0000</pubDate>
    </item>
    <item>
      <title>【Stop React Native Crashes: A Production-Ready Error Handling Guide】停止 React Native 崩溃：生产就绪的错误处理指南</title>
      <link>https://dzone.com/articles/react-native-error-handling-guide</link>
      <description>【&lt;p&gt;You are demonstrating your next mobile application idea to investors, and suddenly the application crashes. Now you are clueless whether it crashed due to bad WIFI at the venue, your service is down, or your application itself hit a snag. There are no logs or alerts to tell you what just happened. Mere imagination of this scenario can send any founder or developer into panic and nervousness. Therefore, having robust error handling is critical to modern-day mobile applications. React Native has become an industry standard in building cross-platform native mobile applications. React Native boasts a rich ecosystem of error handling at various levels of architecture.&lt;/p&gt;&#xA;&lt;p&gt;However, often projects lack clear guidelines on how to handle various error scenarios. This results in either overdoing or underdoing error handling in otherwise robust and feature-rich applications. In this article, you will learn how to adopt a three-layer error handling mechanism, which is gaining widespread popularity with major enterprise-level applications built at leading companies. The article will give you a practical guide instead of pure theory, so you are ready to adapt these concepts immediately.&amp;nbsp;&lt;/p&gt;】&lt;p&gt;您正在向投资者展示您的下一个移动应用程序创意，突然应用程序崩溃了。现在你不知道是否是由于场地 WIFI 不好而崩溃、你的服务中断了，还是你的应用程序本身遇到了障碍。没有日志或警报告诉您刚刚发生了什么。仅仅想象这种情况就会让任何创始人或开发人员陷入恐慌和紧张。因此，拥有强大的错误处理能力对于现代移动应用程序至关重要。 React Native 已成为构建跨平台本机移动应用程序的行业标准。 React Native 拥有丰富的各种架构级别的错误处理生态系统。&lt;/p&gt;&#xA;&lt;p&gt;但是，项目通常缺乏关于如何处理各种错误情况的明确指南。这会导致在其他健壮且功能丰富的应用程序中过度或不足的错误处理。在本文中，您将学习如何采用三层错误处理机制，该机制在领先公司构建的主要企业级应用程序中越来越受欢迎。本文将为您提供实用指南，而不是纯粹的理论，因此您可以立即适应这些概念。 &lt;/p&gt;</description>
      <pubDate>Fri, 10 Oct 2025 15:00:10 +0000</pubDate>
    </item>
    <item>
      <title>【Fixing a Test Involves Much More Than Simply Making It Pass】修复测试不仅仅只是让它通过</title>
      <link>https://dzone.com/articles/why-fixing-a-test-is-not-just-making-it-pass</link>
      <description>【&lt;p dir=&#34;ltr&#34;&gt;Software tests are essential mechanisms in the development lifecycle designed to verify that code behaves as expected. They catch bugs, ensuring functionality aligns with requirements, and maintain overall system reliability through automated assertions on inputs, outputs, and states.&amp;nbsp;&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;However, fixing a failing test extends far beyond merely adjusting it to pass, as this superficial approach can mask deeper issues in the underlying code or architecture. True resolution demands a thorough investigation into the root cause. It could be a logic error, an environmental mismatch, a dependency failure, or an outdated assumption in the test itself, followed by targeted corrections that preserve the test&#39;s intent as a safeguard against regressions. Blindly modifying assertions to match unexpected outcomes, such as changing an expected value from false to true without validating why the discrepancy occurred, risks introducing false positives, eroding trust in the test suite.&amp;nbsp;&lt;/p&gt;】&lt;p dir=&#34;ltr&#34;&gt;软件测试是开发生命周期中的重要机制，旨在验证代码的行为是否符合预期。他们捕获错误，确保功能符合需求，并通过对输入、输出和状态的自动断言来维护整体系统的可靠性。 &lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;但是，修复失败的测试远远超出了仅仅将其调整为通过的范围，因为这种肤浅的方法可能会掩盖底层代码或架构中更深层次的问题。真正的解决方案需要彻底调查根本原因。它可能是逻辑错误、环境不匹配、依赖性失败或测试本身过时的假设，然后进行有针对性的更正，以保留测试的意图以防止回归。盲目修改断言以匹配意外结果，例如在不验证差异发生原因的情况下将预期值从假更改为真，可能会引入误报，削弱对测试套件的信任。 &lt;/p&gt;</description>
      <pubDate>Fri, 10 Oct 2025 14:00:15 +0000</pubDate>
    </item>
    <item>
      <title>【AI-Assisted Kubernetes Diagnostics: A Practical Implementation】AI 辅助 Kubernetes 诊断：实际实施</title>
      <link>https://dzone.com/articles/ai-assisted-kubernetes-diagnostics</link>
      <description>【&lt;p&gt;&lt;span&gt;Kubernetes troubleshooting follows a repetitive pattern: identify unhealthy pods, examine descriptions, review logs, analyze events, and correlate information to find root causes. For common issues like &lt;code&gt;CrashLoopBackOff&lt;/code&gt;, &lt;code&gt;ImagePullBackOff&lt;/code&gt;, or &lt;code&gt;OOMKilled&lt;/code&gt; pods, engineers repeat the same diagnostic steps daily, sometimes dozens of times per week in busy production environments.&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;The traditional workflow requires running multiple kubectl commands in sequence, mentally correlating outputs from pod descriptions, container logs, event streams, and resource configurations. An engineer investigating a single failing pod might execute 5–10 commands, read through hundreds of lines of output, and spend 10-30 minutes connecting the dots between symptoms and root causes. For straightforward issues like memory limits or missing images, this time investment yields solutions that follow predictable patterns.&lt;/p&gt;】&lt;p&gt;&lt;span&gt;Kubernetes 故障排除遵循重复模式：识别不健康的 Pod、检查描述、查看日志、分析事件以及关联信息以查找根本原因。对于 &lt;code&gt;CrashLoopBackOff&lt;/code&gt;、&lt;code&gt;ImagePullBackOff&lt;/code&gt; 或 &lt;code&gt;OOMKilled&lt;/code&gt; Pod 等常见问题，工程师每天重复相同的诊断步骤，有时在繁忙的生产环境中每周重复数十次。&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;传统工作流程需要按顺序运行多个 kubectl 命令，在心里关联 Pod 描述、容器日志、事件流和资源配置的输出。调查单个故障 Pod 的工程师可能会执行 5-10 个命令，阅读数百行输出，并花费 10-30 分钟将症状和根本原因联系起来。对于内存限制或丢失图像等简单问题，这次投资会产生遵循可预测模式的解决方案。&lt;/p&gt;</description>
      <pubDate>Fri, 10 Oct 2025 13:00:06 +0000</pubDate>
    </item>
    <item>
      <title>【Building Realistic Test Data in Java: A Hands-On Guide for Developers】用 Java 构建真实的测试数据：开发人员实践指南</title>
      <link>https://dzone.com/articles/building-realistic-test-data-in-java-with-datafake</link>
      <description>【&lt;p data-end=&#34;113&#34; data-start=&#34;0&#34;&gt;There’s something that every backend or API developer faces sooner or later: &lt;strong data-end=&#34;228&#34; data-start=&#34;197&#34;&gt;the need for good fake data&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;p data-end=&#34;586&#34; data-start=&#34;233&#34;&gt;Whether you’re testing a new API, populating a database for demos, or simply trying to make your unit tests less “boring”, fake data is part of your daily routine. The problem? Most fake data feels… fake. You end up with “John Doe” and “123 Main Street” repeated over and over, which doesn’t look great when showing a prototype to your team or client.&lt;/p&gt;】&lt;p data-end=&#34;113&#34; data-start=&#34;0&#34;&gt;每个后端或 API 开发人员迟早都会面临一些问题：&lt;strong data-end=&#34;228&#34; data-start=&#34;197&#34;&gt;需要良好的虚假数据&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p data-end=&#34;586&#34; data-start=&#34;233&#34;&gt;无论您是在测试新的 API、为演示填充数据库，还是只是想让单元测试不那么“无聊”，虚假数据都是您日常生活的一部分。问题？大多数虚假数据给人的感觉是……假的。您最终会一遍又一遍地重复“John Doe”和“123 Main Street”，这在向您的团队或客户展示原型时看起来不太好。&lt;/p&gt;</description>
      <pubDate>Fri, 10 Oct 2025 12:00:08 +0000</pubDate>
    </item>
    <item>
      <title>【Securing HTTPS From the Inside Out: Preventing Client-Side Interception Attacks】从内到外保护 HTTPS：防止客户端拦截攻击</title>
      <link>https://dzone.com/articles/securing-https-client-side-interception</link>
      <description>【&lt;h2 data-end=&#34;171&#34; data-start=&#34;160&#34;&gt;Overview&lt;/h2&gt;&#xA;&lt;p data-end=&#34;599&#34; data-start=&#34;172&#34;&gt;HTTPS is the most common mechanism used to protect client-server communication on the internet. Most teams focus on SSL/TLS and server-side hardening — and for good reason — but security is layered: the system is only as strong as its weakest link. This article focuses on a specific class of HTTPS man-in-the-middle (MITM) attacks that is not widely discussed. The aim is to harden one of the weaker links in many deployments.&lt;/p&gt;&#xA;&lt;p data-end=&#34;753&#34; data-start=&#34;601&#34;&gt;If you believe it’s perfectly safe to use a banking site over HTTPS on a device that isn’t yours (a friend’s laptop, an office machine), please read on.&lt;/p&gt;】&lt;h2 data-end=&#34;171&#34; data-start=&#34;160&#34;&gt;概述&lt;/h2&gt;&#xA;&lt;p data-end=&#34;599&#34; data-start=&#34;172&#34;&gt;HTTPS 是用于保护互联网上客户端与服务器通信的最常用机制。大多数团队都专注于 SSL/TLS 和服务器端强化——这是有充分理由的——但安全性是分层的：系统的强度取决于其最薄弱的环节。本文重点讨论尚未广泛讨论的一类特定的 HTTPS 中间人 (MITM) 攻击。目的是强化许多部署中的薄弱环节之一。&lt;/p&gt;&#xA;&lt;p data-end=&#34;753&#34; data-start=&#34;601&#34;&gt;如果您认为在非您的设备（朋友的笔记本电脑、办公机器）上通过 HTTPS 使用银行网站是完全安全的，请继续阅读。&lt;/p&gt;</description>
      <pubDate>Fri, 10 Oct 2025 11:00:08 +0000</pubDate>
    </item>
    <item>
      <title>【Popular DevOps Automation Tools】流行的 DevOps 自动化工具</title>
      <link>https://dzone.com/articles/popular-devops-automation-tools</link>
      <description>【&lt;p dir=&#34;ltr&#34;&gt;DevOps automation tools streamline the path from idea to deployment by turning repetitive, error-prone steps into reliable, repeatable workflows that reduce toil and shorten mean time to recovery (MTTR).&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;This article walks through five categories of DevOps automation tools. Expanding your tool stack thoughtfully is less about quantity and more about reducing change failure rate and increasing deployment frequency in a safe way.&lt;/p&gt;】&lt;p dir=&#34;ltr&#34;&gt;DevOps 自动化工具将重复、容易出错的步骤转变为可靠、可重复的工作流程，从而减少繁琐工作并缩短平均恢复时间 (MTTR)，从而简化从创意到部署的路径。&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;本文将介绍五类 DevOps 自动化工具。深思熟虑地扩展工具堆栈不在于数量，而在于以安全的方式降低变更失败率并提高部署频率。&lt;/p&gt;</description>
      <pubDate>Thu, 09 Oct 2025 19:00:04 +0000</pubDate>
    </item>
  </channel>
</rss>