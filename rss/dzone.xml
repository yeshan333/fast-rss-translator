<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DZone.com Feed</title>
    <link>https://feeds.dzone.com/home</link>
    <description>Recent posts on DZone.com</description>
    <item>
      <title>【Prompt-Based ETL: Automating SQL Generation for Data Movement With LLMs】基于及时的ETL：使用LLM的数据移动自动化SQL生成</title>
      <link>https://dzone.com/articles/prompt-based-etl-sql-automation-llms</link>
      <description>【&lt;p&gt;Every modern data team has experienced it: A product manager asks for a quick metric, “total signups in Asia over the last quarter, broken down by device type,” and suddenly the analytics backlog grows.&amp;nbsp;&lt;/p&gt;&#xA;&lt;p&gt;Somewhere deep in the data warehouse, an engineer is now tracing join paths across five tables, crafting a carefully optimized SQL query, validating edge cases, and packaging it into a pipeline that will likely break the next time the schema changes.&lt;/p&gt;】&lt;p&gt;每个现代数据团队都经历了它：产品经理要求快速指标“在上一季度亚洲的总注册，按设备类型分解”，突然间，Analytics Backlog增长了。 &lt;/p&gt;&#xA;&lt;p&gt;在数据仓库深处的某个地方，工程师现在正在追踪五个桌子上的连接路径，制作精心优化的SQL查询，验证边缘案例，并将其包装到管道中，该管道可能会破坏下一次架构时。&lt;/p&gt; &lt;/p&gt; &lt;/p&gt;</description>
      <pubDate>Mon, 18 Aug 2025 16:00:10 +0000</pubDate>
    </item>
    <item>
      <title>【Building AI Agents With .NET: A Practical Guide】用.NET构建AI代理：实用指南</title>
      <link>https://dzone.com/articles/agentic-ai-in-dotnet</link>
      <description>【&lt;p data-end=&#34;641&#34; data-start=&#34;292&#34;&gt;As software systems evolve, there&#39;s a growing demand for applications that are not just reactive but proactive, adaptive, and intelligent. This is where &lt;strong data-end=&#34;459&#34; data-start=&#34;445&#34;&gt;Agentic AI&lt;/strong&gt; comes in. Unlike traditional AI that simply follows instructions, Agentic AI involves autonomous agents that can perceive, reason, act, and learn just like intelligent assistants.&lt;/p&gt;&#xA;&lt;p data-end=&#34;788&#34; data-start=&#34;643&#34;&gt;In this article, we’ll explore how to bring Agentic AI concepts into the world of &lt;a href=&#34;https://dzone.com/refcardz/coredotnet&#34;&gt;.NET&lt;/a&gt; development, creating smarter, self-directed applications.&lt;/p&gt;】&lt;p data-end =“ 641” data-start =“ 292”&gt;随着软件系统的发展，对应用的需求不仅是反应性，而且是主动，自适应和智能的。这是&lt;strong data-end =“ 459” data-start =“ 445”&gt; agesic ai &lt;/strong&gt;出现的地方。与传统的AI仅遵循指示不同，代理AI涉及可以感知，推理，行动和学习的自主剂，就像智能助理一样。&lt;/p&gt;。&lt;/p&gt;。&lt;/p&gt;。&lt;/p&gt;。&#xA;&lt;p data-end =“ 788” data-start =“ 643”&gt;在本文中，我们将探讨如何将代理AI概念带入&lt;a href =“ https://dzone.com/refcardz/refcardz/coredotnet”&gt; .net&gt; .net &lt;/a&gt;开发，创建SMARTER，自我定义的应用程序。</description>
      <pubDate>Mon, 18 Aug 2025 14:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【10 Essential Bash Scripts to Boost DevOps Efficiency】10个基本狂欢脚本以提高DevOps效率</title>
      <link>https://dzone.com/articles/10-essential-bash-scripts-to-boost-devops-efficien</link>
      <description>【&lt;p&gt;Automation is a major aspect of the DevOps workflow, enhancing efficiency, and Bash script is one of the oldest and powerful tools for achieving this automation. Bash scripts help engineers and system admins to eliminate mundane workflow, repetitive tasks, and reduce errors across multiple environments. With its simplicity and adaptability in many Unix-based systems, the Bash script is used in day-to-day operations without the overhead of complex automation tooling.&lt;/p&gt;&#xA;&lt;p&gt;In this article, you will learn 10 essential Bash scripts that can boost your DevOps productivity. These range from automating simple &lt;a href=&#34;https://dzone.com/articles/what-is-a-cicd-pipeline&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;CI/CD&lt;/a&gt; DevOps workflow, backups, and Docker container management to monitoring system health and environment provisioning.&lt;/p&gt;】&lt;p&gt;自动化是DevOps工作流程的主要方面，提高效率，而Bash脚本是实现此自动化的最古老，最有力的工具之一。 bash脚本可帮助工程师和系统管理员消除平凡的工作流程，重复性任务，并减少多种环境中的错误。 BASH脚本在许多基于UNIX的系统中的简单性和适应性，在日常操作中使用，而没有复杂的自动化工具的开销。&lt;/p&gt;&#xA;&lt;p&gt;在本文中，您将学习10个必需的bash脚本，以提高您的DevOps生产力。这些范围从自动化简单&lt;a href =“ https://dzone.com/articles/what-is-a-cicd-pipeline” rer =“ noopener noreferrer” target =“ _ black”&gt; ci/cd&gt; ci/cd&gt; ci/cd &lt;/a&gt; DevOps Workflow，备份，备份，备份，备份和DOCKER容器以监测系统的健康和环境服务。</description>
      <pubDate>Mon, 18 Aug 2025 13:00:01 +0000</pubDate>
    </item>
    <item>
      <title>【Architecting Compound AI Systems for Scalable Enterprise Workflows】用于可扩展企业工作流的架构化合物AI系统</title>
      <link>https://dzone.com/articles/compound-ai-systems-scalable-enterprise-workflows</link>
      <description>【&lt;p&gt;&lt;span style=&#34;margin: 0px; padding: 0px;&#34;&gt;The convergence of generative AI, large language models (LLMs), and multi-agent orchestration has given rise to a transformative concept: compound AI systems. These architectures extend beyond individual models or assistants, representing ecosystems of intelligent agents that collaborate to deliver business outcomes at scale. As enterprises pursue hyperautomation, continuous optimization, and personalized engagement, designing agentic workflows becomes a critical differentiator.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p data-pm-slice=&#34;1 1 []&#34;&gt;&lt;span style=&#34;margin: 0px; padding: 0px;&#34;&gt;&lt;span style=&#34;background-color: transparent;&#34;&gt;This article examines the design of compound AI systems with an emphasis on&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;a href=&#34;https://dzone.com/articles/ai-agents-future-of-automation-or-overhyped-buzzword&#34;&gt;&lt;span style=&#34;margin: 0px; padding: 0px;&#34;&gt;modular AI agents&lt;/span&gt;&lt;/a&gt;&lt;span style=&#34;margin: 0px; padding: 0px;&#34;&gt;, secure orchestration, real-time data integration, and enterprise governance. The aim is to provide solution architects, engineering leaders, and digital transformation executives with a practical blueprint for building and scaling intelligent agent ecosystems across various domains, including customer service, IT operations, marketing, and field automation.&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;img style=&#34;width: 713px;&#34; class=&#34;fr-fic fr-dib lazyload&#34; data-image=&#34;true&#34; data-new=&#34;false&#34; data-sizeformatted=&#34;94.4 kB&#34; data-mimetype=&#34;image/png&#34; data-creationdate=&#34;1748846310741&#34; data-creationdateformatted=&#34;06/02/2025 06:38 AM&#34; data-type=&#34;temp&#34; data-url=&#34;https://dz2cdn1.dzone.com/storage/temp/18443436-1748846310236.png&#34; data-modificationdate=&#34;null&#34; data-size=&#34;94359&#34; data-name=&#34;1748846310236.png&#34; data-id=&#34;18443436&#34; data-src=&#34;https://dz2cdn1.dzone.com/storage/temp/18443436-1748846310236.png&#34; alt=&#34;Auto Agent Planning&#34;&gt;&lt;/p&gt;】&lt;p&gt; &lt;span style =“ margin：0px; padding：0px;“&gt;生成AI，大语言模型（LLMS）和多机构编排的收敛性导致了变革性的概念：复合AI系统。这些体系结构超出了各个模型或助手的范围，代表了智能代理的生态系统，这些生态系统合作以大规模提供业务成果。随着企业追求过度自动化，持续优化和个性化参与，设计代理工作流成为一个关键的区别。 &lt;/span&gt; &lt;/p&gt;&#xA;&lt;p data-pm-slice =“ 1 1 []&gt; &lt;span style =“ margin：0px; padding：0px;”&gt; &lt;span style =“ backend-color：pransparent;”&gt;本文研究了复合AI系统的设计，重点是&lt;/span&gt; &lt;/span&gt; &lt;/span&gt; &lt;a href =“ https://dzone.com/articles/ai-aigents-future-future-future-of-automation-or-overhyped-buzzword”&gt; &lt;span style =“ margin =” margin：0px; padding：0px;&gt; 0px;“&gt; modular ai Agents &lt;/span&gt; &lt;/span&gt; &lt;/a&gt;治理。目的是为解决方案建筑师，工程领导者和数字转换管理人员提供实用的蓝图，用于在各个领域建立和扩展智能代理生态系统，包括客户服务，IT运营，营销，营销和现场自动化。&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;img style =“ width =” width：713px;“”; class =“ fr-fic fr-dib lazyload” data-image =“ true” data-new =“ false” data-sizeFormatted =“ 94.4 kb” data-mimetype =“ image/png” data-creationdate =“ 1748846310741” data-creationdateDateDateDateFormatted =“ 06/06/02/202/202/202/202/202/202/202/202/202/202/202/202/202/202/202/202/202/202/206:306.306.306.306.38” data-url =“ https://dz2cdn1.dzone.com/storage/temp/184443436-17488846310236.png” data-modificationdate =“ nul nul data null” data-size =“ 94359” data-name =“ data data data data data name =” 174888444444444444444444444310236.PATATA data-src =“ https://dz2cdn1.dzone.com/storage/temp/184443436-174884846310236.png” alt =“自动代理计划”&gt; &lt;/p&gt;</description>
      <pubDate>Mon, 18 Aug 2025 11:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Logging MCP Protocol When Using stdio, Part I】使用STDIO时记录MCP协议，第一部分</title>
      <link>https://dzone.com/articles/logging-mcp-protocol-when-using-stdio-part-i</link>
      <description>【&lt;h2 style=&#34; border-box;font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif;font-weight: 600;line-height: 1.2;color: rgb(34, 38, 53);margin: 20px 0px 5px;font-size: 30px;clear: both;letter-spacing: -0.5px;font-style: normal;font-variant-ligatures: normal;font-variant-caps: normal;orphans: 2;text-align: left;text-indent: 0px;text-transform: none;widows: 2;word-spacing: 0px;-webkit-text-stroke-width: 0px;white-space: normal;background-color: rgb(255, 255, 255);text-decoration-thickness: initial;text-decoration-style: initial;text-decoration-color: initial;&#34;&gt;&lt;strong style=&#34; border-box;font-weight: bold;font-style: normal;&#34;&gt;Logging MCP Protocol When Using stdio&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p style=&#34; border-box;margin: 5px 0px 15px;color: rgb(34, 38, 53);font-family: Cambria, serif;font-size: 19px;font-style: normal;font-variant-ligatures: normal;font-variant-caps: normal;font-weight: 400;letter-spacing: normal;orphans: 2;text-align: left;text-indent: 0px;text-transform: none;widows: 2;word-spacing: 0px;-webkit-text-stroke-width: 0px;white-space: normal;background-color: rgb(255, 255, 255);text-decoration-thickness: initial;text-decoration-style: initial;text-decoration-color: initial;&#34;&gt;If you haven’t heard of MCP — the Model Context Protocol — you’ve probably been living under a rock. The Model Context Protocol (MCP) is becoming widely recognized, standardizing how applications provide context to LLMs. It barely needs an introduction anymore. Still, for the sake of completeness, let me borrow selectively from the &lt;a href=&#34;https://modelcontextprotocol.io/introduction&#34; rel=&#34;noopener noreferrer&#34; style=&#34; border-box;background: transparent;color: rgb(41, 168, 255);text-decoration: none;user-select: auto;&#34; target=&#34;_blank&#34;&gt;official MCP site&lt;/a&gt;. &amp;nbsp;Do take a moment to explore the well-explained pages if you&#39;re new to MCP.&lt;/p&gt;&#xA;&lt;p style=&#34; border-box;margin: 5px 0px 15px;color: rgb(34, 38, 53);font-family: Cambria, serif;font-size: 19px;font-style: normal;font-variant-ligatures: normal;font-variant-caps: normal;font-weight: 400;letter-spacing: normal;orphans: 2;text-align: left;text-indent: 0px;text-transform: none;widows: 2;word-spacing: 0px;-webkit-text-stroke-width: 0px;white-space: normal;background-color: rgb(255, 255, 255);text-decoration-thickness: initial;text-decoration-style: initial;text-decoration-color: initial;&#34;&gt;MCP is an open protocol that standardizes how applications provide context to LLMs. It’s designed to help developers build agents and complex workflows on top of LLMs. Since LLMs often need to interact with external data and tools, MCP offers:&lt;/p&gt;】&lt;h2 style =“ border-box; font-family：“ helvetica neue”，helvetica，arial，sans-serif; font-weight：600; line-heiver：1.2; color：rgb（34，38，53）; margin; margin; margin; margin; margin：20px 0px 5px; font size：30px; font size：30px; cele; cele; cele; normal;font-variant-ligatures: normal;font-variant-caps: normal;orphans: 2;text-align: left;text-indent: 0px;text-transform: none;widows: 2;word-spacing: 0px;-webkit-text-stroke-width: 0px;white-space: normal;background-color: rgb(255, 255, 255);text-decoration-thickness: initial;text-decoration-style: initial;text-decoration-color: initial;&#34;&gt;&lt;strong style=&#34; border-box;font-weight: bold;font-style: normal;&#34;&gt;Logging MCP Protocol When Using stdio&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p style =“边界框；边距：5px 0px 15px;颜色：rgb（34、38、53）; font-family：cambria，serif; font-size; font-size：19px; font-style; forman; formal; fort-font-variant; font-variant; font-var; 2;text-align: left;text-indent: 0px;text-transform: none;widows: 2;word-spacing: 0px;-webkit-text-stroke-width: 0px;white-space: normal;background-color: rgb(255, 255, 255);text-decoration-thickness: initial;text-decoration-style: initial;text-decoration-color: initial;&#34;&gt;If您还没有听说过MCP（模型上下文协议），您可能一直生活在岩石之下。模型上下文协议（MCP）正被广泛认可，标准化应用程序如何为LLM提供上下文。它几乎不再需要介绍了。尽管如此，为了完整，让我从&lt;a href =“ https://modelcontextprotocol.io/introduction”中有选择地借钱。 target =“ _ blank”&gt;官方MCP网站&lt;/a&gt;。  如果您是MCP的新手，请花一点时间探索解释的页面。&lt;/p&gt;&#xA;&lt;p style =“边界框；边距：5px 0px 15px;颜色：rgb（34、38、53）; font-family：cambria，serif; font-size; font-size：19px; font-style; forman; formal; fort-font-variant; font-variant; font-var; 2; text-align：左;文本 -  0px;文本转变：无；初始;“&gt; MCP是一个开放协议，标准化应用程序如何为LLM提供上下文。它旨在帮助开发人员在LLM上建立代理和复杂的工作流程。由于LLMS通常需要与外部数据和工具进行交互，因此MCP提供：&lt;/p&gt;</description>
      <pubDate>Mon, 18 Aug 2025 13:30:00 +0000</pubDate>
    </item>
    <item>
      <title>【React Server Components in Next.js 15: A Deep Dive】Next.js 15：深入潜水中的React服务器组件</title>
      <link>https://dzone.com/articles/react-server-components-nextjs-15</link>
      <description>【&lt;p&gt;React 19.1 and Next.js 15.3.2 have arrived, and React Server Components (RSC) are now officially a stable part of the React ecosystem and the Next.js framework. In this article, we&#39;ll dive into what server components are, how they work under the hood, and what they mean for developers. We&#39;ll cover the RSC architecture, data loading and caching, integration with Next.js (including the new &lt;code&gt;app/&lt;/code&gt; routing, the use client directive, layouts), and examine limitations and pitfalls. Of course, we&#39;ll also explore practical examples and nuances — from performance to testing and security — and finish by comparing RSC to alternative approaches like Remix, Astro, and others.&lt;/p&gt;&#xA;&lt;h2&gt;Why Do We Need Server Components?&lt;/h2&gt;&#xA;&lt;p&gt;Until recently, React apps were either rendered entirely on the client or partially on the server (via SSR) with hydration handled on the client. Neither approach is perfect: full &lt;a href=&#34;https://dzone.com/articles/a-short-history-of-ajax-and-ssr&#34;&gt;client-side rendering&lt;/a&gt; (CSR) can overload the browser with heavy JavaScript, while &lt;a href=&#34;https://dzone.com/articles/what-is-server-side-rendering-and-why-do-you-need&#34;&gt;server-side rendering&lt;/a&gt; (SSR) still requires full hydration of interactive components on the client — which adds significant overhead. React Server Components offer a new solution: move parts of the UI logic and rendering to the server, sending pre-rendered HTML to the browser and sprinkling in interactivity only where needed. In other words, we can write React components that run exclusively on the server — they can directly query a database or filesystem, generate HTML, and stream that UI to the browser. The client receives the already-rendered output and loads only the minimal JavaScript required for interactive parts of the app.&lt;/p&gt;】&lt;p&gt; React 19.1和Next.js 15.3.2已经到达，现在正式成为React生态系统和Next.js Framework的React Server组件（RSC）现在正式成为稳定的一部分。在本文中，我们将深入研究服务器组件是什么，它们在引擎盖下的工作方式以及对开发人员的意义。我们将介绍RSC架构，数据加载和缓存，与Next.js集成（包括新的&lt;code&gt; App/&lt;/code&gt;路由，使用客户端指令，布局），并检查限制和陷阱。当然，我们还将探讨实用的示例和细微差别 - 从性能到测试和安全性 - 并通过将RSC与Remix，Astro和其他其他方法进行比较。&lt;/p&gt;&#xA;&lt;h2&gt;为什么我们需要服务器组件？&lt;/h2&gt;&#xA;&lt;p&gt;直到最近，React应用程序要么完全在客户端上或部分在服务器上（通过SSR）渲染，并在客户端上处理水合。这两种方法都不完美：完整&lt;a href =“ https://dzone.com/articles/a-short-hort-hort-hort-of-ajax-and-ssr”&gt; client-side渲染href =“ https://dzone.com/articles/what-is-server-side-side-rendering-and-why-why-do-you-need”&gt;服务器范围渲染&lt;/a&gt;（ssr）仍然需要在客户端上的交互式组件充分水合 - 增加了大量的俯顶。 React Server组件提供了一个新的解决方案：将UI逻辑的一部分移动到服务器，将预渲染的HTML发送到浏览器，并仅在需要的情况下洒水。换句话说，我们可以编写专门在服务器上运行的React组件 - 它们可以直接查询数据库或文件系统，生成HTML并将其流到浏览器中。客户端接收已经渲染的输出，并仅加载应用程序交互零件所需的最小JavaScript。&lt;/p&gt;</description>
      <pubDate>Mon, 18 Aug 2025 12:00:09 +0000</pubDate>
    </item>
    <item>
      <title>【Expert Techniques to Trim Your Docker Images and Speed Up Build Times】专家技术来修剪您的码头图像并加快构建时间</title>
      <link>https://dzone.com/articles/trim-docker-images-speed-up-builds</link>
      <description>【&lt;h2 dir=&#34;ltr&#34;&gt;Key Takeaways&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA; &lt;li dir=&#34;ltr&#34;&gt;&lt;strong&gt;Pick your base image like you&#39;re choosing a foundation for your house&lt;/strong&gt;. Going with a minimal variant like &lt;code&gt;python-slim&lt;/code&gt; or a runtime-specific CUDA image, is hands down the quickest way to slash your image size and reduce security risks.&lt;/li&gt;&#xA; &lt;li dir=&#34;ltr&#34;&gt;&lt;strong&gt;Multi-stage builds are your new best friend for keeping things organized&lt;/strong&gt;. Think of it like having a messy workshop (your &#34;builder&#34; stage) where you do all the heavy lifting with compilers and testing tools, then only moving the finished product to your clean showroom (the &#34;runtime&#34; stage).&lt;/li&gt;&#xA; &lt;li dir=&#34;ltr&#34;&gt;&lt;strong&gt;Layer your Dockerfile with caching in mind, always&lt;/strong&gt;. Put the stuff that rarely changes (like dependency installation) before the stuff that changes all the time (like your app code). This simple trick can cut your build times from minutes to mere seconds.&lt;/li&gt;&#xA; &lt;li dir=&#34;ltr&#34;&gt;&lt;strong&gt;Remember that every &lt;code&gt;RUN&lt;/code&gt; command creates a permanent layer&lt;/strong&gt;. You&#39;ve got to chain your installation and cleanup commands together with &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; to make sure temporary files actually disappear within the same layer. Otherwise, you&#39;re just hiding a mess under the rug while still paying for the storage.&lt;/li&gt;&#xA; &lt;li dir=&#34;ltr&#34;&gt;&lt;strong&gt;Stop treating &lt;code&gt;.dockerignore&lt;/code&gt; like an afterthought&lt;/strong&gt;. Make it your first line of defense to keep huge datasets, model checkpoints, and (yikes!) credentials from ever getting near your build context.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;So you&#39;ve built your AI model, containerized everything, and hit &lt;code&gt;docker build&lt;/code&gt;. The build finishes, and there it is: a multi-gigabyte monster staring back at you. If you&#39;ve worked with AI containers, you know this pain. Docker&#39;s convenience comes at a price, and that price is bloated, sluggish images that slow down everything from developer workflows to CI/CD pipelines while burning through your cloud budget.&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;This guide isn&#39;t just another collection of Docker tips. We&#39;re going deep into the fundamental principles that make containers efficient. We&#39;ll tackle both sides of the optimization coin:&lt;/p&gt;】&lt;h2 dir =“ ltr”&gt;键外卖&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA; &lt;li dir =“ ltr”&gt; &lt;strong&gt;选择您的基本图像，就像您为您的房屋选择基础&lt;/strong&gt;一样。使用最小的变体，例如&lt;code&gt; python-slim &lt;/code&gt;或特定于运行时的CUDA图像，是最快的方法来削减图像大小并降低安全风险。&lt;/li&gt;&#xA; &lt;li dir =“ ltr”&gt; &lt;strong&gt;多阶段构建是您保持井井有条的新最好的朋友&lt;/strong&gt;。将其视为拥有一个凌乱的工作坊（您的“建筑商”阶段），在这里您可以使用编译器和测试工具进行所有繁重的工作，然后将成品移至干净的陈列室（“运行时”阶段）。&lt;/li&gt; &lt;/li&gt;&#xA; &lt;li dir =“ ltr”&gt; &lt;strong&gt;将您的dockerfile层置于牢记，始终&lt;/strong&gt;。将很少更改的内容（例如依赖安装）放在一直在更改的内容之前（例如您的应用程序代码）。这个简单的技巧可以将您的构建时间从几分钟到几秒钟。&lt;/li&gt;&#xA; &lt;li dir =“ ltr”&gt; &lt;strong&gt;请记住，每个&lt;code&gt;运行&lt;/code&gt;命令都会创建一个永久层&lt;/strong&gt;。您必须将安装和清理命令与&lt;code&gt; &amp;&amp; &lt;/code&gt;一起链接，以确保临时文件实际上消失在同一层中。否则，您只是将一团糟在地毯下藏起来，同时仍在为存储付费。&lt;/li&gt;&#xA; &lt;li dir =“ ltr”&gt; &lt;strong&gt;停止处理&lt;code&gt; .dockerignore &lt;/code&gt;像事后&lt;/strong&gt;一样。使其成为您的第一道防线，以保持巨大的数据集，模型检查点和（yikes！）凭据靠近您的构建上下文。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p dir =“ ltr”&gt;因此，您已经构建了AI模型，对所有内容进行了容器，然后击中&lt;code&gt; docker build &lt;/code&gt;。构建结束了，就在那里：一个多gabyte怪物盯着您。如果您使用AI容器，您会知道这种痛苦。 Docker的便利性是有代价的，价格膨胀，较短的图像，这些图像放慢了从开发人员工作流程到CI/CD管道的所有内容，同时燃烧您的云预算。&lt;/p&gt;&#xA;&lt;p dir =“ ltr”&gt;本指南不仅仅是Docker提示的另一集。我们深入探讨了使容器高效的基本原则。我们将解决优化硬币的两面：&lt;/p&gt;</description>
      <pubDate>Mon, 18 Aug 2025 17:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Real-Time Analytics Using Zero-ETL for MySQL】实时分析使用MySQL的零ETL</title>
      <link>https://dzone.com/articles/real-time-analytics-zero-etl-mysql</link>
      <description>【&lt;p&gt;Organizations rely on real-time analytics to gain insights into their core business drivers, enhance operational efficiency, and maintain a competitive edge. Traditionally, this has involved the use of complex extract, transform, and load (ETL) pipelines. ETL is the process of combining, cleaning, and normalizing data from different sources to prepare it for analytics, AI, and machine learning (ML) workloads. Although ETL processes have long been a staple of data integration, they often prove time-consuming, complex, and less adaptable to the fast-changing demands of modern data architectures. By transitioning towards zero-ETL architectures, businesses can foster agility in analytics, streamline processes, and make sure that data is immediately actionable.&lt;/p&gt;&#xA;&lt;p&gt;In this post, we demonstrate how to set up a zero-ETL integration between &lt;a href=&#34;https://aws.amazon.com/rds/mysql/&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;Amazon Relational Database Service (Amazon RDS) for MySQL&lt;/a&gt; (source) and Amazon Redshift (destination). The transactional data from the source gets refreshed in near real time on the destination, which processes analytical queries.&lt;/p&gt;】&lt;p&gt;组织依靠实时分析来了解其核心业务驱动力，提高运营效率并保持竞争优势。传统上，这涉及使用复杂提取物，转换和负载（ETL）管道的使用。 ETL是将来自不同来源的数据组合，清洁和标准化的过程，以准备分析，AI和机器学习（ML）工作量。尽管ETL过程长期以来一直是数据集成的主要内容，但它们通常证明是耗时，复杂的，并且不适合现代数据体系结构的快速变化需求。通过向零元素架构过渡，企业可以在分析，简化流程中促进敏捷性，并确保数据立即可行。&lt;/p&gt;&#xA;&lt;p&gt;在这篇文章中，我们演示了如何在&lt;a href =“ https://aws.amazon.com/rds/mysql/”之间建立零ETL集成。来自源的交易数据在目的地几乎实时刷新，该数据处理分析查询。&lt;/p&gt;</description>
      <pubDate>Mon, 18 Aug 2025 15:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【The Kill Switch: A Coder&#39;s Silent Act of Revenge】杀戮开关：编码人员的复仇行为</title>
      <link>https://dzone.com/articles/kill-switch-coders-silent-act-of-revenge</link>
      <description>【&lt;p&gt;In the age of code dominance, where billions of dollars are controlled by lines of code, a frustrated coder crossed the boundary between protest and cybercrime. What began as a grudge became an organized act of sabotage, one that now could land him 10 years in federal prison.&lt;/p&gt;&#xA;&lt;p&gt;Recently, a contract programmer was fired by a US trucking and logistics company. But unbeknownst to his bosses, he had secretly embedded a digital kill switch in their production infrastructure. A week later, the company&#39;s systems were knocked offline, their settings scrambled, and vital services grounded.&lt;/p&gt;】&lt;p&gt;在代码统治时代，数十亿美元由代码线控制，一个沮丧的编码员越过抗议和网络犯罪之间的边界。最初的怨恨成为有组织的破坏行为，现在可以将他送入联邦监狱10年。&lt;/p&gt; &lt;/p&gt;&#xA;&lt;p&gt;最近，合同程序员是由一家美国卡车运输公司解雇的。但是他的老板不为人知，他秘密地将数字杀戮开关嵌入了他们的生产基础设施中。一周后，该公司的系统被撞倒，设置扰乱，而重要的服务扎根。&lt;/p&gt;</description>
      <pubDate>Mon, 18 Aug 2025 18:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Logging MCP Protocol When Using stdio- Part II】使用stdio-part II时记录MCP协议</title>
      <link>https://dzone.com/articles/logging-mcp-protocol-when-using-stdio-part-ii</link>
      <description>【&lt;p&gt;In &lt;a href=&#34;https://dzone.com/articles/logging-mcp-protocol-when-using-stdio-part-i&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;Part 1&lt;/a&gt;, we introduced the challenge of logging MCP’s stdio communication and outlined three powerful techniques to solve it. Now, let’s get our hands dirty. This part provides a complete, practical walkthrough, demonstrating how to apply these concepts by building a Spring AI-based MCP server from scratch, configuring a GitHub Copilot client, and even creating a custom client to showcase the full power of the protocol.&lt;/p&gt;&#xA;&lt;h2&gt;Copilot Conversation Illustration&lt;/h2&gt;&#xA;&lt;h3&gt;&lt;strong&gt;&lt;img data-new=&#34;false&#34; data-mimetype=&#34;image/png&#34; data-creationdateformatted=&#34;08/06/2025 07:49 AM&#34; data-url=&#34;https://dz2cdn1.dzone.com/storage/temp/18569888-1754466565008.png&#34; data-size=&#34;33960&#34; data-id=&#34;18569888&#34; class=&#34;fr-fic fr-dib lazyload&#34; data-image=&#34;true&#34; data-sizeformatted=&#34;34.0 kB&#34; data-creationdate=&#34;1754466564425&#34; data-type=&#34;temp&#34; data-modificationdate=&#34;null&#34; data-name=&#34;1754466565008.png&#34; data-src=&#34;https://dz2cdn1.dzone.com/storage/temp/18569888-1754466565008.png&#34; alt=&#34;Copilot conversation illustration&#34;&gt;&#xA;  &lt;p&gt;&lt;br&gt;&lt;/p&gt;】&lt;p&gt; in &lt;a href =“ https://dzone.com/articles/logging-mcp-protocol-when-using-stdio-part-i” rel =“ noopener noreferrer” target =“ _ black”&gt;第1部分&lt;/a&gt;，我们引入了登录MCP沟通的挑战，以解决三个强大的技巧。现在，让我们弄脏双手。这部分提供了完整，实用的演练，展示了如何通过从头开始构建基于Spring AI的MCP服务器，配置Github Copilot客户端，甚至创建自定义客户端来展示协议的全部功能。&lt;/p&gt;&gt;&#xA;&lt;H2&gt;副副言对话插图&lt;/h2&gt;&#xA;&lt;h3&gt;&lt;strong&gt;&lt;img data-new=&#34;false&#34; data-mimetype=&#34;image/png&#34; data-creationdateformatted=&#34;08/06/2025 07:49 AM&#34; data-url=&#34;https://dz2cdn1.dzone.com/storage/temp/18569888-1754466565008.png&#34; data-size =“ 33960” data-id =“ 18569888” class =“ fr-fic fr-dib lazyload” data-image =“ true” data-sizeFormatted =“ 34.0 kb” data-creationdate =“ 17544466564425” data-name =“ 17544666565008.png” data-src =“ https://dz2cdn1.dzone.com/storage/storage/temp/18569888888-17544466656565008.png”&#xA;  &lt;p&gt; &lt;br&gt; &lt;/p&gt;</description>
      <pubDate>Mon, 18 Aug 2025 14:30:00 +0000</pubDate>
    </item>
  </channel>
</rss>