<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DZone.com Feed</title>
    <link>https://feeds.dzone.com/home</link>
    <description>Recent posts on DZone.com</description>
    <item>
      <title>【A Beginner&#39;s Guide to Docker Compose】Docker Compose 初学者指南</title>
      <link>https://dzone.com/articles/beginners-guide-to-docker-compose</link>
      <description>【&lt;p data-pm-slice=&#34;1 1 []&#34;&gt;The constant need to run &lt;code&gt;docker run&lt;/code&gt; in multiple terminals for managing multi-container setups.&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;If you’re new to Docker, you’ve likely already discovered the &lt;code&gt;docker run&lt;/code&gt; command that makes it easy to run a single container. However, what happens if your app requires a database? A cache? Before you know it, you’re dealing with a terminal tab nightmare:&lt;/p&gt;】&lt;p data-pm-slice=&#34;1 1 []&#34;&gt;经常需要在多个终端中运行 &lt;code&gt;docker run&lt;/code&gt; 来管理多容器设置。&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;如果您是 Docker 新手，您可能已经发现了 &lt;code&gt;docker run&lt;/code&gt; 命令，它可以轻松运行单个容器。但是，如果您的应用程序需要数据库，会发生什么情况？缓存？在您意识到之前，您正在处理终端选项卡的噩梦：&lt;/p&gt;</description>
      <pubDate>Thu, 06 Nov 2025 20:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Unlocking Modernization: SUSE Virtualization on Arm64 With Harvester】解锁现代化：Arm64 上的 SUSE 虚拟化与 Harvester</title>
      <link>https://dzone.com/articles/unlocking-modernization-suse-virtualization-on-arm</link>
      <description>【&lt;p dir=&#34;ltr&#34;&gt;As the number of data centers and their size grow worldwide, requiring increased efficiency, scalability, and agility from IT infrastructure, the convergence of virtual machines (VMs) and cloud-native technologies is crucial for success.&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;A recent conversation between Dave Neary of Ampere Computing and Alexandra Settle, Product Manager for SUSE Virtualization, highlights a significant step forward: the general availability of SUSE Virtualization for Arm64 architecture, and Harvester’s pivotal role within SUSE’s ecosystem. This white paper summarizes their discussion, highlighting how SUSE is empowering organizations to modernize infrastructure with energy-efficient, high-performance solutions.&lt;/p&gt;】&lt;p dir=&#34;ltr&#34;&gt;随着全球数据中心数量及其规模不断增长，要求 IT 基础设施提高效率、可扩展性和敏捷性，虚拟机 (VM) 和云原生技术的融合对于成功至关重要。&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;AmpereComputing 的 Dave Neary 和 SUSE Virtualization 产品经理 Alexandra Settle 最近的一次对话强调了向前迈出的重要一步：Arm64 架构的 SUSE Virtualization 的普遍可用性，以及 Harvester 在 SUSE 生态系统中的关键作用。本白皮书总结了他们的讨论，重点介绍了 SUSE 如何帮助组织通过节能、高性能的解决方案实现基础设施现代化。&lt;/p&gt;</description>
      <pubDate>Thu, 06 Nov 2025 19:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【A Developer&#39;s Guide to Sentiment Analysis With Naive Bayes and Python】使用朴素贝叶斯和 Python 进行情感分析的开发人员指南</title>
      <link>https://dzone.com/articles/sentiment-analysis-naive-bayes-python-guide</link>
      <description>【&lt;p&gt;Sentiment analysis is a powerful tool for understanding customer feedback, social media comments, and product reviews. It allows us to programmatically determine whether a piece of text is positive, negative, or neutral. While complex models like Transformers (e.g., BERT) often grab the headlines, the classic &lt;strong&gt;Multinomial Naive Bayes&lt;/strong&gt; classifier remains a surprisingly effective, efficient, and interpretable baseline, especially for text-based tasks.&lt;/p&gt;&#xA;&lt;p&gt;In this guide, we&#39;ll walk through a complete sentiment analysis project using Python and Scikit-learn. We&#39;ll cover:&lt;/p&gt;】&lt;p&gt;情绪分析是了解客户反馈、社交媒体评论和产品评论的强大工具。它允许我们以编程方式确定一段文本是积极的、消极的还是中性的。虽然像 Transformers（例如 BERT）这样的复杂模型经常成为头条新闻，但经典的&lt;strong&gt;多项式朴素贝叶斯&lt;/strong&gt;分类器仍然是一个令人惊讶的有效、高效和可解释的基线，特别是对于基于文本的任务。&lt;/p&gt;&#xA;&lt;p&gt;在本指南中，我们将使用 Python 和 Scikit-learn 逐步完成一个完整的情感分析项目。我们将介绍：&lt;/p&gt;</description>
      <pubDate>Thu, 06 Nov 2025 18:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【A Beginner&#39;s Guide to Essential Commands to Fix Container Setup Issues】修复容器设置问题的基本命令的初学者指南</title>
      <link>https://dzone.com/articles/docker-commands-fix-container-setup-issues</link>
      <description>【&lt;p&gt;You followed the tutorial. You ran Docker Run. And... nothing. The container exited immediately. Or maybe it is running, but localhost just shows “This site can’t be reached.” We’ve all been there. When you’re new to Docker, a failing container can feel like a sealed black box. You know something is wrong inside, but you have no idea how to look.&amp;nbsp;&lt;/p&gt;&#xA;&lt;p&gt;In this quick guide, I’ll show you the five essential commands to open that box, see what’s happening, and fix your broken containers.&lt;/p&gt;】&lt;p&gt;您已按照教程进行操作。您运行了 Docker Run。而且……什么也没有。容器立即退出。或者它可能正在运行，但 localhost 只是显示“无法访问此站点”。我们都去过那里。当您刚接触 Docker 时，失败的容器可能会感觉就像一个密封的黑匣子。你知道内心出了问题，但你不知道如何看待。 &lt;/p&gt;&#xA;&lt;p&gt;在本快速指南中，我将向您展示五个基本命令，用于打开该盒子，查看发生了什么，并修复损坏的容器。&lt;/p&gt;</description>
      <pubDate>Thu, 06 Nov 2025 17:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【A Practical Guide to Modernizing Data Serving Architectures Using DBSQL】使用 DBSQL 实现数据服务架构现代化的实用指南</title>
      <link>https://dzone.com/articles/modernizing-data-serving-architectures-with-dbsql</link>
      <description>【&lt;p data-end=&#34;699&#34; data-start=&#34;531&#34;&gt;If you’ve ever built analytical dashboards, chances are you’ve worked with the old “batch-load-to-RDS” pattern, where we load the data into RDS from a batch process and read from that operational data store, such as AWS RDS or other databases. We certainly did in our case — and for a while, it served us well.&lt;/p&gt;&#xA;&lt;p data-end=&#34;921&#34; data-start=&#34;701&#34;&gt;Our applications pulled data from a lakehouse like Snowflake or Delta Lake, transformed it in AWS Glue, and loaded it into &lt;a href=&#34;https://dzone.com/articles/7-invaluable-advantages-of-using-amazon-rds&#34;&gt;Amazon RDS&lt;/a&gt;. The RDS database powered Lambda APIs that fed dashboards and front-end apps.&lt;/p&gt;】&lt;p data-end=&#34;699&#34; data-start=&#34;531&#34;&gt;如果您曾经构建过分析仪表板，那么您很可能使用过旧的“批量加载到 RDS”模式，在该模式中，我们通过批处理将数据加载到 RDS 中，并从操作数据存储（例如 AWS RDS 或其他数据库）中读取数据。在我们的案例中，我们确实做到了——并且在一段时间内，它对我们很有帮助。&lt;/p&gt;&#xA;&lt;p data-end=&#34;921&#34; data-start=&#34;701&#34;&gt;我们的应用程序从 Snowflake 或 Delta Lake 等 Lakehouse 中提取数据，在 AWS Glue 中进行转换，然后将其加载到 &lt;a href=&#34;https://dzone.com/articles/7-invaluable-advantages-of-using-amazon-rds&#34;&gt;Amazon RDS&lt;/a&gt; 中。 RDS 数据库支持 Lambda API，为仪表板和前端应用程序提供数据。&lt;/p&gt;</description>
      <pubDate>Thu, 06 Nov 2025 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Optimizing Write-Heavy Database Workloads for Low Latency】优化写入密集型数据库工作负载以实现低延迟</title>
      <link>https://dzone.com/articles/optimizing-write-heavy-database-workloads-low-latency</link>
      <description>【&lt;p&gt;Write-heavy database workloads bring a distinctly different set of challenges than read-heavy ones. For example:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA; &lt;li&gt;Scaling writes can be costly, especially if you pay per operation, and writes are 5X more costly than reads&lt;/li&gt;&#xA; &lt;li&gt;Locking can add delays and reduce throughput&lt;/li&gt;&#xA; &lt;li&gt;I/O bottlenecks can lead to write amplification and complicate crash recovery&lt;/li&gt;&#xA; &lt;li&gt;Database backpressure can throttle the incoming load&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;While cost matters quite a lot, in many cases, it’s not a topic we want to cover here. Rather, let’s focus on the performance-related complexities that teams commonly face and discuss your options for tackling them.&lt;/p&gt;】&lt;p&gt;写入密集型数据库工作负载带来的挑战与读取密集型数据库工作负载截然不同。例如：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA; &lt;li&gt;扩展写入的成本可能很高，特别是如果您按操作付费，并且写入的成本比读取高 5 倍&lt;/li&gt;&#xA; &lt;li&gt;锁定会增加延迟并降低吞吐量&lt;/li&gt;&#xA; &lt;li&gt;I/O 瓶颈可能导致写入放大并使崩溃恢复变得复杂&lt;/li&gt;&#xA; &lt;li&gt;数据库背压可以限制传入负载&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;虽然成本非常重要，但在许多情况下，这不是我们想要在此讨论的主题。相反，让我们关注团队通常面临的与绩效相关的复杂性，并讨论解决这些问题的选择。&lt;/p&gt;</description>
      <pubDate>Thu, 06 Nov 2025 15:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Tactical Domain-Driven Design: Bringing Strategy to Code】战术领域驱动设计：将策略转化为代码</title>
      <link>https://dzone.com/articles/tactical-domain-driven-design-bringing-strategy-to</link>
      <description>【&lt;p&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;In the&amp;nbsp;&lt;/span&gt;&lt;a href=&#34;https://dzone.com/articles/strategic-domain-driven-design&#34; target=&#34;_blank&#34;&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;previous article&lt;/span&gt;&lt;/a&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;, I discussed the most often overlooked aspect of Domain-Driven Design: the strategic side. When it comes to software development, teams tend to rush toward code, believing that implementation will clarify the domain. History shows the opposite — building without understanding the underlying reason or direction often leads to systems that are technically correct but conceptually wrong. As the old Latin root of&amp;nbsp;&lt;/span&gt;&lt;em&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;strategy&lt;/span&gt;&lt;/em&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;&amp;nbsp;(&lt;/span&gt;&lt;em&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;strategos&lt;/span&gt;&lt;/em&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;, “the art of the general”) suggests, the plan must precede the movement.&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;Now that we’ve explored the “why” and “what,” it’s time to turn to the “how.” Tactical DDD represents this next step — the process of transforming a well-understood domain into expressive, maintainable code.&amp;nbsp;&lt;/span&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;While strategic design defines boundaries and fosters a shared understanding, tactical design brings those ideas to life within&lt;/span&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;&amp;nbsp;each bounded context.&lt;/span&gt;&lt;/p&gt;】&lt;p&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;在&lt;/span&gt;&lt;a href=&#34;https://dzone.com/articles/strategic-domain-driven-design&#34; target=&#34;_blank&#34;&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;上一篇文章&lt;/span&gt;&lt;/a&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;中，我讨论了领域驱动设计中最常被忽视的方面：战略方面。当谈到软件开发时，团队往往会急于编写代码，相信实现会澄清领域。历史表明了相反的情况——在不了解根本原因或方向的情况下进行构建通常会导致技术上正确但概念上错误的系统。正如&lt;/span&gt;&lt;em&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;策略&lt;/span&gt;&lt;/em&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;（&lt;/span&gt;&lt;em&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;strategos&lt;/span&gt;&lt;/em&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;“将军的艺术”）的古老拉丁词根所暗示的那样，计划必须先于运动。&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;现在我们已经探讨了“为什么”和“什么”，现在是时候讨论“如何”了。战术 DDD 代表了下一步——将易于理解的领域转换为富有表现力、可维护的代码的过程。 &lt;/span&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;虽然战略设计定义了边界并促进了共同理解，但战术设计却在&lt;/span&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;每个有界上下文中将这些想法变为现实。&lt;/span&gt;&lt;/p&gt;</description>
      <pubDate>Thu, 06 Nov 2025 14:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【The JVM Pause That Wasn&#39;t: A War Story】JVM 暂停并非如此：一个战争故事</title>
      <link>https://dzone.com/articles/the-jvm-pause-that-wasnt-a-war-story</link>
      <description>【&lt;p&gt;In high-performance computing, we are trained to hunt for bottlenecks in our code, our algorithms, or our infrastructure. But my favorite bug was not in any of those. It was an invisible interaction between the JVM&#39;s garbage collector and the server&#39;s disk, resulting in 15+ second, stop-the-world (STW) pauses on a service handling millions of requests per second.&lt;/p&gt;&#xA;&lt;h2&gt;&lt;strong&gt;The Mystery: The 503 Spikes&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;I was working on a large-scale Java service handling millions of user requests per second. The system was designed for extreme throughput, but we were plagued by intermittent spikes in load balancer timeouts, causing 503 responses to be returned to the users.&amp;nbsp;&lt;/p&gt;】&lt;p&gt;在高性能计算中，我们被训练去寻找代码、算法或基础设施中的瓶颈。但我最喜欢的 bug 并不在其中。这是 JVM 的垃圾收集器和服务器磁盘之间的隐形交互，导致每秒处理数百万个请求的服务出现 15 秒以上的停止世界 (STW) 暂停。&lt;/p&gt;&#xA;&lt;h2&gt;&lt;strong&gt;谜团：503 个尖峰&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;我当时正在开发一个每秒处理数百万个用户请求的大型 Java 服务。该系统是为极高的吞吐量而设计的，但我们受到负载均衡器超时间歇性峰值的困扰，导致向用户返回 503 响应。 &lt;/p&gt;</description>
      <pubDate>Thu, 06 Nov 2025 13:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Master Production-Ready Big Data, Apache Spark Jobs in Databricks and Beyond: An Expert Guide】掌握 Databricks 及其他领域的生产就绪型大数据、Apache Spark 作业：专家指南</title>
      <link>https://dzone.com/articles/optimizing-apache-spark-jobs-in-databricks</link>
      <description>【&lt;p&gt;This iteration is based on existing experience scaling big data with Apache Spark workloads and uses more refinements by still preserving the eight most important strategies but moving high-value but less important strategies — such as preferring narrow transformations, applying code-level best practices, leveraging Databricks Runtime features, and optimizing cluster configuration — to a Miscellaneous section, thereby not losing focus on impactful areas such as shuffles and memory, but still addressing them thoroughly.&amp;nbsp;&lt;/p&gt;&#xA;&lt;p&gt;Diagrams for in-phased insights and example code can be completely executed in Databricks or vanilla Spark sessions, and for all of these to be worth your time, the application will yield unbelievable performance benefits, often in the range of 5–20x in real-world pipelines.&lt;/p&gt;】&lt;p&gt;此迭代基于使用 Apache Spark 工作负载扩展大数据的现有经验，并通过仍然保留八个最重要的策略但将高价值但不太重要的策略（例如更喜欢窄转换、应用代码级最佳实践、利用 Databricks 运行时功能和优化集群配置）移至其他部分来进行更多改进，从而不会失去对洗牌和内存等有影响力的领域的关注，但仍然彻底解决它们。 &lt;/p&gt;&#xA;&lt;p&gt;分阶段见解和示例代码的图表可以在 Databricks 或 vanilla Spark 会话中完全执行，并且为了让所有这些都值得您花时间，该应用程序将产生令人难以置信的性能优势，通常在实际管道中的 5-20 倍范围内。&lt;/p&gt;</description>
      <pubDate>Thu, 06 Nov 2025 12:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Bridging the Divide: Tactical Security Approaches for Vendor Integration in Hybrid Architectures】弥合鸿沟：混合架构中供应商集成的战术安全方法</title>
      <link>https://dzone.com/articles/securing-vendor-integration-hybrid-environments</link>
      <description>【&lt;p&gt;Security architecture in hybrid environments has traditionally focused on well-known concepts such as OWASP vulnerabilities, identity and access management, role-based access control, network security, and the principle of least privilege. Best practices like secure coding and incorporating SAST/DAST testing into CI/CD pipelines are also widely discussed.&lt;/p&gt;&#xA;&lt;p&gt;However, when organizations operate in a hybrid model — running workloads both on-premises and in the cloud — while also integrating with vendor-managed cloud solutions, a different set of security design considerations comes into play. These scenarios are not uncommon, yet they are rarely highlighted in the context of secure solution implementation involving vendor software in hybrid environments.&lt;/p&gt;】&lt;p&gt;混合环境中的安全架构传统上侧重于众所周知的概念，例如 OWASP 漏洞、身份和访问管理、基于角色的访问控制、网络安全和最小权限原则。安全编码和将 SAST/DAST 测试纳入 CI/CD 管道等最佳实践也得到了广泛讨论。&lt;/p&gt;&#xA;&lt;p&gt;但是，当组织采用混合模型运营时（在本地和云中运行工作负载）同时还与供应商管理的云解决方案集成，则需要考虑一组不同的安全设计注意事项。这些场景并不罕见，但在涉及混合环境中供应商软件的安全解决方案实施的背景下，它们很少被强调。&lt;/p&gt;</description>
      <pubDate>Wed, 05 Nov 2025 20:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>