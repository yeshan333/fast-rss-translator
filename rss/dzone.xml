<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DZone.com Feed</title>
    <link>https://feeds.dzone.com/home</link>
    <description>Recent posts on DZone.com</description>
    <item>
      <title>【Production-Ready Observability for Analytics Agents: An Open Telemetry Blueprint Across Retrieval, SQL, Redaction, and Tool Calls】分析代理的生产就绪可观测性：跨检索、SQL、编辑和工具调用的开放遥测蓝图</title>
      <link>https://dzone.com/articles/production-ready-observability-for-analytics-agent</link>
      <description>【&lt;p&gt;An analytics agent works great in demos: ask a question, and it fetches context, runs SQL queries, and summarizes the results. Then the real incident happens: a VP challenges a number, the security team asks whether restricted fields were exposed, or an auditor requests to see how the answer was produced and which controls were applied.&lt;/p&gt;&#xA;&lt;p data-end=&#34;634&#34; data-start=&#34;506&#34;&gt;Most teams can’t answer confidently because their observability was built for latency and debugging — not governance. They either:&lt;/p&gt;】&lt;p&gt;分析代理在演示中效果很好：提出问题，它会获取上下文、运行 SQL 查询并总结结果。然后，真正的事件发生了：副总裁询问一个数字，安全团队询问受限字段是否暴露，或者审计员要求查看答案是如何产生的以及应用了哪些控制。&lt;/p&gt;&#xA;&lt;p data-end=&#34;634&#34; data-start=&#34;506&#34;&gt;大多数团队无法自信地回答，因为他们的可观察性是为延迟和调试而构建的，而不是治理。他们要么：&lt;/p&gt;</description>
      <pubDate>Wed, 18 Feb 2026 20:00:16 +0000</pubDate>
    </item>
    <item>
      <title>【Mastering the Gemini 3 API: Architecting Next-Gen Multimodal AI Applications】掌握 Gemini 3 API：构建下一代多模式 AI 应用程序</title>
      <link>https://dzone.com/articles/mastering-the-gemini-3-api-architecting-next-gen-ai</link>
      <description>【&lt;p data-end=&#34;638&#34; data-start=&#34;212&#34;&gt;The landscape of &lt;a href=&#34;https://dzone.com/articles/guide-to-developing-llms-pretraining&#34;&gt;large language models (LLMs)&lt;/a&gt; has shifted from text-centric interfaces to truly multimodal reasoning engines. With the release of the Gemini 3 API, Google has introduced a paradigm shift in how developers interact with artificial intelligence. Gemini 3 isn’t just an incremental update; it represents a fundamental advancement in native multimodality, expanded context windows, and efficient agentic workflows.&lt;/p&gt;&#xA;&lt;p data-end=&#34;881&#34; data-start=&#34;640&#34;&gt;In this technical deep dive, we will explore the architecture of Gemini 3, compare its capabilities with previous generations, and walk through the implementation of a production-ready AI feature: a &lt;a href=&#34;https://dzone.com/articles/understanding-multimodal-applications-when-ai-mode&#34;&gt;Multimodal Intelligent Research Assistant&lt;/a&gt;.&lt;/p&gt;】&lt;p data-end=&#34;638&#34; data-start=&#34;212&#34;&gt;&lt;a href=&#34;https://dzone.com/articles/guide-to-developing-llms-pretraining&#34;&gt;大型语言模型 (LLM)&lt;/a&gt; 的格局已从以文本为中心的界面转变为真正的多模式推理引擎。随着 Gemini 3 API 的发布，谷歌在开发人员与人工智能交互的方式上引入了范式转变。 Gemini 3 不仅仅是增量更新；它代表了本机多模态、扩展的上下文窗口和高效的代理工作流程的根本性进步。&lt;/p&gt;&#xA;&lt;p data-end=&#34;881&#34; data-start=&#34;640&#34;&gt;在本次技术深入探讨中，我们将探索 Gemini 3 的架构，将其功能与前几代产品进行比较，并逐步实施可用于生产的 AI 功能：&lt;a href=&#34;https://dzone.com/articles/understanding-multimodal-applications-when-ai-mode&#34;&gt;多模态智能研究助手&lt;/a&gt;。&lt;/p&gt;</description>
      <pubDate>Wed, 18 Feb 2026 19:00:10 +0000</pubDate>
    </item>
    <item>
      <title>【10 Go Best Practices Every Backend Developer Should Know】每个后端开发人员都应该知道的 10 个 Go 最佳实践</title>
      <link>https://dzone.com/articles/10-go-best-practices-every-backend-developer-shoul</link>
      <description>【&lt;p data-end=&#34;556&#34; data-start=&#34;175&#34;&gt;Go has become a cornerstone language for building scalable backend services, cloud-native applications, and DevOps tooling. While Go’s simplicity is one of its greatest strengths, writing production-ready Go code requires more than just knowing the syntax. This guide distills practical best practices that teams can adopt to improve code quality, consistency, and maintainability.&lt;/p&gt;&#xA;&lt;p&gt;If you&#39;re new to Go, start with the &lt;a href=&#34;https://go.dev/doc/&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;official Go documentation&lt;/a&gt; and &lt;a href=&#34;https://go.dev/doc/effective_go&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;Effective Go&lt;/a&gt;. This article builds on those foundations with team-specific patterns that work well in enterprise environments.&lt;/p&gt;】&lt;p data-end=&#34;556&#34; data-start=&#34;175&#34;&gt;Go 已成为构建可扩展后端服务、云原生应用程序和 DevOps 工具的基石语言。虽然 Go 的简单性是其最大的优势之一，但编写可用于生产的 Go 代码需要的不仅仅是了解语法。本指南提炼了团队可以采用的实用最佳实践来提高代码质量、一致性和可维护性。&lt;/p&gt;&#xA;&lt;p&gt;如果您是 Go 新手，请从&lt;a href=&#34;https://go.dev/doc/&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;Go 官方文档&lt;/a&gt;和&lt;a href=&#34;https://go.dev/doc/ effective_go&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;Effective Go&lt;/a&gt;开始。本文建立在这些基础上，具有在企业环境中运行良好的特定于团队的模式。&lt;/p&gt;</description>
      <pubDate>Wed, 18 Feb 2026 18:00:18 +0000</pubDate>
    </item>
    <item>
      <title>【From On-Call to On-Guard: Hardening Incident Response Against Security-Driven Outages】从待命到待命：强化针对安全驱动的中断的事件响应</title>
      <link>https://dzone.com/articles/hardening-incident-response-security-outages</link>
      <description>【&lt;p&gt;The pager doesn&#39;t care why production is burning. A compromised credential chain triggering mass file encryption demands the same midnight scramble as a misconfigured load balancer taking down the payment gateway. Yet most organizations still maintain separate playbooks, separate escalation trees, separate war rooms for &#34;technical incidents&#34; versus &#34;security incidents&#34; — as if attackers politely wait for the right team to clock in.&lt;/p&gt;&#xA;&lt;p&gt;This artificial boundary is killing response times when every minute counts.&lt;/p&gt;】&lt;p&gt;寻呼机不关心为什么生产正在燃烧。触发大量文件加密的受损凭证链需要与配置错误的负载均衡器关闭支付网关相同的午夜混乱。然而，大多数组织仍然为“技术事件”和“安全事件”维护单独的剧本、单独的升级树、单独的作战室——就好像攻击者礼貌地等待正确的团队打卡一样。&lt;/p&gt;&#xA;&lt;p&gt;当每一分钟都很重要时，这种人为的边界正在缩短响应时间。&lt;/p&gt;</description>
      <pubDate>Wed, 18 Feb 2026 17:00:05 +0000</pubDate>
    </item>
    <item>
      <title>【How to Build Permission-Aware Retrieval That Doesn&#39;t Leak Across Teams】如何构建不会在团队之间泄漏的权限感知检索</title>
      <link>https://dzone.com/articles/build-secure-permission-aware-retrieval</link>
      <description>【&lt;p&gt;LLM assistants or chatbots are very good at connecting the dots, which is exactly why they can be dangerous in multi-team organizations. A PM from team A asks, &#39;Why did the churn rate spike last Wednesday?&#39; The assistant retrieves and displays an answer written by Team B, which includes customer names and contact details. Even if you block the final answer, the leak may have already occurred through retried snippets, intermediate summaries, cached results, etc.&lt;/p&gt;&#xA;&lt;p&gt;If your retrieval layer isn&#39;t permission-aware end-to-end, the model can pull context from other teams&#39; documents, tickets, dashboards, or embeddings. This is not just about blocking access. In reality, leaks happen during retrieval, summarization, inside tool traces/logs, or via shared embedding stores.&lt;/p&gt;】&lt;p&gt;LLM 助理或聊天机器人非常擅长将各个点连接起来，这正是它们在多团队组织中可能很危险的原因。 A 团队的一位产品经理问道：“为什么上周三客户流失率突然飙升？”助理检索并显示 B 团队编写的答案，其中包括客户姓名和联系方式。即使您阻止最终答案，泄漏也可能已经通过重试片段、中间摘要、缓存结果等发生。&lt;/p&gt;&#xA;&lt;p&gt;如果您的检索层不是端到端的权限感知，则模型可以从其他团队的文档、票证、仪表板或嵌入中提取上下文。这不仅仅是阻止访问。实际上，泄漏发生在检索、汇总、内部工具跟踪/日志或通过共享嵌入存储期间。&lt;/p&gt;</description>
      <pubDate>Wed, 18 Feb 2026 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Testing Legacy JSP Code】测试旧版 JSP 代码</title>
      <link>https://dzone.com/articles/testing-legacy-jsp</link>
      <description>【&lt;p dir=&#34;ltr&#34;&gt;JSP might be old, not fancy, or trendy anymore, but many legacy systems still use it, and there are development teams tasked with maintaining and extending systems with a JSP frontend (see &lt;a href=&#34;https://webtechsurvey.com/technology/javaserver-pages&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;https://webtechsurvey.com/technology/javaserver-pages&lt;/a&gt;). What can you do when you need to work on a code base that has unit tests for the Java code, but a significant part of the code base is living in (an untested) frontend code and is prone to failures?&amp;nbsp;&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;You can rely on code reviews or &lt;a href=&#34;https://dzone.com/articles/7-ways-to-manage-pull-requests&#34;&gt;pull requests&lt;/a&gt;, but that seems insufficient to flag even trivial issues. You can wait for manual testers or automated UI tests to find problems after the change was deployed to the QA environment, but that is way too late and cumbersome.&lt;/p&gt;】&lt;p dir=&#34;ltr&#34;&gt;JSP 可能已经过时、不再花哨或流行，但许多遗留系统仍在使用它，并且有开发团队负责维护和扩展具有 JSP 前端的系统（请参阅&lt;a href=&#34;https://webtechsurvey.com/technology/javaserver-pages&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;https://webtechsurvey.com/technology/javaserver-pages&lt;/a&gt;）。当您需要处理具有 Java 代码单元测试的代码库，但代码库的很大一部分位于（未经测试的）前端代码并且容易出现故障时，您该怎么办？ &lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;您可以依靠代码审查或&lt;a href=&#34;https://dzone.com/articles/7-ways-to-manage-pull-requests&#34;&gt;拉取请求&lt;/a&gt;，但这似乎不足以标记甚至微不足道的问题。您可以等待手动测试人员或自动化 UI 测试在将更改部署到 QA 环境后发现问题，但这太晚了而且很麻烦。&lt;/p&gt;</description>
      <pubDate>Wed, 18 Feb 2026 15:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Why “At-Least-Once” Is a Lie: Lessons from Java Event Systems at Global Scale】为什么“至少一次”是一个谎言：全球范围内 Java 事件系统的经验教训</title>
      <link>https://dzone.com/articles/at-least-once-java-events-lessons</link>
      <description>【&lt;p dir=&#34;ltr&#34;&gt;At-least-once delivery is treated like a safety net in Java event systems. Nothing gets lost. Retries handle failures. Duplicates are “a consumer problem.” It sounds practical, even mature.&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;That assumption doesn’t survive production.&lt;/p&gt;】&lt;p dir=&#34;ltr&#34;&gt;至少一次传递被视为 Java 事件系统中的安全网。没有什么会丢失。重试处理失败。重复是“消费者的问题”。听起来很实用，甚至很成熟。&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;这种假设在生产中无法生存。&lt;/p&gt;</description>
      <pubDate>Wed, 18 Feb 2026 14:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Functional Scaffolding for LLM Solutions】LLM 解决方案的功能脚手架</title>
      <link>https://dzone.com/articles/functional-scaffolding-for-llm-solutions</link>
      <description>【&lt;h2 data-end=&#34;326&#34; data-start=&#34;228&#34;&gt;Slingshot Your Way to Secure, Efficient AI Solutions&lt;/h2&gt;&#xA;&lt;p data-end=&#34;570&#34; data-start=&#34;328&#34;&gt;I have always been fascinated by the elliptical trail maneuvers of &lt;a href=&#34;https://www.scientificamerican.com/article/how-does-a-gravitational-slingshot-work/&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;gravity-assisted slingshots in rocketry&lt;/a&gt;. Somehow, it feels comparable to how we reach our goals in the AI solutions world — moving from a starting point to a target destination.&lt;/p&gt;&#xA;&lt;p data-end=&#34;1233&#34; data-start=&#34;786&#34;&gt;A gravitational slingshot leverages every planet in its path — using each body’s gravity to gain momentum (saving fuel in the process) — until the spacecraft is flung toward its destination. The starting point is analogous to our problem statement, and the destination is the target state we wish to achieve with AI agents. The smarter the agents, the greater the efficiency, the less compute “fuel” burned, and the faster we reach the final solution.&lt;/p&gt;】&lt;h2 data-end=&#34;326&#34; data-start=&#34;228&#34;&gt;Slingshot 打造安全、高效的 AI 解决方案&lt;/h2&gt;&#xA;&lt;p data-end=&#34;570&#34; data-start=&#34;328&#34;&gt;我一直对火箭中重力辅助弹弓的椭圆轨迹机动着迷&lt;/a&gt;。不知何故，这感觉就像我们在人工智能解决方案世界中实现目标的方式一样——从起点到目标目的地。&lt;/p&gt;&#xA;&lt;p data-end=&#34;1233&#34; data-start=&#34;786&#34;&gt;引力弹弓利用其路径上的每颗行星 - 利用每个物体的重力来获得动量（在此过程中节省燃料） - 直到航天器被抛向目的地。起点类似于我们的问题陈述，目的地是我们希望通过人工智能代理实现的目标状态。代理越聪明，效率就越高，消耗的计算“燃料”就越少，我们就能更快地找到最终解决方案。&lt;/p&gt;</description>
      <pubDate>Wed, 18 Feb 2026 13:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【When Kubernetes Forgets: The 90-Second Evidence Gap】当 Kubernetes 忘记时：90 秒的证据差距</title>
      <link>https://dzone.com/articles/kubernetes-the-90-second-evidence-gap</link>
      <description>【&lt;article&gt;&#xA; &lt;h2&gt;The Contradiction&lt;/h2&gt;&#xA; &lt;div data-ast-blocks-layout=&#34;true&#34; itemprop=&#34;text&#34;&gt;&#xA;  &lt;p&gt;At 3:47 AM, your monitoring dashboard shows a healthy Kubernetes cluster — 99.97% availability. Your customers report a complete outage.&lt;/p&gt;&#xA;  &lt;p&gt;Ninety seconds later, the pod has self-healed. Metrics look normal. The restart counter reads “1.” But why it restarted — what actually happened — has vanished. This isn’t a tooling failure. The system simply recovered faster than a human could observe.&lt;/p&gt;】&lt;文章&gt;&#xA; &lt;h2&gt;矛盾&lt;/h2&gt;&#xA; &lt;div data-ast-blocks-layout=&#34;true&#34; itemprop=&#34;text&#34;&gt;&#xA;  &lt;p&gt;凌晨 3:47，您的监控仪表板显示运行状况良好的 Kubernetes 集群 — 可用性为 99.97%。您的客户报告完全中断。&lt;/p&gt;&#xA;  &lt;p&gt;九十秒后，pod 已自我修复。指标看起来很正常。重启计数器读数为“1”。但为什么它会重新启动——到底发生了什么——已经消失了。这不是工具故障。该系统的恢复速度比人类观察到的要快。&lt;/p&gt;</description>
      <pubDate>Wed, 18 Feb 2026 12:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Diffs Are Dead. Why You Need Scalable Previews.】差异已死。为什么您需要可扩展的预览。</title>
      <link>https://dzone.com/articles/diffs-are-dead-why-you-need-scalable-previews</link>
      <description>【&lt;p&gt;The software development lifecycle (SDLC) is going through a massive shift as coding agents become increasingly ubiquitous in the industry. While this has very visible impacts that have been widely documented, it also results in more subtle changes that are less obvious.&lt;/p&gt;&#xA;&lt;p&gt;I noticed one of those changes recently: code review has all but died without us noticing. I have seen this happen on my own engineering team. Senior engineers known for meticulous review are approving &lt;a href=&#34;https://dzone.com/articles/the-pull-request-paradox-merge-faster-by-promoting&#34;&gt;pull requests&lt;/a&gt; (PRs) within minutes.&lt;/p&gt;】&lt;p&gt;随着编码代理在行业中变得越来越普遍，软件开发生命周期 (SDLC) 正在经历巨大的转变。虽然这具有非常明显的影响并已被广泛记录，但它也会导致更微妙的、不太明显的变化。&lt;/p&gt;&#xA;&lt;p&gt;我最近注意到其中一个变化：代码审查几乎在我们没有注意到的情况下消失了。我在自己的工程团队中见过这种情况。以细致审查而闻名的高级工程师会在几分钟内批准&lt;a href=&#34;https://dzone.com/articles/the-pull-request-paradox-merge-faster-by-promoting&#34;&gt;拉取请求&lt;/a&gt; (PR)。&lt;/p&gt;</description>
      <pubDate>Tue, 17 Feb 2026 20:41:22 +0000</pubDate>
    </item>
  </channel>
</rss>