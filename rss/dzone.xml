<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DZone.com Feed</title>
    <link>https://feeds.dzone.com/home</link>
    <description>Recent posts on DZone.com</description>
    <item>
      <title>【What OpenAI&#39;s Reasoning Models Mean for GPT and AI】OpenAI 的推理模型对 GPT 和 AI 意味着什么</title>
      <link>https://dzone.com/articles/what-openai-reasoning-models-mean-for-gpt-and-ai</link>
      <description>【&lt;p&gt;OpenAI’s latest announcement about its reasoning models has really made me pause and think about where AI is headed. Over the years, I have seen GPT models evolve from something experimental to tools we now rely on daily for everything from content creation to customer support. But as impressive as GPT is, we have all noticed its shortcomings, especially when it’s tasked with solving complex problems or making logical connections. That’s why the idea of reasoning models feels like such a big step forward. It’s not just an upgrade; it’s a shift in what AI is capable of.&lt;/p&gt;&#xA;&lt;p&gt;So, what are &lt;a href=&#34;https://dzone.com/articles/reasoner-models-test-time-compute&#34;&gt;reasoning models&lt;/a&gt; really about? And how will they change the AI landscape we have gotten so used to?&lt;/p&gt;】&lt;p&gt;OpenAI 关于其推理模型的最新公告确实让我停下来思考人工智能的发展方向。多年来，我看到 GPT 模型从实验性的东西发展成为我们现在每天依赖的工具，从内容创建到客户支持。但尽管 GPT 令人印象深刻，我们都注意到了它的缺点，尤其是当它的任务是解决复杂问题或建立逻辑联系时。这就是为什么推理模型的想法感觉像是向前迈出了一大步。这不仅仅是一次升级；这是人工智能能力的转变。&lt;/p&gt;&#xA;&lt;p&gt;那么，&lt;a href=&#34;https://dzone.com/articles/reasoner-models-test-time-compute&#34;&gt;推理模型&lt;/a&gt;到底是什么？他们将如何改变我们已经习以为常的人工智能格局？&lt;/p&gt;</description>
      <pubDate>Thu, 23 Jan 2025 17:00:14 +0000</pubDate>
    </item>
    <item>
      <title>【Building an AI-Powered Cold Email System With CrewAI】使用 CrewAI 构建人工智能驱动的冷电子邮件系统</title>
      <link>https://dzone.com/articles/building-ai-powered-cold-email-system-with-crewai</link>
      <description>【&lt;p&gt;Cold emailing remains one of the most effective ways to reach potential employers or clients, but crafting personalized, compelling messages at scale can be challenging. CrewAI is a framework for creating AI agent teams to automate and enhance cold email outreach.&amp;nbsp;&lt;/p&gt;&#xA;&lt;p&gt;In this tutorial, we&#39;ll build a sophisticated cold email system using CrewAI that researches companies, generates personalized templates, and provides strategic insights.&lt;/p&gt;】&lt;p&gt;冷电子邮件仍然是接触潜在雇主或客户的最有效方式之一，但大规模制作个性化、引人注目的消息可能具有挑战性。 CrewAI 是一个用于创建 AI 代理团队的框架，用于自动化和增强冷电子邮件推广。 &lt;/p&gt;&#xA;&lt;p&gt;在本教程中，我们将使用 CrewAI 构建一个复杂的冷电子邮件系统，用于研究公司、生成个性化模板并提供战略见解。&lt;/p&gt;</description>
      <pubDate>Thu, 23 Jan 2025 16:00:09 +0000</pubDate>
    </item>
    <item>
      <title>【Secure Your Frontend: Practical Tips for Developers】保护您的前端：开发人员的实用技巧</title>
      <link>https://dzone.com/articles/secure-your-frontend-practical-tips-for-developers</link>
      <description>【&lt;p&gt;Let’s face it: frontend security often gets overlooked. With so much focus on UI/UX and performance, it’s easy to assume that back-end APIs and firewalls are taking care of all the heavy lifting. But the reality is that your beautiful React or Vue app could be a ticking time bomb if you’re not paying attention to security.&lt;/p&gt;&#xA;&lt;p&gt;Having spent years building front-end applications and learning (sometimes the hard way), I’ve picked up a few essential practices that every developer should follow to keep their apps secure. Here are some practical, battle-tested tips to secure your frontend and sleep better at night.&lt;/p&gt;】&lt;p&gt;让我们面对现实：前端安全经常被忽视。由于如此关注 UI/UX 和性能，很容易认为后端 API 和防火墙正在处理所有繁重的工作。但现实是，如果您不注意安全性，您漂亮的 React 或 Vue 应用程序可能会成为一颗定时炸弹。&lt;/p&gt;&#xA;&lt;p&gt;经过多年构建前端应用程序和学习（有时是艰难的方式），我已经掌握了每个开发人员都应该遵循的一些基本实践，以确保他们的应用程序安全。这里有一些实用的、经过实战考验的技巧，可以保护您的前端并在晚上睡得更好。&lt;/p&gt;</description>
      <pubDate>Thu, 23 Jan 2025 20:00:01 +0000</pubDate>
    </item>
    <item>
      <title>【NoSQL for Relational Minds】NOSQL的关系思维</title>
      <link>https://dzone.com/articles/nosql-for-relational-minds</link>
      <description>【&lt;p&gt;When developers first think about managing data or choosing a database for their application, the first thing that often comes to their mind is —&amp;nbsp;&lt;/p&gt;&#xA;&lt;p&gt;— that’s right, a table.&lt;/p&gt;】&lt;p&gt;当开发人员首先考虑管理数据或为其应用程序选择数据库时，他们首先想到的往往是 - &lt;/p&gt;&#xA;&lt;p&gt;——没错，是一张桌子。&lt;/p&gt;</description>
      <pubDate>Thu, 23 Jan 2025 21:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Phased Migration Strategy for Zero Downtime in Systems】系统零停机的分阶段迁移策略</title>
      <link>https://dzone.com/articles/phased-migration-strategy-zero-downtime</link>
      <description>【&lt;p&gt;In distributed systems, multiple services work together to complete a task, each managed by different teams and evolving independently. This often leads to the need for dependency migrations, such as database schema updates, external service upgrades, or changes in data sources. These migrations are a crucial part of the development lifecycle and require thorough planning and execution to prevent rollbacks, data inconsistencies, and operational disruptions.&lt;/p&gt;&#xA;&lt;h2&gt;Examples of Software Migration&lt;/h2&gt;&#xA;&lt;p&gt;Before exploring migration strategies, it&#39;s important to understand common scenarios that necessitate software migrations and require detailed planning:&lt;/p&gt;】&lt;p&gt;在分布式系统中，多个服务共同完成了一项任务，每个服务由不同的团队管理并独立发展。这通常会导致需要依赖性迁移，例如数据库架构更新，外部服务升级或数据源的更改。这些迁移是开发生命周期的关键部分，需要彻底的计划和执行，以防止回滚，数据不一致和操作中断。&lt;/p&gt;&#xA;&lt;h2&gt;软件迁移的示例&lt;/h2&gt;&#xA;&lt;p&gt;在探索迁移策略之前，重要的是要了解需要软件迁移并需要详细规划的常见场景：&lt;/p&gt;</description>
      <pubDate>Thu, 23 Jan 2025 22:00:08 +0000</pubDate>
    </item>
    <item>
      <title>【An Introduction to Bloom Filters】布隆过滤器简介</title>
      <link>https://dzone.com/articles/introduction-to-bloom-filters</link>
      <description>【&lt;p&gt;The Bloom filter is a lesser-known data structure that is not widely used by developers. It is a space-efficient, highly probabilistic data structure that every developer should be familiar with. It can significantly speed up exact match queries, especially in cases where indexing has not been added to that field. The space efficiency of a Bloom filter provides the added advantage of allowing filters to be created for multiple fields.&lt;/p&gt;&#xA;&lt;h2&gt;How It Works&lt;/h2&gt;&#xA;&lt;p&gt;Reading from a database or storage is a costly operation. To optimize this, we use a &lt;a href=&#34;https://dzone.com/articles/bloom-filters-efficient-data-filtering-with-practi&#34;&gt;Bloom filter&lt;/a&gt; to check the availability of a key-value pair and only perform a database read if the filter responds with a &#39;Yes.&#39; Bloom filters are space-efficient and can be stored in memory. Additionally, the lookup test for a value can be performed in O(1) time. More on this later. Let’s explore this concept with an example:&lt;/p&gt;】&lt;p&gt; Bloom过滤器是鲜为人知的数据结构，开发人员未广泛使用。这是每个开发人员都应该熟悉的空间效率，高度概率的数据结构。它可以大大加快匹配查询的加快，尤其是在尚未将索引添加到该字段的情况下。 Bloom过滤器的空间效率提供了允许为多个字段创建过滤器的额外优势。&lt;/p&gt;&#xA;&lt;h2&gt;它如何工作&lt;/h2&gt;&#xA;&lt;p&gt;从数据库或存储中读取是一个昂贵的操作。为了优化这一点，我们使用a &lt;a href =“ https://dzone.com/articles/bloom-filters-filters-filter-data-filtering-with-practi”&gt; bloom filter &lt;/a&gt;检查键的可用性 - 值配对，仅执行数据库，如果过滤器以“是”响应，则读取数据库。 Bloom过滤器是空间效率的，可以存储在内存中。此外，可以在O（1）时间内执行值的查找测试。稍后再详细介绍。让我们以一个例子来探索这个概念：&lt;/p&gt;</description>
      <pubDate>Thu, 23 Jan 2025 14:00:09 +0000</pubDate>
    </item>
    <item>
      <title>【Mocking and Its Importance in Integration and E2E Testing】模拟及其在集成和E2E测试中的重要性</title>
      <link>https://dzone.com/articles/mocking-importance-in-integration-e2e-testing</link>
      <description>【&lt;p&gt;In the software development lifecycle (SDLC), testing is one of the important stages where we ensure that the application works as expected and meets end-user requirements. Among the various techniques that we use for testing, mocking plays a crucial role in testing different components of a system, especially when the external services that the application is dependent on are not yet ready or deployed.&lt;/p&gt;&#xA;&lt;p&gt;&lt;span&gt;With that being said, let’s try to understand what mocking is and how it helps in &lt;/span&gt;&lt;a href=&#34;https://dzone.com/articles/integration-testing-what-it-is-and-how-to-do-it-ri&#34;&gt;&lt;span&gt;integration testing&lt;/span&gt;&lt;/a&gt;&lt;span&gt; and&amp;nbsp;&lt;/span&gt;&lt;a href=&#34;https://dzone.com/articles/what-is-end-to-end-testing-3&#34;&gt;&lt;span&gt;end-to-end (E2E) testing&lt;/span&gt;&lt;/a&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;】&lt;p&gt;在软件开发生命周期（SDLC）中，测试是确保应用程序按预期工作并满足最终用户要求的重要阶段之一。在我们用于测试的各种技术中，嘲笑在测试系统的不同组件中起着至关重要的作用，尤其是当应用程序所依赖的外部服务尚未准备就绪或部署时。&lt;/p&gt;&#xA;&lt;p&gt; &lt;span&gt;话虽如此，让我们尝试了解嘲笑是什么，以及它在&lt;/span&gt; &lt;a href =“ https://dzone.com/articles/integration-testing-what-what-it-it-- is-and-and-how-how-to-do-it-ri“&gt; &lt;span&gt;集成测试&lt;/span&gt; &lt;/a&gt; &lt;span&gt;和&lt;/span&gt; &lt;a href =” https://dzone.com/articles /what-is-end-end-to-end-testing-3“&gt; &lt;span&gt;端到端（E2E）测试&lt;/span&gt; &lt;/a&gt; &lt;span&gt;。&lt;/span&gt;。&lt;/span&gt; &lt;/p&gt;</description>
      <pubDate>Thu, 23 Jan 2025 15:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Powering LLMs With Apache Camel and LangChain4j】用Apache Camel和Langchain4J为LLM供电</title>
      <link>https://dzone.com/articles/powering-llms-with-apache-camel-and-langchain4j</link>
      <description>【&lt;p&gt;LLMs need to connect to the real world. LangChain4j tools, combined with Apache Camel, make this easy. Camel provides robust integration, connecting your LLM to any service or API. This lets your AI interact with databases, queues, and more, creating truly powerful applications. We&#39;ll explore this powerful combination and its potential.&lt;/p&gt;&#xA;&lt;h2&gt;&lt;strong&gt;Setting Up the Development Environment&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA; &lt;li&gt;&lt;strong&gt;Ollama&lt;/strong&gt;: Provides a way to run large language models (LLMs) locally. You can run &lt;a href=&#34;https://ollama.com/library&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;many models&lt;/a&gt;, such as LLama3, &lt;a href=&#34;https://dzone.com/articles/use-mistral-ai-to-build-generative-ai-apps-with-go&#34;&gt;Mistral&lt;/a&gt;, CodeLlama, and many others on your machine, with full CPU and GPU support.&lt;/li&gt;&#xA; &lt;li&gt;&lt;strong&gt;Visual Studio Code&lt;/strong&gt;: With Kaoto, &lt;a href=&#34;https://dzone.com/articles/java-21-features-a-detailed-look&#34;&gt;Java&lt;/a&gt;, and Quarkus plugins installed.&lt;/li&gt;&#xA; &lt;li&gt;&lt;strong&gt;OpenJDK 21&lt;/strong&gt;&lt;/li&gt;&#xA; &lt;li&gt;&lt;strong&gt;Maven&lt;/strong&gt;&lt;/li&gt;&#xA; &lt;li&gt;&lt;strong&gt;Quarkus 3.17&lt;/strong&gt;&lt;/li&gt;&#xA; &lt;li&gt;&lt;span style=&#34;margin: 0px; padding: 0px;&#34;&gt;&lt;strong&gt;Quarkus Dev Services&lt;/strong&gt;: A feature of&amp;nbsp;&lt;/span&gt;&lt;a href=&#34;https://dzone.com/refcardz/getting-started-with-quarkus-serverless-functions&#34;&gt;&lt;span style=&#34;margin: 0px; padding: 0px;&#34;&gt;Quarkus&lt;/span&gt;&lt;/a&gt;&lt;span style=&#34;margin: 0px; padding: 0px;&#34;&gt;&amp;nbsp;that simplifies the development and testing of applications the development and testing of applications that rely on external services such as databases, messaging systems, and other resources.&lt;/span&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;You can download the complete code at the following &lt;a href=&#34;https://github.com/mikeintoch/camel-agent-tools&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;GitHub repo&lt;/a&gt;.&lt;/p&gt;】&lt;p&gt; llms需要连接到现实世界。 Langchain4J工具与Apache Camel结合使用，使其变得容易。骆驼提供强大的集成，将LLM连接到任何服务或API。这使您的AI可以与数据库，队列等相互作用，从而创建真正强大的应用程序。我们将探索这种强大的组合及其潜力。&lt;/p&gt;&#xA;&lt;H2&gt; &lt;strong&gt;设置开发环境&lt;/strong&gt; &lt;/h2&gt;&#xA;&lt;ul&gt;&#xA; &lt;li&gt; &lt;strong&gt; ollama &lt;/strong&gt;：提供了一种在本地运行大型语言模型（LLM）的方法。您可以运行&lt;a href =“ https://ollama.com/library” rel =“ noopener noreferrer” target =“ _ blank”&gt;许多型号&lt;/a&gt;，例如llama3，&lt;a href =“ https：// dzone.com/articles/use-mistral-ai-to-build-generative-apps-with-go&#34;&gt; Mistral &lt;/a&gt;，Codellama以及您的机器上的许多其他人，并提供完整的CPU和GPU支持。&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; /li&gt;&#xA; &lt;li&gt; &lt;strong&gt; Visual Studio Code &lt;/strong&gt;：使用Kaoto，&lt;a href =“ https://dzone.com/articles/java-21-features-a-detailed-look-look”&gt; java &lt;/a&gt;和Quarkus插件已安装。&lt;/li&gt;&#xA; &lt;li&gt; &lt;strong&gt; OpenJDK 21 &lt;/strong&gt; &lt;/li&gt;&#xA; &lt;li&gt; &lt;strong&gt; maven &lt;/strong&gt; &lt;/li&gt;&#xA; &lt;li&gt; &lt;strong&gt; Quarkus 3.17 &lt;/strong&gt; &lt;/li&gt;&#xA; &lt;li&gt; &lt;span style =“ margin：0px; padding：0px;”&gt; &lt;strong&gt; Quarkus dev Services &lt;/strong&gt;：&lt;/span&gt; &lt;a href =的功能/Quarkus-Server-Server-server-with-server-server-server-server-server-server-server-server-server = &lt;span样式：0px; 0px;“&gt; quarkus &lt;/span&gt; &lt;/span&gt; &lt;span&gt; &lt;span style =” Margin：0px; 0px; ;“&gt;简化应用程序的开发和测试，开发和测试依赖外部服务的应用程序，例如数据库，消息传递系统和其他资源。&lt;/span&gt; &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;您可以在以下&lt;a href =“ https://github.com/mikeintoch/camel-agent-tools”中下载完整的代码。 &gt;。&lt;/p&gt;</description>
      <pubDate>Thu, 23 Jan 2025 13:00:13 +0000</pubDate>
    </item>
    <item>
      <title>【Multi-Tenant Data Isolation and Row Level Security】多租户数据隔离和行级安全性</title>
      <link>https://dzone.com/articles/multi-tenant-data-isolation-row-level-security</link>
      <description>【&lt;p&gt;Over the past one and a half years, I was involved in designing and developing a multi-tenant treasury management system. In this article, I will share our approaches to the data isolation aspect of our multi-tenant solution and the learnings from it.&lt;/p&gt;&#xA;&lt;h2&gt;Background and Problem Regarding Data Isolation&lt;/h2&gt;&#xA;&lt;p&gt;Before going into the problem that I will focus on today, I must first give some background into our architecture for storage and data in our system. When it comes to data partitioning for &lt;a href=&#34;https://dzone.com/articles/how-to-develop-saas-application-1&#34;&gt;SaaS systems&lt;/a&gt;, at the extreme far right end, we have the approach of using dedicated databases for each tenant (silo model), and on the other side of the spectrum is the shared database model (pool model).&lt;/p&gt;】&lt;p&gt;在过去的一年半中，我参与了设计和开发多租户的财政管理系统。在本文中，我将分享我们对多租户解决方案的数据隔离方面及其从中学习的方法。&lt;/p&gt;&#xA;&lt;h2&gt;有关数据隔离的背景和问题&lt;/h2&gt;&#xA;&lt;p&gt;在解决我今天要关注的问题之前，我必须首先为我们的系统中的存储和数据提供一些背景。当涉及到&lt;a href =“ https://dzone.com/articles/how-to-develops-saas-application-1”&gt; SaaS Systems &lt;/a&gt;的数据分区时具有为每个租户（筒仓模型）使用专用数据库的方法，在频谱的另一侧是共享数据库模型（池模型）。&lt;/p&gt;</description>
      <pubDate>Thu, 23 Jan 2025 18:00:03 +0000</pubDate>
    </item>
    <item>
      <title>【Refactoring Design Patterns in Python】Python中的重构设计模式</title>
      <link>https://dzone.com/articles/refactoring-design-patterns-python</link>
      <description>【&lt;section name=&#34;e9a8&#34;&gt;&#xA; &lt;blockquote name=&#34;a03c&#34;&gt;&#xA;  &lt;a data-href=&#34;https://github.com/douglasdcm/refactoring-to-patterns/blob/main/code_smells_table.py&#34; href=&#34;https://github.com/douglasdcm/refactoring-to-patterns/blob/main/code_smells_table.py&#34; rel=&#34;noopener&#34; target=&#34;_blank&#34;&gt;This table in Python&lt;/a&gt; contains a list of code smells and the design patterns that address them.&#xA; &lt;/blockquote&gt;&#xA; &lt;div class=&#34;codeMirror-wrapper&#34; contenteditable=&#34;false&#34;&gt;&#xA;  &lt;div contenteditable=&#34;false&#34;&gt;&#xA;   &lt;div class=&#34;codeHeader&#34;&gt;&#xA;    &lt;div class=&#34;nameLanguage&#34;&gt;&#xA;     Python&#xA;    &lt;/div&gt;&lt;i class=&#34;icon-cancel-circled-1 cm-remove&#34;&gt;&amp;nbsp;&lt;/i&gt;&#xA;   &lt;/div&gt;&#xA;   &lt;div class=&#34;codeMirror-code--wrapper&#34; data-code=&#34;class CodeSmells:&#xA;    Duplicated_Code = [&#xA;        form_template_method,&#xA;        introduce_polymorphic_creation_with_factory_method,&#xA;        chain_constructors,&#xA;        replace_one__many_distinctions_with_composite,&#xA;        extract_composite,&#xA;        unify_interfaces_with_adapter,&#xA;        introduce_null_object,&#xA;    ]&#xA;    Long_Method = [&#xA;        compose_method,&#xA;        move_accumulation_to_collecting_parameter,&#xA;        replace_conditional_dispatcher_with_command,&#xA;        move_accumulation_to_visitor,&#xA;        replace_conditional_logic_with_strategy,&#xA;    ]&#xA;    Conditional_Complexity = [  # Complicated conditonal logic&#xA;        replace_conditional_logic_with_strategy,&#xA;        move_emblishment_to_decorator,&#xA;        replace_state_altering_conditionals_with_state,&#xA;        introduce_null_object,&#xA;    ]&#xA;    Primitive_Obssession = [&#xA;        replace_type_code_with_class,&#xA;        replace_state_altering_conditionals_with_state,&#xA;        replace_conditional_logic_with_strategy,&#xA;        replace_implict_tree_with_composite,&#xA;        replace_implicit_language_with_interpreter,&#xA;        move_emblishment_to_decorator,&#xA;        encapsulate_composite_with_builder,&#xA;    ]&#xA;    # Lack of &amp;quot;information hiding&amp;quot; [Parnas]&#xA;    Indecent_Exposure = [encapsulate_classes_with_factory]&#xA;    # The logic/responsibility is sprawled in multiple places&#xA;    # (classes, methods)&#xA;    Solution_Sprawl = [move_creation_knowledge_to_factory]&#xA;    # [Fowler and Beck] Interfaces of classes different,&#xA;    # but classes are similar&#xA;    Alternative_Classes_with_Different_Interfaces = unify_interfaces_with_adapter&#xA;    # [Fowler and Beck] A class the doesn&#39;t do enough to pay itself&#xA;    Lazy_Class = [inline_singleton]&#xA;    Large_Class = [&#xA;        replace_conditional_dispatcher_with_command,&#xA;        replace_state_altering_conditionals_with_state,&#xA;        replace_implict_tree_with_composite,&#xA;    ]&#xA;    Switch_Statements = [  # Complicated switches&#xA;        replace_conditional_dispatcher_with_command,&#xA;        move_accumulation_to_visitor,&#xA;    ]&#xA;    # Code that do the same with different types or quantity of data&#xA;    # (similar to duplication)&#xA;    Combination_Explostion = [replace_implicit_language_with_interpreter]&#xA;    # The same problem being solved in many ways in the system&#xA;    # (similar to duplication)&#xA;    Oddball_Solutions = [unify_interfaces_with_adapter]&#34; data-lang=&#34;text/x-python&#34;&gt;&#xA;    &lt;pre&gt;&lt;code lang=&#34;text/x-python&#34;&gt;class CodeSmells:&#xA;    Duplicated_Code = [&#xA;        form_template_method,&#xA;        introduce_polymorphic_creation_with_factory_method,&#xA;        chain_constructors,&#xA;        replace_one__many_distinctions_with_composite,&#xA;        extract_composite,&#xA;        unify_interfaces_with_adapter,&#xA;        introduce_null_object,&#xA;    ]&#xA;    Long_Method = [&#xA;        compose_method,&#xA;        move_accumulation_to_collecting_parameter,&#xA;        replace_conditional_dispatcher_with_command,&#xA;        move_accumulation_to_visitor,&#xA;        replace_conditional_logic_with_strategy,&#xA;    ]&#xA;    Conditional_Complexity = [  # Complicated conditonal logic&#xA;        replace_conditional_logic_with_strategy,&#xA;        move_emblishment_to_decorator,&#xA;        replace_state_altering_conditionals_with_state,&#xA;        introduce_null_object,&#xA;    ]&#xA;    Primitive_Obssession = [&#xA;        replace_type_code_with_class,&#xA;        replace_state_altering_conditionals_with_state,&#xA;        replace_conditional_logic_with_strategy,&#xA;        replace_implict_tree_with_composite,&#xA;        replace_implicit_language_with_interpreter,&#xA;        move_emblishment_to_decorator,&#xA;        encapsulate_composite_with_builder,&#xA;    ]&#xA;    # Lack of &#34;information hiding&#34; [Parnas]&#xA;    Indecent_Exposure = [encapsulate_classes_with_factory]&#xA;    # The logic/responsibility is sprawled in multiple places&#xA;    # (classes, methods)&#xA;    Solution_Sprawl = [move_creation_knowledge_to_factory]&#xA;    # [Fowler and Beck] Interfaces of classes different,&#xA;    # but classes are similar&#xA;    Alternative_Classes_with_Different_Interfaces = unify_interfaces_with_adapter&#xA;    # [Fowler and Beck] A class the doesn&#39;t do enough to pay itself&#xA;    Lazy_Class = [inline_singleton]&#xA;    Large_Class = [&#xA;        replace_conditional_dispatcher_with_command,&#xA;        replace_state_altering_conditionals_with_state,&#xA;        replace_implict_tree_with_composite,&#xA;    ]&#xA;    Switch_Statements = [  # Complicated switches&#xA;        replace_conditional_dispatcher_with_command,&#xA;        move_accumulation_to_visitor,&#xA;    ]&#xA;    # Code that do the same with different types or quantity of data&#xA;    # (similar to duplication)&#xA;    Combination_Explostion = [replace_implicit_language_with_interpreter]&#xA;    # The same problem being solved in many ways in the system&#xA;    # (similar to duplication)&#xA;&amp;nbsp; &amp;nbsp; Oddball_Solutions = [unify_interfaces_with_adapter]&lt;/code&gt;&lt;/pre&gt;&#xA;   &lt;/div&gt;&#xA;  &lt;/div&gt;&#xA; &lt;/div&gt;&#xA; &lt;p&gt;&lt;br&gt;&lt;/p&gt;&#xA;&lt;/section&gt;&#xA;&lt;section name=&#34;7ea0&#34;&gt;&#xA; &lt;h2 name=&#34;10f7&#34;&gt;The Journey&lt;/h2&gt;&#xA; &lt;p name=&#34;f93f&#34;&gt;After nearly a year of effort, I’ve finally completed my self-imposed goal of writing all the refactoring examples from the book &lt;a data-href=&#34;https://www.amazon.com/Refactoring-Patterns-Joshua-Kerievsky/dp/0321213351&#34; href=&#34;https://www.amazon.com/Refactoring-Patterns-Joshua-Kerievsky/dp/0321213351&#34; rel=&#34;noopener&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;Refactoring to Patterns&lt;/em&gt; by Joshua Kerievsky&lt;/a&gt; in &lt;a href=&#34;https://dzone.com/articles/python-tutorial-for-beginners-a-comprehensive-guid&#34;&gt;Python&lt;/a&gt;. This book broadened my understanding of how to apply design patterns in production code.&lt;/p&gt;】&lt;部分名称=“ e9a8”&gt;&#xA; &lt;blockquote name =“ a03c”&gt;&#xA;  &lt;a data-href =“ https://github.com/douglasdcm/refactoring-to-patterns/blob/main/main/code_smells_table.py.py” blob/main/code_smells_table.py“ rel =“ noopener” target =“ _ black”&gt; python中的此表&lt;/a&gt;包含一个代码气味的列表以及解决它们的设计模式。&#xA; &lt;/blockquote&gt;&#xA; &lt;div class =“ codemirror-wrapper” pontrentediable =“ false”&gt;&#xA;  &lt;div contenteaditable =“ false”&gt;&#xA;   &lt;div class =“ codeheader”&gt;&#xA;    &lt;div class =“ namelanguage”&gt;&#xA;     Python&#xA;    &lt;/div&gt; &lt;i class =“ icon-cancel-circled-1 cm-remove”&gt; &lt;/i&gt;&#xA;   &lt;/div&gt;&#xA;   &lt;div class =“ codemirror-code  -  wrapper” data-code =“类代码：&#xA;    deplicated_code = [&#xA;        form_template_method，&#xA;        profissuce_polymorphic_creation_with_factory_method，&#xA;        chain_constructors，&#xA;        repents_one__many_distincions_with_composite，&#xA;        extract_composite，&#xA;        unify_interfaces_with_adapter，&#xA;        pristion_null_object，&#xA;    这是给出的&#xA;    long_method = [&#xA;        compose_method，&#xA;        move_accumulation_to_collecting_parameter，&#xA;        repent_conditional_dispatcher_with_command，&#xA;        move_accumulation_to_visitor，&#xA;        repent_conditional_logic_with_strategy，&#xA;    这是给出的&#xA;    conditdyal_complexity = [＃复杂的孔子逻辑&#xA;        repent_conditional_logic_with_strategy，&#xA;        move_embluring_to_decorator，&#xA;        repent_state_altering_conditionals_with_state，&#xA;        pristion_null_object，&#xA;    这是给出的&#xA;    primitive_obssession = [&#xA;        repest_type_code_with_class，&#xA;        repent_state_altering_conditionals_with_state，&#xA;        repent_conditional_logic_with_strategy，&#xA;        repents_implict_tree_with_composite，&#xA;        repent_implitic_language_with_interpreter，&#xA;        move_embluring_to_decorator，&#xA;        endapsulate_compoits_with_builder，&#xA;    这是给出的&#xA;    ＃缺乏“信息隐藏” [parnas]&#xA;    indecent_expuse = [endapsulate_classes_with_factory]&#xA;    ＃逻辑/责任遍布多个地方&#xA;    ＃（类，方法）&#xA;    solution_sprawl = [move_creation_knowledge_to_factory]&#xA;    ＃[Fowler and Beck]类的接口不同，&#xA;    ＃但是课相似&#xA;    nester_classes_with_different_interfaces = unify_interfaces_with_adapter&#xA;    ＃[Fowler and Beck]一堂课不足以付钱&#xA;    lazy_class = [inline_singleton]&#xA;    大_class = [&#xA;        repent_conditional_dispatcher_with_command，&#xA;        repent_state_altering_conditionals_with_state，&#xA;        repents_implict_tree_with_composite，&#xA;    这是给出的&#xA;    switch_statements = [＃复杂的开关&#xA;        repent_conditional_dispatcher_with_command，&#xA;        move_accumulation_to_visitor，&#xA;    这是给出的&#xA;    ＃与不同类型或数量数据相同的代码&#xA;    ＃（类似于重复）&#xA;    Compination_explostion = [repent_implitic_language_with_interpreter]&#xA;    ＃在系统中许多方面解决了相同的问题&#xA;    ＃（类似于重复）&#xA;    oddball_solutions = [unify_interfaces_with_adapter]“ data-lang =” text/x-python&gt;&#xA;    &lt;pre&gt; &lt;code lang =“ text/x-python”&gt;类代码：&#xA;    deplicated_code = [&#xA;        form_template_method，&#xA;        profissuce_polymorphic_creation_with_factory_method，&#xA;        chain_constructors，&#xA;        repents_one__many_distincions_with_composite，&#xA;        extract_composite，&#xA;        unify_interfaces_with_adapter，&#xA;        pristion_null_object，&#xA;    这是给出的&#xA;    long_method = [&#xA;        compose_method，&#xA;        move_accumulation_to_collecting_parameter，&#xA;        repent_conditional_dispatcher_with_command，&#xA;        move_accumulation_to_visitor，&#xA;        repent_conditional_logic_with_strategy，&#xA;    这是给出的&#xA;    conditdyal_complexity = [＃复杂的孔子逻辑&#xA;        repent_conditional_logic_with_strategy，&#xA;        move_embluring_to_decorator，&#xA;        repent_state_altering_conditionals_with_state，&#xA;        pristion_null_object，&#xA;    这是给出的&#xA;    primitive_obssession = [&#xA;        repest_type_code_with_class，&#xA;        repent_state_altering_conditionals_with_state，&#xA;        repent_conditional_logic_with_strategy，&#xA;        repents_implict_tree_with_composite，&#xA;        repent_implitic_language_with_interpreter，&#xA;        move_embluring_to_decorator，&#xA;        endapsulate_compoits_with_builder，&#xA;    这是给出的&#xA;    ＃缺乏“信息隐藏” [parnas]&#xA;    indecent_expuse = [endapsulate_classes_with_factory]&#xA;    ＃逻辑/责任遍布多个地方&#xA;    ＃（类，方法）&#xA;    solution_sprawl = [move_creation_knowledge_to_factory]&#xA;    ＃[Fowler and Beck]类的接口不同，&#xA;    ＃但是课相似&#xA;    nester_classes_with_different_interfaces = unify_interfaces_with_adapter&#xA;    ＃[Fowler and Beck]一堂课不足以付钱&#xA;    lazy_class = [inline_singleton]&#xA;    大_class = [&#xA;        repent_conditional_dispatcher_with_command，&#xA;        repent_state_altering_conditionals_with_state，&#xA;        repents_implict_tree_with_composite，&#xA;    这是给出的&#xA;    switch_statements = [＃复杂的开关&#xA;        repent_conditional_dispatcher_with_command，&#xA;        move_accumulation_to_visitor，&#xA;    这是给出的&#xA;    ＃与不同类型或数量数据相同的代码&#xA;    ＃（类似于重复）&#xA;    Compination_explostion = [repent_implitic_language_with_interpreter]&#xA;    ＃在系统中许多方面解决了相同的问题&#xA;    ＃（类似于重复）&#xA;    oddball_solutions = [unify_interfaces_with_adapter] &lt;/code&gt; &lt;/pre&gt;&#xA;   &lt;/div&gt;&#xA;  &lt;/div&gt;&#xA; &lt;/div&gt;&#xA; &lt;p&gt; &lt;br&gt; &lt;/p&gt;&#xA;&lt;/section&gt;&#xA;&lt;部分名称=“ 7EA0”&gt;&#xA; &lt;h2 name =“ 10f7”&gt;旅程&lt;/h2&gt;&#xA; &lt;p name =“ f93f”&gt;经过近一年的努力，我终于完成了我的自我实现的目标，即撰写本书中的所有重构示例&lt;a data-href =“ https://www.amazon.com /recactoring-patterns-joshua-kerievsky/dp/03212133351“ href =” https://www.amazon.com/refactoring-pattorns-patterns-joshua-kerievsky/dp/0321212121213351 real = em&gt; joshua kerievsky &lt;/a&gt;在&lt;a href =“ https://dzone.com/articles/python-t中，utorial-for-beginners-a-compressive-guid&#34;&gt;Python&lt;/a&gt;。这本书拓宽了我对如何在生产代码中应用设计模式的理解。&lt;/p&gt;</description>
      <pubDate>Thu, 23 Jan 2025 19:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>