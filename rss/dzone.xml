<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DZone.com Feed</title>
    <link>https://feeds.dzone.com/home</link>
    <description>Recent posts on DZone.com</description>
    <item>
      <title>【Bye Tokens, Hello Patches】再见代币，你好补丁</title>
      <link>https://dzone.com/articles/bye-tokens-hello-patches</link>
      <description>【&lt;p&gt;Do we really need to break text into tokens, or could we work directly with raw bytes?&lt;/p&gt;&#xA;&lt;p&gt;First, let’s think about how do LLMs currently handle text. They first chop it up into chunks called tokens using rules about common word pieces. This tokenization step has always been a bit of an odd one out. While the rest of the model learns and adapts during training, tokenization stays fixed, based on those initial rules. This can cause problems, especially for languages that aren’t well-represented in the training data or when handling unusual text formats.&lt;/p&gt;】&lt;p&gt;我们真的需要将文本分解为标记，还是可以直接使用原始字节？&lt;/p&gt;&#xA;&lt;p&gt;首先，让我们考虑一下法学硕士目前如何处理文本。他们首先使用常见单词片段的规则将其切成称为标记的块。这个标记化步骤一直有点奇怪。虽然模型的其余部分在训练期间学习和适应，但标记化根据这些初始规则保持固定。这可能会导致问题，特别是对于训练数据中没有很好表示的语言或处理不常见的文本格式时。&lt;/p&gt;</description>
      <pubDate>Wed, 15 Jan 2025 17:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Efficient Long-Term Trend Analysis in Presto Using Datelists】使用日期列表在 Presto 中进行高效的长期趋势分析</title>
      <link>https://dzone.com/articles/long-term-trend-analysis-presto-datelists</link>
      <description>【&lt;p dir=&#34;ltr&#34;&gt;Data analytics teams, plenty of times, would have to do long-term trend analysis to study patterns over time. Some of the common analyses are WoW (week over week), MoM (month over month), and YoY (year over year). This would usually require data to be stored across multiple years.&amp;nbsp;&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;However, this takes up a lot of storage and querying across years worth of &lt;a href=&#34;https://dzone.com/articles/partitioning-mysql-why-when-how&#34;&gt;partitions&lt;/a&gt; is inefficient and expensive. On top of this, if we have to do user attribute cuts, it will be more cumbersome. To overcome this issue, we can implement an efficient solution using datelists.&lt;/p&gt;】&lt;p dir=&#34;ltr&#34;&gt;数据分析团队很多时候必须进行长期趋势分析来研究一段时间内的模式。一些常见的分析包括 WoW（周环比）、MoM（月环比）和 YoY（年环比）。这通常需要将数据存储多年。 &lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;但是，这会占用大量存储空间并在多年的&lt;a href=&#34;https://dzone.com/articles/partitioning-mysql-why-when-how&#34;&gt;分区中进行查询&lt;/a&gt; 效率低且昂贵。除此之外，如果我们还要做用户属性切割，那就更麻烦了。为了解决这个问题，我们可以使用日期列表实现有效的解决方案。&lt;/p&gt;</description>
      <pubDate>Wed, 15 Jan 2025 22:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Kafka vs NATS: A Comparison for Message Processing】Kafka 与 NATS：消息处理比较</title>
      <link>https://dzone.com/articles/kafka-vs-nats-message-processing</link>
      <description>【&lt;p style=&#34;text-align: left;&#34;&gt;In a distributed architecture, communications between systems form the foundation of the entire infrastructure. The performance, scalability, and reliability of the infrastructure depend much on how events/messages/data are exchanged and persisted.&amp;nbsp;&lt;/p&gt;&#xA;&lt;p style=&#34;text-align: left;&#34;&gt;Kafka and NATS are two popular tools for handling streaming and messaging. They have different architectures and different performance characteristics. They are suitable for specific use cases. In this article, we will compare the features of NATS with Kafka and explain the use cases I addressed at work.&lt;/p&gt;】&lt;p style=&#34;text-align: left;&#34;&gt;在分布式架构中，系统之间的通信构成了整个基础设施的基础。基础设施的性能、可扩展性和可靠性在很大程度上取决于事件/消息/数据的交换和保存方式。 &lt;/p&gt;&#xA;&lt;p style=&#34;text-align: left;&#34;&gt;Kafka 和 NATS 是处理流媒体和消息传递的两种流行工具。它们具有不同的架构和不同的性能特征。它们适用于特定的用例。在本文中，我们将比较 NATS 与 Kafka 的功能，并解释我在工作中遇到的用例。&lt;/p&gt;</description>
      <pubDate>Wed, 15 Jan 2025 21:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Distributed Training at Scale】大规模分布式培训</title>
      <link>https://dzone.com/articles/distributed-training-at-scale</link>
      <description>【&lt;p style=&#34;text-align: left;&#34;&gt;As artificial intelligence (AI) and machine learning (ML) models grow in complexity, the computational resources required to train them increase exponentially. Training large models on vast datasets can be a time-consuming and resource-intensive process, often taking days or even weeks to complete on a single machine.&amp;nbsp;&lt;/p&gt;&#xA;&lt;p style=&#34;text-align: left;&#34;&gt;This is where &lt;a href=&#34;https://dzone.com/articles/distributed-training-on-multiple-gpus&#34;&gt;distributed training&lt;/a&gt; comes into play. By leveraging multiple computing resources, distributed training allows for faster model training, enabling teams to iterate more quickly. In this article, we will explore the concept of distributed training, its importance, key strategies, and tools to scale model training efficiently.&lt;/p&gt;】&lt;p style=&#34;text-align: left;&#34;&gt;随着人工智能 (AI) 和机器学习 (ML) 模型的复杂性不断增加，训练它们所需的计算资源呈指数级增长。在海量数据集上训练大型模型可能是一个耗时且资源密集的过程，通常需要数天甚至数周才能在一台机器上完成。 &lt;/p&gt;&#xA;&lt;p style=&#34;text-align: left;&#34;&gt;这就是&lt;a href=&#34;https://dzone.com/articles/distributed-training-on-multiple-gpus&#34;&gt;分布式训练&lt;/a&gt;的用武之地玩。通过利用多个计算资源，分布式训练可以实现更快的模型训练，使团队能够更快地迭代。在本文中，我们将探讨分布式训练的概念、其重要性、关键策略以及有效扩展模型训练的工具。&lt;/p&gt;</description>
      <pubDate>Wed, 15 Jan 2025 13:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Consistency Conundrum: The Challenge of Keeping Data Aligned】一致性难题：保持数据一致的挑战</title>
      <link>https://dzone.com/articles/consistency-conundrum-keeping-data-aligned</link>
      <description>【&lt;p data-selectable-paragraph=&#34;&#34;&gt;A system may store and replicate its data across different nodes to fulfill its scaling, fault tolerance, load balancing, or partitioning needs. This causes data synchronization issues, read-write conflicts, causality problems, or out-of-order updates. These issues arise due to concurrent updates on copies of the same data, network latency or network partition between nodes, node or process crashes, and clock synchronization, to name a few.&lt;/p&gt;&#xA;&lt;p data-selectable-paragraph=&#34;&#34;&gt;Due to these issues, the application may read stale or incorrect data. Non-repeatable reads may occur, and own writes may not be read, either! &lt;span style=&#34;background-color: transparent;&#34;&gt;The solution to these common problems of a distributed system is to maintain&amp;nbsp;&lt;/span&gt;&lt;a href=&#34;https://dzone.com/articles/consistency-patterns-demystified&#34;&gt;consistency&lt;/a&gt;&lt;em style=&#34;background-color: transparent;&#34;&gt;,&amp;nbsp;&lt;/em&gt;&lt;span style=&#34;background-color: transparent;&#34;&gt;i.e., keep the data aligned.&lt;/span&gt;&lt;/p&gt;】&lt;p data-selectable-paragraph=&#34;&#34;&gt;系统可以跨不同节点存储和复制其数据，以满足其扩展、容错、负载平衡或分区需求。这会导致数据同步问题、读写冲突、因果关系问题或乱序更新。这些问题的出现是由于相同数据副本的并发更新、节点之间的网络延迟或网络分区、节点或进程崩溃以及时钟同步等。&lt;/p&gt;&#xA;&lt;p data-selectable-paragraph=&#34;&#34;&gt;由于这些问题，应用程序可能会读取过时或不正确的数据。可能会发生不可重复读取，并且自己的写入也可能无法读取！ &lt;span style=&#34;background-color:透明;&#34;&gt;分布式系统的这些常见问题的解决方案是维护&lt;/span&gt;&lt;a href=&#34;https://dzone.com/articles/consistency-patterns-demystified &#34;&gt;一致性&lt;/a&gt;&lt;em style=&#34;background-color:透明;&#34;&gt;，&lt;/em&gt;&lt;span style=&#34;background-color:透明;&#34;&gt;即保持数据对齐。&lt;/span&gt;&lt; /p&gt;</description>
      <pubDate>Wed, 15 Jan 2025 19:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Branches to Backlogs: Implementing Effective Timeframes in Software Development】从分支到待办事项：在软件开发中实施有效的时间框架</title>
      <link>https://dzone.com/articles/branches-to-backlogs-effective-timeframes</link>
      <description>【&lt;p&gt;A few years ago, at my previous company, I found myself on a familiar quest: hunting down a specific Jira issue. What I discovered was both amusing and alarming — three versions of the same problem statement, each with different solutions spaced four to six months apart. Every solution was valid in its context, but the older ones had become obsolete.&lt;/p&gt;&#xA;&lt;p&gt;This scenario is all too common in the software development world. New ideas constantly emerge, priorities shift, and tasks often get put on hold. As a result, the same issues resurface repeatedly, leading to a chaotic backlog with multiple solutions for identical problems. This clutter makes it challenging to grasp our true roadmap and impedes our ability to achieve objectives.&lt;/p&gt;】&lt;p&gt;几年前，在我之前的公司，我发现自己面临着一个熟悉的任务：寻找特定的 Jira 问题。我的发现既有趣又令人震惊——同一问题陈述的三个版本，每个版本都有不同的解决方案，间隔四到六个月。每个解决方案在其上下文中都是有效的，但旧的解决方案已经过时了。&lt;/p&gt;&#xA;&lt;p&gt;这种情况在软件开发领域太常见了。新想法不断涌现，优先事项发生变化，任务常常被搁置。结果，相同的问题反复出现，导致混乱的积压，针对相同的问题有多种解决方案。这种混乱使得我们很难掌握真正的路线图，并阻碍我们实现目标的能力。&lt;/p&gt;</description>
      <pubDate>Wed, 15 Jan 2025 18:15:00 +0000</pubDate>
    </item>
    <item>
      <title>【Heterogeneity of Computing Environments Using Cross-Compilation】使用交叉编译的计算环境的异构性</title>
      <link>https://dzone.com/articles/heterogeneity-computing-environments-cross-compilation</link>
      <description>【&lt;p&gt;&lt;span data-contrast=&#34;auto&#34; lang=&#34;EN-IN&#34;&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;With the advent of open-source software and the&amp;nbsp;&lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;acceptance of these solutions in creating complex systems, the ability to develop applications that can run seamlessly&amp;nbsp;&lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;across multiple hardware platforms becomes inherently important.&amp;nbsp;&lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;There is a constant need to develop the s&lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;oftware&lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;&amp;nbsp;on one architecture but have the capability to execute these on&amp;nbsp;&lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;other target architectures. One common technique to achieve this is cross-compilation of&lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;&amp;nbsp;&lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;the application for the target architecture&lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span data-ccp-props=&#34;{&amp;quot;201341983&amp;quot;:0,&amp;quot;335551550&amp;quot;:6,&amp;quot;335551620&amp;quot;:6,&amp;quot;335559738&amp;quot;:240,&amp;quot;335559739&amp;quot;:160,&amp;quot;335559740&amp;quot;:240}&#34;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://dzone.com/articles/cross-compilation-with-buildroot&#34;&gt;&lt;span data-contrast=&#34;auto&#34; lang=&#34;EN-IN&#34;&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;Cross-compilation&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-contrast=&#34;auto&#34; lang=&#34;EN-IN&#34;&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt; is significant in embedded systems where the intent is to run applications on specialized hardware like ARM and PowerPC boards. These systems are resource-constrained and hence a direct compilation is not an option&lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;.&lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;&amp;nbsp;Thus, developers will leverage the common x86 architecture as a host and use toolchains specific to the target hardware, generating binaries compatible with the target hardware.&lt;/span&gt;&lt;/span&gt;&lt;span data-ccp-props=&#34;{&amp;quot;201341983&amp;quot;:0,&amp;quot;335559738&amp;quot;:240,&amp;quot;335559739&amp;quot;:160,&amp;quot;335559740&amp;quot;:240}&#34;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;】&lt;p&gt;&lt;span data-contrast=&#34;auto&#34; lang=&#34;EN-IN&#34;&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;随着开源软件和&lt;/span&gt;&lt;span 数据的出现-ccp-parastyle=&#34;Plain Text&#34;&gt;在创建复杂系统时接受这些解决方案，开发可无缝运行的应用程序的能力&lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;跨多个硬件平台成为本质上很重要。 &lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;不断需要开发软件&lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;软件&lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt; 在一种架构上执行这些操作，但能够在&lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;其他目标架构上执行这些操作。实现此目的的一种常见技术是交叉编译&lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt; &lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;目标应用程序架构&lt;/span&gt;&lt;span data-ccp-parastyle=&#34;纯文本&#34;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;span data-ccp-props=&#34;{&#34;201341983&#34;:0,&#34;335551550&#34;:6,&#34;335551620&#34;:6,&#34;335559738&#34;:240,&#34;335559739&#34;:160,&#34;335559740&#34;:240}&#34;&gt; &lt;/span&gt; &lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://dzone.com/articles/cross-compilation-with-buildroot&#34;&gt;&lt;span data-contrast=&#34;auto&#34; lang=&#34;EN-IN&#34;&gt;&lt;span data-ccp- parastyle=&#34;Plain Text&#34;&gt;交叉编译&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-contrast=&#34;auto&#34; lang=&#34;EN-IN&#34;&gt;&lt;span data-ccp-parastyle=&#34;Plain Text &#34;&gt; 在嵌入式系统中很重要其目的是在 ARM 和 PowerPC 板等专用硬件上运行应用程序。这些系统资源有限，因此无法直接编译&lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;。&lt;/span&gt;&lt;span data-ccp-parastyle=&#34;Plain Text&#34;&gt;因此，开发人员将利用通用的 x86 架构作为主机，并使用特定于目标硬件的工具链，生成与目标硬件兼容的二进制文件。&lt;/span&gt;&lt;/span&gt;&lt;span data-ccp-props=&#34;{&#34;201341983&#34;:0,&#34;335559738&#34;:240,&#34;335559739&#34;:160,&#34;335559740&#34;:240}&#34;&gt; &lt;/span&gt;&lt;/p&gt;</description>
      <pubDate>Wed, 15 Jan 2025 20:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Personalized Search Optimization Using Semantic Models and Context-Aware NLP for Improved Results】使用语义模型和上下文感知 NLP 进行个性化搜索优化以改进结果</title>
      <link>https://dzone.com/articles/personalized-search-through-sematic-models-nlp</link>
      <description>【&lt;p dir=&#34;ltr&#34;&gt;Have you ever wondered how search engines like Google interpret phrases such as &#34;budget-friendly vacation spots&#34; and &#34;cheap places to travel&#34; as essentially the same query? That’s the power of semantic search. Traditional search engines rely heavily on exact keyword matches. They only find documents or results that contain the exact words entered in a query. For example, if you search for &#34;budget-friendly vacation spots,&#34; a keyword-based search engine would return results containing those exact terms. However, this method falls short when it comes to understanding the nuances of human language, such as synonyms, different phrasing, or the intent behind the words.&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;For instance, one user might search for&amp;nbsp;&#34;affordable beach resorts,&#34;&amp;nbsp;while another might search for&amp;nbsp;&#34;cheap seaside hotels.&#34;&amp;nbsp;Both queries refer to similar types of accommodations, but traditional search engines might fail to connect these two searches effectively due to differing phrasing.&lt;/p&gt;】&lt;p dir=&#34;ltr&#34;&gt;您是否想知道 Google 等搜索引擎如何将“经济实惠的度假胜地”和“便宜的旅行地点”等短语解释为本质上相同的查询？这就是语义搜索的力量。传统的搜索引擎严重依赖关键字的精确匹配。他们仅查找包含在查询中输入的确切单词的文档或结果。例如，如果您搜索“预算友好的度假胜地”，基于关键字的搜索引擎将返回包含这些确切术语的结果。然而，这种方法在理解人类语言的细微差别（例如同义词、不同的措辞或单词背后的意图）方面存在不足。&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;例如，一个用户可能会搜索“经济实惠的海滩度假村”，而另一个用户可能会搜索“便宜的海滨酒店”。 这两个查询都指的是相似类型的住宿，但传统搜索引擎可能由于措辞不同而无法有效连接这两个搜索。&lt;/p&gt;</description>
      <pubDate>Wed, 15 Jan 2025 14:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Advanced Bot Mitigation Using Custom Rate-Limiting Techniques】使用自定义速率限制技术的高级机器人缓解</title>
      <link>https://dzone.com/articles/advanced-bot-mitigation-using-custom-rate-limiting</link>
      <description>【&lt;p dir=&#34;ltr&#34;&gt;Today, automated bot traffic creates a very costly and complex challenge for organizations in the modern digital environment. The traditional defenses present the platform operators with a paradox: the very methods effective in keeping the bots away frustrate legitimate users, leading to higher abandonment rates and thus debilitating user experience.&amp;nbsp;&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;What if one could block bots without deterring actual users? Let’s take a look at an innovative and data-driven approach to bot mitigation, which uses a custom rate-limiting technique, with real-world examples that prove this can drastically reduce costs, increase stability, and result in a frictionless user experience.&lt;/p&gt;】&lt;p dir=&#34;ltr&#34;&gt;如今，自动化机器人流量给现代数字环境中的组织带来了成本高昂且复杂的挑战。传统的防御措施给平台运营商带来了一个悖论：有效阻止机器人的方法却让合法用户感到沮丧，导致更高的放弃率，从而削弱用户体验。 &lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;如果可以阻止机器人而不阻止实际用户怎么办？让我们看一下一种创新的、数据驱动的机器人缓解方法，该方法使用自定义速率限制技术，并通过实际示例证明这可以大大降低成本、提高稳定性并带来顺畅的用户体验。&lt; /p&gt;</description>
      <pubDate>Wed, 15 Jan 2025 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Data-First IDP: Driving AI Innovation in Developer Platforms】数据优先的 IDP：推动开发者平台的人工智能创新</title>
      <link>https://dzone.com/articles/data-first-idp-driving-ai-innovation</link>
      <description>【&lt;p&gt;Traditional internal developer platforms (IDPs) have transformed how organizations manage code and infrastructure. By standardizing workflows through tools like CI/CD pipelines and Infrastructure as Code (IaC), these platforms have enabled rapid deployments, reduced manual errors, and improved developer experience. However, their focus has primarily been on operational efficiency, often treating data as an afterthought.&lt;/p&gt;&#xA;&lt;p&gt;This omission becomes critical in today&#39;s AI-driven landscape. While &lt;a href=&#34;https://dzone.com/articles/is-2021-the-year-of-the-internal-developer-platfor&#34;&gt;traditional IDPs&lt;/a&gt; excel at managing infrastructure, they fall short when it comes to the foundational elements required for scalable and compliant AI innovation:&lt;/p&gt;】&lt;p&gt;传统的内部开发人员平台 (IDP) 已经改变了组织管理代码和基础设施的方式。通过 CI/CD 管道和基础设施即代码 (IaC) 等工具标准化工作流程，这些平台实现了快速部署、减少了手动错误并改善了开发人员体验。然而，他们的重点主要是运营效率，通常将数据视为事后的想法。&lt;/p&gt;&#xA;&lt;p&gt;这种遗漏在当今人工智能驱动的环境中变得至关重要。虽然&lt;a href=&#34;https://dzone.com/articles/is-2021-the-year-of-the-internal-developer-platfor&#34;&gt;传统 IDP&lt;/a&gt; 擅长管理基础设施，但当它涉及可扩展且合规的人工智能创新所需的基本要素：&lt;/p&gt;</description>
      <pubDate>Wed, 15 Jan 2025 15:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>