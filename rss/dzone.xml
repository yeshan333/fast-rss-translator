<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DZone.com Feed</title>
    <link>https://feeds.dzone.com/home</link>
    <description>Recent posts on DZone.com</description>
    <item>
      <title>【Lightning Data Service for Lightning Web Components】用于闪电网络组件的闪电数据服务</title>
      <link>https://dzone.com/articles/lightning-data-service-for-lightning-web-components</link>
      <description>【&lt;p&gt;When developing Lightning Web Components (LWC) in Salesforce, working with data efficiently is key to building powerful and scalable applications. Salesforce provides several ways to retrieve and manipulate data within LWC, and one of the most effective methods is using Lightning Data Service (LDS).&lt;/p&gt;&#xA;&lt;p&gt;LDS allows you to interact with Salesforce data — whether it’s retrieving, modifying, or deleting — without the need for any &lt;a href=&#34;https://dzone.com/articles/integrating-apex-lightning-web-components&#34;&gt;Apex code&lt;/a&gt;. It also offers a built-in cache that is shared across components, ensuring that data changes made by one component are automatically reflected in others, enhancing synchronization and reducing redundancy.&lt;/p&gt;】&lt;p&gt;在Salesforce开发Lightning Web组件（LWC）时，有效地使用数据是构建功能强大且可扩展的应用程序的关键。 Salesforce提供了多种检索和操纵LWC中数据的方法，最有效的方法之一是使用闪电数据服务（LDS）。&lt;/p&gt;&#xA;&lt;p&gt; lds允许您与Salesforce数据进行交互（无论是检索，修改还是删除），而无需任何&lt;a href =“ https://dzone.com/articles/articles/articles/integration-integrating-eppex-lightning-web-components”&gt; apex代码&lt;/a&gt;。它还提供了一个内置的缓存，该缓存在组件之间共享，以确保一个组件所做的数据更改会自动反映在其他组件中，从而增强同步和减少冗余。&lt;/p&gt;</description>
      <pubDate>Wed, 12 Mar 2025 14:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【GenAI: Running Prototypes Faster Than Wireframes】Genai：运行原型比线框快</title>
      <link>https://dzone.com/articles/genai-running-prototypes-faster-than-wireframes</link>
      <description>【&lt;h2&gt;Required: Rapid Prototyping, Working Software&lt;/h2&gt;&#xA;&lt;p&gt;Digital transformation is all about speed in turning business ideas into systems. Speed in getting actual working software — running screens, reading and writing real data, with underlying business logic.&lt;/p&gt;&#xA;&lt;p&gt;Experience has taught us there is no substitute for working software. It&#39;s all too common to spend weeks to months creating running screens, only to find out the business idea was not compelling or the requirements were misunderstood.&lt;/p&gt;】&lt;h2&gt;必需：快速原型，工作软件&lt;/h2&gt;&#xA;&lt;p&gt;数字转换是将业务思想变成系统的速度。获得实际工作软件的速度 - 运行屏幕，阅读和编​​写真实数据，并具有基本的业务逻辑。&lt;/p&gt;&#xA;&lt;p&gt;经验教会了我们，无法替代工作软件。花几周到几个月的播放屏幕是太普遍了，只是发现业务想法并没有引人注目，或者要求被误解。&lt;/p&gt;</description>
      <pubDate>Wed, 12 Mar 2025 19:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【SRE Best Practices for Java Applications】SRE适用于Java应用的最佳实践</title>
      <link>https://dzone.com/articles/sre-best-practices-for-java-applications</link>
      <description>【&lt;p style=&#34;text-align: left;&#34;&gt;Site reliability engineering (SRE) plays a vital role in ensuring Java applications&#39; high availability, performance, and scalability. This discipline merges software engineering and operations, aiming to create a robust infrastructure that supports seamless user experiences.&amp;nbsp;&lt;/p&gt;&#xA;&lt;p style=&#34;text-align: left;&#34;&gt;In this article, we will delve into a range of best practices aligned with &lt;a href=&#34;https://dzone.com/articles/site-reliability-and-engineering&#34;&gt;SRE principles&lt;/a&gt;, including monitoring, logging, alerting, performance optimization, disaster recovery, security, automation, and incident management. Each section will be illustrated with relevant Java code samples to provide practical insights.&lt;/p&gt;】&lt;p style =“ text-align：left;”&gt;站点可靠性工程（SRE）在确保Java应用程序的高可用性，性能和可扩展性方面起着至关重要的作用。该学科合并了软件工程和操作，旨在创建一个支持无缝用户体验的强大基础架构。 &lt;/p&gt;&#xA;&lt;p style=&#34;text-align: left;&#34;&gt;In this article, we will delve into a range of best practices aligned with &lt;a href=&#34;https://dzone.com/articles/site-reliability-and-engineering&#34;&gt;SRE principles&lt;/a&gt;, including monitoring, logging, alerting, performance optimization, disaster recovery, security, automation, and incident management.每个部分将使用相关的Java代码样本进行说明以提供实用的见解。&lt;/p&gt;</description>
      <pubDate>Wed, 12 Mar 2025 18:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Low-Code Development Is Dead; Long Live Low Code, No Limits】低代码开发已死；千载难逢的代码，没有限制</title>
      <link>https://dzone.com/articles/long-live-low-code-no-limits</link>
      <description>【&lt;p dir=&#34;ltr&#34;&gt;Low-code was supposed to be the future. It promised faster development, simpler integrations, and the ability to build complex applications without drowning in code. And for a while, it seemed like it would deliver.&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;But then reality hit. Developers and IT teams who embraced low-code quickly found its limitations. Instead of accelerating innovation, it created bottlenecks. Instead of freeing developers, it forced them into&amp;nbsp;rigid, vendor-controlled ecosystems.&lt;/p&gt;】&lt;p dir =“ ltr”&gt;低代码应该是未来。它承诺更快地开发，更简单的集成以及构建复杂应用程序而不淹没代码的能力。有一段时间，它似乎会交付。&lt;/p&gt;&#xA;&lt;p dir =“ ltr”&gt;，但随后发生了。接受低代码的开发人员和IT团队很快发现了其局限性。它没有加速创新，而是创造了瓶颈。它没有释放开发人员，而是迫使他们进入僵化的供应商控制的生态系统。&lt;/p&gt;</description>
      <pubDate>Wed, 12 Mar 2025 15:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Handling Concurrent Data Loads in Delta Tables】在三角洲表中处理并发数据负载</title>
      <link>https://dzone.com/articles/handling-concurrent-data-load-challenges-in-delta</link>
      <description>【&lt;h2 data-end=&#34;302&#34; data-start=&#34;277&#34;&gt;Ensuring Reliable Concurrent Writes With Retrying Options&lt;/h2&gt;&#xA;&lt;p&gt;Delta Lake is a resilient storage layer that offers ACID transactions, schema enforcement, and data versioning. However, concurrent writes generate contention since different processes are attempting to write, update, or delete at the same time. This process offers a structured retry mechanism with exponential backoff to handle concurrency in Delta tables.&lt;/p&gt;&#xA;&lt;h2 data-end=&#34;691&#34; data-start=&#34;303&#34;&gt;Delta Table Concurrent Writes Issues&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://dzone.com/articles/concurrency-issues-in-sql-and-distributed-systems&#34;&gt;Concurrency failures&lt;/a&gt; occur when multiple processes simultaneously attempt to write to the same Delta table. The common failure scenarios are as follows:&lt;/p&gt;】&lt;h2 data-end =“ 302” data-start =“ 277”&gt;确保可靠的并发与重试选项&lt;/h2&gt;&#xA;&lt;p&gt; Delta Lake是一个有弹性的存储层，可提供酸性交易，模式执行和数据版本。但是，并发写入生成争论，因为不同的过程正在尝试同时编写，更新或删除。此过程提供了一个结构化的重试机制，并带有指数向后，以处理三角洲表中的并发。&lt;/p&gt;&#xA;&lt;h2 data-end =“ 691” data-start =“ 303”&gt; delta表并发撰写问题&lt;/h2&gt;&#xA;&lt;p&gt; &lt;a href =“ https://dzone.com/articles/concurrency-issues-ins-sql-and-distributed-systems”&gt;并发故障&lt;/a&gt;当多个过程同时尝试写入同一delta表时发生。常见的故障情况如下：&lt;/p&gt;</description>
      <pubDate>Wed, 12 Mar 2025 21:15:00 +0000</pubDate>
    </item>
    <item>
      <title>【Build a DIY AI Model Hosting Platform With vLLM】使用VLLM构建DIY AI模型托管平台</title>
      <link>https://dzone.com/articles/build-an-ai-model-hosting-with-vllm-inference-engine</link>
      <description>【&lt;p style=&#34;text-align: left;&#34;&gt;One of the biggest challenges that developers and researchers face is deploying models for AI inference at scale. Traditionally, this involves relying on cloud services or complex server setups that can be expensive and resource intensive. However, with innovations like the vLLM AI Inference engine, Do-It-Yourself (DIY) model hosting is becoming more accessible and efficient. One can build cost-effective model-serving solutions for their machine learning needs.&lt;/p&gt;&#xA;&lt;h2 style=&#34;text-align: left;&#34;&gt;vLLM&lt;/h2&gt;&#xA;&lt;p data-end=&#34;1088&#34; data-start=&#34;671&#34; style=&#34;text-align: left;&#34;&gt;vLLM is an AI inference engine designed to efficiently serve large language models (LLMs) at scale. It is a robust, high-performance engine that provides a streamlined approach to serving AI models. It stands out in its ability to optimize resources and maintain low latency and high throughput even with large-scale models. The &lt;a href=&#34;https://dzone.com/articles/generative-ai-unleashed-mlops-and-llm-deployment-s&#34;&gt;vLLM engine&lt;/a&gt; allows for faster inference times, improved memory management, and optimized execution, all of which are crucial for hosting models effectively on a DIY setup.&lt;/p&gt;】&lt;p style =“ text-align：left;”&gt;开发人员和研究人员面临的最大挑战之一是在大规模上部署模型。传统上，这涉及依靠云服务或复杂的服务器设置，这些设置可能昂贵且资源密集。但是，借助VLLM AI推理引擎等创新，Do-youranf（DIY）模型托管变得越来越易于​​访问和高效。一个人可以为其机器学习需求构建具有成本效益的模型服务解决方案。&lt;/p&gt;&#xA;&lt;h2 style =“ text-align：left;”&gt; vllm &lt;/h2&gt;&#xA;&lt;p data-end =“ 1088” data-start =“ 671” style =“ text-align：left;”&gt; vllm是一种AI推理引擎，旨在在大规模上有效地提供大型语言模型（LLMS）。这是一种强大的高性能引擎，为服务AI模型提供了简化的方法。它具有优化资源并保持低潜伏期和高吞吐量的能力，即使使用大型模型也是如此。 &lt;a href =“ https://dzone.com/articles/generative-ai-unleashed-mlops-and-mlops-and-and-llm-deployment-s”&gt; vllm Engine &lt;/a&gt;允许更快的推断时间，改进的内存管理和优化的执行速度，以及所有这些对托管模型有效地对DIY设置的托管模型至关重要。&lt;/p&gt; &lt;/p&gt; &lt;/p&gt;</description>
      <pubDate>Wed, 12 Mar 2025 12:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Chat History for AI Applications With Azure Cosmos DB Go SDK】使用Azure Cosmos DB GO SDK的AI应用程序聊天历史记录</title>
      <link>https://dzone.com/articles/chat-history-ai-applications-azure-cosmos-db-go-sdk</link>
      <description>【&lt;p&gt;This blog post covers how to build a chat history implementation using Azure Cosmos DB for NoSQL Go SDK and LangChainGo. If you are new to the Go SDK, the sample chatbot application presented in the blog serves as a practical introduction, covering basic operations like read, upsert, etc. It also demonstrates using the Azure Cosmos DB Linux-based emulator (in preview at the time of writing) for integration tests with Testcontainers for Go.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://dzone.com/articles/golang-first-look-at-generics&#34;&gt;Go developers&lt;/a&gt; looking to build AI applications can use &lt;a href=&#34;https://github.com/tmc/langchaingo&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;LangChainGo&lt;/a&gt;, which is a framework for LLM-powered applications. It provides pluggable APIs for components like vector store, embedding, loading documents, chains (for composing multiple operations), chat history, and more.&lt;/p&gt;】&lt;p&gt;本博客文章涵盖了如何使用nosql GO SDK和Langchaingo的Azure Cosmos DB构建聊天历史记录实现。如果您是GO SDK的新手，那么博客中介绍的示例聊天机器人应用程序是一个实用的介绍，涵盖了诸如read，upsert等的基本操作。它还证明了使用基于azure cosmos db linux的模拟器（在写作时在预览中进行预览）进行集成测试，以进行testContainers进行。&lt;/p&gt; &lt;/p&gt; &lt;/p&gt; &lt;/p&gt; &lt;/p&gt; &lt;/p&gt;&#xA;&lt;p&gt; &lt;a href =“ https://dzone.com/articles/golang-first-look-at-generics”&gt; go Developers &lt;/a&gt;希望构建AI应用程序可以使用&lt;a href =“ https://github.com/github.com/tmc/tmc/tmc/langchaingo” target =“ _ blank”&gt; langchaingo &lt;/a&gt;，这是LLM驱动应用程序的框架。它为诸如矢量商店，嵌入，加载文档，链条（用于组合多个操作），聊天历史记录等组件提供可插入的API。&lt;/p&gt;</description>
      <pubDate>Wed, 12 Mar 2025 11:00:03 +0000</pubDate>
    </item>
    <item>
      <title>【Using Jetpack Compose With MVI Architecture】使用与MVI架构组合的JetPack</title>
      <link>https://dzone.com/articles/using-jetpack-compose-with-mvi-architecture</link>
      <description>【&lt;h2 dir=&#34;ltr&#34;&gt;Understanding MVVM and MVI&lt;/h2&gt;&#xA;&lt;h3 dir=&#34;ltr&#34;&gt;MVVM (Model-View-ViewModel)&lt;/h3&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://dzone.com/articles/the-mvvm-pattern-services-helpers-and-templates&#34;&gt;MVVM&lt;/a&gt; is one of the most popular architecture patterns in Android development. It helps keep UI logic separate from business logic by using a ViewModel, which acts as a bridge between the View (UI) and the Model (data and logic). The View listens for updates from the ViewModel and updates the UI when needed.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA; &lt;li dir=&#34;ltr&#34;&gt;&lt;strong&gt;Model&lt;/strong&gt;: Handles data and business logic.&lt;/li&gt;&#xA; &lt;li dir=&#34;ltr&#34;&gt;&lt;strong&gt;View&lt;/strong&gt;: Displays the UI and passes user actions to the ViewModel.&lt;/li&gt;&#xA; &lt;li dir=&#34;ltr&#34;&gt;&lt;strong&gt;ViewModel&lt;/strong&gt;: Manages data for the View and responds to user interactions.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 dir=&#34;ltr&#34;&gt;MVI (Model-View-Intent)&lt;/h3&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;MVI follows a reactive, unidirectional data flow, meaning UI updates happen in a predictable way from a single source of truth. This makes state management clearer and more structured.&lt;/p&gt;】&lt;h2 dir =“ ltr”&gt;了解MVVM和MVI &lt;/h2&gt;&#xA;&lt;h3 dir =“ ltr”&gt; mvvm（model-view-viewModel）&lt;/h3&gt;&#xA;&lt;p dir =“ ltr”&gt; &lt;a href =“ https://dzone.com/articles/the-mvvm-pattern-services-helpers-and-and-templates”&gt; mvvm &lt;/a&gt;是Android开发中最受欢迎的建筑模式之一。它通过使用ViewModel作为视图（UI）和模型（数据和逻辑）之间的桥梁来帮助将UI逻辑与业务逻辑分开。该视图听取了ViewModel的更新并在需要时更新UI。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA; &lt;li dir =“ ltr”&gt; &lt;strong&gt;模型&lt;/strong&gt;：处理数据和业务逻辑。&lt;/li&gt;&#xA; &lt;li dir =“ ltr”&gt; &lt;strong&gt; view &lt;/strong&gt;：显示UI并将用户操作传递到ViewModel。&lt;/li&gt;&#xA; &lt;li dir =“ ltr”&gt; &lt;strong&gt; ViewModel &lt;/strong&gt;：管理视图数据并响应用户交互。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 dir =“ ltr”&gt; MVI（模型视图）&lt;/h3&gt;&#xA;&lt;p dir =“ ltr”&gt; MVI遵循反应性的单向数据流，这意味着UI更新以可预测的方式从单个真实来源开始。这使国家管理更清晰，更结构化。&lt;/p&gt;</description>
      <pubDate>Wed, 12 Mar 2025 20:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Mobile Backend With Docker, Kubernetes, and Microservices】与Docker，Kubernetes和微服务的移动后端</title>
      <link>https://dzone.com/articles/mobile-backend-docker-kubernetes-microservices</link>
      <description>【&lt;p&gt;Mobile applications always demand highly scalable, available, and fault-tolerant backend systems. Traditional monolithic architectures often struggle with performance bottlenecks, slow deployments, and scalability limitations. To overcome these challenges, a microservices-based architecture deployed using Docker and Kubernetes provides a robust solution.&lt;/p&gt;&#xA;&lt;p&gt;This article covers the following points:&lt;/p&gt;】&lt;p&gt;移动应用程序总是需要高度可扩展，可用和容忍故障的后端系统。传统的整体建筑通常在性能瓶颈，缓慢的部署和可扩展性限制方面挣扎。为了克服这些挑战，使用Docker和Kubernetes部署的基于微服务的架构提供了强大的解决方案。&lt;/p&gt;&#xA;&lt;p&gt;本文涵盖以下几点：&lt;/p&gt;</description>
      <pubDate>Wed, 12 Mar 2025 16:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【How to Recover a Deleted Table in a SQL Server Database】如何在SQL Server数据库中恢复已删除的表</title>
      <link>https://dzone.com/articles/recover-deleted-table-sql-server</link>
      <description>【&lt;p&gt;Accidentally deleting a table in SQL Server can be a critical issue, but there are several methods to recover it. Below are three effective ways to successfully recover a deleted table in SQL Server.&lt;/p&gt;&#xA;&lt;h2&gt;&lt;strong&gt;Method 1: Restore the Deleted Table From Backup&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;The most reliable way to recover a deleted table is to restore it from a &lt;strong&gt;database backup&lt;/strong&gt;. This method works if you have a recent backup of the database.&lt;/p&gt;】&lt;p&gt;意外删除SQL Server中的表可能是一个关键问题，但是有几种恢复它的方法。以下是在SQL Server中成功恢复已删除表的三种有效方法。&lt;/p&gt;&#xA;&lt;H2&gt; &lt;strong&gt;方法1：从备份恢复已删除的表&lt;/strong&gt; &lt;/h2&gt;&#xA;&lt;p&gt;恢复删除表的最可靠方法是从&lt;strong&gt;数据库备份&lt;/strong&gt;还原它。如果您对数据库有最近的备份，则此方法可行。&lt;/p&gt;</description>
      <pubDate>Wed, 12 Mar 2025 13:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>