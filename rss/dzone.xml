<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DZone.com Feed</title>
    <link>https://feeds.dzone.com/home</link>
    <description>Recent posts on DZone.com</description>
    <item>
      <title>【A Comprehensive Guide to Database Sharding: Building Scalable Systems】数据库分片综合指南：构建可扩展系统</title>
      <link>https://dzone.com/articles/a-comprehensive-guide-to-database-sharding</link>
      <description>【&lt;section name=&#34;3377&#34;&gt;&#xA; &lt;p name=&#34;b7f3&#34;&gt;In this article, we’ll dive deep into the concept of database sharding, a critical technique for scaling databases to handle large volumes of data and high levels of traffic. Here’s what you can expect to learn:&lt;/p&gt;&#xA; &lt;ul&gt;&#xA;  &lt;li name=&#34;c110&#34;&gt;&lt;strong&gt;What is Sharding?:&amp;nbsp;&lt;/strong&gt;We’ll start by defining what sharding is and why it’s essential for modern, high-performance databases. You’ll understand how sharding can help overcome the limitations of traditional database scaling methods.&lt;/li&gt;&#xA;  &lt;li name=&#34;125e&#34;&gt;&lt;strong&gt;Types of Sharding:&amp;nbsp;&lt;/strong&gt;Next, we’ll explore the different types of sharding, including horizontal and vertical sharding. We’ll discuss the benefits and challenges of each approach, helping you decide which might be best for your use case.&lt;/li&gt;&#xA;  &lt;li name=&#34;8cc5&#34;&gt;&lt;strong&gt;Selecting a Shard Key:&amp;nbsp;&lt;/strong&gt;Choosing the right shard key is crucial for the success of a sharded database. In this section, we’ll walk through the factors to consider when selecting a shard key, common mistakes to avoid, and how to balance performance with even data distribution.&lt;/li&gt;&#xA;  &lt;li name=&#34;7bb6&#34;&gt;&lt;strong&gt;Routing Requests to Shards:&amp;nbsp;&lt;/strong&gt;Finally, we’ll cover the methods for routing queries to the correct shard. This section will provide insights into the architecture and strategies to ensure efficient query processing in a sharded environment.&lt;/li&gt;&#xA; &lt;/ul&gt;&#xA; &lt;p name=&#34;7743&#34;&gt;By the end of this guide, you’ll have a comprehensive understanding of database sharding, enabling you to implement it effectively in your systems.&lt;/p&gt;】&lt;部分名称=“3377”&gt;&#xA; &lt;p name=&#34;b7f3&#34;&gt;在本文中，我们将深入探讨数据库分片的概念，这是一种扩展数据库以处理大量数据和高流量的关键技术。以下是您可以学到的内容：&lt;/p&gt;&#xA; &lt;ul&gt;&#xA;  &lt;li name=&#34;c110&#34;&gt;&lt;strong&gt;什么是分片？：&lt;/strong&gt;我们首先定义什么是分片以及为什么它对于现代高性能数据库至关重要。您将了解分片如何帮助克服传统数据库扩展方法的局限性。&lt;/li&gt;&#xA;  &lt;li name=&#34;125e&#34;&gt;&lt;strong&gt;分片类型：&lt;/strong&gt;接下来，我们将探讨不同类型的分片，包括水平分片和垂直分片。我们将讨论每种方法的优点和挑战，帮助您决定哪种方法最适合您的用例。&lt;/li&gt;&#xA;  &lt;li name=&#34;8cc5&#34;&gt;&lt;strong&gt;选择分片键：&lt;/strong&gt;选择正确的分片键对于分片数据库的成功至关重要。在本节中，我们将介绍选择分片键时要考虑的因素、要避免的常见错误，以及如何在性能与均匀数据分布之间取得平衡。&lt;/li&gt;&#xA;  &lt;li name=&#34;7bb6&#34;&gt;&lt;strong&gt;将请求路由到分片&lt;/strong&gt;：最后，我们将介绍将查询路由到正确分片的方法。本部分将深入介绍确保分片环境中高效查询处理的架构和策略。&lt;/li&gt;&#xA; &lt;/ul&gt;&#xA; &lt;p name=&#34;7743&#34;&gt;读完本指南后，您将对数据库分片有一个全面的了解，从而能够在您的系统中有效地实施它。&lt;/p&gt;</description>
      <pubDate>Wed, 02 Oct 2024 21:00:03 +0000</pubDate>
    </item>
    <item>
      <title>【Understanding the Dependency Injection Lifecycle: Singleton, Scoped, and Transient With Detailed Examples】了解依赖注入生命周期：单例、作用域和瞬态以及详细示例</title>
      <link>https://dzone.com/articles/understanding-the-dependency-injection-lifecycle</link>
      <description>【&lt;p&gt;Developers may be aware of the lifecycle of service instances when using &lt;a href=&#34;https://dzone.com/articles/about-dependency-injection&#34;&gt;dependency injection&lt;/a&gt;, but many don’t fully grasp how it works. You can find numerous articles online that clarify these concepts, but they often just reiterate definitions that you might already know. Let me illustrate with a detailed example that simplifies the explanation.&lt;/p&gt;&#xA;&lt;p&gt;When implementing dependency injection, developers have three options that determine the life cycle of the instances:&lt;/p&gt;】&lt;p&gt;开发人员在使用&lt;a href=&#34;https://dzone.com/articles/about-dependency-injection&#34;&gt;依赖注入&lt;/a&gt;时可能会了解服务实例的生命周期，但许多人并没有完全了解掌握它是如何运作的。您可以在网上找到许多文章来阐明这些概念，但它们通常只是重申您可能已经知道的定义。让我用一个详细的例子来说明，以简化解释。&lt;/p&gt;&#xA;&lt;p&gt;在实现依赖注入时，开发人员有三个选项来确定实例的生命周期：&lt;/p&gt;</description>
      <pubDate>Thu, 03 Oct 2024 20:00:04 +0000</pubDate>
    </item>
    <item>
      <title>【Curating Efficient Distributed Application Runtime (Dapr) Workflows】策划高效的分布式应用程序运行时 (Dapr) 工作流程</title>
      <link>https://dzone.com/articles/curating-efficient-dapr-workflows</link>
      <description>【&lt;p&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;Distributed Application Runtime (Dapr) is a portable and event-driven runtime that commoditizes some of the problems developers face with &lt;/span&gt;&lt;a href=&#34;https://dzone.com/articles/demystifying-distributed-systems-a-beginners-guide&#34;&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;distributed systems&lt;/span&gt;&lt;/a&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt; and microservices daily.&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;Imagine there are 3-4 different microservices. As part of communication between these services, developers must think about:&lt;/span&gt;&lt;/p&gt;】&lt;p&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;分布式应用程序运行时 (Dapr) 是一种可移植且事件驱动的运行时，它将开发人员面临的一些问题商品化&lt;/span&gt;&lt;a href=&#34;https:// /dzone.com/articles/demystifying-distributed-systems-a-beginners-guide&#34;&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;分布式系统&lt;/span&gt;&lt;/a&gt;&lt;span data-preserver-spaces= “true”&gt; 和微服务日常。&lt;/span&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;span data-preserver-spaces=&#34;true&#34;&gt;想象一下有 3-4 个不同的微服务。作为这些服务之间通信的一部分，开发人员必须考虑：&lt;/span&gt;&lt;/p&gt;</description>
      <pubDate>Fri, 04 Oct 2024 19:30:04 +0000</pubDate>
    </item>
    <item>
      <title>【Supercharge Your Search With GenAI: From Simple Queries to Smarter Results】使用 GenAI 增强您的搜索：从简单查询到更智能的结果</title>
      <link>https://dzone.com/articles/supercharge-your-search-with-genai</link>
      <description>【&lt;p dir=&#34;ltr&#34;&gt;In specialized fields like law, medicine, or even fashion, search engines are critical tools that professionals use to find accurate, relevant information quickly. However, traditional search engines often struggle to interpret complex, domain-specific queries. That’s where &lt;a href=&#34;https://dzone.com/articles/introduction-generative-ai-empowering-enterprises&#34;&gt;Generative AI (GenAI)&lt;/a&gt; can revolutionize the process by transforming simple queries into powerful search instructions through query expansion and reformulation.&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;By integrating &lt;strong&gt;Chain-of-Thought (CoT) prompting&lt;/strong&gt; with &lt;a href=&#34;https://dzone.com/refcardz/getting-started-with-large-language-models&#34;&gt;&lt;strong&gt;Large Language Models (LLMs)&lt;/strong&gt;&lt;/a&gt;, you can significantly enhance the precision and relevance of search results. This tutorial will show you how to implement &lt;strong&gt;Flan-T5&lt;/strong&gt; (or similar models) for advanced query expansion and reformulation.&lt;/p&gt;】&lt;p dir=&#34;ltr&#34;&gt;在法律、医学甚至时尚等专业领域，搜索引擎是专业人士用来快速查找准确、相关信息的重要工具。然而，传统的搜索引擎通常很难解释复杂的、特定领域的查询。这就是&lt;a href=&#34;https://dzone.com/articles/introduction-generative-ai-empowering-enterprises&#34;&gt;生成式人工智能 (GenAI)&lt;/a&gt; 可以通过以下方式彻底改变这一过程：将简单的查询转换为强大的搜索指令查询扩展和重构。&lt;/p&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;通过将&lt;strong&gt;思想链 (CoT) 提示&lt;/strong&gt;与 &lt;a href=&#34;https://dzone.com/refcardz/getting-started-with-large- language-models&#34;&gt;&lt;strong&gt;大型语言模型 (LLM)&lt;/strong&gt;&lt;/a&gt;，可以显着提高搜索结果的精确度和相关性。本教程将向您展示如何实现&lt;strong&gt;Flan-T5&lt;/strong&gt;（或类似模型）以进行高级查询扩展和重构。&lt;/p&gt;</description>
      <pubDate>Thu, 03 Oct 2024 12:00:05 +0000</pubDate>
    </item>
    <item>
      <title>【Why Doesn&#39;t Postgres Use My Index?】为什么 Postgres 不使用我的索引？</title>
      <link>https://dzone.com/articles/why-doesnt-postgres-use-my-index</link>
      <description>【&lt;p data-pm-slice=&#34;1 1 []&#34;&gt;It may happen that we create an index, but PostgreSQL doesn’t use it. What could be the reason, and how can we fix it? We identified 11 distinct scenarios. Read on to find out.&lt;/p&gt;&#xA;&lt;h2&gt;Important Things&lt;/h2&gt;&#xA;&lt;p&gt;Indexes may be tricky. We already covered how they work in &lt;a href=&#34;https://dzone.com/articles/indexes-under-the-hood&#34;&gt;another article&lt;/a&gt;. Let’s quickly recap the important parts of how they work.&lt;/p&gt;】&lt;p data-pm-slice=&#34;1 1 []&#34;&gt;有可能我们创建了索引，但 PostgreSQL 不使用它。可能是什么原因，我们该如何解决？我们确定了 11 种不同的场景。请继续阅读以找出答案。&lt;/p&gt;&#xA;&lt;h2&gt;重要的事情&lt;/h2&gt;&#xA;&lt;p&gt;索引可能很棘手。我们已经在&lt;a href=&#34;https://dzone.com/articles/indexes-under-the-hood&#34;&gt;另一篇文章&lt;/a&gt;中介绍了它们的工作原理。让我们快速回顾一下它们工作原理的重要部分。&lt;/p&gt;</description>
      <pubDate>Thu, 03 Oct 2024 14:00:21 +0000</pubDate>
    </item>
    <item>
      <title>【Augmenting the Client With Alpine.js】使用 Alpine.js 增强客户端</title>
      <link>https://dzone.com/articles/augmenting-the-client-with-alpinejs</link>
      <description>【&lt;p&gt;This post is part of a series comparing different ways to implement asynchronous requests on the client, which is colloquially known as AJAX. I dedicated the &lt;a href=&#34;https://dzone.com/articles/augmenting-the-client-with-vuejs&#34;&gt;previous post to Vue.js&lt;/a&gt;. I&#39;ll dedicate this one to &lt;a href=&#34;https://alpinejs.dev/&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;Alpine.js&lt;/a&gt; — not to be confused with Alpine Linux.&lt;/p&gt;&#xA;&lt;p&gt;I&#39;ll follow the same structure as previously.&lt;/p&gt;】&lt;p&gt;这篇文章是比较在客户端上实现异步请求（俗称 AJAX）的不同方法的系列文章的一部分。我将&lt;a href=&#34;https://dzone.com/articles/augmenting-the-client-with-vuejs&#34;&gt;上一篇文章献给了 Vue.js&lt;/a&gt;。我将把这篇文章献给 &lt;a href=&#34;https://alpinejs.dev/&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;Alpine.js&lt;/a&gt; — 不要与 Alpine Linux 混淆。&lt; /p&gt;&#xA;&lt;p&gt;我将遵循与之前相同的结构。&lt;/p&gt;</description>
      <pubDate>Fri, 04 Oct 2024 12:00:08 +0000</pubDate>
    </item>
    <item>
      <title>【Implementing Polling With RxJS】使用 RxJS 实现轮询</title>
      <link>https://dzone.com/articles/implementing-polling-with-rxjs</link>
      <description>【&lt;p&gt;In most front-end applications, fetching data from the back-end is a common requirement to provide up-to-date information to the user. Typically, this process is straightforward: know the API endpoint, create a function, call it, process the response, and display it on the page. However, there are scenarios — often rare or specific to certain business needs — where client-server communication must be more sophisticated. In this article, we’ll explore one such case: implementing repetitive API calls (polling) using RxJS.&lt;/p&gt;&#xA;&lt;h2&gt;RxJS Refresher&lt;/h2&gt;&#xA;&lt;p&gt;Before diving into polling, let’s take a moment to refresh our understanding of RxJS. For those new to it, &lt;a href=&#34;https://dzone.com/refcardz/rxjs-streams&#34;&gt;RxJS (Reactive Extensions for JavaScript)&lt;/a&gt; is a library that brings reactive programming concepts into the JavaScript ecosystem. It’s particularly useful for managing asynchronous operations, offering powerful tools like &lt;a href=&#34;https://dzone.com/articles/angular-observables-and-promises-how-to-use-them&#34;&gt;&lt;strong&gt;Observables&lt;/strong&gt;&lt;/a&gt;, &lt;strong&gt;Observers&lt;/strong&gt;, &lt;strong&gt;Subjects&lt;/strong&gt;, and &lt;a href=&#34;https://dzone.com/articles/angular-rxjs-reactive-operators&#34;&gt;&lt;strong&gt;Operators&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;】&lt;p&gt;在大多数前端应用程序中，从后端获取数据是向用户提供最新信息的常见要求。通常，此过程很简单：了解 API 端点、创建函数、调用它、处理响应并将其显示在页面上。然而，在某些情况下（通常很少见或特定于某些业务需求），客户端-服务器通信必须更加复杂。在本文中，我们将探讨这样一个案例：使用 RxJS 实现重复的 API 调用（轮询）。&lt;/p&gt;&#xA;&lt;h2&gt;RxJS 复习&lt;/h2&gt;&#xA;&lt;p&gt;在深入讨论轮询之前，让我们花点时间回顾一下对 RxJS 的理解。对于新手来说，&lt;a href=&#34;https://dzone.com/refcardz/rxjs-streams&#34;&gt;RxJS（JavaScript 响应式扩展）&lt;/a&gt; 是一个将响应式编程概念引入 JavaScript 生态系统的库。它对于管理异步操作特别有用，提供强大的工具，例如 &lt;a href=&#34;https://dzone.com/articles/angular-observables-and-promises-how-to-use-them&#34;&gt;&lt;strong&gt;Observables&lt;/ strong&gt;&lt;/a&gt;、&lt;strong&gt;观察者&lt;/strong&gt;、&lt;strong&gt;主题&lt;/strong&gt;和&lt;a href=&#34;https://dzone.com/articles/angular-rxjs-reactive-operators&#34;&gt; &lt;strong&gt;操作员&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;</description>
      <pubDate>Thu, 03 Oct 2024 16:00:04 +0000</pubDate>
    </item>
    <item>
      <title>【Enhanced API Security: Fine-Grained Access Control Using OPA and Kong Gateway】增强的 API 安全性：使用 OPA 和 Kong 网关进行细粒度访问控制</title>
      <link>https://dzone.com/articles/enhanced-api-security-fine-grained-access-control</link>
      <description>【&lt;p dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://dzone.com/articles/why-use-kong-api-gateway&#34;&gt;Kong Gateway&lt;/a&gt; is an open-source API gateway that ensures only the right requests get in while managing security, rate limiting, logging, and more. &lt;a href=&#34;https://dzone.com/articles/building-with-open-policy-agent-opa-for-better-pol&#34;&gt;OPA (Open Policy Agent)&lt;/a&gt; is an open-source policy engine that takes control of your security and access decisions. Think of it as the mind that decouples policy enforcement from your app, so your services don’t need to stress about enforcing rules. Instead, OPA does the thinking with its Rego language, evaluating policies across APIs, microservices, or even &lt;a href=&#34;https://dzone.com/articles/open-policy-agent-with-kubernetes-part-one&#34;&gt;Kubernetes&lt;/a&gt;. It’s flexible, and secure, and makes updating policies a breeze. OPA works by evaluating three key things: input (real-time data like requests), data (external info like user roles), and policy (the logic in Rego that decides whether to &#34;allow&#34; or &#34;deny&#34;). Together, these components allow OPA to keep your &lt;a href=&#34;https://dzone.com/articles/api-security-patterns&#34;&gt;security&lt;/a&gt; game strong while keeping things simple and consistent.&amp;nbsp;&lt;/p&gt;&#xA;&lt;h2 dir=&#34;ltr&#34;&gt;&lt;img width=&#34;539&#34; height=&#34;289&#34; class=&#34;fr-fic fr-dib lazyload&#34; data-image=&#34;true&#34; data-new=&#34;false&#34; data-sizeformatted=&#34;64.4 kB&#34; data-mimetype=&#34;image/png&#34; data-creationdate=&#34;1726255537414&#34; data-creationdateformatted=&#34;09/13/2024 07:25 PM&#34; data-type=&#34;temp&#34; data-url=&#34;https://dz2cdn1.dzone.com/storage/temp/17917049-1726255536632.png&#34; data-modificationdate=&#34;null&#34; data-size=&#34;64390&#34; data-name=&#34;1726255536632.png&#34; data-id=&#34;17917049&#34; data-src=&#34;https://dz2cdn1.dzone.com/storage/temp/17917049-1726255536632.png&#34; alt=&#34;Kong and OPA logos&#34;&gt;What Are We Seeking to Accomplish or Resolve?&lt;/h2&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;Oftentimes, the&amp;nbsp;data&amp;nbsp;in OPA is like a steady old friend — static or slowly changing. It’s used alongside the ever-changing&amp;nbsp;input&amp;nbsp;data to make smart decisions. But, imagine a system with a sprawling web of microservices, tons of users, and a massive database like PostgreSQL. This system handles a high volume of transactions every second and needs to keep up its speed and throughput without breaking a sweat.&lt;/p&gt;】&lt;p dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://dzone.com/articles/why-use-kong-api-gateway&#34;&gt;Kong Gateway&lt;/a&gt; 是一个开源 API 网关，可确保仅在管理安全性、速率限制、日志记录等的同时接收正确的请求。 &lt;a href=&#34;https://dzone.com/articles/building-with-open-policy-agent-opa-for-better-pol&#34;&gt;OPA（开放策略代理）&lt;/a&gt;是一项开源策略控制您的安全和访问决策的引擎。将其视为将策略执行与应用程序解耦的思想，因此您的服务不需要强调执行规则。相反，OPA 使用其 Rego 语言进行思考，跨 API、微服务甚至 &lt;a href=&#34;https://dzone.com/articles/open-policy-agent-with-kubernetes-part-one&#34;&gt; 评估策略库伯内特斯&lt;/a&gt;。它灵活、安全，并且使更新策略变得轻而易举。 OPA 的工作原理是评估三个关键因素：输入（请求等实时数据）、数据（用户角色等外部信息）和策略（Rego 中决定“允许”或“拒绝”的逻辑）。这些组件共同使 OPA 能够保持您的&lt;a href=&#34;https://dzone.com/articles/api-security-patterns&#34;&gt;安全&lt;/a&gt;游戏强大，同时保持简单和一致。 &lt;/p&gt;&#xA;&lt;h2 dir=&#34;ltr&#34;&gt;&lt;img width=&#34;539&#34; height=&#34;289&#34; class=&#34;fr-fic fr-diblazyload&#34; data-image=&#34;true&#34; data-new=&#34;false&#34; data-sizeformatted=&#34; 64.4 kB&#34; data-mimetype=&#34;image/png&#34; data-creationdate=&#34;1726255537414&#34; data-creationdateformatted=&#34;09/13/2024 07:25 PM&#34; data-type=&#34;temp&#34; data-url=&#34;https:// dz2cdn1.dzone.com/storage/temp/17917049-1726255536632.png&#34; data-modificationdate=&#34;null&#34; data-size=&#34;64390&#34; data-name=&#34;1726255536632.png&#34; data-id=&#34;17917049&#34; data-src= &#34;https://dz2cdn1.dzone.com/storage/temp/17917049-1726255536632.png&#34; alt=&#34;Kong 和 OPA 徽标&#34;&gt;我们寻求实现或解决什么？&lt;/h2&gt;&#xA;&lt;p dir=&#34;ltr&#34;&gt;通常，OPA 中的数据就像一位稳定的老朋友 - 静态或缓慢变化。它与不断变化的输入数据一起使用以做出明智的决策。但是，想象一下一个拥有庞大的微服务网络、大量用户和像 PostgreSQL 这样的庞大数据库的系统。该系统每秒处理大量交易，需要毫不费力地保持其速度和吞吐量。&lt;/p&gt;</description>
      <pubDate>Fri, 04 Oct 2024 14:30:02 +0000</pubDate>
    </item>
    <item>
      <title>【How to Create a Search Engine and Algorithm With ClickHouse and Snowflake】如何使用 ClickHouse 和 Snowflake 创建搜索引擎和算法</title>
      <link>https://dzone.com/articles/create-a-search-engine-with-clickhouse-and-snowflake</link>
      <description>【&lt;p&gt;&lt;a href=&#34;https://dzone.com/articles/clickhouse-made-easy-getting-started-with-a-few-cl&#34;&gt;ClickHouse&lt;/a&gt; is an open-source data warehousing solution that is architected as a &lt;a href=&#34;https://clickhouse.com/docs/en/faq/general/columnar-database&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;columnar database management system&lt;/a&gt;. This makes it extremely powerful to work with massive datasets, especially ones that are long as they can be aggregated, ordered, or computed with low latency. When working with the same data type, it&#39;s very efficient for fast scanning and filtering of the data. This makes it a great use case for implementing a search engine.&lt;/p&gt;&#xA;&lt;p&gt;A lot of applications use &lt;a href=&#34;https://dzone.com/articles/introduction-to-elasticsearch-1&#34;&gt;Elasticsearch&lt;/a&gt; as their search engine solution. However, such an implementation can be expensive both in terms of cost and time. Copying the data over to Elasticsearch can also cause lags because data is being migrated to another data store. Also, &lt;a href=&#34;https://logz.io/blog/elasticsearch-cluster-tutorial/&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;setting up the Elasticsearch cluster&lt;/a&gt;, configuring the nodes and defining and fine-tuning indexes can take more programmatic work, which may not be justified for all projects.&amp;nbsp;&lt;/p&gt;】&lt;p&gt;&lt;a href=&#34;https://dzone.com/articles/clickhouse-made-easy-getting-started-with-a-few-cl&#34;&gt;ClickHouse&lt;/a&gt; 是一个开源数据仓库解决方案其架构为&lt;a href=&#34;https://clickhouse.com/docs/en/faq/general/columnar-database&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;列式数据库管理系统&lt;/a&gt; 。这使得处理海量数据集变得非常强大，尤其是那些可以低延迟聚合、排序或计算的数据集。当处理相同的数据类型时，它对于快速扫描和过滤数据非常有效。这使其成为实现搜索引擎的绝佳用例。&lt;/p&gt;&#xA;&lt;p&gt;许多应用程序使用 &lt;a href=&#34;https://dzone.com/articles/introduction-to-elasticsearch-1&#34;&gt;Elasticsearch&lt;/a&gt; 作为其搜索引擎解决方案。然而，这样的实施在成本和时间方面都可能是昂贵的。将数据复制到 Elasticsearch 也可能会导致滞后，因为数据正在迁移到另一个数据存储。另外，&lt;a href=&#34;https://logz.io/blog/elasticsearch-cluster-tutorial/&#34; rel=&#34;noopener noreferrer&#34; target=&#34;_blank&#34;&gt;设置 Elasticsearch 集群&lt;/a&gt;、配置节点和定义和微调索引可能需要更多的编程工作，这可能并不适合所有项目。 &lt;/p&gt;</description>
      <pubDate>Thu, 03 Oct 2024 18:00:04 +0000</pubDate>
    </item>
    <item>
      <title>【How to Build a RAG-Powered Chatbot With Google Gemini and MyScaleDB】如何使用 Google Gemini 和 MyScaleDB 构建 RAG 支持的聊天机器人</title>
      <link>https://dzone.com/articles/build-a-rag-powered-chatbot-with-gemini-myscaledb</link>
      <description>【&lt;p&gt;In the ever-evolving landscape of artificial intelligence, the quest for more intelligent, responsive, and context-aware chatbots has led us to the doorstep of a new era. Welcome to the world of RAG —Retrieval-Augmented Generation (RAG)&lt;span&gt;&lt;span class=&#34;sr-only&#34;&gt;(opens a new window&lt;/span&gt;&lt;/span&gt;, a groundbreaking approach that combines the vast knowledge of retrieval systems with the creative prowess of generative models. RAG technology allows chatbots to handle any type of user query effectively by accessing a knowledge base. But to harness this power effectively, we need a storage solution that can match its speed and efficiency. This is where vector databases shine, offering a quantum leap in how we manage and retrieve vast amounts of data.&lt;/p&gt;&#xA;&lt;p&gt;In this blog, we will show you how to build a RAG-powered chatbot using Google Gemini models and MyScaleDB&lt;span&gt;&amp;nbsp;&lt;span class=&#34;sr-only&#34;&gt;(opens new window)&lt;/span&gt;&lt;/span&gt;within minutes.&lt;/p&gt;】&lt;p&gt;在不断发展的人工智能领域，对更智能、响应更快和上下文感知的聊天机器人的追求使我们迈入了新时代的门口。欢迎来到 RAG 的世界 — 检索增强生成 (RAG)&lt;span&gt;&lt;span class=&#34;sr-only&#34;&gt;（打开一个新窗口&lt;/span&gt;&lt;/span&gt;，这是一种突破性的方法，结合了广泛的知识具有生成模型创造力的检索系统允许聊天机器人通过访问知识库来有效地处理任何类型的用户查询，但为了有效地利用这种能力，我们需要一个能够匹配其速度和效率的存储解决方案。矢量数据库大放异彩，为我们管理和检索大量数据的方式带来了巨大飞跃。&lt;/p&gt;&#xA;&lt;p&gt;在本博客中，我们将向您展示如何使用 Google Gemini 模型和 MyScaleDB 构建由 RAG 驱动的聊天机器人&lt;span&gt; &lt;span class=&#34;sr-only&#34;&gt;（打开新窗口）&lt;/span&gt;&lt;/span &gt;几分钟之内。&lt;/p&gt;</description>
      <pubDate>Fri, 04 Oct 2024 17:00:14 +0000</pubDate>
    </item>
  </channel>
</rss>