<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Grafana Labs blog on Grafana Labs</title>
    <link>/blog/index.xml</link>
    <description>Recent content in Grafana Labs blog on Grafana Labs</description>
    <item>
      <title>【How to query private network data without an agent using AWS and Grafana Cloud】如何使用AWS和Grafana Cloud在没有代理的情况下查询私有网络数据</title>
      <link>https://grafana.com/blog/2024/12/02/private-datasource-connect-aws-privatelink-amazon-vpc-lattice/</link>
      <description>【&lt;p&gt;Connecting to data sources in a private network or an Amazon Virtual Private Cloud (Amazon VPC) can require extra attention to the network security configuration to prevent unintended network exposure. For example, if you wanted to query a network-secured data source, like a MySQL database or an Elasticsearch cluster, that is hosted in an on-premises private network, you would need to open your network to inbound queries from a range of IP addresses.&lt;/p&gt;&#xA;&lt;p&gt;Luckily there are tools to help protect against those vulnerabilities. You can query your network-secured data sources from Grafana Cloud using Private Data Source Connect (PDC), which we &lt;a href=&#34;/blog/2023/10/05/unify-and-query-private-network-data-in-grafana-cloud-private-data-source-connect-is-now-ga/&#34;&gt;rolled out last year&lt;/a&gt; to all tiers of Grafana Cloud. And if you want to build secure and efficient integrations between your AWS VPC resources and Grafana Cloud, that process just got much easier.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;PDC can now establish a private connection using AWS PrivateLink and Amazon VPC Lattice, bypassing the public internet and eliminating the need to deploy the PDC agent within an AWS environment.&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1600px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/pdc-privatelink-lattice/grafana-cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/pdc-privatelink-lattice/grafana-cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png&#34;data-srcset=&#34;/media/blog/pdc-privatelink-lattice/grafana-cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png?w=320 320w, /media/blog/pdc-privatelink-lattice/grafana-cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png?w=550 550w, /media/blog/pdc-privatelink-lattice/grafana-cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png?w=750 750w, /media/blog/pdc-privatelink-lattice/grafana-cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png?w=900 900w, /media/blog/pdc-privatelink-lattice/grafana-cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png?w=1040 1040w, /media/blog/pdc-privatelink-lattice/grafana-cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png?w=1240 1240w, /media/blog/pdc-privatelink-lattice/grafana-cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Diagram of how Grafana Cloud PDC, AWS PrivateLink, and Amazon VPC Lattice work together.&#34;width=&#34;1600&#34;height=&#34;779&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/pdc-privatelink-lattice/grafana-cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png&#34;&#xA;alt=&#34;Diagram of how Grafana Cloud PDC, AWS PrivateLink, and Amazon VPC Lattice work together.&#34;width=&#34;1600&#34;height=&#34;779&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;This new feature — which was &lt;a href=&#34;https://aws.amazon.com/about-aws/whats-new/2024/12/access-vpc-resources-aws-privatelink/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;announced at AWS re:Invent&lt;/a&gt; and is now available in private preview — means that your teams no longer need to allowlist a wide range of IP addresses. Instead, you can query and alert on your data securely within the AWS network, minimizing exposure to external threats while adhering to compliance standards across industries. You&amp;rsquo;ll also be able to quickly and more easily visualize and alert on your private data using the Grafana dashboards you know and love.&lt;/p&gt;&#xA;&lt;h2 id=&#34;key-features-and-benefits&#34;&gt;Key features and benefits&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;1. Granular control:&lt;/strong&gt; Share resources with your Grafana Cloud stack, which will then be available to use as Grafana data sources. All queries to those resources will go over AWS PrivateLink. Access to these shared resources is completely within your control — you can remove access at any time.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;2. Enhanced security:&lt;/strong&gt; Using AWS PrivateLink and VPC Lattice, data flows through a secure, private network, reducing the risk of data interception and ensuring compliance with regulations like GDPR and HIPAA.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;3. Optimized performance:&lt;/strong&gt; AWS PrivateLink’s reliable, low-latency pathways result in improved responsiveness and efficiency of your Grafana dashboards, enhancing the overall user experience.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;4. Ease of integration:&lt;/strong&gt; PDC in Grafana Cloud simplifies the process of connecting AWS-hosted data sources, eliminating the need for complex VPN configurations and providing a straightforward setup process.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;5. Cost effective:&lt;/strong&gt; All transactions stay in your AWS network, eliminating the egress cost of sending your data through the public internet.&lt;/p&gt;&#xA;&lt;p&gt;The combination of PDC with AWS PrivateLink and VPC Lattice is especially well-suited for industries where data security and integrity are critical:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Financial services:&lt;/strong&gt; Gain insights from financial data while safeguarding against unauthorized access.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Healthcare:&lt;/strong&gt; Monitor and evaluate health metrics with full compliance and data protection assurances.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Technology and SaaS:&lt;/strong&gt; Optimize infrastructure performance with secure, real-time monitoring capabilities.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;learn-more-about-pdc-in-grafana-cloud-and-aws-privatelink&#34;&gt;Learn more about PDC in Grafana Cloud and AWS PrivateLink&lt;/h2&gt;&#xA;&lt;p&gt;This functionality in PDC using AWS PrivateLink and VPC Lattice is currently available in private preview. If you are interested in learning more,&lt;a href=&#34;https://docs.google.com/forms/d/e/1FAIpQLSeYOWQDHVFmHJXsqXL63lHtTWhD2fmJhrFAVhgr1C4pXP8bkA/viewform&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt; please contact the Grafana Labs team&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;To learn more about PDC, check out our &lt;a href=&#34;/docs/grafana-cloud/private-data-source-connect/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Private Data Source Connect documentation&lt;/a&gt;. For more on AWS offerings, check out the &lt;a href=&#34;https://docs.aws.amazon.com/vpc/latest/privatelink/what-is-privatelink.html&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;AWS PrivateLink documentation&lt;/a&gt; and the &lt;a href=&#34;https://docs.aws.amazon.com/vpc-lattice/latest/ug/what-is-vpc-lattice.html&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Amazon VPC Lattice web page&lt;/a&gt;.&lt;/p&gt;】&lt;p&gt;连接到私有网络或 Amazon Virtual Private Cloud (Amazon VPC) 中的数据源可能需要额外注意网络安全配置，以防止意外的网络暴露。例如，如果您想要查询托管在本地专用网络中的受网络保护的数据源（例如 MySQL 数据库或 Elasticsearch 集群），则需要将网络开放给来自一系列 IP 的入站查询。地址。&lt;/p&gt;&#xA;&lt;p&gt;幸运的是，有一些工具可以帮助防范这些漏洞。您可以使用私有数据源连接 (PDC) 从 Grafana Cloud 查询网络安全数据源，我们&lt;a href=&#34;/blog/2023/10/05/unify-and-query-private-network-data-in -grafana-cloud-private-data-source-connect-is-now-ga/&#34;&gt;去年推出&lt;/a&gt;到 Grafana Cloud 的所有层。如果您想在 AWS VPC 资源和 Grafana Cloud 之间构建安全高效的集成，这个过程就会变得更加容易。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;PDC 现在可以使用 AWS PrivateLink 和 Amazon VPC Lattice 建立私有连接，绕过公共互联网，并且无需在 AWS 环境中部署 PDC 代理。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1600px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/pdc-privatelink-lattice/grafana-cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/pdc-privatelink-lattice/grafana-cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png&#34;data-srcset=&#34;/media/blog/pdc- privatelink-lattice/grafana-cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png?w=320 320w, /media/blog/pdc-privatelink-lattice/grafana-cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png?w=550 550w，/media/blog/pdc-privatelink-lattice/grafana -cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png?w=750 750w, /media/blog/pdc-privatelink-lattice/grafana-cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png?w=900 900w，/media/blog/pdc-privatelink-lattice/grafana -cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png?w=1040 1040w, /media/blog/pdc-privatelink-lattice/grafana-cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png?w=1240 1240w，/media/blog/pdc-privatelink-lattice/grafana -cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png?w=1920 1920瓦”&#xA;data-sizes=&#34;auto&#34;alt=&#34;Grafana Cloud PDC、AWS PrivateLink 和 Amazon VPC Lattice 如何协同工作的图表。&#34;width=&#34;1600&#34;height=&#34;779&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/pdc-privatelink-lattice/grafana-cloud-pdc-aws-privatelink-amazon-vpc-lattice-diagram-2.png”&#xA;alt=&#34;Grafana Cloud PDC、AWS PrivateLink 和 Amazon VPC Lattice 如何协同工作的图表。&#34;width=&#34;1600&#34;height=&#34;779&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;这个新功能 - &lt;a href=&#34;https://aws.amazon.com/about-aws/whats-new/2024/12/access-vpc-resources-aws-privatelink/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;在 AWS re:Invent&lt;/a&gt; 上宣布现已提供私人预览版 — 意味着您的团队不再需要将各种 IP 地址列入许可名单，您可以在 AWS 网络中安全地查询数据并发出警报，从而最大程度地减少受到外部威胁的风险。遵守跨行业的合规标准，您还可以使用您熟悉和喜爱的 Grafana 仪表板快速、轻松地可视化您的私人数据并发出警报。&lt;/p&gt;&#xA;&lt;h2 id=&#34;key-features-and-benefits&#34;&gt;主要功能和优势&lt;/h2&gt;&#xA;&lt;p&gt;&lt;强&gt;1。精细控制：&lt;/strong&gt;与 Grafana Cloud 堆栈共享资源，然后可以将其用作 Grafana 数据源。对这些资源的所有查询都将通过 AWS PrivateLink 进行。对这些共享资源的访问完全在您的控制范围内 - 您可以随时删除访问权限。&lt;/p&gt;&#xA;&lt;p&gt;&lt;强&gt;2。增强的安全性：&lt;/strong&gt;使用 AWS PrivateLink 和 VPC Lattice，数据流经安全的专用网络，降低数据拦截的风险并确保遵守 GDPR 和 HIPAA 等法规。&lt;/p&gt;&#xA;&lt;p&gt;&lt;强&gt;3。优化的性能：&lt;/strong&gt;AWS PrivateLink 可靠、低延迟的路径可提高 Grafana 仪表板的响应能力和效率，从而增强整体用户体验。&lt;/p&gt;&#xA;&lt;p&gt;&lt;强&gt;4。易于集成：&lt;/strong&gt;Grafana Cloud 中的 PDC 简化了连接 AWS 托管数据源的过程，无需复杂的 VPN 配置并提供简单的设置过程。&lt;/p&gt;&#xA;&lt;p&gt;&lt;强&gt;5。成本效益高：&lt;/strong&gt;所有交易都保留在您的 AWS 网络中，消除了通过公共互联网发送数据的出口成本。&lt;/p&gt;&#xA;&lt;p&gt;PDC 与 AWS PrivateLink 和 VPC Lattice 的组合特别适合数据安全性和完整性至关重要的行业：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;金融服务&lt;/strong&gt;：从财务数据中获取见解，同时防止未经授权的访问。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;医疗保健&lt;/strong&gt;：在完全合规和数据保护保证的情况下监控和评估健康指标。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;技术和 SaaS：&lt;/strong&gt;通过安全、实时的监控功能优化基础架构性能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;learn-more-about-pdc-in-grafana-cloud-and-aws-privatelink&#34;&gt;了解有关 Grafana Cloud 和 AWS PrivateLink 中的 PDC 的更多信息&lt;/h2&gt;&#xA;&lt;p&gt;使用 AWS PrivateLink 和 VPC Lattice 的 PDC 中的此功能目前在私人预览版中提供。如果您有兴趣了解更多信息，&lt;a href=&#34;https://docs.google.com/forms/d/e/1FAIpQLSeYOWQDHVFmHJXsqXL63lHtTWhD2fmJhrFAVhgr1C4pXP8bkA/viewform&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;请联系 Grafana 实验室团队&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;p&gt;要了解有关 PDC 的更多信息，请查看我们的&lt;a href=&#34;/docs/grafana-cloud/private-data-source-connect/?pg=blog&amp;plcmt=body-txt&#34;&gt;私有数据源e 连接文档&lt;/a&gt;。有关 AWS 产品的更多信息，请查看 &lt;a href=&#34;https://docs.aws.amazon.com/vpc/latest/privatelink/what-is-privatelink.html&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer &#34;&gt;AWS PrivateLink 文档&lt;/a&gt; 和 &lt;a href=&#34;https://docs.aws.amazon.com/vpc-lattice/latest/ug/what-is-vpc-lattice.html&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Amazon VPC Lattice 网页&lt;/a&gt;。&lt;/p&gt;</description>
      <pubDate>Mon, 02 Dec 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【The evolution of Grafana Cloud Synthetic Monitoring: new features, pricing updates, and more】Grafana 云综合监控的演变：新功能、定价更新等</title>
      <link>https://grafana.com/blog/2024/12/02/the-evolution-of-grafana-cloud-synthetic-monitoring-new-features-pricing-updates-and-more/</link>
      <description>【&lt;p&gt;With 2024 coming to a close, it’s a good time to reflect on how Grafana Cloud has evolved this year — and synthetic monitoring, in particular, is one area where we’ve really focused our efforts.&lt;/p&gt;&#xA;&lt;p&gt;In May, we rolled out a &lt;a href=&#34;/blog/2024/05/01/grafana-cloud-synthetic-monitoring-all-the-latest-features/&#34;&gt;revamped version of Grafana Cloud Synthetic Monitoring&lt;/a&gt; with the overall goal of making your monitoring processes not just more efficient, but more impactful. &lt;a href=&#34;/products/cloud/synthetic-monitoring/&#34;&gt;Synthetic Monitoring&lt;/a&gt; now enables you to emulate even the most complex transactions and user journeys so you can ensure the best possible end-user experience for your apps.&lt;/p&gt;&#xA;&lt;p&gt;But we didn’t stop there. We’ve made a number of other updates since then to continue the evolution of Synthetic Monitoring, and help you get even more value out of the product.&lt;/p&gt;&#xA;&lt;p&gt;In case you missed it, here’s a look back at the highlights.&lt;/p&gt;&#xA;&lt;h2 id=&#34;synthetic-monitoring-now-better-than-ever-powered-by-grafana-k6&#34;&gt;Synthetic Monitoring: now better than ever, powered by Grafana k6&lt;/h2&gt;&#xA;&lt;p&gt;From the beginning, Synthetic Monitoring has used the &lt;a href=&#34;https://github.com/prometheus/blackbox_exporter&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Prometheus blackbox exporter&lt;/a&gt; to test at the protocol level. This worked well for health and uptime monitoring, but didn’t cover the full range of synthetic monitoring use cases.&lt;/p&gt;&#xA;&lt;p&gt;To ensure system reliability, engineering teams today need to monitor and validate an increasingly intricate set of steps within the end-user journey. While we couldn’t offer this capability with the blackbox exporter alone, we can with &lt;a href=&#34;/oss/k6/&#34;&gt;Grafana k6&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The k6 performance testing platform has certain capabilities that perfectly suit synthetic monitoring use cases. These include:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A high-performance JavaScript engine written in Go&lt;/li&gt;&#xA;&lt;li&gt;A scripting API designed to help emulate and test real application traffic&lt;/li&gt;&#xA;&lt;li&gt;Protocol support for HTTP, WebSockets, and gRPC&lt;/li&gt;&#xA;&lt;li&gt;Built-in metrics, with the ability to add custom metrics and logs to help with troubleshooting&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;These capabilities are exactly why we integrated k6 with the Synthetic Monitoring architecture earlier this year — a move that resulted in two new check types you can use today.&lt;/p&gt;&#xA;&lt;h3 id=&#34;multihttp-and-k6-scripted-checks&#34;&gt;MultiHTTP and k6 scripted checks&lt;/h3&gt;&#xA;&lt;p&gt;HTTP checks have always been a core feature of Grafana Cloud Synthetic Monitoring, enabling users to test an HTTP endpoint to measure uptime and latency. These single HTTP checks are an effective way to perform basic health checks on a website or monitor the response time of a specific API endpoint.&lt;/p&gt;&#xA;&lt;p&gt;In many cases, however, testing scenarios have become more complex. For example, they may have to verify multi-step API interactions or ensure data flows correctly between various parts of an application. This is where our two new check types — multiHTTP and k6 scripted checks — come into play.&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/multihttp/&#34;&gt;MultiHTTP checks&lt;/a&gt;&lt;/strong&gt;: These checks let you test multiple URLs in a single check, while measuring uptime and response latency. Under the hood, a k6 script is generated, which means you don’t have to write code.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6/&#34;&gt;k6 scripted checks&lt;/a&gt;&lt;/strong&gt;: These checks give you the power and flexibility to define your workflow tests in JavaScript, using the &lt;a href=&#34;/docs/k6/latest/javascript-api/&#34;&gt;k6 API&lt;/a&gt; to efficiently author tests.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1504px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_dashboard-screenshot.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_dashboard-screenshot.png&#34;data-srcset=&#34;/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_dashboard-screenshot.png?w=320 320w, /media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_dashboard-screenshot.png?w=550 550w, /media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_dashboard-screenshot.png?w=750 750w, /media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_dashboard-screenshot.png?w=900 900w, /media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_dashboard-screenshot.png?w=1040 1040w, /media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_dashboard-screenshot.png?w=1240 1240w, /media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_dashboard-screenshot.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of a Synthetic Monitoring dashboard.&#34;width=&#34;1504&#34;height=&#34;1020&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_dashboard-screenshot.png&#34;&#xA;alt=&#34;A screenshot of a Synthetic Monitoring dashboard.&#34;width=&#34;1504&#34;height=&#34;1020&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;Bonus: you can use these k6 scripts in other parts of the development lifecycle, which eliminates the need for teams to maintain separate testing scenarios. For example, the same script used for Synthetic Monitoring could be used by developers in a CI pipeline to test for regressions.&lt;/p&gt;&#xA;&lt;h2 id=&#34;a-streamlined-ui&#34;&gt;A streamlined UI&lt;/h2&gt;&#xA;&lt;p&gt;We’ve also been making iterative changes to the Synthetic Monitoring UI, many of which you’ve probably noticed already. We want to make setting up and understanding your running checks a breeze, so we&amp;rsquo;ve improved the check creation flow, updated lists of probes, and made the dashboards for checks more error-driven.&lt;/p&gt;&#xA;&lt;p&gt;We’ve condensed the in-app check creation flow to five simple steps, as shown in the screenshot below.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1999px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_new-scripted-check-UI.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_new-scripted-check-UI.png&#34;data-srcset=&#34;/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_new-scripted-check-UI.png?w=320 320w, /media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_new-scripted-check-UI.png?w=550 550w, /media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_new-scripted-check-UI.png?w=750 750w, /media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_new-scripted-check-UI.png?w=900 900w, /media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_new-scripted-check-UI.png?w=1040 1040w, /media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_new-scripted-check-UI.png?w=1240 1240w, /media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_new-scripted-check-UI.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of the new in-app check creation process. &#34;width=&#34;1999&#34;height=&#34;1762&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_new-scripted-check-UI.png&#34;&#xA;alt=&#34;A screenshot of the new in-app check creation process. &#34;width=&#34;1999&#34;height=&#34;1762&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h2 id=&#34;new-pricing-for-synthetic-monitoring&#34;&gt;New pricing for Synthetic Monitoring&lt;/h2&gt;&#xA;&lt;p&gt;Alongside these enhancements, we&amp;rsquo;ve updated our Grafana Cloud Synthetic Monitoring pricing model.&lt;/p&gt;&#xA;&lt;p&gt;Synthetic Monitoring has transitioned from a telemetry-based pricing model to an execution-based model. This means pricing is now based on the number of executions your checks run each month.&lt;/p&gt;&#xA;&lt;p&gt;The change reflects our investment in the product itself and the value provided to our customers, and matches how other Synthetic Monitoring products on the market are priced.&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;Note: an “execution” is defined as one minute of synthetic check runtime multiplied by the number of locations used. We are including 100k executions per month in our Cloud free tier.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;optimize-your-synthetic-monitoring-spend&#34;&gt;Optimize your Synthetic Monitoring spend&lt;/h3&gt;&#xA;&lt;p&gt;If you’re an existing customer impacted by this pricing change, we’ve reached out via email over the past few months. Please check your inbox and contact customer support, so we can walk you through the changes and help you optimize your spend.&lt;/p&gt;&#xA;&lt;p&gt;We also recommend you evaluate your Synthetic Monitoring configurations, as noted in the following points, to reduce costs:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Review your usage&lt;/strong&gt;: You can review usage on the &lt;a href=&#34;/docs/grafana-cloud/cost-management-and-billing/understand-your-invoice/#billing-and-usage-dashboard&#34;&gt;Billing and Usage dashboard&lt;/a&gt; on the Synthetic Monitoring Usage Details panel. You also can configure &lt;a href=&#34;/docs/grafana-cloud/cost-management-and-billing/set-up-usage-alerts/&#34;&gt;usage alerts&lt;/a&gt; from the panels displayed on the Billing and Usage dashboard to notify your team when activity exceeds expected levels.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Reduce execution frequency&lt;/strong&gt;: The easiest and most effective way to cut costs is to reduce the frequency of your check executions. Unless you require high-frequency monitoring, changing from once per minute to once every five minutes reduces costs by 80% with minimal loss of fidelity.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Use fewer probe locations&lt;/strong&gt;: For most use cases, we recommend using three &lt;a href=&#34;/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/public-probes/&#34;&gt;public probes&lt;/a&gt;. If you are using more than three probes, you should have a unique use case that supports that need — otherwise, you can reduce your number of probes to cut costs. For example, going from six probes to three probes would lower your costs by roughly 50% with minimal impact.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;To learn more about these and other optimization techniques, please refer to our &lt;a href=&#34;/docs/grafana-cloud/cost-management-and-billing/reduce-costs/synthetic-monitoring-costs/&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;We look forward to hearing your feedback, and to the continued evolution of Synthetic Monitoring in 2025.&lt;/p&gt;】&lt;p&gt;随着 2024 年即将结束，现在是反思 Grafana Cloud 今年如何发展的好时机，尤其是综合监控，这是我们真正重点关注的领域。&lt;/p&gt;&#xA;&lt;p&gt;5 月份，我们推出了&lt;a href=&#34;/blog/2024/05/01/grafana-cloud-synthetic-monitoring-all-the-latest-features/&#34;&gt;Grafana Cloud Synthetic Monitoring 的改进版本&lt; /a&gt; 总体目标是使您的监控流程不仅更加高效，而且更具影响力。 &lt;a href=&#34;/products/cloud/synthetic-monitoring/&#34;&gt;综合监控&lt;/a&gt;现在使您能够模拟最复杂的交易和用户旅程，从而确保您的应用获得最佳的最终用户体验。 &lt;/p&gt;&#xA;&lt;p&gt;但我们并没有就此止步。从那时起，我们进行了许多其他更新，以继续综合监控的发展，并帮助您从产品中获得更多价值。&lt;/p&gt;&#xA;&lt;p&gt;如果您错过了，请回顾一下亮点。&lt;/p&gt;&#xA;&lt;h2 id=&#34;synthetic-monitoring-now-better-than-ever-powered-by-grafana-k6&#34;&gt;综合监控：现在比以往更好，由 Grafana k6 提供支持&lt;/h2&gt;&#xA;&lt;p&gt;从一开始，综合监控就使用 &lt;a href=&#34;https://github.com/prometheus/blackbox_exporter&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Prometheus blackbox exporter&lt;/a&gt; 进行测试在协议级别。这对于运行状况和正常运行时间监控效果很好，但没有涵盖全面的综合监控用例。&lt;/p&gt;&#xA;&lt;p&gt;为了确保系统可靠性，当今的工程团队需要监控和验证最终用户旅程中越来越复杂的一系列步骤。虽然我们无法单独使用 blackbox 导出器提供此功能，但可以使用 &lt;a href=&#34;/oss/k6/&#34;&gt;Grafana k6&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;p&gt;k6 性能测试平台具有非常适合综合监控用例的某些功能。其中包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用 Go 编写的高性能 JavaScript 引擎&lt;/li&gt;&#xA;&lt;li&gt;旨在帮助模拟和测试真实应用流量的脚​​本 API&lt;/li&gt;&#xA;&lt;li&gt;对 HTTP、WebSocket 和 gRPC 的协议支持&lt;/li&gt;&#xA;&lt;li&gt;内置指标，能够添加自定义指标和日志以帮助排查问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这些功能正是我们今年早些时候将 k6 与综合监控架构集成的原因 - 这一举措带来了两种您现在可以使用的新检查类型。&lt;/p&gt;&#xA;&lt;h3 id=&#34;multihttp-and-k6-scripted-checks&#34;&gt;MultiHTTP 和 k6 脚本检查&lt;/h3&gt;&#xA;&lt;p&gt;HTTP 检查一直是 Grafana 云综合监控的核心功能，使用户能够测试 HTTP 端点以测量正常运行时间和延迟。这些单一 HTTP 检查是在网站上执行基本运行状况检查或监控特定 API 端点响应时间的有效方法。&lt;/p&gt;&#xA;&lt;p&gt;然而，在许多情况下，测试场景变得更加复杂。例如，他们可能必须验证多步骤 API 交互或确保数据在应用程序的各个部分之间正确流动。这是我们的两个新检查类型——multiHTTP 和 k6 脚本检查——开始发挥作用。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/multihttp/&#34;&gt;MultiHTTP 检查&lt;/a&gt;&lt;/strong&gt;：这些检查可让您进行测试一次检查多个 URL，同时测量正常运行时间和响应延迟。在后台，会生成一个 k6 脚本，这意味着您无需编写代码。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6/&#34;&gt;k6 脚本化检查&lt;/a&gt;&lt;/strong&gt;：这些检查为您提供使用 &lt;a href=&#34;/docs/k6/latest/javascript-api/&#34;&gt;k6 API&lt;/a&gt; 高效编写测试，以 JavaScript 定义工作流程测试的强大功能和灵活性。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1504px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_dashboard-screenshot.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_dashboard-screenshot.png”data-srcset =“/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring- update_dashboard-screenshot.png?w=320 320w, /media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_dashboard-screenshot.png?w=550 550w，/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_dashboard-screenshot.png ?w=750 750w, /media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_dashboard-screenshot.png?w=900 900w，/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_dashboard-screenshot.png ?w=1040 1040w, /media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_dashboard-screenshot.png?w=1240 1240w，/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_dashboard-screenshot.png ?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;综合监控仪表板的屏幕截图。&#34;width=&#34;1504&#34;height=&#34;1020&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_dashboard-screenshot.png”&#xA;alt=&#34;综合监控仪表板的屏幕截图。&#34;width=&#34;1504&#34;height=&#34;1020&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;额外好处：您可以在开发生命周期的其他部分使用这些 k6 脚本，这样团队就无需维护单独的测试场景。例如，开发人员可以在 CI 管道中使用用于综合监控的相同脚本来测试回归。&lt;/p&gt;&#xA;&lt;h2 id=&#34;a-streamlined-ui&#34;&gt;简化的用户界面&lt;/h2&gt;&#xA;&lt;p&gt;我们还对综合监控 UI 进行了迭代更改，您可能已经注意到其中许多更改。我们希望让您的运行检查的设置和理解变得轻而易举，因此我们改进了检查创建流程，更新了探测器列表，并使用于检查更多错误驱动的仪表板。&lt;/p&gt;&#xA;&lt;p&gt;我们将应用内支票创建流程压缩为五个简单步骤，如下面的屏幕截图所示。&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1999px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_new-scripted-check-UI.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_new-scripted-check-UI.png”data-srcset =“/media/blog/synthetic-monitoring-updates-2024/合成监控更新_新脚本检查-UI.png?w=320 320w, /media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_new-scripted-check-UI.png?w=550 550w，/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_new -scripted-check-UI.png?w=750 750w, /media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_new-scripted-check-UI.png?w=900 900w，/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_new -scripted-check-UI.png?w=1040 1040w, /media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_new-scripted-check-UI.png?w=1240 1240w，/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_new -scripted-check-UI.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;新的应用内支票创建过程的屏幕截图。&#34;width=&#34;1999&#34;height=&#34;1762&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/synthetic-monitoring-updates-2024/synthetic-monitoring-updates_new-scripted-check-UI.png”&#xA;alt=&#34;新的应用内支票创建过程的屏幕截图。&#34;width=&#34;1999&#34;height=&#34;1762&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h2 id=&#34;new-pricing-for-synthetic-monitoring&#34;&gt;综合监控的新定价&lt;/h2&gt;&#xA;&lt;p&gt;除了这些增强功能之外，我们还更新了 Grafana Cloud Synthetic Monitoring 定价模型。&lt;/p&gt;&#xA;&lt;p&gt;综合监控已从基于遥测的定价模型转变为基于执行的模型。这意味着现在定价基于您每月运行的检查的执行次数。&lt;/p&gt;&#xA;&lt;p&gt;这一变化反映了我们对产品本身的投资以及为客户提供的价值，并且与市场上其他综合监控产品的定价相匹配。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;注意：“执行”定义为一分钟的综合检查运行时间乘以所使用的位置数。我们的云免费套餐中包含每月 10 万次执行。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;optimize-your-synthetic-monitoring-spend&#34;&gt;优化您的综合监控支出&lt;/h3&gt;&#xA;&lt;p&gt;如果您是受此次价格变动影响的现有客户，我们在过去几个月已通过电子邮件与您联系。请检查您的收件箱并联系客户支持，以便我们可以引导您完成更改并帮助您优化支出。&lt;/p&gt;&#xA;&lt;p&gt;我们还建议您评估您的 Synt严格的监控配置，如以下几点所述，以降低成本：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;查看您的使用情况&lt;/strong&gt;：您可以在 &lt;a href=&#34;/docs/grafana-cloud/cost-management-and-billing/understand-your-invoice/#billing-and 上查看使用情况-usage-dashboard&#34;&gt;综合监控使用情况详细信息面板上的计费和使用情况仪表板&lt;/a&gt;。您还可以从账单和使用情况仪表板上显示的面板配置&lt;a href=&#34;/docs/grafana-cloud/cost-management-and-billing/set-up-usage-alerts/&#34;&gt;使用情况警报&lt;/a&gt;当活动超出预期水平时通知您的团队。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;降低执行频率&lt;/strong&gt;：削减成本最简单、最有效的方法是降低支票执行频率。除非您需要高频监控，否则从每分钟一次更改为每五分钟一次可将成本降低 80%，同时将保真度损失降至最低。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;使用更少的探测位置&lt;/strong&gt;：对于大多数用例，我们建议使用三个&lt;a href=&#34;/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/public-probes/ ”公开调查&lt;/a&gt;。如果您使用三个以上的探针，您应该有一个独特的用例来支持该需求 - 否则，您可以减少探针的数量以降低成本。例如，从六个探针改为三个探针可以将您的成本降低大约 50%，同时影响最小。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;要了解有关这些和其他优化技术的更多信息，请参阅我们的&lt;a href=&#34;/docs/grafana-cloud/cost-management-and-billing/reduce-costs/synthetic-monitoring-costs/&#34;&gt;文档&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;我们期待听到您的反馈，并期待 2025 年综合监控的持续发展。&lt;/p&gt;</description>
      <pubDate>Mon, 02 Dec 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Grafana 11.4 release: Introducing support for OpenSearch PPL and OpenSearch SQL in the AWS CloudWatch data source plugin】Grafana 11.4 版本：在 AWS CloudWatch 数据源插件中引入对 OpenSearch PPL 和 OpenSearch SQL 的支持</title>
      <link>https://grafana.com/blog/2024/12/05/grafana-11.4-release-all-the-latest-features/</link>
      <description>【&lt;p&gt;Holidays came early for AWS users: Grafana 11.4 introduces support for two new query languages in the AWS CloudWatch data source plugin.&lt;/p&gt;&#xA;&lt;div class=&#34;btn-row &#34;&gt;&lt;a class=&#34;btn btn--primary &#34; href=&#34;https://grafana.com/grafana/download/11.4.0/?pg=blog&amp;amp;plcmt=body-txt&#34; rel=&#34;noopener noreferrer&#34;&gt;Grafana 11.4: Download now&lt;/a&gt;&lt;/div&gt;&#xA;&lt;p&gt;Announced during &lt;a href=&#34;https://aws.amazon.com/blogs/aws/new-amazon-cloudwatch-and-amazon-opensearch-service-launch-an-integrated-analytics-experience/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;AWS re:Invent&lt;/a&gt;, AWS CloudWatch Logs expanded its querying capabilities with the addition of OpenSearch Piped Processing Language (PPL) and OpenSearch SQL. In Grafana 11.4, the AWS Cloudwatch data source plugin has been updated to offer the same functionality — and the same flexibility. If you&amp;rsquo;re an AWS user, you can now choose the query language that you&amp;rsquo;re most familiar with to filter and aggregate your CloudWatch logs, and OpenSearch users will be able to query their logs without having to duplicate data.&lt;/p&gt;&#xA;&lt;div&#xA;class=&#34;youtube-lazyload responsive-video&#34;&#xA;data-embed=&#34;g1BfokyzF4Q&#34;&#xA;data-url=&#34;https://www.youtube.com/embed/g1BfokyzF4Q?autoplay=1&amp;amp;rel=0&#34;&#xA;data-title=&#34;YouTube Video&#34;&#xA;&gt;&#xA;&lt;div class=&#34;play-button&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;In addition to the already supported &lt;strong&gt;Logs Insights QL&lt;/strong&gt; option, you can find the added query language options in the new &lt;strong&gt;Query language&lt;/strong&gt; drop-down menu.&lt;/p&gt;&#xA;&lt;p&gt;The following features are supported in the AWS CloudWatch data source plugin for both OpenSearch PPL and OpenSearch SQL:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Syntax highlighting&lt;/strong&gt; to improve readability of complex queries.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Live code completion with suggestions&lt;/strong&gt; of language-specific commands and functions depending on what you’re typing. This includes discovered fields based on your selected log groups.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Sample queries&lt;/strong&gt; in Logs Cheat Sheet that contain a number of example queries, which you can simply select to paste in the query field.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1999px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/grafana-11.4/aws-cloudwatch-plugin-grafana-opensearch-ppl-opensearch-sql.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/grafana-11.4/aws-cloudwatch-plugin-grafana-opensearch-ppl-opensearch-sql.png&#34;data-srcset=&#34;/media/blog/grafana-11.4/aws-cloudwatch-plugin-grafana-opensearch-ppl-opensearch-sql.png?w=320 320w, /media/blog/grafana-11.4/aws-cloudwatch-plugin-grafana-opensearch-ppl-opensearch-sql.png?w=550 550w, /media/blog/grafana-11.4/aws-cloudwatch-plugin-grafana-opensearch-ppl-opensearch-sql.png?w=750 750w, /media/blog/grafana-11.4/aws-cloudwatch-plugin-grafana-opensearch-ppl-opensearch-sql.png?w=900 900w, /media/blog/grafana-11.4/aws-cloudwatch-plugin-grafana-opensearch-ppl-opensearch-sql.png?w=1040 1040w, /media/blog/grafana-11.4/aws-cloudwatch-plugin-grafana-opensearch-ppl-opensearch-sql.png?w=1240 1240w, /media/blog/grafana-11.4/aws-cloudwatch-plugin-grafana-opensearch-ppl-opensearch-sql.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Screenshot of AWS CloudWatch plugin in Grafana&#34;width=&#34;1999&#34;height=&#34;1071&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/grafana-11.4/aws-cloudwatch-plugin-grafana-opensearch-ppl-opensearch-sql.png&#34;&#xA;alt=&#34;Screenshot of AWS CloudWatch plugin in Grafana&#34;width=&#34;1999&#34;height=&#34;1071&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;For the complete list of commands supported for OpenSearch PPL and OpenSearch SQL, refer to the &lt;a href=&#34;https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_AnalyzeLogData_Languages.html&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;AWS CloudWatch Logs Insights documentation&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;learn-more-about-grafana&#34;&gt;Learn more about Grafana&lt;/h2&gt;&#xA;&lt;p&gt;For an in-depth list of all the new features in Grafana, check out our &lt;a href=&#34;/docs/grafana/latest/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana documentation&lt;/a&gt;, the Grafana &lt;a href=&#34;https://github.com/grafana/grafana/blob/main/CHANGELOG.md&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;changelog&lt;/a&gt;, or our &lt;a href=&#34;/docs/grafana/latest/whatsnew/whats-new-in-v11-4/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;What’s New documentation&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;join-the-grafana-labs-community&#34;&gt;Join the Grafana Labs community&lt;/h2&gt;&#xA;&lt;p&gt;We invite you to engage with the &lt;a href=&#34;https://community.grafana.com/?pg=blog&amp;amp;plcmt=body-txt&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Grafana Labs community forums&lt;/a&gt;. Share your experiences with the new features, discuss best practices, and explore creative ways to integrate these updates into your workflows. Your insights and use cases are invaluable in enriching the Grafana ecosystem.&lt;/p&gt;&#xA;&lt;h2 id=&#34;upgrade-to-grafana-114&#34;&gt;Upgrade to Grafana 11.4&lt;/h2&gt;&#xA;&lt;p&gt;Download &lt;a href=&#34;/grafana/download/11.4.0&#34;&gt;Grafana 11.4&lt;/a&gt; today or experience all the latest features by signing up for Grafana Cloud, which offers an actually useful forever-free tier and plans for every use case. Sign up for a &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;free Grafana Cloud&lt;/a&gt; account today.&lt;/p&gt;&#xA;&lt;p&gt;Our &lt;a href=&#34;/docs/grafana/latest/upgrade-guide/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana upgrade guide&lt;/a&gt; also provides step-by-step instructions for those looking to upgrade from an earlier version to ensure a smooth transition.&lt;/p&gt;&#xA;&lt;h2 id=&#34;a-special-thanks-to-our-community&#34;&gt;A special thanks to our community&lt;/h2&gt;&#xA;&lt;p&gt;We extend our heartfelt gratitude to the &lt;a href=&#34;/blog/2023/12/12/the-story-of-grafana-documentary-the-community-behind-the-code/&#34;&gt;Grafana community&lt;/a&gt;!&lt;/p&gt;&#xA;&lt;p&gt;Your contributions, ranging from pull requests to valuable feedback, are crucial in continually enhancing Grafana. And your enthusiasm and dedication inspire us at Grafana Labs to persistently innovate and elevate the Grafana platform.&lt;/p&gt;&#xA;&lt;p&gt;We’d love to hear your thoughts on the state of observability. Click the button below to take our annual Observability Survey today!&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper w-100p &#34;&#xA;style=&#34;max-width: 567px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;https://grafana.com/observability-survey/?pg=blog&amp;amp;plcmt=body-txt&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/survey-promo/take-the-survey.png&#34;data-srcset=&#34;/media/blog/survey-promo/take-the-survey.png?w=320 320w, /media/blog/survey-promo/take-the-survey.png?w=550 550w, /media/blog/survey-promo/take-the-survey.png?w=750 750w, /media/blog/survey-promo/take-the-survey.png?w=900 900w, /media/blog/survey-promo/take-the-survey.png?w=1040 1040w, /media/blog/survey-promo/take-the-survey.png?w=1240 1240w, /media/blog/survey-promo/take-the-survey.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Call to action to take the Observability Survey&#34;width=&#34;567&#34;height=&#34;71&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/survey-promo/take-the-survey.png&#34;&#xA;alt=&#34;Call to action to take the Observability Survey&#34;width=&#34;567&#34;height=&#34;71&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt; is the easiest way to get started with metrics, logs, traces, dashboards, and more. We have a generous forever-free tier and plans for every use case. &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Sign up for free now&lt;/a&gt;!&lt;/p&gt;】&lt;p&gt;AWS 用户的假期来得很早：Grafana 11.4 在 AWS CloudWatch 数据源插件中引入了对两种新查询语言的支持。&lt;/p&gt;&#xA;&lt;div class=&#34;btn-row &#34;&gt;&lt;a class=&#34;btn btn--primary&#34; href=&#34;https://grafana.com/grafana/download/11.4.0/?pg=blog&amp;plcmt=body-txt&#34; rel =&#34;noopener noreferrer&#34;&gt;Grafana 11.4：立即下载&lt;/a&gt;&lt;/div&gt;&#xA;&lt;p&gt;在&lt;a href=&#34;https://aws.amazon.com/blogs/aws/new-amazon-cloudwatch-and-amazon-opensearch-service-launch-an-integrated-analytics-experience/”目标期间宣布=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;AWS re:Invent&lt;/a&gt;，AWS CloudWatch Logs 通过添加 OpenSearch 管道处理语言 (PPL) 和 OpenSearch 扩展了其查询功能SQL。在 Grafana 11.4 中，AWS Cloudwatch 数据源插件已更新，可提供相同的功能和相同的灵活性。如果您是 AWS 用户，您现在可以选择您最熟悉的查询语言来过滤和聚合您的 CloudWatch 日志，并且 OpenSearch 用户将能够查询其日志，而无需复制数据。&lt;/p&gt;&#xA;&lt;div&#xA;类 =“youtube-lazyload 响应视频”&#xA;数据嵌入=“g1BfokyzF4Q”&#xA;data-url=&#34;https://www.youtube.com/embed/g1BfokyzF4Q?autoplay=1&amp;rel=0&#34;&#xA;数据标题=“YouTube 视频”&#xA;&gt;&#xA;&lt;div class=&#34;play-button&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;除了已经支持的&lt;strong&gt;Logs Insights QL&lt;/strong&gt;选项之外，您还可以在新的&lt;strong&gt;查询语言&lt;/strong&gt;下拉菜单中找到添加的查询语言选项。&lt;/p&gt;&#xA;&lt;p&gt;OpenSearch PPL 和 OpenSearch SQL 的 AWS CloudWatch 数据源插件支持以下功能：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;语法突出显示&lt;/strong&gt;以提高复杂查询的可读性。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;实时代码补全，并根据您输入的内容提供特定于语言的命令和函数的建议&lt;/strong&gt;。这包括根据您选择的日志组发现的字段。&lt;/li&gt;&#xA;&lt;li&gt;日志备忘单中的&lt;strong&gt;示例查询&lt;/strong&gt;包含许多示例查询，您只需选择将其粘贴到查询字段中即可。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1999px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/grafana-11.4/aws-cloudwatch-plugin-grafana-opensearch-ppl-opensearch-sql.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/grafana-11.4/aws-cloudwatch-plugin-grafana-opensearch-ppl-opensearch-sql.png&#34;data-srcset=&#34;/media/blog/grafana-11.4/aws-cloudwatch-插件-grafana-opensearch-ppl-opensearch-sql.png?w=320 320w, /media/blog/grafana-11.4/aws-cloudwatch-plugin-grafana-opensearch-ppl-opensearch-sql.png?w=550 550w，/media/blog/grafana-11.4/aws-cloudwatch-plugin-grafana-opensearch -ppl-opensearch-sql.png?w=750 750w, /media/blog/grafana-11.4/aws-cloudwatch-plugin-grafana-opensearch-ppl-opensearch-sql.png?w=900 900w，/media/blog/grafana-11.4/aws-cLoudwatch-plugin-grafana-opensearch-ppl-opensearch-sql.png?w=1040 1040w，/media/blog/grafana-11.4/aws-cloudwatch-plugin-grafana-opensearch-ppl-opensearch-sql.png?w= 1240 1240瓦， /media/blog/grafana-11.4/aws-cloudwatch-plugin-grafana-opensearch-ppl-opensearch-sql.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Grafana 中 AWS CloudWatch 插件的屏幕截图&#34;width=&#34;1999&#34;height=&#34;1071&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/media/blog/grafana-11.4/aws-cloudwatch-plugin-grafana-opensearch-ppl-opensearch-sql.png&#34;&#xA;alt=&#34;Grafana 中 AWS CloudWatch 插件的屏幕截图&#34;width=&#34;1999&#34;height=&#34;1071&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;有关 OpenSearch PPL 和 OpenSearch SQL 支持的命令的完整列表，请参阅 &lt;a href=&#34;https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_AnalyzeLogData_Languages.html&#34; target=&#34; _blank&#34; rel=&#34;noopener noreferrer&#34;&gt;AWS CloudWatch Logs Insights 文档&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;learn-more-about-grafana&#34;&gt;了解有关 Grafana 的更多信息&lt;/h2&gt;&#xA;&lt;p&gt;有关 Grafana 所有新功能的详细列表，请查看我们的 &lt;a href=&#34;/docs/grafana/latest/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana 文档&lt;/a&gt;， Grafana &lt;a href=&#34;https://github.com/grafana/grafana/blob/main/CHANGELOG.md&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;变更日志&lt;/a&gt;，或我们的&lt;a href=&#34;/docs/grafana/latest/whatsnew/whats-new-in-v11-4/?pg=blog&amp;plcmt=body-txt&#34;&gt;新增功能文档&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;join-the-grafana-labs-community&#34;&gt;加入 Grafana Labs 社区&lt;/h2&gt;&#xA;&lt;p&gt;我们邀请您参与 &lt;a href=&#34;https://community.grafana.com/?pg=blog&amp;plcmt=body-txt&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Grafana Labs 社区论坛&lt;/a&gt;。分享您使用新功能的体验，讨论最佳实践，并探索将这些更新集成到您的工作流程中的创造性方法。您的见解和用例对于丰富 Grafana 生态系统非常宝贵。&lt;/p&gt;&#xA;&lt;h2 id=&#34;upgrade-to-grafana-114&#34;&gt;升级到 Grafana 11.4&lt;/h2&gt;&#xA;&lt;p&gt;立即下载 &lt;a href=&#34;/grafana/download/11.4.0&#34;&gt;Grafana 11.4&lt;/a&gt; 或通过注册 Grafana Cloud 体验所有最新功能，Grafana Cloud 提供真正有用的永久免费套餐和计划对于每个用例。立即注册&lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;plcmt=body-txt&#34;&gt;免费 Grafana Cloud&lt;/a&gt; 帐户。&lt;/p&gt;&#xA;&lt;p&gt;我们的 &lt;a href=&#34;/docs/grafana/latest/upgrade-guide/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana 升级指南&lt;/a&gt;还为希望升级的用户提供分步说明从早期版本开始，以确保平稳过渡。&lt;/p&gt;&#xA;&lt;h2 id=&#34;a-special-thanks-to-our-community&#34;&gt;特别感谢我们的社区&lt;/h2&gt;&#xA;&lt;p&gt;我们向 &lt;a href=&#34;/blog/2023/12/12/the-story-of-grafana-documentary-the-community-behind-the-code/&#34;&gt;Grafana 社区表示衷心的感谢&lt;/一个&gt;!&lt;/p&gt;&#xA;&lt;p&gt;您的贡献（从拉取请求到有价值的反馈）对于持续增强 Grafana 至关重要。您的热情和奉献精神激励我们 Grafana Labs 不断创新并提升 Grafana 平台。&lt;/p&gt;&#xA;&lt;p&gt;我们”我很想听听您对可观察性状态的想法。单击下面的按钮立即参加我们的年度可观察性调查！&lt;/p&gt;&#xA;&lt;图&#xA;类=“图形包装器w-100p”&#xA;样式=“最大宽度：567px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;https://grafana.com/observability-survey/?pg=blog&amp;plcmt=body-txt&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/survey-promo/take-the-survey.png&#34;data-srcset=&#34;/media/blog/survey-promo/take-the-survey.png?w=320 320w, /媒体/博客/survey-promo/take-the-survey.png?w=550 550w, /media/blog/survey-promo/take-the-survey.png?w=750 750w, /media/blog/survey-promo/take-the-survey.png?w=900 900w, /media/blog/survey -promo/take-the-survey.png?w=1040 1040w, /media/blog/survey-promo/take-the-survey.png?w=1240 1240w, /media/blog/survey-promo/take-the-survey.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;号召采取可观测性调查&#34;width=&#34;567&#34;height=&#34;71&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/survey-promo/take-the-survey.png”&#xA;alt=&#34;号召采取可观测性调查&#34;width=&#34;567&#34;height=&#34;71&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt; 是开始使用指标、日志、跟踪、仪表板等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。 &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;plcmt=body-txt&#34;&gt;立即免费注册&lt;/a&gt;！&lt;/p&gt;</description>
      <pubDate>Thu, 05 Dec 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Grafana Loki 3.3 release: faster query results via Blooms for structured metadata】Grafana Loki 3.3 版本：通过 Blooms 获取结构化元数据更快的查询结果</title>
      <link>https://grafana.com/blog/2024/11/21/grafana-loki-3.3-release-faster-query-results-via-blooms-for-structured-metadata/</link>
      <description>【&lt;p&gt;The &lt;a href=&#34;https://github.com/grafana/loki/releases/tag/v3.3.0&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Grafana Loki 3.3&lt;/a&gt; release is here, and it brings a fresh wave of enhancements aimed at making your log management experience faster, more efficient, and more scalable.&lt;/p&gt;&#xA;&lt;p&gt;While this update includes the usual round of bug fixes and operational improvements, the standout feature is a shift in how Loki leverages Bloom filters—going from free-text search to harnessing the power of structured metadata. This will make it easier to find a specific needle in your haystack of logs, while improving the query experience for our OpenTelemetry community as well.&lt;/p&gt;&#xA;&lt;p&gt;Query acceleration via Bloom filters is considered experimental for our Loki and Grafana Enterprise Logs (GEL) 3.3 releases, and is available in public preview for large &lt;a href=&#34;/products/cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt; customers.&lt;/p&gt;&#xA;&lt;p&gt;Let’s dive into what this means for your workflows and how it sets the stage for Loki’s exciting future.&lt;/p&gt;&#xA;&lt;h2 id=&#34;query-acceleration-via-bloom-filters&#34;&gt;Query acceleration via Bloom filters&lt;/h2&gt;&#xA;&lt;p&gt;With &lt;a href=&#34;/blog/2024/04/09/grafana-loki-3.0-release-all-the-new-features/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Loki 3.0&lt;/a&gt;, we announced Bloom filters, a very promising, experimental feature intended to speed up needle in a haystack queries. Since then, we&amp;rsquo;ve received great insights from early adopters and learned a lot about running Blooms at a large scale—and the tradeoffs our users were willing to make.&lt;/p&gt;&#xA;&lt;p&gt;With this in mind, and with the increasing adoption of OpenTelemetry, we adjusted our approach and decided to create Blooms leveraging &lt;a href=&#34;/docs/loki/latest/get-started/labels/structured-metadata/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;structured metadata&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h3 id=&#34;what-is-structured-metadata-in-loki&#34;&gt;What is structured metadata in Loki?&lt;/h3&gt;&#xA;&lt;p&gt;Structured metadata allows you to attach metadata labels to each of your log lines. It was first introduced in Loki 2.9 for high cardinality labels that couldn&amp;rsquo;t be indexed, and for when it was too difficult to extract commonly-accessed log content into labels at query time. Then, In Loki 3.0, we added &lt;a href=&#34;/blog/2024/04/09/grafana-loki-3.0-release-all-the-new-features/?pg=blog&amp;amp;plcmt=body-txt#native-opentelemetry-support&#34;&gt;native OpenTelemetry support&lt;/a&gt;, which leverages structured metadata to store all the attributes OTel sends with each log line.&lt;/p&gt;&#xA;&lt;p&gt;And now, this same structured metadata can also be used to accelerate queries.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If you are not using OTel, you can still attach structured metadata to your log lines with &lt;a href=&#34;/docs/alloy/latest/reference/components/loki/loki.process/?pg=blog&amp;amp;plcmt=body-txt#stagestructured_metadata-block&#34;&gt;Grafana Alloy&amp;rsquo;s Loki pipelines&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;a-refresher-on-bloom-filters-and-why-you-would-use-them&#34;&gt;A refresher on Bloom filters, and why you would use them&lt;/h3&gt;&#xA;&lt;p&gt;Loki leverages Bloom filters in order to tell it what data &lt;em&gt;not&lt;/em&gt; to search. In managing Loki, we’ve observed that many log searches touch lots of log lines but only need the results from a select few that meet a certain criteria.&lt;/p&gt;&#xA;&lt;p&gt;As an example, maybe you&amp;rsquo;re looking for all log lines that have a certain user ID because you need to debug why an ecommerce user is being logged out of their account when they add an item to their shopping cart. Or maybe you want to find all the log lines that match a certain device ID to help troubleshoot a payment device or game controller.&lt;/p&gt;&#xA;&lt;h3 id=&#34;how-we-are-using-blooms-to-accelerate-queries&#34;&gt;How we are using Blooms to accelerate queries&lt;/h3&gt;&#xA;&lt;p&gt;Just like the previous version of Blooms, we still build Blooms per series. This time, instead of n-grams computed out of the whole log content, Blooms now contain the key of each structured metadata field seen within the series, along with all the existing key-value pairs.&lt;/p&gt;&#xA;&lt;p&gt;Blooms built out of structured metadata are orders of magnitude smaller, thus faster to build, download, and query.&lt;/p&gt;&#xA;&lt;h2 id=&#34;how-to-use-query-acceleration&#34;&gt;How to use query acceleration&lt;/h2&gt;&#xA;&lt;p&gt;To take advantage of Blooms, your queries need to satisfy the following criteria:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Bloom blocks should be created and available in the Bloom gateways for the time interval of the query.&lt;/li&gt;&#xA;&lt;li&gt;Queries should invoke acceleration &lt;a href=&#34;/docs/loki/latest/query/query_accceleration/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;by using proper syntax&lt;/a&gt; to query structured metadata&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;For example, if you want to look for a specific trace ID, and the trace ID is available as structured metadata, the following expression should be accelerated if they are available:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;{env=&amp;#34;prod&amp;#34;} | traceID=&amp;#34;3f54c1d2ae0c&amp;#34; | json | line_format &amp;#34;{{.api_route}} time={{.req_time}}&amp;#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;In this query, the &lt;code&gt;{env=”prod”}&lt;/code&gt; stream selector will narrow down the search space to the matching series. Then, with &lt;code&gt;traceID=&amp;quot;3f54c1d2ae0c&amp;quot;&lt;/code&gt; we use Blooms to further narrow down the search space by discarding all the chunks from the matching series that we&amp;rsquo;re sure don&amp;rsquo;t contain this structured metadata key-value pair. Finally, we only apply the &lt;code&gt;json&lt;/code&gt; parser and the line formatting to the logs from the matching chunks. This significantly reduces the amount of data Loki needs to download, unpack, and process.&lt;/p&gt;&#xA;&lt;h2 id=&#34;how-to-upgrade&#34;&gt;How to upgrade&lt;/h2&gt;&#xA;&lt;p&gt;The new Bloom blocks have a new format that&amp;rsquo;s incompatible with the previous version of Blooms. As a result, any previously created blocks are now obsolete. We recommend you clean your Bloom blocks before upgrading to the new Loki version by deleting the &lt;em&gt;bloom&lt;/em&gt; path inside the object store (see &lt;a href=&#34;/docs/loki/latest/setup/upgrade/?pg=blog&amp;amp;plcmt=body-txt#330&#34;&gt;upgrade notes&lt;/a&gt;).&lt;/p&gt;&#xA;&lt;p&gt;In addition to building Blooms for structured metadata, we also made some others changes and improvements for Blooms:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;We removed the Bloom compactor in favor of the &lt;a href=&#34;/docs/loki/latest/operations/query-acceleration-blooms/?pg=blog&amp;amp;plcmt=body-txt#bloom-planner-and-builder&#34;&gt;Bloom planner and builder components&lt;/a&gt;, which are now configured in &lt;a href=&#34;/docs/loki/latest/setup/install/helm/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Helm&lt;/a&gt; and enabled in the &lt;a href=&#34;/docs/loki/latest/get-started/deployment-modes/?pg=blog&amp;amp;plcmt=body-txt#simple-scalable&#34;&gt;simple scale deployment&lt;/a&gt; backend target.&lt;/li&gt;&#xA;&lt;li&gt;We introduced a new build strategy that split tasks based on the TSDB stats for the chunks size of the series. The strategy is configurable via the &lt;code&gt;bloom_planning_strategy&lt;/code&gt; per-tenant limit. We haven’t changed the default planning strategy, which splits the series key-space by a configurable factor. But we encourage users to try the new strategy, which should result in more consistently sized Bloom building tasks.&lt;/li&gt;&#xA;&lt;li&gt;Another addition to the Bloom planner component is a disk-backed queue. By default, the queue keeps all tasks in memory, but you can enable the disk-backed queue if you have a large set of tenants or a memory-contrained environment.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;start-using-loki-33-today&#34;&gt;Start using Loki 3.3 today&lt;/h2&gt;&#xA;&lt;p&gt;Loki 3.3 ships a whole set of new experimental features, improvements and bug fixes that opens the door to make Loki more scalable, faster, and easy to use in the near future. If you are a GEL customer, the same functionality that’s in Loki 3.3 is also part of our GEL 3.3 release.&lt;/p&gt;&#xA;&lt;p&gt;Consult the Loki and GEL release notes and changelog for more:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/docs/loki/latest/release-notes/v3-3/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Loki release notes&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/grafana/loki/blob/release-3.3.x/CHANGELOG.md&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Loki changelog&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/docs/enterprise-logs/latest/release-notes/v3-3/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;GEL release notes&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/grafana/enterprise-logs/blob/main/cmd/enterprise-logs/CHANGELOG.md&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;GEL changelog&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;And if you are new to Loki, please consult our &lt;a href=&#34;/docs/loki/latest/get-started/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Getting Started&lt;/a&gt; section to get up and running as quickly as possible. In the meantime, give the new features a spin, explore the benefits of structured metadata Blooms, and let us know your feedback. Your insights help us make Loki better with every release.&lt;/p&gt;&#xA;&lt;p&gt;Happy logging!&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud &lt;/a&gt;is the easiest way to get started with metrics, logs, traces, dashboards, and more. We have a generous forever-free tier and plans for every use case. &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Sign up for free now!&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;】&lt;p&gt;&lt;a href=&#34;https://github.com/grafana/loki/releases/tag/v3.3.0&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Grafana Loki 3.3&lt;/a&gt; 版本为在这里，它带来了新一波的增强功能，旨在让您的日志管理体验更快、更高效、更具可扩展性。&lt;/p&gt;&#xA;&lt;p&gt;虽然此更新包括通常的错误修复和操作改进，但最突出的功能是 Loki 利用 Bloom 过滤器的方式的转变 - 从自由文本搜索到利用结构化元数据的力量。这将使您更轻松地在日志大海捞针中找到特定的目标，同时也改善了我们 OpenTelemetry 社区的查询体验。&lt;/p&gt;&#xA;&lt;p&gt;通过 Bloom 过滤器进行查询加速对于我们的 Loki 和 Grafana Enterprise Logs (GEL) 3.3 版本被认为是实验性的，并且在大型 &lt;a href=&#34;/products/cloud/?pg=blog&amp;plcmt=body-txt 中提供公共预览版&#34;&gt;Grafana Cloud&lt;/a&gt; 客户。&lt;/p&gt;&#xA;&lt;p&gt;让我们深入了解这对您的工作流程意味着什么，以及它如何为 Loki 令人兴奋的未来奠定基础。&lt;/p&gt;&#xA;&lt;h2 id=&#34;query-acceleration-via-bloom-filters&#34;&gt;通过 Bloom 过滤器进行查询加速&lt;/h2&gt;&#xA;&lt;p&gt;与&lt;a href=&#34;/blog/2024/04/09/grafana-loki-3.0-release-all-the-new-features/?pg=blog&amp;plcmt=body-txt&#34;&gt;Loki 3.0&lt;/a&gt; ，我们发布了布隆过滤器，这是一个非常有前途的实验性功能，旨在加速大海捞针查询。从那时起，我们从早期采用者那里获得了深刻的见解，并了解了很多有关大规模运行 Bloom 的知识，以及我们的用户愿意做出的权衡。&lt;/p&gt;&#xA;&lt;p&gt;考虑到这一点，并且随着 OpenTelemetry 的日益普及，我们调整了我们的方法，并决定利用 &lt;a href=&#34;/docs/loki/latest/get-started/labels/structed-metadata/?pg 创建 Blooms =blog&amp;plcmt=body-txt&#34;&gt;结构化元数据&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;what-is-structed-metadata-in-loki&#34;&gt;Loki 中的结构化元数据是什么？&lt;/h3&gt;&#xA;&lt;p&gt;结构化元数据允许您将元数据标签附加到每个日志行。它首次在 Loki 2.9 中引入，用于无法索引的高基数标签，以及在查询时将常用访问的日志内容提取到标签中太困难的情况。然后，在 Loki 3.0 中，我们添加了 &lt;a href=&#34;/blog/2024/04/09/grafana-loki-3.0-release-all-the-new-features/?pg=blog&amp;plcmt=body-txt#native-opentelemetry -support&#34;&gt;原生 OpenTelemetry 支持&lt;/a&gt;，它利用结构化元数据来存储 OTel 随每个日志行发送的所有属性。&lt;/p&gt;&#xA;&lt;p&gt;现在，同样的结构化元数据也可用于加速查询。&lt;/p&gt;&#xA;&lt;块引用&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;如果您不使用 OTel，您仍然可以使用 &lt;a href=&#34;/docs/alloy/latest/reference/components/loki/loki.txt 将结构化元数据附加到日志行中。 process/?pg=blog&amp;plcmt=body-txt#stagestructed_metadata-block&#34;&gt;Grafana Alloy 的 Loki 管道&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;/块引用&gt;&#xA;&lt;h3 id=&#34;a-refresher-on-bloom-filters-and-why-you-would-use-them&#34;&gt;回顾一下 Bloom 过滤器，以及为什么要使用会使用它们&lt;/h3&gt;&#xA;&lt;p&gt;Loki 利用布隆过滤器来告诉它哪些数据&lt;em&gt;不&lt;/em&gt;要搜索。在管理 Loki 时，我们观察到许多日志搜索涉及大量日志行，但只需要满足特定条件的少数几个日志行的结果。&lt;/p&gt;&#xA;&lt;p&gt;举个例子，也许您正在查找具有特定用户 ID 的所有日志行，因为您需要调试为什么电子商务用户在将商品添加到购物车时会从其帐户中注销。或者您可能想要查找与特定设备 ID 匹配的所有日志行，以帮助对支付设备或游戏控制器进行故障排除。&lt;/p&gt;&#xA;&lt;h3 id=&#34;how-we-are-using-blooms-to-accelerate-queries&#34;&gt;我们如何使用 Bloom 来加速查询&lt;/h3&gt;&#xA;&lt;p&gt;就像之前版本的 Blooms 一样，我们仍然按系列构建 Blooms。这次，Bloom 现在包含该系列中看到的每个结构化元数据字段的键以及所有现有的键值对，而不是根据整个日志内容计算出的 n 元语法。&lt;/p&gt;&#xA;&lt;p&gt;基于结构化元数据构建的 Bloom 的数量级要小，因此构建、下载和查询速度更快。&lt;/p&gt;&#xA;&lt;h2 id=&#34;how-to-use-query-acceleration&#34;&gt;如何使用查询加速&lt;/h2&gt;&#xA;&lt;p&gt;要利用 Bloom，您的查询需要满足以下条件：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;应在查询的时间间隔内在 Bloom 网关中创建并可用 Bloom 块。&lt;/li&gt;&#xA;&lt;li&gt;查询应&lt;a href=&#34;/docs/loki/latest/query/query_accceleration/?pg=blog&amp;plcmt=body-txt&#34;&gt;使用正确的语法&lt;/a&gt;调用加速来查询结构化元数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;例如，如果您想要查找特定的跟踪 ID，并且该跟踪 ID 可作为结构化元数据使用，则应加速以下表达式（如果可用）：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;{env=&#34;prod&#34;} |跟踪ID =“3f54c1d2ae0c”| json | line_format &#34;{{.api_route}} time={{.req_time}}&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;在此查询中，&lt;code&gt;{env=”prod”}&lt;/code&gt; 流选择器会将搜索空间缩小到匹配的系列。然后，通过 &lt;code&gt;traceID=&#34;3f54c1d2ae0c&#34;&lt;/code&gt;，我们使用 Blooms 丢弃匹配系列中我们确定不包含此结构化元数据键值对的所有块，进一步缩小搜索空间。最后，我们仅将 &lt;code&gt;json&lt;/code&gt; 解析器和行格式应用于匹配块中的日志。这显着减少了 Loki 需要下载、解压和处理的数据量。&lt;/p&gt;&#xA;&lt;h2 id=&#34;如何升级&#34;&gt;如何升级&lt;/h2&gt;&#xA;&lt;p&gt;新的 Bloom 块具有与之前版本的 Bloom 不兼容的新格式。因此，任何以前创建的块现在都已过时。我们建议您在升级到新的 Loki 版本之前，通过删除对象存储中的 &lt;em&gt;bloom&lt;/em&gt; 路径来清理 Bloom 块（请参阅 &lt;a href=&#34;/docs/loki/latest/setup/upgrade/?pg =blog&amp;plcmt=body-txt#330&#34;&gt;升级说明&lt;/a&gt;）。&lt;/p&gt;&#xA;&lt;p&gt;除了为结构化元数据构建 Bloom 之外，我们还对 Bloom 进行了一些其他更改和改进：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;我们删除了 Bloom 压缩器，转而采用&lt;a href=&#34;/docs/loki/latest/operations/query-acceleration-blooms/?pg=blog&amp;plcmt=body-txt#bloom-planner-and-builder&#34;&gt; Bloom 规划器和构建器组件&lt;/a&gt;，现在在 &lt;a 中配置href=&#34;/docs/loki/latest/setup/install/helm/?pg=blog&amp;plcmt=body-txt&#34;&gt;Helm&lt;/a&gt; 并在 &lt;a href=&#34;/docs/loki/latest/get-started 中启用/deployment-modes/?pg=blog&amp;plcmt=body-txt#simple-scalable&#34;&gt;简单规模部署&lt;/a&gt;后端目标。&lt;/li&gt;&#xA;&lt;li&gt;我们引入了一种新的构建策略，该策略根据系列块大小的 TSDB 统计数据来拆分任务。该策略可通过 &lt;code&gt;bloom_planning_strategy&lt;/code&gt; 每租户限制进行配置。我们没有更改默认的规划策略，该策略通过可配置的因子分割系列键空间。但我们鼓励用户尝试新策略，这应该会导致 Bloom 构建任务的大小更加一致。&lt;/li&gt;&#xA;&lt;li&gt;Bloom planner 组件的另一个附加功能是磁盘支持的队列。默认情况下，队列将所有任务保留在内存中，但如果您有大量租户或内存受限的环境，则可以启用磁盘支持的队列。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;start-using-loki-33-today&#34;&gt;立即开始使用 Loki 3.3&lt;/h2&gt;&#xA;&lt;p&gt;Loki 3.3 提供了一整套新的实验性功能、改进和错误修复，为在不久的将来使 Loki 更具可扩展性、更快且易于使用打开了大门。如果您是 GEL 客户，Loki 3.3 中的相同功能也是我们的 GEL 3.3 版本的一部分。&lt;/p&gt;&#xA;&lt;p&gt;请参阅 Loki 和 GEL 发行说明和变更日志以了解更多信息：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/docs/loki/latest/release-notes/v3-3/?pg=blog&amp;plcmt=body-txt&#34;&gt;Loki 发行说明&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/grafana/loki/blob/release-3.3.x/CHANGELOG.md&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Loki 变更日志&lt;/a&gt; &lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/docs/enterprise-logs/latest/release-notes/v3-3/?pg=blog&amp;plcmt=body-txt&#34;&gt;GEL 发行说明&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/grafana/enterprise-logs/blob/main/cmd/enterprise-logs/CHANGELOG.md&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;GEL 变更日志&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如果您是 Loki 新手，请查阅我们的&lt;a href=&#34;/docs/loki/latest/get-started/?pg=blog&amp;plcmt=body-txt&#34;&gt;入门&lt;/a&gt;部分以开始使用并尽可能快地跑。与此同时，尝试一下新功能，探索结构化元数据的好处Blooms，请让我们知道您的反馈。您的见解帮助我们在每个版本中让 Loki 变得更好。&lt;/p&gt;&#xA;&lt;p&gt;祝您登录愉快！&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt;是开始使用指标、日志、跟踪、仪表板等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。 &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;plcmt=body-txt&#34;&gt;立即免费注册！&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</description>
      <pubDate>Thu, 21 Nov 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Leveraging OpenTelemetry and Grafana for observing, visualizing, and monitoring Kubernetes applications】利用 OpenTelemetry 和 Grafana 观察、可视化和监控 Kubernetes 应用程序</title>
      <link>https://grafana.com/blog/2024/11/22/leveraging-opentelemetry-and-grafana-for-observing-visualizing-and-monitoring-kubernetes-applications/</link>
      <description>【&lt;p&gt;&lt;em&gt;Ken has over 15 years of industry experience as a noted information and cybersecurity practitioner, software developer, author, and presenter, focusing on endpoint security, big security data analytics, and Federal Information Security Management Act (FISMA) and NIST 800-53 compliance. Focusing on strict federal standards, Ken has consulted with numerous federal organizations, including Defense Information Systems Agency (DISA), Department of Veterans Affairs, and the Census Bureau.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;Enterprises today can gain a competitive advantage by enabling developers to rapidly compose new application capabilities by utilizing existing microservices and Kubernetes.&lt;/p&gt;&#xA;&lt;p&gt;For example, by leveraging a library of reusable microservices, a financial institution can quickly develop and deploy new features, such as real-time fraud detection or personalized customer insights, without having to build these capabilities from scratch. This modular approach not only accelerates development cycles, but also ensures greater flexibility and scalability.&lt;/p&gt;&#xA;&lt;p&gt;Additionally, when a retail company integrates microservices for inventory management, payment processing, and customer notifications, it can swiftly adapt to market changes and seasonal demands, enhancing its responsiveness and customer satisfaction. This ability to innovate rapidly and efficiently through microservice composition is transforming how businesses compete and succeed in the digital age.&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-dark-side-of-composable-applications&#34;&gt;The dark side of composable applications&lt;/h2&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 2952px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/otel-report-ema/telemetry-stacks.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/otel-report-ema/telemetry-stacks.png&#34;data-srcset=&#34;/media/blog/otel-report-ema/telemetry-stacks.png?w=320 320w, /media/blog/otel-report-ema/telemetry-stacks.png?w=550 550w, /media/blog/otel-report-ema/telemetry-stacks.png?w=750 750w, /media/blog/otel-report-ema/telemetry-stacks.png?w=900 900w, /media/blog/otel-report-ema/telemetry-stacks.png?w=1040 1040w, /media/blog/otel-report-ema/telemetry-stacks.png?w=1240 1240w, /media/blog/otel-report-ema/telemetry-stacks.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;&#34;width=&#34;2952&#34;height=&#34;1580&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/otel-report-ema/telemetry-stacks.png&#34;&#xA;alt=&#34;&#34;width=&#34;2952&#34;height=&#34;1580&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;While the composable nature of microservices apps offers significant advantages in terms of agility and modularity, it also introduces considerable complexity in managing disconnected telemetry data. As organizations deploy numerous microservices, each with its own independent technology stack and CI/CD pipelines, they encounter a deluge of heterogeneous telemetry data.&lt;/p&gt;&#xA;&lt;p&gt;Application telemetry, storage telemetry, and cloud and virtualization telemetry—along with inputs from user interactions, IoT devices, message queues, databases, and various system and network telemetry sources—create a fragmented observability landscape. This fragmentation can drown organizations in data silos, making it difficult to achieve a unified view of system performance and health.&lt;/p&gt;&#xA;&lt;p&gt;The lack of integration between these disparate telemetry sources can lead to blind spots, inefficient troubleshooting, and increased operational overhead as teams struggle to correlate data across different services and infrastructure components. Consequently, the significant challenges in managing and making sense of the distributed telemetry data can undermine the promised benefits of microservices.&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-importance-of-opentelemetry&#34;&gt;The importance of OpenTelemetry&lt;/h2&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1476px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png&#34;data-srcset=&#34;/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=320 320w, /media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=550 550w, /media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=750 750w, /media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=900 900w, /media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=1040 1040w, /media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=1240 1240w, /media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;&#34;width=&#34;1476&#34;height=&#34;1548&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png&#34;&#xA;alt=&#34;&#34;width=&#34;1476&#34;height=&#34;1548&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;Organizations need unified observability that spans their entire technology stack. One way to achieve this is to standardize on a single observability tool, but that can create a significant vendor lock-in issue, complicating future tool changes. &lt;a href=&#34;/opentelemetry-report/&#34;&gt;OpenTelemetry&lt;/a&gt; offers a standardized, vendor-neutral method for instrumenting applications and their infrastructure components to generate consistent, contextual, and application-centric telemetry data. This eliminates the vendor lock-in problem, enabling organizations to significantly reduce migration costs if they decide to switch tools in the future.&lt;/p&gt;&#xA;&lt;p&gt;Of course, standardizing on a single tool sounds good in theory. But in practice, organizations often use a variety of additional observability tools and platforms, such as Prometheus, Jaeger, Zabbix, Fluentd, Elasticsearch, Nagios, OpenSearch, Zipkin, Skywalking, and Logstash. This diversity can lead to data silos and inconsistent telemetry data pipelines, which are often managed by different teams within the organization.&lt;/p&gt;&#xA;&lt;p&gt;Absorbing these silos into OpenTelemetry is generally possible and highly beneficial. With its vendor-neutral standard and support for a wide range of languages, OpenTelemetry can streamline telemetry data collection, improve data consistency, and enhance the overall observability strategy.&lt;/p&gt;&#xA;&lt;p&gt;Nevertheless, most organizations face significant challenges in doing so. The primary obstacles include the lack of necessary skills and resources to integrate these disparate systems quickly and reliably, as well as the high costs associated with such an undertaking.&lt;/p&gt;&#xA;&lt;p&gt;To address these challenges, organizations need to invest in training their teams in OpenTelemetry and related technologies. Additionally, adopting a phased approach to integration can help manage costs and minimize disruptions. Leveraging professional services or consulting firms with expertise in OpenTelemetry can also expedite the process and ensure a smoother transition.&lt;/p&gt;&#xA;&lt;h2 id=&#34;accelerate-opentelemetry-implementation-through-loki-mimir-tempo-beyla-pyroscope-and-alloy&#34;&gt;Accelerate OpenTelemetry implementation through Loki, Mimir, Tempo, Beyla, Pyroscope, and Alloy&lt;/h2&gt;&#xA;&lt;p&gt;Grafana&amp;rsquo;s suite of open source observability tools—Loki, Pyroscope, Mimir, Tempo, Alloy, and Beyla—complements OpenTelemetry (OTel) by providing a seamless integration that simplifies and enhances the adoption of standardized telemetry data.&lt;/p&gt;&#xA;&lt;p&gt;OpenTelemetry offers a framework for generating consistent, contextualized telemetry data across the various components of an organization&amp;rsquo;s technology stack. However, the challenge lies in effectively collecting, storing, and visualizing this data. Grafana’s tools address these challenges head-on, ensuring that organizations can fully leverage OpenTelemetry without the associated complexities and costs.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/oss/loki/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Loki&lt;/a&gt;, for instance, complements OpenTelemetry by providing a scalable and efficient log aggregation system that can ingest and query logs that OTel-instrumented applications generate.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/oss/mimir/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Mimir&lt;/a&gt; enhances this by handling the vast volumes of metrics data, ensuring they are efficiently stored and readily available for analysis.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/oss/tempo/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Tempo&lt;/a&gt;, with its distributed tracing capabilities integrate seamlessly with OpenTelemetry traces, allowing for a unified view of request flows across microservices.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/oss/pyroscope/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Pyroscope&lt;/a&gt; adds continuous profiling, giving detailed performance insights that are contextualized with OTel’s telemetry data.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/oss/beyla-ebpf/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Beyla&lt;/a&gt; provides eBPF-based auto-instrumentation to ensure that all telemetry data—logs, metrics, traces, or profiles—can be visualized and acted upon in real time within Grafana’s unified dashboards.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;While OTel has surged in popularity, especially after its &lt;a href=&#34;https://www.cncf.io/blog/2023/11/07/opentelemetry-at-kubecon-cloudnativecon-north-america-2023-update/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;GA announcement at KubeCon&lt;/a&gt; last year, Prometheus remains the leader in core infrastructure monitoring with over 10,000 integrations. Grafana’s newest OSS project, &lt;a href=&#34;/oss/alloy-opentelemetry-collector/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Alloy&lt;/a&gt;, is the successor to Grafana Agent, integrating its observability codebase and lessons from challenging use cases to create an efficient OTel Collector distribution that also handles Prometheus-compatible metrics. Alloy supports advanced use cases with features like GitOps-friendly configuration, native clustering, secure Vault integration, and embedded debugging utilities.&lt;/p&gt;&#xA;&lt;p&gt;Together, these tools transform OpenTelemetry’s rich telemetry data into actionable insights, providing a cohesive and comprehensive observability strategy. Organizations can benefit from OpenTelemetry’s standardized data collection while leveraging Grafana’s powerful analytics and visualization capabilities, resulting in a more efficient, reliable, and cost-effective observability solution. This synergy ensures that teams can easily correlate and analyze diverse telemetry data, leading to enhanced operational efficiency and improved system performance.&lt;/p&gt;&#xA;&lt;h2 id=&#34;one-dashboard-to-rule-them-all&#34;&gt;One dashboard to rule them all&lt;/h2&gt;&#xA;&lt;p&gt;Grafana&amp;rsquo;s integration with OpenTelemetry truly brings to life the concept of a single, unified dashboard for comprehensive observability. By combining the power of OpenTelemetry’s standardized telemetry data and semantic conventions with Grafana’s robust suite of tools—Loki, Pyroscope, Mimir, Tempo, Beyla, and Alloy—organizations can achieve unparalleled visibility into their systems. This unified approach eliminates the data silos and inconsistencies that typically plague observability efforts, enabling teams to quickly and efficiently correlate logs, metrics, traces, and profiles.&lt;/p&gt;&#xA;&lt;p&gt;With Grafana’s intuitive interface and powerful visualization capabilities, all relevant telemetry data is accessible in one place, simplifying analysis and accelerating troubleshooting. This one dashboard to rule them all not only reduces the complexity and cost associated with adopting OpenTelemetry, but also empowers organizations to proactively manage and optimize their IT infrastructure. The result is a more resilient, efficient, and high-performing technology stack that provides a significant competitive advantage in today’s fast-paced digital landscape.&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;To learn more about OpenTelemetry, check out the complete &lt;a href=&#34;/opentelemetry-report/&#34;&gt;OpenTelemetry: Challenges, priorities, adoption patterns, and solutions report&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;】&lt;p&gt;&lt;em&gt;Ken 作为著名的信息和网络安全从业者、软件开发人员、作者和演讲者，拥有超过 15 年的行业经验，专注于端点安全、大安全数据分析以及联邦信息安全管理法案 (FISMA) 和NIST 800-53 合规性。 Ken 专注于严格的联邦标准，咨询了众多联邦组织，包括国防信息系统局 (DISA)、退伍军人事务部和人口普查局。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;当今的企业可以通过使开发人员能够利用现有的微服务和 Kubernetes 快速构建新的应用程序功能来获得竞争优势。&lt;/p&gt;&#xA;&lt;p&gt;例如，通过利用可重用微服务库，金融机构可以快速开发和部署新功能，例如实时欺诈检测或个性化客户洞察，而无需从头开始构建这些功能。这种模块化方法不仅加快了开发周期，还确保了更大的灵活性和可扩展性。&lt;/p&gt;&#xA;&lt;p&gt;此外，当零售公司集成用于库存管理、付款处理和客户通知的微服务时，它可以快速适应市场变化和季节性需求，从而提高响应速度和客户满意度。这种通过微服务组合快速高效地创新的能力正在改变企业在数字时代竞争和取得成功的方式。&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-dark-side-of-composable-applications&#34;&gt;可组合应用程序的阴暗面&lt;/h2&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：2952px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/otel-report-ema/telemetry-stacks.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/otel-report-ema/telemetry-stacks.png”data-srcset =“/media/blog/otel-report-ema/telemetry-stacks.png？w = 320 320w，/媒体/博客/otel-report-ema/telemetry-stacks.png?w=550 550w, /media/blog/otel-report-ema/telemetry-stacks.png?w=750 750w, /media/blog/otel-report-ema/telemetry-stacks.png?w=900 900w, /media/blog/otel -report-ema/telemetry-stacks.png?w=1040 1040w, /media/blog/otel-report-ema/telemetry-stacks.png?w=1240 1240w，/media/blog/otel-report-ema/telemetry-stacks.png?w=1920 1920w&#34;&#xA;数据大小=“自动”alt =“”宽度=“2952”高度=“1580”/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/otel-report-ema/telemetry-stacks.png”&#xA;alt=“”宽度=“2952”高度=“1580”/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;虽然微服务应用程序的可组合性在敏捷性和模块化方面提供了显着的优势，但它在管理断开连接的遥测数据方面也带来了相当大的复杂性。当组织部署大量微服务（每个微服务都有自己独立的技术堆栈和 CI/CD 管道）时，他们会遇到大量异构遥测数据。&lt;/p&gt;&#xA;&lt;p&gt;应用遥测、存储遥测以及云和虚拟化遥测，以及来自用户交互、物联网设备、消息队列、数据库以及各种系统和网络遥测源的输入，创建了一个碎片化的可观察性环境。这种碎片化会使组织陷入数据孤岛，从而难以实现系统性能和运行状况的统一视图。&lt;/p&gt;&#xA;&lt;p&gt;当团队努力关联不同服务和基础设施组件之间的数据时，这些不同的遥测源之间缺乏集成可能会导致盲点、故障排除效率低下以及运营开销增加。因此，管理和理解分布式遥测数据所面临的重大挑战可能会破坏微服务所承诺的优势。&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-importance-of-opentelemetry&#34;&gt;OpenTelemetry 的重要性&lt;/h2&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1476px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png&#34;data-srcset=&#34;/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png png?w=320 320w，/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=550 550w，/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=750 750w，/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w =900 900w， /media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=1040 1040w, /media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=1240 1240瓦， /media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=1920 1920w&#34;&#xA;数据大小=“自动” alt =“”宽度=“1476”高度=“1548”/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png”&#xA;alt=“”宽度=“1476”高度=“1548”/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;组织需要跨越整个技术堆栈的统一可观察性。实现这一目标的一种方法是对单一可观察性工具进行标准化，但这可能会造成严重的供应商锁定问题，使未来的工具变更变得复杂。 &lt;a href=&#34;/opentelemetry-report/&#34;&gt;OpenTelemetry&lt;/a&gt; 提供了一种标准化的、供应商中立的方法，用于检测应用程序及其基础设施组件，以生成一致的、上下文相关的、以应用程序为中心的遥测数据。这消除了供应商锁定问题，使组织能够在决定将来更换工具时显着降低迁移成本。&lt;/p&gt;&#xA;&lt;p&gt;当然，从理论上讲，对单一工具进行标准化听起来不错。但在实践中，组织经常使用各种额外的可观察性工具和平台，例如 Prometheus、Jaeger、Zabbix、Fluentd、Elasticsearch、Nagios、OpenSearch、Zipkin、Skywalking 和 Logstash。这种多样性可能会导致数据孤岛和不一致的遥测数据管道，而这些数据管道通常由组织内的不同团队管理。&lt;/p&gt;&#xA;&lt;p&gt;将这些孤岛吸收到 OpenTelemetry 中通常是可能的并且非常有益。凭借其供应商中立的标准和对多种语言的支持，OpenTelemetry 可以简化遥测数据收集、提高数据一致性并增强整体可观测性策略。&lt;/p&gt;&#xA;&lt;p&gt;尽管如此，大多数组织在这样做时都面临着重大挑战。主要障碍包括缺乏必要的技能和资源来快速可靠地集成这些不同的系统，以及与此类任务相关的高成本。&lt;/p&gt;&#xA;&lt;p&gt;为了应对这些挑战，组织需要投资对其团队进行 OpenTelemetry 和相关技术的培训。此外，采用分阶段的集成方法可以帮助管理成本并最大限度地减少中断。利用具有 OpenTelemetry 专业知识的专业服务或咨询公司也可以加快这一过程并确保更顺利的过渡。&lt;/p&gt;&#xA;&lt;h2 id=&#34;accelerate-opentelemetry-implementation-through-loki-mimir-tempo-beyla-pyrscope-and-alloy&#34;&gt;通过 Loki、Mimir、Tempo、Beyla、Pyrscope 和 Alloy 加速 OpenTelemetry 实施&lt;/h2&gt;&#xA;&lt;p&gt;Grafana 的开源可观测工具套件（Loki、Pyrscope、Mimir、Tempo、Alloy 和 Beyla）通过提供无缝集成来补充 OpenTelemetry (OTel)，从而简化和增强标准化遥测数据的采用。&lt;/p&gt;&#xA;&lt;p&gt;OpenTelemetry 提供了一个框架，用于跨组织技术堆栈的各个组件生成一致的、上下文化的遥测数据。然而，挑战在于如何有效地收集、存储和可视化这些数据。 Grafana 的工具正面解决了这些挑战，确保组织可以充分利用 OpenTelemetry，而无需承担相关的复杂性和成本。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;例如，&lt;li&gt;&lt;a href=&#34;/oss/loki/?pg=blog&amp;plcmt=body-txt&#34;&gt;Loki&lt;/a&gt; 通过提供可扩展且高效的日志聚合系统来补充 OpenTelemetry，该系统可以提取和查询以下日志：生成 OTel 检测的应用程序。&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/oss/mimir/?pg=blog&amp;plcmt=body-txt&#34;&gt;Mimir&lt;/a&gt; 通过处理大量指标数据来增强这一功能，确保它们得到有效存储并随时可供分析。 &lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/oss/tempo/?pg=blog&amp;plcmt=body-txt&#34;&gt;Tempo&lt;/a&gt; 其分布式跟踪功能与 OpenTelemetry 跟踪无缝集成，可提供跨微服务的请求流的统一视图.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/oss/pyrscope/?pg=blog&amp;plcmt=body-txt&#34;&gt;Pyrscope&lt;/a&gt; 添加了持续分析功能，提供与 OTel 遥测数据相关的详细性能洞察。&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/oss/beyla-ebpf/?pg=blog&amp;plcmt=body-txt&#34;&gt;Beyla&lt;/a&gt;提供基于eBPF的自动仪器确保所有遥测数据（日志、指标、跟踪或配置文件）都可以在 Grafana 的统一仪表板中实时可视化并采取行动。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;虽然 OTel 的受欢迎程度激增，尤其是在 &lt;a href=&#34;https://www.cncf.io/blog/2023/11/07/opentelemetry-at-kubecon-cloudnativecon-north-america-2023- update/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;去年 KubeCon&lt;/a&gt; 上发布的 GA 公告显示，Prometheus 仍然是核心基础设施监控领域的领导者，拥有超过10,000 次集成。 Grafana 最新的 OSS 项目 &lt;a href=&#34;/oss/alloy-opentelemetry-collector/?pg=blog&amp;plcmt=body-txt&#34;&gt;Alloy&lt;/a&gt; 是 Grafana Agent 的继承者，集成了其可观测性代码库和挑战中的经验教训使用案例创建高效的 OTel Collector 发行版，该发行版还可以处理 Prometheus 兼容的指标。 Alloy 通过 GitOps 友好配置、本机集群、安全 Vault 集成和嵌入式调试实用程序等功能支持高级用例。&lt;/p&gt;&#xA;&lt;p&gt;这些工具共同将 OpenTelemetry 丰富的遥测数据转化为可操作的见解，提供了连贯且全面的可观测性策略。组织可以受益于 OpenTelemetry 的标准化数据收集，同时利用 Grafana 强大的分析和可视化功能，从而形成更高效、可靠且更具成本效益的可观测性解决方案。这种协同作用确保团队可以轻松关联和分析不同的遥测数据，从而提高运营效率和系统性能。&lt;/p&gt;&#xA;&lt;h2 id=&#34;one-dashboard-to-rule-them-all&#34;&gt;一个仪表板即可统治所有内容&lt;/h2&gt;&#xA;&lt;p&gt;Grafana 与 OpenTelemetry 的集成真正实现了单一、统一仪表板的概念，以实现全面的可观察性。通过将 OpenTelemetry 标准化遥测数据和语义约定的强大功能与 Grafana 强大的工具套件（Loki、Pyrscope、Mimir、Tempo、Beyla 和 Alloy）相结合，组织可以实现对其系统的无与伦比的可见性。这种统一的方法消除了通常困扰可观察性工作的数据孤岛和不一致性，使团队能够快速有效地关联日志、指标、跟踪和配置文件。&lt;/p&gt;&#xA;&lt;p&gt;借助 Grafana 直观的界面和强大的可视化功能，可以在一处访问所有相关遥测数据，从而简化分析并加速故障排除。这一控制所有这些的仪表板不仅降低了与采用 OpenTelemetry 相关的复杂性和成本，而且使组织能够主动管理和优化其 IT 基础设施。其结果是一个更具弹性、高效和高性能的技术堆栈，在当今快节奏的数字环境中提供了显着的竞争优势。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;要了解有关 OpenTelemetry 的更多信息，请查看完整的 &lt;a href=&#34;/opentelemetry-report/&#34;&gt;OpenTelemetry：挑战、优先事项、采用模式和解决方案报告&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;</description>
      <pubDate>Fri, 22 Nov 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【How to use OpenTelemetry and Grafana Alloy to convert delta to cumulative at scale】如何使用 OpenTelemetry 和 Grafana Alloy 将增量转换为大规模累积值</title>
      <link>https://grafana.com/blog/2024/11/25/how-to-use-opentelemetry-and-grafana-alloy-to-convert-delta-to-cumulative-at-scale/</link>
      <description>【&lt;p&gt;Migrating from other vendors becomes a lot easier with &lt;a href=&#34;/oss/opentelemetry?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;OpenTelemetry&lt;/a&gt; and&#xA;&lt;a href=&#34;/docs/alloy/latest/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Alloy&lt;/a&gt;, our distribution of the&#xA;OpenTelemetry Collector.&lt;/p&gt;&#xA;&lt;p&gt;But when you come from platforms that use different temporalities, such as&#xA;&lt;a href=&#34;/blog/2024/06/18/translate-datadog-metrics-into-otlp-with-the-opentelemetry-collector-and-grafana-alloy/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Datadog&lt;/a&gt;&#xA;or Dynatrace, you face a challenge integrating with a Prometheus-like ecosystem such as&#xA;Grafana Cloud: Your metrics still mean the same as before, but they just don&amp;rsquo;t&#xA;look right.&lt;/p&gt;&#xA;&lt;p&gt;That&amp;rsquo;s because delta samples, which are used in other some non-Prometheus-based&#xA;observability tools, report a relative change to a measurement, such as +3, -7,&#xA;etc.&lt;/p&gt;&#xA;&lt;p&gt;Conversely, cumulative sampling, which is used in Prometheus, represents the&#xA;exact same information, but it does so as an &amp;ldquo;absolute&amp;rdquo; value in relation to an&#xA;arbitrary aggregation period, giving samples like 10, 4.&lt;/p&gt;&#xA;&lt;p&gt;Consider the following example time series (or stream, in OTel language):&lt;/p&gt;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;th&gt;Time&lt;/th&gt;&#xA;&lt;th&gt;10&lt;/th&gt;&#xA;&lt;th&gt;20&lt;/th&gt;&#xA;&lt;th&gt;30&lt;/th&gt;&#xA;&lt;th&gt;40&lt;/th&gt;&#xA;&lt;th&gt;50&lt;/th&gt;&#xA;&lt;th&gt;60&lt;/th&gt;&#xA;&lt;th&gt;70&lt;/th&gt;&#xA;&lt;th&gt;80&lt;/th&gt;&#xA;&lt;th&gt;90&lt;/th&gt;&#xA;&lt;th&gt;100&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Cumulative&lt;/td&gt;&#xA;&lt;td&gt;12&lt;/td&gt;&#xA;&lt;td&gt;14&lt;/td&gt;&#xA;&lt;td&gt;14&lt;/td&gt;&#xA;&lt;td&gt;17&lt;/td&gt;&#xA;&lt;td&gt;10&lt;/td&gt;&#xA;&lt;td&gt;4&lt;/td&gt;&#xA;&lt;td&gt;13&lt;/td&gt;&#xA;&lt;td&gt;18&lt;/td&gt;&#xA;&lt;td&gt;22&lt;/td&gt;&#xA;&lt;td&gt;24&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Delta&lt;/td&gt;&#xA;&lt;td&gt;+12&lt;/td&gt;&#xA;&lt;td&gt;+2&lt;/td&gt;&#xA;&lt;td&gt;+0&lt;/td&gt;&#xA;&lt;td&gt;+3&lt;/td&gt;&#xA;&lt;td&gt;-7&lt;/td&gt;&#xA;&lt;td&gt;-6&lt;/td&gt;&#xA;&lt;td&gt;+9&lt;/td&gt;&#xA;&lt;td&gt;+5&lt;/td&gt;&#xA;&lt;td&gt;+4&lt;/td&gt;&#xA;&lt;td&gt;+2&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;We covered this topic on the Grafana Labs blog &lt;a href=&#34;/blog/2023/09/26/opentelemetry-metrics-a-guide-to-delta-vs.-cumulative-temporality-trade-offs/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;in more detail&#xA;before&lt;/a&gt;,&#xA;and I also spoke about it during OTel Community Day 2024:&lt;/p&gt;&#xA;&lt;div&#xA;class=&#34;youtube-lazyload responsive-video&#34;&#xA;data-embed=&#34;hmm39H2Tfew&#34;&#xA;data-url=&#34;https://www.youtube.com/embed/hmm39H2Tfew?autoplay=1&amp;amp;rel=0&#34;&#xA;data-title=&#34;YouTube Video&#34;&#xA;&gt;&#xA;&lt;div class=&#34;play-button&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;Luckily, Alloy (and the &lt;a href=&#34;https://opentelemetry.io/docs/collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;OpenTelemetry&#xA;Collector&lt;/a&gt;) &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/pull/34747&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;recently&#xA;got&lt;/a&gt;&#xA;a whole lot better at handling this scenario!&lt;/p&gt;&#xA;&lt;p&gt;That&amp;rsquo;s because the team at Grafana Labs&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/issues/30705&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;contributed&lt;/a&gt;&#xA;the&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/deltatocumulativeprocessor&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;deltatocumulative&lt;/code&gt;&lt;/a&gt;&#xA;processor upstream, adding the missing piece to send delta samples to cumulative&#xA;backends such as Prometheus or Grafana Cloud.&lt;/p&gt;&#xA;&lt;h2 id=&#34;converting-delta-metrics&#34;&gt;Converting delta metrics&lt;/h2&gt;&#xA;&lt;p&gt;The underlying math to convert a stream of delta samples to their cumulative&#xA;equivalent is not overly complex.&lt;/p&gt;&#xA;&lt;p&gt;Consider the following simplified algorithm:&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/delta-to-cumulative/diagram-1.svg&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/delta-to-cumulative/diagram-1.svg&#34;alt=&#34;Delta to cumulative diagram&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/delta-to-cumulative/diagram-1.svg&#34;&#xA;alt=&#34;Delta to cumulative diagram&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;When processing a metrics write request, it iterates the sample list. For each&#xA;delta increase or decrease it adds that amount to the last value of that stream&#xA;(or zero if this is the first sample ever seen).&lt;/p&gt;&#xA;&lt;p&gt;The result is now a proper cumulative sample, because it&amp;rsquo;s accumulated (added&#xA;up) over time. Those values are stored in the processor for the next aggregation&#xA;and also passed onto the next consumer in the metrics pipeline.&lt;/p&gt;&#xA;&lt;p&gt;(There is a little more timestamp and edge-case handling involved to do this&#xA;properly all the time, but this captures the basic idea.)&lt;/p&gt;&#xA;&lt;h3 id=&#34;the-role-of-statefulness&#34;&gt;The role of statefulness&lt;/h3&gt;&#xA;&lt;p&gt;Unfortunately, however, the above operation comes with a big caveat: It&amp;rsquo;s&#xA;&lt;strong&gt;stateful&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;p&gt;See the &lt;em&gt;Processor state&lt;/em&gt; the algorithm keeps interacting with? This state is&#xA;what the collector has to keep in memory. And because this must be done&#xA;per-series specifically, &lt;strong&gt;every sample&lt;/strong&gt; of a certain time series must always&#xA;be sent to &lt;strong&gt;the exact same collector&lt;/strong&gt; instance as the last sample was.&lt;/p&gt;&#xA;&lt;p&gt;Not exactly scaling-friendly, right?&lt;/p&gt;&#xA;&lt;h2 id=&#34;incorporating-load-balancing&#34;&gt;Incorporating load balancing&lt;/h2&gt;&#xA;&lt;p&gt;Luckily, there is another component for this exact kind of requirement: The&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/loadbalancingexporter&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;loadbalancing&lt;/code&gt;&lt;/a&gt;&#xA;exporter.&lt;/p&gt;&#xA;&lt;p&gt;It recently gained support for&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/pull/34086&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;streamID&lt;/code&gt;&lt;/a&gt;-based&#xA;routing, which does exactly what we need: it always sends samples of the same&#xA;time series to a fixed collector endpoint.&lt;/p&gt;&#xA;&lt;p&gt;To leverage that, we setup a two-layer collector deployment:&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/delta-to-cumulative/load-balancer-alloy.svg&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/delta-to-cumulative/load-balancer-alloy.svg&#34;alt=&#34;Load balancer diagram&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/delta-to-cumulative/load-balancer-alloy.svg&#34;&#xA;alt=&#34;Load balancer diagram&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;For brevity, the following sections only include the most important parts. You&#xA;can find the full configuration on&#xA;&lt;a href=&#34;https://github.com/sh0rez/deltatocumulative-scaling&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;GitHub&lt;/a&gt;:&lt;/em&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;a class=&#34;btn btn--primary&#34; href=&#34;https://github.com/sh0rez/deltatocumulative-scaling&#34; style=&#34;display: flex; align-items: center; gap: .5em&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&#xA;&lt;span style=&#34;font-size: 1.5em&#34; class=&#34;fa fa-github&#34;&gt;&lt;/span&gt; sh0rez/deltatocumulative-scaling&#xA;&lt;/a&gt;&#xA;&lt;h3 id=&#34;using-containers&#34;&gt;Using containers&lt;/h3&gt;&#xA;&lt;p&gt;I&amp;rsquo;m using &lt;a href=&#34;https://docs.docker.com/compose&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Docker Compose&lt;/a&gt; to create the&#xA;containers in our deployment above, but this can be done using any system,&#xA;including Kubernetes:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;services:&#xA;# application generating delta metrics, writes to router using OTLP&#xA;app:&#xA;build: ./deltagen&#xA;environment:&#xA;OTEL_EXPORTER_OTLP_ENDPOINT: http://router:4318&#xA;OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: delta&#xA;scale: 4&#xA;# stateless collector, routing incoming metrics to workers based on stream-id&#xA;router:&#xA;image: otel/opentelemetry-collector-contrib:0.112.0&#xA;volumes:&#xA;- ./loadbal.yml:/etc/otelcol-contrib/config.yaml&#xA;scale: 1&#xA;# stateful collector, converting from delta to cumulative and remote_writing to prometheus&#xA;worker:&#xA;image: otel/opentelemetry-collector-contrib:0.112.0&#xA;volumes:&#xA;- ./worker.yml:/etc/otelcol-contrib/config.yaml&#xA;scale: 2&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;This gives us several instances of an app that generates metrics, a single&#xA;load-balancer, and two workers.&lt;/p&gt;&#xA;&lt;p&gt;Docker Compose also automatically sets up the Docker DNS server, such that&#xA;&lt;code&gt;nslookup router&lt;/code&gt; returns the IPs of both instances.&lt;/p&gt;&#xA;&lt;h3 id=&#34;configuration-load-balancer&#34;&gt;Configuration: load balancer&lt;/h3&gt;&#xA;&lt;p&gt;Our application sends metrics using OTLP, but any other receiver works:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;receivers:&#xA;otlp:&#xA;protocols:&#xA;http:&#xA;endpoint: 0.0.0.0:4318&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;Next, the &lt;code&gt;loadbalancing&lt;/code&gt; exporter is configured to do sticky routing on a&#xA;per-series basis:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;exporters:&#xA;loadbalancing:&#xA;routing_key: streamID # load-balance on a per-stream basis&#xA;resolver:&#xA;dns:&#xA;hostname: worker # send to a stable worker of the pool&#xA;protocol:&#xA;otlp:&#xA;tls:&#xA;insecure: true # for testing, properly configure TLS in production&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;This uses the &lt;code&gt;dns&lt;/code&gt; resolver, which discovers worker instances by doing a DNS A&#xA;lookup on the hostname &lt;code&gt;worker&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Docker Compose configures the built-in Docker DNS server so that it always&#xA;returns all instance IPs when querying for the service name. The same can be&#xA;achieved in Kubernetes by using a &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#headless-services&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;headless&#xA;Service&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h3 id=&#34;configuration-worker&#34;&gt;Configuration: worker&lt;/h3&gt;&#xA;&lt;p&gt;The workers receive samples from a router in OTLP gRPC, convert them to&#xA;cumulative, and forward them to some backend supported by the collector (e.g.,&#xA;Grafana Cloud).&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;receivers:&#xA;otlp:&#xA;protocols:&#xA;grpc:&#xA;endpoint: 0.0.0.0:4317&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;deltatocumulative&lt;/code&gt; processor works out-of-the-box. See &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/deltatocumulativeprocessor#configuration&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;its&#xA;documentation&lt;/a&gt;&#xA;for additional configuration options.&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;processors:&#xA;deltatocumulative: {}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;Once converted to cumulative, the samples can be used with any exporter that&#xA;supports the cumulative temporality, such as the&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/prometheusremotewriteexporter&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;prometheusremotewrite&lt;/code&gt;&lt;/a&gt;&#xA;exporter.&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;exporters:&#xA;prometheusremotewrite:&#xA;endpoint: http://prometheus:9090/api/v1/write&#xA;resource_to_telemetry_conversion:&#xA;enabled: true&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h2 id=&#34;running-the-processor&#34;&gt;Running the processor&lt;/h2&gt;&#xA;&lt;p&gt;Once started, we can clearly see the even distribution of data points across the&#xA;different workers, using the following query:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;promql&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-promql&#34;&gt;rate(otelcol_receiver_accepted_metric_points[1m])&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;In this example, the number of workers was scaled from two to three, then up to&#xA;five, then back to two.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1597px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/delta-to-cumulative/otlp.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/delta-to-cumulative/otlp.png&#34;data-srcset=&#34;/media/blog/delta-to-cumulative/otlp.png?w=320 320w, /media/blog/delta-to-cumulative/otlp.png?w=550 550w, /media/blog/delta-to-cumulative/otlp.png?w=750 750w, /media/blog/delta-to-cumulative/otlp.png?w=900 900w, /media/blog/delta-to-cumulative/otlp.png?w=1040 1040w, /media/blog/delta-to-cumulative/otlp.png?w=1240 1240w, /media/blog/delta-to-cumulative/otlp.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;OTLP panel&#34;width=&#34;1597&#34;height=&#34;501&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/delta-to-cumulative/otlp.png&#34;&#xA;alt=&#34;OTLP panel&#34;width=&#34;1597&#34;height=&#34;501&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;The instances were DNS discovered as they came and went, with &lt;code&gt;loadbalancing&lt;/code&gt;&#xA;always evenly distributing load between them.&lt;/p&gt;&#xA;&lt;p&gt;The load-balancer (red line) was scaled from one to two and back.&lt;/p&gt;&#xA;&lt;p&gt;Looking at &lt;code&gt;deltatocumulative&lt;/code&gt;, we can see the streams tracked in memory. They&#xA;are dropped after five minutes without receiving new samples:&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1597px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/delta-to-cumulative/tracked-streams.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/delta-to-cumulative/tracked-streams.png&#34;data-srcset=&#34;/media/blog/delta-to-cumulative/tracked-streams.png?w=320 320w, /media/blog/delta-to-cumulative/tracked-streams.png?w=550 550w, /media/blog/delta-to-cumulative/tracked-streams.png?w=750 750w, /media/blog/delta-to-cumulative/tracked-streams.png?w=900 900w, /media/blog/delta-to-cumulative/tracked-streams.png?w=1040 1040w, /media/blog/delta-to-cumulative/tracked-streams.png?w=1240 1240w, /media/blog/delta-to-cumulative/tracked-streams.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Delta to cumulative panel&#34;width=&#34;1597&#34;height=&#34;501&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/delta-to-cumulative/tracked-streams.png&#34;&#xA;alt=&#34;Delta to cumulative panel&#34;width=&#34;1597&#34;height=&#34;501&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h2 id=&#34;looking-ahead&#34;&gt;Looking ahead&lt;/h2&gt;&#xA;&lt;p&gt;Most of this is early work, just released to the wider community.&lt;/p&gt;&#xA;&lt;p&gt;Any kind of testing and feedback is highly appreciated. Don&amp;rsquo;t hesitate to &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/issues/new/choose&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;file&#xA;issues&lt;/a&gt;,&#xA;engage on Slack (the Grafana community Slack and CNCF Slack both have&#xA;#opentelemetry channels) or even contribute PRs.&lt;/p&gt;&#xA;&lt;p&gt;Once mature, we will explore ways to reduce the operational complexity, such as&#xA;bringing this functionality directly into backends such as Prometheus&amp;rsquo; &lt;a href=&#34;https://github.com/prometheus/prometheus/pull/12571&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;OTLP&#xA;receiver&lt;/a&gt; or Grafana Cloud.&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud &lt;/a&gt;is the easiest way to get started with metrics, logs, traces, dashboards, and more. We have a generous forever-free tier and plans for every use case. &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Sign up for free now!&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;】&lt;p&gt;使用 &lt;a href=&#34;/oss/opentelemetry?pg=blog&amp;plcmt=body-txt&#34;&gt;OpenTelemetry&lt;/a&gt; 从其他供应商迁移变得更加容易&#xA;&lt;a href=&#34;/docs/alloy/latest/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Alloy&lt;/a&gt;，我们的发行版&#xA;打开遥测收集器。&lt;/p&gt;&#xA;&lt;p&gt;但是当您来自使用不同时间性的平台时，例如&#xA;&lt;a href=&#34;/blog/2024/06/18/translate-datadog-metrics-into-otlp-with-the-opentelemetry-collector-and-grafana-alloy/?pg=blog&amp;plcmt=body-txt&#34;&gt;Datadog&lt; /a&gt;&#xA;或 Dynatrace，您面临着与类似 Prometheus 的生态系统集成的挑战，例如&#xA;Grafana Cloud：您的指标仍然与以前相同，但它们只是不同&#xA;看右边。&lt;/p&gt;&#xA;&lt;p&gt;这是因为 delta 样本，在其他一些非 Prometheus 基础上使用&#xA;可观测性工具，报告测量的相对变化，例如+3、-7、&#xA;等等&lt;/p&gt;&#xA;&lt;p&gt;相反，Prometheus 中使用的累积采样表示&#xA;完全相同的信息，但它是作为相对于某个值的“绝对”值&#xA;任意聚合周期，给出 10、4 等样本。&lt;/p&gt;&#xA;&lt;p&gt;考虑以下示例时间序列（或 OTel 语言中的流）：&lt;/p&gt;&#xA;&lt;表&gt;&#xA;&lt;标题&gt;&#xA;&lt;tr&gt;&#xA;&lt;th&gt;时间&lt;/th&gt;&#xA;&lt;th&gt;10&lt;/th&gt;&#xA;&lt;th&gt;20&lt;/th&gt;&#xA;&lt;th&gt;30&lt;/th&gt;&#xA;&lt;th&gt;40&lt;/th&gt;&#xA;&lt;th&gt;50&lt;/th&gt;&#xA;&lt;th&gt;60&lt;/th&gt;&#xA;&lt;th&gt;70&lt;/th&gt;&#xA;&lt;th&gt;80&lt;/th&gt;&#xA;&lt;th&gt;90&lt;/th&gt;&#xA;&lt;th&gt;100&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/标题&gt;&#xA;&lt;正文&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;累计&lt;/td&gt;&#xA;&lt;td&gt;12&lt;/td&gt;&#xA;&lt;td&gt;14&lt;/td&gt;&#xA;&lt;td&gt;14&lt;/td&gt;&#xA;&lt;td&gt;17&lt;/td&gt;&#xA;&lt;td&gt;10&lt;/td&gt;&#xA;&lt;td&gt;4&lt;/td&gt;&#xA;&lt;td&gt;13&lt;/td&gt;&#xA;&lt;td&gt;18&lt;/td&gt;&#xA;&lt;td&gt;22&lt;/td&gt;&#xA;&lt;td&gt;24&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;达美航空&lt;/td&gt;&#xA;&lt;td&gt;+12&lt;/td&gt;&#xA;&lt;td&gt;+2&lt;/td&gt;&#xA;&lt;td&gt;+0&lt;/td&gt;&#xA;&lt;td&gt;+3&lt;/td&gt;&#xA;&lt;td&gt;-7&lt;/td&gt;&#xA;&lt;td&gt;-6&lt;/td&gt;&#xA;&lt;td&gt;+9&lt;/td&gt;&#xA;&lt;td&gt;+5&lt;/td&gt;&#xA;&lt;td&gt;+4&lt;/td&gt;&#xA;&lt;td&gt;+2&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/表&gt;&#xA;&lt;p&gt;我们在 Grafana Labs 博客&lt;a href=&#34;/blog/2023/09/26/opentelemetry-metrics-a-guide-to-delta-vs.-cumulative-temporality-trade-offs/? pg=blog&amp;plcmt=body-txt&#34;&gt;更详细&#xA;之前&lt;/a&gt;，&#xA;我还在 2024 年 OTel 社区日期间谈到了这一点：&lt;/p&gt;&#xA;&lt;div&#xA;类 =“youtube-lazyload 响应视频”&#xA;数据嵌入=“hmm39H2Tfew”&#xA;data-url=&#34;https://www.youtube.com/embed/hmm39H2Tfew?autoplay=1&amp;rel=0&#34;&#xA;数据标题=“YouTube 视频”&#xA;&gt;&#xA;&lt;div class=&#34;play-button&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;幸运的是，Alloy（以及 &lt;a href=&#34;https://opentelemetry.io/docs/collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;OpenTelemetry&#xA;收集器&lt;/a&gt;）&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/pull/34747&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;最近&#xA;得到&lt;/a&gt;&#xA;能够更好地处理这种情况！&lt;/p&gt;&#xA;&lt;p&gt;那是因为 Grafana Labs 的团队&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/issues/30705&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;贡献&lt;/a&gt;&#xA;这&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/deltatocumulativeprocessor&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;deltatocumulative&lt;/code &gt;&lt;/a&gt;&#xA;处理器上游，添加缺失的部分以将增量样本发送到累积&#xA;后端例如Prometheus 或 Grafana Cloud。&lt;/p&gt;&#xA;&lt;h2 id=&#34;converting-delta-metrics&#34;&gt;转换增量指标&lt;/h2&gt;&#xA;&lt;p&gt;将增量样本流转换为其累积值的基础数学&#xA;等效项并不太复杂。&lt;/p&gt;&#xA;&lt;p&gt;考虑以下简化算法：&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/delta-to-cumulative/diagram-1.svg&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/delta-to-cumulative/diagram-1.svg&#34;alt=&#34;Delta 到累积图&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/delta-to-cumulative/diagram-1.svg”&#xA;alt=&#34;累积图的增量&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;处理指标写入请求时，它会迭代示例列表。对于每个&#xA;增量增加或减少它将该金额添加到该流的最后一个值&#xA;（如果这是有史以来第一个样本，则为零）。&lt;/p&gt;&#xA;&lt;p&gt;结果现在是一个正确的累积样本，因为它是累积的（添加了&#xA;上）随着时间的推移。这些值存储在处理器中以供下一次聚合&#xA;并传递给指标管道中的下一个消费者。&lt;/p&gt;&#xA;&lt;p&gt;（执行此操作涉及更多时间戳和边缘情况处理&#xA;始终正确，但这抓住了基本思想。）&lt;/p&gt;&#xA;&lt;h3 id=&#34;the-role-of-stateativity&#34;&gt;有状态的作用&lt;/h3&gt;&#xA;&lt;p&gt;然而不幸的是，上述操作有一个很大的警告：&#xA;&lt;strong&gt;有状态&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;看到算法一直与之交互的&lt;em&gt;处理器状态&lt;/em&gt;吗？这个状态是&#xA;收藏家必须记住的东西。因为这必须要做&#xA;具体来说，特定时间序列的&lt;strong&gt;每个样本&lt;/strong&gt;必须始终&#xA;被发送到与上一个样本&lt;strong&gt;完全相同的收集器&lt;/strong&gt;实例。&lt;/p&gt;&#xA;&lt;p&gt;不完全适合扩展，对吧？&lt;/p&gt;&#xA;&lt;h2 id=&#34;incorporating-load-balancing&#34;&gt;合并负载平衡&lt;/h2&gt;&#xA;&lt;p&gt;幸运的是，还有另一个组件可以满足这种确切的要求：&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/loadbalancingexporter&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;负载均衡&lt;/code &gt;&lt;/a&gt;&#xA;出口商。&lt;/p&gt;&#xA;&lt;p&gt;它最近获得了支持&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/pull/34086&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;streamID&lt;/code&gt;&lt;/a &gt;基于&#xA;路由，它正是我们所需要的：它总是发送相同的样本&#xA;时间序列到固定收集器端点。&lt;/p&gt;&#xA;&lt;p&gt;为了利用这一点，我们设置了两层收集器部署：&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/delta-to-cumulative/load-balancer-alloy.svg&#34;&#xA;itemprop=“内容”网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/delta-to-cumulative/load-balancer-alloy.svg&#34;alt=&#34;负载均衡器图&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/delta-to-cumulative/load-balancer-alloy.svg”&#xA;alt=&#34;负载均衡器图&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;块引用&gt;&#xA;&lt;p&gt;&lt;em&gt;为简洁起见，以下部分仅包含最重要的部分。你&#xA;可以找到完整的配置&#xA;&lt;a href=&#34;https://github.com/sh0rez/deltatocumulative-scaling&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;GitHub&lt;/a&gt;：&lt;/em&gt;&lt;/p&gt;&#xA;&lt;/块引用&gt;&#xA;&lt;a class =“btn btn--primary”href =“https://github.com/sh0rez/deltatocumulative-scaling”style =“显示：flex;对齐项目：中心;间隙：.5em”target =“_blank” “ rel =“noopener noreferrer”&gt;&#xA;&lt;span style=&#34;font-size: 1.5em&#34; class=&#34;fa fa-github&#34;&gt;&lt;/span&gt; sh0rez/deltatocumulative-scaling&#xA;&lt;/a&gt;&#xA;&lt;h3 id=&#34;using-containers&#34;&gt;使用容器&lt;/h3&gt;&#xA;&lt;p&gt;我正在使用 &lt;a href=&#34;https://docs.docker.com/compose&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Docker Compose&lt;/a&gt; 来创建&#xA;我们上面部署中的容器，但这可以使用任何系统来完成，&#xA;包括 Kubernetes：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;服务：&#xA;# 应用程序生成增量指标，使用 OTLP 写入路由器&#xA;应用程序：&#xA;构建：./deltagen&#xA;环境：&#xA;OTEL_EXPORTER_OTLP_ENDPOINT：http://路由器:4318&#xA;OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE：增量&#xA;规模：4&#xA;# 无状态收集器，根据流 ID 将传入指标路由到工作人员&#xA;路由器：&#xA;图片：otel/opentelemetry-collector-contrib:0.112.0&#xA;卷：&#xA;- ./loadbal.yml:/etc/otelcol-contrib/config.yaml&#xA;规模：1&#xA;# 有状态收集器，从 delta 转换为cumulative，remote_writing 转换为 prometheus&#xA;工人：&#xA;图片：otel/opentelemetry-collector-contrib:0.112.0&#xA;卷：&#xA;- ./worker.yml:/etc/otelcol-contrib/config.yaml&#xA;规模：2&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;这为我们提供了生成指标的应用程序的多个实例，一个&#xA;负载均衡器和两个工作人员。&lt;/p&gt;&#xA;&lt;p&gt;Docker Compose 还会自动设置 Docker DNS 服务器，这样&#xA;&lt;code&gt;nslookup router&lt;/code&gt; 返回两个实例的 IP。&lt;/p&gt;&#xA;&lt;h3 id=&#34;configuration-load-balancer&#34;&gt;配置：负载均衡器&lt;/h3&gt;&#xA;&lt;p&gt;我们的应用程序使用 OTLP 发送指标，但任何其他接收器都可以工作：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;接收者：&#xA;奥特普：&#xA;协议：&#xA;http：&#xA;端点：0.0.0.0:4318&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;接下来，&lt;code&gt;loadbalancing&lt;/code&gt; 导出器配置为在&#xA;每个系列的基础：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;导出器：&#xA;负载平衡：&#xA;Routing_key: StreamID # 基于每个流的负载平衡&#xA;解析器：&#xA;域名：&#xA;hostname:worker # 发送到池中稳定的worker&#xA;协议：&#xA;奥特普：&#xA;:&#xA;insecure: true # 用于测试，在生产中正确配置 TLS&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;这使用 &lt;code&gt;dns&lt;/code&gt; 解析器，它通过执行 DNS A 来发现工作实例&#xA;查找主机名&lt;code&gt;worker&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;Docker Compose 配置内置 Docker DNS 服务器，使其始终&#xA;查询服务名称时返回所有实例IP。同样可以&#xA;通过使用 &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#headless-services&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;headless 在 Kubernetes 中实现&#xA;服务&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;configuration-worker&#34;&gt;配置：工作人员&lt;/h3&gt;&#xA;&lt;p&gt;工作人员从 OTLP gRPC 中的路由器接收样本，将其转换为&#xA;累积的，并将它们转发到收集器支持的某些后端（例如，&#xA;Grafana 云）。&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;接收者：&#xA;奥特普：&#xA;协议：&#xA;组：&#xA;端点：0.0.0.0:4317&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;&lt;code&gt;deltatocumulative&lt;/code&gt; 处理器开箱即用。请参阅&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/deltatocumulativeprocessor#configuration&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;其&#xA;文档&lt;/a&gt;&#xA;更多配置选项。&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;复制()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;处理器：&#xA;增量累积：{}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;一旦转换为累积，样本就可以与任何出口商一起使用&#xA;支持累积时间性，例如&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/prometheusremotewriteexporter&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;prometheusremotewrite&lt;/code &gt;&lt;/a&gt;&#xA;出口商。&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;导出器：&#xA;普罗米修斯远程写入：&#xA;端点：http://prometheus:9090/api/v1/write&#xA;资源到遥测转换：&#xA;启用：true&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h2 id=&#34;running-the-processor&#34;&gt;运行处理器&lt;/h2&gt;&#xA;&lt;p&gt;一旦开始，我们可以清楚地看到数据点在整个区域的均匀分布&#xA;不同的工作人员，使用以下查询：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;promql&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-promql&#34;&gt;费率(otelcol_receiver_accepted_metric_points[1m])&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;在这个例子中，工人的数量从两个扩展到三个，然后增加到&#xA;五个，然后回到两个。&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1597px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/delta-to-cumulative/otlp.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/delta-to-cumulative/otlp.png”data-srcset =“/media/blog/delta-to-cumulative/otlp.png？w = 320 320w，/media/blog/增量到累积/otlp.png？w=550 550w，/media/blog/增量到累积/otlp.png？w=750 750w， /media/blog/delta-to-cumulative/otlp.png?w=900 900w, /media/blog/delta-to-cumulative/otlp.png?w=1040 1040w, /media/blog/delta-to-cumulative /otlp.png?w=1240 1240w, /media/blog/delta-to-cumulative/otlp.png?w=1920 1920w&#34;&#xA;data-size=&#34;auto&#34;alt=&#34;OTLP 面板&#34;width=&#34;1597&#34;height=&#34;501&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/delta-to-cumulative/otlp.png”&#xA;alt=&#34;OTLP 面板&#34;width=&#34;1597&#34;height=&#34;501&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;这些实例在它们来来往往时被 DNS 发现，并使用&lt;code&gt;负载平衡&lt;/code&gt;&#xA;始终在它们之间均匀分配负载。&lt;/p&gt;&#xA;&lt;p&gt;负载均衡器（红线）从 1 缩放到 2，然后再缩放回来。&lt;/p&gt;&#xA;&lt;p&gt;查看&lt;code&gt;deltatocumulative&lt;/code&gt;，我们可以看到内存中跟踪的流。他们&#xA;五分钟后没有收到新样本就被丢弃：&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1597px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/delta-to-cumulative/tracked-streams.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/delta-to-cumulative/tracked-streams.png”data-srcset =“/media/blog/delta-to-cumulative/tracked-streams.png？w = 320 320w，/媒体/博客/delta-to-cumulative/tracked-streams.png?w=550 550w, /media/blog/delta-to-cumulative/tracked-streams.png?w=750 750w, /media/blog/delta-to-cumulative/tracked-streams.png?w=900 900w, /media/blog/delta -to-cumulative/tracked-streams.png?w=1040 1040w, /media/blog/delta-to-cumulative/tracked-streams.png?w=1240 1240w, /media/blog/delta-to-cumulative/tracked-streams.png?w=1920 1920w&#34;&#xA;data-size=&#34;auto&#34;alt=&#34;累积面板的增量&#34;width=&#34;1597&#34;height=&#34;501&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/delta-to-cumulative/tracked-streams.png”&#xA;alt=&#34;累积面板的增量&#34;width=&#34;1597&#34;height=&#34;501&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h2 id=&#34;looking-ahead&#34;&gt;展望未来&lt;/h2&gt;&#xA;&lt;p&gt;其中大部分是早期工作，刚刚发布给更广泛的社区。&lt;/​​p&gt;&#xA;&lt;p&gt;任何类型的测试和反馈都受到高度赞赏。不要犹豫 &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/issues/new/choose&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;文件&#xA;问题&lt;/a&gt;，&#xA;参与 Slack（Grafana 社区 Slack 和 CNCF Slack 都有&#xA;#opentelemetry频道）甚至贡献PR。&lt;/p&gt;&#xA;&lt;p&gt;一旦成熟，我们将探索降低运营复杂度的方法，例如&#xA;将此功能直接引入后端，例如 Prometheus 的 &lt;a href=&#34;https://github.com/prometheus/prometheus/pull/12571&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;OTLP&#xA;接收器&lt;/a&gt;或Grafana Cloud。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt;是开始使用指标、日志、跟踪、仪表板等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。 &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;plcmt=body-txt&#34;&gt;立即免费注册！&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</description>
      <pubDate>Mon, 25 Nov 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Grafana Alerting: Save time and effort with Grafana-managed recording rules】Grafana 警报：使用 Grafana 管理的记录规则节省时间和精力</title>
      <link>https://grafana.com/blog/2024/12/03/grafana-alerting-save-time-and-effort-with-grafana-managed-recording-rules/</link>
      <description>【&lt;p&gt;Grafana Alerting has seen steady growth and adoption since it was &lt;a href=&#34;/blog/2022/06/14/grafana-9.0-release-oss-and-cloud-features/#grafana-alerting-improvements&#34;&gt;revamped in Grafana 9&lt;/a&gt;. Since then, we&amp;rsquo;ve been busy making your alerts more robust, more reliable, and easier to manage.&lt;/p&gt;&#xA;&lt;p&gt;As part of that process, Grafana Alerting has adopted several concepts from Prometheus. The Prometheus alerting model is well understood and flexible, and with Grafana Alerting we want to bring that same flexibility to all Grafana data sources.&lt;/p&gt;&#xA;&lt;p&gt;That&amp;rsquo;s why we&amp;rsquo;re excited to tell you about &lt;strong&gt;Grafana-managed recording rules&lt;/strong&gt;, a powerful new tool in Grafana Alerting — added in Grafana 11.3 — that can save you time and effort in setting up and managing incident response.&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-is-a-recording-rule&#34;&gt;What is a recording rule?&lt;/h2&gt;&#xA;&lt;p&gt;Do you have any expensive or slow data source queries? Are you tired of embedding the same slow query in all your dashboards, and having to wait for the same query to run over and over every time you open the page?&lt;/p&gt;&#xA;&lt;p&gt;You can use recording rules to help solve this problem. To quote the &lt;a href=&#34;https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#recording-rules&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Prometheus docs&lt;/a&gt;, &amp;ldquo;Recording rules allow you to precompute frequently needed or computationally expensive expressions and save their result as a new set of time series.&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;With recording rules, you can tell Grafana to execute any data source query in the background, and save the results in a designated Prometheus time-series database.&lt;/p&gt;&#xA;&lt;p&gt;By building on the powerful Grafana Alerting rules engine, the results will be automatically kept up-to-date in the background for you. Then, you can update your dashboards and alert rules to quickly query that saved series instead, deduplicating your slow and expensive queries and speeding up your dashboards.&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-else-can-i-do-with-recording-rules&#34;&gt;What else can I do with recording rules?&lt;/h2&gt;&#xA;&lt;p&gt;In addition to the benefits outlined above, there are other things you can do with Grafana-managed recording rules:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Reduce your cloud costs.&lt;/strong&gt; If you are using a data source that charges by the query, you can use recording rules to reduce the cost of running Grafana as a whole. By recording your most expensive queries into Prometheus, you can reduce the number of times that Grafana is hitting the data source, letting you build many dashboards for the same data while only paying for the queries once. This helps keep your observability costs low while writing as many dashboards as you like.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Query multiple data sources and combine the results with expressions.&lt;/strong&gt; If you need to combine two disparate sources of information, you can mix data source queries in the same rule, the same way you would in a dashboard panel. You can then write the combined result into Prometheus for quick access later.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Try Prometheus without committing to a full migration.&lt;/strong&gt; If you aren&amp;rsquo;t sure where to start with Prometheus, Grafana-managed recording rules support reads from any &lt;a href=&#34;/grafana/plugins/data-source-plugins/?features=alerting&#34;&gt;data source supported by Grafana Alerting&lt;/a&gt; and saves the results in Prometheus. You can use this to ETL a subset of your data and test out Prometheus-driven dashboards or start learning PromQL on your real data. We hope this feature improves the onboarding experience for existing Grafana users who are interested in changing where their data is stored.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;how-do-i-get-started&#34;&gt;How do I get started?&lt;/h2&gt;&#xA;&lt;p&gt;To keep operations light, Grafana does not ship with an embedded time-series database. You&amp;rsquo;ll need to set up your own Prometheus-compatible database, such as &lt;a href=&#34;/oss/mimir/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Mimir&lt;/a&gt;, to store the results of recording rule evaluations.&lt;/p&gt;&#xA;&lt;p&gt;You can start by enabling the &lt;code&gt;grafanaManagedRecordingRules&lt;/code&gt; feature toggle.&lt;/p&gt;&#xA;&lt;p&gt;For now, recording rules only support a single target. Enable the feature, and provide your target credentials in Grafana&amp;rsquo;s &lt;code&gt;config.ini&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;[recording_rules]&#xA;enabled = true&#xA;url = http://my-example-prometheus.local:9090/api/prom/push&#xA;basic_auth_username = my-user&#xA;basic_auth_password = my-pass&#xA;[recording_rules.custom_headers]&#xA;X-My-Header = MyValue&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;Then, you can create a recording rule from the Alerting UI, against any alerting-compatible datasource.&lt;/p&gt;&#xA;&lt;p&gt;Much like &lt;a href=&#34;/docs/grafana/latest/alerting/fundamentals/alert-rules/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;alert rules&lt;/a&gt;, your data needs to be collapsed to look like a Prometheus instant query. You can easily accomplish this by adding a &lt;code&gt;Reduce&lt;/code&gt; expression in front of most data source queries. This should be familiar to most Grafana Alerting users.&lt;/p&gt;&#xA;&lt;p&gt;When dealing with more complex expressions involving multiple queries, you can mark which expression you want to record by clicking &lt;strong&gt;Set as recording rule output&lt;/strong&gt; in the query builder.&lt;/p&gt;&#xA;&lt;p&gt;Recording rules are modeled as an extension of existing Grafana alert rules. That means you can view, search, and manage them in exactly the same way you would alert rules.&lt;/p&gt;&#xA;&lt;p&gt;Grafana rule groups and folders can contain a mixture of alerting and recording rules. If you define your alerts as code, recording rules are supported in all the same provisioning systems and APIs that you&amp;rsquo;re already using.&lt;/p&gt;&#xA;&lt;p&gt;In the screenshot below, you can see a single expression that is already selected as the rule output:&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 651px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/grafana-managed-recording-rules/managed-recording-rule-output.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/grafana-managed-recording-rules/managed-recording-rule-output.png&#34;data-srcset=&#34;/media/blog/grafana-managed-recording-rules/managed-recording-rule-output.png?w=320 320w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-output.png?w=550 550w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-output.png?w=750 750w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-output.png?w=900 900w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-output.png?w=1040 1040w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-output.png?w=1240 1240w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-output.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of a single expression that is already selected as the rule output.&#34;width=&#34;651&#34;height=&#34;287&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/grafana-managed-recording-rules/managed-recording-rule-output.png&#34;&#xA;alt=&#34;A screenshot of a single expression that is already selected as the rule output.&#34;width=&#34;651&#34;height=&#34;287&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;And here, the left expression is showing the &lt;strong&gt;Set as recording rule output&lt;/strong&gt; action link:&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1163px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/grafana-managed-recording-rules/managed-recording-rule-set-as-output.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/grafana-managed-recording-rules/managed-recording-rule-set-as-output.png&#34;data-srcset=&#34;/media/blog/grafana-managed-recording-rules/managed-recording-rule-set-as-output.png?w=320 320w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-set-as-output.png?w=550 550w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-set-as-output.png?w=750 750w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-set-as-output.png?w=900 900w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-set-as-output.png?w=1040 1040w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-set-as-output.png?w=1240 1240w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-set-as-output.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of an expression expression showing the Set as recording rule output action link.&#34;width=&#34;1163&#34;height=&#34;262&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/grafana-managed-recording-rules/managed-recording-rule-set-as-output.png&#34;&#xA;alt=&#34;A screenshot of an expression expression showing the Set as recording rule output action link.&#34;width=&#34;1163&#34;height=&#34;262&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s say we often want to visualize the CPU usage of several Kubernetes pods, broken down by namespace. If we make the same query in several dashboards, it makes sense to record it:&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1168px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/grafana-managed-recording-rules/managed-recording-rule-edit-rule.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/grafana-managed-recording-rules/managed-recording-rule-edit-rule.png&#34;data-srcset=&#34;/media/blog/grafana-managed-recording-rules/managed-recording-rule-edit-rule.png?w=320 320w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-edit-rule.png?w=550 550w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-edit-rule.png?w=750 750w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-edit-rule.png?w=900 900w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-edit-rule.png?w=1040 1040w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-edit-rule.png?w=1240 1240w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-edit-rule.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot showing how to enter a recording rule and metric name.&#34;width=&#34;1168&#34;height=&#34;570&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/grafana-managed-recording-rules/managed-recording-rule-edit-rule.png&#34;&#xA;alt=&#34;A screenshot showing how to enter a recording rule and metric name.&#34;width=&#34;1168&#34;height=&#34;570&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;Then, we can reference that data with &lt;code&gt;my_recorded_kube_cpu_usage_by_namespace&lt;/code&gt;. Here&amp;rsquo;s what the underlying query looks like next to the recorded series:&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1999px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/grafana-managed-recording-rules/managed-recording-rule-recorded-and-query-data.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/grafana-managed-recording-rules/managed-recording-rule-recorded-and-query-data.png&#34;data-srcset=&#34;/media/blog/grafana-managed-recording-rules/managed-recording-rule-recorded-and-query-data.png?w=320 320w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-recorded-and-query-data.png?w=550 550w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-recorded-and-query-data.png?w=750 750w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-recorded-and-query-data.png?w=900 900w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-recorded-and-query-data.png?w=1040 1040w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-recorded-and-query-data.png?w=1240 1240w, /media/blog/grafana-managed-recording-rules/managed-recording-rule-recorded-and-query-data.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot showing the underlying query next to the recorded series. &#34;width=&#34;1999&#34;height=&#34;858&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/grafana-managed-recording-rules/managed-recording-rule-recorded-and-query-data.png&#34;&#xA;alt=&#34;A screenshot showing the underlying query next to the recorded series. &#34;width=&#34;1999&#34;height=&#34;858&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;You can see the recorded data following the queried data very closely. The recording rule saved every dimension from the original query — like with Alerting rules, you can query many series with just one rule.&lt;/p&gt;&#xA;&lt;p&gt;Note how the recorded series also inherits the labels from the original query. This means you can still correlate and filter your recorded data, the same way you did before! Also notice how the same label matcher works for both the original and recorded series: &lt;code&gt;namespace=~&amp;quot;kube-system|loki|robot-shop&amp;quot;&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Recorded data often has a &amp;ldquo;sampling lag&amp;rdquo; when directly superimposed onto the original query. This is because the recording rule runs once a minute, which may not line up perfectly with the time that you issued the query from the browser. This is especially common for data with high variance. To reduce sampling lag, try increasing the evaluation interval of your recording rule.&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-about-enterprise-recorded-queries&#34;&gt;What about enterprise recorded queries?&lt;/h2&gt;&#xA;&lt;p&gt;For Grafana Enterprise users, some of this might sound somewhat familiar, as there is an enterprise recorded query (ERQ) feature that can record a limited set of queries. However, Grafana-managed recording rules offer several benefits over ERQs:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;They are open source and available to all Grafana users.&lt;/li&gt;&#xA;&lt;li&gt;They fully integrate with the Grafana Alerting engine, meaning they can be managed and operated more easily, and configured in the Grafana Alerting UI.&lt;/li&gt;&#xA;&lt;li&gt;They can be mixed and managed alongside Grafana Alert rules.&lt;/li&gt;&#xA;&lt;li&gt;They can be provisioned as-code using the same provisioning mechanisms for Grafana Alerting.&lt;/li&gt;&#xA;&lt;li&gt;Access can be controlled via RBAC.&lt;/li&gt;&#xA;&lt;li&gt;They work on both single-host and highly available (HA) Grafana deployments.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;For now, we plan to leave ERQs as they are, but we hope you try out Grafana-managed recording rules as an alternative. We plan to bring the remaining benefits of ERQs to recording rules in the future, including a per-rule configurable Prometheus target and ease of creation from a dashboard.&lt;/p&gt;&#xA;&lt;p&gt;Eventually, we hope that Grafana-managed recording rules become a superset of ERQs, at which point we want to build an automated migration path between the two, leading to the eventual deprecation of ERQs. Currently, we have no planned date for this.&lt;/p&gt;&#xA;&lt;h2 id=&#34;whats-next-for-recording-rules&#34;&gt;What&amp;rsquo;s next for recording rules?&lt;/h2&gt;&#xA;&lt;p&gt;In the future, we hope to bring several improvements to this powerful new functionality:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Per-rule configurable target data sources, allowing you to use many Prometheus targets at once and manage them via the Grafana UI as data sources rather than config settings.&lt;/li&gt;&#xA;&lt;li&gt;Sequential evaluation of rules in rule groups, allowing you to deterministically mix recording rules and alert rules with strong consistency, and bringing even tighter alignment with Prometheus rules.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;In addition, bringing this feature under the Grafana Alerting umbrella means that recording rules uptake &lt;a href=&#34;/blog/2023/03/06/grafana-alerting-12-ways-we-made-creating-and-managing-alerts-easier-than-ever/&#34;&gt;many of the improvements you already enjoy from Grafana Alerting&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;learn-more-about-grafana-alerting&#34;&gt;Learn more about Grafana Alerting&lt;/h2&gt;&#xA;&lt;p&gt;If you’d like to learn more, check out our&lt;a href=&#34;/docs/grafana/latest/alerting/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt; Grafana Alerting documentation&lt;/a&gt; or &lt;a href=&#34;https://www.youtube.com/watch?v=7z5FwdfL7v4&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;watch this talk on the evolution of Grafana Alerting&lt;/a&gt; from GrafanaCON 2024.&lt;/p&gt;&#xA;&lt;p&gt;And if you&amp;rsquo;d like to provide feedback on the new recording rules, or if you’d just like to request a new feature for Grafana Alerting in general, please let us know! You can do this by opening an issue in the&lt;a href=&#34;https://github.com/grafana/grafana&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt; Grafana GitHub repository&lt;/a&gt;, or by asking in the&lt;a href=&#34;https://grafana.slack.com/archives/C043CEX9MBK&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;#alerting channel&lt;/a&gt; in the&lt;a href=&#34;https://slack.grafana.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt; Grafana Labs Community Slack&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt; is the easiest way to get started with metrics, logs, traces, and dashboards. We have a generous free forever tier and plans for every use case.&lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt; Sign up for free now&lt;/a&gt;!&lt;/em&gt;&lt;/p&gt;】&lt;p&gt;自 &lt;a href=&#34;/blog/2022/06/14/grafana-9.0-release-oss-and-cloud-features/#grafana-alerting-improvements&#34;&gt; 推出以来，Grafana Alerting 一直在稳步增长和采用在 Grafana 9 中进行了改进&lt;/a&gt;。从那时起，我们一直致力于让您的警报更加强大、更加可靠且更易于管理。&lt;/p&gt;&#xA;&lt;p&gt;作为该流程的一部分，Grafana Alerting 采用了 Prometheus 的几个概念。 Prometheus 警报模型易于理解且灵活，通过 Grafana Alerting，我们希望为所有 Grafana 数据源带来同样的灵活性。&lt;/p&gt;&#xA;&lt;p&gt;因此，我们很高兴向您介绍 &lt;strong&gt;Grafana 管理的记录规则&lt;/strong&gt;，这是 Grafana 警报中的一个强大的新工具（在 Grafana 11.3 中添加），可以节省您设置和管理的时间和精力。管理事件响应。&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-is-a-recording-rule&#34;&gt;什么是录音规则？&lt;/h2&gt;&#xA;&lt;p&gt;您是否有任何昂贵或缓慢的数据源查询？您是否厌倦了在所有仪表板中嵌入相同的慢速查询，并且每次打开页面时都必须等待相同的查询一遍又一遍地运行？&lt;/p&gt;&#xA;&lt;p&gt;您可以使用录制规则来帮助解决此问题。引用 &lt;a href=&#34;https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#recording-rules&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Prometheus 文档&lt;/a&gt;， “记录规则允许您预先计算经常需要的或计算成本较高的表达式，并将其结果保存为一组新的时间序列。”&lt;/p&gt;&#xA;&lt;p&gt;通过记录规则，您可以告诉Grafana在后台执行任何数据源查询，并将结果保存在指定的Prometheus时序数据库中。&lt;/p&gt;&#xA;&lt;p&gt;通过构建强大的 Grafana 警报规则引擎，结果将在后台自动为您保持最新。然后，您可以更新仪表板和警报规则以快速查询已保存的系列，从而消除缓慢且昂贵的重复查询并加快仪表板速度。&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-else-can-i-do-with-recording-rules&#34;&gt;我还能用录制规则做什么？&lt;/h2&gt;&#xA;&lt;p&gt;除了上述优势之外，您还可以使用 Grafana 管理的记录规则执行其他操作：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;降低云成本。&lt;/strong&gt;如果您使用的是按查询收费的数据源，则可以使用记录规则来降低整体运行 Grafana 的成本。通过将最昂贵的查询记录到 Prometheus 中，您可以减少 Grafana 访问数据源的次数，让您可以为相同的数据构建多个仪表板，而只需为查询付费一次。这有助于在编写任意数量的仪表板时保持较低的可观察性成本。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;查询多个数据源并将结果与​​表达式组合。&lt;/strong&gt;如果您需要组合两个不同的信息源，您可以在同一规则中混合数据源查询，就像在仪表板面板。然后你可以写co将结果合并到 Prometheus 中以便稍后快速访问。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;在不承诺完全迁移的情况下尝试 Prometheus。&lt;/strong&gt;如果您不确定从哪里开始使用 Prometheus，Grafana 管理的记录规则支持从任何 &lt;a href=&#34;/grafana/plugins/ 读取data-source-plugins/?features=alerting&#34;&gt;Grafana Alerting支持的数据源&lt;/a&gt;，并将结果保存在Prometheus中。您可以使用它来 ETL 数据子集并测试 Prometheus 驱动的仪表板或开始在真实数据上学习 PromQL。我们希望此功能能够改善有兴趣更改数据存储位置的现有 Grafana 用户的入门体验。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;how-do-i-get-started&#34;&gt;我该如何开始？&lt;/h2&gt;&#xA;&lt;p&gt;为了保持操作轻便，Grafana 没有附带嵌入式时间序列数据库。您需要设置自己的 Prometheus 兼容数据库，例如 &lt;a href=&#34;/oss/mimir/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Mimir&lt;/a&gt;，用于存储记录规则的结果评价。&lt;/p&gt;&#xA;&lt;p&gt;您可以首先启用 &lt;code&gt;grafanaManagedRecordingRules&lt;/code&gt; 功能切换。&lt;/p&gt;&#xA;&lt;p&gt;目前，记录规则仅支持单个目标。启用该功能，并在 Grafana 的 config.ini 中提供您的目标凭据：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;[recording_rules]&#xA;启用=真&#xA;url = http://my-example-prometheus.local:9090/api/prom/push&#xA;basic_auth_username = 我的用户&#xA;basic_auth_password = 我的密码&#xA;[录制规则.自定义标题]&#xA;X-My-Header = MyValue&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;然后，您可以从警报 UI 针对任何与警报兼容的数据源创建记录规则。&lt;/p&gt;&#xA;&lt;p&gt;与&lt;a href=&#34;/docs/grafana/latest/alerting/fundamentals/alert-rules/?pg=blog&amp;plcmt=body-txt&#34;&gt;警报规则&lt;/a&gt;非常相似，您的数据需要折叠才能查看就像普罗米修斯即时查询一样。您可以通过在大多数数据源查询前面添加 &lt;code&gt;Reduce&lt;/code&gt; 表达式来轻松实现此目的。大多数 Grafana Alerting 用户应该熟悉这一点。&lt;/p&gt;&#xA;&lt;p&gt;当处理涉及多个查询的更复杂表达式时，您可以通过单击查询构建器中的&lt;strong&gt;设置为记录规则输出&lt;/strong&gt;来标记要记录的表达式。&lt;/p&gt;&#xA;&lt;p&gt;记录规则被建模为现有 Grafana 警报规则的扩展。这意味着您可以按照与警报规则完全相同的方式查看、搜索和管理它们。&lt;/p&gt;&#xA;&lt;p&gt;Grafana 规则组和文件夹可以包含警报和记录规则的混合。如果您将警报定义为代码，则支持记录规则您已经在使用的所有相同的配置系统和 API。&lt;/p&gt;&#xA;&lt;p&gt;在下面的屏幕截图中，您可以看到已选择作为规则输出的单个表达式：&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：651px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/grafana-management-recording-rules/driven-recording-rule-output.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/grafana-management-recording-rules/management-recording-rule-output.png”data-srcset =“/media/blog/grafana-management-recording-rules/driven-recording-规则输出.png？w = 320 320w，/media/blog/grafana-管理-记录-规则/管理-记录-规则-输出.png？w = 550 550w， /media/blog/grafana-management-recording-rules/driven-recording-rule-output.png?w=750 750w，/media/blog/grafana-management-recording-rules/driven-recording-rule-output.png ?w=900 900w，/media/blog/grafana-management-recording-rules/driven-recording-rule-output.png?w=1040 1040w，/media/blog/grafana-管理-记录-规则/管理-记录-规则-输出.png？w=1240 1240w，/媒体/博客/grafana-管理-记录-规则/管理-记录-规则-输出.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;已选为规则输出的单个表达式的屏幕截图。&#34;width=&#34;651&#34;height=&#34;287&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/grafana-management-recording-rules/driven-recording-rule-output.png”&#xA;alt=&#34;已选为规则输出的单个表达式的屏幕截图。&#34;width=&#34;651&#34;height=&#34;287&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;这里，左侧表达式显示&lt;strong&gt;设置为记录规则输出&lt;/strong&gt;操作链接：&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1163px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/grafana-management-recording-rules/driven-recording-rule-set-as-output.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/grafana-management-recording-rules/management-recording-rule-set-as-output.png”data-srcset =“/media/blog/grafana-management-recording-rules/托管记录规则集as-output.png?w=320 320w, /media/blog/grafana-management-recording-rules/driven-recording-rule-set-as-output.png?w=550 550w，/media/blog/grafana-management-recording-rules/driven-recording-rule -set-as-output.png?w=750 750w, /media/blog/grafana-management-recording-rules/driven-recording-rule-set-as-output.png?w=900 900w，/media/blog/grafana-management-recording-rules/driven-recording-rule -set-as-output.png?w=1040 1040w, /media/blog/grafana-management-recording-rules/driven-recording-rule-set-as-output.png?w=1240 1240w，/media/blog/grafana-management-recording-rules/driven-recording-rule -set-as-output.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;表达式 exp 的屏幕截图显示设置为记录规则输出操作链接的ression。&#34;width=&#34;1163&#34;height=&#34;262&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/grafana-management-recording-rules/management-recording-rule-set-as-output.png”&#xA;alt=&#34;显示设置为记录规则输出操作链接的表达式屏幕截图。&#34;width=&#34;1163&#34;height=&#34;262&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;假设我们经常想要可视化多个 Kubernetes Pod 的 CPU 使用情况，并按命名空间细分。如果我们在多个仪表板中进行相同的查询，则记录它是有意义的：&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1168px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/grafana-management-recording-rules/driven-recording-rule-edit-rule.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/grafana-management-recording-rules/driven-recording-rule-edit-rule.png”data-srcset =“/media/blog/grafana-management-recording-rules/driven-录音规则编辑规则.png?w=320 320w，/media/blog/grafana-management-recording-rules/management-recording-rule-edit-rule.png?w=550 550w，/media/blog/grafana-托管-记录-规则/托管-记录-规则-编辑-rule.png？w = 750 750w，/media/博客/grafana-托管-记录-规则/托管-记录-规则-edit-rule.png?w=900 900w, /media/blog/grafana-management-recording-rules/driven-recording-rule-edit-rule.png?w=1040 1040w，/media/blog/grafana-management-recording-rules/driven-recording-rule-edit -rule.png?w=1240 1240w, /media/blog/grafana-管理-记录-规则/管理-记录-规则-编辑-rule.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;显示如何输入记录规则和指标名称的屏幕截图。&#34;width=&#34;1168&#34;height=&#34;570&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/grafana-management-recording-rules/management-recording-rule-edit-rule.png”&#xA;alt=&#34;显示如何输入记录规则和指标名称的屏幕截图。&#34;width=&#34;1168&#34;height=&#34;570&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;然后，我们可以使用 &lt;code&gt;my_recorded_kube_cpu_usage_by_namespace&lt;/code&gt; 引用该数据。以下是记录系列旁边的基础查询的样子：&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1999px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/grafana-management-recording-rules/management-recording-rule-recorded-and-query-data.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/grafana-management-recording-rules/management-recording-rule-recorded-and-query-data.png”data-srcset =“/media/blog/grafana-management-recording-规则/托管记录规则记录和查询数据.png?w=320 320w, /media/blog/grafana-management-recording-rules/driven-recording-rule-recorded-and-query-data.png?w=550 550w，/media/blog/grafana-management-recording-rules/driven-recording -规则记录ded-and-query-data.png?w=750 750w, /media/blog/grafana-management-recording-rules/driven-recording-rule-recorded-and-query-data.png?w=900 900w, /媒体/博客/grafana-管理-记录-规则/管理-记录-规则-记录-和-查询-data.png？w = 1040 1040w， /media/blog/grafana-management-recording-rules/driven-recording-rule-recorded-and-query-data.png?w=1240 1240w，/media/blog/grafana-management-recording-rules/driven-recording -规则记录和查询数据.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;显示记录系列旁边的基础查询的屏幕截图。&#34;width=&#34;1999&#34;height=&#34;858&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/grafana-management-recording-rules/management-recording-rule-recorded-and-query-data.png”&#xA;alt=&#34;显示记录系列旁边的基础查询的屏幕截图。&#34;width=&#34;1999&#34;height=&#34;858&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;您可以看到记录的数据紧随查询的数据。记录规则保存了原始查询的每个维度 - 与警报规则一样，您可以仅使用一个规则查询多个系列。&lt;/p&gt;&#xA;&lt;p&gt;请注意记录的系列如何继承原始查询的标签。这意味着您仍然可以像以前一样关联和过滤记录的数据！另请注意相同的标签匹配器如何适用于原始系列和录制的系列：&lt;code&gt;namespace=~&#34;kube-system|loki|robot-shop&#34;&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;当直接叠加到原始查询上时，记录的数据通常会存在“采样滞后”。这是因为记录规则每分钟运行一次，这可能与您从浏览器发出查询的时间不完全一致。这对于具有高方差的数据尤其常见。要减少采样延迟，请尝试增加记录规则的评估间隔。&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-about-enterprise-recorded-queries&#34;&gt;企业记录查询怎么样？&lt;/h2&gt;&#xA;&lt;p&gt;对于 Grafana Enterprise 用户来说，其中一些听起来可能有些熟悉，因为有一个企业记录查询 (ERQ) 功能可以记录一组有限的查询。但是，与 ERQ 相比，Grafana 管理的记录规则具有以下几个优点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;它们是开源的，可供所有 Grafana 用户使用。&lt;/li&gt;&#xA;&lt;li&gt;它们与 Grafana 警报引擎完全集成，这意味着可以更轻松地管理和操作它们，并在 Grafana 警报 UI 中进行配置。&lt;/li&gt;&#xA;&lt;li&gt;它们可以与 Grafana 警报规则一起混合和管理。&lt;/li&gt;&#xA;&lt;li&gt;可以使用与 Grafana 警报相同的配置机制将它们配置为代码。&lt;/li&gt;&#xA;&lt;li&gt;可以通过 RBAC 控制访问。&lt;/li&gt;&#xA;&lt;li&gt;它们适用于单主机和高可用性 (HA) Grafana 部署。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;目前，我们计划保留 ERQ 不变，但我们希望您尝试使用 Grafana 管理的记录规则作为替代方案。我们计划在未来将 ERQ 的剩余优势引入到记录规则中，包括每条规则可配置的 Prometheus 目标以及通过仪表板轻松创建。&lt;/p&gt;&#xA;&lt;p&gt;最终，我们跳Grafana 管理的记录规则成为 ERQ 的超集，此时我们希望在两者之间构建自动迁移路径，从而最终弃用 ERQ。目前，我们还没有计划执行此操作的日期。&lt;/p&gt;&#xA;&lt;h2 id=&#34;whats-next-for-recording-rules&#34;&gt;录制规则的下一步是什么？&lt;/h2&gt;&#xA;&lt;p&gt;未来，我们希望对这一强大的新功能进行多项改进：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;按规则配置目标数据源，允许您同时使用多个 Prometheus 目标，并通过 Grafana UI 将它们作为数据源而不是配置设置进行管理。&lt;/li&gt;&#xA;&lt;li&gt;对规则组中的规则进行顺序评估，使您能够确定性地混合具有强一致性的记录规则和警报规则，并与 Prometheus 规则实现更紧密的一致性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;此外，将此功能纳入 Grafana 警报保护伞下意味着记录规则会被采用&lt;a href=&#34;/blog/2023/03/06/grafana-alerting-12-ways-we-made-creating-and-managing -alerts-easier-than-ever/&#34;&gt;您已经从 Grafana Alerting 中享受到的许多改进&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;learn-more-about-grafana-alerting&#34;&gt;了解有关 Grafana 警报的更多信息&lt;/h2&gt;&#xA;&lt;p&gt;如果您想了解更多信息，请查看我们的&lt;a href=&#34;/docs/grafana/latest/alerting/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana 警报文档&lt;/a&gt;或&lt;a href =&#34;https://www.youtube.com/watch?v=7z5FwdfL7v4&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;观看有关 Grafana 演变的演讲来自 GrafanaCON 2024 的警报&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;p&gt;如果您想提供有关新记录规则的反馈，或者您只是想请求 Grafana Alerting 的新功能，请告诉我们！您可以通过在 &lt;a href=&#34;https://github.com/grafana/grafana&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt; Grafana GitHub 存储库&lt;/a&gt;中提出问题来完成此操作，或者通过询问在&lt;a href=&#34;https://grafana.slack.com/archives/C043CEX9MBK&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;#alerting 频道&lt;/a&gt;在 &lt;a href=&#34;https://slack.grafana.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Grafana Labs 社区 Slack&lt;/a&gt; 中。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt; 是开始使用指标、日志、跟踪和仪表板的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。&lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;plcmt=body-txt&#34;&gt;立即免费注册&lt;/a&gt;！ &lt;/em&gt;&lt;/p&gt;</description>
      <pubDate>Tue, 03 Dec 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Why companies choose Grafana Cloud over self-hosted OSS stacks】为什么公司选择 Grafana Cloud 而不是自托管 OSS 堆栈</title>
      <link>https://grafana.com/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/</link>
      <description>【&lt;p&gt;While we all love &lt;a href=&#34;/oss/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;open source technology&lt;/a&gt; and the &lt;a href=&#34;/blog/2023/12/12/the-story-of-grafana-documentary-the-community-behind-the-code/&#34;&gt;community&lt;/a&gt; that comes with it, we don’t always have the time or resources to stand up, maintain, update, and troubleshoot a self-hosted OSS stack.&lt;/p&gt;&#xA;&lt;p&gt;This is one of the (many) reasons companies choose to implement &lt;a href=&#34;/products/cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt;: you get all the goodness of the open source Grafana LGTM Stack (&lt;a href=&#34;/oss/loki/&#34;&gt;Loki&lt;/a&gt; for logs,&lt;a href=&#34;/oss/grafana?pg=blog&amp;amp;plcmt=body-txt&#34;&gt; Grafana&lt;/a&gt; for visualization,&lt;a href=&#34;/oss/tempo/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt; Tempo&lt;/a&gt; for traces,&lt;a href=&#34;/oss/mimir/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt; Mimir&lt;/a&gt; for metrics) in a fully managed, end-to-end observability platform.&lt;/p&gt;&#xA;&lt;p&gt;“With Grafana Cloud, there is very little to no maintenance,” said Omar Lopez, Head of Observability at SailPoint, during &lt;a href=&#34;/events/observabilitycon/2024/sailpoint-cost-efficiency-with-grafana-cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;a talk at ObservabilityCON 2024&lt;/a&gt;. “We let Grafana handle all the complexity that we were handling before, so we can spend that time on higher-priority initiatives.”&lt;/p&gt;&#xA;&lt;p&gt;Grafana Cloud also provides out-of-the-box, cutting-edge observability solutions like &lt;a href=&#34;/products/cloud/metrics/prometheus-cardinality-optimization/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Adaptive Metrics&lt;/a&gt;, a cardinality optimization feature that helps you identify and eliminate unused time series metrics to reduce overall observability costs.&lt;/p&gt;&#xA;&lt;p&gt;But why just take our word for it? In this post, observability practitioners share the top reasons they chose Grafana Cloud, most of which fall into three broad categories, and the benefits that ensued:&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;1. Reducing the burden of managing an observability stack&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks//#focus-more-on-apps-and-strategic-projects&#34;&gt;Focus more on apps and strategic projects&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#increase-security-for-customers&#34;&gt;Increase security for customers&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;2. Lowering observability costs&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#reduce-metrics-volume&#34;&gt;Reduce metrics volume&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#consolidate-tools&#34;&gt;Consolidate tools&lt;/a&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#reduce-metrics-volume&#34;&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;3. Supporting modern cloud architectures&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#optimize-hybrid-and-multi-cloud-deployments&#34;&gt;Optimize hybrid and multi-cloud deployments&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#enable-easier-migration-to-prometheus&#34;&gt;Enable easier migration to Prometheus&lt;/a&gt;&lt;a href=&#34;/blog/2023/10/16/why-companies-choose-grafana-cloud-over-self-managed-oss-stacks/#enable-easy-migration-to-prometheus&#34;&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;reducing-the-burden-of-managing-an-observability-stack&#34;&gt;Reducing the burden of managing an observability stack&lt;/h2&gt;&#xA;&lt;h3 id=&#34;focus-more-on-apps-and-strategic-projects&#34;&gt;Focus more on apps and strategic projects&lt;/h3&gt;&#xA;&lt;p&gt;The benefits of Grafana Cloud were almost instantaneous at The Trade Desk, a SaaS provider in the advertising and digital media space.&lt;/p&gt;&#xA;&lt;p&gt;“Query time immediately improved and many, many developers seemed to notice. Also, our reliability improved quite a bit,” said Patrick O’Brien, now a Senior Staff Software Engineer, SRE, at The Trade Desk. “We have zero storage nodes, which were the most expensive piece of that stack. Now we just have three nodes and everything feeds back to Grafana Labs.”&lt;/p&gt;&#xA;&lt;p&gt;In addition to saving the company money, the shift to Grafana Cloud spared the engineering department the headaches of troubleshooting. “Metrics usage frustration improved nearly overnight once we went with the hosted platform,” said Carl Johnson, now Senior Director, Production Engineering at The Trade Desk. “The reason we know it was a success is the complaints and frustrations internally stopped.&amp;quot;&lt;/p&gt;&#xA;&lt;p&gt;Added Johnson: “I think most of the ROI is really coming from time and labor savings. We can all say that what was once a time-sink was removed from our radar altogether.”&lt;/p&gt;&#xA;&lt;p&gt;Mux — a start-up that operates an API-first video platform designed to give development teams world-class video streaming and analytics capabilities — had a similar experience with Grafana Cloud.&lt;/p&gt;&#xA;&lt;p&gt;After struggling for years to maintain an in-house OSS stack (Elasticsearch, Kibana, Prometheus, Jaeger, Grafana) that left the team feeling too reactive and largely in maintenance mode, they knew it was time for a change. They also needed the ability to scale dynamically to accommodate unpredictable usage demands for compute-, network- and storage-intensive workloads.&lt;/p&gt;&#xA;&lt;p&gt;Ultimately, they turned to Grafana Cloud, in part because of their existing familiarity with Grafana OSS, but the payoff has been a lot more than an easy onramp.&lt;/p&gt;&#xA;&lt;p&gt;They’ve cut their metrics volume by 60% while also greatly expanding their data retention time, going from seven days to 30 days for traces and from 14 days to 13 months for metrics. This has helped Mux reduce noise, improve long-term analysis, and take a more proactive approach to incident management — all while keeping their costs level and their engineers engaged with more high-impact work.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1098px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link captioned&#34;&#xA;href=&#34;/media/blog/mux-success/ingest-job-logs.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload mb-0&#34;&#xA;data-src=&#34;/media/blog/mux-success/ingest-job-logs.png&#34;data-srcset=&#34;/media/blog/mux-success/ingest-job-logs.png?w=320 320w, /media/blog/mux-success/ingest-job-logs.png?w=550 550w, /media/blog/mux-success/ingest-job-logs.png?w=750 750w, /media/blog/mux-success/ingest-job-logs.png?w=900 900w, /media/blog/mux-success/ingest-job-logs.png?w=1040 1040w, /media/blog/mux-success/ingest-job-logs.png?w=1240 1240w, /media/blog/mux-success/ingest-job-logs.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A graph showing ingest job logs at Mux.&#34;width=&#34;1098&#34;height=&#34;665&#34;title=&#34;*A graph showing ingest job logs at Mux.*&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/mux-success/ingest-job-logs.png&#34;&#xA;alt=&#34;A graph showing ingest job logs at Mux.&#34;width=&#34;1098&#34;height=&#34;665&#34;title=&#34;*A graph showing ingest job logs at Mux.*&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;figcaption class=&#34;w-100p caption text-gray-13 &#34;&gt;&lt;em&gt;A graph showing ingest job logs at Mux.&lt;/em&gt;&lt;/figcaption&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;“Grafana Cloud probably saves us hundreds of engineering hours a year,” said Ryan Grothouse, VP, Engineering at Mux. “Our platform engineers don’t have to manage the stack any more, and our product engineers don’t have to work through multiple observability tools, which used to really slow down our response times.”&lt;/p&gt;&#xA;&lt;p&gt;Read more about how Grafana Cloud has saved engineering hours at both &lt;a href=&#34;/blog/2024/07/22/how-mux-cut-metrics-volume-by-60-increased-retention-times-and-improved-developer-productivity-with-grafana-cloud/&#34;&gt;Mux &lt;/a&gt;and &lt;a href=&#34;/success/thetradedesk/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;The Trade Desk&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h3 id=&#34;increase-security-for-customers&#34;&gt;Increase security for customers&lt;/h3&gt;&#xA;&lt;p&gt;Sometimes you just want more of a good thing. That’s the case at Royal IHC, which used Grafana OSS to create dashboards for their customers as part of integrated solutions that improve operational efficiency for maritime fleets around the world.&lt;/p&gt;&#xA;&lt;p&gt;Guus Derksen, a Royal IHC project leader, was so happy with the dashboards his team was able to create that he wanted to expand their offerings with Grafana Cloud Advanced, which provides built-in security and access features for their clients.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link captioned&#34;&#xA;href=&#34;/static/assets/img/blog/royal-ihc-dashboard.jpg?w=1240&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload mb-0&#34;&#xA;data-src=&#34;/static/assets/img/blog/royal-ihc-dashboard.jpg?w=1240&#34;alt=&#34;A Roya IHC dashboard showcasing key metrics.&#34;title=&#34;*A Royal IHC dashboard showcasing key metrics.*&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/static/assets/img/blog/royal-ihc-dashboard.jpg?w=1240&#34;&#xA;alt=&#34;A Roya IHC dashboard showcasing key metrics.&#34;title=&#34;*A Royal IHC dashboard showcasing key metrics.*&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;figcaption class=&#34;w-100p caption text-gray-13 &#34;&gt;&lt;em&gt;A Royal IHC dashboard showcasing key metrics.&lt;/em&gt;&lt;/figcaption&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;There are a lot more opportunities for growth and evolution at Royal IHC, which is possible because Grafana Cloud also maintains everything for their individual clients. “It was quite user-friendly,” said Derksen. “It definitely gave us the right direction to move in with the development we are going through in general.”&lt;/p&gt;&#xA;&lt;p&gt;Learn more about &lt;a href=&#34;/success/royal-ihc/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Royal IHC’s observability journey with Grafana Cloud Advanced&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;lowering-observability-costs&#34;&gt;Lowering observability costs&lt;/h2&gt;&#xA;&lt;h3 id=&#34;reduce-metrics-volume&#34;&gt;Reduce metrics volume&lt;/h3&gt;&#xA;&lt;p&gt;Despite initial success with Prometheus and Grafana, SailPoint — a leader in identity management solutions — reached limits with scaling, leading to performance challenges and rising maintenance costs. After evaluating options through their internal DACI decision-making framework, SailPoint chose Grafana Cloud for its scalability, built-in support, and reduced maintenance overhead.&lt;/p&gt;&#xA;&lt;p&gt;The company’s use of Grafana Cloud Adaptive Metrics, combined with the efforts of the engineering team, also helped SailPoint achieve a 50% reduction in active metric series — from 75 million to 37.5 million.&lt;/p&gt;&#xA;&lt;p&gt;With Adaptive Metrics, “we could reduce metrics while we continue to grow,” said Omar Lopez, Head of Observability, &lt;a href=&#34;/events/observabilitycon/2024/sailpoint-cost-efficiency-with-grafana-cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;at ObservabilityCON 2024&lt;/a&gt;. “We&amp;rsquo;re still starting up new customers, we&amp;rsquo;re still writing new features, deploying new microservices, and opening up new regions. All that growth is still happening, but at the same time, we&amp;rsquo;re reducing our metric count. It blows my mind.”&lt;/p&gt;&#xA;&lt;p&gt;SailPoint is now exploring additional Grafana Cloud features, such as &lt;a href=&#34;/products/cloud/synthetic-monitoring/&#34;&gt;Synthetic Monitoring&lt;/a&gt; for performance testing and &lt;a href=&#34;/products/cloud/asserts/&#34;&gt;Asserts&lt;/a&gt; to enhance their monitoring capabilities.&lt;/p&gt;&#xA;&lt;p&gt;TeleTracking, an integrated healthcare operations platform provider, has seen similar success with Adaptive Metrics. Despite some initial skepticism from the observability team, who feared that removing or aggregating metrics might disrupt critical services or hinder visibility, the company has reduced its telemetry costs by 50% — a reduction that has helped advance TeleTracking’s observability strategy in other significant ways.&lt;/p&gt;&#xA;&lt;p&gt;“Thanks to 50% savings on our telemetry bill with Adaptive Metrics, we had room in our budget to fund Grafana IRM, and now we spend less time on our incident workflow, including post-mortems,” said Oren Lion, Director of Software Engineering, Productivity Engineering at TeleTracking &lt;a href=&#34;/events/observabilitycon/2024/teletracking-future-proof-observability-with-grafana-cloud/&#34;&gt;at ObservabilityCON 2024&lt;/a&gt;.&lt;br /&gt;&#xA;&lt;br /&gt;&#xA;Because of the wins they&amp;rsquo;ve seen with Adaptive Metrics, TeleTracking also became an early adopter of &lt;a href=&#34;/blog/2024/09/24/introducing-adaptive-logs/&#34;&gt;Adaptive Logs&lt;/a&gt;, a Grafana Cloud feature that helps you lower your observability costs by reducing the volume of unnecessary logs.&lt;br /&gt;&#xA;&lt;br /&gt;&#xA;“Adaptive Logs helps reduce noise, making it easier to spot valuable logs and ultimately saves us costs,” said Andrew Qu, Software Engineer II at TeleTracking, who is already seeing a 50% reduction in log volumes.&lt;/p&gt;&#xA;&lt;h3 id=&#34;consolidate-tools&#34;&gt;Consolidate tools&lt;/h3&gt;&#xA;&lt;p&gt;Ultimate AI is an industry-leading customer support automation platform that helps companies improve customer satisfaction and increase efficiency with AI. Ultimate’s incident response, however, was anything but automatic prior to adopting Grafana Cloud.&lt;/p&gt;&#xA;&lt;p&gt;Though they were already Grafana OSS users, it wasn’t heavily used because the company had dashboards, logs, and on-call information spread across multiple applications — and the same could be said for their observability bills. “We were spreading our money across multiple different tools and [the system] was indeed doing its job, but it took a lot of cognitive load for developers to actually understand all of those tools,” said a senior software engineer at Ultimate AI.&lt;/p&gt;&#xA;&lt;p&gt;They eventually centralized on-call management in Grafana IRM, and then quickly built out their managed stack on Grafana Cloud to include &lt;a href=&#34;/products/cloud/logs/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud Logs&lt;/a&gt; and &lt;a href=&#34;/products/cloud/k6/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud k6&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Learn more about how &lt;a href=&#34;/blog/2023/06/30/how-ultimate-improved-workflow-adoption-and-more-with-grafana-irm/&#34;&gt;Ultimate AI leverages Grafana Cloud&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;supporting-modern-cloud-architectures&#34;&gt;Supporting modern cloud architectures&lt;/h2&gt;&#xA;&lt;h3 id=&#34;optimize-hybrid-and-multi-cloud-deployments&#34;&gt;Optimize hybrid and multi-cloud deployments&lt;/h3&gt;&#xA;&lt;p&gt;Booking.com, one of the world’s leading digital travel companies, had a proprietary observability stack that consisted of multiple, disparate tools, redundant storage, and fragmented telemetry. While it served the company well for years, it couldn’t adequately support their complex multi-cloud and hybrid cloud infrastructure.&lt;/p&gt;&#xA;&lt;p&gt;“We are a multi-cloud company,” said Murugesan Ramaiah, Solutions Architect at Booking.com, during a &lt;a href=&#34;/events/observabilitycon-on-the-road/2024/london/bookingcom-agnostic-observability/&#34;&gt;talk at ObservabilityCON on the Road in London&lt;/a&gt;. “Our applications are running on AWS, but also on Google, on-premises within Kubernetes, and on EKS. We have a machine learning platform, a gen AI platform, and a data platform. We are a technology-driven travel company, and there are a lot of telemetry agents.”&lt;/p&gt;&#xA;&lt;p&gt;To modernize and centralize their observability strategy, the team moved to Grafana Cloud. They integrated Grafana’s centralized telemetry pipeline using &lt;a href=&#34;/oss/opentelemetry/&#34;&gt;OpenTelemetry&lt;/a&gt;, which simplified data gathering and enabled vendor-agnostic monitoring across environments.&lt;/p&gt;&#xA;&lt;p&gt;For metrics and logging, Booking.com deployed &lt;a href=&#34;/products/cloud/metrics/&#34;&gt;Grafana Cloud Metrics&lt;/a&gt; and &lt;a href=&#34;/products/cloud/logs/&#34;&gt;Grafana Cloud Logs&lt;/a&gt;, which now manage over 85 million metrics. The company also implemented &lt;a href=&#34;/products/cloud/profiles-for-continuous-profiling/&#34;&gt;Grafana Cloud Profiles&lt;/a&gt; to gain real-time visibility into application performance, helping them enhance both the customer experience and application performance.&lt;/p&gt;&#xA;&lt;p&gt;“The reason we chose Grafana Labs is because they align with our strategy — they natively support OpenTelemetry, and we want to work with somebody who built a product born in the cloud, for the cloud,” Ramaiah said.&lt;/p&gt;&#xA;&lt;h3 id=&#34;enable-easier-migration-to-prometheus&#34;&gt;Enable easier migration to Prometheus&lt;/h3&gt;&#xA;&lt;p&gt;At Kambi, they had a “pretty standard” setup for Graphite that was based on Python. As the leading independent provider of premium sports betting technology and services within the global regulated betting and gaming industry, Kambi had an infrastructure that included around 500 services feeding into an HAProxy that divided the load between six instances of carbon-relay. Carbon-relay nodes then forwarded it to the carbon-cache nodes, which stored the actual data as whisper files.&lt;/p&gt;&#xA;&lt;p&gt;Soon, however, issues began popping up. Their disk space, CPU, and even RAM were running out. Kambi SRE Frank Stengård’s team also discovered that in Graphite, many metrics were being sent at more frequent intervals than they were actually stored at, and the values were zeros or mostly zeros. As Stengård put it: “The house was burning now. We needed to fix it.”&lt;/p&gt;&#xA;&lt;p&gt;To battle their three-alarm fire, Stengård and his team decided to modify Hadrianus, their own open source application-aware firewall load-balancer, to send Kambi data in a mirror replica to a third-party provider. Since Kambi was already a Grafana OSS fan, they decided to test sending all of the production data straight to Grafana Cloud — and to their pleasant surprise, the hosted platform was able to handle their telemetry load.&lt;/p&gt;&#xA;&lt;p&gt;The company also decided they wanted to use Prometheus instead of Graphite because of its more popular support and the fact that it worked better in Kubernetes. Grafana Cloud was also a good fit because it not only supports Graphite; it also enabled an easy migration path to Prometheus, which the team did over time.&lt;/p&gt;&#xA;&lt;p&gt;Watch &lt;a href=&#34;/blog/2021/11/26/how-kambi-migrated-from-an-in-house-graphite-solution-to-grafana-cloud/&#34;&gt;Kambi’s deep dive into their Prometheus migration with Grafana Cloud&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt; is the easiest way to get started with metrics, logs, traces, dashboards, and more. We have a generous forever-free tier and plans for every use case. &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Sign up for free now!&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;】&lt;p&gt;虽然我们都喜欢&lt;a href=&#34;/oss/?pg=blog&amp;plcmt=body-txt&#34;&gt;开源技术&lt;/a&gt;和&lt;a href=&#34;/blog/2023/12/12/the-随之而来的story-of-grafana-documentary-the-community-behind-the-code/&#34;&gt;社区&lt;/a&gt;，我们并不总是有时间或资源来站出来、维护、更新和排除故障一个自托管 OSS 堆栈。&lt;/p&gt;&#xA;&lt;p&gt;这是公司选择实施 &lt;a href=&#34;/products/cloud/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt; 的（众多）原因之一：您可以获得 Grafana Cloud 的所有优点开源 Grafana LGTM Stack（&lt;a href=&#34;/oss/loki/&#34;&gt;Loki&lt;/a&gt; 用于日志，&lt;a href=&#34;/oss/grafana?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana&lt;/a&gt;为了可视化，&lt;a href=&#34;/oss/tempo/?pg=blog&amp;plcmt=body-txt&#34;&gt;轨迹速度&lt;/a&gt;，&lt;a href=&#34;/oss/mimir/?pg=blog&amp;plcmt=body-txt&#34;&gt; Mimir&lt;/a&gt; 指标）位于完全托管的端到端可观察性平台中。&lt;/p&gt;&#xA;&lt;p&gt;“使用 Grafana Cloud，几乎不需要维护，”SailPoint 可观测性主管 Omar Lopez 在 &lt;a href=&#34;/events/observabilitycon/2024/sailpoint-cost-efficiency-with-grafana- cloud/?pg=blog&amp;plcmt=body-txt&#34;&gt;ObservabilityCON 2024 上的演讲&lt;/a&gt;。 “我们让 Grafana 处理我们之前处理的所有复杂性，这样我们就可以将时间花在优先级更高的计划上。”&lt;/p&gt;&#xA;&lt;p&gt;Grafana Cloud 还提供开箱即用的尖端可观测性解决方案，例如 &lt;a href=&#34;/products/cloud/metrics/prometheus-cardinality-optimization/?pg=blog&amp;plcmt=body-txt&#34;&gt;Adaptive指标&lt;/a&gt;，一种基数优化功能，可帮助您识别和消除未使用的时间序列指标，以降低总体可观测性成本。&lt;/p&gt;&#xA;&lt;p&gt;但为什么只相信我们的话呢？在这篇文章中，可观察性从业者分享了他们选择 Grafana Cloud 的主要原因，其中大部分分为三大类，以及随之而来的好处：&lt;/p&gt;&#xA;&lt;p&gt;&lt;强&gt;1。减轻管理可观察性堆栈的负担&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks//#focus-more-on-apps-and-strategic -projects&#34;&gt;更多地关注应用和战略项目&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#increase-security-for-customers&#34;&gt;提高安全性客户&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;强&gt;2。降低可观测性成本&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#reduce-metrics-volume&#34;&gt;减少指标量&lt;/一个&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#consolidate-tools&#34;&gt;整合工具&lt;/a&gt;&lt;一个href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#reduce-metrics-volume&#34;&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;强&gt;3。支持现代云架构&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#optimize-hybrid-and-multi-cloud-deployments&#34; &gt;优化混合动力和多云部署&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#enable-easier-migration-to-prometheus&#34;&gt;启用更轻松地迁移到 Prometheus&lt;/a&gt;&lt;a href=&#34;/blog/2023/10/16/why-companies-choose-grafana-cloud-over-self-management-oss-stacks/#enable-easy-migration-to-prometheus&#34;&gt;&lt;/a&gt;&lt;/李&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;reducing-the-burden-of-managing-an-observability-stack&#34;&gt;减轻管理可观察性堆栈的负担&lt;/h2&gt;&#xA;&lt;h3 id=&#34;focus-more-on-apps-and-strategic-projects&#34;&gt;更多地关注应用和战略项目&lt;/h3&gt;&#xA;&lt;p&gt;对于广告和数字媒体领域的 SaaS 提供商 The Trade Desk，Grafana Cloud 的好处几乎是立竿见影的。&lt;/p&gt;&#xA;&lt;p&gt;“查询时间立即得到改善，许多开发人员似乎都注意到了。此外，我们的可靠性也得到了很大提高。”现任 The Trade Desk 的 SRE 高级软件工程师 Patrick O’Brien 说道。 “我们的存储节点为零，这是该堆栈中最昂贵的部分。现在我们只有三个节点，所有内容都会反馈给 Grafana Labs。”&lt;/p&gt;&#xA;&lt;p&gt;除了为公司节省资金之外，转向 Grafana Cloud 还让工程部门免去了故障排除的麻烦。 “一旦我们使用托管平台，指标使用的挫败感几乎在一夜之间得到改善，”现任 The Trade Desk 生产工程高级总监 Carl Johnson 说道。 “我们知道这是成功的原因是内部的抱怨和挫败感停止了。”&lt;/p&gt;&#xA;&lt;p&gt;约翰逊补充道：“我认为大部分投资回报率实际上来自时间和劳动力的节省。我们都可以说，曾经的时间槽已经从我们的雷达中完全消失了。”&lt;/p&gt;&#xA;&lt;p&gt;Mux 是一家运营 API 优先视频平台的初创公司，旨在为开发团队提供世界一流的视频流和分析功能，它在 Grafana Cloud 上也有类似的经历。&lt;/p&gt;&#xA;&lt;p&gt;多年来一直在努力维护内部 OSS 堆栈（Elasticsearch、Kibana、Prometheus、Jaeger、Grafana），这让团队感觉过于被动且主要处于维护模式，他们知道是时候做出改变了。他们还需要能够动态扩展，以适应计算、网络和存储密集型工作负载的不可预测的使用需求。&lt;/p&gt;&#xA;&lt;p&gt;最终，他们转向了 Grafana Cloud，部分原因是他们对 Grafana OSS 已经很熟悉，但回报远不止是一个简单的入门。&lt;/p&gt;&#xA;&lt;p&gt;他们将指标量减少了 60%，同时还大大延长了数据保留时间，跟踪从 7 天延长到 30 天，指标从 14 天延长到 13 个月。这帮助 Mux 降低了噪音、改进了长期分析并采取了更主动的事件管理方法，同时保持了成本水平并让工程师参与了更具影响力的工作。&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1098px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;项目pe=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;一个&#xA;类=“灯箱链接标题”&#xA;href=&#34;/media/blog/mux-success/ingest-job-logs.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“lazyload mb-0”&#xA;data-src =“/media/blog/mux-success/ingest-job-logs.png”data-srcset =“/media/blog/mux-success/ingest-job-logs.png？w = 320 320w，/媒体/博客/mux-success/ingest-job-logs.png?w=550 550w, /media/blog/mux-success/ingest-job-logs.png?w=750 750w, /media/blog/mux-success/ingest-job-logs.png?w=900 900w, /media/blog/mux -成功/摄取作业日志.png?w=1040 1040w, /media/blog/mux-success/ingest-job-logs.png?w=1240 1240w, /media/blog/mux-success/ingest-job-logs.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;显示 Mux 上的摄取作业日志的图表。&#34;width=&#34;1098&#34;height=&#34;665&#34;title=&#34;*显示 Mux 上的摄取作业日志的图表。*&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/mux-success/ingest-job-logs.png”&#xA;alt=&#34;显示 Mux 上的摄取作业日志的图表。&#34;width=&#34;1098&#34;height=&#34;665&#34;title=&#34;*显示 Mux 上的摄取作业日志的图表。*&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;figcaption class=&#34;w-100p title text-gray-13 &#34;&gt;&lt;em&gt;显示 Mux 采集作业日志的图表。&lt;/em&gt;&lt;/figcaption&gt;&lt;/a&gt;&lt;/图&gt;&#xA;&lt;p&gt;“Grafana Cloud 可能每年为我们节省数百个工程时间，”Mux 工程副总裁 Ryan Grothouse 说道。 “我们的平台工程师不必再管理堆栈，我们的产品工程师也不必使用多种可观察性工具，这实际上会减慢我们的响应时间。”&lt;/p&gt;&#xA;&lt;p&gt;详细了解 Grafana Cloud 如何节省工程时间，请访问 &lt;a href=&#34;/blog/2024/07/22/how-mux-cut-metrics-volume-by-60-increased-retention-times-and -improved-developer-productivity-with-grafana-cloud/&#34;&gt;Mux &lt;/a&gt; 和 &lt;a href=&#34;/success/thetradedesk/?pg=blog&amp;plcmt=body-txt&#34;&gt;交易台&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;increase-security-for-customers&#34;&gt;提高客户的安全性&lt;/h3&gt;&#xA;&lt;p&gt;有时您只是想要更多好东西。 Royal IHC 就是这种情况，该公司使用 Grafana OSS 为其客户创建仪表板，作为提高世界各地海运船队运营效率的集成解决方案的一部分。&lt;/p&gt;&#xA;&lt;p&gt;Royal IHC 项目负责人 Guus Derksen 对他的团队能够创建的仪表板非常满意，因此他希望通过 Grafana Cloud Advanced 来扩展他们的产品，Grafana Cloud Advanced 为客户提供了内置的安全性和访问功能。&lt; /p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接标题”&#xA;href=&#34;/static/assets/img/blog/royal-ihc-dashboard.jpg?w=1240&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“lazyload mb-0”&#xA;data-src=&#34;/static/assets/img/blog/royal-ihc-dashboard.jpg?w=1240&#34;alt=&#34;显示关键指标的 Roya IHC 仪表板。&#34;title=&#34;*显示关键指标的 Royal IHC 仪表板。 *&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/static/assets/img/blog/royal-ihc-dashboard.jpg?w=1240&#34;&#xA;alt=&#34;A Roya IHC dashb显示关键指标的仪表板。&#34;title=&#34;*显示关键指标的 Royal IHC 仪表板。*&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;figcaption class=&#34;w-100p title text-gray-13 &#34;&gt;&lt;em&gt;皇家 IHC 仪表板展示关键指标。&lt;/em&gt;&lt;/figcaption&gt;&lt;/a&gt;&lt;/figure &gt;&#xA;&lt;p&gt;Royal IHC 有更多的成长和发展机会，这是可能的，因为 Grafana Cloud 还为其个人客户维护一切。 “它非常用户友好，”德克森说。 “这无疑为我们提供了正确的方向，以适应我们正在经历的总体发展。”&lt;/p&gt;&#xA;&lt;p&gt;详细了解&lt;a href=&#34;/success/royal-ihc/?pg=blog&amp;plcmt=body-txt&#34;&gt;Royal IHC 使用 Grafana Cloud Advanced 的可观测性之旅&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;lowering-observability-costs&#34;&gt;降低可观测性成本&lt;/h2&gt;&#xA;&lt;h3 id=&#34;reduce-metrics-volume&#34;&gt;减少指标量&lt;/h3&gt;&#xA;&lt;p&gt;尽管 Prometheus 和 Grafana 取得了初步成功，身份管理解决方案的领导者 SailPoint 在扩展方面却达到了极限，导致性能挑战和维护成本上升。在通过内部 DACI 决策框架评估选项后，SailPoint 选择 Grafana Cloud，因为它具有可扩展性、内置支持和减少的维护开销。&lt;/p&gt;&#xA;&lt;p&gt;该公司使用 Grafana Cloud Adaptive Metrics，再加上工程团队的努力，还帮助 SailPoint 将活跃指标系列减少了 50%，从 7500 万减少到 3750 万。&lt;/p&gt;&#xA;&lt;p&gt;借助自适应指标，“我们可以在持续增长的同时减少指标”，&lt;a href=&#34;/events/observabilitycon/2024/sailpoint-cost-efficiency-with-grafana-cloud”可观测性主管 Omar Lopez 说道/?pg=blog&amp;plcmt=body-txt&#34;&gt;ObservabilityCON 2024&lt;/a&gt;。 “我们仍在开发新客户，仍在编写新功能，部署新微服务，并开辟新区域。所有这些增长仍在发生，但与此同时，我们正在减少指标数量。这让我大吃一惊。”&lt;/p&gt;&#xA;&lt;p&gt;SailPoint 目前正在探索其他 Grafana Cloud 功能，例如用于性能测试的&lt;a href=&#34;/products/cloud/synthetic-monitoring/&#34;&gt;综合监控&lt;/a&gt;和&lt;a href=&#34;/products/cloud/断言/&#34;&gt;断言&lt;/a&gt;以增强其监控能力。&lt;/p&gt;&#xA;&lt;p&gt;TeleTracking 是一家综合医疗保健运营平台提供商，在 Adaptive Metrics 方面也取得了类似的成功。尽管可观测性团队最初持怀疑态度，担心删除或聚合指标可能会破坏关键服务或阻碍可见性，但该公司已将遥测成本降低了 50%，这一降低有助于以其他重要方式推进 TeleTracking 的可观测性策略。&lt; /p&gt;&#xA;&lt;p&gt;“借助 Adaptive Metrics，我们的遥测费用节省了 50%，我们的预算中有足够的空间来资助 Grafana IRM，现在我们花在事件工作流程（包括事后分析）上的时间更少了，”总监 Oren Lion 说道TeleTrack 软件工程、生产力工程系&lt;a href=&#34;/events/observabilitycon/2024/teletracking-future-proof-observability-with-grafana-cloud/&#34;&gt;在 ObservabilityCON 2024&lt;/a&gt;。&lt;br /&gt;&#xA;&lt;br/&gt;&#xA;由于他们在自适应指标方面取得的胜利，TeleTracking 也成为了 &lt;a href=&#34;/blog/2024/09/24/introducing-adaptive-logs/&#34;&gt;自适应日志&lt;/a&gt;（Grafana 的一个）的早期采用者云功能可通过减少不必要的日志量来帮助您降低可观测性成本。&lt;br /&gt;&#xA;&lt;br/&gt;&#xA;TeleTracking 的二级软件工程师 Andrew Qu 表示：“自适应日志有助于减少噪音，让我们更容易发现有价值的日志，并最终节省我们的成本。”他已经看到日志量减少了 50%。&lt;/p&gt;&#xA;&lt;h3 id=&#34;consolidate-tools&#34;&gt;整合工具&lt;/h3&gt;&#xA;&lt;p&gt;Ultimate AI 是行业领先的客户支持自动化平台，可帮助公司通过 AI 提高客户满意度并提高效率。然而，在采用 Grafana Cloud 之前，Ultimate 的事件响应绝非自动的。&lt;/p&gt;&#xA;&lt;p&gt;虽然他们已经是 Grafana OSS 用户，但它并没有被大量使用，因为该公司的仪表板、日志和待命信息分布在多个应用程序中 - 他们的可观察性账单也是如此。 Ultimate AI 的一位高级软件工程师表示：“我们将资金分散到多种不同的工具上，[系统]确实在完成其工作，但开发人员需要承受大量的认知负担才能真正理解所有这些工具。”&lt; /p&gt;&#xA;&lt;p&gt;他们最终将待命管理集中在 Grafana IRM 中，然后在 Grafana Cloud 上快速构建托管堆栈，以包含 &lt;a href=&#34;/products/cloud/logs/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud Logs&lt;/a&gt; 和 &lt;a href=&#34;/products/cloud/k6/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud k6&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;p&gt;详细了解&lt;a href=&#34;/blog/2023/06/30/how-ultimate-improved-workflow-adoption-and-more-with-grafana-irm/&#34;&gt;Ultimate AI 如何利用 Grafana Cloud&lt;/一个&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;supporting-modern-cloud-architectures&#34;&gt;支持现代云架构&lt;/h2&gt;&#xA;&lt;h3 id=&#34;optimize-hybrid-and-multi-cloud-deployments&#34;&gt;优化混合云和多云部署&lt;/h3&gt;&#xA;&lt;p&gt;Booking.com 是世界领先的数字旅游公司之一，拥有专有的可观测性堆栈，其中包括多个不同的工具、冗余存储和分散的遥测技术。虽然它多年来为公司提供了良好的服务，但无法充分支持其复杂的多云和混合云基础设施。&lt;/p&gt;&#xA;&lt;p&gt;“我们是一家多云公司，”Booking.com 解决方案架构师 Murugesan Ramaiah 在 &lt;a href=&#34;/events/observabilitycon-on-the-road/2024/london/bookingcom-agnostic- observability/&#34;&gt;在伦敦举行的 ObservabilityCON on the Road 上的演讲&lt;/a&gt;。 “我们的应用程序不仅在 AWS 上运行，也在 Google、Kubernetes 内的本地以及 EKS 上运行。我们有机器学习平台、gen AI平台、数据平台。我们是一家技术驱动的旅游公司，有很多遥测代理s。”&lt;/p&gt;&#xA;&lt;p&gt;为了实现可观察性策略的现代化和集中化，团队迁移到了 Grafana Cloud。他们使用 &lt;a href=&#34;/oss/opentelemetry/&#34;&gt;OpenTelemetry&lt;/a&gt; 集成了 Grafana 的集中式遥测管道，从而简化了数据收集并实现了跨环境的供应商无关监控。&lt;/p&gt;&#xA;&lt;p&gt;对于指标和日志记录，Booking.com 部署了 &lt;a href=&#34;/products/cloud/metrics/&#34;&gt;Grafana Cloud Metrics&lt;/a&gt; 和 &lt;a href=&#34;/products/cloud/logs/&#34;&gt;Grafana Cloud日志&lt;/a&gt;，现在管理超过 8500 万个指标。该公司还实施了 &lt;a href=&#34;/products/cloud/profiles-for-continuous-profiling/&#34;&gt;Grafana Cloud Profiles&lt;/a&gt; 来实时了解应用程序性能，帮助他们增强客户体验和应用程序性能。&lt;/p&gt;&#xA;&lt;p&gt;“我们选择 Grafana Labs 的原因是因为他们符合我们的战略——他们本身就支持 OpenTelemetry，我们希望与那些在云中构建产品、为云服务的人合作，”Ramaiah 说。&lt;/p &gt;&#xA;&lt;h3 id=&#34;enable-easier-migration-to-prometheus&#34;&gt;更轻松地迁移到 Prometheus&lt;/h3&gt;&#xA;&lt;p&gt;在 Kambi，他们有一个基于 Python 的“相当标准”的 Graphite 设置。作为全球受监管的博彩和游戏行业中领先的优质体育博彩技术和服务的独立提供商，Kambi 拥有一个基础设施，其中包括大约 500 项服务，这些服务馈入 HAProxy，在六个碳中继实例之间分配负载。然后 Carbon 中继节点将其转发到 Carbon 缓存节点，后者将实际数据存储为耳语文件。&lt;/p&gt;&#xA;&lt;p&gt;然而，很快问题就开始出现。他们的磁盘空间、CPU 甚至 RAM 都快用完了。 Kambi SRE Frank Stengård 的团队还发现，在 Graphite 中，许多指标的发送间隔比实际存储的间隔更频繁，并且值为零或大部分为零。正如斯坦加德所说：“房子现在正在燃烧。我们需要修复它。”&lt;/p&gt;&#xA;&lt;p&gt;为了对抗三级警报，Stengård 和他的团队决定修改 Hadrianus（他们自己的开源应用程序感知防火墙负载平衡器），将镜像副本中的 Kambi 数据发送给第三方提供商。由于 Kambi 已经是 Grafana OSS 的粉丝，他们决定测试将所有生产数据直接发送到 Grafana Cloud - 令他们惊喜的是，托管平台能够处理他们的遥测负载。&lt;/p&gt;&#xA;&lt;p&gt;该公司还决定使用 Prometheus 而不是 Graphite，因为它更受欢迎，而且它在 Kubernetes 中运行得更好。 Grafana Cloud 也很适合，因为它不仅支持 Graphite，还支持 Graphite。它还实现了到 Prometheus 的轻松迁移路径，团队随着时间的推移做到了这一点。&lt;/p&gt;&#xA;&lt;p&gt;观看&lt;a href=&#34;/blog/2021/11/26/how-kambi-migrate-from-an-in-house-graphite-solution-to-grafana-cloud/&#34;&gt;Kambi 深入研究 Prometheus使用 Grafana Cloud 进行迁移&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt; 是开始使用指标、日志、跟踪、仪表板等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。 &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;plcmt=body-txt&#34;&gt;立即免费注册！&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</description>
      <pubDate>Tue, 26 Nov 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【5 tips to write better browser tests for performance testing and synthetic monitoring】编写更好的浏览器测试以进行性能测试和综合监控的 5 个技巧</title>
      <link>https://grafana.com/blog/2024/11/21/5-tips-to-write-better-browser-tests-for-performance-testing-and-synthetic-monitoring/</link>
      <description>【&lt;p&gt;Given the complexity of modern websites, browser testing is essential to ensure a positive user experience. With the &lt;a href=&#34;/docs/k6/latest/using-k6-browser/&#34;&gt;Grafana k6 browser module&lt;/a&gt;, you can interact with real web browsers and simulate user interactions — like clicking, typing, or navigating pages — to collect frontend metrics, increase site reliability, and fix performance issues before they ever impact your users.&lt;/p&gt;&#xA;&lt;p&gt;Part of &lt;a href=&#34;/oss/k6/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana k6 OSS&lt;/a&gt;, the k6 browser module is also compatible with our fully managed &lt;a href=&#34;/products/cloud/k6/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud k6&lt;/a&gt; solution, as well as &lt;a href=&#34;/products/cloud/synthetic-monitoring/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud Synthetic Monitoring&lt;/a&gt;, for out-of-the-box monitoring capabilities. This means you can re-use your browser testing scripts across those three environments, based on your testing needs.&lt;/p&gt;&#xA;&lt;p&gt;With an API that’s similar to &lt;a href=&#34;https://playwright.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Playwright’s&lt;/a&gt;, the k6 browser module makes it easy for those familiar with the Playwright web testing framework to write their first browser tests. That said, we know a few best practices can go a long way when it comes to authoring browser test scripts and integrating them into your workflow.&lt;/p&gt;&#xA;&lt;p&gt;In this blog, we outline five tips you can apply today to write better browser tests in Grafana k6, Grafana Cloud k6, and Grafana Cloud Synthetic Monitoring.&lt;/p&gt;&#xA;&lt;h2 id=&#34;tip-1-run-the-test-locally-for-a-faster-feedback-loop&#34;&gt;Tip 1. Run the test locally for a faster feedback loop&lt;/h2&gt;&#xA;&lt;p&gt;Our cloud offerings, including Grafana Cloud k6 and Synthetic Monitoring, are the best way to visualize the output of your script, but running tests locally on your machine is a great way to debug and iterate faster. To get started you will want to:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/docs/k6/latest/set-up/install-k6/&#34;&gt;Install Grafana k6 on your machine&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;Have Chrome (or a &lt;a href=&#34;https://alternativeto.net/category/browsers/chromium-based/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Chromium-based browser&lt;/a&gt;) available&lt;/li&gt;&#xA;&lt;li&gt;Set up an empty directory&lt;/li&gt;&#xA;&lt;li&gt;Create a script with the &lt;a href=&#34;/docs/k6/latest/using-k6/scenarios/executors/shared-iterations/&#34;&gt;&lt;code&gt;shared-iterations&lt;/code&gt; executor&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;For the purposes of debugging browser scripts locally, ensure your test scenario is only going to run one virtual user (VU) and one iteration. The &lt;code&gt;shared-iterations&lt;/code&gt; executor has these options set by default, so is the perfect choice for debugging. You can run tests quickly, read your logs output, and reduce the feedback loop as you author your tests.&lt;/p&gt;&#xA;&lt;p&gt;As your tests grow in length and complexity, the logs might become too noisy to efficiently use, or might be missing critical pieces of information to pinpoint potential issues. Take this script, for example, which tests the federated login flow for &lt;a href=&#34;https://grafana.com&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;grafana.com&lt;/a&gt;:&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;federated-login-test.js&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { browser } from &amp;#34;k6/browser&amp;#34;&#xA;import { check } from &amp;#34;https://jslib.k6.io/k6-utils/1.6.0/index.js&amp;#34;&#xA;export const options = {&#xA;scenarios: {&#xA;ui: {&#xA;executor: &amp;#34;shared-iterations&amp;#34;,&#xA;options: {&#xA;browser: {&#xA;type: &amp;#34;chromium&amp;#34;,&#xA;},&#xA;},&#xA;},&#xA;},&#xA;}&#xA;export default async function () {&#xA;const context = await browser.newContext()&#xA;const page = await context.newPage()&#xA;await page.goto(`https://grafana.com/`)&#xA;await page.locator(`#menu__login-link`).click()&#xA;await page.waitForNavigation()&#xA;await page.locator(`button[aria-label=&amp;#34;Login using Google&amp;#34;]`).click()&#xA;await page.waitForNavigation()&#xA;// You will have to add or replace the __ENV variables as appropriate.&#xA;await page&#xA;.locator(`input[aria-label=&amp;#34;Email or phone&amp;#34;]`)&#xA;.fill(__ENV.GRAFANA_STACK_USER_EMAIL)&#xA;await page.locator(`//*[text()=&amp;#34;Next&amp;#34;]`).click()&#xA;await check(page.locator(`form h2`), {&#xA;&amp;#34;Form heading text is correct&amp;#34;: async (lo) =&amp;gt;&#xA;(await lo.textContent()) === `Grafana Labs`,&#xA;})&#xA;await page.close()&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;You can run the test by executing &lt;code&gt;k6 run federated-login-test.js&lt;/code&gt; in your terminal, but seemingly, the test ends prematurely. The check never runs, so it doesn&amp;rsquo;t trigger the threshold failure, and if you inspect the logs you see:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;Uncaught (in promise) getting text content of &amp;#34;h2&amp;#34;: Inspected target navigated or closed&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;It’s a cryptic log, especially if you are unfamiliar with the underlying API and what it’s doing. If you follow the steps by clicking along in your own browser, it isn’t clear what the problem is, as you end up on a page where &lt;code&gt;document.querySelector(‘form h2`).textContent&lt;/code&gt; is valid and returns the expected result.&lt;/p&gt;&#xA;&lt;p&gt;Using the &lt;a href=&#34;/docs/k6/latest/using-k6-browser/options/#environment-variable-options&#34;&gt;k6 browser CLI options&lt;/a&gt;, you can disable headless mode and watch your Chromium instance on your screen, so you can follow along as the bot steps through executing the script.&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;K6_BROWSER_HEADLESS=false k6 run {{scriptName}}.js&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;This often provides invaluable insights to uncover a problem that the logs themselves weren’t able to fully convey.&lt;/p&gt;&#xA;&lt;p&gt;In the example above, it is now easy to establish what the problem is: the last page is never reached. We forgot to wait for a navigation change after the &lt;strong&gt;next&lt;/strong&gt; button was clicked, and the asynchronous check function couldn’t successfully complete because, as it was executing, its page context was canceled.&lt;/p&gt;&#xA;&lt;p&gt;The solution is to add &lt;code&gt;page.waitForNavigation()&lt;/code&gt; on line 36 and now the test passes. 🎉&lt;/p&gt;&#xA;&lt;p&gt;Bots are much quicker than humans when interacting with a browser. You may want to use the &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/page/screenshot/&#34;&gt;&lt;code&gt;page.screenshot()&lt;/code&gt;&lt;/a&gt; method or artificially increase the time between asynchronous steps using &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/page/waitfortimeout/&#34;&gt;&lt;code&gt;page.waitForTimeout()&lt;/code&gt;&lt;/a&gt;, so you can process what is going on. However, if you do inject timeouts into your script to help with debugging, remember to remove them afterwards because…&lt;/p&gt;&#xA;&lt;h2 id=&#34;tip-2-timeouts-and-sleep-are-anti-patterns&#34;&gt;Tip 2. Timeouts and sleep are anti-patterns!&lt;/h2&gt;&#xA;&lt;p&gt;If you’ve seen a k6 script before, there is a good chance it included &lt;a href=&#34;/docs/k6/latest/javascript-api/k6/sleep/&#34;&gt;&lt;code&gt;sleep(t)&lt;/code&gt;&lt;/a&gt;. In the context of non-browser scripts that are focused on testing APIs at the protocol level, this is often a necessary step to &lt;a href=&#34;/docs/k6/latest/using-k6-browser/recommended-practices/simulate-user-input-delay/&#34;&gt;simulate a real user’s input delay&lt;/a&gt;. However, when working with the browser, this can be a source of flaky and unreliable tests that become difficult to untangle and debug. This is because the k6 script pauses, but the browser continues to execute its tasks and processes at an unknown rate, which may be different from one test to the next.&lt;/p&gt;&#xA;&lt;p&gt;If in the &lt;strong&gt;federated-login-test.js&lt;/strong&gt; script, instead of adding &lt;code&gt;page.waitForNavigation()&lt;/code&gt; you added &lt;code&gt;sleep(5)&lt;/code&gt;, this would often get the test to pass; however, you have now introduced one of the following problems every time it runs:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;An iteration in your script is now running longer than necessary (so it is going to cost you money)&lt;/li&gt;&#xA;&lt;li&gt;An iteration in your script is not running long enough and reports failure (so it is going to cost you money)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;The more &lt;code&gt;sleep(t)&lt;/code&gt; or &lt;code&gt;page.waitForTimeout()&lt;/code&gt; calls you add, the more these issues compound and introduce further problems. If you are using your script with Grafana Cloud Synthetic Monitoring, browser checks currently have &lt;a href=&#34;/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6-browser/#public-preview-limitations&#34;&gt;a limit on running time&lt;/a&gt;, so you may be reaching that limit unintentionally. For k6 browser tests, you are increasing memory and CPU usage unnecessarily, which might not just fail the current iteration, but make your script report failure altogether.&lt;/p&gt;&#xA;&lt;p&gt;If using &lt;code&gt;sleep(t)&lt;/code&gt;, it is important to note it is a synchronous function native to k6 that blocks the JavaScript event loop. If you are using the &lt;a href=&#34;/docs/grafana-cloud/whats-new/2024-07-03-browser-timeline-and-screenshots-in-grafana-cloud-k6/&#34;&gt;k6 timeline feature,&lt;/a&gt; the sleep time will get included in the trace and you will lose valuable insights into when your services are &lt;em&gt;really&lt;/em&gt; slowing down.&lt;/p&gt;&#xA;&lt;h3 id=&#34;what-to-do-instead&#34;&gt;What to do instead?&lt;/h3&gt;&#xA;&lt;p&gt;In the &lt;strong&gt;federated-login-test.js&lt;/strong&gt; example above, adding &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/page/waitfornavigation/&#34;&gt;&lt;code&gt;page.waitForNavigation()&lt;/code&gt;&lt;/a&gt; was the solution. This method waits for the browser’s window &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;load event&lt;/a&gt; to fire, ensuring the test is reliable and no longer waiting too little or too long until the browser script should continue its execution.&lt;/p&gt;&#xA;&lt;p&gt;If you aren’t waiting for a page navigation event, but for some in-page content that hasn’t been rendered to the page yet, you want to use &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/locator/&#34;&gt;&lt;code&gt;page.locator()&lt;/code&gt;&lt;/a&gt; and its associated methods.&lt;/p&gt;&#xA;&lt;p&gt;As an example, here’s a browser script checking if the performance testing plugin is displaying the expected information within Grafana.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;performance-app-renders.js&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { browser } from &amp;#34;k6/browser&amp;#34;&#xA;import { check } from &amp;#34;k6&amp;#34;&#xA;export const options = {&#xA;scenarios: {&#xA;ui: {&#xA;executor: &amp;#34;shared-iterations&amp;#34;,&#xA;options: {&#xA;browser: {&#xA;type: &amp;#34;chromium&amp;#34;,&#xA;},&#xA;},&#xA;},&#xA;},&#xA;}&#xA;export default async function () {&#xA;const context = await browser.newContext()&#xA;const page = await context.newPage()&#xA;// You will have to add or replace the __ENV variables as appropriate.&#xA;await page.goto(__ENV.GRAFANA_APP_URL)&#xA;// login&#xA;await page&#xA;.locator(`[data-testid=&amp;#34;data-testid Username input field&amp;#34;]`)&#xA;.fill(&amp;#34;admin&amp;#34;)&#xA;await page&#xA;.locator(`[data-testid=&amp;#34;data-testid Password input field&amp;#34;]`)&#xA;.fill(__ENV.GRAFANA_APP_PASSWORD)&#xA;await page.locator(`[data-testid=&amp;#34;data-testid Login button&amp;#34;]`).click()&#xA;await page.waitForNavigation()&#xA;// navigate to Performance page&#xA;await page.locator(`[data-testid=&amp;#34;data-testid Toggle menu&amp;#34;]`).click()&#xA;await page&#xA;.locator(`[aria-label=&amp;#34;Expand section Testing &amp;amp; synthetics&amp;#34;]`)&#xA;.click()&#xA;await page.locator(`//*[text()=&amp;#34;Performance&amp;#34;]`).click()&#xA;const perfH1Text = await page&#xA;.locator(`//h1[text()=&amp;#34;Performance&amp;#34;]`)&#xA;.textContent()&#xA;check(perfH1Text, {&#xA;&amp;#34;Performance page heading is correct&amp;#34;: (text) =&amp;gt; text === &amp;#34;Performance&amp;#34;,&#xA;})&#xA;await page.close()&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;If you follow along manually (or by turning off headless mode, as suggested in tip 1) you will notice that, at every stage, you have to wait for something to be rendered to the page before continuing. By using &lt;code&gt;page.locator()&lt;/code&gt; and its &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/locator/&#34;&gt;provided methods&lt;/a&gt;, the script waits for the content to be available before proceeding.&lt;/p&gt;&#xA;&lt;p&gt;By using a combination of &lt;code&gt;page.waitForNavigation()&lt;/code&gt; and &lt;code&gt;page.locator()&lt;/code&gt; methods, you now have a reliable script without having to add arbitrary and unreliable timeout functions.&lt;/p&gt;&#xA;&lt;h2 id=&#34;tip-3-think-about-the-asynchronous-execution-of-your-test&#34;&gt;Tip 3: Think about the asynchronous execution of your test&lt;/h2&gt;&#xA;&lt;p&gt;When writing your browser tests, it is important to evaluate and consider:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;What is the next function call &lt;em&gt;really&lt;/em&gt; doing?&lt;/li&gt;&#xA;&lt;li&gt;What is happening from the script’s point of view?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;The k6 browser API is purposefully designed to be compatible with the &lt;a href=&#34;https://playwright.dev/docs/api/class-playwright&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Playwright API for NodeJS&lt;/a&gt;. Grafana k6, however, does not run in a NodeJS environment, but uses &lt;a href=&#34;https://go.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Go&lt;/a&gt; and transpiles scripts using &lt;a href=&#34;https://github.com/grafana/sobek&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Sobek&lt;/a&gt;. Why is this important to know? &lt;br /&gt;&#xA;&lt;br /&gt;&#xA;k6 has evolved over time and two significant milestones for browser checks were introducing the &lt;a href=&#34;https://github.com/grafana/k6/pull/2228&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;event loop&lt;/a&gt; and implementing all the &lt;a href=&#34;https://github.com/grafana/k6/releases/tag/v0.52.0&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;browser APIs as async methods&lt;/a&gt;. For the most part, writing a browser test should be indistinguishable from writing native JavaScript, but there can be a few opaque ‘gotchas’ that are difficult to recognize and identify.&lt;/p&gt;&#xA;&lt;h3 id=&#34;the-native-k6check-does-not-support-passing-asynchronous-functions&#34;&gt;The native k6/check does not support passing asynchronous functions&lt;/h3&gt;&#xA;&lt;p&gt;Because all of the k6 browser API methods are asynchronous, it feels intuitive to write a check like this:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { check } from &amp;#39;k6&amp;#39;&#xA;...&#xA;// doesn&amp;#39;t work&#xA;await check(page.locator(`h1`), {&#xA;&amp;#39;text content is correct&amp;#39;: async(lo) =&amp;gt; (await lo.textContent()) === &amp;#39;Expected content&amp;#39;&#xA;})&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;This will not work, however, because the native k6 check is synchronous. To fix this problem, you can replace the native k6 check with our &lt;a href=&#34;https://jslib.k6.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;jslib.k6.io&lt;/a&gt; version. It is compatible and can be directly swapped out in any of your existing tests.&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { check } from &amp;#34;https://jslib.k6.io/k6-utils/1.6.0/index.js&amp;#34;&#xA;...&#xA;// works!&#xA;await check(page.locator(`h1`), {&#xA;&amp;#39;text content is correct&amp;#39;: async(lo) =&amp;gt; (await lo.textContent()) === &amp;#39;Expected content&amp;#39;&#xA;})&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;dont-use-pagewaitfornavigation-unnecessarily&#34;&gt;Don’t use page.waitForNavigation unnecessarily&lt;/h3&gt;&#xA;&lt;p&gt;It is important to know the underlying architecture of your website when you are authoring browser tests. Are you using a Single Page Application (SPA), such as React, Angular or Vue, or a traditional Multi Page Application (MPA)? Or maybe a mixture of both?&lt;/p&gt;&#xA;&lt;p&gt;You may expect that any time the URL changes in your browser, it would trigger a page load event — but if your application is an SPA, it uses the browser’s &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/History/pushState&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;history.pushState&lt;/a&gt; method, so the &lt;code&gt;page.waitForNavigation()&lt;/code&gt; function call will never resolve, block the rest of the execution of your script, and eventually timeout. This is especially important to note with the next ‘gotcha’ below.&lt;/p&gt;&#xA;&lt;h3 id=&#34;k6-doesnt-know-what-is-in-the-script-until-it-is-encountered&#34;&gt;k6 doesn’t know what is in the script until it is encountered&lt;/h3&gt;&#xA;&lt;p&gt;If your script execution aborted part-way through, none of your checks, logs or custom metrics that are declared and executed after that point will be registered. If you have set up your script so it only fails when a check failure threshold is reached, you are going to have false positives in your test results. &lt;em&gt;Note: see the bonus tip below to solve this.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;have-a-bots-eye-view&#34;&gt;Have a ‘bots-eye’ view&lt;/h3&gt;&#xA;&lt;p&gt;If you take the &lt;strong&gt;performance-app-renders.js&lt;/strong&gt; script from above and change the locator for the h1, the script now fails!&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;const perfH1Text = await page&#xA;.locator(`#pageContent h1`)&#xA;.textContent()&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;There are no logs indicating what has gone wrong — just a failed check. If we summarize the steps from a human perspective:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Go to your Grafana URL&lt;/li&gt;&#xA;&lt;li&gt;Fill in username, fill in password, and click &lt;strong&gt;login&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;em&gt;Wait for page navigation&lt;/em&gt;&lt;/li&gt;&#xA;&lt;li&gt;Click the &lt;strong&gt;menu&lt;/strong&gt; toggle, expand &lt;strong&gt;Testing &amp;amp; Synthetics&lt;/strong&gt;, click &lt;strong&gt;Performance&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;Check if the h1’s text content is “Performance”&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;If you follow along in your browser, open your devTools console and run &lt;code&gt;document.querySelector(‘#pageContent h1`).textContent&lt;/code&gt; — it returns “Performance!&amp;quot; So what is going on?&lt;/p&gt;&#xA;&lt;p&gt;The problem is that the bot executing the script “thinks,” “sees,” and “evaluates” things &lt;strong&gt;a lot&lt;/strong&gt; quicker than humans do. If you add this &lt;a href=&#34;https://gist.github.com/ckbedwell/c18142bb8aa20c7ba9133a8a53304e74&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;useful debug snippet&lt;/a&gt; at the beginning of the script and open the devTools console, the execution will pause, allowing an investigation into what has happened.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1999px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png&#34;data-srcset=&#34;/media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=320 320w, /media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=550 550w, /media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=750 750w, /media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=900 900w, /media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=1040 1040w, /media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=1240 1240w, /media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of debugging Grafana with Chrome DevTools. The screen is split in two with Grafana displayed on the left with an h1 with 0 width and 0 height highlighted and on the right is the elements panel displaying the DOM tree. The h1 contains no text content.&#34;width=&#34;1999&#34;height=&#34;716&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png&#34;&#xA;alt=&#34;A screenshot of debugging Grafana with Chrome DevTools. The screen is split in two with Grafana displayed on the left with an h1 with 0 width and 0 height highlighted and on the right is the elements panel displaying the DOM tree. The h1 contains no text content.&#34;width=&#34;1999&#34;height=&#34;716&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;While waiting for the plugin to load, for a split second, Grafana has rendered an empty h1 to the screen that fulfills the selector we are looking for, so it moves onto executing the check comparison: the text content of the h1 is not “Performance,” so the check and our test ultimately fails.&lt;/p&gt;&#xA;&lt;p&gt;And that brings us nicely into our fourth tip…&lt;/p&gt;&#xA;&lt;h2 id=&#34;tip-4-write-unique-and-durable-selectors-for-pagelocator&#34;&gt;Tip 4: Write unique and durable selectors for page.locator()&lt;/h2&gt;&#xA;&lt;p&gt;We have a guide on best practices for &lt;a href=&#34;/docs/k6/latest/using-k6-browser/recommended-practices/select-elements/&#34;&gt;selecting elements&lt;/a&gt;, where the fundamental idea is to create durable selectors that:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Are unique to the page (if not the whole journey, where possible, as shown by the bug above!)&lt;/li&gt;&#xA;&lt;li&gt;Are guaranteed to be stable&lt;/li&gt;&#xA;&lt;li&gt;Convey intent in the script&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;If you were to write a browser script to test the login of Grafana, when inspecting the Document Object Model (DOM), you would see markup similar to this for the Username input field:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;&amp;lt;input class=&amp;#34;css-8tk2dk-input-input&amp;#34; name=&amp;#34;user&amp;#34; id=&amp;#34;:r0:&amp;#34; autocapitalize=&amp;#34;none&amp;#34; placeholder=&amp;#34;email or username&amp;#34; data-testid=&amp;#34;data-testid Username input field&amp;#34;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;The input element has several attributes on it. To decide which would be appropriate to use, you can assign each a score:&lt;/p&gt;&#xA;&lt;table&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;Unique to the page&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;Value is stable&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;Conveys intent&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;Total&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;autocapitalize&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;❌&#xA;&lt;/td&gt;&#xA;&lt;td&gt;❌&#xA;&lt;/td&gt;&#xA;&lt;td&gt;❌&#xA;&lt;/td&gt;&#xA;&lt;td&gt;0&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;class&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;❌&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;1&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;id&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;2&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;name&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;2.5&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;placeholder&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;2.5&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;data-testid&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;3&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;&lt;em&gt;❌ = 0, ⚠️= 0.5, ✅ = 1&lt;/em&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;The &lt;strong&gt;autocapitalize&lt;/strong&gt; attribute can immediately be ruled out. There is no guarantee it is unique to the page, it has no bearing on what you are trying to select, and it would be difficult to infer your intent when reviewing the test script.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;The &lt;strong&gt;class&lt;/strong&gt; attribute might be considered. It is often used when using tag manager tools or other rudimentary recorders to act as a selector. But there are several problems with using this attribute:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;There is no guarantee that it is unique to the page (and it isn’t, in this case, as the password input shares the same classes)&lt;/li&gt;&#xA;&lt;li&gt;They are often considered as an implementation detail by developers and are subject to change (especially in the case here, where the value is generated by the build process)&lt;/li&gt;&#xA;&lt;li&gt;Even if it was unique and stable, it makes your test scripts less maintainable. How would someone else reading your script be able to infer you are selecting the username input?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;The &lt;strong&gt;id&lt;/strong&gt; attribute should be unique, but it has similar problems to &lt;strong&gt;class&lt;/strong&gt; in this case. Those who are familiar with React APIs will recognize this ID has been generated by the &lt;a href=&#34;https://react.dev/reference/react/useId&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;useId&lt;/code&gt; hook&lt;/a&gt;, so if the developers were to use this hook elsewhere on the page for a component that gets rendered before the input field, this &lt;strong&gt;id&lt;/strong&gt; value would shift, so it is not guaranteed to be a stable selector. In this case, it also doesn’t convey any meaning when reading the test script, so isn’t a good candidate.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;The &lt;strong&gt;name&lt;/strong&gt; and &lt;strong&gt;placeholder&lt;/strong&gt; attributes have a similar weighting and both would be strong candidates for a stable selector that conveys meaning in the test script. There are some additional considerations:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;If you want to reuse the test script for testing the page in a different language, the placeholder selector would have to be updated in the script.&lt;/li&gt;&#xA;&lt;li&gt;If you haven’t communicated with your development and/or content teams, they might be unaware of the testing contract you have just enrolled them in. They might have good reason in the future to update the value of either of these attributes and be unaware your script is about to break.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;This brings us to the &lt;strong&gt;data-testid.&lt;/strong&gt; It is unique in the DOM, it conveys intent in the script, and it has an implicit contract with other teams that its only purpose is for use in testing scripts, so it will remain stable. This is the ideal selector you should be using.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;page.locator(`[data-testid=&amp;#34;data-testid Username input field&amp;#34;]`)&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;This process works well with elements that have suitable attributes or well-labeled IDs or classes. You could strengthen and further clarify intent by adding the element’s tag name.&lt;/p&gt;&#xA;&lt;p&gt;But what happens if you don’t have any useful attributes available? There are two options, which can be combined:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Look up the node’s parent tree to find a suitable selector. If using this method, it is important not to write selectors that are too closely tied to your DOM structure. Selectors tightly coupled with the DOM are brittle and prone to breaking, as they are too closely tied to your developer’s implementation, which may change at any point.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;// good&#xA;page.locator(`#product-detail h2`)&#xA;// bad&#xA;page.locator(`#product-detail &amp;gt; section &amp;gt; div &amp;gt; div.arbitaryClass &amp;gt; h2`)&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;Use an xpath selector with a &lt;code&gt;text()&lt;/code&gt; node test. &lt;code&gt;page.locator()&lt;/code&gt; supports xpath selectors and &lt;a href=&#34;https://devhints.io/xpath&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;there are many that are very powerful&lt;/a&gt;. Targeting elements based on their text content is highly recommended because it decouples the test script from your implementation details and focuses on writing locators the same way that a user would find things on the page.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;page.locator(`//h2[text()=&amp;#34;Product Title&amp;#34;]`)&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h2 id=&#34;tip-5-use-threshold-options-or-the-fail-method-to-ensure-you-get-the-right-results&#34;&gt;Tip 5: Use threshold options or the fail() method to ensure you get the right results&lt;/h2&gt;&#xA;&lt;p&gt;Whenever you are authoring a test, you should think about your acceptance criteria to consider it a success. But how do we define what a pass or failure looks like for a browser test?&lt;/p&gt;&#xA;&lt;p&gt;k6 provides a &lt;a href=&#34;/docs/k6/latest/using-k6/checks/&#34;&gt;checks API&lt;/a&gt; where you can define at any point in the script’s execution if something has passed or failed. A check can be as simple as confirming if an API request returned a successful status code, whether an element has the correct text content, or if a user journey took an acceptable amount of time.&lt;/p&gt;&#xA;&lt;p&gt;You may think any failed checks in your script should mean the whole test should fail, but if that was the default behavior, most load tests would result in failure. When writing a k6 script, you should identify what context it is running in (i.e., is it a performance test or for synthetic monitoring?), as well as what scenarios, VUs, and iterations are being used.&lt;/p&gt;&#xA;&lt;p&gt;After establishing these details, you can determine the appropriate ways to think about success and failure, which checks to add, and appropriate thresholds — for example, is this check a warning, or is it a critical failure for our test?&lt;/p&gt;&#xA;&lt;p&gt;Here are two examples — one for performance testing, and one for synthetic monitoring — that support the k6 browser module and demonstrate how you could use the checks API.&lt;/p&gt;&#xA;&lt;h4 id=&#34;grafana-k6-performance-tests-using-the-browser-module&#34;&gt;Grafana k6 performance tests using the browser module&lt;/h4&gt;&#xA;&lt;p&gt;A k6 performance test is a versatile way to define any number of scenarios, VUs, and iterations. In the following example, we have a demo e-commerce website and we are using a hybrid test to record what happens if our recommended product API is under heavy load unexpectedly. Our recommendation engine is an important part of the application, but it’s not as business-critical as ensuring customers can place orders and check out.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;recommend-product-spike.js&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { browser } from &amp;#34;k6/browser&amp;#34;&#xA;import http from &amp;#34;k6/http&amp;#34;&#xA;import { check } from &amp;#34;https://jslib.k6.io/k6-utils/1.6.0/index.js&amp;#34;&#xA;const PRODUCT_IDS = __ENV.PRODUCT_IDS&#xA;const HAS_SOME_LEEWAY = `warn`&#xA;const SUPER_IMPORTANT_CHECK = `critical`&#xA;const LESS_IMPORTANT = `info`&#xA;export const options = {&#xA;scenarios: {&#xA;ui: {&#xA;executor: &amp;#34;constant-vus&amp;#34;,&#xA;duration: &amp;#34;1m&amp;#34;,&#xA;vus: 3,&#xA;options: {&#xA;browser: {&#xA;type: &amp;#34;chromium&amp;#34;,&#xA;},&#xA;},&#xA;exec: &amp;#34;checkoutCompletion&amp;#34;,&#xA;},&#xA;&amp;#34;spike-api&amp;#34;: {&#xA;executor: &amp;#34;ramping-vus&amp;#34;,&#xA;startVUs: 0,&#xA;stages: [&#xA;{ duration: &amp;#34;10s&amp;#34;, target: 10 },&#xA;{ duration: &amp;#34;40s&amp;#34;, target: 30 },&#xA;{ duration: &amp;#34;10s&amp;#34;, target: 10 },&#xA;],&#xA;gracefulRampDown: &amp;#34;10s&amp;#34;,&#xA;exec: &amp;#34;spikeApi&amp;#34;,&#xA;},&#xA;},&#xA;thresholds: {&#xA;[`checks{importance:${SUPER_IMPORTANT_CHECK}}`]: [&amp;#34;rate==1.0&amp;#34;],&#xA;[`checks{importance:${HAS_SOME_LEEWAY}}`]: [&amp;#34;rate&amp;gt;=0.95&amp;#34;],&#xA;[`checks{importance:${LESS_IMPORTANT}}`]: [&amp;#34;rate&amp;gt;=0.9&amp;#34;],&#xA;},&#xA;}&#xA;export function spikeApi() {&#xA;const randomProduct =&#xA;PRODUCT_IDS[Math.floor(Math.random() * PRODUCT_IDS.length)]&#xA;const res = http.get(`https://otel-demo.field-eng.grafana.net/api/recommendations?productIds=${randomProduct}`)&#xA;check(&#xA;res,&#xA;{&#xA;&amp;#34;status code is 200&amp;#34;: (r) =&amp;gt; r.status === 200,&#xA;},&#xA;{ importance: HAS_SOME_LEEWAY }&#xA;)&#xA;}&#xA;export async function checkoutCompletion() {&#xA;const context = await browser.newContext()&#xA;const page = await context.newPage()&#xA;await page.goto(`https://otel-demo.field-eng.grafana.net/`)&#xA;await page.locator(`//*[text()=&amp;#34;Go Shopping&amp;#34;]`).click()&#xA;await Promise.all([&#xA;page&#xA;.locator(`//*[text()=&amp;#34;Starsense Explorer Refractor Telescope&amp;#34;]`)&#xA;.click(),&#xA;page.waitForNavigation(),&#xA;])&#xA;// less important check&#xA;await checkForRecommendedProducts(page, `Product page`)&#xA;await Promise.all([&#xA;page.locator(`//*[text()=&amp;#34; Add To Cart&amp;#34;]`).click(),&#xA;page.waitForNavigation(),&#xA;])&#xA;// less important check&#xA;await checkForRecommendedProducts(page, `Shipping form`)&#xA;await Promise.all([&#xA;page.locator(`//*[text()=&amp;#34;Place Order&amp;#34;]`).click(),&#xA;page.waitForNavigation(),&#xA;])&#xA;// Super important check&#xA;await check(&#xA;page.locator(`h1`),&#xA;{&#xA;&amp;#34;Place order page was reached&amp;#34;: async (lo) =&amp;gt;&#xA;(await lo.textContent()) === &amp;#34;Your order is complete!&amp;#34;,&#xA;},&#xA;{ important: SUPER_IMPORTANT_CHECK }&#xA;)&#xA;// less important check&#xA;await checkForRecommendedProducts(page, `Order confirmation`)&#xA;await page.close()&#xA;}&#xA;const TWO_SECONDS = 2000&#xA;async function checkForRecommendedProducts(page, step) {&#xA;try {&#xA;await page&#xA;.locator(&#xA;`[data-cy=&amp;#34;recommendation-list&amp;#34;] [data-cy=&amp;#34;product-card&amp;#34;]:first-of-type`&#xA;)&#xA;.waitFor({ timeout: TWO_SECONDS })&#xA;} catch (e) {&#xA;await page.screenshot({ path: `./screenshots/${step}.png` })&#xA;} finally {&#xA;const cards = await page.$$(`[data-cy=&amp;#34;product-card&amp;#34;]`)&#xA;console.log(step, cards.length)&#xA;check(&#xA;cards.length,&#xA;{&#xA;&amp;#34;4 recommended products are displayed&amp;#34;: (length) =&amp;gt; length === 4,&#xA;},&#xA;{&#xA;importance: LESS_IMPORTANT,&#xA;}&#xA;)&#xA;}&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;In the script above, there are two scenarios to form a hybrid test: &lt;code&gt;spike-api&lt;/code&gt;, which is using k6’s &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-http/&#34;&gt;&lt;code&gt;http&lt;/code&gt; protocol&lt;/a&gt; to simulate a spike of traffic, and &lt;code&gt;user-checkout&lt;/code&gt; which is a browser test simulating the checkout flow. There are three checks that are tagged with a key of importance and a varying value, depending on what level of success we require for the check.&lt;/p&gt;&#xA;&lt;p&gt;In the &lt;code&gt;options&lt;/code&gt; object, a threshold has been set for each of these key/value pairs that will dictate whether the test has passed or failed. The &lt;code&gt;abortOnFail&lt;/code&gt; option is not being used in the thresholds because valuable data would be lost if the test ended prematurely. If failures started occurring, it would be useful to know what the extent of the failure looks like for the API and what is happening on the frontend in the browser.&lt;/p&gt;&#xA;&lt;h4 id=&#34;synthetic-monitoring-check&#34;&gt;Synthetic Monitoring check&lt;/h4&gt;&#xA;&lt;p&gt;If you are running a Synthetic Monitoring browser check, it will always be one scenario with one VU and one iteration. Synthetic Monitoring doesn’t currently support the &lt;code&gt;thresholds&lt;/code&gt; object in the options declaration (but it’s coming soon!), so you have to use the explicit &lt;a href=&#34;/docs/k6/latest/javascript-api/k6/fail/&#34;&gt;&lt;code&gt;fail()&lt;/code&gt; method&lt;/a&gt; to let the probe know the check has failed.&lt;/p&gt;&#xA;&lt;p&gt;Synthetic Monitoring browser checks behave differently than k6 checks because they primarily assess if your test passed or failed based on your definition of uptime. For non-scripted Synthetic Monitoring checks, you define uptime with a set of assertions in its own step during check creation, but because browser checks are written as a script, it is up to you to mark out explicitly what you want to count towards defining uptime.&lt;/p&gt;&#xA;&lt;p&gt;If you take our &lt;strong&gt;recommended-product-spike-test.js&lt;/strong&gt; script above and extract the checkout flow scenario, it would only need a small modification to suit the needs of a Synthetic Monitoring browser check. By adding the &lt;code&gt;fail()&lt;/code&gt; method to the check, confirming if the order confirmation page was reached, the Synthetic Monitoring probe will now understand what constitutes a failure of uptime and report correctly.&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (&#xA;!(await check(page.locator(`h1`), {&#xA;&amp;#34;Place order page was reached&amp;#34;: async (lo) =&amp;gt; (await lo.textContent()) === &amp;#34;Your order is complete!&amp;#34;,&#xA;}))&#xA;) {&#xA;fail(`Order completion page was not reached`)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;We can leave our less important checks in the script without adding an explicit fail to them, as that’s just a bonus we are receiving from this set-up. We could even add a custom alert using &lt;a href=&#34;/products/cloud/alerting/&#34;&gt;Grafana Alerting&lt;/a&gt; to know if the recommended products aren’t rendering consistently.&lt;/p&gt;&#xA;&lt;p&gt;This kind of flexibility in your Synthetic Monitoring browser checks means you can set primary and secondary assertions in just one execution, saving you both time and money!&lt;/p&gt;&#xA;&lt;h2 id=&#34;bonus-tip-dont-just-account-for-the-happy-path&#34;&gt;Bonus tip: don’t just account for the ‘happy’ path&lt;/h2&gt;&#xA;&lt;p&gt;A notorious mistake in any kind of testing is assuming they will always succeed. However, the real value of testing is when the inevitable failure occurs, how well do the tests inform us of the problem they encountered?&lt;/p&gt;&#xA;&lt;p&gt;If you look at the checkout scenario in the &lt;strong&gt;recommend-product-spike.js&lt;/strong&gt;, there are several &lt;code&gt;page.locator().click()&lt;/code&gt; functions called. What happens if our application has an error and these aren’t displaying correctly and the selectors fail?&lt;/p&gt;&#xA;&lt;p&gt;Each iteration will wait the &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/locator/click/#clickoptions&#34;&gt;default 30 seconds&lt;/a&gt; before timing out and throwing a failure. This could be an issue for our test because it “blocks” a VU for 30 seconds before ending the iteration and starting again. The first part of the problem is this test only runs for one minute, so if it encounters a problem early, we lose a lot of potential iterations and all the additional data they would generate.&lt;/p&gt;&#xA;&lt;p&gt;There are two ways of solving this problem:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Providing each &lt;code&gt;page.locator().click()&lt;/code&gt; (and similar methods) with their own appropriate timeouts&lt;/li&gt;&#xA;&lt;li&gt;Setting a default timeout value on the page using &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/page/setdefaulttimeout/#setdefaulttimeouttimeout&#34;&gt;&lt;code&gt;page.setDefaultTimeout()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Each of these approaches has its pros and cons and is up to you to decide which works best for you.&lt;/p&gt;&#xA;&lt;p&gt;The second problem is outlined above in tip three: the test execution was halted, the check confirming if the order page was reached is never encountered, and this failure goes unreported in the test’s metrics. The solution is to add a catch block to our &lt;code&gt;try / finally&lt;/code&gt; statement:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;try {&#xA;...&#xA;} catch (e) {&#xA;console.error(e)&#xA;await page.screenshot({&#xA;path: `./screenshots/${__VU}_${__ITER}-failure.png`,&#xA;})&#xA;check(&#xA;null,&#xA;{&#xA;&amp;#34;Place order page was reached&amp;#34;: false,&#xA;},&#xA;{ important: SUPER_IMPORTANT_CHECK }&#xA;)&#xA;} finally {&#xA;...&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;&lt;em&gt;Note: It is good practice to take a screenshot to make your debugging sessions easier.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;Synthetic Monitoring reports an uptime failure if any execution results in an unhandled exception, so if you do add this catch block, remember to rethrow the error (with your own logging if you favor it over the default) or call k6’s &lt;code&gt;fail()&lt;/code&gt; method.&lt;/p&gt;&#xA;&lt;h2 id=&#34;summing-up&#34;&gt;Summing up&lt;/h2&gt;&#xA;&lt;p&gt;The k6 browser API is a versatile tool to help monitor your website’s performance and reliability. With the tips above, you can ensure a tight feedback loop when authoring your tests, while also keeping them adaptable and bug-free. Ultimately, these best practices will make it easier for you to identify potential performance issues and optimize your end-user experiences.&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;Grafana Cloud is the easiest way to get started with browser testing. With &lt;a href=&#34;/products/cloud/k6/&#34;&gt;Grafana Cloud k6&lt;/a&gt;, you can effortlessly combine frontend and backend testing in a single cloud-based test. &lt;a href=&#34;/products/cloud/synthetic-monitoring/&#34;&gt;Grafana Cloud Synthetic Monitoring&lt;/a&gt; enables continuous monitoring of your critical journeys in a production environment. We offer a generous forever-free tier and plans tailored for every use case. Sign up for free now (&lt;a href=&#34;/auth/sign-up/create-user?pg=plugins&amp;amp;plcmt=grafana-synthetic-monitoring-app&amp;amp;redirectPath=synthetic-monitoring&#34;&gt;Grafana Cloud k6&lt;/a&gt; or &lt;a href=&#34;/auth/sign-up/create-user?pg=plugins&amp;amp;plcmt=grafana-synthetic-monitoring-app&#34;&gt;Grafana Cloud Synthetic Monitoring&lt;/a&gt;)!&lt;/em&gt;&lt;/p&gt;】&lt;p&gt;鉴于现代网站的复杂性，浏览器测试对于确保良好的用户体验至关重要。借助 &lt;a href=&#34;/docs/k6/latest/using-k6-browser/&#34;&gt;Grafana k6 浏览器模块&lt;/a&gt;，您可以与真实的 Web 浏览器交互并模拟用户交互 - 例如单击、键入或导航页面 - 收集前端指标，提高网站可靠性，并在性能问题影响用户之前修复它们。&lt;/p&gt;&#xA;&lt;p&gt;作为 &lt;a href=&#34;/oss/k6/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana k6 OSS&lt;/a&gt; 的一部分，k6 浏览器模块也与我们完全托管的&lt;a href=&#34;/ products/cloud/k6/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud k6&lt;/a&gt; 解决方案，以及&lt;a href=&#34;/products/cloud/synthetic-monitoring/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana 云综合监控&lt;/a&gt;，提供开箱即用的监控功能。这意味着您可以根据您的测试需求在这三个环境中重复使用浏览器测试脚本。&lt;/p&gt;&#xA;&lt;p&gt;通过与 &lt;a href=&#34;https://playwright.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Playwright&lt;/a&gt; 类似的 API，k6 浏览器模块使那些人可以轻松使用熟悉 Playwright Web 测试框架来编写他们的第一个浏览器测试。也就是说，我们知道在编写浏览器测试脚本并将其集成到您的工作流程中时，一些最佳实践可以发挥很大作用。&lt;/p&gt;&#xA;&lt;p&gt;在本博客中，我们概述了您今天可以应用的五个技巧，以便在 Grafana k6、Grafana Cloud k6 和 Grafana Cloud Synthetic Monitoring 中编写更好的浏览器测试。&lt;/p&gt;&#xA;&lt;h2 id=&#34;tip-1-run-the-test-locally-for-a-faster-feedback-loop&#34;&gt;提示 1. 在本地运行测试以获得更快的反馈循环&lt;/h2&gt;&#xA;&lt;p&gt;我们的云产品（包括 Grafana Cloud k6 和综合监控）是可视化脚本输出的最佳方式，但在计算机上本地运行测试是更快地调试和迭代的好方法。首先，您需要：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/docs/k6/latest/set-up/install-k6/&#34;&gt;在您的计算机上安装 Grafana k6&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;拥有 Chrome（或&lt;a href=&#34;https://alternativeto.net/category/browsers/chromium-based/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;基于 Chromium 的浏览器&lt;/a&gt; ）可用&lt;/li&gt;&#xA;&lt;li&gt;设置一个空目录&lt;/li&gt;&#xA;&lt;li&gt;使用&lt;a href=&#34;/docs/k6/latest/using-k6/scenarios/executors/shared-iterations/&#34;&gt;&lt;code&gt;shared-iterations&lt;/code&gt;执行器创建脚本&lt;/a&gt;&lt; /里&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;为了在本地调试浏览器脚本，请确保您的测试场景仅运行一个虚拟用户 (VU) 和一次迭代。 &lt;code&gt;shared-iterations&lt;/code&gt; 执行器默认设置了这些选项，因此是调试的完美选择。您可以在编写测试时快速运行测试、读取日志输出并减少反馈循环。&lt;/p&gt;&#xA;&lt;p&gt;随着测试长度和复杂性的增加，日志可能会变得过于嘈杂而无法有效使用，或者可能会丢失关键信息来查明潜在问题。以这个脚本为例，它测试联邦 l&lt;a href=&#34;https://grafana.com&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;grafana.com&lt;/a&gt; 的登录流程：&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;federated-login-test.js&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;从“k6/browser”导入 { browser }&#xA;从“https://jslib.k6.io/k6-utils/1.6.0/index.js”导入{检查}&#xA;导出常量选项= {&#xA;场景：{&#xA;用户界面：{&#xA;执行者：“共享迭代”，&#xA;选项： {&#xA;浏览器：{&#xA;类型：“铬”，&#xA;},&#xA;},&#xA;},&#xA;},&#xA;}&#xA;导出默认异步函数 () {&#xA;const context = 等待 browser.newContext()&#xA;const page = 等待 context.newPage()&#xA;等待 page.goto(`https://grafana.com/`)&#xA;等待 page.locator(`#menu__login-link`).click()&#xA;等待页面.waitForNavigation()&#xA;等待 page.locator(`button[aria-label=&#34;使用 Google 登录&#34;]`).click()&#xA;等待页面.waitForNavigation()&#xA;// 您必须根据需要添加或替换 __ENV 变量。&#xA;等待页面&#xA;.locator(`input[aria-label=&#34;电子邮件或电话&#34;]`)&#xA;.fill(__ENV.GRAFANA_STACK_USER_EMAIL)&#xA;等待 page.locator(`//*[text()=&#34;下一步&#34;]`).click()&#xA;等待检查(page.locator(`form h2`), {&#xA;“表单标题文本正确”：async (lo) =&gt;&#xA;(await lo.textContent()) === `Grafana Labs`,&#xA;})&#xA;等待页面.close()&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;您可以通过在终端中执行&lt;code&gt;k6 run federated-login-test.js&lt;/code&gt;来运行测试，但看起来测试提前结束了。检查永远不会运行，因此它不会触发阈值失败，如果您检查日志，您会看到：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;未捕获（承诺）获取“h2”文本内容：检查的目标已导航或关闭&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;这是一个神秘的日志，尤其是当您不熟悉底层 API 及其功能时。如果您按照这些步骤在自己的浏览器中单击，则不清楚问题是什么，因为您最终会看到 &lt;code&gt;document.querySelector(&#39;form h2`).textContent&lt;/code&gt; 的页面有效并返回预期结果。&lt;/p&gt;&#xA;&lt;p&gt;使用 &lt;a href=&#34;/docs/k6/latest/using-k6-browser/options/#environment-variable-options&#34;&gt;k6 浏览器 CLI 选项&lt;/a&gt;，哟您可以禁用无头模式并在屏幕上观看您的 Chromium 实例，这样您就可以跟随机器人逐步执行脚本。&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;K6_BROWSER_HEADLESS=false k6 run {{scriptName}}.js&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;这通常可以提供宝贵的见解来发现日志本身无法完全传达的问题。&lt;/p&gt;&#xA;&lt;p&gt;在上面的示例中，现在很容易确定问题所在：永远无法到达最后一页。我们忘记在单击&lt;strong&gt;下一步&lt;/strong&gt;按钮后等待导航更改，并且异步检查功能无法成功完成，因为在执行时，其页面上下文被取消。&lt;/p&gt;&#xA;&lt;p&gt;解决方案是在第36行添加&lt;code&gt;page.waitForNavigation()&lt;/code&gt;，现在测试通过了。 🎉&lt;/p&gt;&#xA;&lt;p&gt;与浏览器交互时，机器人比人类快得多。您可能需要使用 &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/page/screenshot/&#34;&gt;&lt;code&gt;page.screenshot()&lt;/code&gt;&lt;/a&gt; 方法或使用 &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/page/waitfortimeout/&#34;&gt;&lt;code&gt;page.waitForTimeout()&lt;/code&gt;&lt;/a&gt; 人为地增加异步步骤之间的时间，这样你就可以处理 到底是怎么回事。但是，如果您确实在脚本中注入超时以​​帮助调试，请记住随后将其删除，因为......&lt;/p&gt;&#xA;&lt;h2 id=&#34;tip-2-timeouts-and-sleep-are-anti-patterns&#34;&gt;提示 2. 超时和睡眠是反模式！&lt;/h2&gt;&#xA;&lt;p&gt;如果您以前见过 k6 脚本，那么它很可能包含 &lt;a href=&#34;/docs/k6/latest/javascript-api/k6/sleep/&#34;&gt;&lt;code&gt;sleep(t)&lt; /代码&gt;&lt;/a&gt;。在专注于在协议级别测试 API 的非浏览器脚本的上下文中，这通常是 &lt;a href=&#34;/docs/k6/latest/using-k6-browser/recommended-practices/simulate- user-input-delay/&#34;&gt;模拟真实用户的输入延迟&lt;/a&gt;。然而，在使用浏览器时，这可能会导致不稳定且不可靠的测试，从而难以理清和调试。这是因为 k6 脚本暂停，但浏览器继续以未知的速率执行其任务和进程，这可能会因一次测试而异。&lt;/p&gt;&#xA;&lt;p&gt;如果在 &lt;strong&gt;federated-login-test.js&lt;/strong&gt; 脚本中，您没有添加 &lt;code&gt;page.waitForNavigation()&lt;/code&gt;，而是添加了 &lt;code&gt;sleep(5)&lt;/code&gt; ，这通常会使测试通过；但是，您现在每次运行时都会引入以下问题之一：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;脚本中的迭代现在运行时间超过了必要的时间（因此它将与给你钱）&lt;/li&gt;&#xA;&lt;li&gt;脚本中的迭代运行时间不够长并报告失败（因此会花费您金钱）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;您添加的 &lt;code&gt;sleep(t)&lt;/code&gt; 或 &lt;code&gt;page.waitForTimeout()&lt;/code&gt; 调用越多，这些问题就越复杂并引入更多问题。如果您将脚本与 Grafana Cloud Synthetic Monitoring 结合使用，浏览器检查当前具有 &lt;a href=&#34;/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6-browser/#public-preview-limitations &#34;&gt;运行时间有限制&lt;/a&gt;，因此您可能会无意中达到该限制。对于 k6 浏览器测试，您不必要地增加了内存和 CPU 使用率，这可能不仅会导致当前迭代失败，还会使您的脚本完全报告失败。&lt;/p&gt;&#xA;&lt;p&gt;如果使用 &lt;code&gt;sleep(t)&lt;/code&gt;，请务必注意，它是 k6 原生的同步函数，会阻止 JavaScript 事件循环。如果您使用&lt;a href=&#34;/docs/grafana-cloud/whats-new/2024-07-03-browser-timeline-and-screenshots-in-grafana-cloud-k6/&#34;&gt;k6 时间线功能，&lt; /a&gt; 睡眠时间将包含在跟踪中，您将无法了解服务何时&lt;em&gt;真正&lt;/em&gt;变慢。&lt;/p&gt;&#xA;&lt;h3 id=&#34;what-to-do-instead&#34;&gt;该怎么办？&lt;/h3&gt;&#xA;&lt;p&gt;在上面的 &lt;strong&gt;federated-login-test.js&lt;/strong&gt; 示例中，添加 &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/page/waitfornavigation/&#34;&gt;&lt; code&gt;page.waitForNavigation()&lt;/code&gt;&lt;/a&gt; 是解决方案。此方法等待浏览器窗口 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;load 事件&lt;/a&gt; 触发，确保测试可靠，并且在浏览器脚本继续执行之前不再等待太短或太长的时间。&lt;/p&gt;&#xA;&lt;p&gt;如果您不是在等待页面导航事件，而是等待某些尚未呈现到页面的页内内容，则需要使用 &lt;a href=&#34;/docs/k6/latest/javascript -api/k6-browser/locator/&#34;&gt;&lt;code&gt;page.locator()&lt;/code&gt;&lt;/a&gt; 及其关联方法。&lt;/p&gt;&#xA;&lt;p&gt;作为示例，下面是一个浏览器脚本，用于检查性能测试插件是否在 Grafana 中显示预期信息。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;performance-app-renders.js&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;从“k6/browser”导入 { browser }&#xA;从“k6”导入{检查}&#xA;导出常量选项= {&#xA;场景：{&#xA;用户界面：{&#xA;执行者：“共享迭代”，&#xA;选项： {&#xA;浏览器：{&#xA;类型：“铬”，&#xA;},&#xA;},&#xA;},&#xA;},&#xA;}&#xA;出口t 默认异步函数 () {&#xA;const context = 等待 browser.newContext()&#xA;const page = 等待 context.newPage()&#xA;// 您必须根据需要添加或替换 __ENV 变量。&#xA;等待 page.goto(__ENV.GRAFANA_APP_URL)&#xA;// 登录&#xA;等待页面&#xA;.locator(`[data-testid=&#34;data-testid 用户名输入字段&#34;]`)&#xA;.fill(&#34;管理员&#34;)&#xA;等待页面&#xA;.locator(`[data-testid=&#34;data-testid 密码输入字段&#34;]`)&#xA;.fill(__ENV.GRAFANA_APP_PASSWORD)&#xA;等待 page.locator(`[data-testid=&#34;data-testid 登录按钮&#34;]`).click()&#xA;等待页面.waitForNavigation()&#xA;// 导航到性能页面&#xA;等待 page.locator(`[data-testid=&#34;data-testid 切换菜单&#34;]`).click()&#xA;等待页面&#xA;.locator(`[aria-label=&#34;展开测试和合成部分&#34;]`)&#xA;。点击（）&#xA;等待 page.locator(`//*[text()=&#34;性能&#34;]`).click()&#xA;const perfH1Text = 等待页面&#xA;.locator(`//h1[text()=&#34;性能&#34;]`)&#xA;.textContent()&#xA;检查（perfH1Text，{&#xA;&#34;性能页面标题正确&#34;: (text) =&gt; text === &#34;性能&#34;,&#xA;})&#xA;等待页面.close()&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;如果您手动进行操作（或者按照技巧 1 中的建议关闭无头模式），您会注意到，在每个阶段，您都必须等待某些内容呈现到页面上才能继续。通过使用 &lt;code&gt;page.locator()&lt;/code&gt; 及其&lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/locator/&#34;&gt;提供的方法&lt;/a&gt;，脚本会等待在继续之前使内容可用。&lt;/p&gt;&#xA;&lt;p&gt;通过结合使用 &lt;code&gt;page.waitForNavigation()&lt;/code&gt; 和 &lt;code&gt;page.locator()&lt;/code&gt; 方法，您现在拥有可靠的脚本，而无需添加任意且不可靠的超时函数.&lt;/p&gt;&#xA;&lt;h2 id=&#34;tip-3-think-about-the-asynchronous-execution-of-your-test&#34;&gt;提示 3：考虑测试的异步执行&lt;/h2&gt;&#xA;&lt;p&gt;编写浏览器测试时，评估和考虑非常重要：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;下一个函数调用&lt;em&gt;真正&lt;/em&gt;在做什么？&lt;/li&gt;&#xA;&lt;li&gt;从脚本的角度来看发生了什么？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;k6 浏览器 API 专门设计为与 &lt;a href=&#34;https://playwright.dev/docs/api/class-playwright&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Playwright API 兼容对于 NodeJS&lt;/a&gt;。然而，Grafana k6 并不在 NodeJS 环境中运行，而是使用 &lt;a href=&#34;https://go.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Go&lt;/a&gt; 并使用&lt;a href=&#34;https://github.com/grafana/sobek&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;索贝克&lt;/a&gt;。为什么知道这一点很重要？ &lt;br/&gt;&#xA;&lt;br/&gt;&#xA;k6 随着时间的推移不断发展，浏览器检查的两个重要里程碑是引入 &lt;a href=&#34;https://github.com/grafana/k6/pull/2228&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;事件循环&lt;/a&gt; 并实现所有 &lt;a href=&#34;https://github.com/grafana/k6/releases/tag/v0.52.0&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;浏览器 API 作为异步方法&lt;/a&gt;。在大多数情况下，编写浏览器测试应该与编写原生 JavaScript，但可能存在一些难以识别和识别的不透明“陷阱”。&lt;/p&gt;&#xA;&lt;h3 id=&#34;the-native-k6check-does-not-support-passing-asynchronous-functions&#34;&gt;原生 k6/check 不支持传递异步函数&lt;/h3&gt;&#xA;&lt;p&gt;因为所有 k6 浏览器 API 方法都是异步的，所以编写这样的检查感觉很直观：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;从 &#39;k6&#39; 导入 { check }&#xA;...&#xA;// 不起作用&#xA;等待检查(page.locator(`h1`), {&#xA;&#39;文本内容正确&#39;: async(lo) =&gt; (await lo.textContent()) === &#39;预期内容&#39;&#xA;})&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;但是，这不起作用，因为本机 k6 检查是同步的。要解决此问题，您可以将原生 k6 检查替换为我们的 &lt;a href=&#34;https://jslib.k6.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;jslib.k6.io&lt;/a &gt; 版本。它是兼容的，并且可以在您现有的任何测试中直接替换。&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;从“https://jslib.k6.io/k6-utils/1.6.0/index.js”导入 { check }&#xA;...&#xA;// 有效！&#xA;等待检查(page.locator(`h1`), {&#xA;&#39;文本内容正确&#39;: async(lo) =&gt; (await lo.textContent()) === &#39;预期内容&#39;&#xA;})&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;dont-use-pagewaitfornavigation-unnecessarily&#34;&gt;不必要时不要使用 page.waitForNavigation&lt;/h3&gt;&#xA;&lt;p&gt;在编写浏览器测试时，了解网站的底层架构非常重要。您使用的是单页面应用程序 (SPA)，例如 React、Angular 或 Vue，还是传统的多页面应用程序 (MPA)？或者两者兼而有之？&lt;/p&gt;&#xA;&lt;p&gt;您可能期望只要浏览器中的 URL 发生变化，就会触发页面加载事件 - 但如果您的应用程序是 SPA，它会使用浏览器的 &lt;a href=&#34;https://developer.mozilla.org /en-US/docs/Web/API/History/pushState&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;history.pushState&lt;/a&gt; 方法，因此 &lt;code&gt;page.waitForNavigation()&lt;/code&gt;功能呼叫永远不会解决，阻止其余的 of 执行脚本，并最终超时。对于下面的下一个“陷阱”，这一点尤其需要注意。&lt;/p&gt;&#xA;&lt;h3 id=&#34;k6-doesnt-know-what-is-in-the-script-until-it-is-encountered&#34;&gt;k6 在遇到脚本之前并不知道脚本中有什么内容&lt;/h3&gt;&#xA;&lt;p&gt;如果您的脚本执行中途中止，则在此之后声明和执行的任何检查、日志或自定义指标都不会被注册。如果您已将脚本设置为仅在达到检查失败阈值时才会失败，则测试结果中将会出现误报。 &lt;em&gt;注意：请参阅下面的额外提示来解决此问题。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;have-a-bots-eye-view&#34;&gt;拥有“机器人之眼”视图&lt;/h3&gt;&#xA;&lt;p&gt;如果您采用上面的 &lt;strong&gt;performance-app-renders.js&lt;/strong&gt; 脚本并更改 h1 的定位器，该脚本现在会失败！&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;const perfH1Text = 等待页面&#xA;.locator(`#pageContent h1`)&#xA;.textContent()&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;没有任何日志表明出了什么问题——只是检查失败。如果我们从人的角度总结一下步骤：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;转到您的 Grafana 网址&lt;/li&gt;&#xA;&lt;li&gt;填写用户名，填写密码，然后点击&lt;strong&gt;登录&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;em&gt;等待页面导航&lt;/em&gt;&lt;/li&gt;&#xA;&lt;li&gt;点击&lt;strong&gt;菜单&lt;/strong&gt;开关，展开&lt;strong&gt;测试与合成&lt;/strong&gt;，点击&lt;strong&gt;性能&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;检查h1的文本内容是否为“Performance”&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如果您在浏览器中按照说明进行操作，请打开 devTools 控制台并运行 &lt;code&gt;document.querySelector(&#39;#pageContent h1`).textContent&lt;/code&gt; — 它会返回“Performance!”那么这是怎么回事？&lt; /p&gt;&#xA;&lt;p&gt;问题在于，执行脚本的机器人“思考”、“看到”和“评估”事物的速度比人类快得多。如果您在脚本开头添加此&lt;a href=&#34;https://gist.github.com/ckbedwell/c18142bb8aa20c7ba9133a8a53304e74&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;有用的调试代码段&lt;/a&gt;并打开devTools 控制台中，执行将暂停，以便调查发生了什么。&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1999px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;数据-SRc =“/media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png”data-srcset =“/media/blog/5-提示-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=320 320w，/media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=550 550w， /media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=750 750w，/media/blog/5-tips-for -k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=900 900w，/media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=1040 1040w， /media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=1240 1240w, /media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;使用 Chrome DevTools 调试 Grafana 的屏幕截图。屏幕分为两部分，左侧显示 Grafana，突出显示 0 宽度和 0 高度的 h1，右侧是显示的元素面板DOM 树。 h1 不包含文本内容。&#34;width=&#34;1999&#34;height=&#34;716&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png”&#xA;alt=&#34;使用 Chrome DevTools 调试 Grafana 的屏幕截图。屏幕分为两部分，左侧显示 Grafana，突出显示 0 宽度和 0 高度的 h1，右侧是显示 DOM 树的元素面板。h1 包含无文字内容。&#34;width=&#34;1999&#34;height=&#34;716&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;在等待插件加载的一瞬间，Grafana 在屏幕上渲染了一个空的 h1，满足我们正在寻找的选择器，因此它开始执行检查比较：h1 的文本内容是不是“性能”，因此检查和我们的测试最终失败。&lt;/p&gt;&#xA;&lt;p&gt;这让我们很好地进入了第四个技巧......&lt;/p&gt;&#xA;&lt;h2 id=&#34;tip-4-write-unique-and-durable-selectors-for-pagelocator&#34;&gt;提示 4：为 page.locator() 编写唯一且持久的选择器&lt;/h2&gt;&#xA;&lt;p&gt;我们有一个关于&lt;a href=&#34;/docs/k6/latest/using-k6-browser/recommished-practices/select-elements/&#34;&gt;选择元素&lt;/a&gt;的最佳实践指南，其中基本思想是创建持久的选择器：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于页面来说是唯一的（如果不是整个旅程，如果可能的话，如上面的错误所示！）&lt;/li&gt;&#xA;&lt;li&gt;保证稳定&lt;/li&gt;&#xA;&lt;li&gt;在脚本中传达意图&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如果您要编写一个浏览器脚本来测试 Grafana 的登录，那么在检查文档对象模型 (DOM) 时，您将在用户名输入字段中看到与此类似的标记：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/但是吨&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;&lt;input class=&#34;css-8tk2dk-input-input&#34; name=&#34;user&#34; id=&#34;:r0:&#34; autocapitalize=&#34;none&#34; placeholder=&#34;电子邮件或用户名&#34; data-testid=&#34;data-testid 用户名输入字段&#34;&gt;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;输入元素有几个属性。要决定适合使用哪个，您可以为每个分配一个分数：&lt;/p&gt;&#xA;&lt;表&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;页面唯一&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;价值稳定&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;传达意图&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;总计&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;自动大写&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;❌&#xA;&lt;/td&gt;&#xA;&lt;td&gt;❌&#xA;&lt;/td&gt;&#xA;&lt;td&gt;❌&#xA;&lt;/td&gt;&#xA;&lt;td&gt;0&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;类别&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;❌&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;1&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;id&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;2&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;姓名&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;TD&gt;2.5&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;占位符&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;TD&gt;2.5&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;数据测试id&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;3&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/表&gt;&#xA;&lt;p&gt;&lt;em&gt;❌=0，⚠️=0.5，✅=1&lt;/em&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可以立即排除&lt;strong&gt;自动大写&lt;/strong&gt;属性。不能保证它对于页面来说是唯一的，它与您尝试选择的内容无关，并且在查看测试脚本时很难推断您的意图。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可以考虑&lt;strong&gt;class&lt;/strong&gt;属性。当使用标签管理器工具或其他基本记录器充当选择器时，通常会使用它。但是使用这个属性有几个问题：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无法保证它对于页面来说是唯一的（在本例中，它不是唯一的，因为密码输入共享相同的类）&lt;/li&gt;&#xA;&lt;li&gt;它们通常被开发人员视为实现细节，并且可能会发生更改（尤其是在此处的情况下，其中值是由构建过程生成的）&lt;/li&gt;&#xA;&lt;li&gt;即使它是独特且稳定的，它也会使您的测试脚本更难以维护。其他人阅读您的脚本如何能够推断您正在选择用户名输入？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;id&lt;/strong&gt; 属性应该是唯一的，但在本例中它与 &lt;strong&gt;class&lt;/strong&gt; 存在类似的问题。熟悉 React API 的人会认识到此 ID 是由 &lt;a href=&#34;https://react.dev/reference/react/useId&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt; 生成的useId&lt;/code&gt; 钩子&lt;/a&gt;，因此，如果开发人员要在页面上的其他位置使用此钩子来获取在输入字段之前呈现的组件，则此 &lt;strong&gt;id&lt;/strong&gt; 值将会发生变化，因此不保证是稳定的选择器。在这种情况下，它也没有传达任何我阅读测试脚本时出现错误，因此不是一个好的候选者。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;名称&lt;/strong&gt;和&lt;strong&gt;占位符&lt;/strong&gt;属性具有相似的权重，两者都是在测试脚本中传达含义的稳定选择器的有力候选者。还有一些额外的注意事项：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果您想重复使用测试脚本来测试不同语言的页面，则必须在脚本中更新占位符选择器。&lt;/li&gt;&#xA;&lt;li&gt;如果您尚未与开发和/或内容团队沟通，他们可能不知道您刚刚为他们注册的测试合同。他们将来可能有充分的理由更新这两个属性的值并且不知道您的脚本即将崩溃。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;这给我们带来了&lt;strong&gt;data-testid。&lt;/strong&gt;它在 DOM 中是唯一的，它在脚本中传达意图，并且它与其他团队有一个隐含的合同，其唯一目的是用于测试脚本，因此它将保持稳定。这是您应该使用的理想选择器。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;page.locator(`[data-testid=&#34;data-testid 用户名输入字段&#34;]`)&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;此过程适用于具有合适属性或标记良好的 ID 或类的元素。您可以通过添加元素的标签名称来加强和进一步阐明意图。&lt;/p&gt;&#xA;&lt;p&gt;但是如果您没有任何有用的属性，会发生什么情况？有两个选项可以组合使用：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;查找节点的父树以找到合适的选择器。如果使用此方法，重要的是不要编写与 DOM 结构过于紧密相关的选择器。与 DOM 紧密耦合的选择器很脆弱并且容易崩溃，因为它们与开发人员的实现联系得太紧密，而开发人员的实现可能随时发生变化。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 好&#xA;page.locator(`#产品详细信息 h2`)&#xA;// 坏的&#xA;page.locator(`#product-detail &gt; 部分 &amp;gt; div &gt; div.arbitaryClass &gt; h2`)&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“2”&gt;&#xA;&lt;li&gt;将 xpath 选择器与 &lt;code&gt;text()&lt;/code&gt; 节点测试结合使用。 &lt;code&gt;page.locator()&lt;/code&gt; 支持 xpath 选择器，&lt;a href=&#34;https://devhints.io/xpath&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;有很多非常强大的选择器&lt;/a&gt;。强烈建议根据文本内容定位元素，因为它将测试脚本与实现细节分离，并专注于编写定位器，就像用户在页面上查找内容一样。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;page.locator(`//h2[text()=&#34;产品标题&#34;]`)&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h2 id=&#34;tip-5-use-threshold-options-or-the-fail-method-to-ensure-you-get-the-right-results&#34;&gt;提示 5：使用阈值选项或fail() 方法确保您获得正确的结果&lt;/h2&gt;&#xA;&lt;p&gt;每当您编写测试时，您都应该考虑您的接受标准以将其视为成功。但是我们如何定义浏览器测试的通过或失败？&lt;/p&gt;&#xA;&lt;p&gt;k6 提供了一个&lt;a href=&#34;/docs/k6/latest/using-k6/checks/&#34;&gt;检查 API&lt;/a&gt;，您可以在脚本执行的任何时刻定义某些内容是否通过或失败。检查可以很简单，例如确认 API 请求是否返回成功的状态代码、元素是否具有正确的文本内容，或者用户旅程是否花费了可接受的时间。&lt;/p&gt;&#xA;&lt;p&gt;您可能认为脚本中任何失败的检查都意味着整个测试应该失败，但如果这是默认行为，则大多数负载测试都会导致失败。在编写 k6 脚本时，您应该确定它在什么上下文中运行（即，它是性能测试还是综合监控？），以及正在使用什么场景、VU 和迭代。&lt;/p&gt;&#xA;&lt;p&gt;建立这些详细信息后，您可以确定考虑成功和失败的适当方法、要添加的检查以及适当的阈值 - 例如，此检查是警告，还是我们测试的严重失败？&lt; /p&gt;&#xA;&lt;p&gt;这里有两个示例，一个用于性能测试，一个用于综合监控，它们支持 k6 浏览器模块并演示如何使用检查 API。&lt;/p&gt;&#xA;&lt;h4 id=&#34;grafana-k6-performance-tests-using-the-browser-module&#34;&gt;使用浏览器模块进行 Grafana k6 性能测试&lt;/h4&gt;&#xA;&lt;p&gt;k6 性能测试是一种定义任意数量的场景、VU 和迭代的通用方法。在下面的例子中，我们有一个演示电子商务网站，我们是进行混合测试来记录如果我们推荐的产品 API 意外处于重负载下会发生什么情况。我们的推荐引擎是应用程序的重要组成部分，但它并不像确保客户可以下订单和结帐那样对业务至关重要。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;推荐-product-spike.js&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;从“k6/browser”导入 { browser }&#xA;从“k6/http”导入http&#xA;从“https://jslib.k6.io/k6-utils/1.6.0/index.js”导入{检查}&#xA;const Product_IDS = __ENV.Product_IDS&#xA;const HAS_SOME_LEEWAY = `警告`&#xA;const SUPER_IMPORTANT_CHECK = `关键`&#xA;const LESS_IMPORTANT = `信息`&#xA;导出常量选项= {&#xA;场景：{&#xA;用户界面：{&#xA;执行者：“constant-vus”，&#xA;持续时间：“1m”，&#xA;视：3，&#xA;选项： {&#xA;浏览器：{&#xA;类型：“铬”，&#xA;},&#xA;},&#xA;执行：“结帐完成”，&#xA;},&#xA;“spike-api”：{&#xA;执行者：“ramping-vus”，&#xA;起始VU：0，&#xA;阶段：[&#xA;{ 持续时间：“10 秒”，目标：10 }，&#xA;{ 持续时间：“40 秒”，目标：30 }，&#xA;{ 持续时间：“10 秒”，目标：10 }，&#xA;],&#xA;优雅的RampDown：“10秒”，&#xA;执行：“spikeApi”，&#xA;},&#xA;},&#xA;阈值：{&#xA;[`检查{重要性：${SUPER_IMPORTANT_CHECK}}`]：[“rate==1.0”]，&#xA;[`检查{重要性：${HAS_SOME_LEEWAY}}`]：[“比率&gt; = 0.95”]，&#xA;[`检查{重要性：${LESS_IMPORTANT}}`]：[“率&gt; = 0.9”]，&#xA;},&#xA;}&#xA;导出函数spikeApi() {&#xA;常量随机产品 =&#xA;product_ids[math.floor(math.random() * product_ids.length)]&#xA;const res = http.get(`https://otel-demo.field-eng.grafana.net/api/recommendations?productIds=${randomProduct}`)&#xA;查看（&#xA;资源，&#xA;{&#xA;“状态代码为 200”：(r) =&gt; r.status === 200,&#xA;},&#xA;{ 重要性：HAS_SOME_LEEWAY }&#xA;）&#xA;}&#xA;导出异步函数 checkoutCompletion() {&#xA;const context = 等待 browser.newContext()&#xA;const page = 等待 context.newPage()&#xA;等待 page.goto(`https://otel-demo.field-eng.grafana.net/`)&#xA;wait page.locator(`//*[text()=&#34;去购物&#34;]`).click()&#xA;等待 Promise.all([&#xA;页&#xA;.locator(`//*[text()=&#34;Starsense Explorer 折射望远镜&#34;]`)&#xA;。点击（），&#xA;page.waitForNavigation(),&#xA;]）&#xA;// 不太重要的检查&#xA;等待 checkForRecommendedProducts(页面, `产品页面`)&#xA;等待 Promise.all([&#xA;page.locator(`//*[text()=&#34; 添加到购物车&#34;]`).click(),&#xA;page.waitForNavigation(),&#xA;]）&#xA;// 不太重要的检查&#xA;等待 checkForRecommendedProducts(页面, `发货单`)&#xA;等待 Promise.all([&#xA;page.locator(`//*[text()=&#34;下订单&#34;]`).click(),&#xA;page.waitForNavigation(),&#xA;]）&#xA;// 超级重要的检查&#xA;等待检查（&#xA;页面.定位器(`h1`),&#xA;{&#xA;“下订单r 页面已到达”： async (lo) =&gt;&#xA;(await lo.textContent()) === &#34;您的订单已完成！&#34;,&#xA;},&#xA;{ 重要：SUPER_IMPORTANT_CHECK }&#xA;）&#xA;// 不太重要的检查&#xA;等待 checkForRecommendedProducts(页面, `订单确认`)&#xA;等待页面.close()&#xA;}&#xA;常量 TWO_SECONDS = 2000&#xA;异步函数 checkForRecommendedProducts(page, step) {&#xA;尝试 {&#xA;等待页面&#xA;.定位器(&#xA;`[data-cy=&#34;recommendation-list&#34;] [data-cy=&#34;product-card&#34;]:first-of-type`&#xA;）&#xA;.waitFor({ 超时: TWO_SECONDS })&#xA;} 捕获 (e) {&#xA;等待 page.screenshot({ 路径: `./screenshots/${step}.png` })&#xA;} 最后 {&#xA;const 卡 = 等待页面。$$(`[data-cy=&#34;product-card&#34;]`)&#xA;console.log(步骤, 卡.长度)&#xA;查看（&#xA;卡片长度，&#xA;{&#xA;&#34;显示4个推荐商品&#34;: (length) =&gt; length === 4,&#xA;},&#xA;{&#xA;重要性：LESS_IMPORTANT，&#xA;}&#xA;）&#xA;}&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;在上面的脚本中，有两种场景可以构成混合测试：&lt;code&gt;spike-api&lt;/code&gt;，它使用k6的&lt;a href=&#34;/docs/k6/latest/javascript -api/k6-http/&#34;&gt;&lt;code&gt;http&lt;/code&gt; 协议&lt;/a&gt; 用于模拟流量峰值，以及 &lt;code&gt;user-checkout&lt;/code&gt; 这是模拟结账流程的浏览器测试。共有三项检查，它们标有重要键和不同的值，具体取决于我们要求检查的成功程度。&lt;/p&gt;&#xA;&lt;p&gt;在 &lt;code&gt;options&lt;/code&gt; 对象中，为每个键/值对设置了一个阈值，该阈值将指示测试是通过还是失败。阈值中未使用 &lt;code&gt;abortOnFail&lt;/code&gt; 选项，因为如果测试过早结束，有价值的数据将会丢失。如果开始发生故障，了解 API 的故障程度以及浏览器前端发生的情况将很有用。&lt;/p&gt;&#xA;&lt;h4 id=&#34;synthetic-monitoring-check&#34;&gt;综合监控检查&lt;/h4&gt;&#xA;&lt;p&gt;如果您正在运行综合监控浏览器检查，则它将始终是一种场景，其中包含一个 VU 和一次迭代。综合监控目前不支持选项声明中的 &lt;code&gt;thresholds&lt;/code&gt; 对象（但即将推出！），因此您必须使用显式 &lt;a href=&#34;/docs/k6/latest/javascript- api/k6/fail/&#34;&gt;&lt;code&gt;fail()&lt;/code&gt; 方法&lt;/a&gt; 让探测器知道检查失败。&lt;/p&gt;&#xA;&lt;p&gt;综合监控浏览器检查的行为与 k6 检查不同，因为它们主要根据您对正常运行时间的定义来评估您的测试是否通过或失败。对于非脚本化综合监控检查，您可以在创建检查期间在其自己的步骤中使用一组断言来定义正常运行时间，但由于浏览器检查是作为脚本编写的，因此您需要明确标记要计入定义的内容正常运行时间。&lt;/p&gt;&#xA;&lt;p&gt;如果您采用上面的&lt;strong&gt;recommended-product-spike-test.js&lt;/strong&gt;脚本并提取结账流程场景，则只需进行少量修改即可满足综合监控浏览器检查的需求。通过在检查中添加&lt;code&gt;fail()&lt;/code&gt;方法，确认订单是否c到达确认页面后，综合监控探测器现在将了解什么构成正常运行时间故障并正确报告。&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (&#xA;!(等待检查(page.locator(`h1`), {&#xA;&#34;已到达下订单页面&#34;: async (lo) =&gt; (await lo.textContent()) === &#34;您的订单已完成！&#34;,&#xA;}））&#xA;）{&#xA;失败（`未到达订单完成页面`）&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;我们可以将不太重要的检查留在脚本中，而无需向它们添加显式失败，因为这只是我们从此设置中获得的好处。我们甚至可以使用 &lt;a href=&#34;/products/cloud/alerting/&#34;&gt;Grafana Alerting&lt;/a&gt; 添加自定义警报，以了解推荐的产品是否呈现不一致。&lt;/p&gt;&#xA;&lt;p&gt;综合监控浏览器检查的这种灵活性意味着您只需一次执行即可设置主要和次要断言，从而节省时间和金钱！&lt;/p&gt;&#xA;&lt;h2 id=&#34;bonus-tip-dont-just-account-for-the-happy-path&#34;&gt;额外提示：不要只考虑“快乐”路径&lt;/h2&gt;&#xA;&lt;p&gt;在任何类型的测试中，一个臭名昭著的错误就是假设它们总是会成功。然而，测试的真正价值在于，当不可避免的故障发生时，测试能否很好地告诉我们他们遇到的问题？&lt;/p&gt;&#xA;&lt;p&gt;如果您查看 &lt;strong&gt;recommend-product-spike.js&lt;/strong&gt; 中的结账场景，就会发现调用了多个 &lt;code&gt;page.locator().click()&lt;/code&gt; 函数。如果我们的应用程序出现错误并且这些内容无法正确显示且选择器失败，会发生什么情况？&lt;/p&gt;&#xA;&lt;p&gt;每次迭代都会等待&lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/locator/click/#clickoptions&#34;&gt;默认 30 秒&lt;/a&gt;，然后超时并引发失败。这对于我们的测试来说可能是一个问题，因为它会“阻塞”VU 30 秒，然后结束迭代并重新开始。问题的第一部分是这个测试只运行一分钟，所以如果它提早遇到问题，我们会丢失很多潜在的迭代以及它们将生成的所有附加数据。&lt;/p&gt;&#xA;&lt;p&gt;有两种方法可以解决这个问题：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;为每个 &lt;code&gt;page.locator().click()&lt;/code&gt;（以及类似方法）提供各自适当的超时&lt;/li&gt;&#xA;&lt;li&gt;使用 &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/page/setdefaulttimeout/#setdefaulttimeouttimeout&#34;&gt;&lt;code&gt;page.setDefaultTimeout() 在页面上设置默认超时值&lt;/代码&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;每种方法都有其优点和缺点，由您决定哪种方法有效最适合你。&lt;/p&gt;&#xA;&lt;p&gt;上面的技巧三概述了第二个问题：测试执行被停止，从未遇到过确认订单页面是否已到达的检查，并且测试指标中未报告此故障。解决方案是在我们的 &lt;code&gt;try / finally&lt;/code&gt; 语句中添加一个 catch 块：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;尝试 {&#xA;...&#xA;} 捕获 (e) {&#xA;控制台.错误(e)&#xA;等待页面.screenshot({&#xA;路径：`./screenshots/${__VU}_${__ITER}-failure.png`,&#xA;})&#xA;查看（&#xA;无效的，&#xA;{&#xA;&#34;已到达下订单页面&#34;: false,&#xA;},&#xA;{ 重要：SUPER_IMPORTANT_CHECK }&#xA;）&#xA;} 最后 {&#xA;...&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;&lt;em&gt;注意：最好的做法是截取屏幕截图，以使调试会话更加轻松。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果任何执行导致未处理的异常，综合监控会报告正常运行时间失败，因此，如果您添加此 catch 块，请记住重新抛出错误（如果您更喜欢默认日志记录，则使用您自己的日志记录）或调用 k6 的 &lt;code &gt;fail()&lt;/code&gt; 方法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;summing-up&#34;&gt;总结&lt;/h2&gt;&#xA;&lt;p&gt;k6 浏览器 API 是一款多功能工具，可帮助监控网站的性能和可靠性。通过上述提示，您可以在编写测试时确保紧密的反馈循环，同时保持它们的适应性和无错误。最终，这些最佳实践将使您更轻松地识别潜在的性能问题并优化您的最终用户体验。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;Grafana Cloud 是开始浏览器测试的最简单方法。借助 &lt;a href=&#34;/products/cloud/k6/&#34;&gt;Grafana Cloud k6&lt;/a&gt;，您可以轻松地将前端和后端测试结合到单个基于云的测试中。 &lt;a href=&#34;/products/cloud/synthetic-monitoring/&#34;&gt;Grafana Cloud Synthetic Monitoring&lt;/a&gt; 支持对生产环境中的关键旅程进行持续监控。我们提供慷慨的永久免费套餐和针对每个用例量身定制的计划。立即免费注册 (&lt;a href=&#34;/auth/sign-up/create-user?pg=plugins&amp;plcmt=grafana-synthetic-monitoring-app&amp;redirectPath=synthetic-monitoring&#34;&gt;Grafana Cloud k6&lt;/a&gt; 或 &lt;a href =&#34;/auth/sign-up/create-user?pg=plugins&amp;plcmt=grafana-synthetic-monitoring-app&#34;&gt;Grafana 云综合监控&lt;/a&gt;）！&lt;/em&gt;&lt;/p&gt;</description>
      <pubDate>Thu, 21 Nov 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Exploring OpenTelemetry Collector configurations in Grafana Cloud: a tasting menu approach】探索 Grafana Cloud 中的 OpenTelemetry Collector 配置：品尝菜单方法</title>
      <link>https://grafana.com/blog/2024/11/27/exploring-opentelemetry-collector-configurations-in-grafana-cloud-a-tasting-menu-approach/</link>
      <description>【&lt;p&gt;I&amp;rsquo;m a big fan of &lt;a href=&#34;https://en.wikipedia.org/wiki/Tasting_menu&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;tasting menus&lt;/a&gt;. In the culinary world they let us sample a variety of dishes in small portions, helping us understand and appreciate different flavors and options.&lt;/p&gt;&#xA;&lt;p&gt;Inspired by this concept and a &lt;a href=&#34;https://github.com/jpkrohling/talks/tree/main/2024/2024-05-24-cncf-santa-catarina/receitas&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;talk I gave earlier this year&lt;/a&gt;, I have crafted a &amp;ldquo;tasting menu&amp;rdquo; of OpenTelemetry Collector configurations in Grafana Cloud. This blog post presents four distinct recipes, complete with code snippets and a GitHub repository for full examples and usage instructions, are each designed to introduce you to different aspects of telemetry data collection and management.&lt;/p&gt;&#xA;&lt;p&gt;Those recipes are part of a cookbook I &lt;a href=&#34;https://github.com/jpkrohling/otelcol-cookbook&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;keep on GitHub&lt;/a&gt;. So whether you are just starting with OpenTelemetry or looking to optimize your existing setup, these configurations will help you appreciate a good range of capabilities the OpenTelemetry Collector offers. So, as we say in Portuguese, bom apetite!&lt;/p&gt;&#xA;&lt;div class=&#34;br-4 base-border border-color-gray-3 docs_tabs&#34;&gt;&#xA;&lt;div x-data=&#34;app_content_tabs([&amp;#34;Appetizer&amp;#34;,&amp;#34;Main course 1&amp;#34;,&amp;#34;Main course 2&amp;#34;,&amp;#34;Dessert&amp;#34;], &#39;b277ffe245eea36efce0533d1e538bbe&#39;)&#34; x-init=&#34;init()&#34;&gt;&#xA;&lt;div class=&#34;d-flex w-100p flex-direction-row align-items-center justify-content-flex-start d-md-none&#34;&gt;&#xA;&lt;select class=&#34;docs_tabs--select w-100p base-border-bottom border-color-gray-3&#34; @change=&#34;toggle($event.target.value)&#34;&gt;&#xA;&lt;option value=&#34;Appetizer&#34; :selected=&#34;active === &#39;Appetizer&#39;&#34;&gt;Appetizer&lt;/option&gt;&#xA;&lt;option value=&#34;Main course 1&#34; :selected=&#34;active === &#39;Main course 1&#39;&#34;&gt;Main course 1&lt;/option&gt;&#xA;&lt;option value=&#34;Main course 2&#34; :selected=&#34;active === &#39;Main course 2&#39;&#34;&gt;Main course 2&lt;/option&gt;&#xA;&lt;option value=&#34;Dessert&#34; :selected=&#34;active === &#39;Dessert&#39;&#34;&gt;Dessert&lt;/option&gt;&#xA;&lt;/select&gt;&#xA;&lt;/div&gt;&#xA;&lt;nav class=&#34;docs_tabs--navigation base-border-bottom border-color-gray-3 d-none d-md-block&#34; role=&#34;tablist&#34; data-codetoggle=&#34;true&#34;&gt;&#xA;&lt;button&#xA;class=&#34;docs_tabs--label f-14 bg-transparent color-gray-11 py-8 px-1&#34;&#xA;data-toggle=&#34;tab&#34;&#xA;role=&#34;tab&#34;&#xA;@click=&#34;toggle(&#39;Appetizer&#39;)&#34;&#xA;:class=&#34;{ &#39;docs_tabs--label-active&#39;: active === &#39;Appetizer&#39; }&#34;&#xA;&gt;&#xA;Appetizer&#xA;&lt;/button&gt;&#xA;&lt;button&#xA;class=&#34;docs_tabs--label f-14 bg-transparent color-gray-11 py-8 px-1&#34;&#xA;data-toggle=&#34;tab&#34;&#xA;role=&#34;tab&#34;&#xA;@click=&#34;toggle(&#39;Main course 1&#39;)&#34;&#xA;:class=&#34;{ &#39;docs_tabs--label-active&#39;: active === &#39;Main course 1&#39; }&#34;&#xA;&gt;&#xA;Main course 1&#xA;&lt;/button&gt;&#xA;&lt;button&#xA;class=&#34;docs_tabs--label f-14 bg-transparent color-gray-11 py-8 px-1&#34;&#xA;data-toggle=&#34;tab&#34;&#xA;role=&#34;tab&#34;&#xA;@click=&#34;toggle(&#39;Main course 2&#39;)&#34;&#xA;:class=&#34;{ &#39;docs_tabs--label-active&#39;: active === &#39;Main course 2&#39; }&#34;&#xA;&gt;&#xA;Main course 2&#xA;&lt;/button&gt;&#xA;&lt;button&#xA;class=&#34;docs_tabs--label f-14 bg-transparent color-gray-11 py-8 px-1&#34;&#xA;data-toggle=&#34;tab&#34;&#xA;role=&#34;tab&#34;&#xA;@click=&#34;toggle(&#39;Dessert&#39;)&#34;&#xA;:class=&#34;{ &#39;docs_tabs--label-active&#39;: active === &#39;Dessert&#39; }&#34;&#xA;&gt;&#xA;Dessert&#xA;&lt;/button&gt;&#xA;&lt;/nav&gt;&#xA;&lt;div class=&#34;docs_tabs--content-container&#34;&gt;&#xA;&lt;div&#xA;class=&#34;docs_tabs--content py-1 px-2&#34;&#xA;:class=&#34;active === &#39;Appetizer&#39; ? &#39;d-block&#39; : &#39;d-none&#39;&#34;&#xA;id=&#34;&#34;&#xA;role=&#34;tabpanel&#34;&#xA;aria-labelledby=&#34;&#34;&#xA;&gt;&#xA;&lt;h2 id=&#34;internal-telemetry-salad&#34;&gt;Internal telemetry salad&lt;/h2&gt;&#xA;&lt;p&gt;We start with a light yet informative configuration that involves sending the Collector&amp;rsquo;s own internal telemetry data to external storage. This dish will help you understand how to extract and read internal telemetry data from the Collector, including metrics and traces.&lt;/p&gt;&#xA;&lt;p&gt;In this configuration, we create one pipeline for each signal type and use the same receiver and exporter for all of them. However, we need to use the debug exporter, as we are not interested in the telemetry that comes to the Collector; we are interested in the telemetry that is generated &lt;em&gt;by&lt;/em&gt; the Collector.&lt;/p&gt;&#xA;&lt;p&gt;Under &lt;code&gt;service::telemetry&lt;/code&gt;, we configure how to send the internal traces and metrics to an external OpenTelemetry protocol (OTLP) endpoint. In this case, we are using the OTLP endpoint for a &lt;a href=&#34;/products/cloud/pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt; instance, obtained from the “OpenTelemetry Configuration” page, which can be found on your “Manage your stack” page.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1236px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/tasting-menu/manage-your-stack.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/tasting-menu/manage-your-stack.png&#34;data-srcset=&#34;/media/blog/tasting-menu/manage-your-stack.png?w=320 320w, /media/blog/tasting-menu/manage-your-stack.png?w=550 550w, /media/blog/tasting-menu/manage-your-stack.png?w=750 750w, /media/blog/tasting-menu/manage-your-stack.png?w=900 900w, /media/blog/tasting-menu/manage-your-stack.png?w=1040 1040w, /media/blog/tasting-menu/manage-your-stack.png?w=1240 1240w, /media/blog/tasting-menu/manage-your-stack.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Manage your stack page in the Grafana Cloud UI&#34;width=&#34;1236&#34;height=&#34;809&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/tasting-menu/manage-your-stack.png&#34;&#xA;alt=&#34;Manage your stack page in the Grafana Cloud UI&#34;width=&#34;1236&#34;height=&#34;809&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;Also on that page, we can look at the environment variable &lt;code&gt;OTEL_EXPORTER_OTLP_HEADERS&lt;/code&gt; that is shown after generating a token. Keep this handy, as we&amp;rsquo;ll need the value of the Authorization header later.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1529px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/tasting-menu/environment-variables.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/tasting-menu/environment-variables.png&#34;data-srcset=&#34;/media/blog/tasting-menu/environment-variables.png?w=320 320w, /media/blog/tasting-menu/environment-variables.png?w=550 550w, /media/blog/tasting-menu/environment-variables.png?w=750 750w, /media/blog/tasting-menu/environment-variables.png?w=900 900w, /media/blog/tasting-menu/environment-variables.png?w=1040 1040w, /media/blog/tasting-menu/environment-variables.png?w=1240 1240w, /media/blog/tasting-menu/environment-variables.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of Environmental Variables code&#34;width=&#34;1529&#34;height=&#34;478&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/tasting-menu/environment-variables.png&#34;&#xA;alt=&#34;A screenshot of Environmental Variables code&#34;width=&#34;1529&#34;height=&#34;478&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;ingredients&#34;&gt;Ingredients&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;An OpenTelemetry Collector distribution that is able to ingest OTLP data via gRPC, and export data with the debug exporter. I used &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-releases/releases/tag/v0.113.0&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;OTel Collector Contrib v0.113.0&lt;/a&gt; for this blog post.&lt;/li&gt;&#xA;&lt;li&gt;An application that can generate OTLP data, such as &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/cmd/telemetrygen&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;telemetrygen&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;A configuration file with the &lt;code&gt;service::telemetry&lt;/code&gt; section properly configured&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;configuration-example&#34;&gt;Configuration example&lt;/h3&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;receivers:&#xA;otlp:&#xA;protocols:&#xA;http:&#xA;grpc:&#xA;exporters:&#xA;debug:&#xA;service:&#xA;pipelines:&#xA;traces:&#xA;receivers: [otlp]&#xA;exporters: [debug]&#xA;metrics:&#xA;receivers: [otlp]&#xA;exporters: [debug]&#xA;logs:&#xA;receivers: [otlp]&#xA;exporters: [debug]&#xA;telemetry:&#xA;traces:&#xA;processors:&#xA;- batch:&#xA;schedule_delay: 1000&#xA;exporter:&#xA;otlp:&#xA;endpoint: https://otlp-gateway-prod-eu-west-2.grafana.net/otlp/v1/traces&#xA;protocol: http/protobuf&#xA;headers:&#xA;Authorization: &amp;#34;Basic ...&amp;#34;&#xA;metrics:&#xA;level: detailed&#xA;readers:&#xA;- periodic:&#xA;exporter:&#xA;otlp:&#xA;endpoint: https://otlp-gateway-prod-eu-west-2.grafana.net/otlp/v1/metrics&#xA;protocol: http/protobuf&#xA;headers:&#xA;Authorization: &amp;#34;Basic ...&amp;#34;&#xA;resource:&#xA;&amp;#34;service.name&amp;#34;: &amp;#34;otelcol-own-telemetry&amp;#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;preparation&#34;&gt;Preparation&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Change the configuration file to include the correct value for the &lt;code&gt;Basic&lt;/code&gt; authentication header and endpoint&lt;/li&gt;&#xA;&lt;li&gt;Run the OpenTelemetry Collector:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;otelcol-contrib --config ./otelcol.yaml&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;Send some telemetry to the Collector. By default, each trace reported by &lt;code&gt;telemetrygen&lt;/code&gt; comes with two spans. Note that this telemetry will be discarded with the configuration provided, but the actions the Collector performed will be recorded:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;telemetrygen traces --traces 1 --otlp-insecure --otlp-attributes=&amp;#39;cookbook=&amp;#34;own-telemetry&amp;#34;&amp;#39;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;On Grafana Cloud, select the traces data source and you’ll be able to find a trace that represents the Collector processing of the &lt;code&gt;telemetrygen&lt;/code&gt; call:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1277px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/tasting-menu/traces-data.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/tasting-menu/traces-data.png&#34;data-srcset=&#34;/media/blog/tasting-menu/traces-data.png?w=320 320w, /media/blog/tasting-menu/traces-data.png?w=550 550w, /media/blog/tasting-menu/traces-data.png?w=750 750w, /media/blog/tasting-menu/traces-data.png?w=900 900w, /media/blog/tasting-menu/traces-data.png?w=1040 1040w, /media/blog/tasting-menu/traces-data.png?w=1240 1240w, /media/blog/tasting-menu/traces-data.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of a TraceQL query in Grafana Cloud&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/tasting-menu/traces-data.png&#34;&#xA;alt=&#34;A screenshot of a TraceQL query in Grafana Cloud&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;ol start=&#34;5&#34;&gt;&#xA;&lt;li&gt;Now, change to your metrics data source, and select the metric &lt;code&gt;otelcol_exporter_sent_spans_total&lt;/code&gt;. We can see that our Collector reported that it received the two spans.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1277px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/tasting-menu/two-spans.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/tasting-menu/two-spans.png&#34;data-srcset=&#34;/media/blog/tasting-menu/two-spans.png?w=320 320w, /media/blog/tasting-menu/two-spans.png?w=550 550w, /media/blog/tasting-menu/two-spans.png?w=750 750w, /media/blog/tasting-menu/two-spans.png?w=900 900w, /media/blog/tasting-menu/two-spans.png?w=1040 1040w, /media/blog/tasting-menu/two-spans.png?w=1240 1240w, /media/blog/tasting-menu/two-spans.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of the query UI in Grafana Cloud&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/tasting-menu/two-spans.png&#34;&#xA;alt=&#34;A screenshot of the query UI in Grafana Cloud&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;tasting-notes&#34;&gt;Tasting notes&lt;/h3&gt;&#xA;&lt;p&gt;We&amp;rsquo;ve now seen that we can observe the Collector to understand what it is doing—we have easy access to its metrics and traces. But what about the logs?&lt;/p&gt;&#xA;&lt;p&gt;For the moment, the logs are available only on the console and should be captured separately. Avoid the temptation to use a file log receiver to read the instance’s own log. It might cause an endless loop of events and violates the principle that software should NOT monitor itself.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div&#xA;class=&#34;docs_tabs--content py-1 px-2&#34;&#xA;:class=&#34;active === &#39;Main course 1&#39; ? &#39;d-block&#39; : &#39;d-none&#39;&#34;&#xA;id=&#34;&#34;&#xA;role=&#34;tabpanel&#34;&#xA;aria-labelledby=&#34;&#34;&#xA;&gt;&#xA;&lt;h2 id=&#34;mixed-events-and-metrics&#34;&gt;Mixed events and metrics&lt;/h2&gt;&#xA;&lt;p&gt;Our first main course features a ratatouille of events and metrics from a Kubernetes cluster. The Collector is provisioned by the OpenTelemetry Operator, running in a Kubernetes cluster in &amp;ldquo;deployment&amp;rdquo; mode, and adheres to the &lt;a href=&#34;https://opentelemetry.io/docs/specs/otel/metrics/data-model/#single-writer&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Single Writer Principle&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h3 id=&#34;ingredients&#34;&gt;Ingredients&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A Kubernetes cluster, such as one provisioned locally via k3d&lt;/li&gt;&#xA;&lt;li&gt;The OpenTelemetry Operator running in the cluster&lt;/li&gt;&#xA;&lt;li&gt;Your Grafana Cloud credentials in a Kubernetes secret&lt;/li&gt;&#xA;&lt;li&gt;A Collector configuration using the &lt;code&gt;k8s_cluster&lt;/code&gt; and &lt;code&gt;k8s_events&lt;/code&gt; receivers&lt;/li&gt;&#xA;&lt;li&gt;A workload that would generate a few Kubernetes events&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;kubens&lt;/code&gt; from the &lt;a href=&#34;https://github.com/ahmetb/kubectx&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;kubectx&lt;/code&gt;&lt;/a&gt; project&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;configuration-example&#34;&gt;Configuration example&lt;/h3&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt; extensions:&#xA;basicauth:&#xA;client_auth:&#xA;username: &amp;#34;${env:GRAFANA_CLOUD_USER}&amp;#34;&#xA;password: &amp;#34;${env:GRAFANA_CLOUD_TOKEN}&amp;#34;&#xA;receivers:&#xA;k8s_events: {}&#xA;k8s_cluster:&#xA;collection_interval: 15s&#xA;exporters:&#xA;otlphttp:&#xA;endpoint: https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;auth:&#xA;authenticator: basicauth&#xA;service:&#xA;extensions: [ basicauth ]&#xA;pipelines:&#xA;metrics:&#xA;receivers: [ k8s_cluster ]&#xA;exporters: [ otlphttp ]&#xA;logs:&#xA;receivers: [ k8s_events ]&#xA;exporters: [ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;preparation&#34;&gt;Preparation&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Make sure you have a running Kubernetes cluster and OpenTelemetry Operator configured, and that you have your context set to the &lt;code&gt;observability&lt;/code&gt; namespace. If you don’t know how to start, you can try these commands for a local setup:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;k3d cluster create&#xA;kubectl apply -f https://github.com/cert-manager/cert-manager/releases/latest/download/cert-manager.yaml&#xA;kubectl wait --for=condition=Available deployments/cert-manager -n cert-manager&#xA;kubectl apply -f https://github.com/open-telemetry/opentelemetry-operator/releases/latest/download/opentelemetry-operator.yaml&#xA;kubectl wait --for=condition=Available deployments/opentelemetry-operator-controller-manager -n opentelemetry-operator-system&#xA;kubectl create namespace observability&#xA;kubens observability&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;Create a secret with your Grafana Cloud credentials. In this example, we have them already set as env vars; replace them appropriately.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;kubectl create secret generic grafana-cloud-credentials \&#xA;--from-literal=GRAFANA_CLOUD_USER=&amp;#34;$GRAFANA_CLOUD_USER&amp;#34; \&#xA;--from-literal=GRAFANA_CLOUD_TOKEN=&amp;#34;$GRAFANA_CLOUD_TOKEN&amp;#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;We’ll now create a &lt;code&gt;ClusterRole&lt;/code&gt; for our Collector:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;apiVersion: rbac.authorization.k8s.io/v1&#xA;kind: ClusterRole&#xA;metadata:&#xA;name: otelcol&#xA;rules:&#xA;- apiGroups:&#xA;- &amp;#34;&amp;#34;&#xA;resources:&#xA;- events&#xA;- namespaces&#xA;- namespaces/status&#xA;- nodes&#xA;- nodes/spec&#xA;- pods&#xA;- pods/status&#xA;- replicationcontrollers&#xA;- replicationcontrollers/status&#xA;- resourcequotas&#xA;- services&#xA;verbs:&#xA;- get&#xA;- list&#xA;- watch&#xA;- apiGroups:&#xA;- apps&#xA;resources:&#xA;- daemonsets&#xA;- deployments&#xA;- replicasets&#xA;- statefulsets&#xA;verbs:&#xA;- get&#xA;- list&#xA;- watch&#xA;- apiGroups:&#xA;- extensions&#xA;resources:&#xA;- daemonsets&#xA;- deployments&#xA;- replicasets&#xA;verbs:&#xA;- get&#xA;- list&#xA;- watch&#xA;- apiGroups:&#xA;- batch&#xA;resources:&#xA;- jobs&#xA;- cronjobs&#xA;verbs:&#xA;- get&#xA;- list&#xA;- watch&#xA;- apiGroups:&#xA;- autoscaling&#xA;resources:&#xA;- horizontalpodautoscalers&#xA;verbs:&#xA;- get&#xA;- list&#xA;- watch&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;We’ll create a &lt;code&gt;ServiceAccount&lt;/code&gt; that will be used by our Collector instance, and we’ll bind the cluster role to the account:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;apiVersion: v1&#xA;kind: ServiceAccount&#xA;metadata:&#xA;name: otelcol-k8s&#xA;namespace: observability&#xA;---&#xA;apiVersion: rbac.authorization.k8s.io/v1&#xA;kind: ClusterRoleBinding&#xA;metadata:&#xA;name: otelcol&#xA;roleRef:&#xA;apiGroup: rbac.authorization.k8s.io&#xA;kind: ClusterRole&#xA;name: otelcol&#xA;subjects:&#xA;- kind: ServiceAccount&#xA;name: otelcol-k8s&#xA;namespace: observability&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;5&#34;&gt;&#xA;&lt;li&gt;We’ll now configure our Collector to obtain metrics and events (as logs) from the Kubernetes cluster.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;apiVersion: opentelemetry.io/v1beta1&#xA;kind: OpenTelemetryCollector&#xA;metadata:&#xA;name: otelcol-k8s&#xA;namespace: observability&#xA;spec:&#xA;image: ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector-contrib:0.113.0&#xA;serviceAccount: otelcol-k8s&#xA;envFrom:&#xA;- secretRef:&#xA;name: grafana-cloud-credentials&#xA;config:&#xA;extensions:&#xA;basicauth:&#xA;client_auth:&#xA;username: &amp;#34;${env:GRAFANA_CLOUD_USER}&amp;#34;&#xA;password: &amp;#34;${env:GRAFANA_CLOUD_TOKEN}&amp;#34;&#xA;receivers:&#xA;k8s_events: {}&#xA;k8s_cluster:&#xA;collection_interval: 15s&#xA;exporters:&#xA;otlphttp:&#xA;endpoint: https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;auth:&#xA;authenticator: basicauth&#xA;service:&#xA;extensions: [ basicauth ]&#xA;pipelines:&#xA;metrics:&#xA;receivers: [ k8s_cluster ]&#xA;exporters: [ otlphttp ]&#xA;logs:&#xA;receivers: [ k8s_events ]&#xA;exporters: [ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;If you don’t have a workload running in your Kubernetes cluster, this one should be enough to generate a few events.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;apiVersion: apps/v1&#xA;kind: Deployment&#xA;metadata:&#xA;name: nginx-deployment&#xA;spec:&#xA;selector:&#xA;matchLabels:&#xA;app: nginx&#xA;template:&#xA;metadata:&#xA;labels:&#xA;app: nginx&#xA;spec:&#xA;containers:&#xA;- name: nginx&#xA;image: nginx:1.27.2&#xA;ports:&#xA;- containerPort: 80&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;6&#34;&gt;&#xA;&lt;li&gt;At this point, you should have received a few events in your Grafana Cloud instance.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1277px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/tasting-menu/cloud-logs.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/tasting-menu/cloud-logs.png&#34;data-srcset=&#34;/media/blog/tasting-menu/cloud-logs.png?w=320 320w, /media/blog/tasting-menu/cloud-logs.png?w=550 550w, /media/blog/tasting-menu/cloud-logs.png?w=750 750w, /media/blog/tasting-menu/cloud-logs.png?w=900 900w, /media/blog/tasting-menu/cloud-logs.png?w=1040 1040w, /media/blog/tasting-menu/cloud-logs.png?w=1240 1240w, /media/blog/tasting-menu/cloud-logs.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Events populating in Grafana Cloud&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/tasting-menu/cloud-logs.png&#34;&#xA;alt=&#34;Events populating in Grafana Cloud&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Kubernetes metrics, such as &lt;code&gt;k8s_container_ready&lt;/code&gt;, should also be available.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1277px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/tasting-menu/k8s-metrics.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/tasting-menu/k8s-metrics.png&#34;data-srcset=&#34;/media/blog/tasting-menu/k8s-metrics.png?w=320 320w, /media/blog/tasting-menu/k8s-metrics.png?w=550 550w, /media/blog/tasting-menu/k8s-metrics.png?w=750 750w, /media/blog/tasting-menu/k8s-metrics.png?w=900 900w, /media/blog/tasting-menu/k8s-metrics.png?w=1040 1040w, /media/blog/tasting-menu/k8s-metrics.png?w=1240 1240w, /media/blog/tasting-menu/k8s-metrics.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Metrics populating a graph in the Grafana UI&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/tasting-menu/k8s-metrics.png&#34;&#xA;alt=&#34;Metrics populating a graph in the Grafana UI&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;tasting-notes&#34;&gt;Tasting notes&lt;/h3&gt;&#xA;&lt;p&gt;We just had a small taste of what those components can do, and this left us with enough information to explore this idea further: which metrics could be interesting for us to watch? How can we combine metrics to tell a story? That’s where we can go from here.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div&#xA;class=&#34;docs_tabs--content py-1 px-2&#34;&#xA;:class=&#34;active === &#39;Main course 2&#39; ? &#39;d-block&#39; : &#39;d-none&#39;&#34;&#xA;id=&#34;&#34;&#xA;role=&#34;tabpanel&#34;&#xA;aria-labelledby=&#34;&#34;&#xA;&gt;&#xA;&lt;h2 id=&#34;bibimbap-of-logs&#34;&gt;Bibimbap of logs&lt;/h2&gt;&#xA;&lt;p&gt;The second main course explores a Collector configured in &amp;ldquo;daemonset&amp;rdquo; mode to collect an assortment of logs from pods running on the same node, potentially following different formats and from various namespaces. This configuration emphasizes placing the Collector close to the telemetry source.&lt;/p&gt;&#xA;&lt;h3 id=&#34;ingredients&#34;&gt;Ingredients&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A Kubernetes cluster, like in the previous recipe&lt;/li&gt;&#xA;&lt;li&gt;The OpenTelemetry Operator running in the cluster&lt;/li&gt;&#xA;&lt;li&gt;Your Grafana Cloud credentials in a Kubernetes secret&lt;/li&gt;&#xA;&lt;li&gt;A Collector configuration using the &lt;code&gt;filelog&lt;/code&gt; receiver&lt;/li&gt;&#xA;&lt;li&gt;A workload that would generate a few Kubernetes events&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;configuration-example&#34;&gt;Configuration example&lt;/h3&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt; extensions:&#xA;basicauth:&#xA;client_auth:&#xA;username: &amp;#34;${env:GRAFANA_CLOUD_USER}&amp;#34;&#xA;password: &amp;#34;${env:GRAFANA_CLOUD_TOKEN}&amp;#34;&#xA;receivers:&#xA;filelog:&#xA;exclude: []&#xA;include:&#xA;- /var/log/pods/*/*/*.log&#xA;include_file_name: false&#xA;include_file_path: true&#xA;operators:&#xA;- id: container-parser&#xA;max_log_size: 102400&#xA;type: container&#xA;retry_on_failure:&#xA;enabled: true&#xA;start_at: end&#xA;exporters:&#xA;otlphttp:&#xA;endpoint: https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;auth:&#xA;authenticator: basicauth&#xA;service:&#xA;extensions: [ basicauth ]&#xA;pipelines:&#xA;logs:&#xA;receivers: [ filelog ]&#xA;exporters: [ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;preparation&#34;&gt;Preparation&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Make sure you have a Kubernetes cluster and an OTel Operator running. Feel free to reuse the one you configured in the previous recipe.&lt;/li&gt;&#xA;&lt;li&gt;Next, create a custom resource with the following configuration.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;apiVersion: opentelemetry.io/v1beta1&#xA;kind: OpenTelemetryCollector&#xA;metadata:&#xA;name: otelcol-podslogs&#xA;namespace: observability&#xA;spec:&#xA;image: ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector-contrib:0.113.0&#xA;mode: daemonset&#xA;envFrom:&#xA;- secretRef:&#xA;name: grafana-cloud-credentials&#xA;volumes:&#xA;- name: varlogpods&#xA;hostPath:&#xA;path: /var/log/pods&#xA;volumeMounts:&#xA;- name: varlogpods&#xA;mountPath: /var/log/pods&#xA;readOnly: true&#xA;config:&#xA;extensions:&#xA;basicauth:&#xA;client_auth:&#xA;username: &amp;#34;${env:GRAFANA_CLOUD_USER}&amp;#34;&#xA;password: &amp;#34;${env:GRAFANA_CLOUD_TOKEN}&amp;#34;&#xA;receivers:&#xA;filelog:&#xA;exclude: []&#xA;include:&#xA;- /var/log/pods/*/*/*.log&#xA;include_file_name: false&#xA;include_file_path: true&#xA;operators:&#xA;- id: container-parser&#xA;max_log_size: 102400&#xA;type: container&#xA;retry_on_failure:&#xA;enabled: true&#xA;start_at: end&#xA;exporters:&#xA;otlphttp:&#xA;endpoint: https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;auth:&#xA;authenticator: basicauth&#xA;service:&#xA;extensions: [ basicauth ]&#xA;pipelines:&#xA;logs:&#xA;receivers: [ filelog ]&#xA;exporters: [ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;After a few moments, you should start seeing logs from the containers in the cluster.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1261px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/tasting-menu/cloud-logs-2.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/tasting-menu/cloud-logs-2.png&#34;data-srcset=&#34;/media/blog/tasting-menu/cloud-logs-2.png?w=320 320w, /media/blog/tasting-menu/cloud-logs-2.png?w=550 550w, /media/blog/tasting-menu/cloud-logs-2.png?w=750 750w, /media/blog/tasting-menu/cloud-logs-2.png?w=900 900w, /media/blog/tasting-menu/cloud-logs-2.png?w=1040 1040w, /media/blog/tasting-menu/cloud-logs-2.png?w=1240 1240w, /media/blog/tasting-menu/cloud-logs-2.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Grafana Cloud Logs query&#34;width=&#34;1261&#34;height=&#34;680&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/tasting-menu/cloud-logs-2.png&#34;&#xA;alt=&#34;Grafana Cloud Logs query&#34;width=&#34;1261&#34;height=&#34;680&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;tasting-notes&#34;&gt;Tasting notes&lt;/h3&gt;&#xA;&lt;p&gt;Logs are umami-rich telemetry data points, exploring all possible tastes we can have: workload- or infra-related, from debug to critical, structured or unstructured. At this point, we&amp;rsquo;ve covered enough to get you longing for more. And now you&amp;rsquo;re read to ask: Which rules can you add to your configuration to enrich the metadata better?&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div&#xA;class=&#34;docs_tabs--content py-1 px-2&#34;&#xA;:class=&#34;active === &#39;Dessert&#39; ? &#39;d-block&#39; : &#39;d-none&#39;&#34;&#xA;id=&#34;&#34;&#xA;role=&#34;tabpanel&#34;&#xA;aria-labelledby=&#34;&#34;&#xA;&gt;&#xA;&lt;h2 id=&#34;kafka-buffer-with-two-collector-layers&#34;&gt;Kafka buffer with two Collector layers&lt;/h2&gt;&#xA;&lt;p&gt;For dessert, we present a sophisticated configuration involving a Kafka buffer with two layers of Collectors—appreciated in highly scalable scenarios for its ability to handle a spike in telemetry volume without stressing the backend or affecting the ingestion layer.&lt;/p&gt;&#xA;&lt;p&gt;The first layer collects telemetry from business services running in Kubernetes and publishes it to a Kafka topic. The second layer consumes these events and sends them to the telemetry storage.&lt;/p&gt;&#xA;&lt;h3 id=&#34;ingredients&#34;&gt;Ingredients&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A Kubernetes cluster, like in the previous recipe&lt;/li&gt;&#xA;&lt;li&gt;The OpenTelemetry Operator running in the cluster&lt;/li&gt;&#xA;&lt;li&gt;Your Grafana Cloud credentials in a Kubernetes secret&lt;/li&gt;&#xA;&lt;li&gt;A Kafka cluster and one topic for each telemetry data type (metric, logs, traces)&lt;/li&gt;&#xA;&lt;li&gt;The &lt;code&gt;telemetrygen&lt;/code&gt; tool, or any other application that is able to send OTLP data to our collector&lt;/li&gt;&#xA;&lt;li&gt;Two Collectors, one configured to publish data to the topic, and one consuming the events&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;configuration-examples&#34;&gt;Configuration examples&lt;/h3&gt;&#xA;&lt;h4 id=&#34;publisher&#34;&gt;Publisher&lt;/h4&gt;&#xA;&lt;p&gt;This is the configuration we’ll use for the &lt;code&gt;otelcol-pub&lt;/code&gt; Collector, responsible for publishing to the queue:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt; receivers:&#xA;otlp:&#xA;protocols:&#xA;http: {}&#xA;grpc: {}&#xA;processors:&#xA;transform:&#xA;error_mode: ignore&#xA;trace_statements:&#xA;- context: span&#xA;statements:&#xA;- set(attributes[&amp;#34;published_at&amp;#34;], UnixMilli(Now()))&#xA;exporters:&#xA;kafka:&#xA;protocol_version: 2.0.0&#xA;brokers: kafka-for-otelcol-kafka-brokers.kafka.svc.cluster.local:9092&#xA;topic: otlp-spans&#xA;service:&#xA;pipelines:&#xA;traces:&#xA;receivers: [ otlp ]&#xA;processors: [ transform ]&#xA;exporters: [ kafka ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h4 id=&#34;consumer&#34;&gt;Consumer&lt;/h4&gt;&#xA;&lt;p&gt;This is the configuration we’ll use for the &lt;code&gt;otelcol-sub&lt;/code&gt; Collector, responsible for reading from the queue and writing to our Grafana Cloud instance:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;extensions:&#xA;basicauth:&#xA;client_auth:&#xA;username: &amp;#34;${env:GRAFANA_CLOUD_USER}&amp;#34;&#xA;password: &amp;#34;${env:GRAFANA_CLOUD_TOKEN}&amp;#34;&#xA;receivers:&#xA;kafka:&#xA;protocol_version: 2.0.0&#xA;brokers: kafka-for-otelcol-kafka-brokers.kafka.svc.cluster.local:9092&#xA;topic: otlp-spans&#xA;processors:&#xA;transform:&#xA;error_mode: ignore&#xA;trace_statements:&#xA;- context: span&#xA;statements:&#xA;- set(attributes[&amp;#34;consumed_at&amp;#34;], UnixMilli(Now()))&#xA;exporters:&#xA;otlphttp:&#xA;endpoint: https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;auth:&#xA;authenticator: basicauth&#xA;service:&#xA;extensions: [ basicauth ]&#xA;pipelines:&#xA;traces:&#xA;receivers: [ kafka ]&#xA;processors: [ transform ]&#xA;exporters: [ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;preparation&#34;&gt;Preparation&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Install &lt;a href=&#34;https://strimzi.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Strimzi&lt;/a&gt;, a Kubernetes Operator for Kafka.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;kubectl create ns kafka&#xA;kubens kafka&#xA;kubectl create -f &amp;#39;https://strimzi.io/install/latest?namespace=kafka&amp;#39;&#xA;kubectl wait --for=condition=Available deployments/strimzi-cluster-operator --timeout=300s&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;Install the Kafka cluster and topics for our recipe.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;apiVersion: kafka.strimzi.io/v1beta2&#xA;kind: KafkaNodePool&#xA;metadata:&#xA;name: dual-role&#xA;labels:&#xA;strimzi.io/cluster: kafka-for-otelcol&#xA;spec:&#xA;replicas: 1&#xA;roles:&#xA;- controller&#xA;- broker&#xA;storage:&#xA;type: jbod&#xA;volumes:&#xA;- id: 0&#xA;type: persistent-claim&#xA;size: 100Gi&#xA;deleteClaim: false&#xA;kraftMetadata: shared&#xA;---&#xA;apiVersion: kafka.strimzi.io/v1beta2&#xA;kind: Kafka&#xA;metadata:&#xA;name: kafka-for-otelcol&#xA;annotations:&#xA;strimzi.io/node-pools: enabled&#xA;strimzi.io/kraft: enabled&#xA;spec:&#xA;kafka:&#xA;version: 3.7.0&#xA;metadataVersion: 3.7-IV4&#xA;config:&#xA;offsets.topic.replication.factor: 1&#xA;transaction.state.log.replication.factor: 1&#xA;transaction.state.log.min.isr: 1&#xA;default.replication.factor: 1&#xA;min.insync.replicas: 1&#xA;listeners:&#xA;- name: plain&#xA;port: 9092&#xA;type: internal&#xA;tls: false&#xA;---&#xA;apiVersion: kafka.strimzi.io/v1beta2&#xA;kind: KafkaTopic&#xA;metadata:&#xA;name: otlp-spans&#xA;labels:&#xA;strimzi.io/cluster: kafka-for-otelcol&#xA;---&#xA;apiVersion: kafka.strimzi.io/v1beta2&#xA;kind: KafkaTopic&#xA;metadata:&#xA;name: otlp-metrics&#xA;labels:&#xA;strimzi.io/cluster: kafka-for-otelcol&#xA;---&#xA;apiVersion: kafka.strimzi.io/v1beta2&#xA;kind: KafkaTopic&#xA;metadata:&#xA;name: otlp-logs&#xA;labels:&#xA;strimzi.io/cluster: kafka-for-otelcol&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;It might take a while for the topics to be ready. Watch the status of the following custom resource before proceeding: &lt;code&gt;kafka/kafka-for-otelcol&lt;/code&gt;. Once it’s marked as &lt;code&gt;Ready&lt;/code&gt;, continue with the next step.&lt;/li&gt;&#xA;&lt;li&gt;Go back to the &lt;code&gt;observability&lt;/code&gt;namespace.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;kubens observability&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;5&#34;&gt;&#xA;&lt;li&gt;Create the Collector that will receive data from the workloads and publish to the topic&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;apiVersion: opentelemetry.io/v1beta1&#xA;kind: OpenTelemetryCollector&#xA;metadata:&#xA;name: otelcol-pub&#xA;spec:&#xA;image: ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector-contrib:0.113.0&#xA;config:&#xA;receivers:&#xA;otlp:&#xA;protocols:&#xA;http: {}&#xA;grpc: {}&#xA;processors:&#xA;transform:&#xA;error_mode: ignore&#xA;trace_statements:&#xA;- context: span&#xA;statements:&#xA;- set(attributes[&amp;#34;published_at&amp;#34;], UnixMilli(Now()))&#xA;exporters:&#xA;kafka:&#xA;protocol_version: 2.0.0&#xA;brokers: kafka-for-otelcol-kafka-brokers.kafka.svc.cluster.local:9092&#xA;topic: otlp-spans&#xA;service:&#xA;pipelines:&#xA;traces:&#xA;receivers: [ otlp ]&#xA;processors: [ transform ]&#xA;exporters: [ kafka ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;6&#34;&gt;&#xA;&lt;li&gt;And now, the Collector &lt;code&gt;otelcol-sub&lt;/code&gt; receives the data from the topic and sends it to Grafana Cloud.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;apiVersion: opentelemetry.io/v1beta1&#xA;kind: OpenTelemetryCollector&#xA;metadata:&#xA;name: otelcol-sub&#xA;spec:&#xA;image: ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector-contrib:0.113.0&#xA;envFrom:&#xA;- secretRef:&#xA;name: grafana-cloud-credentials&#xA;config:&#xA;extensions:&#xA;basicauth:&#xA;client_auth:&#xA;username: &amp;#34;${env:GRAFANA_CLOUD_USER}&amp;#34;&#xA;password: &amp;#34;${env:GRAFANA_CLOUD_TOKEN}&amp;#34;&#xA;receivers:&#xA;kafka:&#xA;protocol_version: 2.0.0&#xA;brokers: kafka-for-otelcol-kafka-brokers.kafka.svc.cluster.local:9092&#xA;topic: otlp-spans&#xA;processors:&#xA;transform:&#xA;error_mode: ignore&#xA;trace_statements:&#xA;- context: span&#xA;statements:&#xA;- set(attributes[&amp;#34;consumed_at&amp;#34;], UnixMilli(Now()))&#xA;exporters:&#xA;otlphttp:&#xA;endpoint: https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;auth:&#xA;authenticator: basicauth&#xA;service:&#xA;extensions: [ basicauth ]&#xA;pipelines:&#xA;traces:&#xA;receivers: [ kafka ]&#xA;processors: [ transform ]&#xA;exporters: [ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;7&#34;&gt;&#xA;&lt;li&gt;Now, we need to send some telemetry to our “pub” Collector. If we don’t have a workload in the cluster available, we can open a port-forward to the Collector that is publishing to Kafka and send data via &lt;code&gt;telemetrygen&lt;/code&gt; to it:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;kubectl port-forward svc/otelcol-pub-collector 4317&#xA;telemetrygen traces --traces 2 --otlp-insecure --otlp-attributes=&amp;#39;recipe=&amp;#34;kafka-on-kubernetes&amp;#34;&amp;#39;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;8&#34;&gt;&#xA;&lt;li&gt;You should now see two new traces in your &lt;a href=&#34;/products/cloud/traces/pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud Traces&lt;/a&gt; view, like the following. Note that we are adding new attributes to the spans, recording the timestamp when they were placed at topic (&lt;code&gt;published_at&lt;/code&gt;) and retrieved from it (&lt;code&gt;consumed_at&lt;/code&gt;).&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1090px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/tasting-menu/cloud-traces.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/tasting-menu/cloud-traces.png&#34;data-srcset=&#34;/media/blog/tasting-menu/cloud-traces.png?w=320 320w, /media/blog/tasting-menu/cloud-traces.png?w=550 550w, /media/blog/tasting-menu/cloud-traces.png?w=750 750w, /media/blog/tasting-menu/cloud-traces.png?w=900 900w, /media/blog/tasting-menu/cloud-traces.png?w=1040 1040w, /media/blog/tasting-menu/cloud-traces.png?w=1240 1240w, /media/blog/tasting-menu/cloud-traces.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Grafana Cloud Traces UI&#34;width=&#34;1090&#34;height=&#34;856&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/tasting-menu/cloud-traces.png&#34;&#xA;alt=&#34;Grafana Cloud Traces UI&#34;width=&#34;1090&#34;height=&#34;856&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;tasting-notes&#34;&gt;Tasting notes&lt;/h3&gt;&#xA;&lt;p&gt;Our desert has a complex taste, which will be appreciated by people who have spiky workloads and need a robust ingestion layer with a backend that might not be fast enough to handle the spikes but fast enough to ingest data over time properly. This way, we don’t need to overprovision our entire pipeline, scaling up and down only the needed parts.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;I hope you&amp;rsquo;ve enjoyed this brief tour of the OpenTelemetry Collector. I hope it inspires you to keep cooking with your telemetry data!&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud &lt;/a&gt;is the easiest way to get started with metrics, logs, traces, dashboards, and more. We have a generous forever-free tier and plans for every use case. &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Sign up for free now!&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;】&lt;p&gt;我非常喜欢&lt;a href=&#34;https://en.wikipedia.org/wiki/Tasting_menu&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;品尝菜单&lt;/a&gt;。在烹饪世界中，他们让我们小份地品尝各种菜肴，帮助我们理解和欣赏不同的口味和选择。&lt;/p&gt;&#xA;&lt;p&gt;受到这个概念和&lt;a href=&#34;https://github.com/jpkrohling/talks/tree/main/2024/2024-05-24-cncf-santa-catarina/receitas&#34; target=&#34;_blank的启发“ rel=&#34;noopener noreferrer&#34;&gt;我今年早些时候发表的演讲&lt;/a&gt;，我在 Grafana 中制作了 OpenTelemetry Collector 配置的“品尝菜单” 云。这篇博文介绍了四种不同的方法，包括代码片段和包含完整示例和使用说明的 GitHub 存储库，每种方法旨在向您介绍遥测数据收集和管理的不同方面。&lt;/p&gt;&#xA;&lt;p&gt;这些食谱是我&lt;a href=&#34;https://github.com/jpkrohling/otelcol-cookbook&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;保存在 GitHub 上的食谱的一部分&lt;/a&gt;。因此，无论您是刚刚开始使用 OpenTelemetry 还是希望优化现有设置，这些配置都将帮助您欣赏 OpenTelemetry Collector 提供的一系列功能。所以，正如我们用葡萄牙语说的，bom apetite！&lt;/p&gt;&#xA;&lt;div class=&#34;br-4 base-border border-color-gray-3 docs_tabs&#34;&gt;&#xA;&lt;div x-data=&#34;app_content_tabs([&#34;开胃菜&#34;,&#34;主菜 1&#34;,&#34;主菜 2&#34;,&#34;甜点&#34;], &#39;b277ffe245eea36efce0533d1e538bbe&#39;)&#34; x-init=&#34;init()&#34;&gt;&#xA;&lt;div class=&#34;d-flex w-100p flex-direction-rowalign-items-center justify-content-flex-start d-md-none&#34;&gt;&#xA;&lt;select class=&#34;docs_tabs--select w-100p base-border-bottom border-color-gray-3&#34; @change=&#34;toggle($event.target.value)&#34;&gt;&#xA;&lt;option value=&#34;Appetizer&#34; :selected=&#34;active === &#39;Appetizer&#39;&#34;&gt;开胃菜&lt;/option&gt;&#xA;&lt;option value=&#34;主菜 1&#34; :selected=&#34;active === &#39;主菜 1&#39;&#34;&gt;主菜 1&lt;/option&gt;&#xA;&lt;option value=&#34;主菜 2&#34; :selected=&#34;active === &#39;主菜 2&#39;&#34;&gt;主菜 2&lt;/option&gt;&#xA;&lt;option value=&#34;甜点&#34; :selected=&#34;active === &#39;甜点&#39;&#34;&gt;甜点&lt;/option&gt;&#xA;&lt;/选择&gt;&#xA;&lt;/div&gt;&#xA;&lt;nav class=&#34;docs_tabs--navigation base-border-bottom border-color-gray-3 d-none d-md-block&#34; role=&#34;tablist&#34; data-codetoggle=&#34;true&#34;&gt;&#xA;&lt;按钮&#xA;类=“docs_tabs--标签f-14 bg-透明颜色-灰色-11 py-8 px-1”&#xA;数据切换=“选项卡”&#xA;角色=“选项卡”&#xA;@click=&#34;切换(&#39;开胃菜&#39;)&#34;&#xA;:class=&#34;{ &#39;docs_tabs--label-active&#39;: active === &#39;开胃菜&#39; }&#34;&#xA;&gt;&#xA;开胃菜&#xA;&lt;/按钮&gt;&#xA;&lt;按钮&#xA;类=“docs_tabs--标签f-14 bg-透明颜色-灰色-11 py-8 px-1”&#xA;数据切换=“选项卡”&#xA;角色=“选项卡”&#xA;@click=&#34;toggle(&#39;主菜1&#39;)&#34;&#xA;:class=&#34;{ &#39;docs_tabs--label-active&#39;: active === &#39;主菜1&#39; }&#34;&#xA;&gt;&#xA;主菜1&#xA;&lt;/按钮&gt;&#xA;&lt;按钮&#xA;类=“docs_tabs--标签f-14 bg-透明颜色-灰色-11 py-8 px-1”&#xA;数据切换=“选项卡”&#xA;角色=“选项卡”&#xA;@click=&#34;toggle(&#39;主菜2&#39;)&#34;&#xA;:class=&#34;{ &#39;docs_tabs--label-active&#39;: active === &#39;主菜2&#39; }&#34;&#xA;&gt;&#xA;主菜2&#xA;&lt;/按钮&gt;&#xA;&lt;按钮&#xA;类=“docs_tabs--标签f-14 bg-透明颜色-灰色-11 py-8 px-1”&#xA;数据切换=“选项卡”&#xA;角色=“选项卡”@click=&#34;切换(&#39;甜点&#39;)&#34;&#xA;:class=&#34;{ &#39;docs_tabs--label-active&#39;: active === &#39;甜点&#39; }&#34;&#xA;&gt;&#xA;甜点&#xA;&lt;/按钮&gt;&#xA;&lt;/导航&gt;&#xA;&lt;div class=&#34;docs_tabs--content-container&#34;&gt;&#xA;&lt;div&#xA;类=“docs_tabs--内容py-1 px-2”&#xA;:class=&#34;active === &#39;开胃菜&#39; ? &#39;d-block&#39; : &#39;d-none&#39;&#34;&#xA;id=&#34;&#34;&#xA;角色=“选项卡面板”&#xA;咏叹调-labelledby=&#34;&#34;&#xA;&gt;&#xA;&lt;h2 id=&#34;internal-telemetry-salad&#34;&gt;内部遥测沙拉&lt;/h2&gt;&#xA;&lt;p&gt;我们从一个简单但信息丰富的配置开始，其中涉及将收集器自己的内部遥测数据发送到外部存储。这道菜将帮助您了解如何从收集器中提取和读取内部遥测数据，包括指标和跟踪。&lt;/p&gt;&#xA;&lt;p&gt;在此配置中，我们为每种信号类型创建一个管道，并为所有信号类型使用相同的接收器和导出器。但是，我们需要使用调试导出器，因为我们对收集器的遥测不感兴趣；我们对收集器生成的遥测数据感兴趣。&lt;/p&gt;&#xA;&lt;p&gt;在 &lt;code&gt;service::telemetry&lt;/code&gt; 下，我们配置如何将内部跟踪和指标发送到外部 OpenTelemetry 协议 (OTLP) 端点。在本例中，我们使用从“OpenTelemetry Configuration”页面获取的 &lt;a href=&#34;/products/cloud/pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt; 实例的 OTLP 端点，该端点可以可以在“管理您的堆栈”页面上找到。&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1236px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/tasting-menu/manage-your-stack.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/tasting-menu/manage-your-stack.png”data-srcset =“/media/blog/tasting-menu/manage-your-stack.png？w = 320 320w，/媒体/博客/品尝菜单/manage-your-stack.png？w=550 550w， /media/blog/tasting-menu/manage-your-stack.png?w=750 750w, /media/blog/tasting-menu/manage-your-stack.png?w=900 900w, /media/blog/tasting -menu/manage-your-stack.png?w=1040 1040w, /media/blog/tasting-menu/manage-your-stack.png?w=1240 1240w, /media/blog/tasting-menu/manage-your-stack.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;在 Grafana Cloud UI 中管理您的堆栈页面&#34;width=&#34;1236&#34;height=&#34;809&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/tasting-menu/manage-your-stack.png”&#xA;alt=&#34;在 Grafana Cloud UI 中管理您的堆栈页面&#34;width=&#34;1236&#34;height=&#34;809&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;此外，在该页面上，我们可以查看生成令牌后显示的环境变量&lt;code&gt;OTEL_EXPORTER_OTLP_HEADERS&lt;/code&gt;。请将此信息放在手边，因为稍后我们将需要 Authorization 标头的值。&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1529px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/tasting-menu/environment-variables.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div 类=“img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/tasting-menu/environment-variables.png”data-srcset =“/media/blog/tasting-menu/environment-variables.png？w = 320 320w，/media/blog/品尝菜单/环境变量.png?w=550 550w, /media/blog/tasting-menu/environment-variables.png?w=750 750w, /media/blog/tasting-menu/environment-variables.png?w=900 900w, /media/blog/tasting-menu/environment -变量.png?w=1040 1040w, /media/blog/tasting-menu/environment-variables.png?w=1240 1240w，/media/blog/tasting-menu/environment-variables.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;环境变量代码截图&#34;width=&#34;1529&#34;height=&#34;478&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/tasting-menu/environment-variables.png”&#xA;alt=&#34;环境变量代码截图&#34;width=&#34;1529&#34;height=&#34;478&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;ingredients&#34;&gt;成分&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OpenTelemetry Collector 发行版，能够通过 gRPC 提取 OTLP 数据，并使用调试导出器导出数据。我使用了&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-releases/releases/tag/v0.113.0&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;OTel Collector Contrib v0。 113.0&lt;/a&gt; 对于此博文。&lt;/li&gt;&#xA;&lt;li&gt;可以生成 OTLP 数据的应用程序，例如 &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/cmd/telemetrygen&#34; target=&#34;_blank&#34; rel =&#34;noopener noreferrer&#34;&gt;telemetrygen&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;正确配置了 &lt;code&gt;service::telemetry&lt;/code&gt; 部分的配置文件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;configuration-example&#34;&gt;配置示例&lt;/h3&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;接收者：&#xA;奥特普：&#xA;协议：&#xA;http：&#xA;组组：&#xA;出口商：&#xA;调试：&#xA;服务：&#xA;管道：&#xA;痕迹：&#xA;接收者：[otlp]&#xA;出口商：[调试]&#xA;指标：&#xA;接收者：[otlp]&#xA;出口商：[调试]&#xA;日志：&#xA;接收者：[otlp]&#xA;出口商：[调试]&#xA;遥测：&#xA;痕迹：&#xA;处理器：&#xA;- 批：&#xA;计划延迟：1000&#xA;出口商：&#xA;奥特普：&#xA;端点：https://otlp-gateway-prod-eu-west-2.grafana.net/otlp/v1/traces&#xA;协议：http/protobuf&#xA;标题：&#xA;授权：“基本……”&#xA;指标：&#xA;级别： 详细&#xA;读者：&#xA;- 定期：&#xA;出口商：&#xA;奥特普：&#xA;端点：https://otlp-gateway-prod-eu-west-2.grafana.net/otlp/v1/metrics&#xA;协议：http/protobuf&#xA;标题：&#xA;授权：“基本……”&#xA;资源：&#xA;“service.name”：“otelcol-own-telemetry”&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;preparation&#34;&gt;准备&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;更改配置文件以包含 &lt;code&gt;Basic&lt;/code&gt; 身份验证标头和端点的正确值&lt;/li&gt;&#xA;&lt;li&gt;运行 OpenTelemetry Collector：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;otelcol-contrib --config ./otelcol.yaml&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“3”&gt;&#xA;&lt;li&gt;向收集器发送一些遥测数据。默认情况下，telemetrygen 报告的每个跟踪都带有两个跨度。请注意，此遥测数据将随所提供的配置一起被丢弃，但收集器执行的操作将被记录：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;telemetrygen 跟踪 --traces 1 --otlp-insecure --otlp-attributes=&#39;cookbook=&#34;own-telemetry&#34;&#39;&lt;/code&gt; &lt;/前&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“4”&gt;&#xA;&lt;li&gt;在 Grafana Cloud 上，选择跟踪数据源，您将能够找到表示 &lt;code&gt;telemetrygen&lt;/code&gt; 调用的 Collector 处理的跟踪：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1277px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/tasting-menu/traces-data.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/tasting-menu/traces-data.png”data-srcset =“/media/blog/tasting-menu/traces-data.png？w = 320 320w，/media/blog/品尝菜单/traces-data.png?w=550 550w，/media/blog/tasting-menu/traces-data.png?w=750 750w，/media/blog/tasting-menu/traces-data.png？w=900 900w，/media/blog/tasting-menu/traces-data.png？w=1040 1040w，/media/blog/tasting-menu /traces-data.png?w=1240 1240w, /media/blog/tasting-menu/traces-data.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Grafana Cloud 中 TraceQL 查询的屏幕截图&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/tasting-menu/traces-data.png”&#xA;alt=&#34;Grafana Cloud 中 TraceQL 查询的屏幕截图&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;ol开始=“5”&gt;&#xA;&lt;li&gt;现在，更改为指标数据源，然后选择指标 &lt;code&gt;otelcol_exporter_sent_spans_total&lt;/code&gt;。我们可以看到我们的收集器报告它收到了两个跨度。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1277px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;项目ype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/tasting-menu/two-spans.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/tasting-menu/two-spans.png”data-srcset =“/media/blog/tasting-menu/two-spans.png？w = 320 320w，/media/blog/品尝菜单/two-spans.png?w=550 550w, /media/blog/tasting-menu/two-spans.png?w=750 750w, /media/blog/tasting-menu/two-spans.png?w=900 900w, /media/blog/tasting-menu/two -spans.png?w=1040 1040w, /media/blog/tasting-menu/two-spans.png?w=1240 1240w, /media/blog/tasting-menu/two-spans.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Grafana Cloud 中查询 UI 的屏幕截图&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/tasting-menu/two-spans.png”&#xA;alt=&#34;Grafana Cloud 中查询 UI 的屏幕截图&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;tasting-notes&#34;&gt;品酒笔记&lt;/h3&gt;&#xA;&lt;p&gt;我们现在已经看到，我们可以观察收集器以了解它在做什么 - 我们可以轻松访问其指标和跟踪。但是日志呢？&lt;/p&gt;&#xA;&lt;p&gt;目前，日志仅在控制台上可用，并且应单独捕获。避免使用文件日志接收器读取实例自己的日志的诱惑。这可能会导致事件无限循环，违反软件不应自我监控的原则。&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div&#xA;类=“docs_tabs--内容py-1 px-2”&#xA;:class=&#34;active === &#39;主菜 1&#39; ? &#39;d-block&#39; : &#39;d-none&#39;&#34;&#xA;id=&#34;&#34;&#xA;角色=“选项卡面板”&#xA;咏叹调-labelledby=&#34;&#34;&#xA;&gt;&#xA;&lt;h2 id=&#34;mixed-events-and-metrics&#34;&gt;混合事件和指标&lt;/h2&gt;&#xA;&lt;p&gt;我们的第一门主菜是来自 Kubernetes 集群的事件和指标的料理鼠王。 Collector 由 OpenTelemetry Operator 进行配置，以“部署”模式在 Kubernetes 集群中运行，并遵守 &lt;a href=&#34;https://opentelemetry.io/docs/specs/otel/metrics/data-model/# single-writer&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;单编写器原则&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;ingredients&#34;&gt;成分&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个 Kubernetes 集群，例如通过 k3d 在本地配置的集群&lt;/li&gt;&#xA;&lt;li&gt;在集群中运行的 OpenTelemetry Operator&lt;/li&gt;&#xA;&lt;li&gt;Kubernetes 密钥中的 Grafana Cloud 凭据&lt;/li&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;k8s_cluster&lt;/code&gt; 和 &lt;code&gt;k8s_events&lt;/code&gt; 接收器的收集器配置&lt;/li&gt;&#xA;&lt;li&gt;会生成一些 Kubernetes 事件的工作负载&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;kubens&lt;/code&gt; 来自 &lt;a href=&#34;https://github.com/ahmetb/kubectx&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;kubectx&lt;/code&gt; &lt;/a&gt; 项目&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;configuration-example&#34;&gt;配置示例&lt;/h3&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div 类=“代码”-片段代码-片段__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt; 扩展：&#xA;基本验证：&#xA;客户端验证：&#xA;用户名：“${env:GRAFANA_CLOUD_USER}”&#xA;密码：“${env:GRAFANA_CLOUD_TOKEN}”&#xA;接收者：&#xA;k8s_事件：{}&#xA;k8s_集群：&#xA;采集间隔：15s&#xA;出口商：&#xA;otlphttp:&#xA;端点：https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;授权：&#xA;验证器：basicauth&#xA;服务：&#xA;扩展： [ basicauth ]&#xA;管道：&#xA;指标：&#xA;接收者：[ k8s_cluster ]&#xA;出口商：[ otlphttp ]&#xA;日志：&#xA;接收者：[ k8s_events ]&#xA;导出器：[ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;preparation&#34;&gt;准备&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;确保您已配置正在运行的 Kubernetes 集群和 OpenTelemetry Operator，并将上下文设置为 &lt;code&gt;observability&lt;/code&gt; 命名空间。如果您不知道如何开始，可以尝试以下命令进行本地设置：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;k3d 集群创建&#xA;kubectl apply -f https://github.com/cert-manager/cert-manager/releases/latest/download/cert-manager.yaml&#xA;kubectl wait --for=condition=可用部署/cert-manager -n cert-manager&#xA;kubectl apply -f https://github.com/open-telemetry/opentelemetry-operator/releases/latest/download/opentelemetry-operator.yaml&#xA;kubectl wait --for=条件=可用部署/opentelemetry-operator-controller-manager -n opentelemetry-operator-system&#xA;kubectl 创建命名空间可观察性&#xA;kubens 可观测性&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“2”&gt;&#xA;&lt;li&gt;使用您的 Grafana Cloud 凭据创建一个密钥。在这个例子中，我们已经将它们设置为环境变量；适当更换它们。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;kubectl 创建秘密通用 grafana-cloud-credentials \&#xA;--from-literal=GRAFANA_CLOUD_USER=&#34;$GRAFANA_CLOUD_USER&#34; \&#xA;--from-literal=GRAFANA_CLOUD_TOKEN=&#34;$GRAFANA_CLOUD_TOKEN&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“3”&gt;&#xA;&lt;li&gt;我们现在将为我们的收集器创建一个 &lt;code&gt;ClusterRole&lt;/code&gt;：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;api版本：rbac.authorization.k8s.io/v1&#xA;种类：集群角色&#xA;元数据：&#xA;姓名：奥特尔科尔&#xA;规则：&#xA;- api 组：&#xA;-“”&#xA;资源：&#xA;- 活动&#xA;- 命名空间&#xA;- 命名空间/状态&#xA;- 节点&#xA;- 节点/规格&#xA;- 豆荚&#xA;- 吊舱/状态&#xA;- 复制控制器&#xA;- 复制控制器/状态&#xA;- 资源配额&#xA;- 服务&#xA;动词：&#xA;- 得到&#xA;- 列表&#xA;- 手表&#xA;- api 组：&#xA;- 应用程序&#xA;资源：&#xA;- 守护进程集&#xA;- 部署&#xA;- 副本集&#xA;- 有状态集&#xA;动词：&#xA;- 得到&#xA;- 列表&#xA;- 手表&#xA;- api 组：&#xA;- 扩展&#xA;资源：&#xA;- 守护进程集&#xA;- 部署&#xA;- 副本集&#xA;动词：&#xA;- 得到&#xA;- 列表&#xA;- 手表&#xA;- api 组：&#xA;- 批&#xA;资源：&#xA;- 职位&#xA;- 定时任务&#xA;动词：&#xA;- 得到&#xA;- 列表&#xA;- 手表&#xA;- api 组：&#xA;- 自动缩放&#xA;资源：&#xA;- 水平pod自动缩放器&#xA;动词：&#xA;- 得到&#xA;- 列表&#xA;- 观看&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“4”&gt;&#xA;&lt;li&gt;我们将创建一个将由 Collector 实例使用的 &lt;code&gt;ServiceAccount&lt;/code&gt;，并将集群角色绑定到该帐户：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;api版本：v1&#xA;种类：服务帐户&#xA;元数据：&#xA;名称：otelcol-k8s&#xA;命名空间：可观察性&#xA;---&#xA;api版本：rbac.authorization.k8s.io/v1&#xA;种类：ClusterRoleBinding&#xA;元数据：&#xA;姓名：奥特尔科尔&#xA;角色参考：&#xA;apiGroup：rbac.authorization.k8s.io&#xA;种类：集群角色&#xA;姓名：奥特尔科尔&#xA;科目：&#xA;- 种类：服务帐户&#xA;名称：otelcol-k8s&#xA;命名空间：可观察性&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“5”&gt;&#xA;&lt;li&gt;我们现在将配置收集器以从 Kubernetes 集群获取指标和事件（作为日志）。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;api版本：opentelemetry.io/v1beta1&#xA;种类：OpenTelemetryCollector&#xA;元数据：&#xA;名称：otelcol-k8s&#xA;命名空间：可观察性&#xA;规格：&#xA;图片：ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector-contrib:0.113.0&#xA;服务帐号：otelcol-k8s&#xA;环境来自：&#xA;- 秘密参考：&#xA;名称：grafana-cloud-credentials&#xA;配置：&#xA;扩展名：&#xA;基本验证：&#xA;客户端验证：&#xA;用户名：“${env:GRAFANA_CLOUD_USER}&amp;#34;&#xA;密码：“${env:GRAFANA_CLOUD_TOKEN}”&#xA;接收者：&#xA;k8s_事件：{}&#xA;k8s_集群：&#xA;采集间隔：15s&#xA;出口商：&#xA;otlphttp:&#xA;端点：https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;授权：&#xA;验证器：basicauth&#xA;服务：&#xA;扩展： [ basicauth ]&#xA;管道：&#xA;指标：&#xA;接收者：[ k8s_cluster ]&#xA;出口商：[ otlphttp ]&#xA;日志：&#xA;接收者：[ k8s_events ]&#xA;导出器：[ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;如果您的 Kubernetes 集群中没有运行工作负载，则此工作负载应该足以生成一些事件。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;api版本：apps/v1&#xA;种类：部署&#xA;元数据：&#xA;名称：nginx-部署&#xA;规格：&#xA;选择器：&#xA;匹配标签：&#xA;应用程序：nginx&#xA;模板：&#xA;元数据：&#xA;标签：&#xA;应用程序：nginx&#xA;规格：&#xA;容器：&#xA;-名称：nginx&#xA;图片：nginx:1.27.2&#xA;端口：&#xA;- 容器端口：80&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“6”&gt;&#xA;&lt;li&gt;此时，您的 Grafana Cloud 实例中应该已收到一些事件。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1277px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/tasting-menu/cloud-logs.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/tasting-menu/cloud-logs.png”data-srcset =“/media/blog/tasting-menu/cloud-logs.png？w = 320 320w，/media/blog/品尝菜单/cloud-logs.png?w=550 550w，/media/blog/tasting-menu/cloud-logs.png?w=750 750w、/media/blog/tasting-menu/cloud-logs.png?w=900 900w、/media/blog/tasting-menu/cloud-logs.png?w=1040 1040w、/media/blog/tasting-menu /cloud-logs.png?w=1240 1240w, /media/blog/tasting-menu/cloud-logs.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Grafana Cloud 中填充的事件&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/media/blog/tasting-menu/cloud-logs.png&#34;&#xA;alt=&#34;Grafana Cloud 中填充的事件&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Kubernetes 指标（例如 &lt;code&gt;k8s_container_ready&lt;/code&gt;）也应该可用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1277px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/tasting-menu/k8s-metrics.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/tasting-menu/k8s-metrics.png”data-srcset =“/media/blog/tasting-menu/k8s-metrics.png？w = 320 320w，/media/blog/品尝菜单/k8s-metrics.png?w=550 550w, /media/blog/tasting-menu/k8s-metrics.png?w=750 750w, /media/blog/tasting-menu/k8s-metrics.png?w=900 900w, /media/blog/tasting-menu/k8s-指标.png?w=1040 1040w, /media/blog/tasting-menu/k8s-metrics.png?w=1240 1240w，/media/blog/tasting-menu/k8s-metrics.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;在 Grafana UI 中填充图表的指标&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/tasting-menu/k8s-metrics.png”&#xA;alt=&#34;在 Grafana UI 中填充图表的指标&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;tasting-notes&#34;&gt;品酒笔记&lt;/h3&gt;&#xA;&lt;p&gt;我们只是初步了解了这些组件的功能，这为我们提供了足够的信息来进一步探索这个想法：哪些指标可能值得我们关注？我们如何结合指标来讲述一个故事？这就是我们可以从这里出发的地方。&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div&#xA;类=“docs_tabs--内容py-1 px-2”&#xA;:class=&#34;active === &#39;主菜 2&#39; ? &#39;d-block&#39; : &#39;d-none&#39;&#34;&#xA;id=&#34;&#34;&#xA;角色=“选项卡面板”&#xA;咏叹调-labelledby=&#34;&#34;&#xA;&gt;&#xA;&lt;h2 id=&#34;bibimbap-of-logs&#34;&gt;原木拌饭&lt;/h2&gt;&#xA;&lt;p&gt;第二个主要课程探讨了在“daemonset”模式下配置的收集器，以从同一节点上运行的 Pod 收集各种日志，可能遵循不同的格式并来自不同的命名空间。此配置强调将收集器放置在靠近遥测源的位置。&lt;/p&gt;&#xA;&lt;h3 id=&#34;ingredients&#34;&gt;成分&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个 Kubernetes 集群，如上一章节所示&lt;/li&gt;&#xA;&lt;li&gt;在集群中运行的 OpenTelemetry Operator&lt;/li&gt;&#xA;&lt;li&gt;Kubernetes 密钥中的 Grafana Cloud 凭据&lt;/li&gt;&#xA;&lt;li&gt;使用&lt;code&gt;filelog&lt;/code&gt;接收器的收集器配置&lt;/li&gt;&#xA;&lt;li&gt;会生成一些 Kubernetes 事件的工作负载&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;configuration-example&#34;&gt;配置示例&lt;/h3&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt; 扩展：&#xA;基本验证：&#xA;客户端验证：&#xA;用户名：“${env:GRAFANA_CLOUD_USER}”&#xA;密码：“${env:GRAFANA_CLOUD_TOKEN}”&#xA;接收者：&#xA;文件日志：&#xA;排除： []&#xA;包括：&#xA;- /var/log/pods/*/*/*.log&#xA;包含文件名： false&#xA;include_file_path: true&#xA;运营商：&#xA;- id：容器解析器&#xA;最大日志大小：102400&#xA;类型：集装箱&#xA;失败时重试：&#xA;启用：真&#xA;开始于：结束&#xA;出口商：&#xA;otlphttp:&#xA;端点：https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;授权：&#xA;验证器：basicauth&#xA;服务：&#xA;扩展： [ basicauth ]&#xA;管道：&#xA;日志：&#xA;接收者：[ 文件日志 ]&#xA;导出器：[ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;preparation&#34;&gt;准备&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;确保您有 Kubernetes 集群和 OTel Operator 正在运行。请随意重复使用您配置的那个上一个食谱中的红色。&lt;/li&gt;&#xA;&lt;li&gt;接下来，使用以下配置创建自定义资源。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;api版本：opentelemetry.io/v1beta1&#xA;种类：OpenTelemetryCollector&#xA;元数据：&#xA;名称： otelcol-podslogs&#xA;命名空间：可观察性&#xA;规格：&#xA;图片：ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector-contrib:0.113.0&#xA;模式：守护进程集&#xA;环境来自：&#xA;- 秘密参考：&#xA;名称：grafana-cloud-credentials&#xA;卷：&#xA;- 名称：varlogpods&#xA;主机路径：&#xA;路径：/var/log/pods&#xA;体积安装：&#xA;- 名称：varlogpods&#xA;挂载路径：/var/log/pods&#xA;只读：真&#xA;配置：&#xA;扩展名：&#xA;基本验证：&#xA;客户端验证：&#xA;用户名：“${env:GRAFANA_CLOUD_USER}”&#xA;密码：“${env:GRAFANA_CLOUD_TOKEN}”&#xA;接收者：&#xA;文件日志：&#xA;排除： []&#xA;包括：&#xA;- /var/log/pods/*/*/*.log&#xA;包含文件名： false&#xA;include_file_path: true&#xA;运营商：&#xA;- id：容器解析器&#xA;最大日志大小：102400&#xA;类型：集装箱&#xA;失败时重试：&#xA;启用：真&#xA;开始于：结束&#xA;出口商：&#xA;otlphttp:&#xA;端点：https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;授权：&#xA;验证器：basicauth&#xA;服务：&#xA;扩展： [ basicauth ]&#xA;管道：&#xA;日志：&#xA;接收者：[ 文件日志 ]&#xA;导出器：[ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“3”&gt;&#xA;&lt;li&gt;片刻之后，您应该开始看到集群中容器的日志。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1261px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/tasting-menu/cloud-logs-2.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/tasting-menu/cloud-logs-2.png&#34;data-srcset=&#34;/media/blog/tasting-menu/cloud-logs-2.png?w=320 320w,/媒体/博客/品尝菜单/cloud-logs-2.png?w=550 550w, /media/blog/tasting-menu/cloud-logs-2.png?w=750 750w, /media/blog/tasting-menu/cloud-logs-2.png?w=900 900w, /media/blog/tasting -menu/cloud-logs-2.png?w=1040 1040w, /media/blog/tasting-menu/cloud-logs-2.png?w=1240 1240w，/media/blog/tasting-menu/cloud-logs-2.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Grafana 云日志查询&#34;width=&#34;1261&#34;height=&#34;680&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/media/blog/tasting-menu/cloud-logs-2.png&#34;&#xA;alt=&#34;Grafana 云日志查询&#34;width=&#34;1261&#34;height=&#34;680&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;tasting-notes&#34;&gt;品酒笔记&lt;/h3&gt;&#xA;&lt;p&gt;日志是富含鲜味的遥测数据点，探索我们可以拥有的所有可能的品味：工作负载或基础设施相关，从调试到关键，结构化或非结构化。至此，我们已经介绍了足够的内容来帮助您渴望更多。现在您会问：您可以在配置中添加哪些规则以更好地丰富元数据？&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div&#xA;类=“docs_tabs--内容py-1 px-2”&#xA;:class=&#34;active === &#39;甜点&#39; ? &#39;d-block&#39; : &#39;d-none&#39;&#34;&#xA;id=&#34;&#34;&#xA;角色=“选项卡面板”&#xA;咏叹调-labelledby=&#34;&#34;&#xA;&gt;&#xA;&lt;h2 id=&#34;kafka-buffer-with-two-collector-layers&#34;&gt;具有两个收集器层的 Kafka 缓冲区&lt;/h2&gt;&#xA;&lt;p&gt;对于甜点，我们提供了一种复杂的配置，涉及带有两层收集器的 Kafka 缓冲区 - 在高度可扩展的场景中因其能够处理遥测数据量的峰值而不受后端压力或影响摄取层的能力而受到赞赏。&lt;/p&gt;&#xA;&lt;p&gt;第一层从 Kubernetes 中运行的业务服务收集遥测数据并将其发布到 Kafka 主题。第二层使用这些事件并将它们发送到遥测存储。&lt;/p&gt;&#xA;&lt;h3 id=&#34;ingredients&#34;&gt;成分&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个 Kubernetes 集群，如上一章节所示&lt;/li&gt;&#xA;&lt;li&gt;在集群中运行的 OpenTelemetry Operator&lt;/li&gt;&#xA;&lt;li&gt;Kubernetes 密钥中的 Grafana Cloud 凭据&lt;/li&gt;&#xA;&lt;li&gt;一个 Kafka 集群以及每种遥测数据类型（指标、日志、跟踪）的一个主题&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;telemetrygen&lt;/code&gt; 工具或任何其他能够将 OTLP 数据发送到我们的收集器的应用程序&lt;/li&gt;&#xA;&lt;li&gt;两个收集器，一个配置为向主题发布数据，另一个使用事件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;configuration-examples&#34;&gt;配置示例&lt;/h3&gt;&#xA;&lt;h4 id=&#34;publisher&#34;&gt;发布者&lt;/h4&gt;&#xA;&lt;p&gt;这是我们将用于 &lt;code&gt;otelcol-pub&lt;/code&gt; 收集器的配置，负责发布到队列：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt; 接收者：&#xA;奥特普：&#xA;协议：&#xA;http：{}&#xA;组：{}&#xA;处理器：&#xA;转换：&#xA;错误模式：忽略&#xA;跟踪语句：&#xA;- 上下文：跨度&#xA;声明：&#xA;- 设置（属性[“published_at”]，UnixMilli（Now（）））&#xA;出口商：&#xA;卡夫卡：&#xA;协议版本：2.0.0&#xA;经纪人：kafka-for-otelcol-kafka-brokers.kafka.svc.cluster.local:9092&#xA;主题： otlp-spans&#xA;服务：&#xA;管道：&#xA;痕迹：&#xA;接收者：[ otlp ]&#xA;处理器：[变换]&#xA;出口商：[ kafka ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h4 id=&#34;consumer&#34;&gt;消费者&lt;/h4&gt;&#xA;&lt;p&gt;这是我们将用于 &lt;code&gt;otelcol-sub&lt;/code&gt; 收集器的配置，负责从队列中读取数据并将其写入 Grafana Cloud 实例：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;复制代码到clipb板”宽度=“14”高度=“13”&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;扩展名：&#xA;基本验证：&#xA;客户端验证：&#xA;用户名：“${env:GRAFANA_CLOUD_USER}”&#xA;密码：“${env:GRAFANA_CLOUD_TOKEN}”&#xA;接收者：&#xA;卡夫卡：&#xA;协议版本：2.0.0&#xA;经纪人：kafka-for-otelcol-kafka-brokers.kafka.svc.cluster.local:9092&#xA;主题： otlp-spans&#xA;处理器：&#xA;转换：&#xA;错误模式：忽略&#xA;跟踪语句：&#xA;- 上下文：跨度&#xA;声明：&#xA;- 设置（属性[“consumed_at”]，UnixMilli（Now（）））&#xA;出口商：&#xA;otlphttp:&#xA;端点：https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;授权：&#xA;验证器：basicauth&#xA;服务：&#xA;扩展： [ basicauth ]&#xA;管道：&#xA;痕迹：&#xA;接收者：[卡夫卡]&#xA;处理器：[变换]&#xA;导出器：[ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;preparation&#34;&gt;准备&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;安装 &lt;a href=&#34;https://strimzi.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Strimzi&lt;/a&gt;，一个 Kafka 的 Kubernetes Operator。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;kubectl 创建 ns kafka&#xA;卡夫卡库本斯&#xA;kubectl create -f &#39;https://strimzi.io/install/latest?namespace=kafka&#39;&#xA;kubectl wait --for=condition=可用部署/strimzi-cluster-operator --timeout=300s&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“2”&gt;&#xA;&lt;li&gt;为我们的配方安装 Kafka 集群和主题。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;api版本：kafka.strimzi.io/v1beta2&#xA;种类：KafkaNodePool&#xA;元数据：&#xA;名称：双角色&#xA;标签：&#xA;strimzi.io/集群：kafka-for-otelcol&#xA;规格：&#xA;副本：1&#xA;角色：&#xA;- 控制器&#xA;- 经纪人&#xA;贮存：&#xA;类型：jbod&#xA;卷：&#xA;- 编号：0&#xA;类型：持久声明&#xA;大小：100Gi&#xA;删除声明： false&#xA;kraft元数据：共享&#xA;---&#xA;api版本：kafka.strimzi.io/v1beta2&#xA;种类：卡夫卡&#xA;元数据：&#xA;名称：kafka-for-otelcol&#xA;注释：&#xA;strimzi.io/node-pools：已启用&#xA;strimzi.io/kraft：已启用&#xA;规格：&#xA;卡夫卡：&#xA;版本：3.7.0&#xA;元数据版本：3.7-IV4&#xA;配置：&#xA;偏移量.主题.复制.因子：1&#xA;事务.状态.日志.复制.因子：1&#xA;交易.状态.log.min.isr: 1&#xA;默认复制因子：1&#xA;最小同步副本数：1&#xA;听众：&#xA;- 名称：普通&#xA;端口：9092&#xA;类型：内部&#xA;tls: 假&#xA;---&#xA;一个pi版本：kafka.strimzi.io/v1beta2&#xA;种类：Kafka主题&#xA;元数据：&#xA;名称： otlp-spans&#xA;标签：&#xA;strimzi.io/集群：kafka-for-otelcol&#xA;---&#xA;api版本：kafka.strimzi.io/v1beta2&#xA;种类：Kafka主题&#xA;元数据：&#xA;名称：otlp-指标&#xA;标签：&#xA;strimzi.io/集群：kafka-for-otelcol&#xA;---&#xA;api版本：kafka.strimzi.io/v1beta2&#xA;种类：Kafka主题&#xA;元数据：&#xA;名称：otlp-日志&#xA;标签：&#xA;strimzi.io/cluster：kafka-for-otelcol&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“3”&gt;&#xA;&lt;li&gt;主题可能需要一段时间才能准备好。在继续操作之前，请查看以下自定义资源的状态：&lt;code&gt;kafka/kafka-for-otelcol&lt;/code&gt;。一旦标记为&lt;code&gt;就绪&lt;/code&gt;，请继续下一步。&lt;/li&gt;&#xA;&lt;li&gt;返回到&lt;code&gt;可观察性&lt;/code&gt;命名空间。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;kubens 可观测性&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“5”&gt;&#xA;&lt;li&gt;创建将从工作负载接收数据并发布到主题的收集器&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;api版本：opentelemetry.io/v1beta1&#xA;种类：OpenTelemetryCollector&#xA;元数据：&#xA;名称: otelcol-pub&#xA;规格：&#xA;图片：ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector-contrib:0.113.0&#xA;配置：&#xA;接收者：&#xA;奥特普：&#xA;协议：&#xA;http：{}&#xA;组：{}&#xA;处理器：&#xA;转换：&#xA;错误模式：忽略&#xA;跟踪语句：&#xA;- 上下文：跨度&#xA;声明：&#xA;- 设置（属性[“published_at”]，UnixMilli（Now（）））&#xA;出口商：&#xA;卡夫卡：&#xA;协议版本：2.0.0&#xA;经纪人：kafka-for-otelcol-kafka-brokers.kafka.svc.cluster.local:9092&#xA;主题： otlp-spans&#xA;服务：&#xA;管道：&#xA;痕迹：&#xA;接收者：[ otlp ]&#xA;处理器：[变换]&#xA;出口商：[ kafka ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“6”&gt;&#xA;&lt;li&gt;现在，收集器 &lt;code&gt;otelcol-sub&lt;/code&gt; 接收来自主题的数据并将其发送到 Grafana Cloud。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet 代码-snipp等__边框&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;api版本：opentelemetry.io/v1beta1&#xA;种类：OpenTelemetryCollector&#xA;元数据：&#xA;名称: otelcol-sub&#xA;规格：&#xA;图片：ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector-contrib:0.113.0&#xA;环境来自：&#xA;- 秘密参考：&#xA;名称：grafana-cloud-credentials&#xA;配置：&#xA;扩展名：&#xA;基本验证：&#xA;客户端验证：&#xA;用户名：“${env:GRAFANA_CLOUD_USER}”&#xA;密码：“${env:GRAFANA_CLOUD_TOKEN}”&#xA;接收者：&#xA;卡夫卡：&#xA;协议版本：2.0.0&#xA;经纪人：kafka-for-otelcol-kafka-brokers.kafka.svc.cluster.local:9092&#xA;主题： otlp-spans&#xA;处理器：&#xA;转换：&#xA;错误模式：忽略&#xA;跟踪语句：&#xA;- 上下文：跨度&#xA;声明：&#xA;- 设置（属性[“consumed_at”]，UnixMilli（Now（）））&#xA;出口商：&#xA;otlphttp:&#xA;端点：https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;授权：&#xA;验证器：basicauth&#xA;服务：&#xA;扩展： [ basicauth ]&#xA;管道：&#xA;痕迹：&#xA;接收者：[卡夫卡]&#xA;处理器：[变换]&#xA;导出器：[ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“7”&gt;&#xA;&lt;li&gt;现在，我们需要向我们的“pub”收集器发送一些遥测数据。如果集群中没有可用的工作负载，我们可以打开一个端口转发到正在发布到 Kafka 的收集器，并通过 &lt;code&gt;telemetrygen&lt;/code&gt; 向其发送数据：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;kubectl 端口转发 svc/otelcol-pub-collector 4317&#xA;telemetrygen 跟踪 --traces 2 --otlp-insecure --otlp-attributes=&#39;recipe=&#34;kafka-on-kubernetes&#34;&#39;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“8”&gt;&#xA;&lt;li&gt;您现在应该在 &lt;a href=&#34;/products/cloud/traces/pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud Traces&lt;/a&gt; 视图中看到两条新跟踪，如下所示。请注意，我们正在向跨度添加新属性，记录它们被放置在主题 (&lt;code&gt;published_at&lt;/code&gt;) 和从中检索 (&lt;code&gt;consumed_at&lt;/code&gt;) 时的时间戳。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1090px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/tasting-menu/cloud-traces.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/tasting-menu/cloud-traces.png”data-srcset =“/media/blog/tasting-menu/cloud-traces.png？w = 320 320w，/media/blog/品尝菜单/cloud-traces.png?w=550 550w，/media/blog/tasting-menu/cloud-traces.png?w=750 750w、/media/blog/tasting-menu/cloud-traces.png?w=900 900w、/media/blog/tasting-menu/cloud-traces.png?w=1040 1040w、/media/blog/tasting-menu /云迹.png?w=1240 1240w，/media/blog/tasting-menu/cloud-traces.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Grafana 云跟踪 UI&#34;width=&#34;1090&#34;height=&#34;856&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/media/blog/tasting-menu/cloud-traces.png&#34;&#xA;alt=&#34;Grafana 云跟踪 UI&#34;width=&#34;1090&#34;height=&#34;856&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;tasting-notes&#34;&gt;品酒笔记&lt;/h3&gt;&#xA;&lt;p&gt;我们的沙漠有一种复杂的味道，那些工作负载尖峰、需要强大的摄取层和后端的人会喜欢这种味道，该后端可能不够快来处理尖峰，但足够快以随着时间的推移正确摄取数据。这样，我们就不需要过度配置整个管道，只扩展和缩减所需的部分。&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;我希望您喜欢这个 OpenTelemetry Collector 的简短介绍。我希望它能激励您继续利用遥测数据做饭！&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt;是开始使用指标、日志、跟踪、仪表板等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。 &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;plcmt=body-txt&#34;&gt;立即免费注册！&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</description>
      <pubDate>Wed, 27 Nov 2024 00:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>