<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Grafana Labs blog on Grafana Labs</title>
    <link>/blog/index.xml</link>
    <description>Recent content in Grafana Labs blog on Grafana Labs</description>
    <item>
      <title>【Connect with Grafana Labs at AWS re:Invent 2024!】在 AWS re:Invent 2024 上与 Grafana Labs 联系！</title>
      <link>https://grafana.com/blog/2024/11/20/connect-with-grafana-labs-at-aws-reinvent-2024/</link>
      <description>【&lt;p&gt;&lt;a href=&#34;https://reinvent.awsevents.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;AWS re:Invent 2024&lt;/a&gt; will once again take over the Las Vegas Strip next month, and we can&amp;rsquo;t wait to see you there!&lt;/p&gt;&#xA;&lt;p&gt;Running from Dec. 2-6, re:Invent features five days of technical talks, labs, bootcamps, keynotes, and more. And once again, Grafana Labs will be in on the action.&lt;/p&gt;&#xA;&lt;div class=&#34;btn-row &#34;&gt;&lt;a class=&#34;btn btn--primary &#34; href=&#34;https://go2.grafana.com/2024-12-AWSreInventLasVegas-AMER-meetingrequest.html&#34; rel=&#34;noopener noreferrer&#34;&gt;Request a meeting&lt;/a&gt;&lt;/div&gt;&#xA;&lt;p&gt;Visit us at &lt;strong&gt;&lt;a href=&#34;/events/aws-reinvent/&#34;&gt;booth #2053&lt;/a&gt;&lt;/strong&gt;, or click the button above to request a meeting. This is your chance to get your technical questions answered by Grafana Labs experts, learn from your peers, and, of course, grab some swag.&lt;/p&gt;&#xA;&lt;p&gt;We also invite you to come see our &lt;a href=&#34;/blog/2024/11/20/metrics-logs-traces-and-mayhem-introducing-an-observability-adventure-game-powered-by-grafana-alloy-and-otel/&#34;&gt;OpenTelemetry + Grafana Alloy demo&lt;/a&gt; at the AWS Modern Applications and Open Source Zone on the expo floor during the following timeslots (spoiler alert: there may be an evil wizard and some sword play involved, too):&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Tues., Dec. 3 from 1 - 2pm&lt;/li&gt;&#xA;&lt;li&gt;Thurs., Dec. 5 from 11am - 12pm&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;grafana-labs-at-reinvent&#34;&gt;Grafana Labs at re:Invent&lt;/h2&gt;&#xA;&lt;p&gt;What better place to learn about how Grafana can help you monitor your AWS environment than at re:Invent? Here&amp;rsquo;s what we have in store for you:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Learn how to visualize and alert on more than 60 AWS offerings in minutes with the&lt;a href=&#34;/solutions/cloud-monitoring-aws/&#34;&gt; AWS Observability app&lt;/a&gt; in Grafana Cloud.&lt;/li&gt;&#xA;&lt;li&gt;Discover the latest features and AI/ML developments that can help you identify and resolve issues faster so you get better value from your observability practice.&lt;/li&gt;&#xA;&lt;li&gt;Read analysis on the state of observability, gathered from our annual &lt;a href=&#34;/observability-survey/&#34;&gt;Observability Survey&lt;/a&gt;—and participate in the next edition! (You&amp;rsquo;ll even have a chance to win some special swag that&amp;rsquo;s just for attendees.)&lt;/li&gt;&#xA;&lt;li&gt;Catch up on all Grafana Labs offers to help monitor your cloud systems and reduce observability costs, including the Grafana LGTM (&lt;a href=&#34;/oss/loki/&#34;&gt;Loki&lt;/a&gt; for logs,&lt;a href=&#34;/oss/grafana?pg=blog&amp;amp;plcmt=body-txt&#34;&gt; Grafana&lt;/a&gt; for visualization,&lt;a href=&#34;/oss/tempo/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt; Tempo&lt;/a&gt; for traces,&lt;a href=&#34;/oss/mimir/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt; Mimir&lt;/a&gt; for metrics) and &lt;a href=&#34;/oss/pyroscope/&#34;&gt;Grafana Pyroscope&lt;/a&gt; stack. You can also learn about our tools for incident response, application observability, performance testing, and more!&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;See you in Vegas!&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;Interested in more ways to connect with Grafana Labs? Visit our&lt;a href=&#34;/about/events/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt; events page&lt;/a&gt; to see upcoming in-person and virtual opportunities.&lt;/em&gt;&lt;/p&gt;】&lt;p&gt;&lt;a href=&#34;https://reinvent.awsevents.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;AWS re:Invent 2024&lt;/a&gt; 接下来将再次接管拉斯维加斯大道月，我们迫不及待地想在那里见到您！&lt;/p&gt;&#xA;&lt;p&gt;re:Invent 活动将于 12 月 2 日至 6 日举行，包括为期五天的技术讲座、实验室、训练营、主题演讲等。 Grafana Labs 将再次参与其中。&lt;/p&gt;&#xA;&lt;div class=&#34;btn-row &#34;&gt;&lt;a class=&#34;btn btn--primary&#34; href=&#34;https://go2.grafana.com/2024-12-AWSreInventLasVegas-AMER-meetingrequest.html&#34; rel=&#34;noopener noreferrer&#34;&gt;请求会面&lt;/a&gt;&lt;/div&gt;&#xA;&lt;p&gt;请访问我们的&lt;strong&gt;&lt;a href=&#34;/events/aws-reinvent/&#34;&gt;2053号展位&lt;/a&gt;&lt;/strong&gt;，或点击上面的按钮请求会面。这是您获得 Grafana Labs 专家解答技术问题、向同行学习的机会，当然还可以获取一些赠品。&lt;/p&gt;&#xA;&lt;p&gt;我们还邀请您来看看我们的&lt;a href=&#34;/blog/2024/11/20/metrics-logs-traces-and-mayhem-introducing-an-observability-adventure-game-powered-by-grafana -alloy-and-otel/&#34;&gt;OpenTelemetry + Grafana Alloy 演示&lt;/a&gt;，将于以下时间段在世博会的 AWS 现代应用程序和开源专区进行（剧透警告：有可能是一个邪恶的巫师，也涉及一些剑术）：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;12 月 3 日星期二下午 1 点至 2 点&lt;/li&gt;&#xA;&lt;li&gt;12 月 5 日星期四上午 11 点至中午 12 点&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;grafana-labs-at-reinvent&#34;&gt;re:Invent 的 Grafana 实验室&lt;/h2&gt;&#xA;&lt;p&gt;还有什么地方比 re:Invent 更好地了解 Grafana 如何帮助您监控 AWS 环境呢？以下是我们为您准备的内容：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;了解如何使用 Grafana Cloud 中的&lt;a href=&#34;/solutions/cloud-monitoring-aws/&#34;&gt;AWS Observability 应用&lt;/a&gt;在几分钟内对 60 多种 AWS 产品进行可视化和警报。&lt;/li&gt;&#xA;&lt;li&gt;了解最新功能和 AI/ML 开发成果，帮助您更快地识别和解决问题，从而从可观测性实践中获得更大价值。&lt;/li&gt;&#xA;&lt;li&gt;阅读我们的年度&lt;a href=&#34;/observability-survey/&#34;&gt;可观测性调查&lt;/a&gt;中收集的有关可观测性状况的分析 - 并参与下一期！ （您甚至有机会赢得一些专为与会者准备的特殊赠品。）&lt;/li&gt;&#xA;&lt;li&gt;了解 Grafana Labs 的所有产品，以帮助监控您的云系统并降低可观测性成本，包括 Grafana LGTM（&lt;a href=&#34;/oss/loki/&#34;&gt;Loki&lt;/a&gt; 用于日志，&lt;a href= &#34;/oss/grafana?pg=blog&amp;plcmt=body-txt&#34;&gt; Grafana&lt;/a&gt; 用于可视化，&lt;a href=&#34;/oss/tempo/?pg=blog&amp;plcmt=body-txt&#34;&gt; Tempo&lt;/a&gt; 用于跟踪，&lt;a href=&#34;/oss/mimir/?pg=blog&amp;plcmt=body-txt&#34;&gt; Mimir&lt;/a&gt; 用于指标）和 &lt;a href=&#34;/oss/pyrscope/&#34;&gt;Grafana热像仪&lt;/a&gt;堆栈。您还可以了解我们的事件响应、应用程序可观察性、性能测试等工具！&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;拉斯维加斯见！&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;有兴趣了解更多与 Grafana Labs 联系的方式吗？请访问我们的&lt;a href=&#34;/about/events/?pg=blog&amp;plcmt=body-txt&#34;&gt;活动页面&lt;/a&gt;，查看即将推出的现场和虚拟机会。&lt;/em&gt;&lt;/p&gt;</description>
      <pubDate>Wed, 20 Nov 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【ObservabilityCON on the Roadが東京にやってくる！】ObservabilityCON on the Road 即将来到东京！</title>
      <link>https://grafana.com/blog/2024/11/26/observabilitycon-on-the-road%E3%81%8B%E6%9D%B1%E4%BA%AC%E3%81%AB%E3%82%84%E3%81%A3%E3%81%A6%E3%81%8F%E3%82%8B/</link>
      <description>【&lt;p&gt;ObservabilityCON on the Roadが初めて日本で開催されることをお知らせできることを、私たちは大変嬉しく思います！2025年2月25日、東京ポートシティ竹芝のポートホールで行われる一日限りの特別なイベントにぜひご参加ください。日本にいながら、オブザーバビリティの最新動向やインサイト、革新技術を直接体験できる貴重な機会です。&lt;/p&gt;&#xA;&lt;p&gt;Grafana LabsのCTOであるTom Wilkieをはじめとする素晴らしいGrafana Labsチームが登壇し、オブザーバビリティの最新トレンドを掘り下げ、Grafanaエコシステムの最新アップデートやイノベーションをご紹介します。また、オブザーバビリティスタックの最適化に役立つ実践的なヒントやテクニックもお届けします。&lt;/p&gt;&#xA;&lt;h2 id=&#34;期待できる内容&#34;&gt;期待できる内容&lt;/h2&gt;&#xA;&lt;p&gt;この一日限りのイベントでは、学び、コミュニティ、そしてもちろん楽しさも満載です。以下は主なプログラムの概要です：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;基調講演:&lt;/strong&gt; Tom WilkieをはじめとするGrafana Labsのリーダーによるインスピレーションあふれる講演で、オブザーバビリティとGrafanaの最新動向や将来の展望をご紹介します。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;デモと技術セッション:&lt;/strong&gt; Grafana Cloudを活用したパフォーマンスの最大化、迅速なトラブルシューティング、そして未来を見据えた最新技術のデモや講演を体験できます。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;日本企業の成功事例:&lt;/strong&gt; グリー株式会社様をはじめとする著名な日本企業がGrafana Cloudをどのように活用してオブザーバビリティ戦略を強化し、可視化、トラブルシューティング、システムの信頼性向上を実現しているかをご紹介します。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;エキスパートへの相談:&lt;/strong&gt; 難しい質問も大歓迎！Grafana Labsのエキスパートが直接お答えし、具体的な課題に対する解決策を提供します。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;イベントの最後にはネットワーキングパーティを開催予定です。業界の仲間と交流し、アイデアを交換し、Grafanaコミュニティとのつながりを深める絶好のチャンスです。&lt;/p&gt;&#xA;&lt;h2 id=&#34;参加登録情報&#34;&gt;参加登録情報&lt;/h2&gt;&#xA;&lt;p&gt;参加登録はまだ始まっていませんが、ご安心ください！12月上旬に登録を開始する予定です。&lt;/p&gt;&#xA;&lt;p&gt;詳細情報は随時お知らせいたしますので、カレンダーに日程を記入して、この素晴らしい機会をお見逃しなく！皆さまにお会いできるのを心より楽しみにしています。&lt;/p&gt;&#xA;&lt;h2 id=&#34;grafana-cloudについて&#34;&gt;Grafana Cloudについて&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;/ja/products/cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloudは&lt;/a&gt;、メトリクス、ログ、トレース、ダッシュボードなどを簡単に始められる最適な方法です。無料で利用可能なプランから、あらゆるニーズに対応したプランをご用意しています。&lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;今すぐ無料でサインアップ&lt;/a&gt;してください！&lt;/p&gt;】&lt;p&gt;我们非常高兴地宣布 ObservabilityCON on the Road 将首次在日本举办！请参加我们于 2025 年 2 月 25 日在东京港口城竹芝港口大厅举行的特别一日活动。这是在日本期间直接体验最新可观测性趋势、见解和创新技术的宝贵机会。 &lt;/p&gt;&#xA;&lt;p&gt;包括 Grafana Labs 首席技术官 Tom Wilkie 在内的出色的 Grafana Labs 团队将登台深入探讨可观测性的最新趋势，并介绍 Grafana 生态系统的最新更新和创新。我们还提供实用的提示和技巧来帮助您优化可观察性堆栈。 &lt;/p&gt;&#xA;&lt;h2 id=&#34;您可以期待什么&#34;&gt;您可以期待什么&lt;/h2&gt;&#xA;&lt;p&gt;这个为期一天的活动充满了学习、社区，当然还有乐趣。以下是主要程序的概述：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;主题演讲&lt;/strong&gt;：Tom Wilkie 和其他 Grafana Labs 领导者的鼓舞人心的演讲将向您介绍可观测性和 Grafana 的最新趋势和未来前景。 &lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;演示和技术会议&lt;/strong&gt;：最大限度地提高性能、加快故障排除速度，并使用 Grafana Cloud 观看面向未来的演示和讲座。 &lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;日本公司成功案例：&lt;/strong&gt;包括 Gree Inc. 在内的著名日本公司如何利用 Grafana Cloud 增强其可视化、故障排除的可观察性策略，我们将向您展示我们如何提高系统可靠性。 &lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;咨询专家：&lt;/strong&gt;也欢迎提出疑难问题！ Grafana Labs 专家将为您提供直接答案，并针对您的具体挑战提供解决方案。 &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;活动结束时将举行社交聚会。这是与业界同行联系、交流想法并加深与 Grafana 社区联系的绝佳机会。 &lt;/p&gt;&#xA;&lt;h2 id=&#34;参与者注册信息&#34;&gt;参与者注册信息&lt;/h2&gt;&#xA;&lt;p&gt;报名尚未开始，但别担心！登记预计于十二月初开始。 &lt;/p&gt;&#xA;&lt;p&gt;我们将为您提供更多最新信息，因此请在您的日历上标记它，不要错过这个绝佳的机会！我真的很期待见到你们大家。 &lt;/p&gt;&#xA;&lt;h2 id=&#34;关于grafana-cloud&#34;&gt;关于Grafana Cloud&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;/ja/products/cloud/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana 云&lt;/a&gt;这是轻松开始使用跟踪、仪表板等的完美方式。我们提供免费计划以满足各种需求。 &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;plcmt=body-txt&#34;&gt;立即免费注册&lt;/a&gt;！ &lt;/p&gt;</description>
      <pubDate>Tue, 26 Nov 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Grafana Loki 3.3 release: faster query results via Blooms for structured metadata】Grafana Loki 3.3 版本：通过 Blooms 获取结构化元数据更快的查询结果</title>
      <link>https://grafana.com/blog/2024/11/21/grafana-loki-3.3-release-faster-query-results-via-blooms-for-structured-metadata/</link>
      <description>【&lt;p&gt;The &lt;a href=&#34;https://github.com/grafana/loki/releases/tag/v3.3.0&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Grafana Loki 3.3&lt;/a&gt; release is here, and it brings a fresh wave of enhancements aimed at making your log management experience faster, more efficient, and more scalable.&lt;/p&gt;&#xA;&lt;p&gt;While this update includes the usual round of bug fixes and operational improvements, the standout feature is a shift in how Loki leverages Bloom filters—going from free-text search to harnessing the power of structured metadata. This will make it easier to find a specific needle in your haystack of logs, while improving the query experience for our OpenTelemetry community as well.&lt;/p&gt;&#xA;&lt;p&gt;Query acceleration via Bloom filters is considered experimental for our Loki and Grafana Enterprise Logs (GEL) 3.3 releases, and is available in public preview for large &lt;a href=&#34;/products/cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt; customers.&lt;/p&gt;&#xA;&lt;p&gt;Let’s dive into what this means for your workflows and how it sets the stage for Loki’s exciting future.&lt;/p&gt;&#xA;&lt;h2 id=&#34;query-acceleration-via-bloom-filters&#34;&gt;Query acceleration via Bloom filters&lt;/h2&gt;&#xA;&lt;p&gt;With &lt;a href=&#34;/blog/2024/04/09/grafana-loki-3.0-release-all-the-new-features/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Loki 3.0&lt;/a&gt;, we announced Bloom filters, a very promising, experimental feature intended to speed up needle in a haystack queries. Since then, we&amp;rsquo;ve received great insights from early adopters and learned a lot about running Blooms at a large scale—and the tradeoffs our users were willing to make.&lt;/p&gt;&#xA;&lt;p&gt;With this in mind, and with the increasing adoption of OpenTelemetry, we adjusted our approach and decided to create Blooms leveraging &lt;a href=&#34;/docs/loki/latest/get-started/labels/structured-metadata/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;structured metadata&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h3 id=&#34;what-is-structured-metadata-in-loki&#34;&gt;What is structured metadata in Loki?&lt;/h3&gt;&#xA;&lt;p&gt;Structured metadata allows you to attach metadata labels to each of your log lines. It was first introduced in Loki 2.9 for high cardinality labels that couldn&amp;rsquo;t be indexed, and for when it was too difficult to extract commonly-accessed log content into labels at query time. Then, In Loki 3.0, we added &lt;a href=&#34;/blog/2024/04/09/grafana-loki-3.0-release-all-the-new-features/?pg=blog&amp;amp;plcmt=body-txt#native-opentelemetry-support&#34;&gt;native OpenTelemetry support&lt;/a&gt;, which leverages structured metadata to store all the attributes OTel sends with each log line.&lt;/p&gt;&#xA;&lt;p&gt;And now, this same structured metadata can also be used to accelerate queries.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If you are not using OTel, you can still attach structured metadata to your log lines with &lt;a href=&#34;/docs/alloy/latest/reference/components/loki/loki.process/?pg=blog&amp;amp;plcmt=body-txt#stagestructured_metadata-block&#34;&gt;Grafana Alloy&amp;rsquo;s Loki pipelines&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;a-refresher-on-bloom-filters-and-why-you-would-use-them&#34;&gt;A refresher on Bloom filters, and why you would use them&lt;/h3&gt;&#xA;&lt;p&gt;Loki leverages Bloom filters in order to tell it what data &lt;em&gt;not&lt;/em&gt; to search. In managing Loki, we’ve observed that many log searches touch lots of log lines but only need the results from a select few that meet a certain criteria.&lt;/p&gt;&#xA;&lt;p&gt;As an example, maybe you&amp;rsquo;re looking for all log lines that have a certain user ID because you need to debug why an ecommerce user is being logged out of their account when they add an item to their shopping cart. Or maybe you want to find all the log lines that match a certain device ID to help troubleshoot a payment device or game controller.&lt;/p&gt;&#xA;&lt;h3 id=&#34;how-we-are-using-blooms-to-accelerate-queries&#34;&gt;How we are using Blooms to accelerate queries&lt;/h3&gt;&#xA;&lt;p&gt;Just like the previous version of Blooms, we still build Blooms per series. This time, instead of n-grams computed out of the whole log content, Blooms now contain the key of each structured metadata field seen within the series, along with all the existing key-value pairs.&lt;/p&gt;&#xA;&lt;p&gt;Blooms built out of structured metadata are orders of magnitude smaller, thus faster to build, download, and query.&lt;/p&gt;&#xA;&lt;h2 id=&#34;how-to-use-query-acceleration&#34;&gt;How to use query acceleration&lt;/h2&gt;&#xA;&lt;p&gt;To take advantage of Blooms, your queries need to satisfy the following criteria:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Bloom blocks should be created and available in the Bloom gateways for the time interval of the query.&lt;/li&gt;&#xA;&lt;li&gt;Queries should invoke acceleration &lt;a href=&#34;/docs/loki/latest/query/query_accceleration/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;by using proper syntax&lt;/a&gt; to query structured metadata&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;For example, if you want to look for a specific trace ID, and the trace ID is available as structured metadata, the following expression should be accelerated if they are available:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;{env=&amp;#34;prod&amp;#34;} | traceID=&amp;#34;3f54c1d2ae0c&amp;#34; | json | line_format &amp;#34;{{.api_route}} time={{.req_time}}&amp;#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;In this query, the &lt;code&gt;{env=”prod”}&lt;/code&gt; stream selector will narrow down the search space to the matching series. Then, with &lt;code&gt;traceID=&amp;quot;3f54c1d2ae0c&amp;quot;&lt;/code&gt; we use Blooms to further narrow down the search space by discarding all the chunks from the matching series that we&amp;rsquo;re sure don&amp;rsquo;t contain this structured metadata key-value pair. Finally, we only apply the &lt;code&gt;json&lt;/code&gt; parser and the line formatting to the logs from the matching chunks. This significantly reduces the amount of data Loki needs to download, unpack, and process.&lt;/p&gt;&#xA;&lt;h2 id=&#34;how-to-upgrade&#34;&gt;How to upgrade&lt;/h2&gt;&#xA;&lt;p&gt;The new Bloom blocks have a new format that&amp;rsquo;s incompatible with the previous version of Blooms. As a result, any previously created blocks are now obsolete. We recommend you clean your Bloom blocks before upgrading to the new Loki version by deleting the &lt;em&gt;bloom&lt;/em&gt; path inside the object store (see &lt;a href=&#34;/docs/loki/latest/setup/upgrade/?pg=blog&amp;amp;plcmt=body-txt#330&#34;&gt;upgrade notes&lt;/a&gt;).&lt;/p&gt;&#xA;&lt;p&gt;In addition to building Blooms for structured metadata, we also made some others changes and improvements for Blooms:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;We removed the Bloom compactor in favor of the &lt;a href=&#34;/docs/loki/latest/operations/query-acceleration-blooms/?pg=blog&amp;amp;plcmt=body-txt#bloom-planner-and-builder&#34;&gt;Bloom planner and builder components&lt;/a&gt;, which are now configured in &lt;a href=&#34;/docs/loki/latest/setup/install/helm/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Helm&lt;/a&gt; and enabled in the &lt;a href=&#34;/docs/loki/latest/get-started/deployment-modes/?pg=blog&amp;amp;plcmt=body-txt#simple-scalable&#34;&gt;simple scale deployment&lt;/a&gt; backend target.&lt;/li&gt;&#xA;&lt;li&gt;We introduced a new build strategy that split tasks based on the TSDB stats for the chunks size of the series. The strategy is configurable via the &lt;code&gt;bloom_planning_strategy&lt;/code&gt; per-tenant limit. We haven’t changed the default planning strategy, which splits the series key-space by a configurable factor. But we encourage users to try the new strategy, which should result in more consistently sized Bloom building tasks.&lt;/li&gt;&#xA;&lt;li&gt;Another addition to the Bloom planner component is a disk-backed queue. By default, the queue keeps all tasks in memory, but you can enable the disk-backed queue if you have a large set of tenants or a memory-contrained environment.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;start-using-loki-33-today&#34;&gt;Start using Loki 3.3 today&lt;/h2&gt;&#xA;&lt;p&gt;Loki 3.3 ships a whole set of new experimental features, improvements and bug fixes that opens the door to make Loki more scalable, faster, and easy to use in the near future. If you are a GEL customer, the same functionality that’s in Loki 3.3 is also part of our GEL 3.3 release.&lt;/p&gt;&#xA;&lt;p&gt;Consult the Loki and GEL release notes and changelog for more:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/docs/loki/latest/release-notes/v3-3/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Loki release notes&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/grafana/loki/blob/release-3.3.x/CHANGELOG.md&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Loki changelog&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/docs/enterprise-logs/latest/release-notes/v3-3/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;GEL release notes&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/grafana/enterprise-logs/blob/main/cmd/enterprise-logs/CHANGELOG.md&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;GEL changelog&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;And if you are new to Loki, please consult our &lt;a href=&#34;/docs/loki/latest/get-started/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Getting Started&lt;/a&gt; section to get up and running as quickly as possible. In the meantime, give the new features a spin, explore the benefits of structured metadata Blooms, and let us know your feedback. Your insights help us make Loki better with every release.&lt;/p&gt;&#xA;&lt;p&gt;Happy logging!&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud &lt;/a&gt;is the easiest way to get started with metrics, logs, traces, dashboards, and more. We have a generous forever-free tier and plans for every use case. &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Sign up for free now!&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;】&lt;p&gt;&lt;a href=&#34;https://github.com/grafana/loki/releases/tag/v3.3.0&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Grafana Loki 3.3&lt;/a&gt; 版本为在这里，它带来了新一波的增强功能，旨在让您的日志管理体验更快、更高效、更具可扩展性。&lt;/p&gt;&#xA;&lt;p&gt;虽然此更新包括通常的错误修复和操作改进，但最突出的功能是 Loki 利用 Bloom 过滤器的方式的转变 - 从自由文本搜索到利用结构化元数据的力量。这将使您更轻松地在日志大海捞针中找到特定的目标，同时也改善了我们 OpenTelemetry 社区的查询体验。&lt;/p&gt;&#xA;&lt;p&gt;通过 Bloom 过滤器进行查询加速对于我们的 Loki 和 Grafana Enterprise Logs (GEL) 3.3 版本被认为是实验性的，并且在大型 &lt;a href=&#34;/products/cloud/?pg=blog&amp;plcmt=body-txt 中提供公共预览版&#34;&gt;Grafana Cloud&lt;/a&gt; 客户。&lt;/p&gt;&#xA;&lt;p&gt;让我们深入了解这对您的工作流程意味着什么，以及它如何为 Loki 令人兴奋的未来奠定基础。&lt;/p&gt;&#xA;&lt;h2 id=&#34;query-acceleration-via-bloom-filters&#34;&gt;通过 Bloom 过滤器进行查询加速&lt;/h2&gt;&#xA;&lt;p&gt;与&lt;a href=&#34;/blog/2024/04/09/grafana-loki-3.0-release-all-the-new-features/?pg=blog&amp;plcmt=body-txt&#34;&gt;Loki 3.0&lt;/a&gt; ，我们发布了布隆过滤器，这是一个非常有前途的实验性功能，旨在加速大海捞针查询。从那时起，我们从早期采用者那里获得了深刻的见解，并了解了很多有关大规模运行 Bloom 的知识，以及我们的用户愿意做出的权衡。&lt;/p&gt;&#xA;&lt;p&gt;考虑到这一点，并且随着 OpenTelemetry 的日益普及，我们调整了我们的方法，并决定利用 &lt;a href=&#34;/docs/loki/latest/get-started/labels/structed-metadata/?pg 创建 Blooms =blog&amp;plcmt=body-txt&#34;&gt;结构化元数据&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;what-is-structed-metadata-in-loki&#34;&gt;Loki 中的结构化元数据是什么？&lt;/h3&gt;&#xA;&lt;p&gt;结构化元数据允许您将元数据标签附加到每个日志行。它首次在 Loki 2.9 中引入，用于无法索引的高基数标签，以及在查询时将常用访问的日志内容提取到标签中太困难的情况。然后，在 Loki 3.0 中，我们添加了 &lt;a href=&#34;/blog/2024/04/09/grafana-loki-3.0-release-all-the-new-features/?pg=blog&amp;plcmt=body-txt#native-opentelemetry -support&#34;&gt;原生 OpenTelemetry 支持&lt;/a&gt;，它利用结构化元数据来存储 OTel 随每个日志行发送的所有属性。&lt;/p&gt;&#xA;&lt;p&gt;现在，同样的结构化元数据也可用于加速查询。&lt;/p&gt;&#xA;&lt;块引用&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;如果您不使用 OTel，您仍然可以使用 &lt;a href=&#34;/docs/alloy/latest/reference/components/loki/loki.txt 将结构化元数据附加到日志行中。 process/?pg=blog&amp;plcmt=body-txt#stagestructed_metadata-block&#34;&gt;Grafana Alloy 的 Loki 管道&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;/块引用&gt;&#xA;&lt;h3 id=&#34;a-refresher-on-bloom-filters-and-why-you-would-use-them&#34;&gt;回顾一下 Bloom 过滤器，以及为什么要使用会使用它们&lt;/h3&gt;&#xA;&lt;p&gt;Loki 利用布隆过滤器来告诉它哪些数据&lt;em&gt;不&lt;/em&gt;要搜索。在管理 Loki 时，我们观察到许多日志搜索涉及大量日志行，但只需要满足特定条件的少数几个日志行的结果。&lt;/p&gt;&#xA;&lt;p&gt;举个例子，也许您正在查找具有特定用户 ID 的所有日志行，因为您需要调试为什么电子商务用户在将商品添加到购物车时会从其帐户中注销。或者您可能想要查找与特定设备 ID 匹配的所有日志行，以帮助对支付设备或游戏控制器进行故障排除。&lt;/p&gt;&#xA;&lt;h3 id=&#34;how-we-are-using-blooms-to-accelerate-queries&#34;&gt;我们如何使用 Bloom 来加速查询&lt;/h3&gt;&#xA;&lt;p&gt;就像之前版本的 Blooms 一样，我们仍然按系列构建 Blooms。这次，Bloom 现在包含该系列中看到的每个结构化元数据字段的键以及所有现有的键值对，而不是根据整个日志内容计算出的 n 元语法。&lt;/p&gt;&#xA;&lt;p&gt;基于结构化元数据构建的 Bloom 的数量级要小，因此构建、下载和查询速度更快。&lt;/p&gt;&#xA;&lt;h2 id=&#34;how-to-use-query-acceleration&#34;&gt;如何使用查询加速&lt;/h2&gt;&#xA;&lt;p&gt;要利用 Bloom，您的查询需要满足以下条件：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;应在查询的时间间隔内在 Bloom 网关中创建并可用 Bloom 块。&lt;/li&gt;&#xA;&lt;li&gt;查询应&lt;a href=&#34;/docs/loki/latest/query/query_accceleration/?pg=blog&amp;plcmt=body-txt&#34;&gt;使用正确的语法&lt;/a&gt;调用加速来查询结构化元数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;例如，如果您想要查找特定的跟踪 ID，并且该跟踪 ID 可作为结构化元数据使用，则应加速以下表达式（如果可用）：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;{env=&#34;prod&#34;} |跟踪ID =“3f54c1d2ae0c”| json | line_format &#34;{{.api_route}} time={{.req_time}}&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;在此查询中，&lt;code&gt;{env=”prod”}&lt;/code&gt; 流选择器会将搜索空间缩小到匹配的系列。然后，通过 &lt;code&gt;traceID=&#34;3f54c1d2ae0c&#34;&lt;/code&gt;，我们使用 Blooms 丢弃匹配系列中我们确定不包含此结构化元数据键值对的所有块，进一步缩小搜索空间。最后，我们仅将 &lt;code&gt;json&lt;/code&gt; 解析器和行格式应用于匹配块中的日志。这显着减少了 Loki 需要下载、解压和处理的数据量。&lt;/p&gt;&#xA;&lt;h2 id=&#34;如何升级&#34;&gt;如何升级&lt;/h2&gt;&#xA;&lt;p&gt;新的 Bloom 块具有与之前版本的 Bloom 不兼容的新格式。因此，任何以前创建的块现在都已过时。我们建议您在升级到新的 Loki 版本之前，通过删除对象存储中的 &lt;em&gt;bloom&lt;/em&gt; 路径来清理 Bloom 块（请参阅 &lt;a href=&#34;/docs/loki/latest/setup/upgrade/?pg =blog&amp;plcmt=body-txt#330&#34;&gt;升级说明&lt;/a&gt;）。&lt;/p&gt;&#xA;&lt;p&gt;除了为结构化元数据构建 Bloom 之外，我们还对 Bloom 进行了一些其他更改和改进：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;我们删除了 Bloom 压缩器，转而采用&lt;a href=&#34;/docs/loki/latest/operations/query-acceleration-blooms/?pg=blog&amp;plcmt=body-txt#bloom-planner-and-builder&#34;&gt; Bloom 规划器和构建器组件&lt;/a&gt;，现在在 &lt;a 中配置href=&#34;/docs/loki/latest/setup/install/helm/?pg=blog&amp;plcmt=body-txt&#34;&gt;Helm&lt;/a&gt; 并在 &lt;a href=&#34;/docs/loki/latest/get-started 中启用/deployment-modes/?pg=blog&amp;plcmt=body-txt#simple-scalable&#34;&gt;简单规模部署&lt;/a&gt;后端目标。&lt;/li&gt;&#xA;&lt;li&gt;我们引入了一种新的构建策略，该策略根据系列块大小的 TSDB 统计数据来拆分任务。该策略可通过 &lt;code&gt;bloom_planning_strategy&lt;/code&gt; 每租户限制进行配置。我们没有更改默认的规划策略，该策略通过可配置的因子分割系列键空间。但我们鼓励用户尝试新策略，这应该会导致 Bloom 构建任务的大小更加一致。&lt;/li&gt;&#xA;&lt;li&gt;Bloom planner 组件的另一个附加功能是磁盘支持的队列。默认情况下，队列将所有任务保留在内存中，但如果您有大量租户或内存受限的环境，则可以启用磁盘支持的队列。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;start-using-loki-33-today&#34;&gt;立即开始使用 Loki 3.3&lt;/h2&gt;&#xA;&lt;p&gt;Loki 3.3 提供了一整套新的实验性功能、改进和错误修复，为在不久的将来使 Loki 更具可扩展性、更快且易于使用打开了大门。如果您是 GEL 客户，Loki 3.3 中的相同功能也是我们的 GEL 3.3 版本的一部分。&lt;/p&gt;&#xA;&lt;p&gt;请参阅 Loki 和 GEL 发行说明和变更日志以了解更多信息：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/docs/loki/latest/release-notes/v3-3/?pg=blog&amp;plcmt=body-txt&#34;&gt;Loki 发行说明&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/grafana/loki/blob/release-3.3.x/CHANGELOG.md&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Loki 变更日志&lt;/a&gt; &lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/docs/enterprise-logs/latest/release-notes/v3-3/?pg=blog&amp;plcmt=body-txt&#34;&gt;GEL 发行说明&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/grafana/enterprise-logs/blob/main/cmd/enterprise-logs/CHANGELOG.md&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;GEL 变更日志&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如果您是 Loki 新手，请查阅我们的&lt;a href=&#34;/docs/loki/latest/get-started/?pg=blog&amp;plcmt=body-txt&#34;&gt;入门&lt;/a&gt;部分以开始使用并尽可能快地跑。与此同时，尝试一下新功能，探索结构化元数据的好处Blooms，请让我们知道您的反馈。您的见解帮助我们在每个版本中让 Loki 变得更好。&lt;/p&gt;&#xA;&lt;p&gt;祝您登录愉快！&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt;是开始使用指标、日志、跟踪、仪表板等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。 &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;plcmt=body-txt&#34;&gt;立即免费注册！&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</description>
      <pubDate>Thu, 21 Nov 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Easily control observability collectors at scale with Fleet Management in Grafana Cloud】通过 Grafana Cloud 中的队列管理轻松大规模控制可观测性收集器</title>
      <link>https://grafana.com/blog/2024/11/20/easily-control-observability-collectors-at-scale-with-fleet-management-in-grafana-cloud/</link>
      <description>【&lt;p&gt;Managing observability workloads can quickly overwhelm even the most experienced admin.&lt;/p&gt;&#xA;&lt;p&gt;Maybe you’re dealing with multiple departments, each needing its own collector configurations and pipelines. Every time you have to run a test or roll out a change, the process is cumbersome and introduces risk.&lt;/p&gt;&#xA;&lt;p&gt;Or perhaps you’re responsible for tracking hundreds of collectors across different environments and regions. In a scenario like this, troubleshooting individual issues feels nearly impossible.&lt;/p&gt;&#xA;&lt;p&gt;Whether you&amp;rsquo;re dealing with complex configurations, rising costs, or just trying to keep tabs on every collector, you need everything in one place to make sense of it all. That&amp;rsquo;s why we’re excited to announce the Public Preview of Fleet Management in Grafana Cloud—a powerful new way to monitor and manage observability collectors efficiently, regardless of scale.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;/docs/grafana-cloud/send-data/fleet-management/intro-fleet-mgmt/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Fleet Management&lt;/a&gt; is designed for teams looking to manage hundreds or thousands of collectors efficiently, so they can remotely configure, activate, or deactivate telemetry pipelines on demand. With Fleet Management, you can roll out configurations remotely, monitor collector health across all deployments, and control cost simply by activating or deactivating pipelines as needed.&lt;/p&gt;&#xA;&lt;h2 id=&#34;why-fleet-management&#34;&gt;Why Fleet Management?&lt;/h2&gt;&#xA;&lt;p&gt;Fleet Management is built to tackle the complexity of scaling collector management:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Streamlined configuration management.&lt;/strong&gt; With a central control hub, you can easily manage configurations across all collectors. Deploy targeted pipelines, fine-tune individual configurations, and cut down on overhead.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Comprehensive Collector Insights.&lt;/strong&gt; Get complete visibility into your collector fleet. Monitor metrics, logs, and applied configurations for each collector, making it faster to identify and resolve issues.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Optimize data collection and costs.&lt;/strong&gt; Tailor data collection pipelines to match specific use cases. Turn data streams on and off as needed to optimize your costs and reduce data overload.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Management of observability collectors at any scale—whether dozens, hundreds, or thousands—is now easier than ever with Fleet Management, starting with support for the Grafana Alloy collector.&lt;/p&gt;&#xA;&lt;h2 id=&#34;how-fleet-management-solves-your-data-collection-pain-points&#34;&gt;How Fleet Management solves your data collection pain points&lt;/h2&gt;&#xA;&lt;div&#xA;class=&#34;youtube-lazyload responsive-video&#34;&#xA;data-embed=&#34;mKOLablQUxM&#34;&#xA;data-url=&#34;https://www.youtube.com/embed/mKOLablQUxM?autoplay=1&amp;amp;rel=0&#34;&#xA;data-title=&#34;YouTube Video&#34;&#xA;&gt;&#xA;&lt;div class=&#34;play-button&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;Fleet Management was designed to be flexible yet powerful, with features that make managing collectors easier and more efficient:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;API Support for as-code automation:&lt;/strong&gt; Seamlessly integrate Fleet Management into your automation workflows. Use the&lt;a href=&#34;/docs/grafana-cloud/send-data/fleet-management/api-reference/collector-api/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt; Collector API&lt;/a&gt; for CRUD operations and bulk management of collectors, and the &lt;a href=&#34;/docs/grafana-cloud/send-data/fleet-management/api-reference/pipeline-api/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Pipeline API&lt;/a&gt; for fine-grained control over configuration creation and deployment.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Dynamic variables and secure credentials:&lt;/strong&gt; Reference system environment variables in configurations so collection templates remain flexible. For enhanced security, Fleet Management also integrates with HashiCorp Vault via an &lt;a href=&#34;/docs/alloy/latest/reference/components/remote/remote.vault/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Alloy Collector module&lt;/a&gt;, so you can securely retrieve and manage sensitive credentials.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;No more monolithic configuration:&lt;/strong&gt; Traditional configurations often rely on large, complex files. Fleet management replaces these with smaller, modular pipelines, making configurations reusable and easier to manage. This approach provides fine-grained control over which pipelines are activated, enabling on-demand collection for specialized use cases like continuous profiling or collecting debug logs.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Bulk editing and attribute management:&lt;/strong&gt; With bulk-editing options, you can assign and update custom attributes for collectors on the fly, even after installation.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;getting-started&#34;&gt;Getting started&lt;/h2&gt;&#xA;&lt;p&gt;Fleet Management is available to Grafana Cloud Admins in the &lt;strong&gt;Collector&lt;/strong&gt; section under &lt;strong&gt;Connections&lt;/strong&gt; in the Grafana UI. To get started, you’ll need to install a new instance of Grafana Alloy enabled with Fleet Management. Once it’s up and running, you’ll see your new collector in Fleet Management’s inventory, where you can monitor and remotely configure it.&lt;/p&gt;&#xA;&lt;p&gt;Follow &lt;a href=&#34;/docs/grafana-cloud/send-data/fleet-management/get-started/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;these steps&lt;/a&gt; to set up a new collector for remote configuration, or refer to &lt;a href=&#34;/docs/grafana-cloud/send-data/fleet-management/onboard-collectors/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;this guide&lt;/a&gt; to onboard existing collector.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Currently, Fleet Management supports &lt;a href=&#34;/docs/alloy/latest/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Alloy&lt;/a&gt;, our open source distribution of the OpenTelemetry Collector, fully compatible with the OTLP protocol and featuring native pipelines for OTel and Prometheus. As leading contributors to the Open Agent Management Protocol (OpAMP) project, we hope to extend support to traditional OTel Collectors in the future.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;try-fleet-management-today&#34;&gt;Try Fleet Management today&lt;/h2&gt;&#xA;&lt;p&gt;We’re excited to bring you Fleet Management in Public Preview, available across all Grafana Cloud stacks. Enable Fleet Management for your Alloy collectors today and experience the benefits of seamless remote configuration. Our team would love to hear from you—&lt;a href=&#34;https://forms.gle/NmLa9dEKCVmWzSDp7&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;reach out with any questions, feedback, or requests for assistance here. &lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt; is the easiest way to get started with metrics, logs, traces, dashboards, and more. We have a generous forever-free tier and plans for every use case. &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Sign up for free now&lt;/a&gt;!&lt;/em&gt;&lt;/p&gt;】&lt;p&gt;即使是最有经验的管理员，管理可观察性工作负载也会很快让他们不知所措。&lt;/p&gt;&#xA;&lt;p&gt;也许您正在与多个部门打交道，每个部门都需要自己的收集器配置和管道。每次您必须运行测试或推出更改时，这个过程都很麻烦并且会带来风险。&lt;/p&gt;&#xA;&lt;p&gt;或者您可能负责跟踪不同环境和地区的数百名收集者。在这种情况下，解决个别问题几乎是不可能的。&lt;/p&gt;&#xA;&lt;p&gt;无论您是在处理复杂的配置、不断上升的成本，还是只是想密切关注每个收集器，您都需要将所有内容集中在一个地方才能理解这一切。这就是为什么我们很高兴宣布在 Grafana Cloud 中推出舰队管理的公开预览版，这是一种强大的新方法，可以有效地监控和管理可观测性收集器，无论规模如何。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;/docs/grafana-cloud/send-data/fleet-management/intro-fleet-mgmt/?pg=blog&amp;plcmt=body-txt&#34;&gt;队列管理&lt;/a&gt;专为以下团队而设计：有效管理数百或数千个收集器，以便他们可以根据需要远程配置、激活或停用遥测管道。借助队列管理，您可以远程部署配置、监控所有部署中的收集器运行状况，并只需根据需要激活或停用管道来控制成本。&lt;/p&gt;&#xA;&lt;h2 id=&#34;why-fleet-management&#34;&gt;为什么选择车队管理？&lt;/h2&gt;&#xA;&lt;p&gt;车队管理旨在解决扩展收集器管理的复杂性：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;简化配置管理。&lt;/strong&gt;借助中央控制中心，您可以轻松管理所有收集器的配置。部署有针对性的管道、微调各个配置并减少开销。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;全面的收集器洞察。&lt;/strong&gt;全面了解您的收集器车队。监控每个收集器的指标、日志和应用的配置，从而更快地识别和解决问题。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;优化数据收集和成本。&lt;/strong&gt;定制数据收集管道以匹配特定用例。根据需要打开和关闭数据流，以优化成本并减少数据过载。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;从对 Grafana Alloy 收集器的支持开始，使用 Fleet Management 来管理任何规模（无论是数十个、数百个还是数千个）的可观测性收集器现在比以往任何时候都更加容易。&lt;/p&gt;&#xA;&lt;h2 id=&#34;how-fleet-management-solves-your-data-collection-pain-points&#34;&gt;车队管理如何解决您的数据收集痛点&lt;/h2&gt;&#xA;&lt;div&#xA;类 =“youtube-lazyload 响应视频”&#xA;数据嵌入=“mKOLablQUxM”&#xA;data-url=&#34;https://www.youtube.com/embed/mKOLablQUxM?autoplay=1&amp;rel=0&#34;&#xA;数据标题=“YouTube 视频”&#xA;&gt;&#xA;&lt;div class=&#34;play-button&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;车队管理的设计既灵活又强大，其功能使管理收集器变得更容易、更高效：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;API 支持代码自动化：&lt;/strong&gt; Sea将车队管理无缝集成到您的自动化工作流程中。使用&lt;a href=&#34;/docs/grafana-cloud/send-data/fleet-management/api-reference/collector-api/?pg=blog&amp;plcmt=body-txt&#34;&gt;收集器 API&lt;/a&gt; 进行 CRUD 操作收集器和管道的批量管理API&lt;/a&gt;用于对配置创建和部署进行细粒度控制。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;动态变量和安全凭证&lt;/strong&gt;：在配置中引用系统环境变量，以便集合模板保持灵活性。为了增强安全性，Fleet Management 还通过&lt;a href=&#34;/docs/alloy/latest/reference/components/remote/remote.vault/?pg=blog&amp;plcmt=body-txt&#34;&gt;合金收集器模块&lt;/ a&gt;，以便您可以安全地检索和管理敏感凭据。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;不再有单一配置：&lt;/strong&gt;传统配置通常依赖于大型、复杂的文件。车队管理用更小的模块化管道取代了这些管道，使配置可重复使用且更易于管理。这种方法提供了对激活哪些管道的细粒度控制，从而能够按需收集特殊用例，例如连续分析或收集调试日志。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;批量编辑和属性管理：&lt;/strong&gt;通过批量编辑选项，您甚至可以在安装后动态分配和更新收集器的自定义属性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;getting-started&#34;&gt;开始使用&lt;/h2&gt;&#xA;&lt;p&gt;Grafana Cloud 管理员可以在 Grafana UI 中&lt;strong&gt;连接&lt;/strong&gt;下的&lt;strong&gt;收集器&lt;/strong&gt;部分中使用队列管理。首先，您需要安装启用了队列管理的新 Grafana Alloy 实例。一旦启动并运行，您将在 Fleet Management 的库存中看到新的收集器，您可以在其中监视和远程配置它。&lt;/p&gt;&#xA;&lt;p&gt;按照&lt;a href=&#34;/docs/grafana-cloud/send-data/fleet-management/get-started/?pg=blog&amp;plcmt=body-txt&#34;&gt;这些步骤&lt;/a&gt;设置新的收集器如需远程配置，或参阅&lt;a href=&#34;/docs/grafana-cloud/send-data/fleet-management/onboard-collectors/?pg=blog&amp;plcmt=body-txt&#34;&gt;本指南&lt;/a&gt;搭载现有收集器。&lt;/p&gt;&#xA;&lt;块引用&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;目前，Fleet Management 支持我们的开源发行版 &lt;a href=&#34;/docs/alloy/latest/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Alloy&lt;/a&gt; OpenTelemetry Collector 的一部分，与 OTLP 协议完全兼容，并具有适用于 OTel 和 Prometheus 的本机管道。作为开放代理管理协议 (OpAMP) 项目的主要贡献者，我们希望将来能够扩展对传统 OTel 收集器的支持。&lt;/p&gt;&#xA;&lt;/块引用&gt;&#xA;&lt;h2 id=&#34;try-fleet-management-today&#34;&gt;立即尝试车队管理&lt;/h2&gt;&#xA;&lt;p&gt;我们很高兴为您带来公共预览版的车队管理，可在所有 Grafana Cloud 堆栈上使用。启用舰队法力立即为您的合金收集器配置并体验无缝远程配置的好处。我们的团队很乐意听取您的意见 - &lt;a href=&#34;https://forms.gle/NmLa9dEKCVmWzSDp7&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;如有任何问题、反馈或帮助请求，请在此处联系。 &lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt; 是开始使用指标、日志、跟踪、仪表板等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。 &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;plcmt=body-txt&#34;&gt;立即免费注册&lt;/a&gt;！&lt;/em&gt;&lt;/p&gt;</description>
      <pubDate>Wed, 20 Nov 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Leveraging OpenTelemetry and Grafana for observing, visualizing, and monitoring Kubernetes applications】利用 OpenTelemetry 和 Grafana 观察、可视化和监控 Kubernetes 应用程序</title>
      <link>https://grafana.com/blog/2024/11/22/leveraging-opentelemetry-and-grafana-for-observing-visualizing-and-monitoring-kubernetes-applications/</link>
      <description>【&lt;p&gt;&lt;em&gt;Ken has over 15 years of industry experience as a noted information and cybersecurity practitioner, software developer, author, and presenter, focusing on endpoint security, big security data analytics, and Federal Information Security Management Act (FISMA) and NIST 800-53 compliance. Focusing on strict federal standards, Ken has consulted with numerous federal organizations, including Defense Information Systems Agency (DISA), Department of Veterans Affairs, and the Census Bureau.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;Enterprises today can gain a competitive advantage by enabling developers to rapidly compose new application capabilities by utilizing existing microservices and Kubernetes.&lt;/p&gt;&#xA;&lt;p&gt;For example, by leveraging a library of reusable microservices, a financial institution can quickly develop and deploy new features, such as real-time fraud detection or personalized customer insights, without having to build these capabilities from scratch. This modular approach not only accelerates development cycles, but also ensures greater flexibility and scalability.&lt;/p&gt;&#xA;&lt;p&gt;Additionally, when a retail company integrates microservices for inventory management, payment processing, and customer notifications, it can swiftly adapt to market changes and seasonal demands, enhancing its responsiveness and customer satisfaction. This ability to innovate rapidly and efficiently through microservice composition is transforming how businesses compete and succeed in the digital age.&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-dark-side-of-composable-applications&#34;&gt;The dark side of composable applications&lt;/h2&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 2952px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/otel-report-ema/telemetry-stacks.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/otel-report-ema/telemetry-stacks.png&#34;data-srcset=&#34;/media/blog/otel-report-ema/telemetry-stacks.png?w=320 320w, /media/blog/otel-report-ema/telemetry-stacks.png?w=550 550w, /media/blog/otel-report-ema/telemetry-stacks.png?w=750 750w, /media/blog/otel-report-ema/telemetry-stacks.png?w=900 900w, /media/blog/otel-report-ema/telemetry-stacks.png?w=1040 1040w, /media/blog/otel-report-ema/telemetry-stacks.png?w=1240 1240w, /media/blog/otel-report-ema/telemetry-stacks.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;&#34;width=&#34;2952&#34;height=&#34;1580&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/otel-report-ema/telemetry-stacks.png&#34;&#xA;alt=&#34;&#34;width=&#34;2952&#34;height=&#34;1580&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;While the composable nature of microservices apps offers significant advantages in terms of agility and modularity, it also introduces considerable complexity in managing disconnected telemetry data. As organizations deploy numerous microservices, each with its own independent technology stack and CI/CD pipelines, they encounter a deluge of heterogeneous telemetry data.&lt;/p&gt;&#xA;&lt;p&gt;Application telemetry, storage telemetry, and cloud and virtualization telemetry—along with inputs from user interactions, IoT devices, message queues, databases, and various system and network telemetry sources—create a fragmented observability landscape. This fragmentation can drown organizations in data silos, making it difficult to achieve a unified view of system performance and health.&lt;/p&gt;&#xA;&lt;p&gt;The lack of integration between these disparate telemetry sources can lead to blind spots, inefficient troubleshooting, and increased operational overhead as teams struggle to correlate data across different services and infrastructure components. Consequently, the significant challenges in managing and making sense of the distributed telemetry data can undermine the promised benefits of microservices.&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-importance-of-opentelemetry&#34;&gt;The importance of OpenTelemetry&lt;/h2&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1476px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png&#34;data-srcset=&#34;/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=320 320w, /media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=550 550w, /media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=750 750w, /media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=900 900w, /media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=1040 1040w, /media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=1240 1240w, /media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;&#34;width=&#34;1476&#34;height=&#34;1548&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png&#34;&#xA;alt=&#34;&#34;width=&#34;1476&#34;height=&#34;1548&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;Organizations need unified observability that spans their entire technology stack. One way to achieve this is to standardize on a single observability tool, but that can create a significant vendor lock-in issue, complicating future tool changes. &lt;a href=&#34;/opentelemetry-report/&#34;&gt;OpenTelemetry&lt;/a&gt; offers a standardized, vendor-neutral method for instrumenting applications and their infrastructure components to generate consistent, contextual, and application-centric telemetry data. This eliminates the vendor lock-in problem, enabling organizations to significantly reduce migration costs if they decide to switch tools in the future.&lt;/p&gt;&#xA;&lt;p&gt;Of course, standardizing on a single tool sounds good in theory. But in practice, organizations often use a variety of additional observability tools and platforms, such as Prometheus, Jaeger, Zabbix, Fluentd, Elasticsearch, Nagios, OpenSearch, Zipkin, Skywalking, and Logstash. This diversity can lead to data silos and inconsistent telemetry data pipelines, which are often managed by different teams within the organization.&lt;/p&gt;&#xA;&lt;p&gt;Absorbing these silos into OpenTelemetry is generally possible and highly beneficial. With its vendor-neutral standard and support for a wide range of languages, OpenTelemetry can streamline telemetry data collection, improve data consistency, and enhance the overall observability strategy.&lt;/p&gt;&#xA;&lt;p&gt;Nevertheless, most organizations face significant challenges in doing so. The primary obstacles include the lack of necessary skills and resources to integrate these disparate systems quickly and reliably, as well as the high costs associated with such an undertaking.&lt;/p&gt;&#xA;&lt;p&gt;To address these challenges, organizations need to invest in training their teams in OpenTelemetry and related technologies. Additionally, adopting a phased approach to integration can help manage costs and minimize disruptions. Leveraging professional services or consulting firms with expertise in OpenTelemetry can also expedite the process and ensure a smoother transition.&lt;/p&gt;&#xA;&lt;h2 id=&#34;accelerate-opentelemetry-implementation-through-loki-mimir-tempo-beyla-pyroscope-and-alloy&#34;&gt;Accelerate OpenTelemetry implementation through Loki, Mimir, Tempo, Beyla, Pyroscope, and Alloy&lt;/h2&gt;&#xA;&lt;p&gt;Grafana&amp;rsquo;s suite of open source observability tools—Loki, Pyroscope, Mimir, Tempo, Alloy, and Beyla—complements OpenTelemetry (OTel) by providing a seamless integration that simplifies and enhances the adoption of standardized telemetry data.&lt;/p&gt;&#xA;&lt;p&gt;OpenTelemetry offers a framework for generating consistent, contextualized telemetry data across the various components of an organization&amp;rsquo;s technology stack. However, the challenge lies in effectively collecting, storing, and visualizing this data. Grafana’s tools address these challenges head-on, ensuring that organizations can fully leverage OpenTelemetry without the associated complexities and costs.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/oss/loki/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Loki&lt;/a&gt;, for instance, complements OpenTelemetry by providing a scalable and efficient log aggregation system that can ingest and query logs that OTel-instrumented applications generate.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/oss/mimir/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Mimir&lt;/a&gt; enhances this by handling the vast volumes of metrics data, ensuring they are efficiently stored and readily available for analysis.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/oss/tempo/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Tempo&lt;/a&gt;, with its distributed tracing capabilities integrate seamlessly with OpenTelemetry traces, allowing for a unified view of request flows across microservices.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/oss/pyroscope/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Pyroscope&lt;/a&gt; adds continuous profiling, giving detailed performance insights that are contextualized with OTel’s telemetry data.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/oss/beyla-ebpf/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Beyla&lt;/a&gt; provides eBPF-based auto-instrumentation to ensure that all telemetry data—logs, metrics, traces, or profiles—can be visualized and acted upon in real time within Grafana’s unified dashboards.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;While OTel has surged in popularity, especially after its &lt;a href=&#34;https://www.cncf.io/blog/2023/11/07/opentelemetry-at-kubecon-cloudnativecon-north-america-2023-update/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;GA announcement at KubeCon&lt;/a&gt; last year, Prometheus remains the leader in core infrastructure monitoring with over 10,000 integrations. Grafana’s newest OSS project, &lt;a href=&#34;/oss/alloy-opentelemetry-collector/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Alloy&lt;/a&gt;, is the successor to Grafana Agent, integrating its observability codebase and lessons from challenging use cases to create an efficient OTel Collector distribution that also handles Prometheus-compatible metrics. Alloy supports advanced use cases with features like GitOps-friendly configuration, native clustering, secure Vault integration, and embedded debugging utilities.&lt;/p&gt;&#xA;&lt;p&gt;Together, these tools transform OpenTelemetry’s rich telemetry data into actionable insights, providing a cohesive and comprehensive observability strategy. Organizations can benefit from OpenTelemetry’s standardized data collection while leveraging Grafana’s powerful analytics and visualization capabilities, resulting in a more efficient, reliable, and cost-effective observability solution. This synergy ensures that teams can easily correlate and analyze diverse telemetry data, leading to enhanced operational efficiency and improved system performance.&lt;/p&gt;&#xA;&lt;h2 id=&#34;one-dashboard-to-rule-them-all&#34;&gt;One dashboard to rule them all&lt;/h2&gt;&#xA;&lt;p&gt;Grafana&amp;rsquo;s integration with OpenTelemetry truly brings to life the concept of a single, unified dashboard for comprehensive observability. By combining the power of OpenTelemetry’s standardized telemetry data and semantic conventions with Grafana’s robust suite of tools—Loki, Pyroscope, Mimir, Tempo, Beyla, and Alloy—organizations can achieve unparalleled visibility into their systems. This unified approach eliminates the data silos and inconsistencies that typically plague observability efforts, enabling teams to quickly and efficiently correlate logs, metrics, traces, and profiles.&lt;/p&gt;&#xA;&lt;p&gt;With Grafana’s intuitive interface and powerful visualization capabilities, all relevant telemetry data is accessible in one place, simplifying analysis and accelerating troubleshooting. This one dashboard to rule them all not only reduces the complexity and cost associated with adopting OpenTelemetry, but also empowers organizations to proactively manage and optimize their IT infrastructure. The result is a more resilient, efficient, and high-performing technology stack that provides a significant competitive advantage in today’s fast-paced digital landscape.&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;To learn more about OpenTelemetry, check out the complete &lt;a href=&#34;/opentelemetry-report/&#34;&gt;OpenTelemetry: Challenges, priorities, adoption patterns, and solutions report&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;】&lt;p&gt;&lt;em&gt;Ken 作为著名的信息和网络安全从业者、软件开发人员、作者和演讲者，拥有超过 15 年的行业经验，专注于端点安全、大安全数据分析以及联邦信息安全管理法案 (FISMA) 和NIST 800-53 合规性。 Ken 专注于严格的联邦标准，咨询了众多联邦组织，包括国防信息系统局 (DISA)、退伍军人事务部和人口普查局。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;当今的企业可以通过使开发人员能够利用现有的微服务和 Kubernetes 快速构建新的应用程序功能来获得竞争优势。&lt;/p&gt;&#xA;&lt;p&gt;例如，通过利用可重用微服务库，金融机构可以快速开发和部署新功能，例如实时欺诈检测或个性化客户洞察，而无需从头开始构建这些功能。这种模块化方法不仅加快了开发周期，还确保了更大的灵活性和可扩展性。&lt;/p&gt;&#xA;&lt;p&gt;此外，当零售公司集成用于库存管理、付款处理和客户通知的微服务时，它可以快速适应市场变化和季节性需求，从而提高响应速度和客户满意度。这种通过微服务组合快速高效地创新的能力正在改变企业在数字时代竞争和取得成功的方式。&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-dark-side-of-composable-applications&#34;&gt;可组合应用程序的阴暗面&lt;/h2&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：2952px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/otel-report-ema/telemetry-stacks.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/otel-report-ema/telemetry-stacks.png”data-srcset =“/media/blog/otel-report-ema/telemetry-stacks.png？w = 320 320w，/媒体/博客/otel-report-ema/telemetry-stacks.png?w=550 550w, /media/blog/otel-report-ema/telemetry-stacks.png?w=750 750w, /media/blog/otel-report-ema/telemetry-stacks.png?w=900 900w, /media/blog/otel -report-ema/telemetry-stacks.png?w=1040 1040w, /media/blog/otel-report-ema/telemetry-stacks.png?w=1240 1240w，/media/blog/otel-report-ema/telemetry-stacks.png?w=1920 1920w&#34;&#xA;数据大小=“自动” alt =“”宽度=“2952”高度=“1580”/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/otel-report-ema/telemetry-stacks.png”&#xA;alt=“”宽度=“2952”高度=“1580”/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;虽然微服务应用程序的可组合性在敏捷性和模块化方面提供了显着的优势，但它在管理断开连接的遥测数据方面也带来了相当大的复杂性。随着组织部署大量微服务，每个微服务都有自己独立的技术堆栈和 CI/CD 管道，他们会遇到大量异构遥测数据。&lt;/p&gt;&#xA;&lt;p&gt;应用遥测、存储遥测以及云和虚拟化遥测，以及来自用户交互、物联网设备、消息队列、数据库以及各种系统和网络遥测源的输入，创建了一个碎片化的可观察性环境。这种碎片化会使组织陷入数据孤岛，从而难以实现系统性能和运行状况的统一视图。&lt;/p&gt;&#xA;&lt;p&gt;当团队努力关联不同服务和基础设施组件之间的数据时，这些不同的遥测源之间缺乏集成可能会导致盲点、故障排除效率低下以及运营开销增加。因此，管理和理解分布式遥测数据所面临的重大挑战可能会破坏微服务所承诺的优势。&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-importance-of-opentelemetry&#34;&gt;OpenTelemetry 的重要性&lt;/h2&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1476px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png&#34;data-srcset=&#34;/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png png?w=320 320w，/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=550 550w，/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=750 750w，/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w =900 900w， /media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=1040 1040w, /media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=1240 1240瓦， /media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png?w=1920 1920w&#34;&#xA;数据大小=“自动” alt =“”宽度=“1476”高度=“1548”/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/otel-report-ema/distributed-kubernetes-app-workflow.png”&#xA;alt=“”宽度=“1476”高度=“1548”/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;组织需要跨越整个技术堆栈的统一可观察性。实现这一目标的一种方法是对单一可观察性工具进行标准化，但这可能会造成严重的供应商锁定问题，使未来的工具变更变得复杂。 &lt;a href=&#34;/opentelemetry-report/&#34;&gt;OpenTelemetry&lt;/a&gt; 提供了一种标准化的、供应商中立的方法，用于检测应用程序及其基础设施组件，以生成一致的、上下文相关的、以应用程序为中心的遥测数据。这消除了供应商锁定问题，使组织能够在决定将来更换工具时显着降低迁移成本。&lt;/p&gt;&#xA;&lt;p&gt;当然，从理论上讲，对单一工具进行标准化听起来不错。但在实践中，组织经常使用各种额外的可观察性工具和平台，例如 Prometheus、Jaeger、Zabbix、Fluentd、Elasticsearch、Nagios、OpenSearch、Zipkin、Skywalking 和 Logstash。这种多样性可能会导致数据孤岛和不一致的遥测数据管道，而这些数据管道通常由组织内的不同团队管理。&lt;/p&gt;&#xA;&lt;p&gt;将这些孤岛吸收到 OpenTelemetry 中通常是可能的并且非常有益。凭借其供应商中立的标准和对多种语言的支持，OpenTelemetry 可以简化遥测数据收集、提高数据一致性并增强整体可观测性策略。&lt;/p&gt;&#xA;&lt;p&gt;尽管如此，大多数组织在这样做时都面临着重大挑战。主要障碍包括缺乏必要的技能和资源来快速可靠地集成这些不同的系统，以及与此类任务相关的高成本。&lt;/p&gt;&#xA;&lt;p&gt;为了应对这些挑战，组织需要投资对其团队进行 OpenTelemetry 和相关技术的培训。此外，采用分阶段的集成方法可以帮助管理成本并最大限度地减少中断。利用具有 OpenTelemetry 专业知识的专业服务或咨询公司也可以加快这一过程并确保更顺利的过渡。&lt;/p&gt;&#xA;&lt;h2 id=&#34;accelerate-opentelemetry-implementation-through-loki-mimir-tempo-beyla-pyrscope-and-alloy&#34;&gt;通过 Loki、Mimir、Tempo、Beyla、Pyrscope 和 Alloy 加速 OpenTelemetry 实施&lt;/h2&gt;&#xA;&lt;p&gt;Grafana 的开源可观测工具套件（Loki、Pyrscope、Mimir、Tempo、Alloy 和 Beyla）通过提供无缝集成来补充 OpenTelemetry (OTel)，从而简化和增强标准化遥测数据的采用。&lt;/p&gt;&#xA;&lt;p&gt;OpenTelemetry 提供了一个框架，用于跨组织技术堆栈的各个组件生成一致的、上下文化的遥测数据。然而，挑战在于如何有效地收集、存储和可视化这些数据。 Grafana 的工具正面解决了这些挑战，确保组织可以充分利用 OpenTelemetry，而无需承担相关的复杂性和成本。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;例如，&lt;li&gt;&lt;a href=&#34;/oss/loki/?pg=blog&amp;plcmt=body-txt&#34;&gt;Loki&lt;/a&gt; 通过提供可扩展且高效的日志聚合系统来补充 OpenTelemetry，该系统可以提取和查询以下日志：生成 OTel 检测的应用程序。&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/oss/mimir/?pg=blog&amp;plcmt=body-txt&#34;&gt;Mimir&lt;/a&gt; 通过处理大量指标数据来增强这一功能，确保它们得到有效存储并随时可供分析。 &lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/oss/tempo/?pg=blog&amp;plcmt=body-txt&#34;&gt;Tempo&lt;/a&gt; 其分布式跟踪功能与 OpenTelemetry 跟踪无缝集成，可提供跨微服务的请求流的统一视图.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/oss/pyrscope/?pg=blog&amp;plcmt=body-txt&#34;&gt;Pyrscope&lt;/a&gt; 添加了持续分析功能，提供与 OTel 遥测数据相关的详细性能洞察。&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/oss/beyla-ebpf/?pg=blog&amp;plcmt=body-txt&#34;&gt;Beyla&lt;/a&gt;提供基于eBPF的自动仪器确保所有遥测数据（日志、指标、跟踪或配置文件）都可以在 Grafana 的统一仪表板中实时可视化并采取行动。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;虽然 OTel 的受欢迎程度激增，尤其是在 &lt;a href=&#34;https://www.cncf.io/blog/2023/11/07/opentelemetry-at-kubecon-cloudnativecon-north-america-2023- update/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;去年 KubeCon&lt;/a&gt; 上发布的 GA 公告显示，Prometheus 仍然是核心基础设施监控领域的领导者，拥有超过10,000 次集成。 Grafana 最新的 OSS 项目 &lt;a href=&#34;/oss/alloy-opentelemetry-collector/?pg=blog&amp;plcmt=body-txt&#34;&gt;Alloy&lt;/a&gt; 是 Grafana Agent 的继承者，集成了其可观测性代码库和挑战中的经验教训使用案例创建高效的 OTel Collector 发行版，该发行版还可以处理 Prometheus 兼容的指标。 Alloy 通过 GitOps 友好配置、本机集群、安全 Vault 集成和嵌入式调试实用程序等功能支持高级用例。&lt;/p&gt;&#xA;&lt;p&gt;这些工具共同将 OpenTelemetry 丰富的遥测数据转化为可操作的见解，提供了连贯且全面的可观测性策略。组织可以受益于 OpenTelemetry 的标准化数据收集，同时利用 Grafana 强大的分析和可视化功能，从而形成更高效、可靠且更具成本效益的可观测性解决方案。这种协同作用确保团队可以轻松关联和分析不同的遥测数据，从而提高运营效率和系统性能。&lt;/p&gt;&#xA;&lt;h2 id=&#34;one-dashboard-to-rule-them-all&#34;&gt;一个仪表板即可统治所有内容&lt;/h2&gt;&#xA;&lt;p&gt;Grafana 与 OpenTelemetry 的集成真正实现了单一、统一仪表板的概念，以实现全面的可观察性。通过将 OpenTelemetry 标准化遥测数据和语义约定的强大功能与 Grafana 强大的工具套件（Loki、Pyrscope、Mimir、Tempo、Beyla 和 Alloy）相结合，组织可以实现对其系统的无与伦比的可见性。这种统一的方法消除了通常困扰可观察性工作的数据孤岛和不一致性，使团队能够快速有效地关联日志、指标、跟踪和配置文件。&lt;/p&gt;&#xA;&lt;p&gt;借助 Grafana 直观的界面和强大的可视化功能，可以在一处访问所有相关遥测数据，从而简化分析并加速故障排除。这一控制所有这些的仪表板不仅降低了与采用 OpenTelemetry 相关的复杂性和成本，而且使组织能够主动管理和优化其 IT 基础设施。其结果是一个更具弹性、高效和高性能的技术堆栈，在当今快节奏的数字环境中提供了显着的竞争优势。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;要了解有关 OpenTelemetry 的更多信息，请查看完整的 &lt;a href=&#34;/opentelemetry-report/&#34;&gt;OpenTelemetry：挑战、优先事项、采用模式和解决方案报告&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;</description>
      <pubDate>Fri, 22 Nov 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【How to use OpenTelemetry and Grafana Alloy to convert delta to cumulative at scale】如何使用 OpenTelemetry 和 Grafana Alloy 将增量转换为大规模累积值</title>
      <link>https://grafana.com/blog/2024/11/25/how-to-use-opentelemetry-and-grafana-alloy-to-convert-delta-to-cumulative-at-scale/</link>
      <description>【&lt;p&gt;Migrating from other vendors becomes a lot easier with &lt;a href=&#34;/oss/opentelemetry?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;OpenTelemetry&lt;/a&gt; and&#xA;&lt;a href=&#34;/docs/alloy/latest/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Alloy&lt;/a&gt;, our distribution of the&#xA;OpenTelemetry Collector.&lt;/p&gt;&#xA;&lt;p&gt;But when you come from platforms that use different temporalities, such as&#xA;&lt;a href=&#34;/blog/2024/06/18/translate-datadog-metrics-into-otlp-with-the-opentelemetry-collector-and-grafana-alloy/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Datadog&lt;/a&gt;&#xA;or Dynatrace, you face a challenge integrating with a Prometheus-like ecosystem such as&#xA;Grafana Cloud: Your metrics still mean the same as before, but they just don&amp;rsquo;t&#xA;look right.&lt;/p&gt;&#xA;&lt;p&gt;That&amp;rsquo;s because delta samples, which are used in other some non-Prometheus-based&#xA;observability tools, report a relative change to a measurement, such as +3, -7,&#xA;etc.&lt;/p&gt;&#xA;&lt;p&gt;Conversely, cumulative sampling, which is used in Prometheus, represents the&#xA;exact same information, but it does so as an &amp;ldquo;absolute&amp;rdquo; value in relation to an&#xA;arbitrary aggregation period, giving samples like 10, 4.&lt;/p&gt;&#xA;&lt;p&gt;Consider the following example time series (or stream, in OTel language):&lt;/p&gt;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;th&gt;Time&lt;/th&gt;&#xA;&lt;th&gt;10&lt;/th&gt;&#xA;&lt;th&gt;20&lt;/th&gt;&#xA;&lt;th&gt;30&lt;/th&gt;&#xA;&lt;th&gt;40&lt;/th&gt;&#xA;&lt;th&gt;50&lt;/th&gt;&#xA;&lt;th&gt;60&lt;/th&gt;&#xA;&lt;th&gt;70&lt;/th&gt;&#xA;&lt;th&gt;80&lt;/th&gt;&#xA;&lt;th&gt;90&lt;/th&gt;&#xA;&lt;th&gt;100&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Cumulative&lt;/td&gt;&#xA;&lt;td&gt;12&lt;/td&gt;&#xA;&lt;td&gt;14&lt;/td&gt;&#xA;&lt;td&gt;14&lt;/td&gt;&#xA;&lt;td&gt;17&lt;/td&gt;&#xA;&lt;td&gt;10&lt;/td&gt;&#xA;&lt;td&gt;4&lt;/td&gt;&#xA;&lt;td&gt;13&lt;/td&gt;&#xA;&lt;td&gt;18&lt;/td&gt;&#xA;&lt;td&gt;22&lt;/td&gt;&#xA;&lt;td&gt;24&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Delta&lt;/td&gt;&#xA;&lt;td&gt;+12&lt;/td&gt;&#xA;&lt;td&gt;+2&lt;/td&gt;&#xA;&lt;td&gt;+0&lt;/td&gt;&#xA;&lt;td&gt;+3&lt;/td&gt;&#xA;&lt;td&gt;-7&lt;/td&gt;&#xA;&lt;td&gt;-6&lt;/td&gt;&#xA;&lt;td&gt;+9&lt;/td&gt;&#xA;&lt;td&gt;+5&lt;/td&gt;&#xA;&lt;td&gt;+4&lt;/td&gt;&#xA;&lt;td&gt;+2&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;We covered this topic on the Grafana Labs blog &lt;a href=&#34;/blog/2023/09/26/opentelemetry-metrics-a-guide-to-delta-vs.-cumulative-temporality-trade-offs/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;in more detail&#xA;before&lt;/a&gt;,&#xA;and I also spoke about it during OTel Community Day 2024:&lt;/p&gt;&#xA;&lt;div&#xA;class=&#34;youtube-lazyload responsive-video&#34;&#xA;data-embed=&#34;hmm39H2Tfew&#34;&#xA;data-url=&#34;https://www.youtube.com/embed/hmm39H2Tfew?autoplay=1&amp;amp;rel=0&#34;&#xA;data-title=&#34;YouTube Video&#34;&#xA;&gt;&#xA;&lt;div class=&#34;play-button&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;Luckily, Alloy (and the &lt;a href=&#34;https://opentelemetry.io/docs/collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;OpenTelemetry&#xA;Collector&lt;/a&gt;) &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/pull/34747&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;recently&#xA;got&lt;/a&gt;&#xA;a whole lot better at handling this scenario!&lt;/p&gt;&#xA;&lt;p&gt;That&amp;rsquo;s because the team at Grafana Labs&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/issues/30705&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;contributed&lt;/a&gt;&#xA;the&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/deltatocumulativeprocessor&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;deltatocumulative&lt;/code&gt;&lt;/a&gt;&#xA;processor upstream, adding the missing piece to send delta samples to cumulative&#xA;backends such as Prometheus or Grafana Cloud.&lt;/p&gt;&#xA;&lt;h2 id=&#34;converting-delta-metrics&#34;&gt;Converting delta metrics&lt;/h2&gt;&#xA;&lt;p&gt;The underlying math to convert a stream of delta samples to their cumulative&#xA;equivalent is not overly complex.&lt;/p&gt;&#xA;&lt;p&gt;Consider the following simplified algorithm:&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/delta-to-cumulative/diagram-1.svg&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/delta-to-cumulative/diagram-1.svg&#34;alt=&#34;Delta to cumulative diagram&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/delta-to-cumulative/diagram-1.svg&#34;&#xA;alt=&#34;Delta to cumulative diagram&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;When processing a metrics write request, it iterates the sample list. For each&#xA;delta increase or decrease it adds that amount to the last value of that stream&#xA;(or zero if this is the first sample ever seen).&lt;/p&gt;&#xA;&lt;p&gt;The result is now a proper cumulative sample, because it&amp;rsquo;s accumulated (added&#xA;up) over time. Those values are stored in the processor for the next aggregation&#xA;and also passed onto the next consumer in the metrics pipeline.&lt;/p&gt;&#xA;&lt;p&gt;(There is a little more timestamp and edge-case handling involved to do this&#xA;properly all the time, but this captures the basic idea.)&lt;/p&gt;&#xA;&lt;h3 id=&#34;the-role-of-statefulness&#34;&gt;The role of statefulness&lt;/h3&gt;&#xA;&lt;p&gt;Unfortunately, however, the above operation comes with a big caveat: It&amp;rsquo;s&#xA;&lt;strong&gt;stateful&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;p&gt;See the &lt;em&gt;Processor state&lt;/em&gt; the algorithm keeps interacting with? This state is&#xA;what the collector has to keep in memory. And because this must be done&#xA;per-series specifically, &lt;strong&gt;every sample&lt;/strong&gt; of a certain time series must always&#xA;be sent to &lt;strong&gt;the exact same collector&lt;/strong&gt; instance as the last sample was.&lt;/p&gt;&#xA;&lt;p&gt;Not exactly scaling-friendly, right?&lt;/p&gt;&#xA;&lt;h2 id=&#34;incorporating-load-balancing&#34;&gt;Incorporating load balancing&lt;/h2&gt;&#xA;&lt;p&gt;Luckily, there is another component for this exact kind of requirement: The&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/loadbalancingexporter&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;loadbalancing&lt;/code&gt;&lt;/a&gt;&#xA;exporter.&lt;/p&gt;&#xA;&lt;p&gt;It recently gained support for&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/pull/34086&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;streamID&lt;/code&gt;&lt;/a&gt;-based&#xA;routing, which does exactly what we need: it always sends samples of the same&#xA;time series to a fixed collector endpoint.&lt;/p&gt;&#xA;&lt;p&gt;To leverage that, we setup a two-layer collector deployment:&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/delta-to-cumulative/load-balancer-alloy.svg&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/delta-to-cumulative/load-balancer-alloy.svg&#34;alt=&#34;Load balancer diagram&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/delta-to-cumulative/load-balancer-alloy.svg&#34;&#xA;alt=&#34;Load balancer diagram&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;For brevity, the following sections only include the most important parts. You&#xA;can find the full configuration on&#xA;&lt;a href=&#34;https://github.com/sh0rez/deltatocumulative-scaling&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;GitHub&lt;/a&gt;:&lt;/em&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;a class=&#34;btn btn--primary&#34; href=&#34;https://github.com/sh0rez/deltatocumulative-scaling&#34; style=&#34;display: flex; align-items: center; gap: .5em&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&#xA;&lt;span style=&#34;font-size: 1.5em&#34; class=&#34;fa fa-github&#34;&gt;&lt;/span&gt; sh0rez/deltatocumulative-scaling&#xA;&lt;/a&gt;&#xA;&lt;h3 id=&#34;using-containers&#34;&gt;Using containers&lt;/h3&gt;&#xA;&lt;p&gt;I&amp;rsquo;m using &lt;a href=&#34;https://docs.docker.com/compose&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Docker Compose&lt;/a&gt; to create the&#xA;containers in our deployment above, but this can be done using any system,&#xA;including Kubernetes:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;services:&#xA;# application generating delta metrics, writes to router using OTLP&#xA;app:&#xA;build: ./deltagen&#xA;environment:&#xA;OTEL_EXPORTER_OTLP_ENDPOINT: http://router:4318&#xA;OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: delta&#xA;scale: 4&#xA;# stateless collector, routing incoming metrics to workers based on stream-id&#xA;router:&#xA;image: otel/opentelemetry-collector-contrib:0.112.0&#xA;volumes:&#xA;- ./loadbal.yml:/etc/otelcol-contrib/config.yaml&#xA;scale: 1&#xA;# stateful collector, converting from delta to cumulative and remote_writing to prometheus&#xA;worker:&#xA;image: otel/opentelemetry-collector-contrib:0.112.0&#xA;volumes:&#xA;- ./worker.yml:/etc/otelcol-contrib/config.yaml&#xA;scale: 2&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;This gives us several instances of an app that generates metrics, a single&#xA;load-balancer, and two workers.&lt;/p&gt;&#xA;&lt;p&gt;Docker Compose also automatically sets up the Docker DNS server, such that&#xA;&lt;code&gt;nslookup router&lt;/code&gt; returns the IPs of both instances.&lt;/p&gt;&#xA;&lt;h3 id=&#34;configuration-load-balancer&#34;&gt;Configuration: load balancer&lt;/h3&gt;&#xA;&lt;p&gt;Our application sends metrics using OTLP, but any other receiver works:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;receivers:&#xA;otlp:&#xA;protocols:&#xA;http:&#xA;endpoint: 0.0.0.0:4318&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;Next, the &lt;code&gt;loadbalancing&lt;/code&gt; exporter is configured to do sticky routing on a&#xA;per-series basis:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;exporters:&#xA;loadbalancing:&#xA;routing_key: streamID # load-balance on a per-stream basis&#xA;resolver:&#xA;dns:&#xA;hostname: worker # send to a stable worker of the pool&#xA;protocol:&#xA;otlp:&#xA;tls:&#xA;insecure: true # for testing, properly configure TLS in production&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;This uses the &lt;code&gt;dns&lt;/code&gt; resolver, which discovers worker instances by doing a DNS A&#xA;lookup on the hostname &lt;code&gt;worker&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Docker Compose configures the built-in Docker DNS server so that it always&#xA;returns all instance IPs when querying for the service name. The same can be&#xA;achieved in Kubernetes by using a &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#headless-services&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;headless&#xA;Service&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h3 id=&#34;configuration-worker&#34;&gt;Configuration: worker&lt;/h3&gt;&#xA;&lt;p&gt;The workers receive samples from a router in OTLP gRPC, convert them to&#xA;cumulative, and forward them to some backend supported by the collector (e.g.,&#xA;Grafana Cloud).&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;receivers:&#xA;otlp:&#xA;protocols:&#xA;grpc:&#xA;endpoint: 0.0.0.0:4317&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;deltatocumulative&lt;/code&gt; processor works out-of-the-box. See &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/deltatocumulativeprocessor#configuration&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;its&#xA;documentation&lt;/a&gt;&#xA;for additional configuration options.&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;processors:&#xA;deltatocumulative: {}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;Once converted to cumulative, the samples can be used with any exporter that&#xA;supports the cumulative temporality, such as the&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/prometheusremotewriteexporter&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;prometheusremotewrite&lt;/code&gt;&lt;/a&gt;&#xA;exporter.&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;exporters:&#xA;prometheusremotewrite:&#xA;endpoint: http://prometheus:9090/api/v1/write&#xA;resource_to_telemetry_conversion:&#xA;enabled: true&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h2 id=&#34;running-the-processor&#34;&gt;Running the processor&lt;/h2&gt;&#xA;&lt;p&gt;Once started, we can clearly see the even distribution of data points across the&#xA;different workers, using the following query:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;promql&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-promql&#34;&gt;rate(otelcol_receiver_accepted_metric_points[1m])&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;In this example, the number of workers was scaled from two to three, then up to&#xA;five, then back to two.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1597px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/delta-to-cumulative/otlp.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/delta-to-cumulative/otlp.png&#34;data-srcset=&#34;/media/blog/delta-to-cumulative/otlp.png?w=320 320w, /media/blog/delta-to-cumulative/otlp.png?w=550 550w, /media/blog/delta-to-cumulative/otlp.png?w=750 750w, /media/blog/delta-to-cumulative/otlp.png?w=900 900w, /media/blog/delta-to-cumulative/otlp.png?w=1040 1040w, /media/blog/delta-to-cumulative/otlp.png?w=1240 1240w, /media/blog/delta-to-cumulative/otlp.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;OTLP panel&#34;width=&#34;1597&#34;height=&#34;501&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/delta-to-cumulative/otlp.png&#34;&#xA;alt=&#34;OTLP panel&#34;width=&#34;1597&#34;height=&#34;501&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;The instances were DNS discovered as they came and went, with &lt;code&gt;loadbalancing&lt;/code&gt;&#xA;always evenly distributing load between them.&lt;/p&gt;&#xA;&lt;p&gt;The load-balancer (red line) was scaled from one to two and back.&lt;/p&gt;&#xA;&lt;p&gt;Looking at &lt;code&gt;deltatocumulative&lt;/code&gt;, we can see the streams tracked in memory. They&#xA;are dropped after five minutes without receiving new samples:&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1597px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/delta-to-cumulative/tracked-streams.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/delta-to-cumulative/tracked-streams.png&#34;data-srcset=&#34;/media/blog/delta-to-cumulative/tracked-streams.png?w=320 320w, /media/blog/delta-to-cumulative/tracked-streams.png?w=550 550w, /media/blog/delta-to-cumulative/tracked-streams.png?w=750 750w, /media/blog/delta-to-cumulative/tracked-streams.png?w=900 900w, /media/blog/delta-to-cumulative/tracked-streams.png?w=1040 1040w, /media/blog/delta-to-cumulative/tracked-streams.png?w=1240 1240w, /media/blog/delta-to-cumulative/tracked-streams.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Delta to cumulative panel&#34;width=&#34;1597&#34;height=&#34;501&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/delta-to-cumulative/tracked-streams.png&#34;&#xA;alt=&#34;Delta to cumulative panel&#34;width=&#34;1597&#34;height=&#34;501&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h2 id=&#34;looking-ahead&#34;&gt;Looking ahead&lt;/h2&gt;&#xA;&lt;p&gt;Most of this is early work, just released to the wider community.&lt;/p&gt;&#xA;&lt;p&gt;Any kind of testing and feedback is highly appreciated. Don&amp;rsquo;t hesitate to &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/issues/new/choose&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;file&#xA;issues&lt;/a&gt;,&#xA;engage on Slack (the Grafana community Slack and CNCF Slack both have&#xA;#opentelemetry channels) or even contribute PRs.&lt;/p&gt;&#xA;&lt;p&gt;Once mature, we will explore ways to reduce the operational complexity, such as&#xA;bringing this functionality directly into backends such as Prometheus&amp;rsquo; &lt;a href=&#34;https://github.com/prometheus/prometheus/pull/12571&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;OTLP&#xA;receiver&lt;/a&gt; or Grafana Cloud.&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud &lt;/a&gt;is the easiest way to get started with metrics, logs, traces, dashboards, and more. We have a generous forever-free tier and plans for every use case. &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Sign up for free now!&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;】&lt;p&gt;使用 &lt;a href=&#34;/oss/opentelemetry?pg=blog&amp;plcmt=body-txt&#34;&gt;OpenTelemetry&lt;/a&gt; 从其他供应商迁移变得更加容易&#xA;&lt;a href=&#34;/docs/alloy/latest/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Alloy&lt;/a&gt;，我们的发行版&#xA;打开遥测收集器。&lt;/p&gt;&#xA;&lt;p&gt;但是当您来自使用不同时间性的平台时，例如&#xA;&lt;a href=&#34;/blog/2024/06/18/translate-datadog-metrics-into-otlp-with-the-opentelemetry-collector-and-grafana-alloy/?pg=blog&amp;plcmt=body-txt&#34;&gt;Datadog&lt; /a&gt;&#xA;或 Dynatrace，您面临着与类似 Prometheus 的生态系统集成的挑战，例如&#xA;Grafana Cloud：您的指标仍然与以前相同，但它们只是不同&#xA;看右边。&lt;/p&gt;&#xA;&lt;p&gt;这是因为 delta 样本，在其他一些非 Prometheus 基础上使用&#xA;可观测性工具，报告测量的相对变化，例如+3、-7、&#xA;等等&lt;/p&gt;&#xA;&lt;p&gt;相反，Prometheus 中使用的累积采样表示&#xA;完全相同的信息，但它是作为相对于某个值的“绝对”值&#xA;任意聚合周期，给出 10、4 等样本。&lt;/p&gt;&#xA;&lt;p&gt;考虑以下示例时间序列（或 OTel 语言中的流）：&lt;/p&gt;&#xA;&lt;表&gt;&#xA;&lt;标题&gt;&#xA;&lt;tr&gt;&#xA;&lt;th&gt;时间&lt;/th&gt;&#xA;&lt;th&gt;10&lt;/th&gt;&#xA;&lt;th&gt;20&lt;/th&gt;&#xA;&lt;th&gt;30&lt;/th&gt;&#xA;&lt;th&gt;40&lt;/th&gt;&#xA;&lt;th&gt;50&lt;/th&gt;&#xA;&lt;th&gt;60&lt;/th&gt;&#xA;&lt;th&gt;70&lt;/th&gt;&#xA;&lt;th&gt;80&lt;/th&gt;&#xA;&lt;th&gt;90&lt;/th&gt;&#xA;&lt;th&gt;100&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/标题&gt;&#xA;&lt;正文&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;累计&lt;/td&gt;&#xA;&lt;td&gt;12&lt;/td&gt;&#xA;&lt;td&gt;14&lt;/td&gt;&#xA;&lt;td&gt;14&lt;/td&gt;&#xA;&lt;td&gt;17&lt;/td&gt;&#xA;&lt;td&gt;10&lt;/td&gt;&#xA;&lt;td&gt;4&lt;/td&gt;&#xA;&lt;td&gt;13&lt;/td&gt;&#xA;&lt;td&gt;18&lt;/td&gt;&#xA;&lt;td&gt;22&lt;/td&gt;&#xA;&lt;td&gt;24&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;达美航空&lt;/td&gt;&#xA;&lt;td&gt;+12&lt;/td&gt;&#xA;&lt;td&gt;+2&lt;/td&gt;&#xA;&lt;td&gt;+0&lt;/td&gt;&#xA;&lt;td&gt;+3&lt;/td&gt;&#xA;&lt;td&gt;-7&lt;/td&gt;&#xA;&lt;td&gt;-6&lt;/td&gt;&#xA;&lt;td&gt;+9&lt;/td&gt;&#xA;&lt;td&gt;+5&lt;/td&gt;&#xA;&lt;td&gt;+4&lt;/td&gt;&#xA;&lt;td&gt;+2&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/表&gt;&#xA;&lt;p&gt;我们在 Grafana Labs 博客&lt;a href=&#34;/blog/2023/09/26/opentelemetry-metrics-a-guide-to-delta-vs.-cumulative-temporality-trade-offs/? pg=blog&amp;plcmt=body-txt&#34;&gt;更详细&#xA;之前&lt;/a&gt;，&#xA;我还在 2024 年 OTel 社区日期间谈到了这一点：&lt;/p&gt;&#xA;&lt;div&#xA;类 =“youtube-lazyload 响应视频”&#xA;数据嵌入=“hmm39H2Tfew”&#xA;data-url=&#34;https://www.youtube.com/embed/hmm39H2Tfew?autoplay=1&amp;rel=0&#34;&#xA;数据标题=“YouTube 视频”&#xA;&gt;&#xA;&lt;div class=&#34;play-button&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;幸运的是，Alloy（以及 &lt;a href=&#34;https://opentelemetry.io/docs/collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;OpenTelemetry&#xA;收集器&lt;/a&gt;）&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/pull/34747&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;最近&#xA;得到&lt;/a&gt;&#xA;能够更好地处理这种情况！&lt;/p&gt;&#xA;&lt;p&gt;那是因为 Grafana Labs 的团队&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/issues/30705&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;贡献&lt;/a&gt;&#xA;这&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/deltatocumulativeprocessor&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;deltatocumulative&lt;/code &gt;&lt;/a&gt;&#xA;处理器上游，添加缺失的部分以将增量样本发送到累积&#xA;后端例如Prometheus 或 Grafana Cloud。&lt;/p&gt;&#xA;&lt;h2 id=&#34;converting-delta-metrics&#34;&gt;转换增量指标&lt;/h2&gt;&#xA;&lt;p&gt;将增量样本流转换为其累积值的基础数学&#xA;等价物并不太复杂。&lt;/p&gt;&#xA;&lt;p&gt;考虑以下简化算法：&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/delta-to-cumulative/diagram-1.svg&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/delta-to-cumulative/diagram-1.svg&#34;alt=&#34;Delta 到累积图&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/delta-to-cumulative/diagram-1.svg”&#xA;alt=&#34;累积图的增量&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;处理指标写入请求时，它会迭代示例列表。对于每个&#xA;增量增加或减少它将该金额添加到该流的最后一个值&#xA;（如果这是有史以来第一个样本，则为零）。&lt;/p&gt;&#xA;&lt;p&gt;结果现在是一个正确的累积样本，因为它是累积的（添加了&#xA;上）随着时间的推移。这些值存储在处理器中以供下一次聚合&#xA;并传递给指标管道中的下一个消费者。&lt;/p&gt;&#xA;&lt;p&gt;（执行此操作涉及更多时间戳和边缘情况处理&#xA;始终正确，但这抓住了基本思想。）&lt;/p&gt;&#xA;&lt;h3 id=&#34;the-role-of-stateativity&#34;&gt;有状态的作用&lt;/h3&gt;&#xA;&lt;p&gt;然而不幸的是，上述操作有一个很大的警告：&#xA;&lt;strong&gt;有状态&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;看到算法一直与之交互的&lt;em&gt;处理器状态&lt;/em&gt;吗？这个状态是&#xA;收藏家必须记住的东西。因为这必须要做&#xA;具体而言，特定时间序列的&lt;strong&gt;每个样本&lt;/strong&gt;必须始终&#xA;被发送到与上一个样本&lt;strong&gt;完全相同的收集器&lt;/strong&gt;实例。&lt;/p&gt;&#xA;&lt;p&gt;不完全适合扩展，对吧？&lt;/p&gt;&#xA;&lt;h2 id=&#34;incorporating-load-balancing&#34;&gt;合并负载平衡&lt;/h2&gt;&#xA;&lt;p&gt;幸运的是，还有另一个组件可以满足这种确切的要求：&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/loadbalancingexporter&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;负载均衡&lt;/code &gt;&lt;/a&gt;&#xA;出口商。&lt;/p&gt;&#xA;&lt;p&gt;它最近获得了支持&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/pull/34086&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;streamID&lt;/code&gt;&lt;/a &gt;基于&#xA;路由，它正是我们所需要的：它总是发送相同的样本&#xA;时间序列到固定收集器端点。&lt;/p&gt;&#xA;&lt;p&gt;为了利用这一点，我们设置了两层收集器部署：&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/delta-to-cumulative/load-balancer-alloy.svg&#34;&#xA;itemprop=“内容”网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/delta-to-cumulative/load-balancer-alloy.svg&#34;alt=&#34;负载均衡器图&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/delta-to-cumulative/load-balancer-alloy.svg”&#xA;alt=&#34;负载均衡器图&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;块引用&gt;&#xA;&lt;p&gt;&lt;em&gt;为简洁起见，以下部分仅包含最重要的部分。你&#xA;可以找到完整的配置&#xA;&lt;a href=&#34;https://github.com/sh0rez/deltatocumulative-scaling&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;GitHub&lt;/a&gt;：&lt;/em&gt;&lt;/p&gt;&#xA;&lt;/块引用&gt;&#xA;&lt;a class =“btn btn--primary”href =“https://github.com/sh0rez/deltatocumulative-scaling”style =“显示：flex;对齐项目：中心;间隙：.5em”target =“_blank” “ rel =“noopener noreferrer”&gt;&#xA;&lt;span style=&#34;font-size: 1.5em&#34; class=&#34;fa fa-github&#34;&gt;&lt;/span&gt; sh0rez/deltatocumulative-scaling&#xA;&lt;/a&gt;&#xA;&lt;h3 id=&#34;using-containers&#34;&gt;使用容器&lt;/h3&gt;&#xA;&lt;p&gt;我正在使用 &lt;a href=&#34;https://docs.docker.com/compose&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Docker Compose&lt;/a&gt; 来创建&#xA;我们上面部署中的容器，但这可以使用任何系统来完成，&#xA;包括 Kubernetes：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;服务：&#xA;# 应用程序生成增量指标，使用 OTLP 写入路由器&#xA;应用程序：&#xA;构建：./deltagen&#xA;环境：&#xA;OTEL_EXPORTER_OTLP_ENDPOINT：http://路由器:4318&#xA;OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE：增量&#xA;规模：4&#xA;# 无状态收集器，根据流 ID 将传入指标路由到工作人员&#xA;路由器：&#xA;图片：otel/opentelemetry-collector-contrib:0.112.0&#xA;卷：&#xA;- ./loadbal.yml:/etc/otelcol-contrib/config.yaml&#xA;规模：1&#xA;# 有状态收集器，从 delta 转换为cumulative，remote_writing 转换为 prometheus&#xA;工人：&#xA;图片：otel/opentelemetry-collector-contrib:0.112.0&#xA;卷：&#xA;- ./worker.yml:/etc/otelcol-contrib/config.yaml&#xA;规模：2&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;这为我们提供了生成指标的应用程序的多个实例，一个&#xA;负载均衡器和两个工作人员。&lt;/p&gt;&#xA;&lt;p&gt;Docker Compose 还会自动设置 Docker DNS 服务器，这样&#xA;&lt;code&gt;nslookup router&lt;/code&gt; 返回两个实例的 IP。&lt;/p&gt;&#xA;&lt;h3 id=&#34;configuration-load-balancer&#34;&gt;配置：负载均衡器&lt;/h3&gt;&#xA;&lt;p&gt;我们的应用程序使用 OTLP 发送指标，但任何其他接收器都可以工作：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;接收者：&#xA;奥特普：&#xA;协议：&#xA;http：&#xA;端点：0.0.0.0:4318&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;接下来，&lt;code&gt;loadbalancing&lt;/code&gt; 导出器配置为在&#xA;每个系列的基础：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;导出器：&#xA;负载平衡：&#xA;routing_key: streamID # 基于每个流的负载平衡&#xA;解析器：&#xA;域名：&#xA;hostname:worker # 发送到池中稳定的worker&#xA;协议：&#xA;奥特普：&#xA;:&#xA;insecure: true # 用于测试，在生产中正确配置 TLS&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;这使用 &lt;code&gt;dns&lt;/code&gt; 解析器，它通过执行 DNS A 来发现工作实例&#xA;查找主机名&lt;code&gt;worker&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;Docker Compose 配置内置 Docker DNS 服务器，使其始终&#xA;查询服务名称时返回所有实例IP。同样可以&#xA;通过使用 &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#headless-services&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;headless 在 Kubernetes 中实现&#xA;服务&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;configuration-worker&#34;&gt;配置：工作人员&lt;/h3&gt;&#xA;&lt;p&gt;工作人员从 OTLP gRPC 中的路由器接收样本，将其转换为&#xA;累积的，并将它们转发到收集器支持的某些后端（例如，&#xA;Grafana 云）。&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;接收者：&#xA;奥特普：&#xA;协议：&#xA;组组：&#xA;端点：0.0.0.0:4317&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;&lt;code&gt;deltatocumulative&lt;/code&gt; 处理器开箱即用。请参阅&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/deltatocumulativeprocessor#configuration&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;其&#xA;文档&lt;/a&gt;&#xA;更多配置选项。&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;复制()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;处理器：&#xA;增量累积：{}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;一旦转换为累积，样本就可以与任何出口商一起使用&#xA;支持累积时间性，例如&#xA;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/prometheusremotewriteexporter&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;prometheusremotewrite&lt;/code &gt;&lt;/a&gt;&#xA;出口商。&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;yaml&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;导出器：&#xA;普罗米修斯远程写入：&#xA;端点：http://prometheus:9090/api/v1/write&#xA;资源到遥测转换：&#xA;启用：true&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h2 id=&#34;running-the-processor&#34;&gt;运行处理器&lt;/h2&gt;&#xA;&lt;p&gt;一旦开始，我们可以清楚地看到数据点在整个区域的均匀分布&#xA;不同的工作人员，使用以下查询：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;promql&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-promql&#34;&gt;费率(otelcol_receiver_accepted_metric_points[1m])&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;在这个例子中，工人的数量从两个扩展到三个，然后增加到&#xA;五个，然后回到两个。&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1597px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/delta-to-cumulative/otlp.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/delta-to-cumulative/otlp.png”data-srcset =“/media/blog/delta-to-cumulative/otlp.png？w = 320 320w，/media/blog/增量到累积/otlp.png？w=550 550w，/media/blog/增量到累积/otlp.png？w=750 750w， /media/blog/delta-to-cumulative/otlp.png?w=900 900w, /media/blog/delta-to-cumulative/otlp.png?w=1040 1040w, /media/blog/delta-to-cumulative /otlp.png?w=1240 1240w, /media/blog/delta-to-cumulative/otlp.png?w=1920 1920w&#34;&#xA;data-size=&#34;auto&#34;alt=&#34;OTLP 面板&#34;width=&#34;1597&#34;height=&#34;501&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/delta-to-cumulative/otlp.png”&#xA;alt=&#34;OTLP 面板&#34;width=&#34;1597&#34;height=&#34;501&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;这些实例在它们来来往往时被 DNS 发现，并使用&lt;code&gt;负载平衡&lt;/code&gt;&#xA;始终在它们之间均匀分配负载。&lt;/p&gt;&#xA;&lt;p&gt;负载均衡器（红线）从 1 缩放到 2，然后再缩放回来。&lt;/p&gt;&#xA;&lt;p&gt;查看&lt;code&gt;deltatocumulative&lt;/code&gt;，我们可以看到内存中跟踪的流。他们&#xA;五分钟后没有收到新样本就被丢弃：&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1597px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/delta-to-cumulative/tracked-streams.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/delta-to-cumulative/tracked-streams.png”data-srcset =“/media/blog/delta-to-cumulative/tracked-streams.png？w = 320 320w，/媒体/博客/delta-to-cumulative/tracked-streams.png?w=550 550w, /media/blog/delta-to-cumulative/tracked-streams.png?w=750 750w, /media/blog/delta-to-cumulative/tracked-streams.png?w=900 900w, /media/blog/delta -to-cumulative/tracked-streams.png?w=1040 1040w, /media/blog/delta-to-cumulative/tracked-streams.png?w=1240 1240w, /media/blog/delta-to-cumulative/tracked-streams.png?w=1920 1920w&#34;&#xA;data-size=&#34;auto&#34;alt=&#34;累积面板的增量&#34;width=&#34;1597&#34;height=&#34;501&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/delta-to-cumulative/tracked-streams.png”&#xA;alt=&#34;累积面板的增量&#34;width=&#34;1597&#34;height=&#34;501&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h2 id=&#34;looking-ahead&#34;&gt;展望未来&lt;/h2&gt;&#xA;&lt;p&gt;其中大部分是早期工作，刚刚发布给更广泛的社区。&lt;/​​p&gt;&#xA;&lt;p&gt;任何类型的测试和反馈都受到高度赞赏。不要犹豫 &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/issues/new/choose&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;文件&#xA;问题&lt;/a&gt;，&#xA;参与 Slack（Grafana 社区 Slack 和 CNCF Slack 都有&#xA;#opentelemetry频道）甚至贡献PR。&lt;/p&gt;&#xA;&lt;p&gt;一旦成熟，我们将探索降低运营复杂度的方法，例如&#xA;将此功能直接引入后端，例如 Prometheus 的 &lt;a href=&#34;https://github.com/prometheus/prometheus/pull/12571&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;OTLP&#xA;接收器&lt;/a&gt;或Grafana Cloud。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt;是开始使用指标、日志、跟踪、仪表板等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。 &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;plcmt=body-txt&#34;&gt;立即免费注册！&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</description>
      <pubDate>Mon, 25 Nov 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Why companies choose Grafana Cloud over self-hosted OSS stacks】为什么公司选择 Grafana Cloud 而不是自托管 OSS 堆栈</title>
      <link>https://grafana.com/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/</link>
      <description>【&lt;p&gt;While we all love &lt;a href=&#34;/oss/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;open source technology&lt;/a&gt; and the &lt;a href=&#34;/blog/2023/12/12/the-story-of-grafana-documentary-the-community-behind-the-code/&#34;&gt;community&lt;/a&gt; that comes with it, we don’t always have the time or resources to stand up, maintain, update, and troubleshoot a self-hosted OSS stack.&lt;/p&gt;&#xA;&lt;p&gt;This is one of the (many) reasons companies choose to implement &lt;a href=&#34;/products/cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt;: you get all the goodness of the open source Grafana LGTM Stack (&lt;a href=&#34;/oss/loki/&#34;&gt;Loki&lt;/a&gt; for logs,&lt;a href=&#34;/oss/grafana?pg=blog&amp;amp;plcmt=body-txt&#34;&gt; Grafana&lt;/a&gt; for visualization,&lt;a href=&#34;/oss/tempo/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt; Tempo&lt;/a&gt; for traces,&lt;a href=&#34;/oss/mimir/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt; Mimir&lt;/a&gt; for metrics) in a fully managed, end-to-end observability platform.&lt;/p&gt;&#xA;&lt;p&gt;“With Grafana Cloud, there is very little to no maintenance,” said Omar Lopez, Head of Observability at SailPoint, during &lt;a href=&#34;/events/observabilitycon/2024/sailpoint-cost-efficiency-with-grafana-cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;a talk at ObservabilityCON 2024&lt;/a&gt;. “We let Grafana handle all the complexity that we were handling before, so we can spend that time on higher-priority initiatives.”&lt;/p&gt;&#xA;&lt;p&gt;Grafana Cloud also provides out-of-the-box, cutting-edge observability solutions like &lt;a href=&#34;/products/cloud/metrics/prometheus-cardinality-optimization/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Adaptive Metrics&lt;/a&gt;, a cardinality optimization feature that helps you identify and eliminate unused time series metrics to reduce overall observability costs.&lt;/p&gt;&#xA;&lt;p&gt;But why just take our word for it? In this post, observability practitioners share the top reasons they chose Grafana Cloud, most of which fall into three broad categories, and the benefits that ensued:&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;1. Reducing the burden of managing an observability stack&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks//#focus-more-on-apps-and-strategic-projects&#34;&gt;Focus more on apps and strategic projects&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#increase-security-for-customers&#34;&gt;Increase security for customers&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;2. Lowering observability costs&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#reduce-metrics-volume&#34;&gt;Reduce metrics volume&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#consolidate-tools&#34;&gt;Consolidate tools&lt;/a&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#reduce-metrics-volume&#34;&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;3. Supporting modern cloud architectures&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#optimize-hybrid-and-multi-cloud-deployments&#34;&gt;Optimize hybrid and multi-cloud deployments&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#enable-easier-migration-to-prometheus&#34;&gt;Enable easier migration to Prometheus&lt;/a&gt;&lt;a href=&#34;/blog/2023/10/16/why-companies-choose-grafana-cloud-over-self-managed-oss-stacks/#enable-easy-migration-to-prometheus&#34;&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;reducing-the-burden-of-managing-an-observability-stack&#34;&gt;Reducing the burden of managing an observability stack&lt;/h2&gt;&#xA;&lt;h3 id=&#34;focus-more-on-apps-and-strategic-projects&#34;&gt;Focus more on apps and strategic projects&lt;/h3&gt;&#xA;&lt;p&gt;The benefits of Grafana Cloud were almost instantaneous at The Trade Desk, a SaaS provider in the advertising and digital media space.&lt;/p&gt;&#xA;&lt;p&gt;“Query time immediately improved and many, many developers seemed to notice. Also, our reliability improved quite a bit,” said Patrick O’Brien, now a Senior Staff Software Engineer, SRE, at The Trade Desk. “We have zero storage nodes, which were the most expensive piece of that stack. Now we just have three nodes and everything feeds back to Grafana Labs.”&lt;/p&gt;&#xA;&lt;p&gt;In addition to saving the company money, the shift to Grafana Cloud spared the engineering department the headaches of troubleshooting. “Metrics usage frustration improved nearly overnight once we went with the hosted platform,” said Carl Johnson, now Senior Director, Production Engineering at The Trade Desk. “The reason we know it was a success is the complaints and frustrations internally stopped.&amp;quot;&lt;/p&gt;&#xA;&lt;p&gt;Added Johnson: “I think most of the ROI is really coming from time and labor savings. We can all say that what was once a time-sink was removed from our radar altogether.”&lt;/p&gt;&#xA;&lt;p&gt;Mux — a start-up that operates an API-first video platform designed to give development teams world-class video streaming and analytics capabilities — had a similar experience with Grafana Cloud.&lt;/p&gt;&#xA;&lt;p&gt;After struggling for years to maintain an in-house OSS stack (Elasticsearch, Kibana, Prometheus, Jaeger, Grafana) that left the team feeling too reactive and largely in maintenance mode, they knew it was time for a change. They also needed the ability to scale dynamically to accommodate unpredictable usage demands for compute-, network- and storage-intensive workloads.&lt;/p&gt;&#xA;&lt;p&gt;Ultimately, they turned to Grafana Cloud, in part because of their existing familiarity with Grafana OSS, but the payoff has been a lot more than an easy onramp.&lt;/p&gt;&#xA;&lt;p&gt;They’ve cut their metrics volume by 60% while also greatly expanding their data retention time, going from seven days to 30 days for traces and from 14 days to 13 months for metrics. This has helped Mux reduce noise, improve long-term analysis, and take a more proactive approach to incident management — all while keeping their costs level and their engineers engaged with more high-impact work.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1098px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link captioned&#34;&#xA;href=&#34;/media/blog/mux-success/ingest-job-logs.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload mb-0&#34;&#xA;data-src=&#34;/media/blog/mux-success/ingest-job-logs.png&#34;data-srcset=&#34;/media/blog/mux-success/ingest-job-logs.png?w=320 320w, /media/blog/mux-success/ingest-job-logs.png?w=550 550w, /media/blog/mux-success/ingest-job-logs.png?w=750 750w, /media/blog/mux-success/ingest-job-logs.png?w=900 900w, /media/blog/mux-success/ingest-job-logs.png?w=1040 1040w, /media/blog/mux-success/ingest-job-logs.png?w=1240 1240w, /media/blog/mux-success/ingest-job-logs.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A graph showing ingest job logs at Mux.&#34;width=&#34;1098&#34;height=&#34;665&#34;title=&#34;*A graph showing ingest job logs at Mux.*&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/mux-success/ingest-job-logs.png&#34;&#xA;alt=&#34;A graph showing ingest job logs at Mux.&#34;width=&#34;1098&#34;height=&#34;665&#34;title=&#34;*A graph showing ingest job logs at Mux.*&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;figcaption class=&#34;w-100p caption text-gray-13 &#34;&gt;&lt;em&gt;A graph showing ingest job logs at Mux.&lt;/em&gt;&lt;/figcaption&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;“Grafana Cloud probably saves us hundreds of engineering hours a year,” said Ryan Grothouse, VP, Engineering at Mux. “Our platform engineers don’t have to manage the stack any more, and our product engineers don’t have to work through multiple observability tools, which used to really slow down our response times.”&lt;/p&gt;&#xA;&lt;p&gt;Read more about how Grafana Cloud has saved engineering hours at both &lt;a href=&#34;/blog/2024/07/22/how-mux-cut-metrics-volume-by-60-increased-retention-times-and-improved-developer-productivity-with-grafana-cloud/&#34;&gt;Mux &lt;/a&gt;and &lt;a href=&#34;/success/thetradedesk/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;The Trade Desk&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h3 id=&#34;increase-security-for-customers&#34;&gt;Increase security for customers&lt;/h3&gt;&#xA;&lt;p&gt;Sometimes you just want more of a good thing. That’s the case at Royal IHC, which used Grafana OSS to create dashboards for their customers as part of integrated solutions that improve operational efficiency for maritime fleets around the world.&lt;/p&gt;&#xA;&lt;p&gt;Guus Derksen, a Royal IHC project leader, was so happy with the dashboards his team was able to create that he wanted to expand their offerings with Grafana Cloud Advanced, which provides built-in security and access features for their clients.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link captioned&#34;&#xA;href=&#34;/static/assets/img/blog/royal-ihc-dashboard.jpg?w=1240&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload mb-0&#34;&#xA;data-src=&#34;/static/assets/img/blog/royal-ihc-dashboard.jpg?w=1240&#34;alt=&#34;A Roya IHC dashboard showcasing key metrics.&#34;title=&#34;*A Royal IHC dashboard showcasing key metrics.*&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/static/assets/img/blog/royal-ihc-dashboard.jpg?w=1240&#34;&#xA;alt=&#34;A Roya IHC dashboard showcasing key metrics.&#34;title=&#34;*A Royal IHC dashboard showcasing key metrics.*&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;figcaption class=&#34;w-100p caption text-gray-13 &#34;&gt;&lt;em&gt;A Royal IHC dashboard showcasing key metrics.&lt;/em&gt;&lt;/figcaption&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;There are a lot more opportunities for growth and evolution at Royal IHC, which is possible because Grafana Cloud also maintains everything for their individual clients. “It was quite user-friendly,” said Derksen. “It definitely gave us the right direction to move in with the development we are going through in general.”&lt;/p&gt;&#xA;&lt;p&gt;Learn more about &lt;a href=&#34;/success/royal-ihc/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Royal IHC’s observability journey with Grafana Cloud Advanced&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;lowering-observability-costs&#34;&gt;Lowering observability costs&lt;/h2&gt;&#xA;&lt;h3 id=&#34;reduce-metrics-volume&#34;&gt;Reduce metrics volume&lt;/h3&gt;&#xA;&lt;p&gt;Despite initial success with Prometheus and Grafana, SailPoint — a leader in identity management solutions — reached limits with scaling, leading to performance challenges and rising maintenance costs. After evaluating options through their internal DACI decision-making framework, SailPoint chose Grafana Cloud for its scalability, built-in support, and reduced maintenance overhead.&lt;/p&gt;&#xA;&lt;p&gt;The company’s use of Grafana Cloud Adaptive Metrics, combined with the efforts of the engineering team, also helped SailPoint achieve a 50% reduction in active metric series — from 75 million to 37.5 million.&lt;/p&gt;&#xA;&lt;p&gt;With Adaptive Metrics, “we could reduce metrics while we continue to grow,” said Omar Lopez, Head of Observability, &lt;a href=&#34;/events/observabilitycon/2024/sailpoint-cost-efficiency-with-grafana-cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;at ObservabilityCON 2024&lt;/a&gt;. “We&amp;rsquo;re still starting up new customers, we&amp;rsquo;re still writing new features, deploying new microservices, and opening up new regions. All that growth is still happening, but at the same time, we&amp;rsquo;re reducing our metric count. It blows my mind.”&lt;/p&gt;&#xA;&lt;p&gt;SailPoint is now exploring additional Grafana Cloud features, such as &lt;a href=&#34;/products/cloud/synthetic-monitoring/&#34;&gt;Synthetic Monitoring&lt;/a&gt; for performance testing and &lt;a href=&#34;/products/cloud/asserts/&#34;&gt;Asserts&lt;/a&gt; to enhance their monitoring capabilities.&lt;/p&gt;&#xA;&lt;p&gt;TeleTracking, an integrated healthcare operations platform provider, has seen similar success with Adaptive Metrics. Despite some initial skepticism from the observability team, who feared that removing or aggregating metrics might disrupt critical services or hinder visibility, the company has reduced its telemetry costs by 50% — a reduction that has helped advance TeleTracking’s observability strategy in other significant ways.&lt;/p&gt;&#xA;&lt;p&gt;“Thanks to 50% savings on our telemetry bill with Adaptive Metrics, we had room in our budget to fund Grafana IRM, and now we spend less time on our incident workflow, including post-mortems,” said Oren Lion, Director of Software Engineering, Productivity Engineering at TeleTracking &lt;a href=&#34;/events/observabilitycon/2024/teletracking-future-proof-observability-with-grafana-cloud/&#34;&gt;at ObservabilityCON 2024&lt;/a&gt;.&lt;br /&gt;&#xA;&lt;br /&gt;&#xA;Because of the wins they&amp;rsquo;ve seen with Adaptive Metrics, TeleTracking also became an early adopter of &lt;a href=&#34;/blog/2024/09/24/introducing-adaptive-logs/&#34;&gt;Adaptive Logs&lt;/a&gt;, a Grafana Cloud feature that helps you lower your observability costs by reducing the volume of unnecessary logs.&lt;br /&gt;&#xA;&lt;br /&gt;&#xA;“Adaptive Logs helps reduce noise, making it easier to spot valuable logs and ultimately saves us costs,” said Andrew Qu, Software Engineer II at TeleTracking, who is already seeing a 50% reduction in log volumes.&lt;/p&gt;&#xA;&lt;h3 id=&#34;consolidate-tools&#34;&gt;Consolidate tools&lt;/h3&gt;&#xA;&lt;p&gt;Ultimate AI is an industry-leading customer support automation platform that helps companies improve customer satisfaction and increase efficiency with AI. Ultimate’s incident response, however, was anything but automatic prior to adopting Grafana Cloud.&lt;/p&gt;&#xA;&lt;p&gt;Though they were already Grafana OSS users, it wasn’t heavily used because the company had dashboards, logs, and on-call information spread across multiple applications — and the same could be said for their observability bills. “We were spreading our money across multiple different tools and [the system] was indeed doing its job, but it took a lot of cognitive load for developers to actually understand all of those tools,” said a senior software engineer at Ultimate AI.&lt;/p&gt;&#xA;&lt;p&gt;They eventually centralized on-call management in Grafana IRM, and then quickly built out their managed stack on Grafana Cloud to include &lt;a href=&#34;/products/cloud/logs/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud Logs&lt;/a&gt; and &lt;a href=&#34;/products/cloud/k6/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud k6&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Learn more about how &lt;a href=&#34;/blog/2023/06/30/how-ultimate-improved-workflow-adoption-and-more-with-grafana-irm/&#34;&gt;Ultimate AI leverages Grafana Cloud&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;supporting-modern-cloud-architectures&#34;&gt;Supporting modern cloud architectures&lt;/h2&gt;&#xA;&lt;h3 id=&#34;optimize-hybrid-and-multi-cloud-deployments&#34;&gt;Optimize hybrid and multi-cloud deployments&lt;/h3&gt;&#xA;&lt;p&gt;Booking.com, one of the world’s leading digital travel companies, had a proprietary observability stack that consisted of multiple, disparate tools, redundant storage, and fragmented telemetry. While it served the company well for years, it couldn’t adequately support their complex multi-cloud and hybrid cloud infrastructure.&lt;/p&gt;&#xA;&lt;p&gt;“We are a multi-cloud company,” said Murugesan Ramaiah, Solutions Architect at Booking.com, during a &lt;a href=&#34;/events/observabilitycon-on-the-road/2024/london/bookingcom-agnostic-observability/&#34;&gt;talk at ObservabilityCON on the Road in London&lt;/a&gt;. “Our applications are running on AWS, but also on Google, on-premises within Kubernetes, and on EKS. We have a machine learning platform, a gen AI platform, and a data platform. We are a technology-driven travel company, and there are a lot of telemetry agents.”&lt;/p&gt;&#xA;&lt;p&gt;To modernize and centralize their observability strategy, the team moved to Grafana Cloud. They integrated Grafana’s centralized telemetry pipeline using &lt;a href=&#34;/oss/opentelemetry/&#34;&gt;OpenTelemetry&lt;/a&gt;, which simplified data gathering and enabled vendor-agnostic monitoring across environments.&lt;/p&gt;&#xA;&lt;p&gt;For metrics and logging, Booking.com deployed &lt;a href=&#34;/products/cloud/metrics/&#34;&gt;Grafana Cloud Metrics&lt;/a&gt; and &lt;a href=&#34;/products/cloud/logs/&#34;&gt;Grafana Cloud Logs&lt;/a&gt;, which now manage over 85 million metrics. The company also implemented &lt;a href=&#34;/products/cloud/profiles-for-continuous-profiling/&#34;&gt;Grafana Cloud Profiles&lt;/a&gt; to gain real-time visibility into application performance, helping them enhance both the customer experience and application performance.&lt;/p&gt;&#xA;&lt;p&gt;“The reason we chose Grafana Labs is because they align with our strategy — they natively support OpenTelemetry, and we want to work with somebody who built a product born in the cloud, for the cloud,” Ramaiah said.&lt;/p&gt;&#xA;&lt;h3 id=&#34;enable-easier-migration-to-prometheus&#34;&gt;Enable easier migration to Prometheus&lt;/h3&gt;&#xA;&lt;p&gt;At Kambi, they had a “pretty standard” setup for Graphite that was based on Python. As the leading independent provider of premium sports betting technology and services within the global regulated betting and gaming industry, Kambi had an infrastructure that included around 500 services feeding into an HAProxy that divided the load between six instances of carbon-relay. Carbon-relay nodes then forwarded it to the carbon-cache nodes, which stored the actual data as whisper files.&lt;/p&gt;&#xA;&lt;p&gt;Soon, however, issues began popping up. Their disk space, CPU, and even RAM were running out. Kambi SRE Frank Stengård’s team also discovered that in Graphite, many metrics were being sent at more frequent intervals than they were actually stored at, and the values were zeros or mostly zeros. As Stengård put it: “The house was burning now. We needed to fix it.”&lt;/p&gt;&#xA;&lt;p&gt;To battle their three-alarm fire, Stengård and his team decided to modify Hadrianus, their own open source application-aware firewall load-balancer, to send Kambi data in a mirror replica to a third-party provider. Since Kambi was already a Grafana OSS fan, they decided to test sending all of the production data straight to Grafana Cloud — and to their pleasant surprise, the hosted platform was able to handle their telemetry load.&lt;/p&gt;&#xA;&lt;p&gt;The company also decided they wanted to use Prometheus instead of Graphite because of its more popular support and the fact that it worked better in Kubernetes. Grafana Cloud was also a good fit because it not only supports Graphite; it also enabled an easy migration path to Prometheus, which the team did over time.&lt;/p&gt;&#xA;&lt;p&gt;Watch &lt;a href=&#34;/blog/2021/11/26/how-kambi-migrated-from-an-in-house-graphite-solution-to-grafana-cloud/&#34;&gt;Kambi’s deep dive into their Prometheus migration with Grafana Cloud&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt; is the easiest way to get started with metrics, logs, traces, dashboards, and more. We have a generous forever-free tier and plans for every use case. &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Sign up for free now!&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;】&lt;p&gt;虽然我们都喜欢&lt;a href=&#34;/oss/?pg=blog&amp;plcmt=body-txt&#34;&gt;开源技术&lt;/a&gt;和&lt;a href=&#34;/blog/2023/12/12/the-随之而来的story-of-grafana-documentary-the-community-behind-the-code/&#34;&gt;社区&lt;/a&gt;，我们并不总是有时间或资源来站出来、维护、更新和排除故障一个自托管 OSS 堆栈。&lt;/p&gt;&#xA;&lt;p&gt;这是公司选择实施 &lt;a href=&#34;/products/cloud/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt; 的（众多）原因之一：您可以获得 Grafana Cloud 的所有优点开源 Grafana LGTM Stack（&lt;a href=&#34;/oss/loki/&#34;&gt;Loki&lt;/a&gt; 用于日志，&lt;a href=&#34;/oss/grafana?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana&lt;/a&gt;为了可视化，&lt;a href=&#34;/oss/tempo/?pg=blog&amp;plcmt=body-txt&#34;&gt;轨迹速度&lt;/a&gt;，&lt;a href=&#34;/oss/mimir/?pg=blog&amp;plcmt=body-txt&#34;&gt; Mimir&lt;/a&gt; 指标）位于完全托管的端到端可观察性平台中。&lt;/p&gt;&#xA;&lt;p&gt;“使用 Grafana Cloud，几乎不需要维护，”SailPoint 可观测性主管 Omar Lopez 在 &lt;a href=&#34;/events/observabilitycon/2024/sailpoint-cost-efficiency-with-grafana- cloud/?pg=blog&amp;plcmt=body-txt&#34;&gt;ObservabilityCON 2024 上的演讲&lt;/a&gt;。 “我们让 Grafana 处理我们之前处理的所有复杂性，这样我们就可以将时间花在优先级更高的计划上。”&lt;/p&gt;&#xA;&lt;p&gt;Grafana Cloud 还提供开箱即用的尖端可观测性解决方案，例如 &lt;a href=&#34;/products/cloud/metrics/prometheus-cardinality-optimization/?pg=blog&amp;plcmt=body-txt&#34;&gt;Adaptive指标&lt;/a&gt;，一种基数优化功能，可帮助您识别和消除未使用的时间序列指标，以降低总体可观测性成本。&lt;/p&gt;&#xA;&lt;p&gt;但是为什么只相信我们的话呢？在这篇文章中，可观察性从业者分享了他们选择 Grafana Cloud 的主要原因，其中大部分分为三大类，以及随之而来的好处：&lt;/p&gt;&#xA;&lt;p&gt;&lt;强&gt;1。减轻管理可观察性堆栈的负担&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks//#focus-more-on-apps-and-strategic -projects&#34;&gt;更多地关注应用和战略项目&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#increase-security-for-customers&#34;&gt;提高安全性客户&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;强&gt;2。降低可观测性成本&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#reduce-metrics-volume&#34;&gt;减少指标量&lt;/一个&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#consolidate-tools&#34;&gt;整合工具&lt;/a&gt;&lt;一个href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#reduce-metrics-volume&#34;&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;强&gt;3。支持现代云架构&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#optimize-hybrid-and-multi-cloud-deployments&#34; &gt;优化混合动力和多云部署&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/blog/2024/11/26/why-companies-choose-grafana-cloud-over-self-hosted-oss-stacks/#enable-easier-migration-to-prometheus&#34;&gt;启用更轻松地迁移到 Prometheus&lt;/a&gt;&lt;a href=&#34;/blog/2023/10/16/why-companies-choose-grafana-cloud-over-self-management-oss-stacks/#enable-easy-migration-to-prometheus&#34;&gt;&lt;/a&gt;&lt;/李&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;reducing-the-burden-of-managing-an-observability-stack&#34;&gt;减轻管理可观察性堆栈的负担&lt;/h2&gt;&#xA;&lt;h3 id=&#34;focus-more-on-apps-and-strategic-projects&#34;&gt;更多地关注应用和战略项目&lt;/h3&gt;&#xA;&lt;p&gt;对于广告和数字媒体领域的 SaaS 提供商 The Trade Desk，Grafana Cloud 的好处几乎是立竿见影的。&lt;/p&gt;&#xA;&lt;p&gt;“查询时间立即得到改善，许多开发人员似乎都注意到了。此外，我们的可靠性也得到了很大提高。”现任 The Trade Desk 的 SRE 高级软件工程师 Patrick O’Brien 说道。 “我们的存储节点为零，这是该堆栈中最昂贵的部分。现在我们只有三个节点，所有内容都会反馈给 Grafana Labs。”&lt;/p&gt;&#xA;&lt;p&gt;除了为公司节省资金之外，转向 Grafana Cloud 还让工程部门免去了故障排除的麻烦。 “一旦我们使用托管平台，指标使用的挫败感几乎在一夜之间得到改善，”现任 The Trade Desk 生产工程高级总监 Carl Johnson 说道。 “我们知道这是成功的原因是内部的抱怨和挫败感停止了。”&lt;/p&gt;&#xA;&lt;p&gt;约翰逊补充道：“我认为大部分投资回报率实际上来自时间和劳动力的节省。我们都可以说，曾经的时间槽已经从我们的雷达中完全消失了。”&lt;/p&gt;&#xA;&lt;p&gt;Mux 是一家运营 API 优先视频平台的初创公司，旨在为开发团队提供世界一流的视频流和分析功能，它在 Grafana Cloud 上也有类似的经历。&lt;/p&gt;&#xA;&lt;p&gt;多年来一直在努力维护内部 OSS 堆栈（Elasticsearch、Kibana、Prometheus、Jaeger、Grafana），这让团队感觉过于被动且主要处于维护模式，他们知道是时候做出改变了。他们还需要能够动态扩展，以适应计算、网络和存储密集型工作负载的不可预测的使用需求。&lt;/p&gt;&#xA;&lt;p&gt;最终，他们转向了 Grafana Cloud，部分原因是他们对 Grafana OSS 已经很熟悉，但回报远不止是一个简单的入门。&lt;/p&gt;&#xA;&lt;p&gt;他们将指标量减少了 60%，同时还大大延长了数据保留时间，跟踪从 7 天延长到 30 天，指标从 14 天延长到 13 个月。这帮助 Mux 降低了噪音、改进了长期分析并采取了更主动的事件管理方法，同时保持了成本水平并让工程师参与了更具影响力的工作。&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1098px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;项目pe=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;一个&#xA;类=“灯箱链接标题”&#xA;href=&#34;/media/blog/mux-success/ingest-job-logs.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“lazyload mb-0”&#xA;data-src =“/media/blog/mux-success/ingest-job-logs.png”data-srcset =“/media/blog/mux-success/ingest-job-logs.png？w = 320 320w，/媒体/博客/mux-success/ingest-job-logs.png?w=550 550w, /media/blog/mux-success/ingest-job-logs.png?w=750 750w, /media/blog/mux-success/ingest-job-logs.png?w=900 900w, /media/blog/mux -成功/摄取作业日志.png?w=1040 1040w, /media/blog/mux-success/ingest-job-logs.png?w=1240 1240w, /media/blog/mux-success/ingest-job-logs.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;显示 Mux 上的摄取作业日志的图表。&#34;width=&#34;1098&#34;height=&#34;665&#34;title=&#34;*显示 Mux 上的摄取作业日志的图表。*&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/mux-success/ingest-job-logs.png”&#xA;alt=&#34;显示 Mux 上的摄取作业日志的图表。&#34;width=&#34;1098&#34;height=&#34;665&#34;title=&#34;*显示 Mux 上的摄取作业日志的图表。*&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;figcaption class=&#34;w-100p title text-gray-13 &#34;&gt;&lt;em&gt;显示 Mux 采集作业日志的图表。&lt;/em&gt;&lt;/figcaption&gt;&lt;/a&gt;&lt;/图&gt;&#xA;&lt;p&gt;“Grafana Cloud 可能每年为我们节省数百个工程时间，”Mux 工程副总裁 Ryan Grothouse 说道。 “我们的平台工程师不必再管理堆栈，我们的产品工程师也不必使用多种可观察性工具，这实际上会减慢我们的响应时间。”&lt;/p&gt;&#xA;&lt;p&gt;详细了解 Grafana Cloud 如何节省工程时间，请访问 &lt;a href=&#34;/blog/2024/07/22/how-mux-cut-metrics-volume-by-60-increased-retention-times-and -improved-developer-productivity-with-grafana-cloud/&#34;&gt;Mux &lt;/a&gt; 和 &lt;a href=&#34;/success/thetradedesk/?pg=blog&amp;plcmt=body-txt&#34;&gt;交易台&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;increase-security-for-customers&#34;&gt;提高客户的安全性&lt;/h3&gt;&#xA;&lt;p&gt;有时您只是想要更多好东西。 Royal IHC 就是这种情况，该公司使用 Grafana OSS 为其客户创建仪表板，作为提高世界各地海运船队运营效率的集成解决方案的一部分。&lt;/p&gt;&#xA;&lt;p&gt;Royal IHC 项目负责人 Guus Derksen 对他的团队能够创建的仪表板非常满意，因此他希望通过 Grafana Cloud Advanced 来扩展他们的产品，Grafana Cloud Advanced 为客户提供了内置的安全性和访问功能。&lt; /p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接标题”&#xA;href=&#34;/static/assets/img/blog/royal-ihc-dashboard.jpg?w=1240&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“lazyload mb-0”&#xA;data-src=&#34;/static/assets/img/blog/royal-ihc-dashboard.jpg?w=1240&#34;alt=&#34;显示关键指标的 Roya IHC 仪表板。&#34;title=&#34;*显示关键指标的 Royal IHC 仪表板。 *&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/static/assets/img/blog/royal-ihc-dashboard.jpg?w=1240&#34;&#xA;alt=&#34;A Roya IHC dashb显示关键指标的仪表板。&#34;title=&#34;*显示关键指标的 Royal IHC 仪表板。*&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;figcaption class=&#34;w-100p title text-gray-13 &#34;&gt;&lt;em&gt;皇家 IHC 仪表板展示关键指标。&lt;/em&gt;&lt;/figcaption&gt;&lt;/a&gt;&lt;/figure &gt;&#xA;&lt;p&gt;Royal IHC 有更多的成长和发展机会，这是可能的，因为 Grafana Cloud 还为其个人客户维护一切。 “它非常用户友好，”德克森说。 “这无疑为我们提供了正确的方向，以适应我们正在经历的总体发展。”&lt;/p&gt;&#xA;&lt;p&gt;详细了解&lt;a href=&#34;/success/royal-ihc/?pg=blog&amp;plcmt=body-txt&#34;&gt;Royal IHC 使用 Grafana Cloud Advanced 的可观测性之旅&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;lowering-observability-costs&#34;&gt;降低可观测性成本&lt;/h2&gt;&#xA;&lt;h3 id=&#34;reduce-metrics-volume&#34;&gt;减少指标量&lt;/h3&gt;&#xA;&lt;p&gt;尽管 Prometheus 和 Grafana 取得了初步成功，身份管理解决方案的领导者 SailPoint 在扩展方面却达到了极限，导致性能挑战和维护成本上升。在通过内部 DACI 决策框架评估选项后，SailPoint 选择 Grafana Cloud，因为它具有可扩展性、内置支持和减少的维护开销。&lt;/p&gt;&#xA;&lt;p&gt;该公司使用 Grafana Cloud Adaptive Metrics，再加上工程团队的努力，还帮助 SailPoint 将活跃指标系列减少了 50%，从 7500 万减少到 3750 万。&lt;/p&gt;&#xA;&lt;p&gt;借助自适应指标，“我们可以在持续增长的同时减少指标”，&lt;a href=&#34;/events/observabilitycon/2024/sailpoint-cost-efficiency-with-grafana-cloud”可观测性主管 Omar Lopez 说道/?pg=blog&amp;plcmt=body-txt&#34;&gt;ObservabilityCON 2024&lt;/a&gt;。 “我们仍在开发新客户，仍在编写新功能，部署新微服务，并开辟新区域。所有这些增长仍在发生，但与此同时，我们正在减少指标数量。这让我大吃一惊。”&lt;/p&gt;&#xA;&lt;p&gt;SailPoint 目前正在探索其他 Grafana Cloud 功能，例如用于性能测试的&lt;a href=&#34;/products/cloud/synthetic-monitoring/&#34;&gt;综合监控&lt;/a&gt;和&lt;a href=&#34;/products/cloud/断言/&#34;&gt;断言&lt;/a&gt;以增强其监控能力。&lt;/p&gt;&#xA;&lt;p&gt;TeleTracking 是一家综合医疗保健运营平台提供商，在 Adaptive Metrics 方面也取得了类似的成功。尽管可观测性团队最初持怀疑态度，担心删除或聚合指标可能会破坏关键服务或阻碍可见性，但该公司已将遥测成本降低了 50%，这一降低有助于以其他重要方式推进 TeleTracking 的可观测性策略。&lt; /p&gt;&#xA;&lt;p&gt;“借助 Adaptive Metrics，我们的遥测费用节省了 50%，我们的预算中有足够的空间来资助 Grafana IRM，现在我们花在事件工作流程（包括事后分析）上的时间更少了，”总监 Oren Lion 说道TeleTrack 软件工程、生产力工程系&lt;a href=&#34;/events/observabilitycon/2024/teletracking-future-proof-observability-with-grafana-cloud/&#34;&gt;在 ObservabilityCON 2024&lt;/a&gt;。&lt;br /&gt;&#xA;&lt;br/&gt;&#xA;由于他们在自适应指标方面取得的胜利，TeleTracking 也成为了 &lt;a href=&#34;/blog/2024/09/24/introducing-adaptive-logs/&#34;&gt;自适应日志&lt;/a&gt;（Grafana 的一个）的早期采用者云功能可通过减少不必要的日志量来帮助您降低可观测性成本。&lt;br /&gt;&#xA;&lt;br/&gt;&#xA;TeleTracking 的二级软件工程师 Andrew Qu 表示：“自适应日志有助于减少噪音，让我们更容易发现有价值的日志，并最终节省我们的成本。”他已经看到日志量减少了 50%。&lt;/p&gt;&#xA;&lt;h3 id=&#34;consolidate-tools&#34;&gt;整合工具&lt;/h3&gt;&#xA;&lt;p&gt;Ultimate AI 是行业领先的客户支持自动化平台，可帮助公司通过 AI 提高客户满意度并提高效率。然而，在采用 Grafana Cloud 之前，Ultimate 的事件响应绝非自动的。&lt;/p&gt;&#xA;&lt;p&gt;虽然他们已经是 Grafana OSS 用户，但它并没有被大量使用，因为该公司的仪表板、日志和待命信息分布在多个应用程序中 - 他们的可观察性账单也是如此。 Ultimate AI 的一位高级软件工程师表示：“我们将资金分散到多种不同的工具上，[系统]确实在完成其工作，但开发人员需要承受大量的认知负担才能真正理解所有这些工具。”&lt; /p&gt;&#xA;&lt;p&gt;他们最终将待命管理集中在 Grafana IRM 中，然后在 Grafana Cloud 上快速构建托管堆栈，以包含 &lt;a href=&#34;/products/cloud/logs/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud Logs&lt;/a&gt; 和 &lt;a href=&#34;/products/cloud/k6/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud k6&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;p&gt;详细了解&lt;a href=&#34;/blog/2023/06/30/how-ultimate-improved-workflow-adoption-and-more-with-grafana-irm/&#34;&gt;Ultimate AI 如何利用 Grafana Cloud&lt;/一个&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;supporting-modern-cloud-architectures&#34;&gt;支持现代云架构&lt;/h2&gt;&#xA;&lt;h3 id=&#34;optimize-hybrid-and-multi-cloud-deployments&#34;&gt;优化混合云和多云部署&lt;/h3&gt;&#xA;&lt;p&gt;Booking.com 是世界领先的数字旅游公司之一，拥有专有的可观测性堆栈，其中包括多个不同的工具、冗余存储和分散的遥测技术。虽然它多年来为公司提供了良好的服务，但无法充分支持其复杂的多云和混合云基础设施。&lt;/p&gt;&#xA;&lt;p&gt;“我们是一家多云公司，”Booking.com 解决方案架构师 Murugesan Ramaiah 在 &lt;a href=&#34;/events/observabilitycon-on-the-road/2024/london/bookingcom-agnostic- observability/&#34;&gt;在伦敦举行的 ObservabilityCON on the Road 上的演讲&lt;/a&gt;。 “我们的应用程序不仅在 AWS 上运行，也在 Google、Kubernetes 内的本地以及 EKS 上运行。我们有机器学习平台、gen AI平台、数据平台。我们是一家技术驱动的旅游公司，有很多遥测代理s。”&lt;/p&gt;&#xA;&lt;p&gt;为了实现可观察性策略的现代化和集中化，团队迁移到了 Grafana Cloud。他们使用 &lt;a href=&#34;/oss/opentelemetry/&#34;&gt;OpenTelemetry&lt;/a&gt; 集成了 Grafana 的集中式遥测管道，从而简化了数据收集并实现了跨环境的供应商无关监控。&lt;/p&gt;&#xA;&lt;p&gt;对于指标和日志记录，Booking.com 部署了 &lt;a href=&#34;/products/cloud/metrics/&#34;&gt;Grafana Cloud Metrics&lt;/a&gt; 和 &lt;a href=&#34;/products/cloud/logs/&#34;&gt;Grafana Cloud日志&lt;/a&gt;，现在管理超过 8500 万个指标。该公司还实施了 &lt;a href=&#34;/products/cloud/profiles-for-continuous-profiling/&#34;&gt;Grafana Cloud Profiles&lt;/a&gt; 来实时了解应用程序性能，帮助他们增强客户体验和应用程序性能。&lt;/p&gt;&#xA;&lt;p&gt;“我们选择 Grafana Labs 的原因是因为他们符合我们的战略——他们本身就支持 OpenTelemetry，我们希望与那些在云中构建产品、为云服务的人合作，”Ramaiah 说。&lt;/p &gt;&#xA;&lt;h3 id=&#34;enable-easier-migration-to-prometheus&#34;&gt;更轻松地迁移到 Prometheus&lt;/h3&gt;&#xA;&lt;p&gt;在 Kambi，他们有一个基于 Python 的“相当标准”的 Graphite 设置。作为全球受监管的博彩和游戏行业中领先的优质体育博彩技术和服务的独立提供商，Kambi 拥有一个基础设施，其中包括大约 500 项服务，这些服务馈入 HAProxy，在六个碳中继实例之间分配负载。然后 Carbon 中继节点将其转发到 Carbon 缓存节点，后者将实际数据存储为耳语文件。&lt;/p&gt;&#xA;&lt;p&gt;然而，很快问题就开始出现。他们的磁盘空间、CPU 甚至 RAM 都快用完了。 Kambi SRE Frank Stengård 的团队还发现，在 Graphite 中，许多指标的发送间隔比实际存储的间隔更频繁，并且值为零或大部分为零。正如斯坦加德所说：“房子现在正在燃烧。我们需要修复它。”&lt;/p&gt;&#xA;&lt;p&gt;为了对抗三级警报，Stengård 和他的团队决定修改 Hadrianus（他们自己的开源应用程序感知防火墙负载平衡器），将镜像副本中的 Kambi 数据发送给第三方提供商。由于 Kambi 已经是 Grafana OSS 的粉丝，他们决定测试将所有生产数据直接发送到 Grafana Cloud - 令他们惊喜的是，托管平台能够处理他们的遥测负载。&lt;/p&gt;&#xA;&lt;p&gt;该公司还决定使用 Prometheus 而不是 Graphite，因为它更受欢迎，而且它在 Kubernetes 中运行得更好。 Grafana Cloud 也很适合，因为它不仅支持 Graphite，还支持 Graphite。它还实现了到 Prometheus 的轻松迁移路径，团队随着时间的推移做到了这一点。&lt;/p&gt;&#xA;&lt;p&gt;观看&lt;a href=&#34;/blog/2021/11/26/how-kambi-migrate-from-an-in-house-graphite-solution-to-grafana-cloud/&#34;&gt;Kambi 深入研究他们的 Prometheus使用 Grafana Cloud 进行迁移&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt; 是开始使用指标、日志、跟踪、仪表板等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。 &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;plcmt=body-txt&#34;&gt;立即免费注册！&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</description>
      <pubDate>Tue, 26 Nov 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Metrics, logs, traces, and mayhem: introducing an observability adventure game powered by Grafana Alloy and OTel】指标、日志、痕迹和混乱：介绍一款由 Grafana Alloy 和 OTel 提供支持的可观察性冒险游戏</title>
      <link>https://grafana.com/blog/2024/11/20/metrics-logs-traces-and-mayhem-introducing-an-observability-adventure-game-powered-by-grafana-alloy-and-otel/</link>
      <description>【&lt;p&gt;&lt;em&gt;Ah, adventurer! Are you ready to embark on a perilous quest through the treacherous lands of observability?&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;As developer advocates here at Grafana Labs, our day job is to learn and teach the pillars of observability to our end users. We spend a lot of time thinking about how software engineers can best learn the basics. Sure, there is a huge amount of great content out there — blogs, videos, and documentation — but we wondered if there’s a way to make the learning experience a bit more interactive and fun.&lt;/p&gt;&#xA;&lt;p&gt;As it happens, we’re also both avid gamers. We tend to view work-related challenges as quests to embark on and monsters to slay. And in the gaming world, we thought observability would be like a hydra with four heads: metrics, logs, traces, and profiles.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p w-100p&#34;&#xA;style=&#34;max-width: 500px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link w-fit mx-auto d-flex flex-direction-column&#34;&#xA;href=&#34;/media/blog/observability-game/otel-alloy-demo-hydra_resized2.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-demo-hydra_resized2.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-demo-hydra_resized2.png?w=320 320w, /media/blog/observability-game/otel-alloy-demo-hydra_resized2.png?w=550 550w, /media/blog/observability-game/otel-alloy-demo-hydra_resized2.png?w=750 750w, /media/blog/observability-game/otel-alloy-demo-hydra_resized2.png?w=900 900w, /media/blog/observability-game/otel-alloy-demo-hydra_resized2.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-demo-hydra_resized2.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-demo-hydra_resized2.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;An image of a knight fighting a hydra.&#34;width=&#34;307&#34;height=&#34;307&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/observability-game/otel-alloy-demo-hydra_resized2.png&#34;&#xA;alt=&#34;An image of a knight fighting a hydra.&#34;width=&#34;307&#34;height=&#34;307&#34;class=&#34;w-100p&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;That’s when the lightbulb went off.&lt;/p&gt;&#xA;&lt;p&gt;Today, we’re excited to introduce Quest World, an interactive game we created using OpenTelemetry, Grafana Alloy, and the Grafana LGTM (&lt;a href=&#34;/oss/loki/&#34;&gt;Loki&lt;/a&gt; for logs,&lt;a href=&#34;/oss/grafana?pg=blog&amp;amp;plcmt=body-txt&#34;&gt; Grafana&lt;/a&gt; for visualization,&lt;a href=&#34;/oss/tempo/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt; Tempo&lt;/a&gt; for traces,&lt;a href=&#34;/oss/mimir/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt; Mimir&lt;/a&gt; for metrics) Stack that can help you and your team learn the basics of observability.&lt;/p&gt;&#xA;&lt;p&gt;Read on to learn how you can set up Quest World today and to explore some of the big architectural decisions we made around game structure, player actions, and incorporating the different observability signals.&lt;/p&gt;&#xA;&lt;p&gt;We’ll also be demoing the game at &lt;a href=&#34;/events/aws-reinvent/&#34;&gt;AWS re:Invent 2024&lt;/a&gt; this year! We hope you’ll come find us in the AWS Modern Applications &amp;amp; Open Source Zone during the following timeslots to check it out and score some extra swag:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Tues., Dec. 3 from 1 - 2pm&lt;/li&gt;&#xA;&lt;li&gt;Thurs., Dec. 5 from 11am - 12pm&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;quest-world-an-interactive-observability-adventure&#34;&gt;Quest World: an interactive observability adventure&lt;/h2&gt;&#xA;&lt;p&gt;Quest World is a text-based adventure game with a twist: you have to use the full Grafana LGTM Stack to solve the quest to defeat the evil wizard.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p w-100p&#34;&#xA;style=&#34;max-width: 500px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link w-fit mx-auto d-flex flex-direction-column&#34;&#xA;href=&#34;/media/blog/observability-game/otel-alloy-questworld-launch_resized2.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-questworld-launch_resized2.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-questworld-launch_resized2.png?w=320 320w, /media/blog/observability-game/otel-alloy-questworld-launch_resized2.png?w=550 550w, /media/blog/observability-game/otel-alloy-questworld-launch_resized2.png?w=750 750w, /media/blog/observability-game/otel-alloy-questworld-launch_resized2.png?w=900 900w, /media/blog/observability-game/otel-alloy-questworld-launch_resized2.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-questworld-launch_resized2.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-questworld-launch_resized2.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot from Quest World. &#34;width=&#34;307&#34;height=&#34;307&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/observability-game/otel-alloy-questworld-launch_resized2.png&#34;&#xA;alt=&#34;A screenshot from Quest World. &#34;width=&#34;307&#34;height=&#34;307&#34;class=&#34;w-100p&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;Without giving too much away, your adventure looks a little like this:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Visit a town&lt;/li&gt;&#xA;&lt;li&gt;Forge a sword: a metrics challenge&lt;/li&gt;&#xA;&lt;li&gt;Empower that sword: a logs challenge&lt;/li&gt;&#xA;&lt;li&gt;Defeat the wizard&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1999px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/observability-game/otel-alloy-mainpy-script.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-mainpy-script.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-mainpy-script.png?w=320 320w, /media/blog/observability-game/otel-alloy-mainpy-script.png?w=550 550w, /media/blog/observability-game/otel-alloy-mainpy-script.png?w=750 750w, /media/blog/observability-game/otel-alloy-mainpy-script.png?w=900 900w, /media/blog/observability-game/otel-alloy-mainpy-script.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-mainpy-script.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-mainpy-script.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of the Quest World text.&#34;width=&#34;1999&#34;height=&#34;765&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/observability-game/otel-alloy-mainpy-script.png&#34;&#xA;alt=&#34;A screenshot of the Quest World text.&#34;width=&#34;1999&#34;height=&#34;765&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;It may look simple at first glance, but take heed of your observability dashboard, adventurer! It is the secret to your success.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1999px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/observability-game/otel-alloy-demo-dashboard.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-demo-dashboard.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-demo-dashboard.png?w=320 320w, /media/blog/observability-game/otel-alloy-demo-dashboard.png?w=550 550w, /media/blog/observability-game/otel-alloy-demo-dashboard.png?w=750 750w, /media/blog/observability-game/otel-alloy-demo-dashboard.png?w=900 900w, /media/blog/observability-game/otel-alloy-demo-dashboard.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-demo-dashboard.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-demo-dashboard.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of a dashboard from Quest World. &#34;width=&#34;1999&#34;height=&#34;988&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/observability-game/otel-alloy-demo-dashboard.png&#34;&#xA;alt=&#34;A screenshot of a dashboard from Quest World. &#34;width=&#34;1999&#34;height=&#34;988&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;goal&#34;&gt;Goal&lt;/h3&gt;&#xA;&lt;p&gt;Our goal was simple when creating the game: we wanted to provide at least two challenges that needed to be solved while learning the basics of that observability data type. Metrics, for example, help you understand trends and accelerate reaction times, while logs allow you to reflect on decisions made and perhaps find secret clues to mechanics not found within the terminal.&lt;/p&gt;&#xA;&lt;p&gt;The adventure is built on open standards and is highly extendable, so you can modify it to meet your learning (and teaching) needs. For instance, we recently just added traces to the adventure to generate a post-game leaderboard (more on this later in the blog).&lt;/p&gt;&#xA;&lt;h3 id=&#34;setup&#34;&gt;Setup&lt;/h3&gt;&#xA;&lt;p&gt;If you would like to try Quest World yourself, you can choose from two paths:&lt;/p&gt;&#xA;&lt;h4 id=&#34;path-1-online-sandbox&#34;&gt;Path 1: Online sandbox&lt;/h4&gt;&#xA;&lt;p&gt;We have created an online sandbox using Killercoda. This will spin up a self-contained environment online so you can play the game without worrying about dependencies:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://killercoda.com/grafana-labs/course/workshops/adventure&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;https://killercoda.com/grafana-labs/course/workshops/adventure&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Simply:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Follow the link&lt;/li&gt;&#xA;&lt;li&gt;Create a free Killercoda account&lt;/li&gt;&#xA;&lt;li&gt;Let the setup script run&lt;/li&gt;&#xA;&lt;li&gt;Follow the instructions in the left panel&lt;/li&gt;&#xA;&lt;li&gt;Click &lt;strong&gt;next&lt;/strong&gt; to see more instructions&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;path-2-run-the-adventure-locally&#34;&gt;Path 2: Run the adventure locally&lt;/h4&gt;&#xA;&lt;p&gt;The code is fully open source and available in this &lt;a href=&#34;https://github.com/grafana/adventure&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;GitHub repo&lt;/a&gt;, so you can try it yourself and even expand the adventure.&lt;/p&gt;&#xA;&lt;p&gt;There are a couple of prerequisites to keep in mind:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Docker and Docker Compose (installed and up-to-date)&lt;/li&gt;&#xA;&lt;li&gt;Python 3.12 or later&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Follow the steps outlined in the &lt;a href=&#34;https://github.com/grafana/adventure/blob/main/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;README&lt;/a&gt; for setup.&lt;/p&gt;&#xA;&lt;h2 id=&#34;creating-the-adventure&#34;&gt;Creating the adventure&lt;/h2&gt;&#xA;&lt;p&gt;So, how did all of this come together? Actually, rather quickly once we planned out the architecture! Let&amp;rsquo;s take a look:&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1920px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/observability-game/otel-alloy-demo-architecture.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-demo-architecture.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-demo-architecture.png?w=320 320w, /media/blog/observability-game/otel-alloy-demo-architecture.png?w=550 550w, /media/blog/observability-game/otel-alloy-demo-architecture.png?w=750 750w, /media/blog/observability-game/otel-alloy-demo-architecture.png?w=900 900w, /media/blog/observability-game/otel-alloy-demo-architecture.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-demo-architecture.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-demo-architecture.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A diagram of the Quest World architecture. &#34;width=&#34;1920&#34;height=&#34;1080&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/observability-game/otel-alloy-demo-architecture.png&#34;&#xA;alt=&#34;A diagram of the Quest World architecture. &#34;width=&#34;1920&#34;height=&#34;1080&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;adventurepy&#34;&gt;Adventure.py&lt;/h3&gt;&#xA;&lt;p&gt;This is where most of the mayhem happens. I should point out that &lt;strong&gt;adventure.py&lt;/strong&gt; actually represents &lt;strong&gt;main.py&lt;/strong&gt; and &lt;strong&gt;otel.py&lt;/strong&gt; in the repo. The code creates a text-based adventure game by defining a class AdventureGame that encapsulates all the game logic and state management. Here&amp;rsquo;s a breakdown of how the game is made:&lt;/p&gt;&#xA;&lt;h4 id=&#34;game-structure&#34;&gt;Game structure&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Locations and actions are defined in a dictionary, &lt;em&gt;&lt;strong&gt;self.locations&lt;/strong&gt;&lt;/em&gt;. Each location has a description, available actions, and optional prerequisites or effects that trigger specific game logic.&lt;/li&gt;&#xA;&lt;li&gt;The player navigates between locations, interacting with characters and items like swords and the blacksmith&amp;rsquo;s forge.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;player-actions&#34;&gt;Player actions&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Actions like &amp;ldquo;&lt;em&gt;request sword&lt;/em&gt;&amp;rdquo; or &amp;ldquo;&lt;em&gt;heat forge&lt;/em&gt;&amp;rdquo; are tied to specific effects implemented as methods (e.g., request_sword, heat_forge).&lt;/li&gt;&#xA;&lt;li&gt;Each action checks conditions (pre-requisites) and modifies game state variables like &lt;em&gt;&lt;strong&gt;self.heat&lt;/strong&gt;&lt;/em&gt;, &lt;em&gt;&lt;strong&gt;self.has_sword&lt;/strong&gt;&lt;/em&gt;, or &lt;em&gt;&lt;strong&gt;self.blacksmith_burned_down&lt;/strong&gt;&lt;/em&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;branching-gameplay&#34;&gt;Branching gameplay&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;The storyline evolves based on player choices, tracked by state variables (e.g., self.quest_accepted, self.has_holy_sword).&lt;/li&gt;&#xA;&lt;li&gt;Decisions have consequences, like forging an evil or holy sword or influencing the outcome of interactions with the priest, wizard, or quest giver.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;This is all tied together in a basic loop that displays the current location and available actions, and processes player commands.&lt;/p&gt;&#xA;&lt;p&gt;Okay, so, where does OpenTelemetry come into all this?&lt;/p&gt;&#xA;&lt;p&gt;We decided to implement each telemetry type using the OTel SDK because it allowed us to unify the implementation of each of our telemetry signals (essentially, each hydra head comes from the same body). It also allowed us to customize a lot of these signals so we could add our fun adventure game log.&lt;/p&gt;&#xA;&lt;p&gt;Here’s how it all works:&lt;/p&gt;&#xA;&lt;h4 id=&#34;metrics&#34;&gt;Metrics&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;Definition&lt;/strong&gt;: Metrics track numerical data like the forge&#39;s heat level and the number of swords forged.&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;Implementation:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CustomMetrics is used to define a meter that creates observable gauges.&lt;/li&gt;&#xA;&lt;li&gt;Metrics include:&lt;/li&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;forge_heat: Tracks the heat level of the blacksmith&#39;s forge.&lt;/li&gt;&#xA;&lt;li&gt;swords: Tracks the total number of swords forged.&lt;/li&gt;&#xA;&lt;li&gt;holy_sword and evil_sword: Monitor the status of enchanted swords.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;li&gt;Gauges use callback functions like observe_forge_heat to return dynamic values based on the game state.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/table&gt;&#xA;&lt;h4 id=&#34;logs&#34;&gt;Logs&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;Definition&lt;/strong&gt;: Logs capture textual information about events and player actions, categorized by severity (INFO, WARNING, ERROR, CRITICAL).&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;Implementation:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CustomLogFW sets up logging for the game.&lt;/li&gt;&#xA;&lt;li&gt;Logging messages are distributed throughout the code to capture:&lt;/li&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Player actions (e.g., heating the forge or requesting a sword).&lt;/li&gt;&#xA;&lt;li&gt;Significant events like burning down the blacksmith or crafting an enchanted sword.&lt;/li&gt;&#xA;&lt;li&gt;Warnings or errors when the player makes poor decisions, such as overheating the forge or obtaining a cursed sword.&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/table&gt;&#xA;&lt;h4 id=&#34;traces&#34;&gt;Traces&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;Definition&lt;/strong&gt;: Traces track the flow of actions taken by the player, capturing contextual metadata for each interaction.&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;Implementation:&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CustomTracer sets up tracing using OpenTelemetry.&lt;/li&gt;&#xA;&lt;li&gt;A root span tracks the player&#39;s entire journey, while child spans are created for individual actions (e.g., &#34;action: request sword&#34;).&lt;/li&gt;&#xA;&lt;li&gt;Spans include attributes like the player&#39;s name and current location for additional context.&lt;/li&gt;&#xA;&lt;li&gt;Events are added to spans for significant milestones (e.g., forging a sword or killing the wizard).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;As you can see, three of our four observability hydra heads play a pivotal imaginary role within the game, while also staying true to their real-world counterparts. The next question is where do all of these telemetry signals go?&lt;/p&gt;&#xA;&lt;h3 id=&#34;grafana-alloy&#34;&gt;Grafana Alloy&lt;/h3&gt;&#xA;&lt;p&gt;The answer is anywhere you like if it&amp;rsquo;s OpenTelemetry-compatible. Realistically, you will be sending it to some form of &lt;a href=&#34;https://opentelemetry.io/docs/collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;OTel Collector&lt;/a&gt; for buffering and potentially further processing. We opted to use &lt;a href=&#34;/docs/alloy/latest/&#34;&gt;Grafana Alloy&lt;/a&gt;, a vendor-neutral distribution of the OTel Collector, because it has a couple features that make it a great teaching tool.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1200px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/observability-game/otel-alloy-demo-alloy-logo2.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-demo-alloy-logo2.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-demo-alloy-logo2.png?w=320 320w, /media/blog/observability-game/otel-alloy-demo-alloy-logo2.png?w=550 550w, /media/blog/observability-game/otel-alloy-demo-alloy-logo2.png?w=750 750w, /media/blog/observability-game/otel-alloy-demo-alloy-logo2.png?w=900 900w, /media/blog/observability-game/otel-alloy-demo-alloy-logo2.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-demo-alloy-logo2.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-demo-alloy-logo2.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of a character in Quest World.&#34;width=&#34;1200&#34;height=&#34;630&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/observability-game/otel-alloy-demo-alloy-logo2.png&#34;&#xA;alt=&#34;A screenshot of a character in Quest World.&#34;width=&#34;1200&#34;height=&#34;630&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h4 id=&#34;integrated-ui&#34;&gt;Integrated UI&lt;/h4&gt;&#xA;&lt;p&gt;Like Prometheus, Grafana Alloy comes with an integrated UI, so you can visually understand the configuration you are deploying and the flow of your data. Check out this relationship graph:&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1999px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/observability-game/otel-alloy-integrated-ui.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-integrated-ui.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-integrated-ui.png?w=320 320w, /media/blog/observability-game/otel-alloy-integrated-ui.png?w=550 550w, /media/blog/observability-game/otel-alloy-integrated-ui.png?w=750 750w, /media/blog/observability-game/otel-alloy-integrated-ui.png?w=900 900w, /media/blog/observability-game/otel-alloy-integrated-ui.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-integrated-ui.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-integrated-ui.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of the Grafana Alloy integrated UI.&#34;width=&#34;1999&#34;height=&#34;1293&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/observability-game/otel-alloy-integrated-ui.png&#34;&#xA;alt=&#34;A screenshot of the Grafana Alloy integrated UI.&#34;width=&#34;1999&#34;height=&#34;1293&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;You can also understand component configuration settings and whether each stage of your pipeline is healthy.&lt;/p&gt;&#xA;&lt;h4 id=&#34;live-debugging&#34;&gt;Live debugging&lt;/h4&gt;&#xA;&lt;p&gt;Live debugging is another, slightly more experimental feature that is great for teaching. This lets you see a live feed of your telemetry data as it is being processed through Alloy.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1999px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/observability-game/otel-alloy-live-debugging.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-live-debugging.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-live-debugging.png?w=320 320w, /media/blog/observability-game/otel-alloy-live-debugging.png?w=550 550w, /media/blog/observability-game/otel-alloy-live-debugging.png?w=750 750w, /media/blog/observability-game/otel-alloy-live-debugging.png?w=900 900w, /media/blog/observability-game/otel-alloy-live-debugging.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-live-debugging.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-live-debugging.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of the live debugging feature.&#34;width=&#34;1999&#34;height=&#34;664&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/observability-game/otel-alloy-live-debugging.png&#34;&#xA;alt=&#34;A screenshot of the live debugging feature.&#34;width=&#34;1999&#34;height=&#34;664&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h2 id=&#34;telemetry-storage&#34;&gt;Telemetry storage&lt;/h2&gt;&#xA;&lt;p&gt;Quest World uses three storage backends: Prometheus (metrics), &lt;a href=&#34;/oss/loki/&#34;&gt;Grafana Loki&lt;/a&gt; (logs), and &lt;a href=&#34;/oss/tempo/&#34;&gt;Grafana Tempo&lt;/a&gt; (traces). All three databases share one key feature: they have a fully compliant native OTel endpoint. This allows us to write OTel format data (OTLP) directly to our storage backends of choice and let them handle the rest.&lt;/p&gt;&#xA;&lt;p&gt;The best part about this is it lets us do some pretty powerful analysis when we reach our observability frontend, Grafana, since all signals share the same attributes.&lt;/p&gt;&#xA;&lt;p&gt;All three databases are running in &lt;a href=&#34;/docs/loki/latest/get-started/deployment-modes/#monolithic-mode&#34;&gt;monolithic mode&lt;/a&gt;, and you can find the docker-compose deployment file &lt;a href=&#34;https://github.com/grafana/adventure/blob/main/docker-compose.yml&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;here&lt;/a&gt;. Also, here is a reference table containing all config files:&lt;/p&gt;&#xA;&lt;table&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Prometheus&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;a href=&#34;https://github.com/grafana/adventure/blob/main/prometheus.yml&#34;&gt;https://github.com/grafana/adventure/blob/main/prometheus.yml&lt;/a&gt;&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Loki&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;a href=&#34;https://github.com/grafana/adventure/blob/main/loki-config.yaml&#34;&gt;https://github.com/grafana/adventure/blob/main/loki-config.yaml&lt;/a&gt;&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Tempo&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;a href=&#34;https://github.com/grafana/adventure/blob/main/tempo.yaml&#34;&gt;https://github.com/grafana/adventure/blob/main/tempo.yaml&lt;/a&gt;&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;grafana&#34;&gt;Grafana&lt;/h2&gt;&#xA;&lt;p&gt;Of course, our adventure would not be complete without Grafana, which acts as our primary game interface (other than the text adventure itself).&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p w-100p&#34;&#xA;style=&#34;max-width: 500px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link w-fit mx-auto d-flex flex-direction-column&#34;&#xA;href=&#34;/media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png?w=320 320w, /media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png?w=550 550w, /media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png?w=750 750w, /media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png?w=900 900w, /media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;An altered Grafana logo. &#34;width=&#34;242&#34;height=&#34;256&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png&#34;&#xA;alt=&#34;An altered Grafana logo. &#34;width=&#34;242&#34;height=&#34;256&#34;class=&#34;w-100p&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;Grafana acts as our:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Quest Log: Notifies the user of events triggered throughout their adventure.&lt;/li&gt;&#xA;&lt;li&gt;Forge Monitor: Extremely useful for forging your own sword (wink, wink, nudge, nudge).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;You can either use our &lt;a href=&#34;/blog/2024/09/24/queryless-metrics-logs-traces-profiles/&#34;&gt;Explore Apps&lt;/a&gt; for metrics, logs, and traces, or use the included dashboard.&lt;/p&gt;&#xA;&lt;p&gt;Grafana also serves another role after a user has completed a play-through: it acts as a scoreboard using our traces visualization panel.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1999px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/observability-game/otel-alloy-leader-board.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-leader-board.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-leader-board.png?w=320 320w, /media/blog/observability-game/otel-alloy-leader-board.png?w=550 550w, /media/blog/observability-game/otel-alloy-leader-board.png?w=750 750w, /media/blog/observability-game/otel-alloy-leader-board.png?w=900 900w, /media/blog/observability-game/otel-alloy-leader-board.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-leader-board.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-leader-board.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of the leader board.&#34;width=&#34;1999&#34;height=&#34;541&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/observability-game/otel-alloy-leader-board.png&#34;&#xA;alt=&#34;A screenshot of the leader board.&#34;width=&#34;1999&#34;height=&#34;541&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;If I have lost you, let me explain. The scoreboard is based on how quickly you complete the game. Each stage takes a certain amount of time to complete. We treat each play-through as a single trace, and each step the user takes as a span.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1999px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/observability-game/otel-alloy-traces.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-traces.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-traces.png?w=320 320w, /media/blog/observability-game/otel-alloy-traces.png?w=550 550w, /media/blog/observability-game/otel-alloy-traces.png?w=750 750w, /media/blog/observability-game/otel-alloy-traces.png?w=900 900w, /media/blog/observability-game/otel-alloy-traces.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-traces.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-traces.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of traces.&#34;width=&#34;1999&#34;height=&#34;948&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/observability-game/otel-alloy-traces.png&#34;&#xA;alt=&#34;A screenshot of traces.&#34;width=&#34;1999&#34;height=&#34;948&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;It also meant we could leave some neat metadata such as Span Events throughout so you can look back on your adventure and understand the implications of the choices you made.&lt;/p&gt;&#xA;&lt;h2 id=&#34;one-last-hydra-head-to-slay&#34;&gt;One last hydra head to slay!&lt;/h2&gt;&#xA;&lt;p&gt;You may have noticed that we haven’t covered continuous profiling yet as part of this observability adventure. No magic or trickery here – we are just still figuring out the best way to represent profiles in the game.&lt;/p&gt;&#xA;&lt;p&gt;Our current thought is to maybe make profiles a mechanic for the “final boss” fight against the wizard. During this stage of the game, users have three lives and a couple of spell options. Certain spells could require more system resources, especially if they are used one after the other, which would leave you vulnerable to the wizard. This is where profiles could come in.&lt;/p&gt;&#xA;&lt;p&gt;If you have any ideas, we would love to hear from you! Please feel free to open issues or PRs to explain how you would incorporate continuous profiles.&lt;/p&gt;&#xA;&lt;h2 id=&#34;did-someone-say-swag-easter-egg&#34;&gt;Did someone say &amp;lsquo;swag Easter egg&amp;rsquo;!?&lt;/h2&gt;&#xA;&lt;p&gt;Would any retro adventure game be complete without an Easter egg hidden somewhere in the game?&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p w-100p&#34;&#xA;style=&#34;max-width: 500px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link w-fit mx-auto d-flex flex-direction-column&#34;&#xA;href=&#34;/media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png?w=320 320w, /media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png?w=550 550w, /media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png?w=750 750w, /media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png?w=900 900w, /media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of an egg.&#34;width=&#34;150&#34;height=&#34;150&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png&#34;&#xA;alt=&#34;A screenshot of an egg.&#34;width=&#34;150&#34;height=&#34;150&#34;class=&#34;w-100p&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;We are giving away swag to the first 10 players who find the secret Easter egg (you’ll know it when you see it). Just send the secret code to either of us via our &lt;a href=&#34;https://slack.grafana.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;community Slack&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-end-of-our-story-for-now&#34;&gt;The end of our story… for now&lt;/h2&gt;&#xA;&lt;p&gt;So, brave adventurer, we come to the end of our story for now. We hope you have as much fun playing Quest World as we did building it. All great stories start from somewhere, and we hope to see the adventure game expand with new ideas and PRs from our awesome community. We want to treat the project like the &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;OTel Demo&lt;/a&gt;, so feel free to fork it, change it, and add your spin.&lt;/p&gt;&#xA;&lt;p&gt;Lastly, just a reminder that we will be demoing the game at &lt;a href=&#34;/events/aws-reinvent/&#34;&gt;AWS re:Invent&lt;/a&gt;. Come visit us at the AWS Modern Applications and Open Source Zone during the following timeslots to try your hand at this observability adventure:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Tues., Dec. 3 from 1 - 2pm&lt;/li&gt;&#xA;&lt;li&gt;Thurs., Dec. 5 from 11am - 12pm&lt;/li&gt;&#xA;&lt;/ul&gt;】&lt;p&gt;&lt;em&gt;啊，冒险家！你准备好在危险的可观察之地开始危险的探索了吗？&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;作为 Grafana Labs 的开发者倡导者，我们的日常工作是向最终用户学习和教授可观察性的支柱。我们花了很多时间思考软件工程师如何才能最好地学习基础知识。当然，有大量精彩的内容——博客、视频和文档——但我们想知道是否有一种方法可以让学习体验更具互动性和乐趣。&lt;/p&gt;&#xA;&lt;p&gt;碰巧，我们都是狂热的游戏玩家。我们倾向于将与工作相关的挑战视为要开始的任务和要杀死的怪物。在游戏世界中，我们认为可观察性就像有四个头的九头蛇：指标、日志、跟踪和配置文件。&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p w-100p”&#xA;样式=“最大宽度：500px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“lightbox-link w-fit mx-auto d-flex flex-direction-column”&#xA;href=&#34;/media/blog/observability-game/otel-alloy-demo-Hydra_resized2.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-demo-Hydra_resized2.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-demo-Hydra_resized2.png?w= 320 320w，/media/blog/observability-game/otel-alloy-demo-Hydra_resized2.png?w=550 550w、/media/blog/observability-game/otel-alloy-demo-Hydra_resized2.png?w=750 750w、/media/blog/observability-game/otel-alloy-demo-Hydra_resized2.png?w=900 900w、 /media/blog/observability-game/otel-alloy-demo-Hydra_resized2.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-demo-Hydra_resized2.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-demo-Hydra_resized2.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;骑士与九头蛇战斗的图像。&#34;width=&#34;307&#34;height=&#34;307&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/observability-game/otel-alloy-demo-Hydra_resized2.png”&#xA;alt=&#34;骑士与九头蛇战斗的图像。&#34;width=&#34;307&#34;height=&#34;307&#34;class=&#34;w-100p&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;就在那时，灯泡熄灭了。&lt;/p&gt;&#xA;&lt;p&gt;今天，我们很高兴推出 Quest World，这是一款我们使用 OpenTelemetry、Grafana Alloy 和 Grafana LGTM（&lt;a href=&#34;/oss/loki/&#34;&gt;Loki&lt;/a&gt; 用于日志、 &lt;a href=&#34;/oss/grafana?pg=blog&amp;plcmt=body-txt&#34;&gt; Grafana&lt;/a&gt; 用于可视化，&lt;a href=&#34;/oss/tempo/?pg=blog&amp;plcmt=body-txt&#34;&gt; 轨迹速度&lt;/a&gt;，&lt;a href=&#34;/oss/mimir/?pg=blog&amp;plcmt=body-txt&#34;&gt; Mimir&lt;/a &gt; 对于指标）堆栈可以帮助您和您的团队学习可观察性的基础知识。&lt;/p&gt;&#xA;&lt;p&gt;请继续阅读，了解如何设置 Quest World，并探索我们围绕游戏结构、玩家行为以及整合不同的可观察性信号做出的一些重大架构决策。&lt;/p&gt;&#xA;&lt;p&gt;我们今年还将在 &lt;a href=&#34;/events/aws-reinvent/&#34;&gt;AWS re:Invent 2024&lt;/a&gt; 上演示该游戏！我们希望你您将在以下时间段到 AWS 现代应用程序和开源专区找到我们，查看并获得一些额外的礼物：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;12 月 3 日星期二下午 1 点至 2 点&lt;/li&gt;&#xA;&lt;li&gt;12 月 5 日星期四上午 11 点至中午 12 点&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;quest-world-an-interactive-observability-adventure&#34;&gt;Quest World：交互式可观察性冒险&lt;/h2&gt;&#xA;&lt;p&gt;Quest World 是一款基于文本的冒险游戏，但有一点不同：你必须使用完整的 Grafana LGTM Stack 来解决击败邪恶巫师的任务。&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p w-100p”&#xA;样式=“最大宽度：500px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“lightbox-link w-fit mx-auto d-flex flex-direction-column”&#xA;href=&#34;/media/blog/observability-game/otel-alloy-questworld-launch_resized2.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-questworld-launch_resized2.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-questworld-launch_resized2.png?w= 320 320w，/media/blog/observability-game/otel-alloy-questworld-launch_resized2.png?w=550 550w、/media/blog/observability-game/otel-alloy-questworld-launch_resized2.png?w=750 750w、/media/blog/observability-game/otel-alloy-questworld-launch_resized2.png?w=900 900w、 /media/blog/observability-game/otel-alloy-questworld-launch_resized2.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-questworld-launch_resized2.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-questworld-launch_resized2.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Quest World 的屏幕截图。&#34;width=&#34;307&#34;height=&#34;307&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/media/blog/observability-game/otel-alloy-questworld-launch_resized2.png&#34;&#xA;alt=&#34;Quest World 的屏幕截图。&#34;width=&#34;307&#34;height=&#34;307&#34;class=&#34;w-100p&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;在不透露太多内容的情况下，你的冒险看起来有点像这样：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;参观城镇&lt;/li&gt;&#xA;&lt;li&gt;铸剑：指标挑战&lt;/li&gt;&#xA;&lt;li&gt;赋予这把剑力量：日志挑战&lt;/li&gt;&#xA;&lt;li&gt;击败巫师&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1999px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/observability-game/otel-alloy-mainpy-script.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-mainpy-script.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-mainpy-script.png?w= 320 320w，/media/blog/observability-game/otel-alloy-mainpy-script.png?w=550 550w， /media/blog/observability-game/otel-alloy-mainpy-script.png?w=750 750w, /media/blog/observability-game/otel-alloy-mainpy-script.png?w=900 900w, /media /blog/observability-game/otel-alloy-mainpy-script.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-mainpy-script.png?w=1240 1240w, /媒体/博客/可观察性游戏/otel-alloy-mainpy-script.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;任务世界文本的屏幕截图。&#34;width=&#34;1999&#34;height=&#34;765&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/media/blog/observability-game/otel-alloy-mainpy-script.png&#34;&#xA;alt=&#34;任务世界文本的屏幕截图。&#34;width=&#34;1999&#34;height=&#34;765&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;乍一看可能很简单，但请注意你的可观察性仪表板，冒险家！这是您成功的秘诀。&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1999px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/observability-game/otel-alloy-demo-dashboard.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-demo-dashboard.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-demo-dashboard.png?w= 320 320w，/media/blog/observability-game/otel-alloy-demo-dashboard.png?w=550 550w， /media/blog/observability-game/otel-alloy-demo-dashboard.png?w=750 750w, /media/blog/observability-game/otel-alloy-demo-dashboard.png?w=900 900w, /media /blog/observability-game/otel-alloy-demo-dashboard.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-demo-dashboard.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-demo-dashboard.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Quest World 仪表板的屏幕截图。&#34;width=&#34;1999&#34;height=&#34;988&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/media/blog/observability-game/otel-alloy-demo-dashboard.png&#34;&#xA;alt=&#34;Quest World 仪表板的屏幕截图。&#34;width=&#34;1999&#34;height=&#34;988&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;goal&#34;&gt;目标&lt;/h3&gt;&#xA;&lt;p&gt;我们在创建游戏时的目标很简单：我们希望提供至少两个需要解决的挑战，同时学习可观察性数据类型的基础知识。例如，指标可以帮助您了解趋势并加快反应时间，而日志可以让您反思所做的决策，并可能找到终端内未找到的机制的秘密线索。&lt;/p&gt;&#xA;&lt;p&gt;这款冒险游戏建立在开放标准之上，并且具有高度可扩展性，因此您可以对其进行修改以满足您的学习（和教学）需求。例如，我们最近刚刚向冒险添加了痕迹，以生成游戏后排行榜（稍后将在博客中详细介绍）。&lt;/p&gt;&#xA;&lt;h3 id=&#34;setup&#34;&gt;设置&lt;/h3&gt;&#xA;&lt;p&gt;如果您想亲自尝试 Quest World，您可以选择以下两条路径：&lt;/p&gt;&#xA;&lt;h4 id=&#34;path-1-online-sandbox&#34;&gt;路径 1：在线沙箱&lt;/h4&gt;&#xA;&lt;p&gt;我们使用 Killercoda 创建了一个在线沙箱。这将启动一个独立的在线环境，这样您就可以玩游戏而不必担心依赖关系：&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://killercoda.com/grafana-labs/course/workshops/adventure&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;https://killercoda.com/grafana-labs/课程/研讨会/冒险&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;简单地说：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;点击链接&lt;/li&gt;&#xA;&lt;li&gt;创建一个免费的 Killercoda帐户&lt;/li&gt;&#xA;&lt;li&gt;让安装脚本运行&lt;/li&gt;&#xA;&lt;li&gt;按照左侧面板中的说明进行操作&lt;/li&gt;&#xA;&lt;li&gt;点击&lt;strong&gt;下一步&lt;/strong&gt;查看更多说明&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;path-2-run-the-adventure-locally&#34;&gt;路径 2：在本地运行冒险&lt;/h4&gt;&#xA;&lt;p&gt;该代码是完全开源的，可以在此 &lt;a href=&#34;https://github.com/grafana/adventure&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;GitHub 存储库&lt;/a&gt;中获取，因此你可以自己尝试，甚至扩展冒险。&lt;/p&gt;&#xA;&lt;p&gt;需要记住几个先决条件：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Docker 和 Docker Compose（已安装且最新）&lt;/li&gt;&#xA;&lt;li&gt;Python 3.12 或更高版本&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;按照&lt;a href=&#34;https://github.com/grafana/adventure/blob/main/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;README&lt;/a中概述的步骤操作&gt; 用于设置。&lt;/p&gt;&#xA;&lt;h2 id=&#34;creating-the-adventure&#34;&gt;创造冒险&lt;/h2&gt;&#xA;&lt;p&gt;那么，这一切是如何结合在一起的呢？事实上，一旦我们规划好架构，就很快了！我们来看看：&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1920px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/observability-game/otel-alloy-demo-architecture.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-demo-architecture.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-demo-architecture.png?w= 320 320w，/media/blog/observability-game/otel-alloy-demo-architecture.png?w=550 550w， /media/blog/observability-game/otel-alloy-demo-architecture.png?w=750 750w, /media/blog/observability-game/otel-alloy-demo-architecture.png?w=900 900w, /media /blog/observability-game/otel-alloy-demo-architecture.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-demo-architecture.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-demo-architecture.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Quest World 架构图。&#34;width=&#34;1920&#34;height=&#34;1080&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/media/blog/observability-game/otel-alloy-demo-architecture.png&#34;&#xA;alt=&#34;探索世界架构图。&#34;width=&#34;1920&#34;height=&#34;1080&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;adventurepy&#34;&gt;冒险.py&lt;/h3&gt;&#xA;&lt;p&gt;这是大多数混乱发生的地方。我应该指出，&lt;strong&gt;adventure.py&lt;/strong&gt;实际上代表了存储库中的&lt;strong&gt;ma​​in.py&lt;/strong&gt;和&lt;strong&gt;otel.py&lt;/strong&gt;。该代码通过定义封装所有游戏逻辑和状态管理的 AdventureGame 类来创建基于文本的冒险游戏。以下是游戏制作过程的详细说明：&lt;/p&gt;&#xA;&lt;h4 id=&#34;game-struct&#34;&gt;游戏结构&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;位置和操作在字典中定义，&lt;em&gt;&lt;strong&gt;self.locations&lt;/strong&gt;&lt;/em&gt;。每个位置都有描述、可用操作以及触发特定游戏逻辑的可选先决条件或效果。&lt;/li&gt;&#xA;&lt;li&gt;玩家在地点之间导航化，与角色和物品（如剑和铁匠铺）互动。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;player-actions&#34;&gt;玩家操作&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;诸如“请求剑”或“热锻造”之类的操作与作为方法实现的特定效果（例如 request_sword、heat_forge）相关联。&lt;/li&gt;&#xA;&lt;li&gt;每个操作都会检查条件（先决条件）并修改游戏状态变量，例如 &lt;em&gt;&lt;strong&gt;self.heat&lt;/strong&gt;&lt;/em&gt;、&lt;em&gt;&lt;strong&gt;self.has_sword&lt;/strong&gt;&lt; /em&gt;，或&lt;em&gt;&lt;strong&gt;self.blacksmith_burned_down&lt;/strong&gt;&lt;/em&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;branching-gameplay&#34;&gt;分支游戏&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;故事情节根据玩家的选择而演变，并通过状态变量（例如 self.quest_accepted、self.has_holy_sword）进行跟踪。&lt;/li&gt;&#xA;&lt;li&gt;决定会产生后果，例如锻造邪恶剑或圣剑，或影响与牧师、巫师或任务给予者互动的结果。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这一切都捆绑在一个基本循环中，该循环显示当前位置和可用操作，并处理玩家命令。&lt;/p&gt;&#xA;&lt;p&gt;好吧，那么，OpenTelemetry 是从哪里来的呢？&lt;/p&gt;&#xA;&lt;p&gt;我们决定使用 OTel SDK 实现每种遥测类型，因为它使我们能够统一每个遥测信号的实现（本质上，每个九头蛇头都来自同一个身体）。它还允许我们自定义许多这样的信号，以便我们可以添加有趣的冒险游戏日志。&lt;/p&gt;&#xA;&lt;p&gt;这就是它的工作原理：&lt;/p&gt;&#xA;&lt;h4 id=&#34;metrics&#34;&gt;指标&lt;/h4&gt;&#xA;&lt;表&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;定义&lt;/strong&gt;：指标跟踪数字数据，例如锻造厂的热度和锻造的剑数量。&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;实施：&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CustomMetrics 用于定义创建可观察量规的仪表。&lt;/li&gt;&#xA;&lt;li&gt;指标包括：&lt;/li&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;forge_heat：跟踪铁匠锻造厂的热度。&lt;/li&gt;&#xA;&lt;li&gt;剑：跟踪锻造剑的总数。&lt;/li&gt;&#xA;&lt;li&gt;holy_sword和evil_sword：监控附魔剑的状态。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;li&gt;仪表使用observe_forge_heat等回调函数根据游戏状态返回动态值。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/表&gt;&#xA;&lt;h4 id=&#34;logs&#34;&gt;日志&lt;/h4&gt;&#xA;&lt;表&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;定义&lt;/strong&gt;：日志捕获有关事件和玩家操作的文本信息，按严重性分类（信息、警告、错误、严重）。&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;实施：&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CustomLogFW 设置游戏日志记录。&lt;/li&gt;&#xA;&lt;li&gt;日志消息分布在整个代码中以捕获：&lt;/li&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;玩家的操作（例如，加热熔炉或索取剑）。&lt;/li&gt;&#xA;&lt;li&gt;重大事件，例如烧毁铁匠或制作魔法剑。&lt;/li&gt;&#xA;&lt;li&gt;当玩家做出错误决定时出现警告或错误，例如使熔炉过热或获得受诅咒的剑。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/表&gt;&#xA;&lt;h4 id=&#34;traces&#34;&gt;痕迹&lt;/h4&gt;&#xA;&lt;表&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;定义&lt;/strong&gt;：踪迹追踪玩家、队长所采取的行动流程处理每次交互的上下文元数据。&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;实施：&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CustomTracer 使用 OpenTelemetry 设置跟踪。&lt;/li&gt;&#xA;&lt;li&gt;根跨度跟踪玩家的整个旅程，而子跨度是为单个操作创建的（例如“操作：请求剑”）。&lt;/li&gt;&#xA;&lt;li&gt;跨度包括玩家姓名和当前位置等属性，以提供更多上下文。&lt;/li&gt;&#xA;&lt;li&gt;事件会添加到重要里程碑的跨度中（例如，锻造一把剑或杀死巫师）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/表&gt;&#xA;&lt;p&gt;正如您所看到的，我们的四个可观察九头蛇头中的三个在游戏中发挥着关键的想象作用，同时也忠于现实世界中的对应角色。下一个问题是所有这些遥测信号去了哪里？&lt;/p&gt;&#xA;&lt;h3 id=&#34;grafana-alloy&#34;&gt;格拉法纳合金&lt;/h3&gt;&#xA;&lt;p&gt;答案是任何你喜欢的地方，只要它与 OpenTelemetry 兼容。实际上，您会将其发送到某种形式的 &lt;a href=&#34;https://opentelemetry.io/docs/collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;OTel Collector&lt;/a&gt; 进行缓冲和可能进一步加工。我们选择使用 &lt;a href=&#34;/docs/alloy/latest/&#34;&gt;Grafana Alloy&lt;/a&gt;，这是 OTel Collector 的供应商中立发行版，因为它具有一些功能，使其成为出色的教学工具。&lt; /p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1200px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/observability-game/otel-alloy-demo-alloy-logo2.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-demo-alloy-logo2.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-demo-alloy-logo2. png?w=320 320w，/media/blog/observability-game/otel-alloy-demo-alloy-logo2.png?w=550 550w， /media/blog/observability-game/otel-alloy-demo-alloy-logo2.png?w=750 750w, /media/blog/observability-game/otel-alloy-demo-alloy-logo2.png?w=900 900w，/media/blog/observability-game/otel-alloy-demo-alloy-logo2.png?w=1040 1040w，/media/blog/observability-game/otel-alloy-demo-alloy-logo2.png?w=1240 1240w，/media/blog/observability-game/otel-alloy-demo-alloy-logo2.png?w =1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;任务世界中角色的屏幕截图。&#34;width=&#34;1200&#34;height=&#34;630&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/media/blog/observability-game/otel-alloy-demo-alloy-logo2.png&#34;&#xA;alt=&#34;任务世界中角色的屏幕截图。&#34;width=&#34;1200&#34;height=&#34;630&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h4 id=&#34;integrated-ui&#34;&gt;集成用户界面&lt;/h4&gt;&#xA;&lt;p&gt;与 Prometheus 一样，Grafana Alloy 具有集成的 UI，因此您可以直观地了解正在部署的配置和数据流。查看此关系图：&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1999px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;小时ref=&#34;/media/blog/observability-game/otel-alloy-integrated-ui.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-integrated-ui.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-integrated-ui.png?w= 320 320w，/media/blog/observability-game/otel-alloy-integrated-ui.png?w=550 550w， /media/blog/observability-game/otel-alloy-integrated-ui.png?w=750 750w, /media/blog/observability-game/otel-alloy-integrated-ui.png?w=900 900w, /media /blog/observability-game/otel-alloy-integrated-ui.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-integrated-ui.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-integrated-ui.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Grafana Alloy 集成 UI 的屏幕截图。&#34;width=&#34;1999&#34;height=&#34;1293&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/media/blog/observability-game/otel-alloy-integrated-ui.png&#34;&#xA;alt=&#34;Grafana Alloy 集成 UI 的屏幕截图。&#34;width=&#34;1999&#34;height=&#34;1293&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;您还可以了解组件配置设置以及管道的每个阶段是否正常。&lt;/p&gt;&#xA;&lt;h4 id=&#34;live-debugging&#34;&gt;实时调试&lt;/h4&gt;&#xA;&lt;p&gt;实时调试是另一个稍微更具实验性的功能，非常适合教学。这让您可以实时查看通过 Alloy 处理的遥测数据。&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1999px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/observability-game/otel-alloy-live-debugging.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-live-debugging.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-live-debugging.png?w= 320 320w，/media/blog/observability-game/otel-alloy-live-debugging.png?w=550 550w， /media/blog/observability-game/otel-alloy-live-debugging.png?w=750 750w, /media/blog/observability-game/otel-alloy-live-debugging.png?w=900 900w, /media /blog/observability-game/otel-alloy-live-debugging.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-live-debugging.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-live-debugging.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;实时调试功能的屏幕截图。&#34;width=&#34;1999&#34;height=&#34;664&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/media/blog/observability-game/otel-alloy-live-debugging.png&#34;&#xA;alt=&#34;实时调试功能的屏幕截图。&#34;width=&#34;1999&#34;height=&#34;664&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h2 id=&#34;telemetry-storage&#34;&gt;遥测存储&lt;/h2&gt;&#xA;&lt;p&gt;Quest World 使用三个存储后端：Prometheus（指标）、&lt;a href=&#34;/oss/loki/&#34;&gt;Grafana Loki&lt;/a&gt;（日志）和 &lt;a href=&#34;/oss/tempo/&#34;&gt; Grafana Tempo&lt;/a&gt;（痕迹）。所有这三个数据库都有一个关键特性：它们具有完全兼容的本机 OTel 端点。这允许我们将 OTel 格式数据 (OTLP) 直接写入我们的存储年龄选择的后端，让他们处理其余的。&lt;/p&gt;&#xA;&lt;p&gt;最好的部分是，当我们到达可观测性前端 Grafana 时，它可以让我们进行一些非常强大的分析，因为所有信号都共享相同的属性。&lt;/p&gt;&#xA;&lt;p&gt;所有三个数据库都以&lt;a href=&#34;/docs/loki/latest/get-started/deployment-modes/#monolithic-mode&#34;&gt;整体模式&lt;/a&gt;运行，您可以找到 docker-compose部署文件&lt;a href=&#34;https://github.com/grafana/adventure/blob/main/docker-compose.yml&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;此处&lt;/a&gt;。另外，这里是包含所有配置文件的参考表：&lt;/p&gt;&#xA;&lt;表&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;普罗米修斯&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;a href=&#34;https://github.com/grafana/adventure/blob/main/prometheus.yml&#34;&gt;https://github.com/grafana/adventure/blob/main/prometheus.yml&lt;/一个&gt;&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;洛基&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;a href=&#34;https://github.com/grafana/adventure/blob/main/loki-config.yaml&#34;&gt;https://github.com/grafana/adventure/blob/main/loki-config .yaml&lt;/a&gt;&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;节奏&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;a href=&#34;https://github.com/grafana/adventure/blob/main/tempo.yaml&#34;&gt;https://github.com/grafana/adventure/blob/main/tempo.yaml&lt;/一个&gt;&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/表&gt;&#xA;&lt;h2 id=&#34;grafana&#34;&gt;格拉法纳&lt;/h2&gt;&#xA;&lt;p&gt;当然，如果没有 Grafana，我们的冒险就不会完整，它是我们的主要游戏界面（除了文本冒险本身）。&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p w-100p”&#xA;样式=“最大宽度：500px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“lightbox-link w-fit mx-auto d-flex flex-direction-column”&#xA;href=&#34;/media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png w=320 320w, /media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png?w=550 550w, /media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png?w=750 750瓦， /media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png?w=900 900w, /media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png?w=1040 1040瓦， /media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png?w=1920 1920瓦”&#xA;data-sizes=&#34;auto&#34;alt=&#34;更改后的 Grafana 徽标。&#34;width=&#34;242&#34;height=&#34;256&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/media/blog/observability-game/otel-alloy-demo-grafana-logo_resized.png&#34;&#xA;alt=&#34;更改后的 Grafana 徽标。&#34;width=&#34;242&#34;height=&#34;256&#34;class=&#34;w-100p&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;Grafana 充当我们的：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;任务日志：通知用户在冒险过程中触发的事件。&lt;/li&gt;&#xA;&lt;li&gt;锻造监视器：对于锻造你自己的剑非常有用（眨眼，眨眼，轻推，轻推）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;您可以使用我们的&lt;a href=&#34;/blog/2024/09/24/queryless-metrics-logs-traces-profiles/&#34;&gt;探索应用程序&lt;/a&gt;以获取指标、日志和跟踪，或使用附带的仪表板。&lt;/p&gt;&#xA;&lt;p&gt;在用户完成游戏后，Grafana 还发挥另一个作用：它使用我们的痕迹可视化面板充当记分板。&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1999px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/observability-game/otel-alloy-leader-board.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-leader-board.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-leader-board.png?w= 320 320w，/media/blog/observability-game/otel-alloy-leader-board.png?w=550 550w， /media/blog/observability-game/otel-alloy-leader-board.png?w=750 750w, /media/blog/observability-game/otel-alloy-leader-board.png?w=900 900w, /media /blog/observability-game/otel-alloy-leader-board.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-leader-board.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-leader-board.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;排行榜截图。&#34;width=&#34;1999&#34;height=&#34;541&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/media/blog/observability-game/otel-alloy-leader-board.png&#34;&#xA;alt=&#34;排行榜截图。&#34;width=&#34;1999&#34;height=&#34;541&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;如果我失去了你，请让我解释一下。记分牌基于您完成游戏的速度。每个阶段都需要一定的时间才能完成。我们将每次游戏视为一条轨迹，将用户采取的每一步视为一个跨度。&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1999px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/observability-game/otel-alloy-traces.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-traces.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-traces.png?w=320 320w, /媒体/博客/observability-game/otel-alloy-traces.png?w=550 550w, /media/blog/observability-game/otel-alloy-traces.png?w=750 750w, /media/blog/observability-game/otel-alloy-traces.png?w=900 900w, /media/blog/observability -game/otel-alloy-traces.png?w=1040 1040w, /media/blog/observability-game/otel-alloy-traces.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-traces.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;痕迹截图。&#34;width=&#34;1999&#34;height=&#34;948&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/media/blog/observability-game/otel-alloy-traces.png&#34;&#xA;alt=&#34;痕迹截图。&#34;width=&#34;1999&#34;height=&#34;948&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;这也意味着我们可以在整个过程中留下一些简洁的元数据，例如跨度事件，以便您可以回顾您的冒险并了解您所做选择的含义。&lt;/p&gt;&#xA;&lt;h2 id=&#34;最后一个-Hydra-head-to slay&#34;&gt;最后一个要杀死的九头蛇头！&lt;/h2&gt;&#xA;&lt;p&gt;您可能已经注意到，我们尚未将连续分析作为此可观察性冒险的一部分。这里没有魔法或诡计——我们只是仍在寻找在游戏中表示个人资料的最佳方式。&lt;/p&gt;&#xA;&lt;p&gt;我们目前的想法是，也许可以让个人资料成为与巫师进行“最终boss”战斗的机制。在游戏的这个阶段，用户拥有三个生命和几个咒语选项。某些咒语可能需要更多的系统资源，特别是当它们一个接一个地使用时，这会让你容易受到巫师的攻击。这就是配置文件可以发挥作用的地方。&lt;/p&gt;&#xA;&lt;p&gt;如果您有任何想法，我们很乐意听取您的意见！请随时提出问题或 PR 来解释如何合并连续配置文件。&lt;/p&gt;&#xA;&lt;h2 id=&#34;did-someone-say-swag-easter-egg&#34;&gt;有人说“赃物复活节彩蛋”吗！？&lt;/h2&gt;&#xA;&lt;p&gt;如果游戏中没有隐藏复活节彩蛋，任何复古冒险游戏都会完整吗？&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p w-100p”&#xA;样式=“最大宽度：500px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“lightbox-link w-fit mx-auto d-flex flex-direction-column”&#xA;href=&#34;/media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png&#34;data-srcset=&#34;/media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png w=320 320w, /media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png?w=550 550w, /media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png?w=750 750瓦， /media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png?w=900 900w, /media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png?w=1040 1040瓦， /media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png?w=1240 1240w, /media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png?w=1920 1920瓦”&#xA;data-sizes=&#34;auto&#34;alt=&#34;鸡蛋的屏幕截图。&#34;width=&#34;150&#34;height=&#34;150&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/media/blog/observability-game/otel-alloy-demo-easter-egg_resized2.png&#34;&#xA;alt=&#34;鸡蛋的屏幕截图。&#34;width=&#34;150&#34;height=&#34;150&#34;class=&#34;w-100p&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;我们正在向前 10 名找到秘密复活节彩蛋的玩家赠送礼物（当你看到它时你就会知道）。只需通过我们的&lt;a href=&#34;https://slack.grafana.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;社区 Slack&lt;/a&gt; 将密码发送给我们任何一个人即可。&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-end-of-our-story-for-now&#34;&gt;我们的故事暂时结束&lt;/h2&gt;&#xA;&lt;p&gt;所以，勇敢的冒险家，我们的故事现在到此结束了。我们希望您在玩《探索世界》时能像我们构建它时一样享受乐趣。所有伟大的故事都从某个地方开始，我们希望看到冒险游戏能够通过我们出色的社区的新想法和公关来扩展。我们希望像 &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;OTel Demo&lt;/a&gt; 一样对待该项目，所以感觉自由地分叉它，改变它，并添加你的旋转。&lt;/p&gt;&#xA;&lt;p&gt;最后，提醒一下，我们将在 &lt;a href=&#34;/events/aws-reinvent/&#34;&gt;AWS re:Invent&lt;/a&gt; 演示游戏。请在以下时间段访问我们的 AWS 现代应用程序和开源专区，尝试一下这一可观测性冒险：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;12 月 3 日星期二下午 1 点至 2 点&lt;/li&gt;&#xA;&lt;li&gt;12 月 5 日星期四上午 11 点至中午 12 点&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
      <pubDate>Wed, 20 Nov 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【Exploring OpenTelemetry Collector configurations in Grafana Cloud: a tasting menu approach】探索 Grafana Cloud 中的 OpenTelemetry Collector 配置：品尝菜单方法</title>
      <link>https://grafana.com/blog/2024/11/27/exploring-opentelemetry-collector-configurations-in-grafana-cloud-a-tasting-menu-approach/</link>
      <description>【&lt;p&gt;I&amp;rsquo;m a big fan of &lt;a href=&#34;https://en.wikipedia.org/wiki/Tasting_menu&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;tasting menus&lt;/a&gt;. In the culinary world they let us sample a variety of dishes in small portions, helping us understand and appreciate different flavors and options.&lt;/p&gt;&#xA;&lt;p&gt;Inspired by this concept and a &lt;a href=&#34;https://github.com/jpkrohling/talks/tree/main/2024/2024-05-24-cncf-santa-catarina/receitas&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;talk I gave earlier this year&lt;/a&gt;, I have crafted a &amp;ldquo;tasting menu&amp;rdquo; of OpenTelemetry Collector configurations in Grafana Cloud. This blog post presents four distinct recipes, complete with code snippets and a GitHub repository for full examples and usage instructions, are each designed to introduce you to different aspects of telemetry data collection and management.&lt;/p&gt;&#xA;&lt;p&gt;Those recipes are part of a cookbook I &lt;a href=&#34;https://github.com/jpkrohling/otelcol-cookbook&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;keep on GitHub&lt;/a&gt;. So whether you are just starting with OpenTelemetry or looking to optimize your existing setup, these configurations will help you appreciate a good range of capabilities the OpenTelemetry Collector offers. So, as we say in Portuguese, bom apetite!&lt;/p&gt;&#xA;&lt;div class=&#34;br-4 base-border border-color-gray-3 docs_tabs&#34;&gt;&#xA;&lt;div x-data=&#34;app_content_tabs([&amp;#34;Appetizer&amp;#34;,&amp;#34;Main course 1&amp;#34;,&amp;#34;Main course 2&amp;#34;,&amp;#34;Dessert&amp;#34;], &#39;0446e2467d163ee15dde7ad691d3bfba&#39;)&#34; x-init=&#34;init()&#34;&gt;&#xA;&lt;div class=&#34;d-flex w-100p flex-direction-row align-items-center justify-content-flex-start d-md-none&#34;&gt;&#xA;&lt;select class=&#34;docs_tabs--select w-100p base-border-bottom border-color-gray-3&#34; @change=&#34;toggle($event.target.value)&#34;&gt;&#xA;&lt;option value=&#34;Appetizer&#34; :selected=&#34;active === &#39;Appetizer&#39;&#34;&gt;Appetizer&lt;/option&gt;&#xA;&lt;option value=&#34;Main course 1&#34; :selected=&#34;active === &#39;Main course 1&#39;&#34;&gt;Main course 1&lt;/option&gt;&#xA;&lt;option value=&#34;Main course 2&#34; :selected=&#34;active === &#39;Main course 2&#39;&#34;&gt;Main course 2&lt;/option&gt;&#xA;&lt;option value=&#34;Dessert&#34; :selected=&#34;active === &#39;Dessert&#39;&#34;&gt;Dessert&lt;/option&gt;&#xA;&lt;/select&gt;&#xA;&lt;/div&gt;&#xA;&lt;nav class=&#34;docs_tabs--navigation base-border-bottom border-color-gray-3 d-none d-md-block&#34; role=&#34;tablist&#34; data-codetoggle=&#34;true&#34;&gt;&#xA;&lt;button&#xA;class=&#34;docs_tabs--label f-14 bg-transparent color-gray-11 py-8 px-1&#34;&#xA;data-toggle=&#34;tab&#34;&#xA;role=&#34;tab&#34;&#xA;@click=&#34;toggle(&#39;Appetizer&#39;)&#34;&#xA;:class=&#34;{ &#39;docs_tabs--label-active&#39;: active === &#39;Appetizer&#39; }&#34;&#xA;&gt;&#xA;Appetizer&#xA;&lt;/button&gt;&#xA;&lt;button&#xA;class=&#34;docs_tabs--label f-14 bg-transparent color-gray-11 py-8 px-1&#34;&#xA;data-toggle=&#34;tab&#34;&#xA;role=&#34;tab&#34;&#xA;@click=&#34;toggle(&#39;Main course 1&#39;)&#34;&#xA;:class=&#34;{ &#39;docs_tabs--label-active&#39;: active === &#39;Main course 1&#39; }&#34;&#xA;&gt;&#xA;Main course 1&#xA;&lt;/button&gt;&#xA;&lt;button&#xA;class=&#34;docs_tabs--label f-14 bg-transparent color-gray-11 py-8 px-1&#34;&#xA;data-toggle=&#34;tab&#34;&#xA;role=&#34;tab&#34;&#xA;@click=&#34;toggle(&#39;Main course 2&#39;)&#34;&#xA;:class=&#34;{ &#39;docs_tabs--label-active&#39;: active === &#39;Main course 2&#39; }&#34;&#xA;&gt;&#xA;Main course 2&#xA;&lt;/button&gt;&#xA;&lt;button&#xA;class=&#34;docs_tabs--label f-14 bg-transparent color-gray-11 py-8 px-1&#34;&#xA;data-toggle=&#34;tab&#34;&#xA;role=&#34;tab&#34;&#xA;@click=&#34;toggle(&#39;Dessert&#39;)&#34;&#xA;:class=&#34;{ &#39;docs_tabs--label-active&#39;: active === &#39;Dessert&#39; }&#34;&#xA;&gt;&#xA;Dessert&#xA;&lt;/button&gt;&#xA;&lt;/nav&gt;&#xA;&lt;div class=&#34;docs_tabs--content-container&#34;&gt;&#xA;&lt;div&#xA;class=&#34;docs_tabs--content py-1 px-2&#34;&#xA;:class=&#34;active === &#39;Appetizer&#39; ? &#39;d-block&#39; : &#39;d-none&#39;&#34;&#xA;id=&#34;&#34;&#xA;role=&#34;tabpanel&#34;&#xA;aria-labelledby=&#34;&#34;&#xA;&gt;&#xA;&lt;h2 id=&#34;internal-telemetry-salad&#34;&gt;Internal telemetry salad&lt;/h2&gt;&#xA;&lt;p&gt;We start with a light yet informative configuration that involves sending the Collector&amp;rsquo;s own internal telemetry data to external storage. This dish will help you understand how to extract and read internal telemetry data from the Collector, including metrics and traces.&lt;/p&gt;&#xA;&lt;p&gt;In this configuration, we create one pipeline for each signal type and use the same receiver and exporter for all of them. However, we need to use the debug exporter, as we are not interested in the telemetry that comes to the Collector; we are interested in the telemetry that is generated &lt;em&gt;by&lt;/em&gt; the Collector.&lt;/p&gt;&#xA;&lt;p&gt;Under &lt;code&gt;service::telemetry&lt;/code&gt;, we configure how to send the internal traces and metrics to an external OpenTelemetry protocol (OTLP) endpoint. In this case, we are using the OTLP endpoint for a &lt;a href=&#34;/products/cloud/pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt; instance, obtained from the “OpenTelemetry Configuration” page, which can be found on your “Manage your stack” page.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1236px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/tasting-menu/manage-your-stack.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/tasting-menu/manage-your-stack.png&#34;data-srcset=&#34;/media/blog/tasting-menu/manage-your-stack.png?w=320 320w, /media/blog/tasting-menu/manage-your-stack.png?w=550 550w, /media/blog/tasting-menu/manage-your-stack.png?w=750 750w, /media/blog/tasting-menu/manage-your-stack.png?w=900 900w, /media/blog/tasting-menu/manage-your-stack.png?w=1040 1040w, /media/blog/tasting-menu/manage-your-stack.png?w=1240 1240w, /media/blog/tasting-menu/manage-your-stack.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Manage your stack page in the Grafana Cloud UI&#34;width=&#34;1236&#34;height=&#34;809&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/tasting-menu/manage-your-stack.png&#34;&#xA;alt=&#34;Manage your stack page in the Grafana Cloud UI&#34;width=&#34;1236&#34;height=&#34;809&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;Also on that page, we can look at the environment variable &lt;code&gt;OTEL_EXPORTER_OTLP_HEADERS&lt;/code&gt; that is shown after generating a token. Keep this handy, as we&amp;rsquo;ll need the value of the Authorization header later.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1529px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/tasting-menu/environment-variables.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/tasting-menu/environment-variables.png&#34;data-srcset=&#34;/media/blog/tasting-menu/environment-variables.png?w=320 320w, /media/blog/tasting-menu/environment-variables.png?w=550 550w, /media/blog/tasting-menu/environment-variables.png?w=750 750w, /media/blog/tasting-menu/environment-variables.png?w=900 900w, /media/blog/tasting-menu/environment-variables.png?w=1040 1040w, /media/blog/tasting-menu/environment-variables.png?w=1240 1240w, /media/blog/tasting-menu/environment-variables.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of Environmental Variables code&#34;width=&#34;1529&#34;height=&#34;478&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/tasting-menu/environment-variables.png&#34;&#xA;alt=&#34;A screenshot of Environmental Variables code&#34;width=&#34;1529&#34;height=&#34;478&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;ingredients&#34;&gt;Ingredients&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;An OpenTelemetry Collector distribution that is able to ingest OTLP data via gRPC, and export data with the debug exporter. I used &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-releases/releases/tag/v0.113.0&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;OTel Collector Contrib v0.113.0&lt;/a&gt; for this blog post.&lt;/li&gt;&#xA;&lt;li&gt;An application that can generate OTLP data, such as &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/cmd/telemetrygen&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;telemetrygen&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;A configuration file with the &lt;code&gt;service::telemetry&lt;/code&gt; section properly configured&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;configuration-example&#34;&gt;Configuration example&lt;/h3&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;receivers:&#xA;otlp:&#xA;protocols:&#xA;http:&#xA;grpc:&#xA;exporters:&#xA;debug:&#xA;service:&#xA;pipelines:&#xA;traces:&#xA;receivers: [otlp]&#xA;exporters: [debug]&#xA;metrics:&#xA;receivers: [otlp]&#xA;exporters: [debug]&#xA;logs:&#xA;receivers: [otlp]&#xA;exporters: [debug]&#xA;telemetry:&#xA;traces:&#xA;processors:&#xA;- batch:&#xA;schedule_delay: 1000&#xA;exporter:&#xA;otlp:&#xA;endpoint: https://otlp-gateway-prod-eu-west-2.grafana.net/otlp/v1/traces&#xA;protocol: http/protobuf&#xA;headers:&#xA;Authorization: &amp;#34;Basic ...&amp;#34;&#xA;metrics:&#xA;level: detailed&#xA;readers:&#xA;- periodic:&#xA;exporter:&#xA;otlp:&#xA;endpoint: https://otlp-gateway-prod-eu-west-2.grafana.net/otlp/v1/metrics&#xA;protocol: http/protobuf&#xA;headers:&#xA;Authorization: &amp;#34;Basic ...&amp;#34;&#xA;resource:&#xA;&amp;#34;service.name&amp;#34;: &amp;#34;otelcol-own-telemetry&amp;#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;preparation&#34;&gt;Preparation&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Change the configuration file to include the correct value for the &lt;code&gt;Basic&lt;/code&gt; authentication header and endpoint&lt;/li&gt;&#xA;&lt;li&gt;Run the OpenTelemetry Collector:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;otelcol-contrib --config ./otelcol.yaml&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;Send some telemetry to the Collector. By default, each trace reported by &lt;code&gt;telemetrygen&lt;/code&gt; comes with two spans. Note that this telemetry will be discarded with the configuration provided, but the actions the Collector performed will be recorded:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;telemetrygen traces --traces 1 --otlp-insecure --otlp-attributes=&amp;#39;cookbook=&amp;#34;own-telemetry&amp;#34;&amp;#39;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;On Grafana Cloud, select the traces data source and you’ll be able to find a trace that represents the Collector processing of the &lt;code&gt;telemetrygen&lt;/code&gt; call:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1277px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/tasting-menu/traces-data.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/tasting-menu/traces-data.png&#34;data-srcset=&#34;/media/blog/tasting-menu/traces-data.png?w=320 320w, /media/blog/tasting-menu/traces-data.png?w=550 550w, /media/blog/tasting-menu/traces-data.png?w=750 750w, /media/blog/tasting-menu/traces-data.png?w=900 900w, /media/blog/tasting-menu/traces-data.png?w=1040 1040w, /media/blog/tasting-menu/traces-data.png?w=1240 1240w, /media/blog/tasting-menu/traces-data.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of a TraceQL query in Grafana Cloud&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/tasting-menu/traces-data.png&#34;&#xA;alt=&#34;A screenshot of a TraceQL query in Grafana Cloud&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;ol start=&#34;5&#34;&gt;&#xA;&lt;li&gt;Now, change to your metrics data source, and select the metric &lt;code&gt;otelcol_exporter_sent_spans_total&lt;/code&gt;. We can see that our Collector reported that it received the two spans.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1277px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/tasting-menu/two-spans.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/tasting-menu/two-spans.png&#34;data-srcset=&#34;/media/blog/tasting-menu/two-spans.png?w=320 320w, /media/blog/tasting-menu/two-spans.png?w=550 550w, /media/blog/tasting-menu/two-spans.png?w=750 750w, /media/blog/tasting-menu/two-spans.png?w=900 900w, /media/blog/tasting-menu/two-spans.png?w=1040 1040w, /media/blog/tasting-menu/two-spans.png?w=1240 1240w, /media/blog/tasting-menu/two-spans.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of the query UI in Grafana Cloud&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/tasting-menu/two-spans.png&#34;&#xA;alt=&#34;A screenshot of the query UI in Grafana Cloud&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;tasting-notes&#34;&gt;Tasting notes&lt;/h3&gt;&#xA;&lt;p&gt;We&amp;rsquo;ve now seen that we can observe the Collector to understand what it is doing—we have easy access to its metrics and traces. But what about the logs?&lt;/p&gt;&#xA;&lt;p&gt;For the moment, the logs are available only on the console and should be captured separately. Avoid the temptation to use a file log receiver to read the instance’s own log. It might cause an endless loop of events and violates the principle that software should NOT monitor itself.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div&#xA;class=&#34;docs_tabs--content py-1 px-2&#34;&#xA;:class=&#34;active === &#39;Main course 1&#39; ? &#39;d-block&#39; : &#39;d-none&#39;&#34;&#xA;id=&#34;&#34;&#xA;role=&#34;tabpanel&#34;&#xA;aria-labelledby=&#34;&#34;&#xA;&gt;&#xA;&lt;h2 id=&#34;mixed-events-and-metrics&#34;&gt;Mixed events and metrics&lt;/h2&gt;&#xA;&lt;p&gt;Our first main course features a ratatouille of events and metrics from a Kubernetes cluster. The Collector is provisioned by the OpenTelemetry Operator, running in a Kubernetes cluster in &amp;ldquo;deployment&amp;rdquo; mode, and adheres to the &lt;a href=&#34;https://opentelemetry.io/docs/specs/otel/metrics/data-model/#single-writer&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Single Writer Principle&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h3 id=&#34;ingredients&#34;&gt;Ingredients&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A Kubernetes cluster, such as one provisioned locally via k3d&lt;/li&gt;&#xA;&lt;li&gt;The OpenTelemetry Operator running in the cluster&lt;/li&gt;&#xA;&lt;li&gt;Your Grafana Cloud credentials in a Kubernetes secret&lt;/li&gt;&#xA;&lt;li&gt;A Collector configuration using the &lt;code&gt;k8s_cluster&lt;/code&gt; and &lt;code&gt;k8s_events&lt;/code&gt; receivers&lt;/li&gt;&#xA;&lt;li&gt;A workload that would generate a few Kubernetes events&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;kubens&lt;/code&gt; from the &lt;a href=&#34;https://github.com/ahmetb/kubectx&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;kubectx&lt;/code&gt;&lt;/a&gt; project&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;configuration-example&#34;&gt;Configuration example&lt;/h3&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt; extensions:&#xA;basicauth:&#xA;client_auth:&#xA;username: &amp;#34;${env:GRAFANA_CLOUD_USER}&amp;#34;&#xA;password: &amp;#34;${env:GRAFANA_CLOUD_TOKEN}&amp;#34;&#xA;receivers:&#xA;k8s_events: {}&#xA;k8s_cluster:&#xA;collection_interval: 15s&#xA;exporters:&#xA;otlphttp:&#xA;endpoint: https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;auth:&#xA;authenticator: basicauth&#xA;service:&#xA;extensions: [ basicauth ]&#xA;pipelines:&#xA;metrics:&#xA;receivers: [ k8s_cluster ]&#xA;exporters: [ otlphttp ]&#xA;logs:&#xA;receivers: [ k8s_events ]&#xA;exporters: [ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;preparation&#34;&gt;Preparation&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Make sure you have a running Kubernetes cluster and OpenTelemetry Operator configured, and that you have your context set to the &lt;code&gt;observability&lt;/code&gt; namespace. If you don’t know how to start, you can try these commands for a local setup:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;k3d cluster create&#xA;kubectl apply -f https://github.com/cert-manager/cert-manager/releases/latest/download/cert-manager.yaml&#xA;kubectl wait --for=condition=Available deployments/cert-manager -n cert-manager&#xA;kubectl apply -f https://github.com/open-telemetry/opentelemetry-operator/releases/latest/download/opentelemetry-operator.yaml&#xA;kubectl wait --for=condition=Available deployments/opentelemetry-operator-controller-manager -n opentelemetry-operator-system&#xA;kubectl create namespace observability&#xA;kubens observability&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;Create a secret with your Grafana Cloud credentials. In this example, we have them already set as env vars; replace them appropriately.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;kubectl create secret generic grafana-cloud-credentials \&#xA;--from-literal=GRAFANA_CLOUD_USER=&amp;#34;$GRAFANA_CLOUD_USER&amp;#34; \&#xA;--from-literal=GRAFANA_CLOUD_TOKEN=&amp;#34;$GRAFANA_CLOUD_TOKEN&amp;#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;We’ll now create a &lt;code&gt;ClusterRole&lt;/code&gt; for our Collector:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;apiVersion: rbac.authorization.k8s.io/v1&#xA;kind: ClusterRole&#xA;metadata:&#xA;name: otelcol&#xA;rules:&#xA;- apiGroups:&#xA;- &amp;#34;&amp;#34;&#xA;resources:&#xA;- events&#xA;- namespaces&#xA;- namespaces/status&#xA;- nodes&#xA;- nodes/spec&#xA;- pods&#xA;- pods/status&#xA;- replicationcontrollers&#xA;- replicationcontrollers/status&#xA;- resourcequotas&#xA;- services&#xA;verbs:&#xA;- get&#xA;- list&#xA;- watch&#xA;- apiGroups:&#xA;- apps&#xA;resources:&#xA;- daemonsets&#xA;- deployments&#xA;- replicasets&#xA;- statefulsets&#xA;verbs:&#xA;- get&#xA;- list&#xA;- watch&#xA;- apiGroups:&#xA;- extensions&#xA;resources:&#xA;- daemonsets&#xA;- deployments&#xA;- replicasets&#xA;verbs:&#xA;- get&#xA;- list&#xA;- watch&#xA;- apiGroups:&#xA;- batch&#xA;resources:&#xA;- jobs&#xA;- cronjobs&#xA;verbs:&#xA;- get&#xA;- list&#xA;- watch&#xA;- apiGroups:&#xA;- autoscaling&#xA;resources:&#xA;- horizontalpodautoscalers&#xA;verbs:&#xA;- get&#xA;- list&#xA;- watch&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;We’ll create a &lt;code&gt;ServiceAccount&lt;/code&gt; that will be used by our Collector instance, and we’ll bind the cluster role to the account:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;apiVersion: v1&#xA;kind: ServiceAccount&#xA;metadata:&#xA;name: otelcol-k8s&#xA;namespace: observability&#xA;---&#xA;apiVersion: rbac.authorization.k8s.io/v1&#xA;kind: ClusterRoleBinding&#xA;metadata:&#xA;name: otelcol&#xA;roleRef:&#xA;apiGroup: rbac.authorization.k8s.io&#xA;kind: ClusterRole&#xA;name: otelcol&#xA;subjects:&#xA;- kind: ServiceAccount&#xA;name: otelcol-k8s&#xA;namespace: observability&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;5&#34;&gt;&#xA;&lt;li&gt;We’ll now configure our Collector to obtain metrics and events (as logs) from the Kubernetes cluster.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;apiVersion: opentelemetry.io/v1beta1&#xA;kind: OpenTelemetryCollector&#xA;metadata:&#xA;name: otelcol-k8s&#xA;namespace: observability&#xA;spec:&#xA;image: ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector-contrib:0.113.0&#xA;serviceAccount: otelcol-k8s&#xA;envFrom:&#xA;- secretRef:&#xA;name: grafana-cloud-credentials&#xA;config:&#xA;extensions:&#xA;basicauth:&#xA;client_auth:&#xA;username: &amp;#34;${env:GRAFANA_CLOUD_USER}&amp;#34;&#xA;password: &amp;#34;${env:GRAFANA_CLOUD_TOKEN}&amp;#34;&#xA;receivers:&#xA;k8s_events: {}&#xA;k8s_cluster:&#xA;collection_interval: 15s&#xA;exporters:&#xA;otlphttp:&#xA;endpoint: https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;auth:&#xA;authenticator: basicauth&#xA;service:&#xA;extensions: [ basicauth ]&#xA;pipelines:&#xA;metrics:&#xA;receivers: [ k8s_cluster ]&#xA;exporters: [ otlphttp ]&#xA;logs:&#xA;receivers: [ k8s_events ]&#xA;exporters: [ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;If you don’t have a workload running in your Kubernetes cluster, this one should be enough to generate a few events.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;apiVersion: apps/v1&#xA;kind: Deployment&#xA;metadata:&#xA;name: nginx-deployment&#xA;spec:&#xA;selector:&#xA;matchLabels:&#xA;app: nginx&#xA;template:&#xA;metadata:&#xA;labels:&#xA;app: nginx&#xA;spec:&#xA;containers:&#xA;- name: nginx&#xA;image: nginx:1.27.2&#xA;ports:&#xA;- containerPort: 80&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;6&#34;&gt;&#xA;&lt;li&gt;At this point, you should have received a few events in your Grafana Cloud instance.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1277px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/tasting-menu/cloud-logs.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/tasting-menu/cloud-logs.png&#34;data-srcset=&#34;/media/blog/tasting-menu/cloud-logs.png?w=320 320w, /media/blog/tasting-menu/cloud-logs.png?w=550 550w, /media/blog/tasting-menu/cloud-logs.png?w=750 750w, /media/blog/tasting-menu/cloud-logs.png?w=900 900w, /media/blog/tasting-menu/cloud-logs.png?w=1040 1040w, /media/blog/tasting-menu/cloud-logs.png?w=1240 1240w, /media/blog/tasting-menu/cloud-logs.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Events populating in Grafana Cloud&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/tasting-menu/cloud-logs.png&#34;&#xA;alt=&#34;Events populating in Grafana Cloud&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Kubernetes metrics, such as &lt;code&gt;k8s_container_ready&lt;/code&gt;, should also be available.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1277px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/tasting-menu/k8s-metrics.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/tasting-menu/k8s-metrics.png&#34;data-srcset=&#34;/media/blog/tasting-menu/k8s-metrics.png?w=320 320w, /media/blog/tasting-menu/k8s-metrics.png?w=550 550w, /media/blog/tasting-menu/k8s-metrics.png?w=750 750w, /media/blog/tasting-menu/k8s-metrics.png?w=900 900w, /media/blog/tasting-menu/k8s-metrics.png?w=1040 1040w, /media/blog/tasting-menu/k8s-metrics.png?w=1240 1240w, /media/blog/tasting-menu/k8s-metrics.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Metrics populating a graph in the Grafana UI&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/tasting-menu/k8s-metrics.png&#34;&#xA;alt=&#34;Metrics populating a graph in the Grafana UI&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;tasting-notes&#34;&gt;Tasting notes&lt;/h3&gt;&#xA;&lt;p&gt;We just had a small taste of what those components can do, and this left us with enough information to explore this idea further: which metrics could be interesting for us to watch? How can we combine metrics to tell a story? That’s where we can go from here.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div&#xA;class=&#34;docs_tabs--content py-1 px-2&#34;&#xA;:class=&#34;active === &#39;Main course 2&#39; ? &#39;d-block&#39; : &#39;d-none&#39;&#34;&#xA;id=&#34;&#34;&#xA;role=&#34;tabpanel&#34;&#xA;aria-labelledby=&#34;&#34;&#xA;&gt;&#xA;&lt;h2 id=&#34;bibimbap-of-logs&#34;&gt;Bibimbap of logs&lt;/h2&gt;&#xA;&lt;p&gt;The second main course explores a Collector configured in &amp;ldquo;daemonset&amp;rdquo; mode to collect an assortment of logs from pods running on the same node, potentially following different formats and from various namespaces. This configuration emphasizes placing the Collector close to the telemetry source.&lt;/p&gt;&#xA;&lt;h3 id=&#34;ingredients&#34;&gt;Ingredients&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A Kubernetes cluster, like in the previous recipe&lt;/li&gt;&#xA;&lt;li&gt;The OpenTelemetry Operator running in the cluster&lt;/li&gt;&#xA;&lt;li&gt;Your Grafana Cloud credentials in a Kubernetes secret&lt;/li&gt;&#xA;&lt;li&gt;A Collector configuration using the &lt;code&gt;k8s_cluster&lt;/code&gt; and &lt;code&gt;k8s_events&lt;/code&gt; receivers&lt;/li&gt;&#xA;&lt;li&gt;A workload that would generate a few Kubernetes events&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;configuration-example&#34;&gt;Configuration example&lt;/h3&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt; extensions:&#xA;basicauth:&#xA;client_auth:&#xA;username: &amp;#34;${env:GRAFANA_CLOUD_USER}&amp;#34;&#xA;password: &amp;#34;${env:GRAFANA_CLOUD_TOKEN}&amp;#34;&#xA;receivers:&#xA;filelog:&#xA;exclude: []&#xA;include:&#xA;- /var/log/pods/*/*/*.log&#xA;include_file_name: false&#xA;include_file_path: true&#xA;operators:&#xA;- id: container-parser&#xA;max_log_size: 102400&#xA;type: container&#xA;retry_on_failure:&#xA;enabled: true&#xA;start_at: end&#xA;exporters:&#xA;otlphttp:&#xA;endpoint: https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;auth:&#xA;authenticator: basicauth&#xA;service:&#xA;extensions: [ basicauth ]&#xA;pipelines:&#xA;logs:&#xA;receivers: [ filelog ]&#xA;exporters: [ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;preparation&#34;&gt;Preparation&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Make sure you have a Kubernetes cluster and an OTel Operator running. Feel free to reuse the one you configured in the previous recipe.&lt;/li&gt;&#xA;&lt;li&gt;Next, create a custom resource with the following configuration.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;apiVersion: opentelemetry.io/v1beta1&#xA;kind: OpenTelemetryCollector&#xA;metadata:&#xA;name: otelcol-podslogs&#xA;namespace: observability&#xA;spec:&#xA;image: ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector-contrib:0.113.0&#xA;mode: daemonset&#xA;envFrom:&#xA;- secretRef:&#xA;name: grafana-cloud-credentials&#xA;volumes:&#xA;- name: varlogpods&#xA;hostPath:&#xA;path: /var/log/pods&#xA;volumeMounts:&#xA;- name: varlogpods&#xA;mountPath: /var/log/pods&#xA;readOnly: true&#xA;config:&#xA;extensions:&#xA;basicauth:&#xA;client_auth:&#xA;username: &amp;#34;${env:GRAFANA_CLOUD_USER}&amp;#34;&#xA;password: &amp;#34;${env:GRAFANA_CLOUD_TOKEN}&amp;#34;&#xA;receivers:&#xA;filelog:&#xA;exclude: []&#xA;include:&#xA;- /var/log/pods/*/*/*.log&#xA;include_file_name: false&#xA;include_file_path: true&#xA;operators:&#xA;- id: container-parser&#xA;max_log_size: 102400&#xA;type: container&#xA;retry_on_failure:&#xA;enabled: true&#xA;start_at: end&#xA;exporters:&#xA;otlphttp:&#xA;endpoint: https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;auth:&#xA;authenticator: basicauth&#xA;service:&#xA;extensions: [ basicauth ]&#xA;pipelines:&#xA;logs:&#xA;receivers: [ filelog ]&#xA;exporters: [ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;After a few moments, you should start seeing logs from the containers in the cluster.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1261px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/tasting-menu/cloud-logs-2.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/tasting-menu/cloud-logs-2.png&#34;data-srcset=&#34;/media/blog/tasting-menu/cloud-logs-2.png?w=320 320w, /media/blog/tasting-menu/cloud-logs-2.png?w=550 550w, /media/blog/tasting-menu/cloud-logs-2.png?w=750 750w, /media/blog/tasting-menu/cloud-logs-2.png?w=900 900w, /media/blog/tasting-menu/cloud-logs-2.png?w=1040 1040w, /media/blog/tasting-menu/cloud-logs-2.png?w=1240 1240w, /media/blog/tasting-menu/cloud-logs-2.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Grafana Cloud Logs query&#34;width=&#34;1261&#34;height=&#34;680&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/tasting-menu/cloud-logs-2.png&#34;&#xA;alt=&#34;Grafana Cloud Logs query&#34;width=&#34;1261&#34;height=&#34;680&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;tasting-notes&#34;&gt;Tasting notes&lt;/h3&gt;&#xA;&lt;p&gt;Logs are umami-rich telemetry data points, exploring all possible tastes we can have: workload- or infra-related, from debug to critical, structured or unstructured. At this point, we&amp;rsquo;ve covered enough to get you longing for more. And now you&amp;rsquo;re read to ask: Which rules can you add to your configuration to enrich the metadata better?&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div&#xA;class=&#34;docs_tabs--content py-1 px-2&#34;&#xA;:class=&#34;active === &#39;Dessert&#39; ? &#39;d-block&#39; : &#39;d-none&#39;&#34;&#xA;id=&#34;&#34;&#xA;role=&#34;tabpanel&#34;&#xA;aria-labelledby=&#34;&#34;&#xA;&gt;&#xA;&lt;h2 id=&#34;kafka-buffer-with-two-collector-layers&#34;&gt;Kafka buffer with two Collector layers&lt;/h2&gt;&#xA;&lt;p&gt;For dessert, we present a sophisticated configuration involving a Kafka buffer with two layers of Collectors—appreciated in highly scalable scenarios for its ability to handle a spike in telemetry volume without stressing the backend or affecting the ingestion layer.&lt;/p&gt;&#xA;&lt;p&gt;The first layer collects telemetry from business services running in Kubernetes and publishes it to a Kafka topic. The second layer consumes these events and sends them to the telemetry storage.&lt;/p&gt;&#xA;&lt;h3 id=&#34;ingredients&#34;&gt;Ingredients&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A Kubernetes cluster, like in the previous recipe&lt;/li&gt;&#xA;&lt;li&gt;The OpenTelemetry Operator running in the cluster&lt;/li&gt;&#xA;&lt;li&gt;Your Grafana Cloud credentials in a Kubernetes secret&lt;/li&gt;&#xA;&lt;li&gt;A Kafka cluster and one topic for each telemetry data type (metric, logs, traces)&lt;/li&gt;&#xA;&lt;li&gt;The &lt;code&gt;telemetrygen&lt;/code&gt; tool, or any other application that is able to send OTLP data to our collector&lt;/li&gt;&#xA;&lt;li&gt;Two Collectors, one configured to publish data to the topic, and one consuming the events&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;configuration-examples&#34;&gt;Configuration examples&lt;/h3&gt;&#xA;&lt;h4 id=&#34;publisher&#34;&gt;Publisher&lt;/h4&gt;&#xA;&lt;p&gt;This is the configuration we’ll use for the &lt;code&gt;otelcol-pub&lt;/code&gt; Collector, responsible for publishing to the queue:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt; receivers:&#xA;otlp:&#xA;protocols:&#xA;http: {}&#xA;grpc: {}&#xA;processors:&#xA;transform:&#xA;error_mode: ignore&#xA;trace_statements:&#xA;- context: span&#xA;statements:&#xA;- set(attributes[&amp;#34;published_at&amp;#34;], UnixMilli(Now()))&#xA;exporters:&#xA;kafka:&#xA;protocol_version: 2.0.0&#xA;brokers: kafka-for-otelcol-kafka-brokers.kafka.svc.cluster.local:9092&#xA;topic: otlp-spans&#xA;service:&#xA;pipelines:&#xA;traces:&#xA;receivers: [ otlp ]&#xA;processors: [ transform ]&#xA;exporters: [ kafka ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h4 id=&#34;consumer&#34;&gt;Consumer&lt;/h4&gt;&#xA;&lt;p&gt;This is the configuration we’ll use for the &lt;code&gt;otelcol-sub&lt;/code&gt; Collector, responsible for reading from the queue and writing to our Grafana Cloud instance:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;extensions:&#xA;basicauth:&#xA;client_auth:&#xA;username: &amp;#34;${env:GRAFANA_CLOUD_USER}&amp;#34;&#xA;password: &amp;#34;${env:GRAFANA_CLOUD_TOKEN}&amp;#34;&#xA;receivers:&#xA;kafka:&#xA;protocol_version: 2.0.0&#xA;brokers: kafka-for-otelcol-kafka-brokers.kafka.svc.cluster.local:9092&#xA;topic: otlp-spans&#xA;processors:&#xA;transform:&#xA;error_mode: ignore&#xA;trace_statements:&#xA;- context: span&#xA;statements:&#xA;- set(attributes[&amp;#34;consumed_at&amp;#34;], UnixMilli(Now()))&#xA;exporters:&#xA;otlphttp:&#xA;endpoint: https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;auth:&#xA;authenticator: basicauth&#xA;service:&#xA;extensions: [ basicauth ]&#xA;pipelines:&#xA;traces:&#xA;receivers: [ kafka ]&#xA;processors: [ transform ]&#xA;exporters: [ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;preparation&#34;&gt;Preparation&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Install &lt;a href=&#34;https://strimzi.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Strimzi&lt;/a&gt;, a Kubernetes Operator for Kafka.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;kubectl create ns kafka&#xA;kubens kafka&#xA;kubectl create -f &amp;#39;https://strimzi.io/install/latest?namespace=kafka&amp;#39;&#xA;kubectl wait --for=condition=Available deployments/strimzi-cluster-operator --timeout=300s&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;Install the Kafka cluster and topics for our recipe.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;apiVersion: kafka.strimzi.io/v1beta2&#xA;kind: KafkaNodePool&#xA;metadata:&#xA;name: dual-role&#xA;labels:&#xA;strimzi.io/cluster: kafka-for-otelcol&#xA;spec:&#xA;replicas: 1&#xA;roles:&#xA;- controller&#xA;- broker&#xA;storage:&#xA;type: jbod&#xA;volumes:&#xA;- id: 0&#xA;type: persistent-claim&#xA;size: 100Gi&#xA;deleteClaim: false&#xA;kraftMetadata: shared&#xA;---&#xA;apiVersion: kafka.strimzi.io/v1beta2&#xA;kind: Kafka&#xA;metadata:&#xA;name: kafka-for-otelcol&#xA;annotations:&#xA;strimzi.io/node-pools: enabled&#xA;strimzi.io/kraft: enabled&#xA;spec:&#xA;kafka:&#xA;version: 3.7.0&#xA;metadataVersion: 3.7-IV4&#xA;config:&#xA;offsets.topic.replication.factor: 1&#xA;transaction.state.log.replication.factor: 1&#xA;transaction.state.log.min.isr: 1&#xA;default.replication.factor: 1&#xA;min.insync.replicas: 1&#xA;listeners:&#xA;- name: plain&#xA;port: 9092&#xA;type: internal&#xA;tls: false&#xA;---&#xA;apiVersion: kafka.strimzi.io/v1beta2&#xA;kind: KafkaTopic&#xA;metadata:&#xA;name: otlp-spans&#xA;labels:&#xA;strimzi.io/cluster: kafka-for-otelcol&#xA;---&#xA;apiVersion: kafka.strimzi.io/v1beta2&#xA;kind: KafkaTopic&#xA;metadata:&#xA;name: otlp-metrics&#xA;labels:&#xA;strimzi.io/cluster: kafka-for-otelcol&#xA;---&#xA;apiVersion: kafka.strimzi.io/v1beta2&#xA;kind: KafkaTopic&#xA;metadata:&#xA;name: otlp-logs&#xA;labels:&#xA;strimzi.io/cluster: kafka-for-otelcol&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;It might take a while for the topics to be ready. Watch the status of the following custom resource before proceeding: &lt;code&gt;kafka/kafka-for-otelcol&lt;/code&gt;. Once it’s marked as &lt;code&gt;Ready&lt;/code&gt;, continue with the next step.&lt;/li&gt;&#xA;&lt;li&gt;Go back to the &lt;code&gt;observability&lt;/code&gt;namespace.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;kubens observability&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;5&#34;&gt;&#xA;&lt;li&gt;Create the Collector that will receive data from the workloads and publish to the topic&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;apiVersion: opentelemetry.io/v1beta1&#xA;kind: OpenTelemetryCollector&#xA;metadata:&#xA;name: otelcol-pub&#xA;spec:&#xA;image: ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector-contrib:0.113.0&#xA;config:&#xA;receivers:&#xA;otlp:&#xA;protocols:&#xA;http: {}&#xA;grpc: {}&#xA;processors:&#xA;transform:&#xA;error_mode: ignore&#xA;trace_statements:&#xA;- context: span&#xA;statements:&#xA;- set(attributes[&amp;#34;published_at&amp;#34;], UnixMilli(Now()))&#xA;exporters:&#xA;kafka:&#xA;protocol_version: 2.0.0&#xA;brokers: kafka-for-otelcol-kafka-brokers.kafka.svc.cluster.local:9092&#xA;topic: otlp-spans&#xA;service:&#xA;pipelines:&#xA;traces:&#xA;receivers: [ otlp ]&#xA;processors: [ transform ]&#xA;exporters: [ kafka ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;6&#34;&gt;&#xA;&lt;li&gt;And now, the Collector &lt;code&gt;otelcol-sub&lt;/code&gt; receives the data from the topic and sends it to Grafana Cloud.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;apiVersion: opentelemetry.io/v1beta1&#xA;kind: OpenTelemetryCollector&#xA;metadata:&#xA;name: otelcol-sub&#xA;spec:&#xA;image: ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector-contrib:0.113.0&#xA;envFrom:&#xA;- secretRef:&#xA;name: grafana-cloud-credentials&#xA;config:&#xA;extensions:&#xA;basicauth:&#xA;client_auth:&#xA;username: &amp;#34;${env:GRAFANA_CLOUD_USER}&amp;#34;&#xA;password: &amp;#34;${env:GRAFANA_CLOUD_TOKEN}&amp;#34;&#xA;receivers:&#xA;kafka:&#xA;protocol_version: 2.0.0&#xA;brokers: kafka-for-otelcol-kafka-brokers.kafka.svc.cluster.local:9092&#xA;topic: otlp-spans&#xA;processors:&#xA;transform:&#xA;error_mode: ignore&#xA;trace_statements:&#xA;- context: span&#xA;statements:&#xA;- set(attributes[&amp;#34;consumed_at&amp;#34;], UnixMilli(Now()))&#xA;exporters:&#xA;otlphttp:&#xA;endpoint: https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;auth:&#xA;authenticator: basicauth&#xA;service:&#xA;extensions: [ basicauth ]&#xA;pipelines:&#xA;traces:&#xA;receivers: [ kafka ]&#xA;processors: [ transform ]&#xA;exporters: [ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;7&#34;&gt;&#xA;&lt;li&gt;Now, we need to send some telemetry to our “pub” Collector. If we don’t have a workload in the cluster available, we can open a port-forward to the Collector that is publishing to Kafka and send data via &lt;code&gt;telemetrygen&lt;/code&gt; to it:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;kubectl port-forward svc/otelcol-pub-collector 4317&#xA;telemetrygen traces --traces 2 --otlp-insecure --otlp-attributes=&amp;#39;recipe=&amp;#34;kafka-on-kubernetes&amp;#34;&amp;#39;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;8&#34;&gt;&#xA;&lt;li&gt;You should now see two new traces in your &lt;a href=&#34;/products/cloud/traces/pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud Traces&lt;/a&gt; view, like the following. Note that we are adding new attributes to the spans, recording the timestamp when they were placed at topic (&lt;code&gt;published_at&lt;/code&gt;) and retrieved from it (&lt;code&gt;consumed_at&lt;/code&gt;).&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1090px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/tasting-menu/cloud-traces.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/tasting-menu/cloud-traces.png&#34;data-srcset=&#34;/media/blog/tasting-menu/cloud-traces.png?w=320 320w, /media/blog/tasting-menu/cloud-traces.png?w=550 550w, /media/blog/tasting-menu/cloud-traces.png?w=750 750w, /media/blog/tasting-menu/cloud-traces.png?w=900 900w, /media/blog/tasting-menu/cloud-traces.png?w=1040 1040w, /media/blog/tasting-menu/cloud-traces.png?w=1240 1240w, /media/blog/tasting-menu/cloud-traces.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Grafana Cloud Traces UI&#34;width=&#34;1090&#34;height=&#34;856&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/tasting-menu/cloud-traces.png&#34;&#xA;alt=&#34;Grafana Cloud Traces UI&#34;width=&#34;1090&#34;height=&#34;856&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;tasting-notes&#34;&gt;Tasting notes&lt;/h3&gt;&#xA;&lt;p&gt;Our desert has a complex taste, which will be appreciated by people who have spiky workloads and need a robust ingestion layer with a backend that might not be fast enough to handle the spikes but fast enough to ingest data over time properly. This way, we don’t need to overprovision our entire pipeline, scaling up and down only the needed parts.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;I hope you&amp;rsquo;ve enjoyed this brief tour of the OpenTelemetry Collector. I hope it inspires you to keep cooking with your telemetry data!&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud &lt;/a&gt;is the easiest way to get started with metrics, logs, traces, dashboards, and more. We have a generous forever-free tier and plans for every use case. &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Sign up for free now!&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;】&lt;p&gt;我非常喜欢&lt;a href=&#34;https://en.wikipedia.org/wiki/Tasting_menu&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;品尝菜单&lt;/a&gt;。在烹饪世界中，他们让我们小份地品尝各种菜肴，帮助我们理解和欣赏不同的口味和选择。&lt;/p&gt;&#xA;&lt;p&gt;受到这个概念和&lt;a href=&#34;https://github.com/jpkrohling/talks/tree/main/2024/2024-05-24-cncf-santa-catarina/receitas&#34; target=&#34;_blank的启发“ rel=&#34;noopener noreferrer&#34;&gt;我今年早些时候发表的演讲&lt;/a&gt;，我在 Grafana 中制作了 OpenTelemetry Collector 配置的“品尝菜单” 云。这篇博文介绍了四种不同的方法，包括代码片段和包含完整示例和使用说明的 GitHub 存储库，每种方法旨在向您介绍遥测数据收集和管理的不同方面。&lt;/p&gt;&#xA;&lt;p&gt;这些食谱是我&lt;a href=&#34;https://github.com/jpkrohling/otelcol-cookbook&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;保存在 GitHub 上的食谱的一部分&lt;/a&gt;。因此，无论您是刚刚开始使用 OpenTelemetry 还是希望优化现有设置，这些配置都将帮助您欣赏 OpenTelemetry Collector 提供的一系列功能。所以，正如我们用葡萄牙语说的，bom apetite！&lt;/p&gt;&#xA;&lt;div class=&#34;br-4 base-border border-color-gray-3 docs_tabs&#34;&gt;&#xA;&lt;div x-data=&#34;app_content_tabs([&#34;开胃菜&#34;,&#34;主菜 1&#34;,&#34;主菜 2&#34;,&#34;甜点&#34;], &#39;0446e2467d163ee15dde7ad691d3bfba&#39;)&#34; x-init=&#34;init()&#34;&gt;&#xA;&lt;div class=&#34;d-flex w-100p flex-direction-rowalign-items-center justify-content-flex-start d-md-none&#34;&gt;&#xA;&lt;select class=&#34;docs_tabs--select w-100p base-border-bottom border-color-gray-3&#34; @change=&#34;toggle($event.target.value)&#34;&gt;&#xA;&lt;option value=&#34;Appetizer&#34; :selected=&#34;active === &#39;Appetizer&#39;&#34;&gt;开胃菜&lt;/option&gt;&#xA;&lt;option value=&#34;主菜 1&#34; :selected=&#34;active === &#39;主菜 1&#39;&#34;&gt;主菜 1&lt;/option&gt;&#xA;&lt;option value=&#34;主菜 2&#34; :selected=&#34;active === &#39;主菜 2&#39;&#34;&gt;主菜 2&lt;/option&gt;&#xA;&lt;option value=&#34;甜点&#34; :selected=&#34;active === &#39;甜点&#39;&#34;&gt;甜点&lt;/option&gt;&#xA;&lt;/选择&gt;&#xA;&lt;/div&gt;&#xA;&lt;nav class=&#34;docs_tabs--navigation base-border-bottom border-color-gray-3 d-none d-md-block&#34; role=&#34;tablist&#34; data-codetoggle=&#34;true&#34;&gt;&#xA;&lt;按钮&#xA;类=“docs_tabs--标签f-14 bg-透明颜色-灰色-11 py-8 px-1”&#xA;数据切换=“选项卡”&#xA;角色=“选项卡”&#xA;@click =“切换（&#39;开胃菜&#39;）”&#xA;:class=&#34;{ &#39;docs_tabs--label-active&#39;: active === &#39;开胃菜&#39; }&#34;&#xA;&gt;&#xA;开胃菜&#xA;&lt;/按钮&gt;&#xA;&lt;按钮&#xA;类=“docs_tabs--标签f-14 bg-透明颜色-灰色-11 py-8 px-1”&#xA;数据切换=“选项卡”&#xA;角色=“选项卡”&#xA;@click=&#34;toggle(&#39;主菜1&#39;)&#34;&#xA;:class=&#34;{ &#39;docs_tabs--label-active&#39;: active === &#39;主菜 1&#39; }&#34;&#xA;&gt;&#xA;主菜1&#xA;&lt;/按钮&gt;&#xA;&lt;按钮&#xA;类=“docs_tabs--标签f-14 bg-透明颜色-灰色-11 py-8 px-1”&#xA;数据切换=“选项卡”&#xA;角色=“选项卡”&#xA;@click=&#34;toggle(&#39;主菜2&#39;)&#34;&#xA;:class=&#34;{ &#39;docs_tabs--label-active&#39;: active === &#39;主菜2&#39; }&#34;&#xA;&gt;&#xA;主菜2&#xA;&lt;/按钮&gt;&#xA;&lt;按钮&#xA;类=“docs_tabs--标签f-14 bg-透明颜色-灰色-11 py-8 px-1”&#xA;数据切换=“选项卡”&#xA;角色=“选项卡”@click=&#34;切换(&#39;甜点&#39;)&#34;&#xA;:class=&#34;{ &#39;docs_tabs--label-active&#39;: active === &#39;甜点&#39; }&#34;&#xA;&gt;&#xA;甜点&#xA;&lt;/按钮&gt;&#xA;&lt;/导航&gt;&#xA;&lt;div class=&#34;docs_tabs--content-container&#34;&gt;&#xA;&lt;div&#xA;类=“docs_tabs--内容py-1 px-2”&#xA;:class=&#34;active === &#39;开胃菜&#39; ? &#39;d-block&#39; : &#39;d-none&#39;&#34;&#xA;id=&#34;&#34;&#xA;角色=“选项卡面板”&#xA;咏叹调-labelledby=&#34;&#34;&#xA;&gt;&#xA;&lt;h2 id=&#34;internal-telemetry-salad&#34;&gt;内部遥测沙拉&lt;/h2&gt;&#xA;&lt;p&gt;我们从一个简单但信息丰富的配置开始，其中涉及将收集器自己的内部遥测数据发送到外部存储。这道菜将帮助您了解如何从收集器中提取和读取内部遥测数据，包括指标和跟踪。&lt;/p&gt;&#xA;&lt;p&gt;在此配置中，我们为每种信号类型创建一个管道，并为所有信号类型使用相同的接收器和导出器。但是，我们需要使用调试导出器，因为我们对收集器的遥测不感兴趣；我们对收集器生成的遥测数据感兴趣。&lt;/p&gt;&#xA;&lt;p&gt;在 &lt;code&gt;service::telemetry&lt;/code&gt; 下，我们配置如何将内部跟踪和指标发送到外部 OpenTelemetry 协议 (OTLP) 端点。在本例中，我们使用从“OpenTelemetry Configuration”页面获取的 &lt;a href=&#34;/products/cloud/pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt; 实例的 OTLP 端点，该端点可以可以在“管理您的堆栈”页面上找到。&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1236px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/tasting-menu/manage-your-stack.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/tasting-menu/manage-your-stack.png”data-srcset =“/media/blog/tasting-menu/manage-your-stack.png？w = 320 320w，/媒体/博客/品尝菜单/manage-your-stack.png？w=550 550w， /media/blog/tasting-menu/manage-your-stack.png?w=750 750w, /media/blog/tasting-menu/manage-your-stack.png?w=900 900w, /media/blog/tasting -menu/manage-your-stack.png?w=1040 1040w, /media/blog/tasting-menu/manage-your-stack.png?w=1240 1240w, /media/blog/tasting-menu/manage-your-stack.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;在 Grafana Cloud UI 中管理您的堆栈页面&#34;width=&#34;1236&#34;height=&#34;809&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/tasting-menu/manage-your-stack.png”&#xA;alt=&#34;在 Grafana Cloud UI 中管理您的堆栈页面&#34;width=&#34;1236&#34;height=&#34;809&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;此外，在该页面上，我们可以查看生成令牌后显示的环境变量&lt;code&gt;OTEL_EXPORTER_OTLP_HEADERS&lt;/code&gt;。请将此信息放在手边，因为稍后我们将需要 Authorization 标头的值。&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1529px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/tasting-menu/environment-variables.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div 类=“img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/tasting-menu/environment-variables.png”data-srcset =“/media/blog/tasting-menu/environment-variables.png？w = 320 320w，/media/blog/品尝菜单/环境变量.png?w=550 550w, /media/blog/tasting-menu/environment-variables.png?w=750 750w, /media/blog/tasting-menu/environment-variables.png?w=900 900w, /media/blog/tasting-menu/environment -变量.png?w=1040 1040w, /media/blog/tasting-menu/environment-variables.png?w=1240 1240w，/media/blog/tasting-menu/environment-variables.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;环境变量代码截图&#34;width=&#34;1529&#34;height=&#34;478&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/tasting-menu/environment-variables.png”&#xA;alt=&#34;环境变量代码截图&#34;width=&#34;1529&#34;height=&#34;478&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;ingredients&#34;&gt;成分&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;OpenTelemetry Collector 发行版，能够通过 gRPC 提取 OTLP 数据，并使用调试导出器导出数据。我使用了&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-releases/releases/tag/v0.113.0&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;OTel Collector Contrib v0。 113.0&lt;/a&gt; 对于此博文。&lt;/li&gt;&#xA;&lt;li&gt;可以生成 OTLP 数据的应用程序，例如 &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/cmd/telemetrygen&#34; target=&#34;_blank&#34; rel =&#34;noopener noreferrer&#34;&gt;telemetrygen&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;正确配置了 &lt;code&gt;service::telemetry&lt;/code&gt; 部分的配置文件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;configuration-example&#34;&gt;配置示例&lt;/h3&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;接收者：&#xA;奥特普：&#xA;协议：&#xA;http：&#xA;组组：&#xA;出口商：&#xA;调试：&#xA;服务：&#xA;管道：&#xA;痕迹：&#xA;接收者：[otlp]&#xA;出口商：[调试]&#xA;指标：&#xA;接收者：[otlp]&#xA;出口商：[调试]&#xA;日志：&#xA;接收者：[otlp]&#xA;出口商：[调试]&#xA;遥测：&#xA;痕迹：&#xA;处理器：&#xA;- 批：&#xA;计划延迟：1000&#xA;出口商：&#xA;奥特普：&#xA;端点：https://otlp-gateway-prod-eu-west-2.grafana.net/otlp/v1/traces&#xA;协议：http/protobuf&#xA;标题：&#xA;授权：“基本……”&#xA;指标：&#xA;级别： 详细&#xA;读者：&#xA;- 定期：&#xA;出口商：&#xA;奥特普：&#xA;端点：https://otlp-gateway-prod-eu-west-2.grafana.net/otlp/v1/metrics&#xA;协议：http/protobuf&#xA;标题：&#xA;授权：“基本……”&#xA;资源：&#xA;“service.name”：“otelcol-own-telemetry”&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;preparation&#34;&gt;准备&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;更改配置文件以包含 &lt;code&gt;Basic&lt;/code&gt; 身份验证标头和端点的正确值&lt;/li&gt;&#xA;&lt;li&gt;运行 OpenTelemetry Collector：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;otelcol-contrib --config ./otelcol.yaml&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“3”&gt;&#xA;&lt;li&gt;向收集器发送一些遥测数据。默认情况下，telemetrygen 报告的每个跟踪都带有两个跨度。请注意，此遥测数据将随所提供的配置一起被丢弃，但收集器执行的操作将被记录：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;telemetrygen 跟踪 --traces 1 --otlp-insecure --otlp-attributes=&#39;cookbook=&#34;own-telemetry&#34;&#39;&lt;/code&gt; &lt;/前&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“4”&gt;&#xA;&lt;li&gt;在 Grafana Cloud 上，选择跟踪数据源，您将能够找到表示 &lt;code&gt;telemetrygen&lt;/code&gt; 调用的 Collector 处理的跟踪：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1277px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/tasting-menu/traces-data.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/tasting-menu/traces-data.png”data-srcset =“/media/blog/tasting-menu/traces-data.png？w = 320 320w，/media/blog/品尝菜单/traces-data.png?w=550 550w，/media/blog/tasting-menu/traces-data.png?w=750 750w，/media/blog/tasting-menu/traces-data.png？w=900 900w，/media/blog/tasting-menu/traces-data.png？w=1040 1040w，/media/blog/tasting-menu /traces-data.png?w=1240 1240w, /media/blog/tasting-menu/traces-data.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Grafana Cloud 中 TraceQL 查询的屏幕截图&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/tasting-menu/traces-data.png”&#xA;alt=&#34;Grafana Cloud 中 TraceQL 查询的屏幕截图&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;ol开始=“5”&gt;&#xA;&lt;li&gt;现在，更改为指标数据源，然后选择指标 &lt;code&gt;otelcol_exporter_sent_spans_total&lt;/code&gt;。我们可以看到我们的收集器报告它收到了两个跨度。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1277px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;项目ype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/tasting-menu/two-spans.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/tasting-menu/two-spans.png”data-srcset =“/media/blog/tasting-menu/two-spans.png？w = 320 320w，/media/blog/品尝菜单/two-spans.png?w=550 550w, /media/blog/tasting-menu/two-spans.png?w=750 750w, /media/blog/tasting-menu/two-spans.png?w=900 900w, /media/blog/tasting-menu/two -spans.png?w=1040 1040w, /media/blog/tasting-menu/two-spans.png?w=1240 1240w, /media/blog/tasting-menu/two-spans.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Grafana Cloud 中查询 UI 的屏幕截图&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/tasting-menu/two-spans.png”&#xA;alt=&#34;Grafana Cloud 中查询 UI 的屏幕截图&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;tasting-notes&#34;&gt;品酒笔记&lt;/h3&gt;&#xA;&lt;p&gt;我们现在已经看到，我们可以观察收集器以了解它在做什么 - 我们可以轻松访问其指标和跟踪。但是日志呢？&lt;/p&gt;&#xA;&lt;p&gt;目前，日志仅在控制台上可用，并且应单独捕获。避免使用文件日志接收器读取实例自己的日志的诱惑。这可能会导致事件无限循环，违反软件不应自我监控的原则。&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div&#xA;类=“docs_tabs--内容py-1 px-2”&#xA;:class=&#34;active === &#39;主菜 1&#39; ? &#39;d-block&#39; : &#39;d-none&#39;&#34;&#xA;id=&#34;&#34;&#xA;角色=“选项卡面板”&#xA;咏叹调-labelledby=&#34;&#34;&#xA;&gt;&#xA;&lt;h2 id=&#34;mixed-events-and-metrics&#34;&gt;混合事件和指标&lt;/h2&gt;&#xA;&lt;p&gt;我们的第一门主菜是来自 Kubernetes 集群的事件和指标的料理鼠王。 Collector 由 OpenTelemetry Operator 进行配置，以“部署”模式在 Kubernetes 集群中运行，并遵守 &lt;a href=&#34;https://opentelemetry.io/docs/specs/otel/metrics/data-model/# single-writer&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;单编写器原则&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;ingredients&#34;&gt;成分&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个 Kubernetes 集群，例如通过 k3d 在本地配置的集群&lt;/li&gt;&#xA;&lt;li&gt;在集群中运行的 OpenTelemetry Operator&lt;/li&gt;&#xA;&lt;li&gt;Kubernetes 密钥中的 Grafana Cloud 凭据&lt;/li&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;k8s_cluster&lt;/code&gt; 和 &lt;code&gt;k8s_events&lt;/code&gt; 接收器的收集器配置&lt;/li&gt;&#xA;&lt;li&gt;会生成一些 Kubernetes 事件的工作负载&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;kubens&lt;/code&gt; 来自 &lt;a href=&#34;https://github.com/ahmetb/kubectx&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;kubectx&lt;/code&gt; &lt;/a&gt; 项目&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;configuration-example&#34;&gt;配置示例&lt;/h3&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div 类=“代码”-片段代码-片段__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt; 扩展：&#xA;基本验证：&#xA;客户端验证：&#xA;用户名：“${env:GRAFANA_CLOUD_USER}”&#xA;密码：“${env:GRAFANA_CLOUD_TOKEN}”&#xA;接收者：&#xA;k8s_事件：{}&#xA;k8s_集群：&#xA;收集间隔：15s&#xA;出口商：&#xA;otlphttp:&#xA;端点：https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;授权：&#xA;验证器：basicauth&#xA;服务：&#xA;扩展： [ basicauth ]&#xA;管道：&#xA;指标：&#xA;接收者：[ k8s_cluster ]&#xA;出口商：[ otlphttp ]&#xA;日志：&#xA;接收者：[ k8s_events ]&#xA;导出器：[ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;preparation&#34;&gt;准备&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;确保您已配置正在运行的 Kubernetes 集群和 OpenTelemetry Operator，并将上下文设置为 &lt;code&gt;observability&lt;/code&gt; 命名空间。如果您不知道如何开始，可以尝试以下命令进行本地设置：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;k3d 集群创建&#xA;kubectl apply -f https://github.com/cert-manager/cert-manager/releases/latest/download/cert-manager.yaml&#xA;kubectl wait --for=condition=可用部署/cert-manager -n cert-manager&#xA;kubectl apply -f https://github.com/open-telemetry/opentelemetry-operator/releases/latest/download/opentelemetry-operator.yaml&#xA;kubectl wait --for=条件=可用部署/opentelemetry-operator-controller-manager -n opentelemetry-operator-system&#xA;kubectl 创建命名空间可观察性&#xA;kubens 可观测性&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“2”&gt;&#xA;&lt;li&gt;使用您的 Grafana Cloud 凭据创建一个密钥。在这个例子中，我们已经将它们设置为环境变量；适当更换它们。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;kubectl 创建秘密通用 grafana-cloud-credentials \&#xA;--from-literal=GRAFANA_CLOUD_USER=&#34;$GRAFANA_CLOUD_USER&#34; \&#xA;--from-literal=GRAFANA_CLOUD_TOKEN=&#34;$GRAFANA_CLOUD_TOKEN&#34;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“3”&gt;&#xA;&lt;li&gt;我们现在将为我们的收集器创建一个 &lt;code&gt;ClusterRole&lt;/code&gt;：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;api版本：rbac.authorization.k8s.io/v1&#xA;种类：集群角色&#xA;元数据：&#xA;姓名：奥特尔科尔&#xA;规则：&#xA;- api 组：&#xA;-“”&#xA;资源：&#xA;- 活动&#xA;- 命名空间&#xA;- 命名空间/状态&#xA;- 节点&#xA;- 节点/规格&#xA;- 豆荚&#xA;- 吊舱/状态&#xA;- 复制控制器&#xA;- 复制控制器/状态&#xA;- 资源配额&#xA;- 服务&#xA;动词：&#xA;- 得到&#xA;- 列表&#xA;- 手表&#xA;- api 组：&#xA;- 应用程序&#xA;资源：&#xA;- 守护进程集&#xA;- 部署&#xA;- 副本集&#xA;- 有状态集&#xA;动词：&#xA;- 得到&#xA;- 列表&#xA;- 手表&#xA;- api 组：&#xA;- 扩展&#xA;资源：&#xA;- 守护进程集&#xA;- 部署&#xA;- 副本集&#xA;动词：&#xA;- 得到&#xA;- 列表&#xA;- 手表&#xA;- api 组：&#xA;- 批&#xA;资源：&#xA;- 职位&#xA;- 定时任务&#xA;动词：&#xA;- 得到&#xA;- 列表&#xA;- 手表&#xA;- api 组：&#xA;- 自动缩放&#xA;资源：&#xA;- 水平pod自动缩放器&#xA;动词：&#xA;- 得到&#xA;- 列表&#xA;- 观看&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“4”&gt;&#xA;&lt;li&gt;我们将创建一个将由 Collector 实例使用的 &lt;code&gt;ServiceAccount&lt;/code&gt;，并将集群角色绑定到该帐户：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;api版本：v1&#xA;种类：服务帐户&#xA;元数据：&#xA;名称：otelcol-k8s&#xA;命名空间：可观察性&#xA;---&#xA;api版本：rbac.authorization.k8s.io/v1&#xA;种类：ClusterRoleBinding&#xA;元数据：&#xA;姓名：奥特尔科尔&#xA;角色参考：&#xA;apiGroup：rbac.authorization.k8s.io&#xA;种类：集群角色&#xA;姓名：奥特尔科尔&#xA;科目：&#xA;- 种类：服务帐户&#xA;名称：otelcol-k8s&#xA;命名空间：可观察性&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“5”&gt;&#xA;&lt;li&gt;我们现在将配置收集器以从 Kubernetes 集群获取指标和事件（作为日志）。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;api版本：opentelemetry.io/v1beta1&#xA;种类：OpenTelemetryCollector&#xA;元数据：&#xA;名称：otelcol-k8s&#xA;命名空间：可观察性&#xA;规格：&#xA;图片：ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector-contrib:0.113.0&#xA;服务帐号：otelcol-k8s&#xA;环境来自：&#xA;- 秘密参考：&#xA;名称：grafana-cloud-credentials&#xA;配置：&#xA;扩展名：&#xA;基本验证：&#xA;客户端验证：&#xA;用户名：“${env:GRAFANA_CLOUD_USER}&amp;#34;&#xA;密码：“${env:GRAFANA_CLOUD_TOKEN}”&#xA;接收者：&#xA;k8s_事件：{}&#xA;k8s_集群：&#xA;收集间隔：15s&#xA;出口商：&#xA;otlphttp:&#xA;端点：https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;授权：&#xA;验证器：basicauth&#xA;服务：&#xA;扩展： [ basicauth ]&#xA;管道：&#xA;指标：&#xA;接收者：[ k8s_cluster ]&#xA;出口商：[ otlphttp ]&#xA;日志：&#xA;接收者：[ k8s_events ]&#xA;导出器：[ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;如果您的 Kubernetes 集群中没有运行工作负载，则此工作负载应该足以生成一些事件。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;api版本：apps/v1&#xA;种类：部署&#xA;元数据：&#xA;名称：nginx-部署&#xA;规格：&#xA;选择器：&#xA;匹配标签：&#xA;应用程序：nginx&#xA;模板：&#xA;元数据：&#xA;标签：&#xA;应用程序：nginx&#xA;规格：&#xA;容器：&#xA;-名称：nginx&#xA;图片：nginx:1.27.2&#xA;端口：&#xA;- 容器端口：80&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“6”&gt;&#xA;&lt;li&gt;此时，您的 Grafana Cloud 实例中应该已收到一些事件。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1277px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/tasting-menu/cloud-logs.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/tasting-menu/cloud-logs.png”data-srcset =“/media/blog/tasting-menu/cloud-logs.png？w = 320 320w，/media/blog/品尝菜单/cloud-logs.png?w=550 550w，/media/blog/tasting-menu/cloud-logs.png?w=750 750w、/media/blog/tasting-menu/cloud-logs.png?w=900 900w、/media/blog/tasting-menu/cloud-logs.png?w=1040 1040w、/media/blog/tasting-menu /cloud-logs.png?w=1240 1240w, /media/blog/tasting-menu/cloud-logs.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Grafana Cloud 中填充的事件&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/media/blog/tasting-menu/cloud-logs.png&#34;&#xA;alt=&#34;Grafana Cloud 中填充的事件&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Kubernetes 指标（例如 &lt;code&gt;k8s_container_ready&lt;/code&gt;）也应该可用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1277px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/tasting-menu/k8s-metrics.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/tasting-menu/k8s-metrics.png”data-srcset =“/media/blog/tasting-menu/k8s-metrics.png？w = 320 320w，/media/blog/品尝菜单/k8s-metrics.png?w=550 550w, /media/blog/tasting-menu/k8s-metrics.png?w=750 750w, /media/blog/tasting-menu/k8s-metrics.png?w=900 900w, /media/blog/tasting-menu/k8s-指标.png?w=1040 1040w, /media/blog/tasting-menu/k8s-metrics.png?w=1240 1240w，/media/blog/tasting-menu/k8s-metrics.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;在 Grafana UI 中填充图表的指标&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/tasting-menu/k8s-metrics.png”&#xA;alt=&#34;在 Grafana UI 中填充图表的指标&#34;width=&#34;1277&#34;height=&#34;677&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;tasting-notes&#34;&gt;品酒笔记&lt;/h3&gt;&#xA;&lt;p&gt;我们只是初步了解了这些组件的功能，这为我们提供了足够的信息来进一步探索这个想法：哪些指标可能值得我们关注？我们如何结合指标来讲述一个故事？这就是我们可以从这里出发的地方。&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div&#xA;类=“docs_tabs--内容py-1 px-2”&#xA;:class=&#34;active === &#39;主菜 2&#39; ? &#39;d-block&#39; : &#39;d-none&#39;&#34;&#xA;id=&#34;&#34;&#xA;角色=“选项卡面板”&#xA;咏叹调-labelledby=&#34;&#34;&#xA;&gt;&#xA;&lt;h2 id=&#34;bibimbap-of-logs&#34;&gt;原木拌饭&lt;/h2&gt;&#xA;&lt;p&gt;第二个主要课程探讨了在“daemonset”模式下配置的收集器，以从同一节点上运行的 Pod 收集各种日志，可能遵循不同的格式并来自不同的命名空间。此配置强调将收集器放置在靠近遥测源的位置。&lt;/p&gt;&#xA;&lt;h3 id=&#34;ingredients&#34;&gt;成分&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个 Kubernetes 集群，如上一章节所示&lt;/li&gt;&#xA;&lt;li&gt;在集群中运行的 OpenTelemetry Operator&lt;/li&gt;&#xA;&lt;li&gt;Kubernetes 密钥中的 Grafana Cloud 凭据&lt;/li&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;k8s_cluster&lt;/code&gt; 和 &lt;code&gt;k8s_events&lt;/code&gt; 接收器的收集器配置&lt;/li&gt;&#xA;&lt;li&gt;会生成一些 Kubernetes 事件的工作负载&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;configuration-example&#34;&gt;配置示例&lt;/h3&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt; 扩展：&#xA;基本验证：&#xA;客户端验证：&#xA;用户名：“${env:GRAFANA_CLOUD_USER}”&#xA;密码：“${env:GRAFANA_CLOUD_TOKEN}”&#xA;接收者：&#xA;文件日志：&#xA;排除： []&#xA;包括：&#xA;- /var/log/pods/*/*/*.log&#xA;包含文件名： false&#xA;include_file_path: true&#xA;运营商：&#xA;- id：容器解析器&#xA;最大日志大小：102400&#xA;类型：集装箱&#xA;失败时重试：&#xA;启用：真&#xA;开始于：结束&#xA;出口商：&#xA;otlphttp:&#xA;端点：https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;授权：&#xA;验证器：basicauth&#xA;服务：&#xA;扩展： [ basicauth ]&#xA;管道：&#xA;日志：&#xA;接收者：[ 文件日志 ]&#xA;导出器：[ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;preparation&#34;&gt;准备&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;确保您有 Kubernetes 集群和 OTel Operator 正在运行。感觉可以随意重复使用您在上一配方中配置的内容。&lt;/li&gt;&#xA;&lt;li&gt;接下来，使用以下配置创建自定义资源。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;api版本：opentelemetry.io/v1beta1&#xA;种类：OpenTelemetryCollector&#xA;元数据：&#xA;名称： otelcol-podslogs&#xA;命名空间：可观察性&#xA;规格：&#xA;图片：ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector-contrib:0.113.0&#xA;模式：守护进程集&#xA;环境来自：&#xA;- 秘密参考：&#xA;名称：grafana-cloud-credentials&#xA;卷：&#xA;- 名称：varlogpods&#xA;主机路径：&#xA;路径：/var/log/pods&#xA;体积安装：&#xA;- 名称：varlogpods&#xA;挂载路径：/var/log/pods&#xA;只读：真&#xA;配置：&#xA;扩展名：&#xA;基本验证：&#xA;客户端验证：&#xA;用户名：“${env:GRAFANA_CLOUD_USER}”&#xA;密码：“${env:GRAFANA_CLOUD_TOKEN}”&#xA;接收者：&#xA;文件日志：&#xA;排除： []&#xA;包括：&#xA;- /var/log/pods/*/*/*.log&#xA;包含文件名： false&#xA;include_file_path: true&#xA;运营商：&#xA;- id：容器解析器&#xA;最大日志大小：102400&#xA;类型：集装箱&#xA;失败时重试：&#xA;启用：真&#xA;开始于：结束&#xA;出口商：&#xA;otlphttp:&#xA;端点：https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;授权：&#xA;验证器：basicauth&#xA;服务：&#xA;扩展： [ basicauth ]&#xA;管道：&#xA;日志：&#xA;接收者：[ 文件日志 ]&#xA;导出器：[ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“3”&gt;&#xA;&lt;li&gt;片刻之后，您应该开始看到集群中容器的日志。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1261px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/tasting-menu/cloud-logs-2.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src=&#34;/media/blog/tasting-menu/cloud-logs-2.png&#34;data-srcset=&#34;/media/blog/tasting-menu/cloud-logs-2.png?w=320 320w,/媒体/博客/品尝菜单/cloud-logs-2.png?w=550 550w, /media/blog/tasting-menu/cloud-logs-2.png?w=750 750w, /media/blog/tasting-menu/cloud-logs-2.png?w=900 900w, /media/blog/tasting -menu/cloud-logs-2.png?w=1040 1040w, /media/blog/tasting-menu/cloud-logs-2.png?w=1240 1240w，/media/blog/tasting-menu/cloud-logs-2.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Grafana 云日志查询&#34;width=&#34;1261&#34;height=&#34;680&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/media/blog/tasting-menu/cloud-logs-2.png&#34;&#xA;alt=&#34;Grafana 云日志查询&#34;width=&#34;1261&#34;height=&#34;680&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;tasting-notes&#34;&gt;品酒笔记&lt;/h3&gt;&#xA;&lt;p&gt;日志是富含鲜味的遥测数据点，探索我们可以拥有的所有可能的品味：工作负载或基础设施相关，从调试到关键，结构化或非结构化。此时，我们&amp;rsqo；已经涵盖的内容足以让您渴望更多。现在您会问：您可以在配置中添加哪些规则以更好地丰富元数据？&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div&#xA;类=“docs_tabs--内容py-1 px-2”&#xA;:class=&#34;active === &#39;甜点&#39; ? &#39;d-block&#39; : &#39;d-none&#39;&#34;&#xA;id=&#34;&#34;&#xA;角色=“选项卡面板”&#xA;咏叹调-labelledby=&#34;&#34;&#xA;&gt;&#xA;&lt;h2 id=&#34;kafka-buffer-with-two-collector-layers&#34;&gt;具有两个收集器层的 Kafka 缓冲区&lt;/h2&gt;&#xA;&lt;p&gt;对于甜点，我们提供了一种复杂的配置，涉及带有两层收集器的 Kafka 缓冲区 - 在高度可扩展的场景中因其能够处理遥测数据量的峰值而不受后端压力或影响摄取层的能力而受到赞赏。&lt;/p&gt;&#xA;&lt;p&gt;第一层从 Kubernetes 中运行的业务服务收集遥测数据并将其发布到 Kafka 主题。第二层使用这些事件并将它们发送到遥测存储。&lt;/p&gt;&#xA;&lt;h3 id=&#34;ingredients&#34;&gt;成分&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个 Kubernetes 集群，如上一章节所示&lt;/li&gt;&#xA;&lt;li&gt;在集群中运行的 OpenTelemetry Operator&lt;/li&gt;&#xA;&lt;li&gt;Kubernetes 密钥中的 Grafana Cloud 凭据&lt;/li&gt;&#xA;&lt;li&gt;一个 Kafka 集群以及每种遥测数据类型（指标、日志、跟踪）的一个主题&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;telemetrygen&lt;/code&gt; 工具，或任何其他能够将 OTLP 数据发送到我们的收集器的应用程序&lt;/li&gt;&#xA;&lt;li&gt;两个收集器，一个配置为将数据发布到主题，另一个使用事件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;configuration-examples&#34;&gt;配置示例&lt;/h3&gt;&#xA;&lt;h4 id=&#34;publisher&#34;&gt;发布者&lt;/h4&gt;&#xA;&lt;p&gt;这是我们将用于 &lt;code&gt;otelcol-pub&lt;/code&gt; 收集器的配置，负责发布到队列：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt; 接收者：&#xA;奥特普：&#xA;协议：&#xA;http：{}&#xA;组：{}&#xA;处理器：&#xA;转换：&#xA;错误模式：忽略&#xA;跟踪语句：&#xA;- 上下文：跨度&#xA;声明：&#xA;- 设置（属性[“published_at”]，UnixMilli（Now（）））&#xA;出口商：&#xA;卡夫卡：&#xA;协议版本：2.0.0&#xA;经纪人：kafka-for-otelcol-kafka-brokers.kafka.svc.cluster.local:9092&#xA;主题： otlp-spans&#xA;服务：&#xA;管道：&#xA;痕迹：&#xA;接收者：[ otlp ]&#xA;处理器：[变换]&#xA;出口商：[ kafka ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h4 id=&#34;consumer&#34;&gt;消费者&lt;/h4&gt;&#xA;&lt;p&gt;这是我们将用于 &lt;code&gt;otelcol-sub&lt;/code&gt; 收集器的配置，负责从队列中读取数据并将其写入 Grafana Cloud 实例：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;扩展名：&#xA;基本验证：&#xA;客户端验证：&#xA;用户名：“${env:GRAFANA_CLOUD_USER}”&#xA;密码：“${env:GRAFANA_CLOUD_TOKEN}”&#xA;接收者：&#xA;卡夫卡：&#xA;协议版本：2.0.0&#xA;经纪人：kafka-for-otelcol-kafka-brokers.kafka.svc.cluster.local:9092&#xA;主题： otlp-spans&#xA;处理器：&#xA;转换：&#xA;错误模式：忽略&#xA;跟踪语句：&#xA;- 上下文：跨度&#xA;声明：&#xA;- 设置（属性[“consumed_at”]，UnixMilli（Now（）））&#xA;出口商：&#xA;otlphttp:&#xA;端点：https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;授权：&#xA;验证器：basicauth&#xA;服务：&#xA;扩展： [ basicauth ]&#xA;管道：&#xA;痕迹：&#xA;接收者：[卡夫卡]&#xA;处理器：[变换]&#xA;导出器：[ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;preparation&#34;&gt;准备&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;安装 &lt;a href=&#34;https://strimzi.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Strimzi&lt;/a&gt;，一个 Kafka 的 Kubernetes Operator。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;kubectl 创建 ns kafka&#xA;卡夫卡库本斯&#xA;kubectl create -f &#39;https://strimzi.io/install/latest?namespace=kafka&#39;&#xA;kubectl wait --for=condition=可用部署/strimzi-cluster-operator --timeout=300s&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“2”&gt;&#xA;&lt;li&gt;为我们的配方安装 Kafka 集群和主题。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;api版本：kafka.strimzi.io/v1beta2&#xA;种类：KafkaNodePool&#xA;元数据：&#xA;名称：双角色&#xA;标签：&#xA;strimzi.io/集群：kafka-for-otelcol&#xA;规格：&#xA;副本：1&#xA;角色：&#xA;- 控制器&#xA;- 经纪人&#xA;贮存：&#xA;类型：jbod&#xA;卷：&#xA;- 编号：0&#xA;类型：持久声明&#xA;大小：100Gi&#xA;删除声明： false&#xA;kraft元数据：共享&#xA;---&#xA;api版本：kafka.strimzi.io/v1beta2&#xA;种类：卡夫卡&#xA;元数据：&#xA;名称：kafka-for-otelcol&#xA;注释：&#xA;strimzi.io/node-pools：已启用&#xA;strimzi.io/kraft：已启用&#xA;规格：&#xA;卡夫卡：&#xA;版本：3.7.0&#xA;元数据版本：3.7-IV4&#xA;配置：&#xA;偏移量.主题.复制.因子：1&#xA;事务.状态.日志.复制.因子：1&#xA;交易.状态.log.min.isr: 1&#xA;默认复制因子：1&#xA;最小同步副本数：1&#xA;听众：&#xA;- 名称：普通&#xA;端口：9092&#xA;类型：内部&#xA;tls: 假&#xA;---&#xA;api版本：kafka.strimzi.io/v1beta2&#xA;种类：Kafka主题&#xA;元数据：&#xA;名称： otlp-spans&#xA;标签：&#xA;strimzi.io/集群：kafka-for-otelcol&#xA;---&#xA;api版本：kafka.strimzi.io/v1beta2&#xA;种类：Kafka主题&#xA;元数据：&#xA;名称：otlp-指标&#xA;标签：&#xA;strimzi.io/集群：kafka-for-otelcol&#xA;---&#xA;api版本：kafka.strimzi.io/v1beta2&#xA;种类：Kafka主题&#xA;元数据：&#xA;名称：otlp-日志&#xA;标签：&#xA;strimzi.io/cluster：kafka-for-otelcol&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“3”&gt;&#xA;&lt;li&gt;主题可能需要一段时间才能准备好。在继续操作之前，请查看以下自定义资源的状态：&lt;code&gt;kafka/kafka-for-otelcol&lt;/code&gt;。一旦标记为&lt;code&gt;就绪&lt;/code&gt;，请继续下一步。&lt;/li&gt;&#xA;&lt;li&gt;返回到&lt;code&gt;可观察性&lt;/code&gt;命名空间。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;kubens 可观测性&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“5”&gt;&#xA;&lt;li&gt;创建将从工作负载接收数据并发布到主题的收集器&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;api版本：opentelemetry.io/v1beta1&#xA;种类：OpenTelemetryCollector&#xA;元数据：&#xA;名称: otelcol-pub&#xA;规格：&#xA;图片：ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector-contrib:0.113.0&#xA;配置：&#xA;接收者：&#xA;奥特普：&#xA;协议：&#xA;http：{}&#xA;组：{}&#xA;处理器：&#xA;转换：&#xA;错误模式：忽略&#xA;跟踪语句：&#xA;- 上下文：跨度&#xA;声明：&#xA;- 设置（属性[“published_at”]，UnixMilli（Now（）））&#xA;出口商：&#xA;卡夫卡：&#xA;协议版本：2.0.0&#xA;经纪人：kafka-for-otelcol-kafka-brokers.kafka.svc.cluster.local:9092&#xA;主题： otlp-spans&#xA;服务：&#xA;管道：&#xA;痕迹：&#xA;接收者：[ otlp ]&#xA;处理器：[变换]&#xA;出口商：[ kafka ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“6”&gt;&#xA;&lt;li&gt;现在，收集器 &lt;code&gt;otelcol-sub&lt;/code&gt; 接收来自主题的数据并将其发送到 Grafana Cloud。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;api版本：opentelemetry.io/v1beta1&#xA;种类：OpenTelemetryCollector&#xA;元数据：&#xA;名称: otelcol-sub&#xA;规格：&#xA;图片：ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector-contrib:0.113.0&#xA;环境来自：&#xA;- 秘密参考：&#xA;名称：grafana-cloud-credentials&#xA;配置：&#xA;扩展名：&#xA;基本验证：&#xA;客户端验证：&#xA;用户名：“${env:GRAFANA_CLOUD_USER}”&#xA;密码：“${env:GRAFANA_CLOUD_TOKEN}”&#xA;接收者：&#xA;卡夫卡：&#xA;协议版本：2.0.0&#xA;经纪人：kafka-for-otelcol-kafka-brokers.kafka.svc.cluster.local:9092&#xA;主题： otlp-spans&#xA;处理器：&#xA;转换：&#xA;错误模式：忽略&#xA;跟踪语句：&#xA;- 上下文：跨度&#xA;声明：&#xA;- 设置（属性[“consumed_at”]，UnixMilli（Now（）））&#xA;出口商：&#xA;otlphttp:&#xA;端点：https://otlp-gateway-prod-eu-west-2.grafana.net/otlp&#xA;授权：&#xA;验证器：basicauth&#xA;服务：&#xA;扩展： [ basicauth ]&#xA;管道：&#xA;痕迹：&#xA;接收者：[卡夫卡]&#xA;处理器：[变换]&#xA;导出器：[ otlphttp ]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“7”&gt;&#xA;&lt;li&gt;现在，我们需要向我们的“pub”收集器发送一些遥测数据。如果集群中没有可用的工作负载，我们可以打开一个端口转发到正在发布到 Kafka 的收集器，并通过 &lt;code&gt;telemetrygen&lt;/code&gt; 向其发送数据：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;kubectl 端口转发 svc/otelcol-pub-collector 4317&#xA;telemetrygen 跟踪 --traces 2 --otlp-insecure --otlp-attributes=&#39;recipe=&#34;kafka-on-kubernetes&#34;&#39;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“8”&gt;&#xA;&lt;li&gt;您现在应该在 &lt;a href=&#34;/products/cloud/traces/pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud Traces&lt;/a&gt; 视图中看到两条新跟踪，如下所示。请注意，我们正在向跨度添加新属性，记录它们被放置在主题 (&lt;code&gt;published_at&lt;/code&gt;) 和从中检索 (&lt;code&gt;consumed_at&lt;/code&gt;) 时的时间戳。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1090px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/tasting-menu/cloud-traces.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;data-src =“/media/blog/tasting-menu/cloud-traces.png”data-srcset =“/media/blog/tasting-menu/cloud-traces.png？w = 320 320w，/media/blog/品尝菜单/cloud-traces.png?w=550 550w，/media/blog/tasting-menu/cloud-traces.png?w=750 750w，/media/blog/tasting-menu/cloud-traces.png？w=900 900w，/media/blog/tasting-menu/cloud-traces.png？w=1040 1040w，/media/blog/tasting-menu/cloud-traces.png?w=1240 1240w，/media/blog/tasting-menu/cloud-traces.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;Grafana 云跟踪 UI&#34;width=&#34;1090&#34;height=&#34;856&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src=&#34;/media/blog/tasting-menu/cloud-traces.png&#34;&#xA;alt=&#34;Grafana 云跟踪 UI&#34;width=&#34;1090&#34;height=&#34;856&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;h3 id=&#34;tasting-notes&#34;&gt;品酒笔记&lt;/h3&gt;&#xA;&lt;p&gt;我们的沙漠有一种复杂的味道，那些工作负载尖峰、需要强大的摄取层和后端的人会喜欢这种味道，该后端可能不够快来处理尖峰，但足够快以随着时间的推移正确摄取数据。这样，我们就不需要过度配置整个管道，只扩展和缩减所需的部分。&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;我希望您喜欢这个 OpenTelemetry Collector 的简短介绍。我希望它能激励您继续利用遥测数据做饭！&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;a href=&#34;/products/cloud/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud&lt;/a&gt;是开始使用指标、日志、跟踪、仪表板等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。 &lt;a href=&#34;/auth/sign-up/create-user/?pg=blog&amp;plcmt=body-txt&#34;&gt;立即免费注册！&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</description>
      <pubDate>Wed, 27 Nov 2024 00:00:00 +0000</pubDate>
    </item>
    <item>
      <title>【5 tips to write better browser tests for performance testing and synthetic monitoring】编写更好的浏览器测试以进行性能测试和综合监控的 5 个技巧</title>
      <link>https://grafana.com/blog/2024/11/21/5-tips-to-write-better-browser-tests-for-performance-testing-and-synthetic-monitoring/</link>
      <description>【&lt;p&gt;Given the complexity of modern websites, browser testing is essential to ensure a positive user experience. With the &lt;a href=&#34;/docs/k6/latest/using-k6-browser/&#34;&gt;Grafana k6 browser module&lt;/a&gt;, you can interact with real web browsers and simulate user interactions — like clicking, typing, or navigating pages — to collect frontend metrics, increase site reliability, and fix performance issues before they ever impact your users.&lt;/p&gt;&#xA;&lt;p&gt;Part of &lt;a href=&#34;/oss/k6/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana k6 OSS&lt;/a&gt;, the k6 browser module is also compatible with our fully managed &lt;a href=&#34;/products/cloud/k6/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud k6&lt;/a&gt; solution, as well as &lt;a href=&#34;/products/cloud/synthetic-monitoring/?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Grafana Cloud Synthetic Monitoring&lt;/a&gt;, for out-of-the-box monitoring capabilities. This means you can re-use your browser testing scripts across those three environments, based on your testing needs.&lt;/p&gt;&#xA;&lt;p&gt;With an API that’s similar to &lt;a href=&#34;https://playwright.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Playwright’s&lt;/a&gt;, the k6 browser module makes it easy for those familiar with the Playwright web testing framework to write their first browser tests. That said, we know a few best practices can go a long way when it comes to authoring browser test scripts and integrating them into your workflow.&lt;/p&gt;&#xA;&lt;p&gt;In this blog, we outline five tips you can apply today to write better browser tests in Grafana k6, Grafana Cloud k6, and Grafana Cloud Synthetic Monitoring.&lt;/p&gt;&#xA;&lt;h2 id=&#34;tip-1-run-the-test-locally-for-a-faster-feedback-loop&#34;&gt;Tip 1. Run the test locally for a faster feedback loop&lt;/h2&gt;&#xA;&lt;p&gt;Our cloud offerings, including Grafana Cloud k6 and Synthetic Monitoring, are the best way to visualize the output of your script, but running tests locally on your machine is a great way to debug and iterate faster. To get started you will want to:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/docs/k6/latest/set-up/install-k6/&#34;&gt;Install Grafana k6 on your machine&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;Have Chrome (or a &lt;a href=&#34;https://alternativeto.net/category/browsers/chromium-based/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Chromium-based browser&lt;/a&gt;) available&lt;/li&gt;&#xA;&lt;li&gt;Set up an empty directory&lt;/li&gt;&#xA;&lt;li&gt;Create a script with the &lt;a href=&#34;/docs/k6/latest/using-k6/scenarios/executors/shared-iterations/&#34;&gt;&lt;code&gt;shared-iterations&lt;/code&gt; executor&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;For the purposes of debugging browser scripts locally, ensure your test scenario is only going to run one virtual user (VU) and one iteration. The &lt;code&gt;shared-iterations&lt;/code&gt; executor has these options set by default, so is the perfect choice for debugging. You can run tests quickly, read your logs output, and reduce the feedback loop as you author your tests.&lt;/p&gt;&#xA;&lt;p&gt;As your tests grow in length and complexity, the logs might become too noisy to efficiently use, or might be missing critical pieces of information to pinpoint potential issues. Take this script, for example, which tests the federated login flow for &lt;a href=&#34;https://grafana.com&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;grafana.com&lt;/a&gt;:&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;federated-login-test.js&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { browser } from &amp;#34;k6/browser&amp;#34;&#xA;import { check } from &amp;#34;https://jslib.k6.io/k6-utils/1.6.0/index.js&amp;#34;&#xA;export const options = {&#xA;scenarios: {&#xA;ui: {&#xA;executor: &amp;#34;shared-iterations&amp;#34;,&#xA;options: {&#xA;browser: {&#xA;type: &amp;#34;chromium&amp;#34;,&#xA;},&#xA;},&#xA;},&#xA;},&#xA;}&#xA;export default async function () {&#xA;const context = await browser.newContext()&#xA;const page = await context.newPage()&#xA;await page.goto(`https://grafana.com/`)&#xA;await page.locator(`#menu__login-link`).click()&#xA;await page.waitForNavigation()&#xA;await page.locator(`button[aria-label=&amp;#34;Login using Google&amp;#34;]`).click()&#xA;await page.waitForNavigation()&#xA;// You will have to add or replace the __ENV variables as appropriate.&#xA;await page&#xA;.locator(`input[aria-label=&amp;#34;Email or phone&amp;#34;]`)&#xA;.fill(__ENV.GRAFANA_STACK_USER_EMAIL)&#xA;await page.locator(`//*[text()=&amp;#34;Next&amp;#34;]`).click()&#xA;await check(page.locator(`form h2`), {&#xA;&amp;#34;Form heading text is correct&amp;#34;: async (lo) =&amp;gt;&#xA;(await lo.textContent()) === `Grafana Labs`,&#xA;})&#xA;await page.close()&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;You can run the test by executing &lt;code&gt;k6 run federated-login-test.js&lt;/code&gt; in your terminal, but seemingly, the test ends prematurely. The check never runs, so it doesn&amp;rsquo;t trigger the threshold failure, and if you inspect the logs you see:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;Uncaught (in promise) getting text content of &amp;#34;h2&amp;#34;: Inspected target navigated or closed&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;It’s a cryptic log, especially if you are unfamiliar with the underlying API and what it’s doing. If you follow the steps by clicking along in your own browser, it isn’t clear what the problem is, as you end up on a page where &lt;code&gt;document.querySelector(‘form h2`).textContent&lt;/code&gt; is valid and returns the expected result.&lt;/p&gt;&#xA;&lt;p&gt;Using the &lt;a href=&#34;/docs/k6/latest/using-k6-browser/options/#environment-variable-options&#34;&gt;k6 browser CLI options&lt;/a&gt;, you can disable headless mode and watch your Chromium instance on your screen, so you can follow along as the bot steps through executing the script.&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;K6_BROWSER_HEADLESS=false k6 run {{scriptName}}.js&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;This often provides invaluable insights to uncover a problem that the logs themselves weren’t able to fully convey.&lt;/p&gt;&#xA;&lt;p&gt;In the example above, it is now easy to establish what the problem is: the last page is never reached. We forgot to wait for a navigation change after the &lt;strong&gt;next&lt;/strong&gt; button was clicked, and the asynchronous check function couldn’t successfully complete because, as it was executing, its page context was canceled.&lt;/p&gt;&#xA;&lt;p&gt;The solution is to add &lt;code&gt;page.waitForNavigation()&lt;/code&gt; on line 36 and now the test passes. 🎉&lt;/p&gt;&#xA;&lt;p&gt;Bots are much quicker than humans when interacting with a browser. You may want to use the &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/page/screenshot/&#34;&gt;&lt;code&gt;page.screenshot()&lt;/code&gt;&lt;/a&gt; method or artificially increase the time between asynchronous steps using &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/page/waitfortimeout/&#34;&gt;&lt;code&gt;page.waitForTimeout()&lt;/code&gt;&lt;/a&gt;, so you can process what is going on. However, if you do inject timeouts into your script to help with debugging, remember to remove them afterwards because…&lt;/p&gt;&#xA;&lt;h2 id=&#34;tip-2-timeouts-and-sleep-are-anti-patterns&#34;&gt;Tip 2. Timeouts and sleep are anti-patterns!&lt;/h2&gt;&#xA;&lt;p&gt;If you’ve seen a k6 script before, there is a good chance it included &lt;a href=&#34;/docs/k6/latest/javascript-api/k6/sleep/&#34;&gt;&lt;code&gt;sleep(t)&lt;/code&gt;&lt;/a&gt;. In the context of non-browser scripts that are focused on testing APIs at the protocol level, this is often a necessary step to &lt;a href=&#34;/docs/k6/latest/using-k6-browser/recommended-practices/simulate-user-input-delay/&#34;&gt;simulate a real user’s input delay&lt;/a&gt;. However, when working with the browser, this can be a source of flaky and unreliable tests that become difficult to untangle and debug. This is because the k6 script pauses, but the browser continues to execute its tasks and processes at an unknown rate, which may be different from one test to the next.&lt;/p&gt;&#xA;&lt;p&gt;If in the &lt;strong&gt;federated-login-test.js&lt;/strong&gt; script, instead of adding &lt;code&gt;page.waitForNavigation()&lt;/code&gt; you added &lt;code&gt;sleep(5)&lt;/code&gt;, this would often get the test to pass; however, you have now introduced one of the following problems every time it runs:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;An iteration in your script is now running longer than necessary (so it is going to cost you money)&lt;/li&gt;&#xA;&lt;li&gt;An iteration in your script is not running long enough and reports failure (so it is going to cost you money)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;The more &lt;code&gt;sleep(t)&lt;/code&gt; or &lt;code&gt;page.waitForTimeout()&lt;/code&gt; calls you add, the more these issues compound and introduce further problems. If you are using your script with Grafana Cloud Synthetic Monitoring, browser checks currently have &lt;a href=&#34;/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6-browser/#public-preview-limitations&#34;&gt;a limit on running time&lt;/a&gt;, so you may be reaching that limit unintentionally. For k6 browser tests, you are increasing memory and CPU usage unnecessarily, which might not just fail the current iteration, but make your script report failure altogether.&lt;/p&gt;&#xA;&lt;p&gt;If using &lt;code&gt;sleep(t)&lt;/code&gt;, it is important to note it is a synchronous function native to k6 that blocks the JavaScript event loop. If you are using the &lt;a href=&#34;/docs/grafana-cloud/whats-new/2024-07-03-browser-timeline-and-screenshots-in-grafana-cloud-k6/&#34;&gt;k6 timeline feature,&lt;/a&gt; the sleep time will get included in the trace and you will lose valuable insights into when your services are &lt;em&gt;really&lt;/em&gt; slowing down.&lt;/p&gt;&#xA;&lt;h3 id=&#34;what-to-do-instead&#34;&gt;What to do instead?&lt;/h3&gt;&#xA;&lt;p&gt;In the &lt;strong&gt;federated-login-test.js&lt;/strong&gt; example above, adding &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/page/waitfornavigation/&#34;&gt;&lt;code&gt;page.waitForNavigation()&lt;/code&gt;&lt;/a&gt; was the solution. This method waits for the browser’s window &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;load event&lt;/a&gt; to fire, ensuring the test is reliable and no longer waiting too little or too long until the browser script should continue its execution.&lt;/p&gt;&#xA;&lt;p&gt;If you aren’t waiting for a page navigation event, but for some in-page content that hasn’t been rendered to the page yet, you want to use &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/locator/&#34;&gt;&lt;code&gt;page.locator()&lt;/code&gt;&lt;/a&gt; and its associated methods.&lt;/p&gt;&#xA;&lt;p&gt;As an example, here’s a browser script checking if the performance testing plugin is displaying the expected information within Grafana.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;performance-app-renders.js&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { browser } from &amp;#34;k6/browser&amp;#34;&#xA;import { check } from &amp;#34;k6&amp;#34;&#xA;export const options = {&#xA;scenarios: {&#xA;ui: {&#xA;executor: &amp;#34;shared-iterations&amp;#34;,&#xA;options: {&#xA;browser: {&#xA;type: &amp;#34;chromium&amp;#34;,&#xA;},&#xA;},&#xA;},&#xA;},&#xA;}&#xA;export default async function () {&#xA;const context = await browser.newContext()&#xA;const page = await context.newPage()&#xA;// You will have to add or replace the __ENV variables as appropriate.&#xA;await page.goto(__ENV.GRAFANA_APP_URL)&#xA;// login&#xA;await page&#xA;.locator(`[data-testid=&amp;#34;data-testid Username input field&amp;#34;]`)&#xA;.fill(&amp;#34;admin&amp;#34;)&#xA;await page&#xA;.locator(`[data-testid=&amp;#34;data-testid Password input field&amp;#34;]`)&#xA;.fill(__ENV.GRAFANA_APP_PASSWORD)&#xA;await page.locator(`[data-testid=&amp;#34;data-testid Login button&amp;#34;]`).click()&#xA;await page.waitForNavigation()&#xA;// navigate to Performance page&#xA;await page.locator(`[data-testid=&amp;#34;data-testid Toggle menu&amp;#34;]`).click()&#xA;await page&#xA;.locator(`[aria-label=&amp;#34;Expand section Testing &amp;amp; synthetics&amp;#34;]`)&#xA;.click()&#xA;await page.locator(`//*[text()=&amp;#34;Performance&amp;#34;]`).click()&#xA;const perfH1Text = await page&#xA;.locator(`//h1[text()=&amp;#34;Performance&amp;#34;]`)&#xA;.textContent()&#xA;check(perfH1Text, {&#xA;&amp;#34;Performance page heading is correct&amp;#34;: (text) =&amp;gt; text === &amp;#34;Performance&amp;#34;,&#xA;})&#xA;await page.close()&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;If you follow along manually (or by turning off headless mode, as suggested in tip 1) you will notice that, at every stage, you have to wait for something to be rendered to the page before continuing. By using &lt;code&gt;page.locator()&lt;/code&gt; and its &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/locator/&#34;&gt;provided methods&lt;/a&gt;, the script waits for the content to be available before proceeding.&lt;/p&gt;&#xA;&lt;p&gt;By using a combination of &lt;code&gt;page.waitForNavigation()&lt;/code&gt; and &lt;code&gt;page.locator()&lt;/code&gt; methods, you now have a reliable script without having to add arbitrary and unreliable timeout functions.&lt;/p&gt;&#xA;&lt;h2 id=&#34;tip-3-think-about-the-asynchronous-execution-of-your-test&#34;&gt;Tip 3: Think about the asynchronous execution of your test&lt;/h2&gt;&#xA;&lt;p&gt;When writing your browser tests, it is important to evaluate and consider:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;What is the next function call &lt;em&gt;really&lt;/em&gt; doing?&lt;/li&gt;&#xA;&lt;li&gt;What is happening from the script’s point of view?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;The k6 browser API is purposefully designed to be compatible with the &lt;a href=&#34;https://playwright.dev/docs/api/class-playwright&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Playwright API for NodeJS&lt;/a&gt;. Grafana k6, however, does not run in a NodeJS environment, but uses &lt;a href=&#34;https://go.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Go&lt;/a&gt; and transpiles scripts using &lt;a href=&#34;https://github.com/grafana/sobek&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Sobek&lt;/a&gt;. Why is this important to know? &lt;br /&gt;&#xA;&lt;br /&gt;&#xA;k6 has evolved over time and two significant milestones for browser checks were introducing the &lt;a href=&#34;https://github.com/grafana/k6/pull/2228&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;event loop&lt;/a&gt; and implementing all the &lt;a href=&#34;https://github.com/grafana/k6/releases/tag/v0.52.0&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;browser APIs as async methods&lt;/a&gt;. For the most part, writing a browser test should be indistinguishable from writing native JavaScript, but there can be a few opaque ‘gotchas’ that are difficult to recognize and identify.&lt;/p&gt;&#xA;&lt;h3 id=&#34;the-native-k6check-does-not-support-passing-asynchronous-functions&#34;&gt;The native k6/check does not support passing asynchronous functions&lt;/h3&gt;&#xA;&lt;p&gt;Because all of the k6 browser API methods are asynchronous, it feels intuitive to write a check like this:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { check } from &amp;#39;k6&amp;#39;&#xA;...&#xA;// doesn&amp;#39;t work&#xA;await check(page.locator(`h1`), {&#xA;&amp;#39;text content is correct&amp;#39;: async(lo) =&amp;gt; (await lo.textContent()) === &amp;#39;Expected content&amp;#39;&#xA;})&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;This will not work, however, because the native k6 check is synchronous. To fix this problem, you can replace the native k6 check with our &lt;a href=&#34;https://jslib.k6.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;jslib.k6.io&lt;/a&gt; version. It is compatible and can be directly swapped out in any of your existing tests.&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { check } from &amp;#34;https://jslib.k6.io/k6-utils/1.6.0/index.js&amp;#34;&#xA;...&#xA;// works!&#xA;await check(page.locator(`h1`), {&#xA;&amp;#39;text content is correct&amp;#39;: async(lo) =&amp;gt; (await lo.textContent()) === &amp;#39;Expected content&amp;#39;&#xA;})&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;dont-use-pagewaitfornavigation-unnecessarily&#34;&gt;Don’t use page.waitForNavigation unnecessarily&lt;/h3&gt;&#xA;&lt;p&gt;It is important to know the underlying architecture of your website when you are authoring browser tests. Are you using a Single Page Application (SPA), such as React, Angular or Vue, or a traditional Multi Page Application (MPA)? Or maybe a mixture of both?&lt;/p&gt;&#xA;&lt;p&gt;You may expect that any time the URL changes in your browser, it would trigger a page load event — but if your application is an SPA, it uses the browser’s &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/History/pushState&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;history.pushState&lt;/a&gt; method, so the &lt;code&gt;page.waitForNavigation()&lt;/code&gt; function call will never resolve, block the rest of the execution of your script, and eventually timeout. This is especially important to note with the next ‘gotcha’ below.&lt;/p&gt;&#xA;&lt;h3 id=&#34;k6-doesnt-know-what-is-in-the-script-until-it-is-encountered&#34;&gt;k6 doesn’t know what is in the script until it is encountered&lt;/h3&gt;&#xA;&lt;p&gt;If your script execution aborted part-way through, none of your checks, logs or custom metrics that are declared and executed after that point will be registered. If you have set up your script so it only fails when a check failure threshold is reached, you are going to have false positives in your test results. &lt;em&gt;Note: see the bonus tip below to solve this.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;have-a-bots-eye-view&#34;&gt;Have a ‘bots-eye’ view&lt;/h3&gt;&#xA;&lt;p&gt;If you take the &lt;strong&gt;performance-app-renders.js&lt;/strong&gt; script from above and change the locator for the h1, the script now fails!&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;const perfH1Text = await page&#xA;.locator(`#pageContent h1`)&#xA;.textContent()&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;There are no logs indicating what has gone wrong — just a failed check. If we summarize the steps from a human perspective:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Go to your Grafana URL&lt;/li&gt;&#xA;&lt;li&gt;Fill in username, fill in password, and click &lt;strong&gt;login&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;em&gt;Wait for page navigation&lt;/em&gt;&lt;/li&gt;&#xA;&lt;li&gt;Click the &lt;strong&gt;menu&lt;/strong&gt; toggle, expand &lt;strong&gt;Testing &amp;amp; Synthetics&lt;/strong&gt;, click &lt;strong&gt;Performance&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;Check if the h1’s text content is “Performance”&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;If you follow along in your browser, open your devTools console and run &lt;code&gt;document.querySelector(‘#pageContent h1`).textContent&lt;/code&gt; — it returns “Performance!&amp;quot; So what is going on?&lt;/p&gt;&#xA;&lt;p&gt;The problem is that the bot executing the script “thinks,” “sees,” and “evaluates” things &lt;strong&gt;a lot&lt;/strong&gt; quicker than humans do. If you add this &lt;a href=&#34;https://gist.github.com/ckbedwell/c18142bb8aa20c7ba9133a8a53304e74&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;useful debug snippet&lt;/a&gt; at the beginning of the script and open the devTools console, the execution will pause, allowing an investigation into what has happened.&lt;/p&gt;&#xA;&lt;figure&#xA;class=&#34;figure-wrapper figure-wrapper__lightbox w-100p &#34;&#xA;style=&#34;max-width: 1999px;&#34;&#xA;itemprop=&#34;associatedMedia&#34;&#xA;itemscope=&#34;&#34;&#xA;itemtype=&#34;http://schema.org/ImageObject&#34;&#xA;&gt;&lt;a&#xA;class=&#34;lightbox-link&#34;&#xA;href=&#34;/media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png&#34;&#xA;itemprop=&#34;contentUrl&#34;&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;class=&#34;lazyload &#34;&#xA;data-src=&#34;/media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png&#34;data-srcset=&#34;/media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=320 320w, /media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=550 550w, /media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=750 750w, /media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=900 900w, /media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=1040 1040w, /media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=1240 1240w, /media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;A screenshot of debugging Grafana with Chrome DevTools. The screen is split in two with Grafana displayed on the left with an h1 with 0 width and 0 height highlighted and on the right is the elements panel displaying the DOM tree. The h1 contains no text content.&#34;width=&#34;1999&#34;height=&#34;716&#34;/&gt;&#xA;&lt;noscript&gt;&#xA;&lt;img&#xA;src=&#34;/media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png&#34;&#xA;alt=&#34;A screenshot of debugging Grafana with Chrome DevTools. The screen is split in two with Grafana displayed on the left with an h1 with 0 width and 0 height highlighted and on the right is the elements panel displaying the DOM tree. The h1 contains no text content.&#34;width=&#34;1999&#34;height=&#34;716&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;While waiting for the plugin to load, for a split second, Grafana has rendered an empty h1 to the screen that fulfills the selector we are looking for, so it moves onto executing the check comparison: the text content of the h1 is not “Performance,” so the check and our test ultimately fails.&lt;/p&gt;&#xA;&lt;p&gt;And that brings us nicely into our fourth tip…&lt;/p&gt;&#xA;&lt;h2 id=&#34;tip-4-write-unique-and-durable-selectors-for-pagelocator&#34;&gt;Tip 4: Write unique and durable selectors for page.locator()&lt;/h2&gt;&#xA;&lt;p&gt;We have a guide on best practices for &lt;a href=&#34;/docs/k6/latest/using-k6-browser/recommended-practices/select-elements/&#34;&gt;selecting elements&lt;/a&gt;, where the fundamental idea is to create durable selectors that:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Are unique to the page (if not the whole journey, where possible, as shown by the bug above!)&lt;/li&gt;&#xA;&lt;li&gt;Are guaranteed to be stable&lt;/li&gt;&#xA;&lt;li&gt;Convey intent in the script&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;If you were to write a browser script to test the login of Grafana, when inspecting the Document Object Model (DOM), you would see markup similar to this for the Username input field:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;&amp;lt;input class=&amp;#34;css-8tk2dk-input-input&amp;#34; name=&amp;#34;user&amp;#34; id=&amp;#34;:r0:&amp;#34; autocapitalize=&amp;#34;none&amp;#34; placeholder=&amp;#34;email or username&amp;#34; data-testid=&amp;#34;data-testid Username input field&amp;#34;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;The input element has several attributes on it. To decide which would be appropriate to use, you can assign each a score:&lt;/p&gt;&#xA;&lt;table&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;Unique to the page&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;Value is stable&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;Conveys intent&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;Total&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;autocapitalize&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;❌&#xA;&lt;/td&gt;&#xA;&lt;td&gt;❌&#xA;&lt;/td&gt;&#xA;&lt;td&gt;❌&#xA;&lt;/td&gt;&#xA;&lt;td&gt;0&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;class&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;❌&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;1&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;id&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;2&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;name&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;2.5&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;placeholder&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;2.5&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;data-testid&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;3&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;&lt;em&gt;❌ = 0, ⚠️= 0.5, ✅ = 1&lt;/em&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;The &lt;strong&gt;autocapitalize&lt;/strong&gt; attribute can immediately be ruled out. There is no guarantee it is unique to the page, it has no bearing on what you are trying to select, and it would be difficult to infer your intent when reviewing the test script.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;The &lt;strong&gt;class&lt;/strong&gt; attribute might be considered. It is often used when using tag manager tools or other rudimentary recorders to act as a selector. But there are several problems with using this attribute:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;There is no guarantee that it is unique to the page (and it isn’t, in this case, as the password input shares the same classes)&lt;/li&gt;&#xA;&lt;li&gt;They are often considered as an implementation detail by developers and are subject to change (especially in the case here, where the value is generated by the build process)&lt;/li&gt;&#xA;&lt;li&gt;Even if it was unique and stable, it makes your test scripts less maintainable. How would someone else reading your script be able to infer you are selecting the username input?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;The &lt;strong&gt;id&lt;/strong&gt; attribute should be unique, but it has similar problems to &lt;strong&gt;class&lt;/strong&gt; in this case. Those who are familiar with React APIs will recognize this ID has been generated by the &lt;a href=&#34;https://react.dev/reference/react/useId&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt;useId&lt;/code&gt; hook&lt;/a&gt;, so if the developers were to use this hook elsewhere on the page for a component that gets rendered before the input field, this &lt;strong&gt;id&lt;/strong&gt; value would shift, so it is not guaranteed to be a stable selector. In this case, it also doesn’t convey any meaning when reading the test script, so isn’t a good candidate.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;The &lt;strong&gt;name&lt;/strong&gt; and &lt;strong&gt;placeholder&lt;/strong&gt; attributes have a similar weighting and both would be strong candidates for a stable selector that conveys meaning in the test script. There are some additional considerations:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;If you want to reuse the test script for testing the page in a different language, the placeholder selector would have to be updated in the script.&lt;/li&gt;&#xA;&lt;li&gt;If you haven’t communicated with your development and/or content teams, they might be unaware of the testing contract you have just enrolled them in. They might have good reason in the future to update the value of either of these attributes and be unaware your script is about to break.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;This brings us to the &lt;strong&gt;data-testid.&lt;/strong&gt; It is unique in the DOM, it conveys intent in the script, and it has an implicit contract with other teams that its only purpose is for use in testing scripts, so it will remain stable. This is the ideal selector you should be using.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;page.locator(`[data-testid=&amp;#34;data-testid Username input field&amp;#34;]`)&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;This process works well with elements that have suitable attributes or well-labeled IDs or classes. You could strengthen and further clarify intent by adding the element’s tag name.&lt;/p&gt;&#xA;&lt;p&gt;But what happens if you don’t have any useful attributes available? There are two options, which can be combined:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Look up the node’s parent tree to find a suitable selector. If using this method, it is important not to write selectors that are too closely tied to your DOM structure. Selectors tightly coupled with the DOM are brittle and prone to breaking, as they are too closely tied to your developer’s implementation, which may change at any point.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;// good&#xA;page.locator(`#product-detail h2`)&#xA;// bad&#xA;page.locator(`#product-detail &amp;gt; section &amp;gt; div &amp;gt; div.arbitaryClass &amp;gt; h2`)&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;Use an xpath selector with a &lt;code&gt;text()&lt;/code&gt; node test. &lt;code&gt;page.locator()&lt;/code&gt; supports xpath selectors and &lt;a href=&#34;https://devhints.io/xpath&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;there are many that are very powerful&lt;/a&gt;. Targeting elements based on their text content is highly recommended because it decouples the test script from your implementation details and focuses on writing locators the same way that a user would find things on the page.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;page.locator(`//h2[text()=&amp;#34;Product Title&amp;#34;]`)&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h2 id=&#34;tip-5-use-threshold-options-or-the-fail-method-to-ensure-you-get-the-right-results&#34;&gt;Tip 5: Use threshold options or the fail() method to ensure you get the right results&lt;/h2&gt;&#xA;&lt;p&gt;Whenever you are authoring a test, you should think about your acceptance criteria to consider it a success. But how do we define what a pass or failure looks like for a browser test?&lt;/p&gt;&#xA;&lt;p&gt;k6 provides a &lt;a href=&#34;/docs/k6/latest/using-k6/checks/&#34;&gt;checks API&lt;/a&gt; where you can define at any point in the script’s execution if something has passed or failed. A check can be as simple as confirming if an API request returned a successful status code, whether an element has the correct text content, or if a user journey took an acceptable amount of time.&lt;/p&gt;&#xA;&lt;p&gt;You may think any failed checks in your script should mean the whole test should fail, but if that was the default behavior, most load tests would result in failure. When writing a k6 script, you should identify what context it is running in (i.e., is it a performance test or for synthetic monitoring?), as well as what scenarios, VUs, and iterations are being used.&lt;/p&gt;&#xA;&lt;p&gt;After establishing these details, you can determine the appropriate ways to think about success and failure, which checks to add, and appropriate thresholds — for example, is this check a warning, or is it a critical failure for our test?&lt;/p&gt;&#xA;&lt;p&gt;Here are two examples — one for performance testing, and one for synthetic monitoring — that support the k6 browser module and demonstrate how you could use the checks API.&lt;/p&gt;&#xA;&lt;h4 id=&#34;grafana-k6-performance-tests-using-the-browser-module&#34;&gt;Grafana k6 performance tests using the browser module&lt;/h4&gt;&#xA;&lt;p&gt;A k6 performance test is a versatile way to define any number of scenarios, VUs, and iterations. In the following example, we have a demo e-commerce website and we are using a hybrid test to record what happens if our recommended product API is under heavy load unexpectedly. Our recommendation engine is an important part of the application, but it’s not as business-critical as ensuring customers can place orders and check out.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;recommend-product-spike.js&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { browser } from &amp;#34;k6/browser&amp;#34;&#xA;import http from &amp;#34;k6/http&amp;#34;&#xA;import { check } from &amp;#34;https://jslib.k6.io/k6-utils/1.6.0/index.js&amp;#34;&#xA;const PRODUCT_IDS = __ENV.PRODUCT_IDS&#xA;const HAS_SOME_LEEWAY = `warn`&#xA;const SUPER_IMPORTANT_CHECK = `critical`&#xA;const LESS_IMPORTANT = `info`&#xA;export const options = {&#xA;scenarios: {&#xA;ui: {&#xA;executor: &amp;#34;constant-vus&amp;#34;,&#xA;duration: &amp;#34;1m&amp;#34;,&#xA;vus: 3,&#xA;options: {&#xA;browser: {&#xA;type: &amp;#34;chromium&amp;#34;,&#xA;},&#xA;},&#xA;exec: &amp;#34;checkoutCompletion&amp;#34;,&#xA;},&#xA;&amp;#34;spike-api&amp;#34;: {&#xA;executor: &amp;#34;ramping-vus&amp;#34;,&#xA;startVUs: 0,&#xA;stages: [&#xA;{ duration: &amp;#34;10s&amp;#34;, target: 10 },&#xA;{ duration: &amp;#34;40s&amp;#34;, target: 30 },&#xA;{ duration: &amp;#34;10s&amp;#34;, target: 10 },&#xA;],&#xA;gracefulRampDown: &amp;#34;10s&amp;#34;,&#xA;exec: &amp;#34;spikeApi&amp;#34;,&#xA;},&#xA;},&#xA;thresholds: {&#xA;[`checks{importance:${SUPER_IMPORTANT_CHECK}}`]: [&amp;#34;rate==1.0&amp;#34;],&#xA;[`checks{importance:${HAS_SOME_LEEWAY}}`]: [&amp;#34;rate&amp;gt;=0.95&amp;#34;],&#xA;[`checks{importance:${LESS_IMPORTANT}}`]: [&amp;#34;rate&amp;gt;=0.9&amp;#34;],&#xA;},&#xA;}&#xA;export function spikeApi() {&#xA;const randomProduct =&#xA;PRODUCT_IDS[Math.floor(Math.random() * PRODUCT_IDS.length)]&#xA;const res = http.get(`https://otel-demo.field-eng.grafana.net/api/recommendations?productIds=${randomProduct}`)&#xA;check(&#xA;res,&#xA;{&#xA;&amp;#34;status code is 200&amp;#34;: (r) =&amp;gt; r.status === 200,&#xA;},&#xA;{ importance: HAS_SOME_LEEWAY }&#xA;)&#xA;}&#xA;export async function checkoutCompletion() {&#xA;const context = await browser.newContext()&#xA;const page = await context.newPage()&#xA;await page.goto(`https://otel-demo.field-eng.grafana.net/`)&#xA;await page.locator(`//*[text()=&amp;#34;Go Shopping&amp;#34;]`).click()&#xA;await Promise.all([&#xA;page&#xA;.locator(`//*[text()=&amp;#34;Starsense Explorer Refractor Telescope&amp;#34;]`)&#xA;.click(),&#xA;page.waitForNavigation(),&#xA;])&#xA;// less important check&#xA;await checkForRecommendedProducts(page, `Product page`)&#xA;await Promise.all([&#xA;page.locator(`//*[text()=&amp;#34; Add To Cart&amp;#34;]`).click(),&#xA;page.waitForNavigation(),&#xA;])&#xA;// less important check&#xA;await checkForRecommendedProducts(page, `Shipping form`)&#xA;await Promise.all([&#xA;page.locator(`//*[text()=&amp;#34;Place Order&amp;#34;]`).click(),&#xA;page.waitForNavigation(),&#xA;])&#xA;// Super important check&#xA;await check(&#xA;page.locator(`h1`),&#xA;{&#xA;&amp;#34;Place order page was reached&amp;#34;: async (lo) =&amp;gt;&#xA;(await lo.textContent()) === &amp;#34;Your order is complete!&amp;#34;,&#xA;},&#xA;{ important: SUPER_IMPORTANT_CHECK }&#xA;)&#xA;// less important check&#xA;await checkForRecommendedProducts(page, `Order confirmation`)&#xA;await page.close()&#xA;}&#xA;const TWO_SECONDS = 2000&#xA;async function checkForRecommendedProducts(page, step) {&#xA;try {&#xA;await page&#xA;.locator(&#xA;`[data-cy=&amp;#34;recommendation-list&amp;#34;] [data-cy=&amp;#34;product-card&amp;#34;]:first-of-type`&#xA;)&#xA;.waitFor({ timeout: TWO_SECONDS })&#xA;} catch (e) {&#xA;await page.screenshot({ path: `./screenshots/${step}.png` })&#xA;} finally {&#xA;const cards = await page.$$(`[data-cy=&amp;#34;product-card&amp;#34;]`)&#xA;console.log(step, cards.length)&#xA;check(&#xA;cards.length,&#xA;{&#xA;&amp;#34;4 recommended products are displayed&amp;#34;: (length) =&amp;gt; length === 4,&#xA;},&#xA;{&#xA;importance: LESS_IMPORTANT,&#xA;}&#xA;)&#xA;}&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;In the script above, there are two scenarios to form a hybrid test: &lt;code&gt;spike-api&lt;/code&gt;, which is using k6’s &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-http/&#34;&gt;&lt;code&gt;http&lt;/code&gt; protocol&lt;/a&gt; to simulate a spike of traffic, and &lt;code&gt;user-checkout&lt;/code&gt; which is a browser test simulating the checkout flow. There are three checks that are tagged with a key of importance and a varying value, depending on what level of success we require for the check.&lt;/p&gt;&#xA;&lt;p&gt;In the &lt;code&gt;options&lt;/code&gt; object, a threshold has been set for each of these key/value pairs that will dictate whether the test has passed or failed. The &lt;code&gt;abortOnFail&lt;/code&gt; option is not being used in the thresholds because valuable data would be lost if the test ended prematurely. If failures started occurring, it would be useful to know what the extent of the failure looks like for the API and what is happening on the frontend in the browser.&lt;/p&gt;&#xA;&lt;h4 id=&#34;synthetic-monitoring-check&#34;&gt;Synthetic Monitoring check&lt;/h4&gt;&#xA;&lt;p&gt;If you are running a Synthetic Monitoring browser check, it will always be one scenario with one VU and one iteration. Synthetic Monitoring doesn’t currently support the &lt;code&gt;thresholds&lt;/code&gt; object in the options declaration (but it’s coming soon!), so you have to use the explicit &lt;a href=&#34;/docs/k6/latest/javascript-api/k6/fail/&#34;&gt;&lt;code&gt;fail()&lt;/code&gt; method&lt;/a&gt; to let the probe know the check has failed.&lt;/p&gt;&#xA;&lt;p&gt;Synthetic Monitoring browser checks behave differently than k6 checks because they primarily assess if your test passed or failed based on your definition of uptime. For non-scripted Synthetic Monitoring checks, you define uptime with a set of assertions in its own step during check creation, but because browser checks are written as a script, it is up to you to mark out explicitly what you want to count towards defining uptime.&lt;/p&gt;&#xA;&lt;p&gt;If you take our &lt;strong&gt;recommended-product-spike-test.js&lt;/strong&gt; script above and extract the checkout flow scenario, it would only need a small modification to suit the needs of a Synthetic Monitoring browser check. By adding the &lt;code&gt;fail()&lt;/code&gt; method to the check, confirming if the order confirmation page was reached, the Synthetic Monitoring probe will now understand what constitutes a failure of uptime and report correctly.&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (&#xA;!(await check(page.locator(`h1`), {&#xA;&amp;#34;Place order page was reached&amp;#34;: async (lo) =&amp;gt; (await lo.textContent()) === &amp;#34;Your order is complete!&amp;#34;,&#xA;}))&#xA;) {&#xA;fail(`Order completion page was not reached`)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;We can leave our less important checks in the script without adding an explicit fail to them, as that’s just a bonus we are receiving from this set-up. We could even add a custom alert using &lt;a href=&#34;/products/cloud/alerting/&#34;&gt;Grafana Alerting&lt;/a&gt; to know if the recommended products aren’t rendering consistently.&lt;/p&gt;&#xA;&lt;p&gt;This kind of flexibility in your Synthetic Monitoring browser checks means you can set primary and secondary assertions in just one execution, saving you both time and money!&lt;/p&gt;&#xA;&lt;h2 id=&#34;bonus-tip-dont-just-account-for-the-happy-path&#34;&gt;Bonus tip: don’t just account for the ‘happy’ path&lt;/h2&gt;&#xA;&lt;p&gt;A notorious mistake in any kind of testing is assuming they will always succeed. However, the real value of testing is when the inevitable failure occurs, how well do the tests inform us of the problem they encountered?&lt;/p&gt;&#xA;&lt;p&gt;If you look at the checkout scenario in the &lt;strong&gt;recommend-product-spike.js&lt;/strong&gt;, there are several &lt;code&gt;page.locator().click()&lt;/code&gt; functions called. What happens if our application has an error and these aren’t displaying correctly and the selectors fail?&lt;/p&gt;&#xA;&lt;p&gt;Each iteration will wait the &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/locator/click/#clickoptions&#34;&gt;default 30 seconds&lt;/a&gt; before timing out and throwing a failure. This could be an issue for our test because it “blocks” a VU for 30 seconds before ending the iteration and starting again. The first part of the problem is this test only runs for one minute, so if it encounters a problem early, we lose a lot of potential iterations and all the additional data they would generate.&lt;/p&gt;&#xA;&lt;p&gt;There are two ways of solving this problem:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Providing each &lt;code&gt;page.locator().click()&lt;/code&gt; (and similar methods) with their own appropriate timeouts&lt;/li&gt;&#xA;&lt;li&gt;Setting a default timeout value on the page using &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/page/setdefaulttimeout/#setdefaulttimeouttimeout&#34;&gt;&lt;code&gt;page.setDefaultTimeout()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Each of these approaches has its pros and cons and is up to you to decide which works best for you.&lt;/p&gt;&#xA;&lt;p&gt;The second problem is outlined above in tip three: the test execution was halted, the check confirming if the order page was reached is never encountered, and this failure goes unreported in the test’s metrics. The solution is to add a catch block to our &lt;code&gt;try / finally&lt;/code&gt; statement:&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet &#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;button x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;Copy code to clipboard&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;Copy&lt;/span&gt;&#xA;&lt;/button&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet &#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;try {&#xA;...&#xA;} catch (e) {&#xA;console.error(e)&#xA;await page.screenshot({&#xA;path: `./screenshots/${__VU}_${__ITER}-failure.png`,&#xA;})&#xA;check(&#xA;null,&#xA;{&#xA;&amp;#34;Place order page was reached&amp;#34;: false,&#xA;},&#xA;{ important: SUPER_IMPORTANT_CHECK }&#xA;)&#xA;} finally {&#xA;...&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;&lt;em&gt;Note: It is good practice to take a screenshot to make your debugging sessions easier.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;Synthetic Monitoring reports an uptime failure if any execution results in an unhandled exception, so if you do add this catch block, remember to rethrow the error (with your own logging if you favor it over the default) or call k6’s &lt;code&gt;fail()&lt;/code&gt; method.&lt;/p&gt;&#xA;&lt;h2 id=&#34;summing-up&#34;&gt;Summing up&lt;/h2&gt;&#xA;&lt;p&gt;The k6 browser API is a versatile tool to help monitor your website’s performance and reliability. With the tips above, you can ensure a tight feedback loop when authoring your tests, while also keeping them adaptable and bug-free. Ultimately, these best practices will make it easier for you to identify potential performance issues and optimize your end-user experiences.&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;Grafana Cloud is the easiest way to get started with browser testing. With &lt;a href=&#34;/products/cloud/k6/&#34;&gt;Grafana Cloud k6&lt;/a&gt;, you can effortlessly combine frontend and backend testing in a single cloud-based test. &lt;a href=&#34;/products/cloud/synthetic-monitoring/&#34;&gt;Grafana Cloud Synthetic Monitoring&lt;/a&gt; enables continuous monitoring of your critical journeys in a production environment. We offer a generous forever-free tier and plans tailored for every use case. Sign up for free now (&lt;a href=&#34;/auth/sign-up/create-user?pg=plugins&amp;amp;plcmt=grafana-synthetic-monitoring-app&amp;amp;redirectPath=synthetic-monitoring&#34;&gt;Grafana Cloud k6&lt;/a&gt; or &lt;a href=&#34;/auth/sign-up/create-user?pg=plugins&amp;amp;plcmt=grafana-synthetic-monitoring-app&#34;&gt;Grafana Cloud Synthetic Monitoring&lt;/a&gt;)!&lt;/em&gt;&lt;/p&gt;】&lt;p&gt;鉴于现代网站的复杂性，浏览器测试对于确保良好的用户体验至关重要。借助 &lt;a href=&#34;/docs/k6/latest/using-k6-browser/&#34;&gt;Grafana k6 浏览器模块&lt;/a&gt;，您可以与真实的 Web 浏览器交互并模拟用户交互 - 例如单击、键入或导航页面 - 收集前端指标，提高网站可靠性，并在性能问题影响用户之前修复它们。&lt;/p&gt;&#xA;&lt;p&gt;作为 &lt;a href=&#34;/oss/k6/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana k6 OSS&lt;/a&gt; 的一部分，k6 浏览器模块也与我们完全托管的&lt;a href=&#34;/ products/cloud/k6/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana Cloud k6&lt;/a&gt; 解决方案，以及&lt;a href=&#34;/products/cloud/synthetic-monitoring/?pg=blog&amp;plcmt=body-txt&#34;&gt;Grafana 云综合监控&lt;/a&gt;，提供开箱即用的监控功能。这意味着您可以根据您的测试需求在这三个环境中重复使用浏览器测试脚本。&lt;/p&gt;&#xA;&lt;p&gt;通过与 &lt;a href=&#34;https://playwright.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Playwright&lt;/a&gt; 类似的 API，k6 浏览器模块使那些人可以轻松使用熟悉 Playwright Web 测试框架来编写他们的第一个浏览器测试。也就是说，我们知道在编写浏览器测试脚本并将其集成到您的工作流程中时，一些最佳实践可以发挥很大作用。&lt;/p&gt;&#xA;&lt;p&gt;在本博客中，我们概述了您今天可以应用的五个技巧，以便在 Grafana k6、Grafana Cloud k6 和 Grafana Cloud Synthetic Monitoring 中编写更好的浏览器测试。&lt;/p&gt;&#xA;&lt;h2 id=&#34;tip-1-run-the-test-locally-for-a-faster-feedback-loop&#34;&gt;提示 1. 在本地运行测试以获得更快的反馈循环&lt;/h2&gt;&#xA;&lt;p&gt;我们的云产品（包括 Grafana Cloud k6 和综合监控）是可视化脚本输出的最佳方式，但在计算机上本地运行测试是更快地调试和迭代的好方法。首先，您需要：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/docs/k6/latest/set-up/install-k6/&#34;&gt;在您的计算机上安装 Grafana k6&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;拥有 Chrome（或&lt;a href=&#34;https://alternativeto.net/category/browsers/chromium-based/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;基于 Chromium 的浏览器&lt;/a&gt; ）可用&lt;/li&gt;&#xA;&lt;li&gt;设置一个空目录&lt;/li&gt;&#xA;&lt;li&gt;使用&lt;a href=&#34;/docs/k6/latest/using-k6/scenarios/executors/shared-iterations/&#34;&gt;&lt;code&gt;shared-iterations&lt;/code&gt;执行器创建脚本&lt;/a&gt;&lt; /里&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;为了在本地调试浏览器脚本，请确保您的测试场景仅运行一个虚拟用户 (VU) 和一次迭代。 &lt;code&gt;shared-iterations&lt;/code&gt; 执行器默认设置了这些选项，因此是调试的完美选择。您可以在编写测试时快速运行测试、读取日志输出并减少反馈循环。&lt;/p&gt;&#xA;&lt;p&gt;随着测试长度和复杂性的增加，日志可能会变得过于嘈杂而无法有效使用，或者可能会丢失关键信息来查明潜在问题。以这个脚本为例，它测试联邦 l&lt;a href=&#34;https://grafana.com&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;grafana.com&lt;/a&gt; 的登录流程：&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;federated-login-test.js&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;从“k6/browser”导入 { browser }&#xA;从“https://jslib.k6.io/k6-utils/1.6.0/index.js”导入{检查}&#xA;导出常量选项= {&#xA;场景：{&#xA;用户界面：{&#xA;执行者：“共享迭代”，&#xA;选项： {&#xA;浏览器：{&#xA;类型：“铬”，&#xA;},&#xA;},&#xA;},&#xA;},&#xA;}&#xA;导出默认异步函数 () {&#xA;const context = 等待 browser.newContext()&#xA;const page = 等待 context.newPage()&#xA;等待 page.goto(`https://grafana.com/`)&#xA;等待 page.locator(`#menu__login-link`).click()&#xA;等待页面.waitForNavigation()&#xA;等待 page.locator(`button[aria-label=&#34;使用 Google 登录&#34;]`).click()&#xA;等待页面.waitForNavigation()&#xA;// 您必须根据需要添加或替换 __ENV 变量。&#xA;等待页面&#xA;.locator(`input[aria-label=&#34;电子邮件或电话&#34;]`)&#xA;.fill(__ENV.GRAFANA_STACK_USER_EMAIL)&#xA;等待 page.locator(`//*[text()=&#34;下一步&#34;]`).click()&#xA;等待检查(page.locator(`form h2`), {&#xA;“表单标题文本正确”：async (lo) =&gt;&#xA;(await lo.textContent()) === `Grafana Labs`,&#xA;})&#xA;等待页面.close()&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;您可以通过在终端中执行&lt;code&gt;k6 run federated-login-test.js&lt;/code&gt;来运行测试，但看起来测试提前结束了。检查永远不会运行，因此它不会触发阈值失败，如果您检查日志，您会看到：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;未捕获（承诺）获取“h2”文本内容：检查的目标已导航或关闭&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;这是一个神秘的日志，尤其是当您不熟悉底层 API 及其功能时。如果您按照这些步骤在自己的浏览器中单击，则不清楚问题是什么，因为您最终会看到 &lt;code&gt;document.querySelector(&#39;form h2`).textContent&lt;/code&gt; 的页面有效并返回预期结果。&lt;/p&gt;&#xA;&lt;p&gt;使用 &lt;a href=&#34;/docs/k6/latest/using-k6-browser/options/#environment-variable-options&#34;&gt;k6 浏览器 CLI 选项&lt;/a&gt;，哟您可以禁用无头模式并在屏幕上观看您的 Chromium 实例，这样您就可以跟随机器人逐步执行脚本。&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;K6_BROWSER_HEADLESS=false k6 run {{scriptName}}.js&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;这通常可以提供宝贵的见解来发现日志本身无法完全传达的问题。&lt;/p&gt;&#xA;&lt;p&gt;在上面的示例中，现在很容易确定问题所在：永远无法到达最后一页。我们忘记在单击&lt;strong&gt;下一步&lt;/strong&gt;按钮后等待导航更改，并且异步检查功能无法成功完成，因为在执行时，其页面上下文被取消。&lt;/p&gt;&#xA;&lt;p&gt;解决方案是在第36行添加&lt;code&gt;page.waitForNavigation()&lt;/code&gt;，现在测试通过了。 🎉&lt;/p&gt;&#xA;&lt;p&gt;与浏览器交互时，机器人比人类快得多。您可能需要使用 &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/page/screenshot/&#34;&gt;&lt;code&gt;page.screenshot()&lt;/code&gt;&lt;/a&gt; 方法或使用 &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/page/waitfortimeout/&#34;&gt;&lt;code&gt;page.waitForTimeout()&lt;/code&gt;&lt;/a&gt; 人为地增加异步步骤之间的时间，这样你就可以处理 到底是怎么回事。但是，如果您确实在脚本中注入超时以​​帮助调试，请记住随后将其删除，因为......&lt;/p&gt;&#xA;&lt;h2 id=&#34;tip-2-timeouts-and-sleep-are-anti-patterns&#34;&gt;提示 2. 超时和睡眠是反模式！&lt;/h2&gt;&#xA;&lt;p&gt;如果您以前见过 k6 脚本，那么它很可能包含 &lt;a href=&#34;/docs/k6/latest/javascript-api/k6/sleep/&#34;&gt;&lt;code&gt;sleep(t)&lt; /代码&gt;&lt;/a&gt;。在专注于在协议级别测试 API 的非浏览器脚本的上下文中，这通常是 &lt;a href=&#34;/docs/k6/latest/using-k6-browser/recommended-practices/simulate- user-input-delay/&#34;&gt;模拟真实用户的输入延迟&lt;/a&gt;。然而，在使用浏览器时，这可能会导致不稳定且不可靠的测试，从而难以理清和调试。这是因为 k6 脚本暂停，但浏览器继续以未知的速率执行其任务和进程，这可能会因一次测试而异。&lt;/p&gt;&#xA;&lt;p&gt;如果在 &lt;strong&gt;federated-login-test.js&lt;/strong&gt; 脚本中，您没有添加 &lt;code&gt;page.waitForNavigation()&lt;/code&gt;，而是添加了 &lt;code&gt;sleep(5)&lt;/code&gt; ，这通常会使测试通过；但是，您现在每次运行时都会引入以下问题之一：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;脚本中的迭代现在运行时间超过了必要的时间（因此它将与给你钱）&lt;/li&gt;&#xA;&lt;li&gt;脚本中的迭代运行时间不够长并报告失败（因此会花费您金钱）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;您添加的 &lt;code&gt;sleep(t)&lt;/code&gt; 或 &lt;code&gt;page.waitForTimeout()&lt;/code&gt; 调用越多，这些问题就越复杂并引入更多问题。如果您将脚本与 Grafana Cloud Synthetic Monitoring 结合使用，浏览器检查当前具有 &lt;a href=&#34;/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6-browser/#public-preview-limitations &#34;&gt;运行时间有限制&lt;/a&gt;，因此您可能会无意中达到该限制。对于 k6 浏览器测试，您不必要地增加了内存和 CPU 使用率，这可能不仅会导致当前迭代失败，还会使您的脚本完全报告失败。&lt;/p&gt;&#xA;&lt;p&gt;如果使用 &lt;code&gt;sleep(t)&lt;/code&gt;，请务必注意，它是 k6 原生的同步函数，会阻止 JavaScript 事件循环。如果您使用&lt;a href=&#34;/docs/grafana-cloud/whats-new/2024-07-03-browser-timeline-and-screenshots-in-grafana-cloud-k6/&#34;&gt;k6 时间线功能，&lt; /a&gt; 睡眠时间将包含在跟踪中，您将无法了解服务何时&lt;em&gt;真正&lt;/em&gt;变慢。&lt;/p&gt;&#xA;&lt;h3 id=&#34;what-to-do-instead&#34;&gt;该怎么办？&lt;/h3&gt;&#xA;&lt;p&gt;在上面的 &lt;strong&gt;federated-login-test.js&lt;/strong&gt; 示例中，添加 &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/page/waitfornavigation/&#34;&gt;&lt; code&gt;page.waitForNavigation()&lt;/code&gt;&lt;/a&gt; 是解决方案。此方法等待浏览器窗口 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;load 事件&lt;/a&gt; 触发，确保测试可靠，并且在浏览器脚本继续执行之前不再等待太短或太长的时间。&lt;/p&gt;&#xA;&lt;p&gt;如果您不是在等待页面导航事件，而是等待某些尚未呈现到页面的页内内容，则需要使用 &lt;a href=&#34;/docs/k6/latest/javascript -api/k6-browser/locator/&#34;&gt;&lt;code&gt;page.locator()&lt;/code&gt;&lt;/a&gt; 及其关联方法。&lt;/p&gt;&#xA;&lt;p&gt;作为示例，下面是一个浏览器脚本，用于检查性能测试插件是否在 Grafana 中显示预期信息。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;performance-app-renders.js&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;从“k6/browser”导入 { browser }&#xA;从“k6”导入{检查}&#xA;导出常量选项= {&#xA;场景：{&#xA;用户界面：{&#xA;执行者：“共享迭代”，&#xA;选项： {&#xA;浏览器：{&#xA;类型：“铬”，&#xA;},&#xA;},&#xA;},&#xA;},&#xA;}&#xA;出口t 默认异步函数 () {&#xA;const context = 等待 browser.newContext()&#xA;const page = 等待 context.newPage()&#xA;// 您必须根据需要添加或替换 __ENV 变量。&#xA;等待 page.goto(__ENV.GRAFANA_APP_URL)&#xA;// 登录&#xA;等待页面&#xA;.locator(`[data-testid=&#34;data-testid 用户名输入字段&#34;]`)&#xA;.fill(&#34;管理员&#34;)&#xA;等待页面&#xA;.locator(`[data-testid=&#34;data-testid 密码输入字段&#34;]`)&#xA;.fill(__ENV.GRAFANA_APP_PASSWORD)&#xA;等待 page.locator(`[data-testid=&#34;data-testid 登录按钮&#34;]`).click()&#xA;等待页面.waitForNavigation()&#xA;// 导航到性能页面&#xA;等待 page.locator(`[data-testid=&#34;data-testid 切换菜单&#34;]`).click()&#xA;等待页面&#xA;.locator(`[aria-label=&#34;展开测试和合成部分&#34;]`)&#xA;。点击（）&#xA;等待 page.locator(`//*[text()=&#34;性能&#34;]`).click()&#xA;const perfH1Text = 等待页面&#xA;.locator(`//h1[text()=&#34;性能&#34;]`)&#xA;.textContent()&#xA;检查（perfH1Text，{&#xA;&#34;性能页面标题正确&#34;: (text) =&gt; text === &#34;性能&#34;,&#xA;})&#xA;等待页面.close()&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;如果您手动进行操作（或者按照技巧 1 中的建议关闭无头模式），您会注意到，在每个阶段，您都必须等待某些内容呈现到页面上才能继续。通过使用 &lt;code&gt;page.locator()&lt;/code&gt; 及其&lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/locator/&#34;&gt;提供的方法&lt;/a&gt;，脚本会等待在继续之前使内容可用。&lt;/p&gt;&#xA;&lt;p&gt;通过结合使用 &lt;code&gt;page.waitForNavigation()&lt;/code&gt; 和 &lt;code&gt;page.locator()&lt;/code&gt; 方法，您现在拥有可靠的脚本，而无需添加任意且不可靠的超时函数.&lt;/p&gt;&#xA;&lt;h2 id=&#34;tip-3-think-about-the-asynchronous-execution-of-your-test&#34;&gt;提示 3：考虑测试的异步执行&lt;/h2&gt;&#xA;&lt;p&gt;编写浏览器测试时，评估和考虑非常重要：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;下一个函数调用&lt;em&gt;真正&lt;/em&gt;在做什么？&lt;/li&gt;&#xA;&lt;li&gt;从脚本的角度来看发生了什么？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;k6 浏览器 API 专门设计为与 &lt;a href=&#34;https://playwright.dev/docs/api/class-playwright&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Playwright API 兼容对于 NodeJS&lt;/a&gt;。然而，Grafana k6 并不在 NodeJS 环境中运行，而是使用 &lt;a href=&#34;https://go.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Go&lt;/a&gt; 并使用&lt;a href=&#34;https://github.com/grafana/sobek&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;索贝克&lt;/a&gt;。为什么知道这一点很重要？ &lt;br/&gt;&#xA;&lt;br/&gt;&#xA;k6 随着时间的推移不断发展，浏览器检查的两个重要里程碑是引入 &lt;a href=&#34;https://github.com/grafana/k6/pull/2228&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;事件循环&lt;/a&gt; 并实现所有 &lt;a href=&#34;https://github.com/grafana/k6/releases/tag/v0.52.0&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;浏览器 API 作为异步方法&lt;/a&gt;。在大多数情况下，编写浏览器测试应该与编写原生 JavaScript，但可能存在一些难以识别和识别的不透明“陷阱”。&lt;/p&gt;&#xA;&lt;h3 id=&#34;the-native-k6check-does-not-support-passing-asynchronous-functions&#34;&gt;原生 k6/check 不支持传递异步函数&lt;/h3&gt;&#xA;&lt;p&gt;因为所有 k6 浏览器 API 方法都是异步的，所以编写这样的检查感觉很直观：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;从 &#39;k6&#39; 导入 { check }&#xA;...&#xA;// 不起作用&#xA;等待检查(page.locator(`h1`), {&#xA;&#39;文本内容正确&#39;: async(lo) =&gt; (await lo.textContent()) === &#39;预期内容&#39;&#xA;})&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;但是，这不起作用，因为本机 k6 检查是同步的。要解决此问题，您可以将原生 k6 检查替换为我们的 &lt;a href=&#34;https://jslib.k6.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;jslib.k6.io&lt;/a &gt; 版本。它是兼容的，并且可以在您现有的任何测试中直接替换。&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;从“https://jslib.k6.io/k6-utils/1.6.0/index.js”导入 { check }&#xA;...&#xA;// 有效！&#xA;等待检查(page.locator(`h1`), {&#xA;&#39;文本内容正确&#39;: async(lo) =&gt; (await lo.textContent()) === &#39;预期内容&#39;&#xA;})&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h3 id=&#34;dont-use-pagewaitfornavigation-unnecessarily&#34;&gt;不必要时不要使用 page.waitForNavigation&lt;/h3&gt;&#xA;&lt;p&gt;在编写浏览器测试时，了解网站的底层架构非常重要。您使用的是单页面应用程序 (SPA)，例如 React、Angular 或 Vue，还是传统的多页面应用程序 (MPA)？或者可能是两者的混合？&lt;/p&gt;&#xA;&lt;p&gt;您可能期望只要浏览器中的 URL 发生变化，就会触发页面加载事件 - 但如果您的应用程序是 SPA，它会使用浏览器的 &lt;a href=&#34;https://developer.mozilla.org /en-US/docs/Web/API/History/pushState&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;history.pushState&lt;/a&gt; 方法，因此 &lt;code&gt;page.waitForNavigation()&lt;/code&gt;功能呼叫永远不会解决，阻止其余的 of 执行脚本，并最终超时。对于下面的下一个“陷阱”，这一点尤其需要注意。&lt;/p&gt;&#xA;&lt;h3 id=&#34;k6-doesnt-know-what-is-in-the-script-until-it-is-encountered&#34;&gt;k6 在遇到脚本之前并不知道脚本中有什么内容&lt;/h3&gt;&#xA;&lt;p&gt;如果您的脚本执行中途中止，则在此之后声明和执行的任何检查、日志或自定义指标都不会被注册。如果您已将脚本设置为仅在达到检查失败阈值时才会失败，则测试结果中将会出现误报。 &lt;em&gt;注意：请参阅下面的额外提示来解决此问题。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;have-a-bots-eye-view&#34;&gt;拥有“机器人之眼”视图&lt;/h3&gt;&#xA;&lt;p&gt;如果您采用上面的 &lt;strong&gt;performance-app-renders.js&lt;/strong&gt; 脚本并更改 h1 的定位器，该脚本现在会失败！&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;const perfH1Text = 等待页面&#xA;.locator(`#pageContent h1`)&#xA;.textContent()&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;没有任何日志表明出了什么问题——只是检查失败。如果我们从人的角度总结一下步骤：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;转到您的 Grafana 网址&lt;/li&gt;&#xA;&lt;li&gt;填写用户名，填写密码，然后点击&lt;strong&gt;登录&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;em&gt;等待页面导航&lt;/em&gt;&lt;/li&gt;&#xA;&lt;li&gt;点击&lt;strong&gt;菜单&lt;/strong&gt;开关，展开&lt;strong&gt;测试与合成&lt;/strong&gt;，点击&lt;strong&gt;性能&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;检查h1的文本内容是否为“Performance”&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如果您在浏览器中按照说明进行操作，请打开 devTools 控制台并运行 &lt;code&gt;document.querySelector(&#39;#pageContent h1`).textContent&lt;/code&gt; — 它会返回“Performance!”那么这是怎么回事？&lt; /p&gt;&#xA;&lt;p&gt;问题在于，执行脚本的机器人“思考”、“看到”和“评估”事物的速度比人类快得多。如果您在脚本开头添加此&lt;a href=&#34;https://gist.github.com/ckbedwell/c18142bb8aa20c7ba9133a8a53304e74&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;有用的调试代码段&lt;/a&gt;并打开devTools 控制台中，执行将暂停，以便调查发生了什么。&lt;/p&gt;&#xA;&lt;图&#xA;类=“图包装图包装__lightbox w-100p”&#xA;样式=“最大宽度：1999px；”&#xA;itemprop =“关联媒体”&#xA;项目范围=“”&#xA;itemtype =“http://schema.org/ImageObject”&#xA;&gt;&lt;一个&#xA;类=“灯箱链接”&#xA;href=&#34;/media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png&#34;&#xA;itemprop=“内容网址”&#xA;&gt;&lt;div class=&#34;img-wrapper w-100p h-auto&#34;&gt;&lt;img&#xA;类=“延迟加载”&#xA;数据-SRc =“/media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png”data-srcset =“/media/blog/5-提示-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=320 320w，/media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=550 550w， /media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=750 750w，/media/blog/5-tips-for -k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=900 900w，/media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=1040 1040w， /media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=1240 1240w, /media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png?w=1920 1920w&#34;&#xA;data-sizes=&#34;auto&#34;alt=&#34;使用 Chrome DevTools 调试 Grafana 的屏幕截图。屏幕分为两部分，左侧显示 Grafana，突出显示 0 宽度和 0 高度的 h1，右侧是显示的元素面板DOM 树。 h1 不包含文本内容。&#34;width=&#34;1999&#34;height=&#34;716&#34;/&gt;&#xA;&lt;无脚本&gt;&#xA;&lt;图片&#xA;src =“/media/blog/5-tips-for-k6-browser-tests/5-tips-for-k6-browser-tests-debugging-snippet.png”&#xA;alt=&#34;使用 Chrome DevTools 调试 Grafana 的屏幕截图。屏幕分为两部分，左侧显示 Grafana，突出显示 0 宽度和 0 高度的 h1，右侧是显示 DOM 树的元素面板。h1 包含无文字内容。&#34;width=&#34;1999&#34;height=&#34;716&#34;/&gt;&#xA;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&#xA;&lt;p&gt;在等待插件加载的一瞬间，Grafana 在屏幕上渲染了一个空的 h1，满足我们正在寻找的选择器，因此它开始执行检查比较：h1 的文本内容是不是“性能”，因此检查和我们的测试最终失败。&lt;/p&gt;&#xA;&lt;p&gt;这让我们很好地进入了第四个技巧......&lt;/p&gt;&#xA;&lt;h2 id=&#34;tip-4-write-unique-and-durable-selectors-for-pagelocator&#34;&gt;提示 4：为 page.locator() 编写唯一且持久的选择器&lt;/h2&gt;&#xA;&lt;p&gt;我们有一个关于&lt;a href=&#34;/docs/k6/latest/using-k6-browser/recommished-practices/select-elements/&#34;&gt;选择元素&lt;/a&gt;的最佳实践指南，其中基本思想是创建持久的选择器：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于页面来说是唯一的（如果不是整个旅程，如果可能的话，如上面的错误所示！）&lt;/li&gt;&#xA;&lt;li&gt;保证稳定&lt;/li&gt;&#xA;&lt;li&gt;在脚本中传达意图&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如果您要编写一个浏览器脚本来测试 Grafana 的登录，那么在检查文档对象模型 (DOM) 时，您将在用户名输入字段中看到与此类似的标记：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet code-snippet__mini&#34;&gt;&lt;div class=&#34;lang-toolbar__mini&#34;&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/但是吨&gt;&#xA;&lt;/span&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet code-snippet__border&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;&lt;input class=&#34;css-8tk2dk-input-input&#34; name=&#34;user&#34; id=&#34;:r0:&#34; autocapitalize=&#34;none&#34; placeholder=&#34;电子邮件或用户名&#34; data-testid=&#34;data-testid 用户名输入字段&#34;&gt;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;输入元素有几个属性。要决定适合使用哪个，您可以为每个分配一个分数：&lt;/p&gt;&#xA;&lt;表&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;页面唯一&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;价值稳定&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;传达意图&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;总计&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;自动大写&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;❌&#xA;&lt;/td&gt;&#xA;&lt;td&gt;❌&#xA;&lt;/td&gt;&#xA;&lt;td&gt;❌&#xA;&lt;/td&gt;&#xA;&lt;td&gt;0&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;类别&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;❌&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;1&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;id&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;2&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;姓名&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;TD&gt;2.5&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;占位符&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;⚠️&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;TD&gt;2.5&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;数据测试id&lt;/strong&gt;&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;✅&#xA;&lt;/td&gt;&#xA;&lt;td&gt;3&#xA;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/表&gt;&#xA;&lt;p&gt;&lt;em&gt;❌=0，⚠️=0.5，✅=1&lt;/em&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可以立即排除&lt;strong&gt;自动大写&lt;/strong&gt;属性。不能保证它对于页面来说是唯一的，它与您尝试选择的内容无关，并且在查看测试脚本时很难推断您的意图。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可以考虑&lt;strong&gt;class&lt;/strong&gt;属性。当使用标签管理器工具或其他基本记录器充当选择器时，通常会使用它。但是使用这个属性有几个问题：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无法保证它对于页面来说是唯一的（在本例中，它不是唯一的，因为密码输入共享相同的类）&lt;/li&gt;&#xA;&lt;li&gt;它们通常被开发人员视为实现细节，并且可能会发生更改（尤其是在此处的情况下，其中值是由构建过程生成的）&lt;/li&gt;&#xA;&lt;li&gt;即使它是独特且稳定的，它也会使您的测试脚本更难以维护。其他人阅读您的脚本如何能够推断您正在选择用户名输入？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;id&lt;/strong&gt; 属性应该是唯一的，但在本例中它与 &lt;strong&gt;class&lt;/strong&gt; 存在类似的问题。熟悉 React API 的人会认识到此 ID 是由 &lt;a href=&#34;https://react.dev/reference/react/useId&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;&lt;code&gt; 生成的useId&lt;/code&gt; 钩子&lt;/a&gt;，因此，如果开发人员要在页面上的其他位置使用此钩子来获取在输入字段之前呈现的组件，则此 &lt;strong&gt;id&lt;/strong&gt; 值将会发生变化，因此不保证是稳定的选择器。在这种情况下，它也没有传达任何我阅读测试脚本时出现错误，因此不是一个好的候选者。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;名称&lt;/strong&gt;和&lt;strong&gt;占位符&lt;/strong&gt;属性具有相似的权重，两者都是在测试脚本中传达含义的稳定选择器的有力候选者。还有一些额外的注意事项：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果您想重复使用测试脚本来测试不同语言的页面，则必须在脚本中更新占位符选择器。&lt;/li&gt;&#xA;&lt;li&gt;如果您尚未与开发和/或内容团队沟通，他们可能不知道您刚刚为他们注册的测试合同。他们将来可能有充分的理由更新这两个属性的值并且不知道您的脚本即将崩溃。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;这给我们带来了&lt;strong&gt;data-testid。&lt;/strong&gt;它在 DOM 中是唯一的，它在脚本中传达意图，并且它与其他团队有一个隐含的合同，其唯一目的是用于测试脚本，因此它将保持稳定。这是您应该使用的理想选择器。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;page.locator(`[data-testid=&#34;data-testid 用户名输入字段&#34;]`)&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;此过程适用于具有合适属性或标记良好的 ID 或类的元素。您可以通过添加元素的标签名称来加强和进一步阐明意图。&lt;/p&gt;&#xA;&lt;p&gt;但是如果您没有任何有用的属性，会发生什么情况？有两个选项可以组合使用：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;查找节点的父树以找到合适的选择器。如果使用此方法，重要的是不要编写与 DOM 结构过于紧密相关的选择器。与 DOM 紧密耦合的选择器很脆弱并且容易崩溃，因为它们与开发人员的实现联系得太紧密，而开发人员的实现可能随时发生变化。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 好&#xA;page.locator(`#产品详细信息 h2`)&#xA;// 坏的&#xA;page.locator(`#product-detail &gt; 部分 &amp;gt; div &gt; div.arbitaryClass &gt; h2`)&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;ol开始=“2”&gt;&#xA;&lt;li&gt;将 xpath 选择器与 &lt;code&gt;text()&lt;/code&gt; 节点测试结合使用。 &lt;code&gt;page.locator()&lt;/code&gt; 支持 xpath 选择器，&lt;a href=&#34;https://devhints.io/xpath&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;有很多非常强大的选择器&lt;/a&gt;。强烈建议根据文本内容定位元素，因为它将测试脚本与实现细节分离，并专注于编写定位器，就像用户在页面上查找内容一样。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;page.locator(`//h2[text()=&#34;产品标题&#34;]`)&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h2 id=&#34;tip-5-use-threshold-options-or-the-fail-method-to-ensure-you-get-the-right-results&#34;&gt;提示 5：使用阈值选项或fail() 方法确保您获得正确的结果&lt;/h2&gt;&#xA;&lt;p&gt;每当您编写测试时，您都应该考虑您的接受标准以将其视为成功。但是我们如何定义浏览器测试的通过或失败？&lt;/p&gt;&#xA;&lt;p&gt;k6 提供了一个&lt;a href=&#34;/docs/k6/latest/using-k6/checks/&#34;&gt;检查 API&lt;/a&gt;，您可以在脚本执行的任何时刻定义某些内容是否通过或失败。检查可以很简单，例如确认 API 请求是否返回成功的状态代码、元素是否具有正确的文本内容，或者用户旅程是否花费了可接受的时间。&lt;/p&gt;&#xA;&lt;p&gt;您可能认为脚本中任何失败的检查都意味着整个测试应该失败，但如果这是默认行为，则大多数负载测试都会导致失败。在编写 k6 脚本时，您应该确定它在什么上下文中运行（即，它是性能测试还是综合监控？），以及正在使用什么场景、VU 和迭代。&lt;/p&gt;&#xA;&lt;p&gt;建立这些详细信息后，您可以确定考虑成功和失败的适当方法、要添加的检查以及适当的阈值 - 例如，此检查是警告，还是我们测试的严重失败？&lt; /p&gt;&#xA;&lt;p&gt;这里有两个示例，一个用于性能测试，一个用于综合监控，它们支持 k6 浏览器模块并演示如何使用检查 API。&lt;/p&gt;&#xA;&lt;h4 id=&#34;grafana-k6-performance-tests-using-the-browser-module&#34;&gt;使用浏览器模块进行 Grafana k6 性能测试&lt;/h4&gt;&#xA;&lt;p&gt;k6 性能测试是一种定义任意数量的场景、VU 和迭代的通用方法。在下面的例子中，我们有一个演示电子商务网站，我们是我们进行混合测试来记录如果我们推荐的产品 API 意外处于重负载下会发生什么情况。我们的推荐引擎是应用程序的重要组成部分，但它并不像确保客户可以下订单和结账那样对业务至关重要。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;推荐-product-spike.js&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;从“k6/browser”导入 { browser }&#xA;从“k6/http”导入http&#xA;从“https://jslib.k6.io/k6-utils/1.6.0/index.js”导入{检查}&#xA;const Product_IDS = __ENV.Product_IDS&#xA;const HAS_SOME_LEEWAY = `警告`&#xA;const SUPER_IMPORTANT_CHECK = `关键`&#xA;const LESS_IMPORTANT = `信息`&#xA;导出常量选项= {&#xA;场景：{&#xA;用户界面：{&#xA;执行者：“constant-vus”，&#xA;持续时间：“1m”，&#xA;视：3，&#xA;选项： {&#xA;浏览器：{&#xA;类型：“铬”，&#xA;},&#xA;},&#xA;执行：“结帐完成”，&#xA;},&#xA;“spike-api”：{&#xA;执行者：“ramping-vus”，&#xA;起始VU：0，&#xA;阶段：[&#xA;{ 持续时间：“10 秒”，目标：10 }，&#xA;{ 持续时间：“40 秒”，目标：30 }，&#xA;{ 持续时间：“10 秒”，目标：10 }，&#xA;],&#xA;优雅的RampDown：“10秒”，&#xA;执行：“spikeApi”，&#xA;},&#xA;},&#xA;阈值：{&#xA;[`检查{重要性：${SUPER_IMPORTANT_CHECK}}`]：[“rate==1.0”]，&#xA;[`检查{重要性：${HAS_SOME_LEEWAY}}`]：[“比率&gt; = 0.95”]，&#xA;[`检查{重要性：${LESS_IMPORTANT}}`]：[“比率&gt; = 0.9”]，&#xA;},&#xA;}&#xA;导出函数spikeApi() {&#xA;常量随机产品 =&#xA;product_ids[math.floor(math.random() * product_ids.length)]&#xA;const res = http.get(`https://otel-demo.field-eng.grafana.net/api/recommendations?productIds=${randomProduct}`)&#xA;查看（&#xA;资源，&#xA;{&#xA;“状态代码为 200”：(r) =&gt; r.status === 200,&#xA;},&#xA;{ 重要性：HAS_SOME_LEEWAY }&#xA;）&#xA;}&#xA;导出异步函数 checkoutCompletion() {&#xA;const context = 等待 browser.newContext()&#xA;const page = 等待 context.newPage()&#xA;等待 page.goto(`https://otel-demo.field-eng.grafana.net/`)&#xA;wait page.locator(`//*[text()=&#34;去购物&#34;]`).click()&#xA;等待 Promise.all([&#xA;页&#xA;.locator(`//*[text()=&#34;Starsense Explorer 折射望远镜&#34;]`)&#xA;。点击（），&#xA;page.waitForNavigation(),&#xA;]）&#xA;// 不太重要的检查&#xA;等待 checkForRecommendedProducts(页面, `产品页面`)&#xA;等待 Promise.all([&#xA;page.locator(`//*[text()=&#34; 添加到购物车&#34;]`).click(),&#xA;page.waitForNavigation(),&#xA;]）&#xA;// 不太重要的检查&#xA;等待 checkForRecommendedProducts(页面, `发货单`)&#xA;等待 Promise.all([&#xA;page.locator(`//*[text()=&#34;下订单&#34;]`).click(),&#xA;page.waitForNavigation(),&#xA;]）&#xA;// 超级重要的检查&#xA;等待检查（&#xA;页面.定位器(`h1`),&#xA;{&#xA;“下订单r 页面已到达”：async (lo) =&gt;&#xA;(await lo.textContent()) === &#34;您的订单已完成！&#34;,&#xA;},&#xA;{ 重要：SUPER_IMPORTANT_CHECK }&#xA;）&#xA;// 不太重要的检查&#xA;等待 checkForRecommendedProducts(页面, `订单确认`)&#xA;等待页面.close()&#xA;}&#xA;常量 TWO_SECONDS = 2000&#xA;异步函数 checkForRecommendedProducts(page, step) {&#xA;尝试 {&#xA;等待页面&#xA;.定位器(&#xA;`[data-cy=&#34;recommendation-list&#34;] [data-cy=&#34;product-card&#34;]:first-of-type`&#xA;）&#xA;.waitFor({ 超时: TWO_SECONDS })&#xA;} 捕获 (e) {&#xA;等待 page.screenshot({ 路径: `./screenshots/${step}.png` })&#xA;} 最后 {&#xA;const 卡 = 等待页面。$$(`[data-cy=&#34;product-card&#34;]`)&#xA;console.log(步骤, 卡.长度)&#xA;查看（&#xA;卡片长度，&#xA;{&#xA;&#34;显示4个推荐商品&#34;: (length) =&gt; length === 4,&#xA;},&#xA;{&#xA;重要性：LESS_IMPORTANT，&#xA;}&#xA;）&#xA;}&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;在上面的脚本中，有两种场景可以构成混合测试：&lt;code&gt;spike-api&lt;/code&gt;，它使用k6的&lt;a href=&#34;/docs/k6/latest/javascript -api/k6-http/&#34;&gt;&lt;code&gt;http&lt;/code&gt; 协议&lt;/a&gt; 用于模拟流量峰值，以及 &lt;code&gt;user-checkout&lt;/code&gt; 这是模拟结账流程的浏览器测试。共有三项检查，它们标有重要键和不同的值，具体取决于我们要求检查的成功程度。&lt;/p&gt;&#xA;&lt;p&gt;在 &lt;code&gt;options&lt;/code&gt; 对象中，为每个键/值对设置了一个阈值，该阈值将指示测试是通过还是失败。阈值中未使用 &lt;code&gt;abortOnFail&lt;/code&gt; 选项，因为如果测试过早结束，有价值的数据将会丢失。如果开始发生故障，了解 API 的故障程度以及浏览器前端发生的情况将很有用。&lt;/p&gt;&#xA;&lt;h4 id=&#34;synthetic-monitoring-check&#34;&gt;综合监控检查&lt;/h4&gt;&#xA;&lt;p&gt;如果您正在运行综合监控浏览器检查，则它始终是一种场景，具有一个 VU 和一次迭代。综合监控目前不支持选项声明中的 &lt;code&gt;thresholds&lt;/code&gt; 对象（但即将推出！），因此您必须使用显式 &lt;a href=&#34;/docs/k6/latest/javascript- api/k6/fail/&#34;&gt;&lt;code&gt;fail()&lt;/code&gt; 方法&lt;/a&gt; 让探测器知道检查失败。&lt;/p&gt;&#xA;&lt;p&gt;综合监控浏览器检查的行为与 k6 检查不同，因为它们主要根据您对正常运行时间的定义来评估您的测试是否通过或失败。对于非脚本化综合监控检查，您可以在创建检查期间在其自己的步骤中使用一组断言来定义正常运行时间，但由于浏览器检查是作为脚本编写的，因此您需要明确标记要计入定义的内容正常运行时间。&lt;/p&gt;&#xA;&lt;p&gt;如果您采用上面的&lt;strong&gt;recommended-product-spike-test.js&lt;/strong&gt;脚本并提取结账流程场景，则只需进行少量修改即可满足综合监控浏览器检查的需求。通过在检查中添加&lt;code&gt;fail()&lt;/code&gt;方法，确认订单是否c到达确认页面后，综合监控探测器现在将了解什么构成正常运行时间故障并正确报告。&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (&#xA;!(等待检查(page.locator(`h1`), {&#xA;&#34;已到达下订单页面&#34;: async (lo) =&gt; (await lo.textContent()) === &#34;您的订单已完成！&#34;,&#xA;}））&#xA;）{&#xA;失败（`未到达订单完成页面`）&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;我们可以将不太重要的检查留在脚本中，而无需向它们添加显式失败，因为这只是我们从此设置中获得的好处。我们甚至可以使用 &lt;a href=&#34;/products/cloud/alerting/&#34;&gt;Grafana Alerting&lt;/a&gt; 添加自定义警报，以了解推荐的产品是否呈现不一致。&lt;/p&gt;&#xA;&lt;p&gt;综合监控浏览器检查的这种灵活性意味着您只需一次执行即可设置主要和次要断言，从而节省时间和金钱！&lt;/p&gt;&#xA;&lt;h2 id=&#34;bonus-tip-dont-just-account-for-the-happy-path&#34;&gt;额外提示：不要只考虑“快乐”路径&lt;/h2&gt;&#xA;&lt;p&gt;在任何类型的测试中，一个臭名昭著的错误就是假设它们总是会成功。然而，测试的真正价值在于，当不可避免的故障发生时，测试能否很好地告诉我们他们遇到的问题？&lt;/p&gt;&#xA;&lt;p&gt;如果您查看 &lt;strong&gt;recommend-product-spike.js&lt;/strong&gt; 中的结账场景，就会发现调用了多个 &lt;code&gt;page.locator().click()&lt;/code&gt; 函数。如果我们的应用程序出现错误并且这些内容无法正确显示且选择器失败，会发生什么情况？&lt;/p&gt;&#xA;&lt;p&gt;每次迭代都会等待&lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/locator/click/#clickoptions&#34;&gt;默认 30 秒&lt;/a&gt;，然后超时并引发失败。这对于我们的测试来说可能是一个问题，因为它会“阻塞”VU 30 秒，然后结束迭代并重新开始。问题的第一部分是这个测试只运行一分钟，所以如果它提早遇到问题，我们会丢失很多潜在的迭代以及它们将生成的所有附加数据。&lt;/p&gt;&#xA;&lt;p&gt;有两种方法可以解决这个问题：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;为每个 &lt;code&gt;page.locator().click()&lt;/code&gt;（以及类似方法）提供各自适当的超时&lt;/li&gt;&#xA;&lt;li&gt;使用 &lt;a href=&#34;/docs/k6/latest/javascript-api/k6-browser/page/setdefaulttimeout/#setdefaulttimeouttimeout&#34;&gt;&lt;code&gt;page.setDefaultTimeout() 在页面上设置默认超时值&lt;/代码&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;每种方法都有其优点和缺点，由您决定哪种方法有效最适合你。&lt;/p&gt;&#xA;&lt;p&gt;上面的技巧三概述了第二个问题：测试执行被停止，从未遇到过确认订单页面是否已到达的检查，并且测试指标中未报告此故障。解决方案是在我们的 &lt;code&gt;try / finally&lt;/code&gt; 语句中添加一个 catch 块：&lt;/p&gt;&#xA;&lt;div class=&#34;code-snippet&#34;&gt;&lt;div class=&#34;lang-toolbar&#34;&gt;&#xA;&lt;span class=&#34;lang-toolbar__item&#34;&gt;JavaScript&lt;/span&gt;&#xA;&lt;span class=&#34;code-clipboard&#34;&gt;&#xA;&lt;按钮 x-data=&#34;app_code_snippet()&#34; x-init=&#34;init()&#34; @click=&#34;copy()&#34;&gt;&#xA;&lt;img class=&#34;code-clipboard__icon&#34; src=&#34;/media/images/icons/icon-copy-small-2.svg&#34; alt=&#34;将代码复制到剪贴板&#34; width=&#34;14&#34; height=&#34;13&#34;&gt;&#xA;&lt;span&gt;复制&lt;/span&gt;&#xA;&lt;/按钮&gt;&#xA;&lt;/span&gt;&#xA;&lt;div class=&#34;lang-toolbar__border&#34;&gt;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;div class=&#34;code-snippet&#34;&gt;&#xA;&lt;pre data-expanded=&#34;false&#34;&gt;&lt;code class=&#34;language-javascript&#34;&gt;尝试 {&#xA;...&#xA;} 捕获 (e) {&#xA;控制台.错误(e)&#xA;等待页面.screenshot({&#xA;路径：`./screenshots/${__VU}_${__ITER}-failure.png`,&#xA;})&#xA;查看（&#xA;无效的，&#xA;{&#xA;&#34;已到达下订单页面&#34;: false,&#xA;},&#xA;{ 重要：SUPER_IMPORTANT_CHECK }&#xA;）&#xA;} 最后 {&#xA;...&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;&lt;em&gt;注意：最好的做法是截取屏幕截图，以使调试会话更加轻松。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果任何执行导致未处理的异常，综合监控会报告正常运行时间失败，因此，如果您添加此 catch 块，请记住重新抛出错误（如果您更喜欢默认日志记录，则使用您自己的日志记录）或调用 k6 的 &lt;code &gt;fail()&lt;/code&gt; 方法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;summing-up&#34;&gt;总结&lt;/h2&gt;&#xA;&lt;p&gt;k6 浏览器 API 是一款多功能工具，可帮助监控网站的性能和可靠性。通过上述提示，您可以在编写测试时确保紧密的反馈循环，同时保持它们的适应性和无错误。最终，这些最佳实践将使您更轻松地识别潜在的性能问题并优化您的最终用户体验。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;Grafana Cloud 是开始浏览器测试的最简单方法。借助 &lt;a href=&#34;/products/cloud/k6/&#34;&gt;Grafana Cloud k6&lt;/a&gt;，您可以轻松地将前端和后端测试结合到单个基于云的测试中。 &lt;a href=&#34;/products/cloud/synthetic-monitoring/&#34;&gt;Grafana Cloud Synthetic Monitoring&lt;/a&gt; 支持对生产环境中的关键旅程进行持续监控。我们提供慷慨的永久免费套餐和针对每个用例量身定制的计划。立即免费注册 (&lt;a href=&#34;/auth/sign-up/create-user?pg=plugins&amp;plcmt=grafana-synthetic-monitoring-app&amp;redirectPath=synthetic-monitoring&#34;&gt;Grafana Cloud k6&lt;/a&gt; 或 &lt;a href =&#34;/auth/sign-up/create-user?pg=plugins&amp;plcmt=grafana-synthetic-monitoring-app&#34;&gt;Grafana 云综合监控&lt;/a&gt;）！&lt;/em&gt;&lt;/p&gt;</description>
      <pubDate>Thu, 21 Nov 2024 00:00:00 +0000</pubDate>
    </item>
  </channel>
</rss>