<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="/rss/styles.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>豌豆花下猫</title>
        <description>Python编程、生活随笔、个人作品，公众号“Python猫”</description>
        <link>https://pythoncat.top/</link>
        <item>
            <title>Python 潮流周刊#62：试用自由线程 Python</title>
            <link>https://pythoncat.top/posts/2024-07-27-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-07-27-weekly/</guid>
            <description>分享了 12 篇文章，12 个开源项目</description>
            <pubDate>Sat, 27 Jul 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;本周刊由 Python猫 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;分享了 12 篇文章，12 个开源项目，全文 2000 字。&lt;/div&gt;
&lt;div&gt;以下是本期摘要：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🦄文章&amp;amp;教程&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① 在 macOS 上试用自由线程 Python&lt;/div&gt;
&lt;div&gt;② PEP-751：一种列出 Python 依赖项的文件格式，确保可重复安装&lt;/div&gt;
&lt;div&gt;③ 超越后现代：Python 现在更加易用了&lt;/div&gt;
&lt;div&gt;④ 使用 Flask 和 HTMX 实现即时搜索&lt;/div&gt;
&lt;div&gt;⑤ Streamlit 101：Python 数据应用的基础&lt;/div&gt;
&lt;div&gt;⑥ 使用 Python + ToolJet 开发一个 CSV 到图表的生成器应用&lt;/div&gt;
&lt;div&gt;⑦ FastAPI（更快的API）：优化处理时间&lt;/div&gt;
&lt;div&gt;⑧ 用 Django + daisyUI + TailwindCSS 开发一个项目&lt;/div&gt;
&lt;div&gt;⑨ Python 的资源管理和生成器&lt;/div&gt;
&lt;div&gt;⑩ 用 Python 数据帧在笔记本电脑上查询 1TB 数据&lt;/div&gt;
&lt;div&gt;⑪ Python 纪元时间戳的时区陷阱&lt;/div&gt;
&lt;div&gt;⑫ 2024 年 Selenium 的 10 个替代品&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🐿️项目&amp;amp;资源&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① whenever：用 Rust 开发的 Python 日期时间库&lt;/div&gt;
&lt;div&gt;② maelstrom：高速的 Rust 和 Python 测试运行器&lt;/div&gt;
&lt;div&gt;③ wat：对 Python 对象作深层检测&lt;/div&gt;
&lt;div&gt;④ txtai：用于语义搜索、LLM 编排和大模型工作流的嵌入数据库&lt;/div&gt;
&lt;div&gt;⑤ PraisonAI：将 AutoGen 和 CrewAI 等框架集成低代码解决方案&lt;/div&gt;
&lt;div&gt;⑥ pgmanage：用于管理数据库的 Web 工具&lt;/div&gt;
&lt;div&gt;⑦ pygamelib：在控制台里开发游戏的小框架&lt;/div&gt;
&lt;div&gt;⑧ composio：面向 AI 代理的生产就绪型工具集&lt;/div&gt;
&lt;div&gt;⑨ Cradle：通用型计算机控制框架&lt;/div&gt;
&lt;div&gt;⑩ lonboard：用 Jupyter 做地理空间矢量数据可视化&lt;/div&gt;
&lt;div&gt;⑪ opencanary：模块化和去中心化的蜜罐&lt;/div&gt;
&lt;div&gt;⑫ amphi-etl：低代码 ETL 数据集成&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;目前周刊实行付费订阅制，年费 128 元，平均每天不到 4 毛钱，但绝对是一笔有眼光的投资。花钱学习知识，花钱提升自己，欢迎订阅这个：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;你绝对不会后悔的专栏&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;订阅后，可免费查看 &lt;a href=&quot;https://xiaobot.net/post/eddb20d5-5a74-4f44-abe7-c0f58ce28647&quot;&gt;第 62 期周刊的全文&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PS.本周刊&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;前30期的合集&lt;/a&gt;永久免费，已集结出了精美电子书（EPUB/PDF），请从该合集文章开头获取下载链接。&lt;/div&gt;
&lt;div&gt;另外，付费期数将在其 50 期后免费开放，例如第 62 期将在第 112 期时免费，敬请留意。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#61：PyPI 管理员密钥泄露事件</title>
            <link>https://pythoncat.top/posts/2024-07-20-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-07-20-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目，2 则音视频，2 则热门话题</description>
            <pubDate>Sat, 20 Jul 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;本周刊由 Python猫 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;本期周刊分享了 12 篇文章，12 个开源项目，2 则音视频，2 则热门话题，全文 2400 字。&lt;/div&gt;
&lt;div&gt;以下是本期摘要：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🦄文章&amp;amp;教程&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① 二进制密钥扫描帮我们防止了（可能是）你能想象到的最严重的供应链攻击&lt;/div&gt;
&lt;div&gt;② 事件报告：泄露的 GitHub 个人访问密钥&lt;/div&gt;
&lt;div&gt;③ 【网络安全】「漏洞复现」（六）探索 Python 中原型链的利用与污染&lt;/div&gt;
&lt;div&gt;④ 自由线程 CPython 已准备好用作实验！&lt;/div&gt;
&lt;div&gt;⑤ Python 性能分析的几个方法，找到你代码中的那个她&lt;/div&gt;
&lt;div&gt;⑥ 用 Python 和 Flask 中开发简单的 Pastebin 服务&lt;/div&gt;
&lt;div&gt;⑦ Debug 日志：CPython GH-121528&lt;/div&gt;
&lt;div&gt;⑧ 分享一件有趣的事情，我帮 CPython 修复了一个 bug&lt;/div&gt;
&lt;div&gt;⑨ 装饰器如何使我的 Flask 代码崩溃：经验教训&lt;/div&gt;
&lt;div&gt;⑩ 2024 年，良好的 Python 项目结构是怎样的？&lt;/div&gt;
&lt;div&gt;⑪ 如何用 PyTorch 从零开发和训练自己的 GPT-2？&lt;/div&gt;
&lt;div&gt;⑫ 万字浓缩版，Python 潮流周刊第 1 季的 800 个链接！&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🐿️项目&amp;amp;资源&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① exo：在家庭日常设备中运行自建的 AI 集群&lt;/div&gt;
&lt;div&gt;② kaskade：Kafka 的 TUI 应用，在终端中管理和消费 topic&lt;/div&gt;
&lt;div&gt;③ G-Scraper：完全用 Python 开发的 GUI 网络爬虫&lt;/div&gt;
&lt;div&gt;④ source2RSS：将信息源转 RSS 的 Python 框架&lt;/div&gt;
&lt;div&gt;⑤ mandala：简单而优雅的代码追踪框架&lt;/div&gt;
&lt;div&gt;⑥ jurigged：Python 的热重载&lt;/div&gt;
&lt;div&gt;⑦ wenet：端到端语音识别工具包&lt;/div&gt;
&lt;div&gt;⑧ mem0：人性化 AI 的内存层&lt;/div&gt;
&lt;div&gt;⑨ MinerU：一站式数据提取工具，支持 PDF/网页/多格式电子书&lt;/div&gt;
&lt;div&gt;⑩ promptdoc：管理多版本、场景和模型的提示词模板&lt;/div&gt;
&lt;div&gt;⑪ disposable-email-domains：一次性的电子邮件域名列表&lt;/div&gt;
&lt;div&gt;⑫ fastembed：轻量级的 Python 库，实现最先进的嵌入&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🐢播客&amp;amp;视频&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① SE Radio 624：与 Marcelo Trylesinski 谈 FastAPI&lt;/div&gt;
&lt;div&gt;② The Python Show Python 42：Harlequin 终端里的 SQL IDE&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🥂讨论&amp;amp;问题&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① 我是 Python 后端开发，如何创建一个现代且高性能的前端？&lt;/div&gt;
&lt;div&gt;② 2024 年 Python 实现定时任务和延时任务，性价比较高的方案是什么？&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;目前周刊实行付费订阅制，年费 128 元，平均每天不到 4 毛钱，但绝对是一笔有眼光的投资。花钱学习知识，花钱提升自己，欢迎订阅这个：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;你绝对不会后悔的专栏&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;订阅后，可免费查看 &lt;a href=&quot;https://xiaobot.net/post/4431a2ef-828e-4e17-9035-f3c195ce90bc&quot;&gt;第 61 期周刊的全文&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PS.本周刊&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;前30期的合集&lt;/a&gt;永久免费，已集结出了精美电子书（EPUB/PDF），请从该合集文章开头获取下载链接。&lt;/div&gt;
&lt;div&gt;另外，付费期数将在其 50 期后免费开放，例如第 61 期将在第 111 期时免费，敬请留意。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>万字浓缩版，Python 潮流周刊第 1 季的 800 个链接！</title>
            <link>https://pythoncat.top/posts/2024-07-17-iweekly/</link>
            <guid>https://pythoncat.top/posts/2024-07-17-iweekly/</guid>
            <description>只取周刊中的内容标题，我将 800 个链接都整理出来啦，一篇看个够！</description>
            <pubDate>Wed, 17 Jul 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是豌豆花下猫。前几天，我重新整理了 &lt;strong&gt;Python 潮流周刊&lt;/strong&gt;的往期分享，推出了第 1 季的图文版电子书，受到了很多读者的一致好评。&lt;/div&gt;
&lt;div&gt;但是，合集和电子书的篇幅很长，阅读起来要花不少时间。所以，为了方便大家阅读，我打算将合集进一步整理，分门别类将原始内容的标题罗列出来。&lt;/div&gt;
&lt;div&gt;本文总计约 800 个链接，有 5 大分类，你可以快速浏览文章、项目、播客、视频和话题讨论的标题，快速找到自己感兴趣的内容进行查看。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Python 周刊的精美电子书 EPUB、PDF 及 Markdown 版本，请在公zh号“&lt;strong&gt;Python猫&lt;/strong&gt;”里发送“&lt;strong&gt;W30&lt;/strong&gt;”，获取免费下载链接&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;精选国内外的优质文章，主要来自于个人博客、技术平台、企业网站等。&lt;/div&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pythoncat.top/posts/2023-05-08-error&quot;&gt;编程语言的错误处理模式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/Chang-LeHung/dive-into-cpython/blob/master/obsy/03decriptor.md&quot;&gt;深入理解 Python 虚拟机：描述器实现原理与源码分析&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://v3u.cn/a_id_310&quot;&gt;人工智能 AI 孙燕姿模型应用实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://juejin.cn/post/7229485914219642941&quot;&gt;用 C 语言写一个 Python 包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.cnblogs.com/shanxihualu/p/17391082.html&quot;&gt;Python 工具箱系列文章&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://peps.python.org/pep-0713&quot;&gt;PEP-713：可调用的模块&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://pythonspeed.com/articles/externally-managed-environment-pep-668&quot;&gt;“Externally managed environments”：当 PEP-668 影响了 pip&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://blog.zech.codes/bevy-v2&quot;&gt;Bevy v2.0：Python 的依赖注入框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;http://coolshell.cn/articles/11265.html&quot;&gt;Python修饰器的函数式编程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://www.cnblogs.com/traditional/p/17403428.html&quot;&gt;asyncio 的一些高级用法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://segmentfault.com/a/1190000043790186&quot;&gt;Nginx+uWSGI 部署 Django 以及负载均衡操作&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;http://vra.github.io/2023/05/17/rye-intro/&quot;&gt;Rye:一个实验性质的Python包管理系统&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://juejin.cn/post/7232571353123487802&quot;&gt;PyInstaller：将你的Python代码打包成独立应用程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://martinheinz.dev/blog/97&quot;&gt;如何在 Python 中实现真正的多线程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;https://www.backblaze.com/blog/python-gil-vs-nogil-boost-i-o-performance-10x-with-one-line-change/&quot;&gt;GIL vs. nogil: 改动一行代码，提升十倍 I/O 性能&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;16、&lt;a href=&quot;https://blog.jetbrains.com/pycharm/2023/05/create-passphrase-generator-in-pycharm/&quot;&gt;如何在 PyCharm 中创建一个密码生成器？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;17、&lt;a href=&quot;https://coderslegacy.com/python-metaclass-tutorial/&quot;&gt;Python 元类教程（带示例）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;18、&lt;a href=&quot;https://www.warp.dev/blog/what-happens-when-you-open-a-terminal-and-enter-ls&quot;&gt;当在终端输入“ls”后会发生什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;19、&lt;a href=&quot;https://segmentfault.com/a/1190000043822529&quot;&gt;掌握Python面向对象编程的关键：类与对象&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;20、&lt;a href=&quot;https://juejin.cn/post/7232977661207085117&quot;&gt;umongo + motor: 构建高效 MongoDB 应用的最佳组合&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;21、&lt;a href=&quot;https://juejin.cn/post/7234821431804002365&quot;&gt;徒手使用 LangChain 搭建一个 ChatGPT PDF 知识库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;22、&lt;a href=&quot;https://laike9m.com/blog/python-zhen-de-shi-kao-yi-ge-switch-lai-zhi-xing-zi-jie-ma-de-ma,138&quot;&gt;Python 真的是靠一个 switch 来执行字节码的吗？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;23、&lt;a href=&quot;https://www.bmpi.dev/dev/renaissance-sqlite&quot;&gt;SQLite 的文艺复兴&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;24、&lt;a href=&quot;https://soulteary.com/2023/04/05/eighty-lines-of-code-to-implement-the-open-source-midjourney-and-stable-diffusion-spell-drawing-tool.html#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2&quot;&gt;八十行代码实现开源的 Midjourney、Stable Diffusion “咒语”作图工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;25、&lt;a href=&quot;https://kobzol.github.io/rust/python/2023/05/20/writing-python-like-its-rust.html&quot;&gt;像写 Rust 一样写 Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;26、&lt;a href=&quot;https://www.patricksoftwareblog.com/flask_tips.html&quot;&gt;一系列的 Flask 小贴士&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;27、&lt;a href=&quot;https://steve.dignam.xyz/2023/05/20/many-problems-with-celery/&quot;&gt;Celery 的诸多问题&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;28、&lt;a href=&quot;https://last9.io/blog/using-golang-package-in-python-using-gopy/&quot;&gt;Python 借助 Gopy 库实现调用 Go 包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;29、&lt;a href=&quot;https://pythonspeed.com/articles/best-file-format-for-pandas/&quot;&gt;最适用于 Pandas 的文件格式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;30、关于 PyPI 的一系列新闻/文章（&lt;a href=&quot;https://pythoncat.top/posts/2023-05-27-weekly3&quot;&gt;共7篇&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;31、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-three.html&quot;&gt;Three Talks on the C API&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;32、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-making.html&quot;&gt;Making the Global Interpreter Lock Optional&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;33、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-towards.html&quot;&gt;Towards Native Profiling for Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;34、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-what-is.html&quot;&gt;What is the stdlib for?&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;35、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-pattern.html&quot;&gt;Pattern Matching, __match__, and View Patterns&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;36、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-python.html&quot;&gt;Python on Mobile: State of the Union&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;37、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-burnout.html&quot;&gt;Burnout is Real&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;38、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023.html&quot;&gt;Lightning Talks&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;39、&lt;a href=&quot;https://pkolaczk.github.io/memory-consumption-of-async/&quot;&gt;并发一百万个任务要用多少内存？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;40、&lt;a href=&quot;https://towardsdatascience.com/use-these-methods-to-make-your-python-concurrent-tasks-perform-better-b693b7a633e1&quot;&gt;使用这些方法让你的 Python 并发任务执行得更好&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;41、原推荐文章为拼凑且非原创，已删&lt;/div&gt;
&lt;div&gt;42、&lt;a href=&quot;https://programmingeeksclub.com/ultimate-python-multithreading-guide&quot;&gt;Python 多线程编程的终极指南&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;43、&lt;a href=&quot;https://www.bmpi.dev/dev/deep-in-program-language/how-to-implement-concurrency/concurrency-model/&quot;&gt;编程语言是如何实现并发的之并发模型篇&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;44、&lt;a href=&quot;https://segmentfault.com/a/1190000043833549&quot;&gt;鹅厂程序员的 9 个生存法则&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;45、&lt;a href=&quot;https://juejin.cn/post/7238274120881422392&quot;&gt;一览 Python 3.12！PEP 701 —— f-string 语法规范化&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;46、&lt;a href=&quot;https://blog.jetbrains.com/pycharm/2023/05/five-things-to-love-about-the-new-ui/&quot;&gt;PyCharm：新用户界面的五大亮点&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;47、&lt;a href=&quot;https://discuss.python.org/t/pep-594-has-been-implemented-python-3-13-removes-20-stdlib-modules/27124&quot;&gt;PEP-594 已被实现：Python 3.13 将移除 20 个标准库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;48、&lt;a href=&quot;https://innovation.alteryx.com/introducing-grasshopper-an-open-source-python-library-for-load-testing/&quot;&gt;Grasshopper：一个用于负载测试的开源 Python 库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;49、&lt;a href=&quot;https://hackthedeveloper.com/python-decorator/&quot;&gt;Python 装饰器：用包装巫术增强你的代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;50、三个 Python 练手项目的实战教程：&lt;a href=&quot;https://swiftuser.hashnode.dev/how-to-telegram-bot-with-python&quot;&gt;用 Python 开发 Telegram 机器人&lt;/a&gt;、&lt;a href=&quot;https://implement-dns.wizardzines.com/index.html&quot;&gt;花一周末用 Python 实现 DNS&lt;/a&gt;、&lt;a href=&quot;https://www.leshenko.net/p/ugit/&quot;&gt;用 Python 构建你自己的 Git&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;51、&lt;a href=&quot;https://zhuanlan.zhihu.com/p/634654153&quot;&gt;CPython 贡献日记：Python 3.12 有什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;52、&lt;a href=&quot;https://topbook.cc/overview?selectedArticle=1975&quot;&gt;有哪些值得关注的 AI 工具？我们整理了这 67 个&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;53、&lt;a href=&quot;https://juejin.cn/post/7240248679515963451&quot;&gt;我买了本豆瓣 9.6 分的 Python 书，发现里面每 5 页一个错误？！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;54、&lt;a href=&quot;https://borretti.me/article/sketch-post-orm&quot;&gt;Sketch of a Post-ORM&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;55、&lt;a href=&quot;https://martinheinz.dev/blog/98&quot;&gt;Python 中运行 Shell 命令的正确做法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;56、&lt;a href=&quot;https://www.vidavolta.io/how-to-upgrade-your-flask-application-using-async/&quot;&gt;如何使用 async 升级 Flask 程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;57、&lt;a href=&quot;https://snarky.ca/proposing-a-struct-syntax/&quot;&gt;提议给 Python 添加一个结构语法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;58、&lt;a href=&quot;https://juejin.cn/post/7240380161555234876&quot;&gt;类属性和实例属性是怎样的关系？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;59、&lt;a href=&quot;https://dev.to/lambdatest/39-top-python-frameworks-to-look-for-in-2023-3hdb&quot;&gt;2023 年 39 个顶级 Python 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;60、内容删除&lt;/div&gt;
&lt;div&gt;61、&lt;a href=&quot;https://www.pythonguis.com/tutorials/getting-started-kivy/&quot;&gt;使用 Kivy 库进行 GUI 开发&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;62、&lt;a href=&quot;https://pythonspeed.com/articles/speeding-up-numba/&quot;&gt;了解 CPU 有助于提升 Numba 和 NumPy 代码的速度&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;63、&lt;a href=&quot;https://www.reversinglabs.com/blog/when-python-bytecode-bites-back-who-checks-the-contents-of-compiled-python-files&quot;&gt;当字节码咬人时：谁检查 Python 文件编译后的内容？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;64、&lt;a href=&quot;http://arthurchiao.art/blog/gpt-as-a-finite-state-markov-chain-zh/&quot;&gt;GPT 是如何工作的：200 行 Python 代码实现一个极简 GPT&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;65、&lt;a href=&quot;http://arthurchiao.art/blog/transformers-from-scratch-zh/&quot;&gt;600 行 Python 代码实现两个 Transformer（文本分类+文本生成）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;66、&lt;a href=&quot;https://charlesleifer.com/blog/asyncio&quot;&gt;AsyncIO&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;67、&lt;a href=&quot;https://eng.lyft.com/what-the-heck-is-gevent-4e87db98a8&quot;&gt;gevent 到底是什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;68、&lt;a href=&quot;https://www.kdnuggets.com/2023/06/getting-started-reactpy.html&quot;&gt;ReactPy 的入门教程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;69、&lt;a href=&quot;https://qin.news/python-circular-dependency-and-global-contexts&quot;&gt;Python 业务框架循环依赖和全局上下文的一些思考&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;70、&lt;a href=&quot;https://amakelov.github.io/blog/deps&quot;&gt;Python 函数调用的实际依赖关系跟踪&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;71、&lt;a href=&quot;https://juejin.cn/post/7244033665209073725&quot;&gt;Python 3.x从基础到实战 - typing类型提示&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;72、&lt;a href=&quot;https://www.pythonpapers.com/p/an-intro-to-wxpython&quot;&gt;wxPython 入门教程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;73、&lt;a href=&quot;https://juejin.cn/post/7241943960083546171&quot;&gt;Python 装饰器的用法指导&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;74、&lt;a href=&quot;https://superfastpython.com/numpy-share-array-processes&quot;&gt;在进程间共享 Numpy 数组的 7 种方式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;75、&lt;a href=&quot;https://www.timescale.com/blog/tools-for-working-with-time-series-analysis-in-python&quot;&gt;在 Python 中作时间序列分析的工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;76、&lt;a href=&quot;https://neuronize.dev/learn-handling-missing-data-in-10-minutes&quot;&gt;如何快速处理缺失的数据&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;77、&lt;a href=&quot;https://coderslegacy.com/cython-vs-cpython-comparing-speed&quot;&gt;Cython 与 CPython：对比性能差异&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;78、&lt;a href=&quot;https://www.vidavolta.io/streaming-with-fastapi&quot;&gt;使用 FastAPI 进行流式处理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;79、&lt;a href=&quot;https://techwasti.com/fastapi-interview-questions-on-middleware&quot;&gt;20 道关于 FastAPI 中间件的面试题&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;80、&lt;a href=&quot;https://github.com/python/cpython/issues/101632&quot;&gt;CPython 添加返回常量指令&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;81、&lt;a href=&quot;https://github.com/faster-cpython/ideas/blob/main/3.13/README.md&quot;&gt;Python 3.13 版本的计划&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;82、&lt;a href=&quot;https://superfastpython.com/why-numpy-parallelism/&quot;&gt;为什么 Numpy 并行性很重要？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;83、&lt;a href=&quot;https://ohadravid.github.io/posts/2023-03-rusty-python/&quot;&gt;用少于 100 行的 Rust 使 Python 变快 100 倍&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;84、&lt;a href=&quot;https://www.jelmer.uk/port-py-to-rust.html&quot;&gt;将 Python 项目移植到 Rust&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;85、&lt;a href=&quot;https://benhoyt.com/writings/python-api-design/&quot;&gt;设计 Pythonic 的库 API&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;86、&lt;a href=&quot;https://bernsteinbear.com/blog/typed-python/&quot;&gt;编译类型化的 Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;87、&lt;a href=&quot;https://www.revsys.com/tidbits/pytest-fixtures-are-magic/&quot;&gt;pytest 的夹具很神奇！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;88、&lt;a href=&quot;https://just-taking-a-ride.com/inside_python_dict/chapter1.html&quot;&gt;探析 Python 字典的实现原理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;89、&lt;a href=&quot;https://djangocentral.com/flask-vs-django-selecting-the-perfect-python-web-framework/&quot;&gt;Flask vs Django：选择完美的 Python Web 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;90、&lt;a href=&quot;https://www.bitecode.dev/p/why-not-tell-people-to-simply-use&quot;&gt;为什么不告诉人们“简单地”使用 pyenv、poetry、anaconda&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;91、&lt;a href=&quot;https://jeff.glass/post/pyscript-asyncio/&quot;&gt;PyScript 中的 Asyncio&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;92、&lt;a href=&quot;https://glyph.twistedmatrix.com/2014/02/unyielding.html&quot;&gt;线程的问题及其解决方案&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;93、&lt;a href=&quot;https://ai.plainenglish.io/%EF%B8%8F-langchain-streamlit-llama-bringing-conversational-ai-to-your-local-machine-a1736252b172&quot;&gt;本地部署开源大模型的完整教程：LangChain + Streamlit+ Llama&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;94、&lt;a href=&quot;http://so1n.me/2023/05/29/python_asyncio_lib_overhead/&quot;&gt;Python Asyncio 协程对象开销成本&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;95、&lt;a href=&quot;https://superfastpython.com/asyncio-runner/&quot;&gt;如何使用 asyncio.Runner 执行多个协程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;96、&lt;a href=&quot;https://hakibenita.com/django-concurrency&quot;&gt;不使用锁的并发实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;97、&lt;a href=&quot;https://zhuanlan.zhihu.com/p/639119164&quot;&gt;贡献 CPython 日记 (3) CPython 是如何运行的&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;98、&lt;a href=&quot;https://coderslegacy.com/python-jit-compilers/&quot;&gt;Python JIT 编译器 - 即时编译&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;99、&lt;a href=&quot;https://www.bitecode.dev/p/whats-the-deal-with-cpython-pypy&quot;&gt;CPython、Pypy、MicroPython、Jython……都是些什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;100、&lt;a href=&quot;https://coderslegacy.com/python-apscheduler-asyncioscheduler/&quot;&gt;Python APScheduler：感受 AsyncIOScheduler 的强大&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;101、&lt;a href=&quot;https://sourcery.ai/blog/chatgpt-maintainable-code/&quot;&gt;在生成代码时避免产生技术债务&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;102、&lt;a href=&quot;https://pythonspeed.com/articles/numpy-is-slow/&quot;&gt;当 NumPy 太慢时&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;103、&lt;a href=&quot;https://coderslegacy.com/python-numba-tutorial/&quot;&gt;Numba 教程：使用 JIT 编译加速 Python 代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;104、&lt;a href=&quot;https://blog.fidelramos.net/software/python-code-quality&quot;&gt;自动化提升 Python 代码质量&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;105、&lt;a href=&quot;https://cognibits.hashnode.dev/enhancing-data-analysis-with-pandasai&quot;&gt;使用 PandasAI 增强数据分析&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;106、&lt;a href=&quot;https://www.codium.ai/blog/best-practices-for-writing-unit-tests/&quot;&gt; 写单元测试的最佳实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;107、&lt;a href=&quot;https://netflixtechblog.com/migrating-netflix-to-graphql-safely-8e1e4d4f1e72&quot;&gt;Netflix 如何安全地迁移到 GraphQL&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;108、&lt;a href=&quot;https://www.yance.wiki/gc_go_py&quot;&gt;聊一聊 Python 和 Golang 的垃圾回收&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;109、&lt;a href=&quot;https://albexl.substack.com/p/a-tale-of-debugging-the-competitive&quot;&gt;像竞赛程序员一样调试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;110、&lt;a href=&quot;https://realpython.com/python312-perf-profiler/&quot;&gt;Python 3.12 预览版：支持 Linux 性能分析器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;111、&lt;a href=&quot;https://lukasz.langa.pl/40b601fc-2b24-4629-91d9-3b32c58365c6/&quot;&gt;CPython 招聘一名全职工程师&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;112、&lt;a href=&quot;https://lukasz.langa.pl/61df599c-d9d8-4938-868b-36b67fdb4448/&quot;&gt;PEP 563 和 PEP 649&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;113、&lt;a href=&quot;https://ritwikmath.hashnode.dev/python-design-patterns-cookbook-recipes-for-clean-and-reusable-code-observer&quot;&gt;Python 设计模式：简洁及可重用代码（观察者）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;114、&lt;a href=&quot;https://jamesturk.net/posts/you-dont-need-all/&quot;&gt;你并不需要写__all__&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;115、&lt;a href=&quot;https://blog.miguelgrinberg.com/post/building-a-toy-programming-language-in-python&quot;&gt;用 Python 实现一门简易的编程语言&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;116、&lt;a href=&quot;https://www.pythonmorsels.com/using-counter/&quot;&gt;使用 Python 的 collections.Counter 计算出现次数&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;117、&lt;a href=&quot;https://coderslegacy.com/python-code-with-numba-vectorize/&quot;&gt;使用 Numba Vectorize 加速 Python 代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;118、&lt;a href=&quot;https://emmmme.com/greatwork&quot;&gt;Paul Graham：如何做出伟大的工作？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;119、&lt;a href=&quot;https://emmmme.com/workhard&quot;&gt;Paul Graham：如何努力工作？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;120、&lt;a href=&quot;https://www.pythonmorsels.com/django-june-2023/&quot;&gt;Django 2023 年 6 月：技巧和讨论&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;121、&lt;a href=&quot;https://soulteary.com/2023/05/21/run-python-code-with-golang-and-docker.html&quot;&gt;使用 Golang 和 Docker 运行 Python 代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;122、&lt;a href=&quot;https://www.piglei.com/articles/the-answer-is-in-the-code-fulfill-requirements/&quot;&gt;答案在代码中：“实现需求”的双重含义&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;123、&lt;a href=&quot;https://www.bitecode.dev/p/relieving-your-python-packaging-pain&quot;&gt;减轻 Python 包管理的痛苦&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;124、&lt;a href=&quot;https://www.cnblogs.com/traditional/p/17536459.html&quot;&gt;CuPy：将 NumPy 数组调度到 GPU 上运行&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;125、&lt;a href=&quot;https://segmentfault.com/a/1190000044006618&quot;&gt;Python 源码剖析：深度探索 Cpython 对象&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;126、&lt;a href=&quot;https://juejin.cn/post/7252976055093592120&quot;&gt;使用 Flask + Flask RESTful 快速搭建 API 服务&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;127、&lt;a href=&quot;https://segmentfault.com/a/1190000043988232&quot;&gt;详解 Django 请求与响应：深入理解 Web Http 交互的核心机制&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;128、&lt;a href=&quot;https://dev.to/derlin/when-plans-go-astray-my-unsuccessful-journey-of-migrating-a-large-django-project-to-mypy-3l23&quot;&gt;将大型 Django 项目迁移到 Mypy 的失败之旅&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;129、&lt;a href=&quot;https://www.python-engineer.com/posts/notion-api-python/&quot;&gt;如何在 Python 中使用 Notion API？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;130、&lt;a href=&quot;https://pythonspeed.com/articles/easiest-rust-python/&quot;&gt;最简单的使用 Rust 加速 Python 的方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;131、&lt;a href=&quot;https://jayconrod.com/posts/101/how-python-parses-white-space&quot;&gt;Python 是如何解析空格的？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;132、&lt;a href=&quot;https://pythonguides.com/remove-duplicate-values-from-a-python-dictionary/&quot;&gt;如何从 Python 字典中删除重复的值？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;133、&lt;a href=&quot;https://realpython.com/python-profiling/&quot;&gt;如何找出 Python 代码中的性能瓶颈？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;134、&lt;a href=&quot;https://samuel-vidovich.medium.com/3-cool-python-libraries-that-will-save-you-time-and-effort-27fcdc6762d5&quot;&gt;3 个很酷的 Python 库，节省你的时间和精力&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;135、&lt;a href=&quot;https://blog.europython.eu/kraken-technologies-how-we-organize-our-very-large-pythonmonolith/&quot;&gt;如何管理有近 3 万个文件的超大型 Python 代码仓？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;136、&lt;a href=&quot;https://martinheinz.dev/blog/101&quot;&gt;使用 PyStack 调试 Python 中的崩溃和死锁&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;137、&lt;a href=&quot;https://bitestreams.com/blog/fastapi_template/&quot;&gt;介绍一个 FastAPI 项目模板&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;138、&lt;a href=&quot;https://davidvujic.blogspot.com/2023/07/python-fastapi-microservices-with-polylith.html&quot;&gt;Python FastAPI 微服务与 Polylith 架构&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;139、&lt;a href=&quot;https://juejin.cn/post/7257321872425058359&quot;&gt;Python日志模块：实战应用与最佳实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;140、&lt;a href=&quot;https://codesolid.com/benchmarking-python-and-rust-async-web-server-performance/&quot;&gt;测量 Python 和 Rust 异步 Web 服务的性能&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;141、&lt;a href=&quot;http://vra.github.io/2023/07/14/dinov2-retrieval/&quot;&gt;dinov2_retrieval：一个基于 DINOv2 的图片检索应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;142、&lt;a href=&quot;https://til.simonwillison.net/python/stdlib-cli-tools&quot;&gt;隐藏在 Python 标准库中的 CLI 工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;143、&lt;a href=&quot;https://www.abdulmumin.com/how-to-use-tailwindcss-in-any-python-project&quot;&gt;如何在 Python 项目中使用 TailwindCSS ？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;144、&lt;a href=&quot;https://dev.to/karishmashukla/a-practical-guide-to-metaprogramming-in-python-691&quot;&gt;Python 元编程实用指南&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;145、&lt;a href=&quot;https://blog.stealthrocket.tech/how-cpython-prints-stack-traces/&quot;&gt;CPython 是如何打印堆栈信息的？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;146、&lt;a href=&quot;https://switowski.com/blog/pathlib/&quot;&gt;用于路径操作的 Pathlib&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;147、&lt;a href=&quot;https://newsletter.techworld-with-milan.com/p/stack-overflow-architecture&quot;&gt;Stack Overflow、Shopify 及 Levels.fyi 的软件架构&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;148、&lt;a href=&quot;https://dev.to/alexomeyer/10-must-know-patterns-for-writing-clean-code-with-python-56bf&quot;&gt;10 条编写干净 Python 代码的建议&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;149、&lt;a href=&quot;https://engineering.fb.com/2023/06/27/developer-tools/meta-developer-tools-open-source/&quot;&gt;Meta 开发者工具：支撑大规模协作的编程体系&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;150、&lt;a href=&quot;https://blog.jupyter.org/announcing-jupyter-notebook-7-8d6d66126dcf&quot;&gt;Jupyter Notebook 7 隆重发布&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;151、&lt;a href=&quot;https://juejin.cn/post/7258881840823615544&quot;&gt;Python 中的弱引用与基础类型支持情况探究&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;152、&lt;a href=&quot;http://so1n.me/2023/07/23/distributed_lock_lntroduction_and_lmplementation/&quot;&gt;分布式锁的介绍与 Python 实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;153、&lt;a href=&quot;https://scofield.hashnode.dev/unlocking-the-power-of-pyscript-a-guide-to-running-python-code-in-your-html&quot;&gt;释放 PyScript 的力量：在 HTML 中运行 Python 代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;154、&lt;a href=&quot;https://superfastpython.com/faster-file-io-with-concurrency/&quot;&gt;通过并发实现更快的文件 I/O&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;155、&lt;a href=&quot;https://dev.to/atkumar/how-to-write-impeccably-clean-code-that-will-save-your-sanity-4np9&quot;&gt;如何编写完美干净的 Python 代码？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;156、&lt;a href=&quot;https://betterstack.com/community/guides/logging/best-python-logging-libraries/&quot;&gt;Python 日志记录：对比最流行的 6 个库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;157、&lt;a href=&quot;https://adamj.eu/tech/2023/07/23/python-profile-section-cprofile/&quot;&gt;使用 cProfile 分析模块级代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;158、&lt;a href=&quot;https://www.codium.ai/blog/mastering-functional-programming-in-python/&quot;&gt;掌握 Python 函数式编程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;159、&lt;a href=&quot;https://realpython.com/python312-f-strings/&quot;&gt;Python 3.12 预览版：更直观和一致的 f-string&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;160、&lt;a href=&quot;https://dev.to/akarshan/asynchronous-python-magic-how-to-create-awaitable-constructors-with-asyncmixin-18j5&quot;&gt;使用 AsyncMixin 创建可等待的构造函数&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;161、&lt;a href=&quot;https://snyk.io/blog/insecure-direct-object-references-python/&quot;&gt;在 Python 中查找并修复不安全的直接对象引用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;162、&lt;a href=&quot;https://medium.com/@DorIndivo/overcoming-performance-bottlenecks-with-async-python-a-deep-dive-into-cpu-bound-code-b604a400255a&quot;&gt;使用异步 Python 克服性能瓶颈：深入研究 CPU 密集型代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;163、&lt;a href=&quot;https://peps.python.org/pep-0720/&quot;&gt;PEP-720 交叉编译 Python 包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;164、&lt;a href=&quot;https://pep-previews--3210.org.readthedocs.build/pep-0722/&quot;&gt;PEP-722 单文件脚本的依赖关系规范&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;165、&lt;a href=&quot;https://lpython.org/blog/2023/07/lpython-novel-fast-retargetable-python-compiler/&quot;&gt;LPython：新颖、高性能、适用于多平台的 Python 编译器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;166、&lt;a href=&quot;https://cython.readthedocs.io/en/latest/src/changes.html&quot;&gt;Cython 3.0.0 的文档&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;167、&lt;a href=&quot;https://www.marsja.se/coefficient-of-variation-in-python-with-pandas-numpy/&quot;&gt;Python 中使用 Pandas 和 NumPy 计算变异系数&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;168、&lt;a href=&quot;https://blog.jupyter.org/generative-ai-in-jupyter-3f7174824862&quot;&gt;Jupyter 中的生成式 AI&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;169、&lt;a href=&quot;https://www.tartley.com/posts/structured-pattern-matching-in-python/&quot;&gt;Python 中的结构化模式匹配&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;170、&lt;a href=&quot;https://textual.textualize.io/blog/2023/07/27/using-rich-inspect-to-interrogate-python-objects/&quot;&gt;使用 Rich 的 Inspect 查看 Python 对象属性&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;171、&lt;a href=&quot;https://sethmlarson.dev/pep-440&quot;&gt;Python 包版本控制的怪癖&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;172、&lt;a href=&quot;https://superfastpython.com/file-io-concurrent-patterns/&quot;&gt;文件 I/O 并发编程的模式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;173、&lt;a href=&quot;https://mostlypython.substack.com/p/reading-code?nthPub=581&quot;&gt;如何高效地阅读 Python 代码？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;174、&lt;a href=&quot;https://www.askpython.com/python/examples/call-java-using-python&quot;&gt;如何在 Python 中用 JPype 与 Pyjnius 调用 Java 代码？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;175、&lt;a href=&quot;https://dev.to/willp/call-javascript-code-in-python-551a&quot;&gt;如何在 Python 中调用 JavaScript 代码？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;176、&lt;a href=&quot;https://chaoticengineer.hashnode.dev/textual-and-chatgpt&quot;&gt;使用 Textual 构建 ChatGPT TUI 应用程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;177、&lt;a href=&quot;https://code.dblock.org/2023/06/16/getting-started-with-vector-dbs-in-python.html&quot;&gt;Python 中的向量数据库入门&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;178、&lt;a href=&quot;https://dev.to/cwprogram/a-tour-of-cpython-compilation-cd5&quot;&gt;CPython 的编译过程是怎样的？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;179、&lt;a href=&quot;https://dev.to/mintzworld/the-new-pdbp-pdb-python-debugger-2blc&quot;&gt;介绍新开源的 Python 调试器 pdbp (Pdb+)！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;180、&lt;a href=&quot;https://blog.balthazar-rouberol.com/how-to-profile-a-fastapi-asynchronous-request&quot;&gt;如何分析 FastAPI 异步请求的性能？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;181、&lt;a href=&quot;https://noplacelikelocalhost.medium.com/leveraging-background-tasks-in-fastapi-enhancing-performance-and-responsiveness-6e4ad64c7d16&quot;&gt;利用 FastAPI 的后台任务：增强性能和响应能力&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;182、&lt;a href=&quot;https://compucademy.net/creating-histograms-with-python/&quot;&gt;使用 Python 创建直方图&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;183、&lt;a href=&quot;https://mypy-lang.blogspot.com/2023/08/mypy-15-released.html&quot;&gt;Mypy 1.5 发布了&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;184、&lt;a href=&quot;https://jvns.ca/blog/2023/08/03/behind--hello-world/&quot;&gt;在 Linux 上运行 Python 的“Hello World”脚本时，会发生什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;185、&lt;a href=&quot;https://kenschutte.com/postscript-vs-python&quot;&gt;通过对比 Python 来学习 PostScript&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;186、&lt;a href=&quot;https://www.nathom.dev/blog/casual_performance_optimization_python/&quot;&gt;Python 中不那么随意的性能优化&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;187、&lt;a href=&quot;https://www.pythonmorsels.com/creating-a-context-manager/&quot;&gt;在 Python 中创建上下文管理器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;188、&lt;a href=&quot;https://kenschutte.com/python-swap-ints&quot;&gt;一个简单的模块，可以篡改 Python 解释器的数字&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;189、&lt;a href=&quot;https://josvisser.substack.com/p/why-python-is-terrible&quot;&gt;为什么说 Python 很糟糕……&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;190、&lt;a href=&quot;https://pybit.es/articles/python-errors-should-not-pass-silently/&quot;&gt;Python 中错误处理的最佳实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;191、&lt;a href=&quot;https://www.pythongasm.com/build-gpt-powered-chatbots-around-enterprise-data-with-python&quot;&gt;使用企业数据和 Python 构建 GPT 对话机器人&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;192、&lt;a href=&quot;https://www.bitecode.dev/p/python-cocktail-mix-a-context-manager&quot;&gt;Python 鸡尾酒：将上下文管理器和迭代器等量混合&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;193、&lt;a href=&quot;https://stackabuse.com/the-power-of-indexing-boosting-data-wrangling-efficiency-with-pandas/&quot;&gt;索引的力量：利用 Pandas 提高数据整理效率&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;194、&lt;a href=&quot;https://www.tinybird.co/blog-posts/killing-the-processpoolexecutor&quot;&gt;杀死 ProcessPoolExecutor&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;195、&lt;a href=&quot;https://mathspp.com/blog/pydonts/does-elegance-matter&quot;&gt;写代码时，优雅有意义吗？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;196、&lt;a href=&quot;https://so1n.me/2023/08/14/python_asyncio_concunrrency_result_share/&quot;&gt;Python Asyncio实践—高并发下如何防止缓存击穿&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;197、&lt;a href=&quot;https://juejin.cn/post/7266663176980185144&quot;&gt;高效定时任务处理：深入学习 Python 中 APScheduler 库的奥秘&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;198、&lt;a href=&quot;https://juejin.cn/post/7266037480750071848&quot;&gt;CPython 开发实战：魔改 lambda 函数&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;199、&lt;a href=&quot;https://codeconfessions.substack.com/p/cpython-reference-counting-internals&quot;&gt;CPython 是如何实现引用计数的？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;200、&lt;a href=&quot;https://coderslegacy.com/python-lazy-loading-with-importlib/&quot;&gt;使用 Importlib 实现 Python 延迟加载&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;201、&lt;a href=&quot;https://sixfeetup.com/blog/end-to-end-testing-python-playwright&quot;&gt;使用 Python 和 Playwright 进行端到端测试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;202、&lt;a href=&quot;https://lwn.net/Articles/939981/&quot;&gt;nogil 项目和 Faster CPython 项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;203、&lt;a href=&quot;https://engineering.fb.com/2023/08/15/developer-tools/immortal-objects-for-python-instagram-meta/&quot;&gt;简单介绍 Python 的永生对象&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;204、&lt;a href=&quot;https://pybit.es/articles/why-you-should-avoid-import-in-python/&quot;&gt;为什么要避免在 Python 中用“import *”？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;205、&lt;a href=&quot;https://prefix.dev/blog/launching_pixi&quot;&gt;让我们终结 Python 的依赖地狱&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;206、&lt;a href=&quot;https://pythonguides.com/jwt-authentication-using-django-rest-framework/&quot;&gt;使用 Django Rest Framework 实现 JWT 身份验证&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;207、&lt;a href=&quot;https://johnnymetz.com/posts/slow-django-database-queries/&quot;&gt;增强 Django 程序：提升数据库查询的 7 个妙招&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;208、&lt;a href=&quot;https://martinheinz.dev/blog/103&quot;&gt;可能让你大吃一惊的奇怪的 Python “特性”&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;209、&lt;a href=&quot;https://blog.quastor.org/p/khan-academy-rewrote-backend&quot;&gt;可汗学院如何将 Python 后端重写成 Go？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;210、&lt;a href=&quot;https://hirrolot.github.io/posts/why-static-languages-suffer-from-complexity.html#the-unfortunate-consequences-of-being-static&quot;&gt;为什么静态语言会面临复杂性的挑战？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;211、&lt;a href=&quot;https://techcommunity.microsoft.com/t5/microsoft-365-blog/introducing-python-in-excel-the-best-of-both-worlds-for-data/ba-p/3905482&quot;&gt;Excel 终于支持 Python 了！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;212、&lt;a href=&quot;https://juejin.cn/post/7269969188391600128&quot;&gt;如何使用 FastAPI 与 aiohttp 进行 SSE 响应开发？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;213、&lt;a href=&quot;https://blog.dagworks.io/p/containerized-pdf-summarizer-with&quot;&gt;用 FastAPI 和 Hamilton 实现的 PDF 摘要工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;214、&lt;a href=&quot;https://juejin.cn/post/7270363281117102099&quot;&gt;放弃 Python 拥抱 Mojo？鹅厂工程师真实使用感受&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;215、&lt;a href=&quot;https://www.modular.com/blog/how-mojo-gets-a-35-000x-speedup-over-python-part-1&quot;&gt;Mojo 如何获得比 Python 快 35000 倍的加速？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;216、&lt;a href=&quot;https://mathspp.com/blog/what-learning-apl-taught-me-about-python&quot;&gt;APL 语言教会我的那些 Python 知识&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;217、&lt;a href=&quot;https://www.romaglushko.com/blog/jupyter-kernel-architecture/&quot;&gt;深度解析 Jupyter 的内核架构&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;218、&lt;a href=&quot;https://engineering.fb.com/2023/08/07/developer-tools/fixit-2-linter-meta/&quot;&gt;Fixit 2：Meta 的下一代自动修复 linter&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;219、&lt;a href=&quot;https://realpython.com/python-code-image-generator/&quot;&gt;使用 Python 构建代码图像生成器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;220、&lt;a href=&quot;https://coderslegacy.com/apipkg-tutorial-enhanced-lazy-loading-in-python/&quot;&gt;apipkg 教程：Python 中的增强延迟加载&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;221、&lt;a href=&quot;https://www.bitecode.dev/p/asyncio-twisted-tornado-gevent-walk&quot;&gt;当 asyncio、twisted、tornado 和 gevent 一起走进酒吧…&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;222、&lt;a href=&quot;https://snarky.ca/state-of-standardized-lock-files-for-python-august-2023/&quot;&gt;Python 标准化锁定文件的现状&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;223、&lt;a href=&quot;https://joaodlf.com/python-just-write-sql&quot;&gt;Python：只需编写 SQL&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;224、&lt;a href=&quot;https://stackabuse.com/incompatible-type-comparisons-in-python/&quot;&gt;Python 中如何比较不兼容的类型？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;225、&lt;a href=&quot;https://florian-dahlitz.de/articles/create-your-own-diff-tool-using-python&quot;&gt;使用 Python 开发一个文件比较工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;226、&lt;a href=&quot;https://eli.thegreenplace.net/2023/my-favorite-prime-number-generator/&quot;&gt;我最喜欢的素数生成函数&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;227、&lt;a href=&quot;https://testdriven.io/guides/flask-deep-dive&quot;&gt;一份深入探索 Flask 的指南&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;228、&lt;a href=&quot;https://artifex.com/blog/table-recognition-extraction-from-pdfs-pymupdf-python&quot;&gt;使用 PyMuPDF 识别与提取表格&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;229、&lt;a href=&quot;https://codeconfessions.substack.com/p/understanding-immortal-objects-in&quot;&gt;深入介绍 Python 3.12 中的永生对象&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;230、&lt;a href=&quot;https://mathspp.com/blog/pydonts/usages-of-underscore&quot;&gt;Python 中下划线的十种用法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;231、&lt;a href=&quot;https://so1n.me/2023/08/29/python_asyncio_lib_network/&quot;&gt;Python Asyncio 之网络编程方法详解&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;232、&lt;a href=&quot;https://dev.to/codemaker2015/streamlit-cheatsheet-for-beginners-706&quot;&gt;给初学者的 Streamlit 学习指南&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;233、&lt;a href=&quot;https://ezzeddin.hashnode.dev/fastapi-tailwind-sqlalchemy&quot;&gt;如何在 FastAPI 应用中使用 Tailwind CSS 和 SQLAlchemy&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;234、&lt;a href=&quot;https://www.bitecode.dev/p/how-not-to-sort-in-python&quot;&gt;Python 如何不作排序但保持数据有序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;235、&lt;a href=&quot;https://delighto.hashnode.dev/send-verification-email-django&quot;&gt;用 Django 发送带有验证链接的电子邮件&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;236、&lt;a href=&quot;https://medium.com/@i18nsolutionspy/exploring-global-diversity-pyetho-python-library-for-language-and-country-insights-4a688958ea83&quot;&gt;探索全球多样性：Pyetho — 用于了解国家及其语言的 Python 库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;237、&lt;a href=&quot;https://realpython.com/polars-python/&quot;&gt;Polars：快如闪电的 DataFrame 库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;238、&lt;a href=&quot;https://dev.to/khaledhosseini/data-structures-and-algorithms-for-multi-language-programmers-c-swift-python-java-c-javascript-alp&quot;&gt;深入学习数据结构与算法：C++、Swift、Python、Java、C#、JavaScript&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;239、&lt;a href=&quot;https://www.modular.com/blog/mojo-its-finally-here&quot;&gt;Mojo🔥 终于提供下载了！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;240、&lt;a href=&quot;https://www.cnblogs.com/apocelipes/p/17679741.html&quot;&gt;我们能从 PEP-703 中学到什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;241、&lt;a href=&quot;https://vgel.me/posts/c500/&quot;&gt;用 500 行 Python 代码写一个 C 语言编译器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;242、&lt;a href=&quot;https://www.blog.pythonlibrary.org/2023/08/30/an-intro-to-protocol-buffers-with-python&quot;&gt;简单介绍如何用 Python 作协议缓冲区编程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;243、&lt;a href=&quot;https://dev.to/oscarleo/how-to-create-a-beautiful-polar-histogram-with-python-and-matplotlib-400l&quot;&gt;用 Python 和 matplotlib 创建漂亮的极坐标直方图&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;244、&lt;a href=&quot;https://codeconfessions.substack.com/p/bloom-filters-and-beyond&quot;&gt;布隆过滤器图解与 Python 实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;245、&lt;a href=&quot;https://favtutor.com/blogs/heap-in-python&quot;&gt;Python 中的堆数据结构：最小和最大堆实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;246、&lt;a href=&quot;https://developers.redhat.com/articles/2023/09/05/beginners-guide-python-containers&quot;&gt;Python 容器化部署教程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;247、&lt;a href=&quot;https://robamu.github.io/posts/packaging-python-in-2023/&quot;&gt;2023 年 Python 包管理的实践指南&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;248、&lt;a href=&quot;https://juejin.cn/post/7274626136328536116&quot;&gt;记一次 Python 应用内存泄漏问题定位&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;249、&lt;a href=&quot;https://adamj.eu/tech/2023/09/07/introducing-flake8-logging/&quot;&gt;介绍 flake8-logging&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;250、&lt;a href=&quot;https://segmentfault.com/a/1190000044189692&quot;&gt;Falcon 180B 正式在 Hugging Face Hub 上发布&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;251、&lt;a href=&quot;https://superfastpython.com/benchmark-python-code/&quot;&gt;三种对 Python 作基准测试的方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;252、&lt;a href=&quot;https://andrich.me/2023/08/switching-to-hatch/&quot;&gt;舍弃 Poetry 和 PDM，切换成 Hatch&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;253、&lt;a href=&quot;https://hitchdev.com/strictyaml/why-not/toml/&quot;&gt;TOML 文件格式有什么问题？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;254、&lt;a href=&quot;https://joseprupi.github.io/misc/2023/08/19/playing_with_genetic_algorithms_in_python.html&quot;&gt;用 Python 玩转遗传算法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;255、&lt;a href=&quot;https://codebeez.nl/blogs/type-hinting-in-modern-python-the-protocol-class/&quot;&gt;现代 Python 的类型提示：Protocal 类&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;256、&lt;a href=&quot;https://dev.to/caipi/tornado-de-xie-cheng-diao-du-yuan-li-2h34&quot;&gt;tornado 的协程调度原理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;257、&lt;a href=&quot;https://sethmlarson.dev/security-developer-in-residence-weekly-report-9&quot;&gt;可视化 CPython 发布过程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;258、&lt;a href=&quot;https://yasoob.me/posts/how-to-use-vision-framework-via-pyobjc/&quot;&gt;如何用 PyObjC 与 Apple Vision 框架作文本识别&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;259、&lt;a href=&quot;https://krishnanchandra.com/posts/regex-catastrophic-backtracking/&quot;&gt;调试 Python 中正则表达式的灾难性回溯&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;260、&lt;a href=&quot;https://www.photondesigner.com/articles/database-search-django-htmx&quot;&gt;使用 Django 和 HTMX 开发一个数据库搜索项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;261、&lt;a href=&quot;https://python-bloggers.com/2023/09/asynchronous-sqlalchemy-and-multiple-databases/&quot;&gt;异步 SqlAlchemy 和多数据库管理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;262、&lt;a href=&quot;https://juejin.cn/post/7278246015193464847&quot;&gt;Python Fire：自动生成命令行接口&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;263、&lt;a href=&quot;https://www.jjinux.com/2022/08/python-my-favorite-python-tricks-for.html&quot;&gt;我最爱的解 LeetCode 问题的 Python 技巧&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;264、&lt;a href=&quot;https://stackabuse.com/why-does-python-code-run-faster-in-a-function/&quot;&gt;为什么 Python 代码在函数中运行得更快？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;265、&lt;a href=&quot;https://pythonspeed.com/articles/optimizing-dithering/&quot;&gt;在单核情况下加快 Python 代码速度&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;266、&lt;a href=&quot;https://www.blog.pythonlibrary.org/2023/09/20/learning-about-code-metrics-in-python-with-radon/&quot;&gt;使用 Radon 作 Python 的代码度量&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;267、&lt;a href=&quot;https://lwn.net/Articles/942767/&quot;&gt;Python（大部分）由语法糖组成&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;268、&lt;a href=&quot;https://oscarbenjamin.github.io/blog/czi/post1.html&quot;&gt;迎接新的 SymPy&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;269、&lt;a href=&quot;https://www.piglei.com/articles/use-import-linter-to-lint-proj-arch/&quot;&gt;使用 import-linter 让你的 Python 项目架构更整洁&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;270、&lt;a href=&quot;https://codeconfessions.substack.com/p/cpython-bloom-filter-usage&quot;&gt;CPython 如何用布隆过滤器作字符串处理？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;271、&lt;a href=&quot;https://medium.com/@m____b____/uuids-with-python-b133cead1b4c&quot;&gt;Python 中 UUID 的使用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;272、&lt;a href=&quot;https://ponder.io/why-are-there-so-many-python-dataframes/&quot;&gt;为什么有这么多 Python Dataframe？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;273、&lt;a href=&quot;https://www.dataschool.io/python-probability-simulation/&quot;&gt;使用 Python 模拟“三门问题”&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;274、&lt;a href=&quot;https://pybit.es/articles/6-cool-things-you-can-do-with-the-functools-module/&quot;&gt;6 件可以用 Functools 模块做的很酷的事&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;275、&lt;a href=&quot;https://juejin.cn/post/7281491804736831542&quot;&gt;深入理解 pytest.main()：Python 测试框架的核心功能解析&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;276、&lt;a href=&quot;https://python.plainenglish.io/7-best-python-authentication-libraries-you-should-use-in-your-next-project-c07b668d5348&quot;&gt;7 个极佳的 Python 身份验证库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;277、&lt;a href=&quot;https://www.python.org/downloads/release/python-3120/&quot;&gt;Python 3.12.0 版本发布了&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;278、&lt;a href=&quot;https://realpython.com/python312-subinterpreters/&quot;&gt;Python 3.12 速览：子解释器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;279、&lt;a href=&quot;https://www.manjusaka.blog/posts/2023/10/05/the-perf-feature-python-312/&quot;&gt;聊聊 Python 3.12 中 perf 的原生支持&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;280、&lt;a href=&quot;https://realpython.com/python312-typing/&quot;&gt;Python 3.12 速览：静态类型的改进&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;281、&lt;a href=&quot;https://juejin.cn/post/7283461184514572349&quot;&gt;FastAPI 中的依赖注入：构建可维护的高性能 Web 应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;282、&lt;a href=&quot;https://juejin.cn/post/7286670786563244090&quot;&gt;深入理解 python 虚拟机：原来虚拟机是这么实现闭包的&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;283、&lt;a href=&quot;https://juejin.cn/post/7287418444647677986&quot;&gt;探索 Pexpect 库：深入理解 expect_list 方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;284、&lt;a href=&quot;https://textual.textualize.io/blog/2023/10/04/announcing-textual-plotext/&quot;&gt;介绍 textual-plotext，在终端里绘图&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;285、&lt;a href=&quot;https://bbc.github.io/cloudfit-public-docs/&quot;&gt;Python Asyncio 系列文章 5 篇&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;286、&lt;a href=&quot;https://www.polarsignals.com/blog/posts/2023/10/04/profiling-python-and-ruby-with-ebpf&quot;&gt;使用 eBPF 分析 Python 和 Ruby&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;287、&lt;a href=&quot;https://www.bitecode.dev/p/python-312-what-didnt-make-the-headlines&quot;&gt;Python 3.12: 不那么热门的改动&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;288、&lt;a href=&quot;https://sethmlarson.dev/security-developer-in-residence-weekly-report-13&quot;&gt;从供应链安全角度看 Python 3.12.0&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;289、&lt;a href=&quot;https://dev.to/praise002/20-exciting-python-project-ideas-3la9&quot;&gt;20 个令人兴奋的 Python 项目创意&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;290、&lt;a href=&quot;https://en.lewoniewski.info/2023/python-3-11-vs-python-3-12-performance-testing/&quot;&gt;Python 3.11 vs Python 3.12 之性能测试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;291、&lt;a href=&quot;https://blog.adarshd.dev/posts/when-i-met-guido-van-rossum/&quot;&gt;当我遇见了 Guido van Rossum&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;292、&lt;a href=&quot;https://death.andgravity.com/stdlib&quot;&gt;通过阅读代码学习：Python 标准库设计决策解释&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;293、&lt;a href=&quot;https://testdriven.io/blog/accepting-payments-with-stripe-vuejs-and-flask/&quot;&gt;使用 Stripe、Vue.js 和 Flask 开发收款功能&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;294、&lt;a href=&quot;https://blog.frankel.ch/rust-from-python/&quot;&gt;使用 Python 调用 Rust 的三种方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;295、&lt;a href=&quot;https://semaphoreci.com/blog/custom-middleware-fastapi&quot;&gt;如何开发 FastAPI 的中间件？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;296、&lt;a href=&quot;https://www.honeybadger.io/blog/options-for-passwordless-authentication-in-django/&quot;&gt;Django 项目实现无密码身份验证&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;297、&lt;a href=&quot;https://thetechbuffet.substack.com/p/improve-python-development-workflow&quot;&gt;在发布 Python 项目前，建议用上这 4 个工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;298、&lt;a href=&quot;https://blog.miguelgrinberg.com/post/we-have-to-talk-about-flask&quot;&gt;我们必须聊聊 Flask&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;299、&lt;a href=&quot;https://juejin.cn/post/7288998044020326415&quot;&gt;基于 ProPainter 技术去除图片以及视频水印&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;300、&lt;a href=&quot;https://thenewstack.io/python-comes-to-google-sheets/&quot;&gt;Google Sheets 也能用 Python 了&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;301、&lt;a href=&quot;https://lwn.net/Articles/947138/&quot;&gt;PEP-703 无 GIL CPython 的进展&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;302、&lt;a href=&quot;https://peps.python.org/pep-0730/&quot;&gt;PEP-730 CPython 提供对 iOS 的官方支持&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;303、&lt;a href=&quot;https://www.pythoncentral.io/the-next-step-in-django-development-advanced-features-to-consider/&quot;&gt;Django 进阶：开发高级的功能&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;304、&lt;a href=&quot;https://testdriven.io/blog/developing-an-asynchronous-task-queue-in-python/&quot;&gt;在 Python 中开发异步的任务队列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;305、&lt;a href=&quot;https://pgjones.dev/blog/flask-ecosystem-compatibility-2023/&quot;&gt;Flask、它的生态和向后兼容性&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;306、&lt;a href=&quot;https://blog.miguelgrinberg.com/post/some-more-to-talk-about-flask&quot;&gt;继续关于 Flask 的讨论&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;307、&lt;a href=&quot;https://prefix.dev/blog/introducing_rip&quot;&gt;介绍 rip - 快速而简约的 pip 实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;308、&lt;a href=&quot;https://willcrichton.net/notes/k-corrset/&quot;&gt;使用 Rust 将数据分析速度提高 180,000 倍&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;309、&lt;a href=&quot;https://www.pythonmorsels.com/lambda-expressions/&quot;&gt;什么是 lambda 表达式？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;310、&lt;a href=&quot;https://juejin.cn/post/7293420609088798731&quot;&gt;手撸个视频翻译和配音工具玩玩 结果不太妙&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;311、&lt;a href=&quot;https://alex-jacobs.com/posts/fastapitests/&quot;&gt;掌握使用 FastAPI 进行集成测试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;312、&lt;a href=&quot;https://www.biaodianfu.com/latexify-python.html&quot;&gt;Python 代码转为 LATEX 公式工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;313、&lt;a href=&quot;https://astral.sh/blog/the-ruff-formatter&quot;&gt;Ruff：一款极其快、兼容 Black 的 Python 格式化工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;314、&lt;a href=&quot;https://pythonspeed.com/articles/upgrade-python-3.12/&quot;&gt;你应该什么时候升级到 Python 3.12？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;315、&lt;a href=&quot;https://www.manjusaka.blog/posts/2023/10/29/the-most-important-thing-in-python-3-12/&quot;&gt;Python 3.12：一个被人忽略的史诗级版本&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;316、&lt;a href=&quot;https://quanttype.net/posts/2023-10-31-do-not-use-requirements.txt.html&quot;&gt;不要再用 requirements.txt 了&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;317、&lt;a href=&quot;https://www.coderedcorp.com/blog/why-is-the-django-admin-ugly/&quot;&gt;为什么 Django 后台管理系统那么“丑陋”？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;318、&lt;a href=&quot;https://gregoryszorc.com/blog/2023/10/30/my-user-experience-porting-off-setup.py/&quot;&gt;我迁移弃用 setup.py 的糟糕体验&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;319、&lt;a href=&quot;https://realpython.com/ptpython-shell/&quot;&gt;使用 Ptpython 提高你的编码效率&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;320、&lt;a href=&quot;https://blog.robertroskam.com/p/100-test-coverage-is-not-enough&quot;&gt;100%的测试覆盖率是不够的：Python 中基于属性的测试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;321、&lt;a href=&quot;https://www.cnblogs.com/hanabi-cnblogs/p/17792740.html&quot;&gt;从零开始编写一个 Python 异步 ASGI Web 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;322、&lt;a href=&quot;https://www.cnblogs.com/frankming/p/17762591.html&quot;&gt;Python 如何在日志中隐藏明文密码？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;323、&lt;a href=&quot;https://monadical.com/posts/from-chaos-to-cohesion.html&quot;&gt;从混沌到凝聚：构建你自己的 Monorepo&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;324、&lt;a href=&quot;https://eddieantonio.ca/blog/2023/10/25/python-is-a-compiled-language/&quot;&gt;Python 是一种编译型语言&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;325、&lt;a href=&quot;https://kennethreitz.org/essays/why-im-not-collaborating-with-kenneth-reitz&quot;&gt;Kenneth Reitz：迟来的道歉，以及 requests 3 的进展&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;326、&lt;a href=&quot;https://coderslegacy.com/python-grequests-making-asynchronous-http-requests/&quot;&gt;grequests：异步的 HTTP 请求&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;327、&lt;a href=&quot;https://mathspp.com/blog/tag:bpci&quot;&gt;开发一个 Python 编译器和解释器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;328、&lt;a href=&quot;https://levelup.gitconnected.com/build-an-ai-tool-to-summarize-books-instantly-828680c1ceb4&quot;&gt;使用 Python+ChatGPT 开发一个书籍摘要 AI&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;329、&lt;a href=&quot;https://www.paulox.net/2023/11/07/database-generated-columns-part-1-django-and-sqlite/&quot;&gt;数据库生成的列 ：Django &amp;amp; SQLite&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;330、&lt;a href=&quot;https://martinheinz.dev/blog/106&quot;&gt;你能用 Python 的 bisect 模块做到这些事&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;331、&lt;a href=&quot;https://labs.quansight.org/blog/building-scipy-with-flang&quot;&gt;为什么说在 Windows 上为 Python 3.12 构建的 SciPy 是一个小奇迹？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;332、&lt;a href=&quot;https://serpapi.com/blog/web-scraping-and-parsing-experiment-with-ai-openai/&quot;&gt;使用 AI 进行网页抓取实验（使用 GPT-4 解析 HTML）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;333、&lt;a href=&quot;https://blog.jetbrains.com/pycharm/2023/11/django-vs-flask-which-is-the-best-python-web-framework/&quot;&gt;Django vs Flask：哪个是最好的 Python Web 框架？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;334、&lt;a href=&quot;https://marvelousmlops.substack.com/p/the-right-way-to-install-python-on&quot;&gt;在 Mac 上安装 Python 的正确方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;335、&lt;a href=&quot;https://www.techbeamers.com/simple-android-data-analytics-app-in-python/&quot;&gt;用 Python 开发简单的 Android 数据分析应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;336、&lt;a href=&quot;https://labs.quansight.org/blog/numpy-python-api-cleanup&quot;&gt;改进 Numpy 的 Python API，为 2.0 版本准备&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;337、&lt;a href=&quot;https://www.inngest.com/blog/python-errors-as-values&quot;&gt;将 Python 错误作为值：比较 Go 和 Rust 的使用模式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;338、&lt;a href=&quot;https://www.better-simple.com/django/2023/11/04/debugging-csrf-error-in-production/&quot;&gt;调试 Django 中的 CSRF 失败/403 禁止错误&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;339、&lt;a href=&quot;https://alpopkes.com/posts/python/packaging_tools/&quot;&gt;对 Python 环境和包管理工具的公正分析&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;340、&lt;a href=&quot;https://mostlynerdless.de/blog/2023/09/20/lets-create-a-python-debugger-together-part-1/&quot;&gt;让我们一起创建一个 Python 调试器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;341、&lt;a href=&quot;https://blog.jetbrains.com/pycharm/2023/11/python-3-12/&quot;&gt;揭开 Python 3.12 的面纱：Python 世界有哪些新东西？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;342、&lt;a href=&quot;https://stackabuse.com/hash-tables-in-python/&quot;&gt;Python 的哈希表指南&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;343、&lt;a href=&quot;https://healeycodes.com/running-untrusted-python-code&quot;&gt;运行不可信的 Python 代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;344、&lt;a href=&quot;https://muhammadraza.me/2023/linux-cp/&quot;&gt;了解 Linux cp 命令并用 Python 编程实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;345、&lt;a href=&quot;https://www.bitecode.dev/p/beginners-should-use-django-not-flask&quot;&gt;初学者应该用 Django，而不是 Flask&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;346、&lt;a href=&quot;https://peps.python.org/pep-0733/&quot;&gt;PEP-733：对 Python 公共 C API 的评估&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;347、&lt;a href=&quot;https://arunmani.in/articles/silly-json-parser/&quot;&gt;让我们做一个类 JSON 语法的解析器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;348、&lt;a href=&quot;https://tratt.net/laurie/blog/2023/how_big_should_a_programming_language_be.html&quot;&gt;一门编程语言应该有多大？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;349、&lt;a href=&quot;https://tratt.net/laurie/blog/2023/four_kinds_of_optimisation.html&quot;&gt;四种优化程序的方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;350、&lt;a href=&quot;https://pythonspeed.com/articles/two-thread-pools/&quot;&gt;两种线程池，以及为什么需要这两种线程池？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;351、&lt;a href=&quot;https://blog.miguelgrinberg.com/post/it-s-time-for-a-change-datetime-utcnow-is-now-deprecated&quot;&gt;是时候改变了：datetime.utcnow() 现已被弃用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;352、&lt;a href=&quot;https://www.biaodianfu.com/python-web-server-deployment.html&quot;&gt;Python Web 应用的线上部署&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;353、&lt;a href=&quot;https://stefan-marr.de/2023/11/python-global-interpreter-lock/&quot;&gt;Python GIL 作出的不断变化的“保证”&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;354、&lt;a href=&quot;https://learndjango.com/tutorials/django-dependency-management-pip-compile-and-pip-t&quot;&gt;使用 pip-compile 和 pip-tools 作 Django 的依赖项管理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;355、&lt;a href=&quot;https://threeofwands.com/the-types-of-errors-in-python-apps/&quot;&gt;Python 程序的 bug 分类&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;356、&lt;a href=&quot;https://blog.orsinium.dev/posts/py/core-devs-typing/&quot;&gt;有多少 Python 核心开发者使用类型提示？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;357、&lt;a href=&quot;https://juejin.cn/post/7304706387645071395&quot;&gt;记一次用 Python 的 ast 模块将 Flask 项目转为 Quart 的尝试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;358、&lt;a href=&quot;https://solothought.com/tutorial/python-numpy/&quot;&gt;Python NumPy 库的可视化解释&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;359、&lt;a href=&quot;https://coady.github.io/posts/composition-vs-inheritance.html&quot;&gt;用组合还是继承？我有不同看法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;360、&lt;a href=&quot;https://python-bloggers.com/2023/10/choosing-the-right-data-dashboard-tool-the-unique-strengths-of-streamlit-and-shiny/&quot;&gt;选择正确的数据仪表板工具：Streamlit 和 Shiny 的独特优势&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;361、&lt;a href=&quot;https://mp.weixin.qq.com/s/m-IBomxu88DlNcEyOgyOew&quot;&gt;Rust std fs 比 Python 慢！真的吗！？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;362、&lt;a href=&quot;https://www.dataroc.ca/blog/most-performant-timestamp-functions-python&quot;&gt;Python 中性能最快的时间戳函数是哪个？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;363、&lt;a href=&quot;https://preslav.me/2023/11/27/python-is-easy-golang-is-simple-simple-is-not-easy/&quot;&gt;Python 是 Easy，Go 是 Simple，但 Simple != Easy&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;364、&lt;a href=&quot;https://labs.quansight.org/blog/unlocking-c-level-performance-in-df-apply&quot;&gt;使用 Numba 提升 pandas.DataFrame.apply 的 C 级别性能&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;365、&lt;a href=&quot;https://davidism.com/maintainer-notes/&quot;&gt;一份杂乱的 Flask 维护任务清单&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;366、&lt;a href=&quot;https://tonybaloney.github.io/posts/sub-interpreter-web-workers.html&quot;&gt;用子解释器运行 Python 并行程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;367、&lt;a href=&quot;https://dev.to/taipy/new-open-source-vs-old-open-source-33k7&quot;&gt;新的开源库 VS. 旧的开源库 &lt;/a&gt;&lt;/div&gt;
&lt;div&gt;368、&lt;a href=&quot;https://pythonspeed.com/articles/polars-pandas-interopability/&quot;&gt;在 Pandas 的世界中使用 Polars&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;369、&lt;a href=&quot;https://mathspp.com/blog/til/pythons-soft-keywords&quot;&gt;Python 的软关键字有哪些？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;370、&lt;a href=&quot;https://blog.untrod.com/2023/11/robot-dad.html&quot;&gt;用 Python 实现机器人爸爸&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;371、&lt;a href=&quot;https://github.com/stickfigure/blog/wiki/How-to-(and-how-not-to)-design-REST-APIs&quot;&gt;如何（以及如何不）设计 REST API&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;372、&lt;a href=&quot;https://superfastpython.com/debug-asyncio/&quot;&gt;如何调试 Asyncio 程序？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;373、&lt;a href=&quot;https://pythonafrica.blogspot.com/2023/12/an-open-letter-to-python-software_5.html&quot;&gt;Python 非洲：致 Python 软件基金会的一封公开信&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;374、&lt;a href=&quot;https://docs.djangoproject.com/en/5.0/releases/5.0&quot;&gt;Django 5.0 发布了！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;375、&lt;a href=&quot;https://www.skywind.me/blog/archives/2761&quot;&gt;56 行代码用 Python 实现一个 Flex/Lex&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;376、&lt;a href=&quot;https://so1n.me/2023/12/07/how-to-use-dependency-injection-in-fastapi/&quot;&gt;如何在 FastAPI 正确地使用依赖注入？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;377、&lt;a href=&quot;https://www.kdnuggets.com/why-you-should-not-overuse-list-comprehensions-in-python&quot;&gt;为什么不应该在 Python 中过度使用列表解析式？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;378、&lt;a href=&quot;https://lucumr.pocoo.org/2023/12/1/the-python-that-was/&quot;&gt;非类型化的 Python：曾经的 Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;379、&lt;a href=&quot;https://idiomaticprogrammers.com/post/django-watson-full-text-search-guide&quot;&gt;用 django-watson 给 Django 项目添加全文搜索&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;380、&lt;a href=&quot;https://www.better-simple.com/django/2023/12/06/fanout-pattern-explained/&quot;&gt;解析 Celery 的扇出模式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;381、&lt;a href=&quot;https://superfastpython.com/asyncio-alternatives/&quot;&gt;Python Asyncio 的 7 个替代库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;382、&lt;a href=&quot;https://codeconfessions.substack.com/p/cpython-dynamic-dispatch-internals&quot;&gt;解密 CPython：当执行 a+b 时，背后发生了什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;383、&lt;a href=&quot;https://www.blog.pythonlibrary.org/2023/12/05/viewing-an-animated-gif-with-python/&quot;&gt;如何使用 Python 播放 GIF？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;384、&lt;a href=&quot;https://bernsteinbear.com//blog/simple-python-repl/&quot;&gt;用 Python 开发一个微型的 REPL&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;主要是 Github 上的开源项目、开源电子书、有趣的网站项目等。&lt;/div&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/zixiiu/Digital_Life_Server&quot;&gt;「数字生命」的服务端&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/RVC-Project/Retrieval-based-Voice-Conversion-WebUI&quot;&gt;一个基于VITS的简单易用的语音转换（变声器）框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/bookfere/Ebook-Translator-Calibre-Plugin&quot;&gt;电子书翻译器（Calibre 插件）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/pikasTech/PikaPython/blob/master/README_zh.md&quot;&gt;跨平台的超轻量级嵌入式 Python 引擎&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/marticliment/WingetUI&quot;&gt;WingetUI：更好用的包管理器 UI&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/gventuri/pandas-ai&quot;&gt;pandas-ai：支持 AI 功能的 Pandas&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/Undertone0809/promptulate&quot;&gt;promptulate：一个强大的 LLM Prompt Layer 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/micropython/micropython/releases/tag/v1.20.0&quot;&gt;MicroPython：面向微控制器和嵌入式系统的 Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/csunny/DB-GPT&quot;&gt;DB-GPT：以数据库为基础的 GPT 实验项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/Syan-Lin/CyberWaifu&quot;&gt;CyberWaifu：使用 LLM 和 TTS 实现的聊天机器人&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/c121914yu/FastGPT&quot;&gt;FastGPT：基于 openai 搭建的知识库平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/pyrustic/jesth&quot;&gt;jesth：更具可读性的数据序列化格式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://github.com/Textualize/trogon&quot;&gt;trogon：为 CLI 程序生成友好的用户界面&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://github.com/ipyflow/ipyflow&quot;&gt;ipyflow：用于 Jupyter 笔记本的响应式 Python 内核&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;https://github.com/widgetti/solara&quot;&gt;solara：一个纯 python、React-风格的框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;16、&lt;a href=&quot;https://pythoninsider.blogspot.com/2023/05/python-3120-beta-1-released.html&quot;&gt;Python 3.12 的 beta 1 版本已发布&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;17、&lt;a href=&quot;https://programming-idioms.org/cheatsheet/Python/Rust&quot;&gt;对比 Python 与 Rust 的编程习惯用法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;18、&lt;a href=&quot;https://github.com/Textualize/frogmouth&quot;&gt;frogmouth：一个在终端中浏览 Markdown 的工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;19、&lt;a href=&quot;https://github.com/dibrale/samist&quot;&gt;使用 Meta AI 的 SAM 进行图像分割的 Python GUI&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;20、&lt;a href=&quot;https://github.com/EniasCailliau/GirlfriendGPT&quot;&gt;GirlfriendGPT：你的人工智能伴侣&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;21、&lt;a href=&quot;https://www.slideshare.net/Manjusaka1/python-pptx-258083055&quot;&gt;Python 进化之路.pptx&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;22、&lt;a href=&quot;https://github.com/lucidrains/soundstorm-pytorch&quot;&gt;soundstorm-pytorch：在 Pytorch 中实现 SoundStorm &lt;/a&gt;&lt;/div&gt;
&lt;div&gt;23、&lt;a href=&quot;https://github.com/quora/asynq&quot;&gt;asynq：Python 的异步编程库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;24、&lt;a href=&quot;https://github.com/Lancetnik/Propan&quot;&gt;Propan：功能强大且易用的 Python 异步 Web 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;25、&lt;a href=&quot;https://vra.github.io/2023/05/27/talkgpt4all-2-0/&quot;&gt;talkGPT4All：基于 GPT4All 的一个语音聊天程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;26、&lt;a href=&quot;https://github.com/lightly-ai/lightly&quot;&gt;lightly：一个用于图像自监督学习的 Python 库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;27、&lt;a href=&quot;https://github.com/neodb-social/neodb&quot;&gt;neodb：标记你喜欢的东西&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;28、&lt;a href=&quot;https://blog.jupyter.org/jupyterlab-4-0-is-here-388d05e03442&quot;&gt;JupyterLab 4.0 已发布&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;29、&lt;a href=&quot;https://github.com/bloomberg/pystack&quot;&gt;pystack&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;30、&lt;a href=&quot;https://gpython.aibang.run/&quot;&gt;GPYTHON：你的专属 Python 学习助手&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;31、&lt;a href=&quot;https://huggingface.co/moka-ai/m3e-base&quot;&gt;M3E 模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;32、&lt;a href=&quot;https://github.com/reactive-python/reactpy&quot;&gt;reactpy：Python 的 React&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;33、&lt;a href=&quot;https://github.com/mouday/domain-admin&quot;&gt;domain-admin: 域名 SSL 证书监测平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;34、&lt;a href=&quot;https://github.com/NaiboWang/EasySpider&quot;&gt;EasySpider：一个可视化爬虫软件&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;35、&lt;a href=&quot;https://github.com/camenduru/text-to-video-synthesis-colab&quot;&gt;text-to-video-synthesis-colab：文本生成视频的模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;36、&lt;a href=&quot;https://github.com/opengeos/segment-geospatial&quot;&gt;segment-geospatial：使用 SAM 分割地理空间数据&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;37、&lt;a href=&quot;https://github.com/andy-landy/traceback_with_variables&quot;&gt;traceback_with_variables：Python 回溯（错误消息）打印变量&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;38、&lt;a href=&quot;https://github.com/kislyuk/argcomplete&quot;&gt;argcomplete：命令行自动补全库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;39、&lt;a href=&quot;https://github.com/AndrewZhe/lawyer-llama&quot;&gt;Lawyer LLaMA：中文法律 LLaMA&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;40、&lt;a href=&quot;https://github.com/OpenBMB/CPM-Bee&quot;&gt;CPM-Bee：百亿参数的中英文双语基座大模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;41、&lt;a href=&quot;https://github.com/TigerResearch/TigerBot&quot;&gt;TigerBot：多语言多任务 LLM&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;42、&lt;a href=&quot;https://github.com/xbzstudio/BingAI-Client&quot;&gt;BingAI-Client：突破限制的 New Bing&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;43、&lt;a href=&quot;https://github.com/TabbyML/tabby&quot;&gt;tabby：可自托管的 AI 编码助手&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;44、&lt;a href=&quot;https://github.com/ahui2016/pyboke&quot;&gt;pyboke：极简博客生成器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;45、&lt;a href=&quot;https://github.com/AntonOsika/gpt-engineer&quot;&gt;gpt-engineer&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;46、&lt;a href=&quot;https://github.com/facebookresearch/audiocraft&quot;&gt;audiocraft：音频处理和生成库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;47、&lt;a href=&quot;https://www.pythonguis.com&quot;&gt;PythonGUI 教程网站&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;48、&lt;a href=&quot;https://hai-shi.gitbook.io/cpython-internals&quot;&gt;CPython 实现原理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;49、&lt;a href=&quot;https://github.com/zhiyiYo/PyQt-Fluent-Widgets/blob/master/docs/README_zh.md&quot;&gt;PyQt-Fluent-Widgets：基于 PyQt5 的 Fluent Design 风格组件库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;50、&lt;a href=&quot;https://github.com/pycob/pyvibe&quot;&gt;pyvibe：使用 Python 生成样式化的 HTML 页面&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;51、&lt;a href=&quot;https://github.com/pynecone-io/pynecone&quot;&gt;pynecone：纯 Python 的 Web 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;52、&lt;a href=&quot;https://github.com/norvig/pytudes&quot;&gt;pytudes：短小精悍的 Python 编程练习内容&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;53、&lt;a href=&quot;https://github.com/xinyu1205/recognize-anything&quot;&gt;recognize-anything：Recognize Anything 模型和 Tag2Text 模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;54、&lt;a href=&quot;https://github.com/alejandro-ao/ask-multiple-pdfs&quot;&gt;ask-multiple-pdfs：支持与多个 PDF 聊天的 Langchain 程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;55、&lt;a href=&quot;https://github.com/zjunlp/DeepKE&quot;&gt;DeepKE：用于知识图谱提取和及构建的开放工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;56、&lt;a href=&quot;https://github.com/wmariuss/awesome-devops&quot;&gt;awesome-DevOps：精选的 DevOps 平台、工具、实践和资源的列表&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;57、&lt;a href=&quot;https://github.com/Kanaries/pygwalker&quot;&gt;PyGWalker：将 pandas 数据转换为 Tableau 样式的可视化界面&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;58、&lt;a href=&quot;https://github.com/Suzhou-Tongyuan/jnumpy&quot;&gt;jnumpy：快速用 Julia 编写 Python C 扩展&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;59、&lt;a href=&quot;https://github.com/jupyterlab/jupyter-ai&quot;&gt;jupyter-ai：JupyterLab 的生成式 AI 扩展&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;60、&lt;a href=&quot;https://github.com/Undertone0809/broadcast-service&quot;&gt;broadcast-service: 一个强大的 Python 发布订阅者框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;61、&lt;a href=&quot;https://github.com/Undertone0809/cushy-storage&quot;&gt;cushy-storage: 一个基于磁盘缓存的 ORM 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;62、&lt;a href=&quot;https://github.com/Giskard-AI/giskard&quot;&gt;giskard：专用于 ML 模型的测试框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;63、&lt;a href=&quot;https://github.com/XingangPan/DragGAN&quot;&gt;DragGAN：基于点的交互式图像编辑&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;64、&lt;a href=&quot;https://github.com/tomerfiliba/plumbum&quot;&gt;plumbum: 永远不要再写 shell 脚本&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;65、&lt;a href=&quot;https://github.com/threestudio-project/threestudio&quot;&gt;threestudio：用于生成 3D 内容的统一框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;66、&lt;a href=&quot;https://github.com/danielgatis/rembg&quot;&gt;rembg：一个删除图像背景的工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;67、&lt;a href=&quot;https://github.com/facebookincubator/cinder&quot;&gt;cinder：Meta 内部以性能为导向的 CPython 版本&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;68、&lt;a href=&quot;https://github.com/sdan/vlite&quot;&gt;vlite：用 NumPy 制作的简易矢量数据库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;69、&lt;a href=&quot;https://github.com/0xpayne/gpt-migrate&quot;&gt;gpt-migrate：将代码仓从一种框架或语言迁移成其它&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;70、&lt;a href=&quot;https://github.com/lancetnik/FastDepends&quot;&gt;FastDepends：从 FastAPI 中提取的依赖注入框架，异步和同步模式都支持&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;71、&lt;a href=&quot;https://github.com/zwq2018/Data-Copilot&quot;&gt;Data-Copilot：通过自主工作流程桥接数十亿数据和人类&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;72、&lt;a href=&quot;https://github.com/readthedocs-examples/awesome-read-the-docs&quot;&gt;awesome-read-the-docs：精选的项目文档列表&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;73、&lt;a href=&quot;https://github.com/Wangt-CN/DisCo&quot;&gt;DisCo：通过指示生成现实世界的人类舞蹈&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;74、&lt;a href=&quot;https://theses.gla.ac.uk/2975/1/2011shannonphd.pdf&quot;&gt;Mark Shannon 博士论文：为动态语言构建高性能虚拟机&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;75、&lt;a href=&quot;https://github.com/guofei9987/blind_watermark&quot;&gt;blind_watermark：图片加盲水印，提取水印无须原图&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;76、&lt;a href=&quot;https://github.com/OpenBMB/VisCPM&quot;&gt;VisCPM：基于 CPM 基础模型的中英双语多模态大模型系列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;77、&lt;a href=&quot;https://github.com/escobar-west/polars-cookbook&quot;&gt;polars-cookbook：Python polars 库的教程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;78、&lt;a href=&quot;https://www.evidentlyai.com/ml-system-design&quot;&gt;ML 系统设计：200 个研究案例&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;79、&lt;a href=&quot;https://github.com/dmytrostriletskyi/threads-net&quot;&gt;threads-net：逆向工程 Threads 的 Python API&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;80、&lt;a href=&quot;https://github.com/ishan0102/engblogs&quot;&gt;engblogs：用 AI 为科技公司官博作摘要，并部署成网站&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;81、&lt;a href=&quot;https://github.com/adamghill/django-unicorn&quot;&gt;django-unicorn：Django 全栈的响应式组件框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;82、&lt;a href=&quot;https://github.com/Undertone0809/imarkdown&quot;&gt;imarkdown：轻量级的 Markdown 图片链接转换器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;83、&lt;a href=&quot;https://github.com/198808xc/Pangu-Weather&quot;&gt;Pangu-Weather：盘古天气的官方实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;84、&lt;a href=&quot;https://github.com/openmedlab/PULSE&quot;&gt;PULSE：中文医疗大语言模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;85、&lt;a href=&quot;https://github.com/fredrikaverpil/creosote&quot;&gt;creosote：识别虚拟环境中未使用的依赖库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;86、&lt;a href=&quot;https://github.com/IMOSR/MediaGPT&quot;&gt;MediaGPT：中文的自媒体大语言模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;87、&lt;a href=&quot;https://github.com/geekan/MetaGPT&quot;&gt;MetaGPT：给定一行需求，返回 PRD、设计、任务、代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;88、&lt;a href=&quot;https://github.com/khoj-ai/khoj&quot;&gt;khoj：数字大脑的 AI 个人助理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;89、&lt;a href=&quot;https://github.com/paul-gauthier/aider&quot;&gt;aider：基于命令行的 AI 编码助手&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;90、&lt;a href=&quot;https://github.com/allenai/visprog&quot;&gt;visprog：可视化编程，无需训练的合成视觉推理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;91、&lt;a href=&quot;https://www.reddit.com/r/Python/comments/111y9o2/python_projects_with_best_practices_on_github/&quot;&gt;GitHub 上有哪些值得推荐学习的 Python 项目？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;92、&lt;a href=&quot;https://github.com/gto76/python-cheatsheet&quot;&gt;python-cheatsheet: Python 知识点速查表&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;93、&lt;a href=&quot;https://github.com/pengzhile/pandora&quot;&gt;pandora：潘多拉，一个让你呼吸顺畅的ChatGPT&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;94、&lt;a href=&quot;https://github.com/web2py/py4web&quot;&gt;py4web：数据库驱动的 Web 开发框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;95、&lt;a href=&quot;https://www.oschina.net/p/fastapi-vue-admin&quot;&gt;FastAPI-Vue-Admin：基于 FastAPI+Vue 的敏捷开发框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;96、&lt;a href=&quot;https://github.com/sunner/ChatALL&quot;&gt;ChatALL：同时与ChatGPT、Bing Chat、Bard、Alpaca、Claude、讯飞星火、文心一言等聊天&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;97、&lt;a href=&quot;https://github.com/jina-ai/vectordb&quot;&gt;vectordb：一个 Python 向量数据库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;98、&lt;a href=&quot;https://github.com/grantjenks/python-sortedcontainers&quot;&gt;python-sortedcontainers：有序容器类型（有序列表、有序字典和有序集合）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;99、&lt;a href=&quot;https://github.com/pallets/quart&quot;&gt;quart：一个支持异步的 Python Web 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;100、&lt;a href=&quot;https://github.com/RayVentura/ShortGPT&quot;&gt;ShortGPT：自动生成短视频内容的 AI 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;101、&lt;a href=&quot;https://github.com/srbhr/Resume-Matcher&quot;&gt;Resume-Matcher：比较简历与职位描述，按照打分排名&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;102、&lt;a href=&quot;https://github.com/PyHAT-stack/awesome-python-htmx&quot;&gt;awesome-python-htmx：Python 中使用 htmx 作 Web 开发的精选内容&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;103、&lt;a href=&quot;https://github.com/THUDM/CodeGeeX2&quot;&gt;CodeGeeX2: 更强大的多语言代码生成模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;104、&lt;a href=&quot;https://github.com/LinkSoul-AI/Chinese-Llama-2-7b&quot;&gt;Chinese-Llama-2-7b: 第一个能下载运行的中文 LLaMA2 模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;105、&lt;a href=&quot;https://github.com/soulteary/docker-llama2-chat&quot;&gt;docker-llama2-chat: LLaMA2 (official / 中文版 / INT4 / llama2.cpp)&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;106、&lt;a href=&quot;https://github.com/Avaiga/taipy&quot;&gt;taipy：将数据和 AI 算法转变为完整的 Web 应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;107、&lt;a href=&quot;https://github.com/lmacken/pyrasite&quot;&gt;pyrasite：将代码注入正在运行的 Python 进程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;108、&lt;a href=&quot;https://github.com/ionelmc/python-manhole&quot;&gt;python-manhole：调试运行中的 Python 程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;109、&lt;a href=&quot;https://github.com/RamiKrispin/vscode-python&quot;&gt;vscode-python：使用 VScode 和 Docker 设置 Python 开发环境&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;110、&lt;a href=&quot;https://github.com/SergeyPirogov/webdriver_manager&quot;&gt;webdriver_manager：Python 的 Webdriver 管理器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;111、&lt;a href=&quot;https://github.com/JetBrains/lets-plot&quot;&gt;lets-plot：用于统计数据的开源绘图库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;112、&lt;a href=&quot;https://github.com/pdfarranger/pdfarranger&quot;&gt;pdfarranger：在图形界面合并或拆分 PDF 文档，支持旋转、裁剪和重排&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;113、&lt;a href=&quot;https://pyflo.net/&quot;&gt;PyFlo：一个很有趣的 Python 入门教学网站&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;114、&lt;a href=&quot;https://pandastutor.com/&quot;&gt;Pandas Tutor：可视化 Pandas 执行过程的网站&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;115、&lt;a href=&quot;https://ploomber-sql.readthedocs.io/en/latest/index.html&quot;&gt;ploomber-sql：使用 SQL 和 Jupyter 开发端到端的应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;116、&lt;a href=&quot;https://github.com/bloomberg/memray&quot;&gt;memray：Python 的内存分析器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;117、&lt;a href=&quot;https://github.com/1j01/textual-paint&quot;&gt;textual-paint：终端中的 MS Paint&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;118、&lt;a href=&quot;https://github.com/Textualize/rich&quot;&gt;rich：在终端中提供富文本和美观的样式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;119、&lt;a href=&quot;https://github.com/Salaah01/json-lineage&quot;&gt;json-lineage：支持解析大型 JSON 文件的工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;120、&lt;a href=&quot;https://github.com/Distributive-Network/PythonMonkey&quot;&gt;PythonMonkey：嵌入到 Python VM 中的 JavaScript 引擎&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;121、&lt;a href=&quot;https://github.com/rapidsai/cudf&quot;&gt;cudf：GPU 数据帧库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;122、&lt;a href=&quot;https://github.com/segmind/distill-sd&quot;&gt;distill-sd：更小更快的 Stable Diffusion&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;123、&lt;a href=&quot;https://github.com/jiawen-zhu/HQTrack&quot;&gt;HQTrack：高质量追踪视频中的任何事物&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;124、&lt;a href=&quot;https://github.com/kelvins/awesome-mlops&quot;&gt;awesome-mlops：很棒的 MLOps 工具精选列表&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;125、&lt;a href=&quot;https://github.com/joerick/pyinstrument&quot;&gt;pyinstrument：Python 的调用堆栈分析器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;126、&lt;a href=&quot;https://github.com/gaogaotiantian/viztracer&quot;&gt;viztracer：低开销的日志记录/调试/分析工具，可视化 Python 代码的执行&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;127、&lt;a href=&quot;https://github.com/jd/tenacity&quot;&gt;tenacity：Python 重试库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;128、&lt;a href=&quot;https://github.com/litestar-org/litestar&quot;&gt;litestar：轻量、灵活且可扩展的 ASGI API 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;129、&lt;a href=&quot;https://github.com/junshutang/Make-It-3D&quot;&gt;Make-It-3D：利用单个图像创建高保真 3D 模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;130、&lt;a href=&quot;https://github.com/ErwannMillon/Color-diffusion&quot;&gt;Color-diffusion：对黑白图像进行着色的扩散模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;131、&lt;a href=&quot;https://github.com/kuafuai/DevOpsGPT&quot;&gt;DevOpsGPT：AI 驱动的自动化软件开发系统&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;132、&lt;a href=&quot;https://github.com/Instagram/LibCST&quot;&gt;ILibCST：Python 的具体语法树解析器和序列化器库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;133、&lt;a href=&quot;https://github.com/HypothesisWorks/hypothesis&quot;&gt;hypothesis：功能强大、灵活且易于使用的库，用于基于属性的测试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;134、&lt;a href=&quot;https://github.com/prefix-dev/pixi&quot;&gt;pixi：Rust 开发的基于 Conda 的包管理器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;135、&lt;a href=&quot;https://github.com/beeware/briefcase&quot;&gt;briefcase：将 Python 项目转换为独立的应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;136、&lt;a href=&quot;https://github.com/modelscope/facechain&quot;&gt;facechain：可生成数字分身的深度学习工具链&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;137、&lt;a href=&quot;https://github.com/modelscope/modelscope&quot;&gt;modelscope：将 Model-as-a-Service 概念变为现实&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;138、&lt;a href=&quot;https://github.com/veekaybee/viberary&quot;&gt;viberary：基于语义的书籍搜索引擎&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;139、&lt;a href=&quot;https://github.com/polarsource/polar&quot;&gt;polar：帮助开源维护者获得更好的资助&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;140、&lt;a href=&quot;https://github.com/plbrault/youre-the-os&quot;&gt;youre-the-os：一个游戏，让你扮演操作系统！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;141、&lt;a href=&quot;https://github.com/spandanb/learndb-py&quot;&gt;learndb-py：通过从头实现数据库来学习&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;142、&lt;a href=&quot;https://github.com/sybrenjansen/mpire&quot;&gt;mpire：比标准库更快的多进程开发库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;143、&lt;a href=&quot;https://github.com/joxeankoret/diaphora&quot;&gt;diaphora：二进制文件的差异比对工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;144、&lt;a href=&quot;https://github.com/beartype/beartype&quot;&gt;beartype：近实时的静态类型检查工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;145、&lt;a href=&quot;https://github.com/AzatAI/cs_books&quot;&gt;cs_books：AzatAI 推荐的计算机科学书籍&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;146、&lt;a href=&quot;https://github.com/facebookresearch/codellama&quot;&gt;codellama：Meta 最新开源的代码生成模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;147、&lt;a href=&quot;https://github.com/facebookresearch/seamless_communication&quot;&gt;seamless_communication：最先进的语音和文本翻译的基础模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;148、&lt;a href=&quot;https://github.com/microsoft/torchscale&quot;&gt;Torchscale：(M)LLM 的基础架构&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;149、&lt;a href=&quot;https://github.com/zhanymkanov/fastapi-best-practices&quot;&gt;fastapi-best-practices：FastAPI 的最佳实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;150、&lt;a href=&quot;https://github.com/sumerc/yappi&quot;&gt;yappi：又一个 Python Profiler，支持多线程、asyncio 和 gevent&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;151、&lt;a href=&quot;https://github.com/fighting41love/funNLP&quot;&gt;funNLP：几乎最全的中文 NLP 资源库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;152、&lt;a href=&quot;https://github.com/chrieke/prettymapp&quot;&gt;prettymapp：在 Web 应用中创建精美的地图&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;153、&lt;a href=&quot;https://github.com/eliben/pycparser&quot;&gt;pycparser：纯 Python 实现的完整 C99 解析器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;154、&lt;a href=&quot;https://github.com/StanGirard/quivr&quot;&gt;quivr：生成式 AI 打造你的第二大脑&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;155、&lt;a href=&quot;https://github.com/taojy123/KeymouseGo&quot;&gt;KeymouseGo: 类似按键精灵的鼠标键盘录制和自动化操作&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;156、&lt;a href=&quot;https://github.com/CodeOptimist/ahkunwrapped&quot;&gt;ahkunwrapped：集成 AutoHotkey，用 Python 执行自动化&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;157、&lt;a href=&quot;https://github.com/ashishpatel26/500-AI-Machine-learning-Deep-learning-Computer-vision-NLP-Projects-with-code&quot;&gt;100+ AI/机器学习/深度学习/计算机视觉/NLP 项目与代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;158、&lt;a href=&quot;https://github.com/adbar/trafilatura&quot;&gt;trafilatura：一个采集 Web 文本的工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;159、&lt;a href=&quot;https://github.com/fastapi-users/fastapi-users&quot;&gt;fastapi-users：开箱即用的 FastAPI 用户管理库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;160、&lt;a href=&quot;https://github.com/eliasdorneles/upiano&quot;&gt;upiano：命令行里的钢琴&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;161、&lt;a href=&quot;https://github.com/daijro/hrequests&quot;&gt;hrequests：requests 库的替代品&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;162、&lt;a href=&quot;https://github.com/zhihaiLLM/wisdomInterrogatory&quot;&gt;wisdomInterrogatory：智海-录问法律大模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;163、&lt;a href=&quot;https://github.com/edarchimbaud/awesome-systematic-trading&quot;&gt;awesome-systematic-trading：一个精选的系统化交易列表&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;164、&lt;a href=&quot;https://github.com/QwenLM/Qwen-VL&quot;&gt;Qwen-VL：阿里通义千问-VL 模型的官方库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;165、&lt;a href=&quot;https://github.com/h2oai/h2ogpt&quot;&gt;h2ogpt：私人文档+图像的问答&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;166、&lt;a href=&quot;https://github.com/smallcloudai/refact&quot;&gt;refact：开源编码助手，支持自动补全、代码重构、代码分析&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;167、&lt;a href=&quot;https://github.com/langgenius/dify&quot;&gt;dify：创建自己的 AI 应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;168、&lt;a href=&quot;https://github.com/causalens/dara&quot;&gt;dara：轻松创建交互式 Web 应用程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;169、&lt;a href=&quot;https://github.com/lancopku/PKUSeg-python&quot;&gt;pkuseg-python：多领域中文分词工具，比 jieba 准确性更高&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;170、&lt;a href=&quot;https://github.com/mimseyedi/pysentation&quot;&gt;pysentation：在 CLI 里显示演示文稿&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;171、&lt;a href=&quot;https://github.com/eschluntz/compress&quot;&gt;compress：基于个人语料库的快捷输入工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;172、&lt;a href=&quot;https://github.com/cofactoryai/textbase&quot;&gt;textbase：用于构建 AI 聊天机器人的简单框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;173、&lt;a href=&quot;https://github.com/lemon24/reader&quot;&gt;reader：Python 开发的 feed 阅读器库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;174、&lt;a href=&quot;https://github.com/baichuan-inc/Baichuan2&quot;&gt;Baichuan2：百川 53B 大模型在线对话平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;175、&lt;a href=&quot;https://github.com/hynek/svcs/&quot;&gt;svcs：灵活的 Python 服务定位器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;176、&lt;a href=&quot;https://github.com/binary-husky/gpt_academic&quot;&gt;gpt_academic: 为 ChatGPT/GLM 提供实用化交互界面&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;177、&lt;a href=&quot;https://github.com/pypa/hatch&quot;&gt;hatch：时髦的可扩展的 Python 项目管理库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;178、&lt;a href=&quot;https://github.com/keephq/keep&quot;&gt;keep：开源的告警管理和自动化执行平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;179、&lt;a href=&quot;https://py-code.org/stats&quot;&gt;PyPI Data 网站：查看 PyPI 的各项数据&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;180、&lt;a href=&quot;https://github.com/crdoconnor/strictyaml&quot;&gt;strictyaml：类型安全的 YAML 解析和校验库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;181、&lt;a href=&quot;https://github.com/facefusion/facefusion&quot;&gt;facefusion：更先进的换脸工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;182、&lt;a href=&quot;https://github.com/deshaw/pyflyby&quot;&gt;pyflyby：一套 Python 的生产力工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;183、&lt;a href=&quot;https://github.com/yoheinakajima/instagraph&quot;&gt;instagraph：将文本内容或 URL 转换为可视化的知识图谱&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;184、&lt;a href=&quot;https://github.com/Textualize/textual-web&quot;&gt;textual-web：在浏览器中运行 TUI 和终端&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;185、&lt;a href=&quot;https://github.com/fulcrum-so/ziggy-pydust&quot;&gt;ziggy-pydust：用 Zig 语言构建 Python 扩展&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;186、&lt;a href=&quot;https://github.com/codefuse-ai/MFTCoder&quot;&gt;MFTCoder：多任务微调代码大模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;187、&lt;a href=&quot;https://github.com/rubik/radon&quot;&gt;radon：Python 代码的各种指标&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;188、&lt;a href=&quot;https://github.com/aiwaves-cn/agents&quot;&gt;agents：自主语言代理的开源框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;189、&lt;a href=&quot;https://github.com/tedivm/quasiqueue&quot;&gt;quasiqueue：一个多进程库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;190、&lt;a href=&quot;https://github.com/nicolas-hbt/pygraft&quot;&gt;pygraft：可配置的模式和知识图谱生成&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;191、&lt;a href=&quot;https://github.com/pwwang/toml-bench&quot;&gt;toml-bench：在 Python 中该用哪个 toml 库？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;192、&lt;a href=&quot;https://github.com/liuyuan-pal/SyncDreamer&quot;&gt;SyncDreamer：以单视角图像生成多视角一致的图像&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;193、&lt;a href=&quot;https://github.com/NVIDIA-AI-IOT/nanosam&quot;&gt;nanosam：使用 NVIDIA TensorRT 实时运行的 SAM 模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;194、&lt;a href=&quot;https://github.com/logpai/logparser&quot;&gt;logparser：用于日志解析的机器学习工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;195、&lt;a href=&quot;https://github.com/tairov/llama2.mojo&quot;&gt;llama2.mojo：纯 Mojo 版本的 Llama 2&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;196、&lt;a href=&quot;https://github.com/dataelement/bisheng&quot;&gt;bisheng：一个开放的 LLM DevOps 平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;197、&lt;a href=&quot;https://github.com/mwmbl/mwmbl&quot;&gt;mwmbl：用 Python 实现的开源非营利搜索引擎&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;198、&lt;a href=&quot;https://github.com/Dataherald/dataherald&quot;&gt;dataherald：自然语言转 SQL 引擎&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;199、&lt;a href=&quot;https://github.com/stanfordnlp/dspy&quot;&gt;dspy：使用基础模型编程的框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;200、&lt;a href=&quot;https://github.com/coqui-ai/TTS&quot;&gt;TTS：文本到语音转换的深度学习工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;201、&lt;a href=&quot;https://github.com/Qiskit/rustworkx&quot;&gt;rustworkx：用 Rust 实现的高性能 Python 图形库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;202、&lt;a href=&quot;https://github.com/airtai/faststream&quot;&gt;faststream：构建与事件流交互的异步服务&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;203、&lt;a href=&quot;https://github.com/aio-libs/aiohttp&quot;&gt;aiohttp：异步 HTTP 客户端/服务器框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;204、&lt;a href=&quot;https://github.com/AliRn76/Panther&quot;&gt;panther：高性能的 Python Web框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;205、&lt;a href=&quot;https://github.com/Qiskit/qiskit&quot;&gt;qiskit：用于量子计算机的开源 SDK&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;206、&lt;a href=&quot;https://github.com/mckinsey/vizro&quot;&gt;vizro：用于创建模块化数据可视化应用的工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;207、&lt;a href=&quot;https://github.com/ddbourgin/numpy-ml&quot;&gt;numpy-ml：用 numpy 作机器学习&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;208、&lt;a href=&quot;https://github.com/jsvine/pdfplumber&quot;&gt;pdfplumber：PDF 解析库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;209、&lt;a href=&quot;http://python.jpglomot.com/#/questions&quot;&gt;一个 Python 知识问答网站&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;210、&lt;a href=&quot;https://github.com/benjie-git/CardStock&quot;&gt;CardStock：跨平台的 GUI 构建工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;211、&lt;a href=&quot;https://github.com/Undertone0809/python-package-template&quot;&gt;python-package-template：标准化的 Python package模板&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;212、&lt;a href=&quot;https://github.com/pipeless-ai/pipeless&quot;&gt;pipeless：一个计算机视觉框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;213、&lt;a href=&quot;https://github.com/KoljaB/RealtimeSTT&quot;&gt;RealtimeSTT：强大、高效、低延迟的语音转文本库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;214、&lt;a href=&quot;https://github.com/richardyc/Chrome-GPT&quot;&gt;Chrome-GPT：可控制 Chrome 的 AutoGPT 代理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;215、&lt;a href=&quot;https://github.com/rohankishore/ZenNotes&quot;&gt;ZenNotes：Windows 记事本，支持翻译和TTS&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;216、&lt;a href=&quot;https://github.com/kr8s-org/kr8s&quot;&gt;kr8s：用于 Kubernetes 的客户端库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;217、&lt;a href=&quot;https://github.com/swirlai/swirl-search&quot;&gt;swirl-search：用 AI 同时搜索多个数据源&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;218、&lt;a href=&quot;https://github.com/getsentry/sentry&quot;&gt;sentry：面向开发者的错误跟踪和性能监控平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;219、&lt;a href=&quot;https://github.com/zhiwehu/100_plus_Python_Projects_Challenge&quot;&gt;15 个 Python 小项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;220、&lt;a href=&quot;https://github.com/jtesta/ssh-audit&quot;&gt;ssh-audit：SSH 服务器和客户端安全审计&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;221、&lt;a href=&quot;https://github.com/celery/celery&quot;&gt;celery：分布式任务队列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;222、&lt;a href=&quot;https://github.com/rq/rq&quot;&gt;rq：简单的任务队列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;223、&lt;a href=&quot;https://github.com/coleifer/huey&quot;&gt;huey：轻量级的任务队列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;224、&lt;a href=&quot;https://github.com/prefix-dev/rip&quot;&gt;rip：快速解决和安装 Python 包（Rust 版 pip）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;225、&lt;a href=&quot;https://github.com/mherrmann/selenium-python-helium&quot;&gt;Selenium-python-helium：Web 自动化库，让 Selenium 更好用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;226、&lt;a href=&quot;https://github.com/sinaatalay/rendercv&quot;&gt;rendercv：用 YAML/JSON 文件创建 PDF 格式的简历&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;227、&lt;a href=&quot;https://github.com/google/latexify_py&quot;&gt;latexify_py：用 Python 代码生成 LaTeX 表达式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;228、&lt;a href=&quot;https://github.com/danielgross/localpilot&quot;&gt;localpilot：Mac 上的 Github Copilot&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;229、&lt;a href=&quot;https://github.com/spotify/annoy&quot;&gt;annoy：C++/Python 的近似最近邻搜索&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;230、&lt;a href=&quot;https://github.com/spotify/voyager&quot;&gt;voyager：用于 Python 和 Java 的近似邻搜索库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;231、&lt;a href=&quot;https://github.com/codefuse-ai/Test-Agent&quot;&gt;Test-Agent：国内首个测试行业大模型工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;232、&lt;a href=&quot;https://github.com/waymo-research/waymax&quot;&gt;waymax：用于自动驾驶研究的基于 JAX 的模拟器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;233、&lt;a href=&quot;https://github.com/ccxt/ccxt&quot;&gt;ccxt：加密货币交易 API，支持 100 多个交易所&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;234、&lt;a href=&quot;https://github.com/pauloxnet/uDjango&quot;&gt;uDjango：单文件的 Django 微型项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;235、&lt;a href=&quot;https://github.com/dymmond/esmerald&quot;&gt;esmerald：高度可扩展、高性能的 Web 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;236、&lt;a href=&quot;https://github.com/laike9m/Python-Type-Challenges&quot;&gt;Python-Type-Challenges：通过在线挑战来学习 Python 类型提示&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;237、&lt;a href=&quot;https://github.com/mify-io/mify&quot;&gt;mify：微服务基础架构，代码生成工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;238、&lt;a href=&quot;https://github.com/Fadi002/de4py&quot;&gt;de4py：Python 逆向工程工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;239、&lt;a href=&quot;https://github.com/public-apis-dev/public-apis&quot;&gt;public-apis：面向开发者的公共 API 列表&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;240、&lt;a href=&quot;https://github.com/alibaba-damo-academy/FunASR&quot;&gt;FunASR：端到端语音识别工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;241、&lt;a href=&quot;https://github.com/JoeanAmier/XHS_Downloader&quot;&gt;XHS_Downloader: 小红书图文/视频作品采集工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;242、&lt;a href=&quot;https://github.com/yinan-c/RSS-GPT&quot;&gt;RSS-GPT：使用 ChatGPT 为你的 RSS 订阅源生成摘要&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;243、&lt;a href=&quot;https://github.com/codespell-project/codespell&quot;&gt;codespell：检查代码是否存在常见拼写错误&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;244、&lt;a href=&quot;https://github.com/WisdomShell/codeshell&quot;&gt;codeshell：多语言代码大模型基座&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;245、&lt;a href=&quot;https://github.com/jianchang512/pyvideotrans&quot;&gt;pyvideotrans：视频的语言翻译，并添加配音&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;246、&lt;a href=&quot;https://github.com/google/pyink&quot;&gt;pyink：Google 内部修改 Black 而成的代码格式化工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;247、&lt;a href=&quot;https://github.com/tiangolo/sqlmodel&quot;&gt;sqlmodel：Python 中的 SQL 数据库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;248、&lt;a href=&quot;https://github.com/wagtail/wagtail&quot;&gt;wagtail：一个 Django 内容管理系统&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;249、&lt;a href=&quot;https://github.com/kyleskom/NBA-Machine-Learning-Sports-Betting&quot;&gt;NBA-Machine-Learning-Sports-Betting：使用机器学习的 NBA 比赛预测&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;250、&lt;a href=&quot;https://github.com/FarhaKousar1601/Python_EBook_Free&quot;&gt;Python_EBook_Free：Python 电子书和资源&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;251、&lt;a href=&quot;https://github.com/pathwaycom/pathway&quot;&gt;pathway：高吞吐量和低延迟实时数据处理框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;252、&lt;a href=&quot;https://github.com/PrefectHQ/prefect&quot;&gt;prefect：一个工作流编排工具，构建数据管道&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;253、&lt;a href=&quot;https://github.com/AILab-CVC/VideoCrafter&quot;&gt;VideoCrafter：生成高质量视频模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;254、&lt;a href=&quot;https://madza.hashnode.dev/42-developer-resources-to-kickstart-your-coding-journey&quot;&gt;程序员值得看的 42 个学习资源&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;255、&lt;a href=&quot;https://github.com/networkx/networkx&quot;&gt;networkx：Python 的网络分析库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;256、&lt;a href=&quot;https://github.com/jgu-bytes/PythonFrameworks&quot;&gt;PythonFrameworks：Python 的各种框架汇总&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;257、&lt;a href=&quot;https://github.com/THUDM/CogVLM&quot;&gt;CogVLM：多模态预训练模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;258、&lt;a href=&quot;https://github.com/rezoo/movis&quot;&gt;movis：用于生成与编辑视频的库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;259、&lt;a href=&quot;https://github.com/cocktailpeanut/mirror&quot;&gt;mirror：基于摄像头内容，实时回答问题&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;260、&lt;a href=&quot;https://github.com/ishan0102/vimGPT&quot;&gt;vimGPT：使用 GPT-4V 和 Vimium 浏览网页&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;261、&lt;a href=&quot;https://github.com/kaixinol/twitter_user_tweet_crawler&quot;&gt;twitter_user_tweet_crawler：无需调用 Twitter API，爬取用户推文&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;262、&lt;a href=&quot;https://github.com/AboutRSS/RSS-OPML-to-Markdown&quot;&gt;RSS-OPML-to-Markdown：将 OPML 文件转化为易读的 Markdown 格式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;263、&lt;a href=&quot;https://github.com/AIFSH/MyHeyGen&quot;&gt;MyHeyGen：视频翻译工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;264、&lt;a href=&quot;https://github.com/emanuelef/awesome-python-repo-stats&quot;&gt;awesome-python-repo-stats：统计“awesome-python”列表中项目的信息&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;265、&lt;a href=&quot;https://github.com/outlines-dev/outlines&quot;&gt;outlines：引导式文本生成&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;266、&lt;a href=&quot;https://github.com/marimo-team/marimo&quot;&gt;marimo：下一代 Python notebook&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;267、&lt;a href=&quot;https://github.com/shashankvemuri/Finance&quot;&gt;Finance：150+ 量化金融 Python 程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;268、&lt;a href=&quot;https://github.com/amidaware/tacticalrmm&quot;&gt;tacticalrmm：一个远程监控和管理工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;269、&lt;a href=&quot;https://github.com/abi/screenshot-to-code&quot;&gt;screenshot-to-code：利用截图生成 HTML/Tailwind/JS 代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;270、&lt;a href=&quot;https://github.com/Dicklesworthstone/sqlalchemy_data_model_visualizer&quot;&gt;sqlalchemy_data_model_visualizer：将SQLalchemy数据模型转换为漂亮的SVG图表&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;271、&lt;a href=&quot;https://github.com/lastmile-ai/aiconfig&quot;&gt;aiconfig：配置驱动的 AI 应用开发框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;272、&lt;a href=&quot;https://github.com/PythonNest/PyNest&quot;&gt;PyNest：基于 FastAPI 构建的框架，遵循 NestJS 的模块化架构&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;273、&lt;a href=&quot;https://github.com/yl4579/StyleTTS2&quot;&gt;StyleTTS2：近乎人类水平的文本转语音库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;274、&lt;a href=&quot;https://github.com/pyjokes/pyjokes&quot;&gt;pyjokes：程序员的一句话笑话（笑话即服务） (github.com)&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;275、&lt;a href=&quot;https://github.com/pndurette/gTTS&quot;&gt;gTTS：用于与 Google 的文本转语音 API 交互&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;276、&lt;a href=&quot;https://github.com/yuxiaoy1/chatfairy&quot;&gt;chatfairy：极简的网页版聊天室，只依赖 Flask&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;277、&lt;a href=&quot;https://github.com/ObservedObserver/streamlit-shadcn-ui&quot;&gt;streamlit-shadcn-ui：在 streamlit 中使用 shadcn-ui 组件&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;278、&lt;a href=&quot;https://github.com/YaoFANGUK/video-subtitle-remover&quot;&gt;video-subtitle-remover：用 AI 去除图片/视频的硬字幕/水印&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;279、&lt;a href=&quot;https://github.com/flowtyone/flowty-realtime-lcm-canvas&quot;&gt;flowty-realtime-lcm-canvas：使用 LCM 和 gradio 库的草图到图像演示&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;280、&lt;a href=&quot;https://github.com/brandon-rhodes/pyephem&quot;&gt;pyephem：科学级的天文学计算库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;281、&lt;a href=&quot;https://github.com/VikParuchuri/marker&quot;&gt;marker：高效将 PDF/EPUB/MOBI 转换为 Markdown&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;282、&lt;a href=&quot;https://github.com/st3v3nmw/awesome-django-performance&quot;&gt;awesome-django-performance：精选资源，用于分析和优化 Django 项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;283、&lt;a href=&quot;https://github.com/koxudaxi/datamodel-code-generator&quot;&gt;datamodel-code-generator：将 JSON/YAML 转换为 Pydantic 模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;284、&lt;a href=&quot;https://github.com/koxudaxi/fastapi-code-generator&quot;&gt;fastapi-code-generator：用 openapi 文件创建 FastAPI 程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;285、&lt;a href=&quot;https://github.com/Zaloog/kanban-python&quot;&gt;kanban-python：终端中的看板应用程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;286、&lt;a href=&quot;https://github.com/tobymao/saq&quot;&gt;saq：简单的异步队列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;287、&lt;a href=&quot;https://github.com/pyqtgraph/pyqtgraph&quot;&gt;pyqtgraph：用于科学/工程应用的数据可视化及 GUI 工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;288、&lt;a href=&quot;https://github.com/beeware/toga&quot;&gt;toga：Python 原生、OS 原生的 GUI 工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;289、&lt;a href=&quot;https://github.com/autometrics-dev/autometrics-py&quot;&gt;autometrics-py：函数级的指标监测工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;290、&lt;a href=&quot;https://github.com/pycompiled/compiled&quot;&gt;compiled：Python 标准库的编译后的变体&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;291、&lt;a href=&quot;https://github.com/frostming/transpyler-gpt&quot;&gt;transpyler-gpt：GPT 驱动的 Python 转译器，让代码在旧版本上运行&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;292、&lt;a href=&quot;https://github.com/jianchang512/clone-voice&quot;&gt;clone-voice: 一个带 web 界面的声音克隆工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;293、&lt;a href=&quot;https://github.com/OthersideAI/self-operating-computer&quot;&gt;self-operating-computer：使多模态模型能够操作计算机&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;294、&lt;a href=&quot;https://github.com/frostming/marko&quot;&gt;marko：具有高扩展性的 markdown 解析器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;295、&lt;a href=&quot;https://github.com/LC044/WeChatMsg&quot;&gt;WeChatMsg：导出微信聊天记录成 HTML/Word/CSV文档&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;296、&lt;a href=&quot;https://github.com/xaoyaoo/PyWxDump&quot;&gt;PyWxDump：获取微信账号信息、导出聊天记录&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;297、&lt;a href=&quot;https://github.com/ml-explore/mlx&quot;&gt;mlx：适用于 Apple 芯片的阵列框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;298、&lt;a href=&quot;https://github.com/SamirPaulb/DSAlgo&quot;&gt;DSAlgo：数据结构和算法的面试题集锦&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;299、&lt;a href=&quot;https://pythononlinecompiler.com/&quot;&gt;Python 在线编译器网站&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;300、&lt;a href=&quot;https://github.com/aio-libs&quot;&gt;aio-libs：65 个基于 Asyncio 的库/项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;301、&lt;a href=&quot;https://github.com/kolofordjango/kolo&quot;&gt;kolo：查看 Django 应用的执行过程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;302、&lt;a href=&quot;https://github.com/m57/dnsteal&quot;&gt;dnsteal：DNS 渗透工具，通过 DNS 请求隐秘发送文件&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;303、&lt;a href=&quot;https://github.com/avgupta456/github-trends&quot;&gt;github-trends：使用自定义卡片美化 GitHub 个人主页&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;304、&lt;a href=&quot;https://github.com/spipm/Depix&quot;&gt;Depix：还原打了马赛克的截图信息&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;Python 相关的音视频内容，但不限于 Python，有不少是视频清单/专辑。&lt;/div&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.xiaoyuzhoufm.com/episode/6446499294d78eb3f74a01d8&quot;&gt;硬地骇客：大厂程序员构建 “小生意”，更加从容应对裁员潮&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://talkpython.fm/episodes/show/414/a-stroll-down-startup-lane&quot;&gt;Talk Python To Me #414：漫步创业之路&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://pythonbytes.fm/episodes/show/335/should-you-get-your-mojo-on&quot;&gt;PythonBytes #335：应该开始用 mojo 了么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://www.bilibili.com/video/BV14M4y147yH&quot;&gt;ChatGPT提示工程师｜AI大神吴恩达教你写提示词&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://pythonhunter.org/episodes/ep40&quot;&gt;Ep 40. Rust 和 PyO3：让 Python 再次伟大&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://talkpython.fm/episodes/show/415/future-of-pydantic-and-fastapi&quot;&gt;Talk Python to Me #415: Future of Pydantic and FastAPI&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://www.thoughtworks.com/insights/podcasts/technology-podcasts/fluent-python-revisited&quot;&gt;再访《流畅的 Python》作者 Luciano Ramalho&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://youtu.be/nH4qjmP2KEE&quot;&gt;最常用的七种分布式系统模式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://www.edx.org/course/cs50s-introduction-to-programming-with-python&quot;&gt;哈佛大学的 Python 编程入门课程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://pybit.es/articles/django-plugin-recommendations-by-antonio-mele-top-10-picks-for-web-development/&quot;&gt;推荐 10 个最好用的 Django 插件&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://www.xiaoyuzhoufm.com/episode/647456af6752b5f9de6bd99c&quot;&gt;硬地骇客：独立开发赚钱难？你需要正确的build策略&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://www.xiaoyuzhoufm.com/episode/646af4a66752b5f9dec561c6&quot;&gt;代码之外：离开微软、人生在于体验？阅读的意义、主动和被动的人生&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://changelog.com/podcast/526&quot;&gt;Changelog #526：与你的朋友一起 Git&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://talkpython.fm/episodes/show/418/how-to-keep-a-secret-in-python-apps&quot;&gt;#418：如何在 Python 程序中加密保存&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;https://www.deeplearning.ai/short-courses/?continueFlag=40c2724537472cbb3553ce1582e0db80&quot;&gt;吴恩达三门新的生成式 AI 课程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;16、&lt;a href=&quot;https://twitter.com/python_spaces/status/1663976856578822144&quot;&gt;MIT 的三门 Python 相关课程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;17、&lt;a href=&quot;https://www.bilibili.com/video/BV1XX4y1y7s4&quot;&gt;当你用Python3.12的时候，或许就跑了我写的代码呢！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;18、&lt;a href=&quot;https://www.youtube.com/playlist?list=PL2Uw4_HvXqvY2zhJ9AMUa_Z6dtMGF3gtb&quot;&gt;PyCon US 2023 - YouTube&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;19、&lt;a href=&quot;https://www.youtube.com/@PyCascades/videos&quot;&gt;PyCascades - 2023 视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;20、&lt;a href=&quot;https://pybit.es/articles/importance-of-refactoring&quot;&gt;pybites：&lt;/a&gt;&lt;a href=&quot;https://pybit.es/articles/importance-of-refactoring&quot;&gt;定期重构的重要性&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;21、&lt;a href=&quot;https://b23.tv/cw3Ai8V&quot;&gt;三个看似一样的列表，占用内存空间竟然不一样多？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;22、&lt;a href=&quot;https://b23.tv/2XeGXwI&quot;&gt;asyncio的理解与入门，搞不明白协程？看这个视频就够了&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;23、&lt;a href=&quot;https://talkpython.fm/episodes/show/421/python-at-netflix&quot;&gt;Talk Python To Me Podcast #421 Python at Netflix&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;24、&lt;a href=&quot;https://pythonbytes.fm/episodes/show/343/so-much-pydantic&quot;&gt;Python Bytes #343 So Much Pydantic!&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;25、&lt;a href=&quot;https://pythonhunter.org/episodes/ep41&quot;&gt;捕蛇者说 Ep 41：和 Penguin 聊聊 CPython 优化和大厂编译器组的工作&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;26、&lt;a href=&quot;https://www.pythonshow.com/p/07-the-robyn-python-web-framework#details&quot;&gt;The Python Show 07 - 访谈 Robyn Web 框架的作者&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;27、&lt;a href=&quot;https://www.youtube.com/playlist?list=PLt4L3V8wVnF4GJb8dekLGTNx44FNIFwdv&quot;&gt;2023 年 Python 网络大会的 80 个视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;28、&lt;a href=&quot;https://thecreatorsai.com/p/what-to-watch-about-ai-6-youtube&quot;&gt;关于 AI 内容：推荐 6 个 YouTube 频道&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;29、&lt;a href=&quot;https://www.xiaoyuzhoufm.com/episode/64b4f4c5d0844ea812ce31e9&quot;&gt;除你武器 013｜我也不想工作啊，只是想找个岸上一上&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;30、&lt;a href=&quot;https://talkpython.fm/episodes/show/425/memray-the-endgame-python-memory-profiler&quot;&gt;Talk Python To Me #425：终极的 Python 内存分析器 Memray&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;31、&lt;a href=&quot;https://pythonpeople.fm/&quot;&gt;Python People 播客&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;32、&lt;a href=&quot;https://talkpython.fm/episodes/show/426/whats-new-in-pyscript-august-2023&quot;&gt;Talk Python To Me #426：PyScript 的新增功能&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;33、&lt;a href=&quot;https://stackoverflow.blog/2023/08/08/understanding-sre-ep-597/&quot;&gt;Stack Overflow Blog #597：了解 SRE&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;34、&lt;a href=&quot;https://stackoverflow.blog/2023/07/25/how-the-python-team-is-adapting-the-language-for-an-ai-future-ep-593/&quot;&gt;Stack Overflow Blog #593：Python 团队如何调整语言以适应 AI 的未来&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;35、&lt;a href=&quot;https://www.youtube.com/watch?v=wf-BqAjZb8M&quot;&gt;超越 PEP-8 — 漂亮易懂代码的最佳实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;36、&lt;a href=&quot;https://www.youtube.com/watch?v=spi0N_PNznE&quot;&gt;只需 5 个步骤，将“勉强能用”的代码变成 Pythonic&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;37、&lt;a href=&quot;https://m.youtube.com/playlist?list=PLs4CJRBY5F1KwxIxbTmhN9jX4hBtE-OKJ&quot;&gt;2023 年 PyCon 澳大利亚的 84 个视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;38、&lt;a href=&quot;https://www.youtube.com/playlist?list=PLnOlTVPC-yFwhpiyjsC0V_98pqRbtwNgh&quot;&gt;2023 年 Pycon 以色列的 23 个视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;39、&lt;a href=&quot;https://www.youtube.com/playlist?list=PL1PbeFStIOoOd01KhBeba-byU5E5dJ716&quot;&gt;2023 年 SciPy Talk 的 44 个视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;40、&lt;a href=&quot;https://www.youtube.com/playlist?list=PL8uoeex94UhFcwvAfWHybD7SfNgIUBRo-&quot;&gt;EuroPython 2023 的 146 个视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;41、&lt;a href=&quot;https://realpython.com/podcasts/rpp/172/&quot;&gt;Real Python 播客 #172：使用 Scalene 测量 Python 性能&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;42、&lt;a href=&quot;https://www.youtube.com/watch?v=5Sm9IVMet9c&quot;&gt;Mojo 编程语言的新手入门教程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;43、&lt;a href=&quot;https://www.youtube.com/watch?v=udHmeAmOlbI&quot;&gt;Python 3.12: 你需要知道的新特性&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;44、&lt;a href=&quot;https://www.youtube.com/playlist?list=PLEpW1LzVyQWgtT_i_IlUmx2FSP2jHcroX&quot;&gt;哥本哈根 2023 Django Day 演讲视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;45、&lt;a href=&quot;https://talkpython.fm/episodes/show/434/building-mobile-apps-backed-with-python&quot;&gt;Talk Python To Me  #434：用 Python 构建移动 APP&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;46、&lt;a href=&quot;https://www.youtube.com/watch?v=jXlR0Icvvh8&quot;&gt;Python 的代码生成：拆解 Jinja&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;47、&lt;a href=&quot;https://www.youtube.com/watch?v=rHmljD-oZrY&quot;&gt;让我们聊一聊模板&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;48、&lt;a href=&quot;https://www.youtube.com/playlist?list=PL_1BH3ug7n1Ih_Yy2TmM7MZ2zogSLZvzE&quot;&gt;JupyterCon 2023 视频 86 个&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;49、&lt;a href=&quot;https://podcasters.spotify.com/pod/show/corepy&quot;&gt;core.py：一档新的 Python 播客&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;50、&lt;a href=&quot;https://www.youtube.com/watch?v=Tml94je2edk&quot;&gt;为什么静态类型又流行起来了？ &lt;/a&gt;&lt;/div&gt;
&lt;div&gt;51、《Boost your Git DX》作者的两期播客：&lt;a href=&quot;https://realpython.com/podcasts/rpp/179/&quot;&gt;Real Python Podcast #179&lt;/a&gt; 和 &lt;a href=&quot;https://pybit.es/articles/maximizing-your-dx-with-adam-johnson/&quot;&gt;Pybites #139&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;52、&lt;a href=&quot;https://www.youtube.com/watch?v=HxSHIpEQRjs&quot;&gt;CPython 的 JIT 编译器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;53、&lt;a href=&quot;https://www.blog.pythonlibrary.org/2023/11/10/episode-21-sanic-the-async-python-web-framework/&quot;&gt;The Python Show 第 21 期：Sanic - 异步 Web 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;54、&lt;a href=&quot;https://talkpython.fm/episodes/show/439/pixi-a-fast-package-manager&quot;&gt;Talk Python To Me #439：Pixi 一个高性能的包管理器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;55、&lt;a href=&quot;https://www.blog.pythonlibrary.org/2023/11/27/episode-23-the-ruff-formatter-with-charlie-marsh/&quot;&gt;Mouse Vs Python #23：与 Charlie Marsh 聊 Ruff Formatter&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🥂讨论&amp;amp;问题&lt;/h2&gt;
&lt;div&gt;主要分享 Python论坛、Hacker News、Reddit、V2EX、知乎、Twitter 等平台的讨论帖。&lt;/div&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.zhihu.com/question/29138020&quot;&gt;如何系统地自学Python？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.v2ex.com/t/938669#reply88&quot;&gt;[吐槽] conda 真是太难用了！ 如何优雅地管理 Python 环境？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://discuss.python.org/t/allow-comprehension-syntax-in-loop-header-of-for-loop/25864&quot;&gt;允许在 for 循环的循环头中使用推导式语法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://www.v2ex.com/t/940584&quot;&gt;作为程序员，有什么提升生活/工作体验的 App、硬件、服务？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/mitsuhiko/rye/discussions/6&quot;&gt;rye 应该存在么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://www.v2ex.com/t/940195&quot;&gt;你是怎样开始程序员职业生涯的？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://tech.slashdot.org/story/23/05/23/1940217/28-years-later-windows-finally-supports-rar-files&quot;&gt;Windows 要支持 tar、7-zip、rar、gz 等格式啦？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://www.reddit.com/r/Python/comments/13nfyir/best_language_for_building_apis_tsjs_vs_py/&quot;&gt;构建 API 的最佳语言——TS/JS vs. Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://news.ycombinator.com/item?id=36339777&quot;&gt;Hacker News：Our Plan for Python 3.13&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://news.ycombinator.com/item?id=36370684&quot;&gt;在你最喜欢的编程语言中，有哪些很优雅的代码库？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://news.ycombinator.com/item?id=36581241&quot;&gt;Ask HN：关于技术史的好书？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://news.ycombinator.com/item?id=36560950&quot;&gt;Ask HN：最有价值的计算机科学书籍？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://www.zhihu.com/question/274635237&quot;&gt;Pytorch有什么节省显存的小技巧？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://discuss.python.org/t/a-fast-free-threading-python/27903/99&quot;&gt;如果 PEP-703 被采纳，Meta 将投入人力支持&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;https://discuss.python.org/t/a-steering-council-notice-about-pep-703-making-the-global-interpreter-lock-optional-in-cpython/30474?s=35&quot;&gt;关于 PEP-703 的指导委员会通知（使 CPython 的 GIL 成为可选）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;16、&lt;a href=&quot;https://www.reddit.com/r/Python/comments/15z1amc/how_to_build_the_front_end_of_a_web_app_if_you/&quot;&gt;如果只懂 Python，如何构建 Web 程序的前端？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;17、V2EX 上三则关于 Python 后端的热门讨论：&lt;a href=&quot;https://www.v2ex.com/t/962899&quot;&gt;Python 后端该如何提升自己呢？&lt;/a&gt; 、&lt;a href=&quot;https://www.v2ex.com/t/965956&quot;&gt;深夜睡不着，思考为什么国内 Python Web 后端太少&lt;/a&gt; 、&lt;a href=&quot;https://www.v2ex.com/t/966460&quot;&gt;Python 做后端，相对于 Java 或者 go 来说，到底差在哪？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;18、&lt;a href=&quot;https://www.reddit.com/r/Python/comments/17upt2f/whats_the_coolest_things_youve_done_with_python/&quot;&gt;你用 Python 做过最酷的事情是什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;19、&lt;a href=&quot;https://discuss.python.org/t/syntactic-sugar-to-encourage-use-of-named-arguments/36217&quot;&gt;鼓励使用命名参数的语法糖&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;附录&lt;/h2&gt;
&lt;div&gt;Python潮流周刊分享的内容后经常有相关联的附录，这里将它们单独整理成一节。&lt;/div&gt;
&lt;div&gt;1、&lt;a href=&quot;https://juejin.cn/post/7237424021768011834&quot;&gt;（译）使用这些方法让你的 Python 并发任务执行得更好&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://segmentfault.com/a/1190000043935266&quot;&gt;（译）本地部署开源大模型的完整教程：LangChain + Streamlit+ Llama&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://mp.weixin.qq.com/s/CcC1QEojybyRpzUUiJxdAw&quot;&gt;详解历时五年的 Cython3.0 都发生了哪些变化&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://medium.com/@willkantorpringle/executing-rust-in-python-using-webassembly-d361eb5583da&quot;&gt;使用 WebAssembly 在 Python 中执行 Rust 代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://medium.com/@willkantorpringle/calling-c-function-from-python-using-webassembly-63a305248951&quot;&gt;使用 WebAssembly 在 Python 中调用 C 函数&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://blog.pyodide.org/posts/pandastutor/&quot;&gt;Pandas Tutor 移植到 Pyodide &lt;/a&gt;&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://cpu.land/&quot;&gt;Putting the “You” in CPU &lt;/a&gt;&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://pythoncat.top/posts/2021-11-14-GIL&quot;&gt;Python 官方第一次针对 nogil 的研讨会&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://pythoncat.top/posts/2021-05-16-Guido&quot;&gt;Faster CPython 项目的首次亮相&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://pythoncat.top/posts/2021-12-13-languages&quot;&gt;从这 27 门编程语言中，也可以加深对 Python 的理解&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://peps.python.org/pep-0725/&quot;&gt;PEP-725 – 在 pyproject.toml 中指定外部依赖项&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://pythoncat.top/posts/2020-01-06-tox&quot;&gt;Python 任务自动化工具 tox 教程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://oscarbenjamin.github.io/blog/czi/post2.html&quot;&gt;系列第二篇：SymPy 多项式计算&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://juejin.cn/post/7281150086351732751&quot;&gt;（译）7 个极佳的 Python 身份验证库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;https://realpython.com/python312-new-features/&quot;&gt;Python 3.12 新功能的详细介绍&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;16、&lt;a href=&quot;https://discuss.python.org/t/pep-703-making-the-global-interpreter-lock-optional/22606/123&quot;&gt;PEP-703 的讨论&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;17、&lt;a href=&quot;https://speakerdeck.com/mitsuhiko/code-generation-in-python-dismantling-jinja&quot;&gt;Python 的代码生成：拆解 Jinja，演讲的 PPT&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;18、&lt;a href=&quot;https://speakerdeck.com/mitsuhiko/lets-talk-about-templates&quot;&gt;让我们聊一聊模板，演讲的 PPT&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;19、&lt;a href=&quot;https://vorpus.org/blog/why-im-not-collaborating-with-kenneth-reitz/&quot;&gt;Why I’m not collaborating with Kenneth Reitz&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;20、&lt;a href=&quot;https://fly.io/django-beats/new-goodies-in-django-50/&quot;&gt;Django 5.0 中的新东西&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;21、&lt;a href=&quot;https://frostming.com/error-handling/&quot;&gt;两种风格的错误处理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;22、&lt;a href=&quot;https://pythoncat.top/posts/2023-05-08-error&quot;&gt;编程语言的四种错误处理方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;23、&lt;a href=&quot;https://www.youtube.com/watch?v=MsJjzVIVs6M&quot;&gt;PyCon DE 2023&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;24、&lt;a href=&quot;https://www.youtube.com/watch?v=3-drZY3u5vo&quot;&gt;EuroPython 2023&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;25、&lt;a href=&quot;https://www.kingname.info/2023/11/11/python-run-other-code/&quot;&gt;如何安全运行别人上传的Python代码？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;26、&lt;a href=&quot;https://github.com/brandtbucher/brandtbucher/blob/master/2023/10/10/a_jit_compiler_for_cpython.pdf&quot;&gt;CPython 的 JIT 编译器，演讲视频的文稿&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;27、&lt;a href=&quot;https://www.dataroc.ca/blog/most-performant-timestamp-functions-python-2&quot;&gt;第二篇性能对比的文章&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;28、&lt;a href=&quot;https://superfastpython.com/profile-asyncio-programs/&quot;&gt;如何分析 Asyncio 程序？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;29、&lt;a href=&quot;https://github.com/VikParuchuri/marker/blob/master/data/examples/marker/thinkpython.md&quot;&gt;PDF 版《Think Python》转换Markdown的效果&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;30、&lt;a href=&quot;https://www.youtube.com/watch?v=lPl5Q5gv9G8&quot;&gt;Django 新特性的视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;最近，我重新整理了 Python 潮流周刊的前 30 期，精华内容超过 6.2 万字，制作成了精美电子书（含 EPUB 及 PDF 版本），免费开放，请在公zh号“&lt;strong&gt;Python猫&lt;/strong&gt;”里发送“&lt;strong&gt;W30&lt;/strong&gt;”，获取下载链接。&lt;/div&gt;
&lt;div&gt;本文是该电子书精华合集的浓缩版，按照分类聚合了周刊中所有内容的标题和链接，主要目的是方便读者快速索引查找。如果你对原始周刊感兴趣，想看看周刊中是如何概括和推荐这些内容的，可下载电子书进行了解。&lt;/div&gt;
&lt;div&gt;另外，周刊第 2 季已完结，也编辑出了电子书，目前仅作为付费专栏的权益，如果你对第 2 季合集和电子书感兴趣，请查看这篇专栏介绍：&lt;a href=&quot;https://pythoncat.top/posts/2024-05-06-information-gap&quot;&gt;周刊是聪明人筛选优质知识的聪明手段！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;人生苦短，我用 Python。知识无穷，我看周刊。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊第 2 季完结了，分享几项总结</title>
            <link>https://pythoncat.top/posts/2024-07-14-iweekly/</link>
            <guid>https://pythoncat.top/posts/2024-07-14-iweekly/</guid>
            <description>210 天，6 万字，700 多则内容分享，以及 93 本赠书</description>
            <pubDate>Sun, 14 Jul 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;我订阅了很多的周刊/Newsletter，但是发现它们都有一个共同的毛病：就是缺乏对往期内容的整理，它们很少会对内容数据作统计分析，更没有将内容整理成合集的习惯。&lt;/div&gt;
&lt;div&gt;在自己开始连载周刊后，我就想别开生面，除了每周更新正刊外，还计划定期做一些盘点。我认为过往周刊值得被串联起来，形成合集后，既方便大家阅读检索，在这个 AI 时代，还能作为知识库的资料，能挖掘出更多有价值的信息。&lt;/div&gt;
&lt;div&gt;Python 潮流周刊每 30 期作为一季，预计有 60,000 字以上。在第 1 季完结时，我整理成了合集，并制作成 PDF 版本的电子书，还写了一篇&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-iweekly&quot;&gt;总结分享&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;现在，第 2 季已完结，我准备延续这个做法，继续做一些总结分享。&lt;/div&gt;
&lt;div&gt;首先，分享一些数据吧。第 2 季从 2023.12.16 到 2024.07.16 正好 210 天，跟第 1 季的时长一样，精华部分总字数约 6 万，与第一季相差不大。&lt;/div&gt;
&lt;div&gt;本季周刊共分享了：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;文章/教程：354 篇&lt;/li&gt;
&lt;li&gt;项目/资源：347 个&lt;/li&gt;
&lt;li&gt;播客/视频：28 则（有不少是视频列表）&lt;/li&gt;
&lt;li&gt;热门讨论：2 个&lt;/li&gt;
&lt;li&gt;赠书：93 本&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;相比第 1 季，文章数、音视频数和热门讨论都有所下降，开源项目数略有增长，赠书数则是前一季的 18.6 倍！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;从上面的柱状图来看，每期分享的内容数相差不是很大。第 55 期是特殊加更，分享的是 9 个周刊类信息源。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;从上面的饼图来看，文章和项目这两大类基本持平，加起来的比重有 85%。音视频和热门讨论的比重相比前一季少了很多，主要是因为我最近很少花时间去接触这些内容。下一季，争取把这两类内容的数量增加起来。&lt;/div&gt;
&lt;div&gt;上一季时，我统计了公众号的阅读量、点赞和在看数。这一季由于后半段转为了付费专栏，在公众号等平台只是发布标题摘要，导致阅读量断崖式下跌，统计阅读量就没有太大意义了。&lt;/div&gt;
&lt;div&gt;截止本文写作时，周刊的&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;小报童专栏&lt;/a&gt;订阅数是 221 人，&lt;a href=&quot;https://afdian.net/a/python_weekly&quot;&gt;爱发电专栏&lt;/a&gt;订阅数是 7 人。目前的年费是 128 元，计划是每满 100 期时涨价一次。&lt;/div&gt;
&lt;div&gt;国内读者的知识付费意愿普遍较低，在程序员群体身上更是明显。很感谢这些订阅周刊的朋友，你们的认可给了我极大的鼓励，既带给我一份副业收入的喜悦，同时也强化了我持续履约更新优质内容的责任。&lt;/div&gt;
&lt;div&gt;前几天在写周刊第 60 期时，我半开玩笑地跟老婆说，每个月总有那么几天不想写周刊。其实，这是真的，很多时候我会心里自我挣扎一下，想拖延或者是罢工一会。&lt;/div&gt;
&lt;div&gt;这跟周刊紧密的更新周期有关。我们周刊基本是在周六发布，然后在周日我常常有一种被掏空感，只想陷在动漫和短视频里；到了周一至周三上午，我基本不会看 Feedly 里那些 Python 信息源，都留在周三下午到周五下午的碎片时间阅读；周五晚上到周六，则是集中的整理、发布和宣传。周而复始。&lt;/div&gt;
&lt;div&gt;非亲身经历的人也许无法体会这项任务对意志力的考验，更别说时不时的周末加班或者要出趟远门的情况对时间的挤压。虽然持续了一年多，我已经越来越得心应手，但时不时还是想偷懒一下，想给自己放松一下。&lt;/div&gt;
&lt;div&gt;有几次晚上，我坐在客厅的餐桌前心神不定，听见房间里不到 2 岁的小孩还闹着不想睡，我干脆停下来，进去给他讲即兴的睡前故事，半小时或者一个小时。我把这当做一种放松了，殊不知，我老婆每天要在小孩身上花太多时间，能安静坐在客厅做自己的事情，其实是一项她非常羡慕的特权。&lt;/div&gt;
&lt;div&gt;我不想抱怨什么，消极的情绪并非常态，更多时候，我其实是打了鸡血一般投身其中。毕竟，我善于给自己做的事赋予价值感，善于抚平情绪的波澜，善于表现出一副很有毅力的模样。&lt;/div&gt;
&lt;div&gt;在本季周刊第 50 期正式转为付费专栏的时候，我在 V2EX 看到过极其刺眼的留言，有一则骂我是“蛀虫”的。当时真的很想喷回去，加倍回击！但我几番心理斗争后还是忍住了，眼不见为净，不跟狭隘有偏见的人交流才是明智之举。&lt;/div&gt;
&lt;div&gt;免费的内容转收费了，就让一些人觉得自己利益受损了，怀有这种心态的人还是尽早远离为好。最近，@古明地觉 似乎是受我启发而出了付费 128 的《Python3.12 源码剖析》专栏，于是被一个人追骂“垃圾”，古兄的回复毫无止骂效果，最后写了一篇《带大家感受一下物种的多样性》。我的经验是，第一回合就屏蔽/忽视这种人，多说无益。&lt;/div&gt;
&lt;div&gt;所以，我对那些表达出尊重和善意的留言，十分珍惜而感激。&lt;/div&gt;
&lt;div&gt;记得在 Python猫发布《&lt;a href=&quot;https://mp.weixin.qq.com/s/SQgRvYAHb-JNLn1kSMgjaQ&quot;&gt;周刊是聪明人筛选优质知识的聪明手段！&lt;/a&gt;》后，短短几分钟就收到 10 几条支持鼓励的留言，没几天，订阅数也迎来暴涨，这更坚定了我要做付费专栏的信心！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;小报童里也收到过不少留言，以下是最近比较打动我的两则：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;除了国内的平台，我还积极扩展海外的渠道，例如 Twitter 和 Telegram，很高兴也收到过一些支持鼓励的话。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;以上是一位来自宝岛台湾的 Twitter 网友，他在周刊发布前几期时就给过我一笔美元赞赏，所以我想回馈他一份年度订阅，最后收到的是这么暖心的答复。&lt;/div&gt;
&lt;div&gt;在拓展周刊的宣传渠道时，我有幸成为中文圈里氛围最好的 &lt;a href=&quot;https://t.me/NewlearnerChannel&quot;&gt;Newlearnerの自留地&lt;/a&gt;频道的一名编辑，为周刊获得了大量关注。在转付费后，我自觉要痛失一大阵地了，没想到频道主@Newlearner365 竟十分支持知识变现：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;在开始时，当然也有一些质疑的声音，但后来，更多的是点赞支持。&lt;/div&gt;
&lt;div&gt;我们有一个与周刊同名的作为副刊的&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;频道&lt;/a&gt;，里面有不少身居海外的朋友，不方便使用微信。因此，我特意开通了&lt;a href=&quot;https://afdian.net/a/python_weekly&quot;&gt;爱发电主页&lt;/a&gt; ，本想着就照顾一下最多 3 位读者吧，没想到如今已经有 7 位订阅者了。&lt;/div&gt;
&lt;div&gt;周刊的转变和以上的留言都发生在最近两个月，现在想想，感觉时间就像突然变慢了一样，两个月前的对话还历历在目。&lt;/div&gt;
&lt;div&gt;如今，第 2 季周刊如期交付了，保质保量，下一季再接再厉。&lt;/div&gt;
&lt;div&gt;最后说一下周刊的合集以及电子书吧。前几天，我重制了第 1 季周刊合集，发布了 EPUB/PDF 版本以及 Markdown 源文件，第 2 季也会这样做。&lt;/div&gt;
&lt;div&gt;但是，为了照顾付费读者的权益，这一季的电子书暂时不会公开。请希望获取免费版本的读者耐心等待，最长不超过 1 年时间。&lt;/div&gt;
&lt;div&gt;如果你喜欢本周刊，欢迎付费订阅支持！&lt;/div&gt;
&lt;div&gt;付费订阅入口，目前只支持三种方式：&lt;/div&gt;
&lt;div&gt;1、&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;小报童&lt;/a&gt; （需要使用微信登录，可微信和邮箱接收更新）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://afdian.net/a/python_weekly&quot;&gt;爱发电&lt;/a&gt; （支持邮箱登录）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://flowus.cn/pythoncat/share/1e0b2dc6-fc44-4be9-895b-d87795299b77?code=MX4369&quot;&gt;FlowUs&lt;/a&gt; （支持手机号、邮箱和微信登录）&lt;/div&gt;
&lt;div&gt;PS. 2024.07.24 前首次订阅我的小报童专栏，请先领取&lt;a href=&quot;https://xiaobot.net/coupon/363a23b8-9acc-4a75-aa73-bd6bbd4a572d&quot;&gt;一张优惠券&lt;/a&gt; ，可享 8 折优惠。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#60：Python 的包管理工具真是多啊</title>
            <link>https://pythoncat.top/posts/2024-07-13-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-07-13-weekly/</guid>
            <description>本期周刊分享了 13 篇文章，13 个开源项目</description>
            <pubDate>Sat, 13 Jul 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;本周刊由 Python猫 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;本期周刊分享了 13 篇文章，13 个开源项目，全文 2300 字。&lt;/div&gt;
&lt;div&gt;重要提醒：&lt;/div&gt;
&lt;div&gt;1、&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;本专栏&lt;/a&gt;的邀请返利已提升到 50%，当有人通过你分享的海报或者邀请链接，购买了专栏，那么你将获得 50% 的返利。&lt;/div&gt;
&lt;div&gt;2、为祝周刊第 2 季完结，新订阅读者可领取 &lt;a href=&quot;https://xiaobot.net/coupon/363a23b8-9acc-4a75-aa73-bd6bbd4a572d&quot;&gt;限时 8 折优惠券&lt;/a&gt; ，数量有限，先到先得哈~&lt;/div&gt;
&lt;div&gt;以下是本期摘要：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🦄文章&amp;amp;教程&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① Python 的包管理工具真是多啊&lt;/div&gt;
&lt;div&gt;② 用 Flask 和 HTMX 开发一个动态博客（第 1 篇）&lt;/div&gt;
&lt;div&gt;③ PySkyWiFi：利用航空公司漏洞，实现免费上网&lt;/div&gt;
&lt;div&gt;④ 让 Python 失去随机性&lt;/div&gt;
&lt;div&gt;⑤ ChatGPT 沙盒中 Linux 系统的秘密&lt;/div&gt;
&lt;div&gt;⑥ 我用 AI 自动将帽子戴到窗外的纽约人头上&lt;/div&gt;
&lt;div&gt;⑦ pip 与 uv：Streamlit Cloud 如何将程序加载时间缩短 55%？&lt;/div&gt;
&lt;div&gt;⑧ 讲座：CPython JIT （Chipy 2024）幻灯片和参考链接&lt;/div&gt;
&lt;div&gt;⑨ Python 包命名的最佳实践&lt;/div&gt;
&lt;div&gt;⑩ 系统调用的对决：Python 与 Ruby 的差异&lt;/div&gt;
&lt;div&gt;⑪ 利用 GitHub Action 做爬虫，并将数据存在 SQLite 数据库中&lt;/div&gt;
&lt;div&gt;⑫ 我从 35 年软件开发生涯中得到的 12 条经验教训&lt;/div&gt;
&lt;div&gt;⑬ 写给 15 年前的自己的 10 条编程建议&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🐿️项目&amp;amp;资源&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① dnstwist：检测域名的钓鱼攻击、拼写错误抢注和品牌冒充&lt;/div&gt;
&lt;div&gt;② posting：位于终端里的现代 API 客户端&lt;/div&gt;
&lt;div&gt;③ filesystem_spec：Python 文件系统应遵守的规范&lt;/div&gt;
&lt;div&gt;④ babel：Python 国际化库&lt;/div&gt;
&lt;div&gt;⑤ fastapi-docker-temp：基于 FastAPI 的最小化 Docker 项目模版&lt;/div&gt;
&lt;div&gt;⑥ crawlee-python：Python Web 抓取和浏览器自动化库&lt;/div&gt;
&lt;div&gt;⑦ django-sql-explorer：通过 SQL 查询，在整个公司内轻松共享数据&lt;/div&gt;
&lt;div&gt;⑧ pyxel：Python 的像素风游戏开发引擎&lt;/div&gt;
&lt;div&gt;⑨ 0xtools：分析 Linux 系统上应用的性能&lt;/div&gt;
&lt;div&gt;⑩ Secator：渗透测试人员的瑞士军刀&lt;/div&gt;
&lt;div&gt;⑪ rss2newsletter：将 RSS/Atom feed 转换为邮件通讯&lt;/div&gt;
&lt;div&gt;⑫ vectorlite：SQLite 的快速可调节的向量搜索扩展&lt;/div&gt;
&lt;div&gt;⑬ LivePortrait：让人像肖像栩栩如生&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;目前周刊实行付费订阅制，年费 128 元，平均每天不到 4 毛钱，但绝对是一笔有眼光的投资。花钱学习知识，花钱提升自己，欢迎订阅这个：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;你绝对不会后悔的专栏&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;订阅后，可免费查看 &lt;a href=&quot;https://xiaobot.net/post/bdcd7330-394a-4e75-a381-dbd439f366c9&quot;&gt;第 60 期周刊的全文&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PS.本周刊&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;前30期的合集&lt;/a&gt;永久免费，已集结出了精美电子书（EPUB/PDF），请从该文开头获取下载链接。&lt;/div&gt;
&lt;div&gt;另外，付费期数将在其 50 期后免费开放，例如第 60 期将在第 110 期时免费，敬请留意。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>读者福利：超值优惠券、高额返利和精美电子书</title>
            <link>https://pythoncat.top/posts/2024-07-10-ebook/</link>
            <guid>https://pythoncat.top/posts/2024-07-10-ebook/</guid>
            <description>预告周刊第2季完结，发放3重不容错过的福利</description>
            <pubDate>Wed, 10 Jul 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;Python潮流周刊从 2023.05.13 连载至今，本周即将发布第 60 期，这意味着我们又要达成一个小小的里程碑啦！&lt;/div&gt;
&lt;div&gt;每周坚持做分享，周复一周，这对自己的精力和意志是一项不小的挑战。于是，为了让自己获得一些仪式感，我给自己定了一个较为合理的时间目标，就是每 30 期周刊作为一季。&lt;/div&gt;
&lt;div&gt;划分出“每一季”，并不是为了像电视剧一样找时间停播休息，而是为了让自己能做一些阶段性的盘点，给读者们分享一些数据、故事和感想，给自己加油鼓气。&lt;/div&gt;
&lt;div&gt;这篇文章并不是周刊第 2 季的盘点，而是一个预告，以及发放一些福利。&lt;/div&gt;
&lt;h3&gt;🎁第一重福利&lt;/h3&gt;
&lt;div&gt;小报童专栏的限时优惠券，错过就要再等 30 期啦（约 210 天）！&lt;/div&gt;
&lt;div&gt;新订阅者的 8 折优惠券（价值 25.6 元）： &lt;a href=&quot;https://xiaobot.net/coupon/363a23b8-9acc-4a75-aa73-bd6bbd4a572d&quot;&gt;点击领取&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;老读者续订的 7 折优惠券（价值 38 元），请在最近几期周刊开头领取。&lt;/div&gt;
&lt;h3&gt;🎁第二重福利&lt;/h3&gt;
&lt;div&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;Python潮流周刊专栏&lt;/a&gt;的邀请返利已提升到 50%，当有人通过你分享的海报或者邀请链接，购买了专栏，那么你将获得 50% 的返利（价值 64 元）。&lt;/div&gt;
&lt;h3&gt;🎁第三重福利&lt;/h3&gt;
&lt;div&gt;第 1 季周刊精华内容出了精美电子书，现在给 &lt;a href=&quot;https://img.pythoncat.top/python_cat.jpg&quot;&gt;Python猫&lt;/a&gt; 公众号发送“&lt;strong&gt;W30&lt;/strong&gt;”，可获取免费下载链接。内容包含 Markdown、PDF 和 EPUB 三种版本，总字数超过 6.5 万字。&lt;/div&gt;
&lt;div&gt;在第1季完结时，我曾将 30 期的精华内容整理成一篇合集文章，也转换成了一本 PDF 电子书。但是当时把周刊内丰富的图片内容都删除了，排版上也非常粗陋。&lt;/div&gt;
&lt;div&gt;这次我不仅将图片都一一加回来了，而且增加了 EPUB 版本，还附上了 Markdown 源文件，应该能提升大家的阅读体验了吧？&lt;/div&gt;
&lt;div&gt;福利介绍完了，接下来再分享几张图吧。&lt;/div&gt;
&lt;div&gt;除了重新整理和排版第 1 季周刊的合集，我还对它做了几个维度的统计分析：&lt;/div&gt;
&lt;div&gt;（1）第1季周刊每一期内容统计&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;可以看出前面几期的数据波动较大，但后来逐渐趋于稳定。&lt;/div&gt;
&lt;div&gt;（2）第1季周刊每一类内容统计&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;可以看出我们是以文章和项目为主，而且数量非常之多（约占 90%）。&lt;/div&gt;
&lt;div&gt;（3）第1季周刊的词云图&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;以上的电子书、图表和词云统计图，其实都是为了做第 2 季内容盘点而顺带完成的，一方面是为了先练练手，另一方面则是将过去有价值的内容再装点一番，让它不至于那么快消失于互联网中。&lt;/div&gt;
&lt;div&gt;最后，预告一下，等第 2 季完结后，我们还会发布第 2 季的精选电子书，敬请留意哦。（专栏付费订阅读者的福利，大家可以提前加猫哥微信为好友，到时领取）&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#59：Polars 1.0 发布了，PyCon US 2024 演讲视频也发布了</title>
            <link>https://pythoncat.top/posts/2024-07-06-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-07-06-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目，2 则视频</description>
            <pubDate>Sat, 06 Jul 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;本周刊由 Python猫 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;本期周刊分享了 12 篇文章，12 个开源项目，2 则视频，全文 2200 字。&lt;/div&gt;
&lt;div&gt;重要提醒：&lt;/div&gt;
&lt;div&gt;1、&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;本专栏&lt;/a&gt;的邀请返利已提升到 50%，当有人通过你分享的海报或者邀请链接，购买了专栏，那么你将获得 50% 的返利。&lt;/div&gt;
&lt;div&gt;2、为预祝周刊第 2 季完结，新订阅读者可领取 &lt;a href=&quot;https://xiaobot.net/coupon/363a23b8-9acc-4a75-aa73-bd6bbd4a572d&quot;&gt;限时 8 折优惠券&lt;/a&gt; ，数量有限，先到先得哈~&lt;/div&gt;
&lt;div&gt;以下是本期摘要：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🦄文章&amp;amp;教程&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① Polars 1.0 版本发布了！今后的计划？&lt;/div&gt;
&lt;div&gt;② Python 努力应对 Apple App Store 的拒绝&lt;/div&gt;
&lt;div&gt;③ 从 PDF 中提取数据的挑战，实用的 RAG 应用&lt;/div&gt;
&lt;div&gt;④ Python 中实现阶乘函数的十种方法&lt;/div&gt;
&lt;div&gt;⑤ Python 开发的最佳实践&lt;/div&gt;
&lt;div&gt;⑥ MicroPython 入门指南：（一）环境配置、Blink、部署&lt;/div&gt;
&lt;div&gt;⑦ Python 使用 .NET 开发的类库来提高你的程序执行效率&lt;/div&gt;
&lt;div&gt;⑧ 我的 Python 代码是一种神经网络&lt;/div&gt;
&lt;div&gt;⑨ Python 稀疏数组生态系统概述&lt;/div&gt;
&lt;div&gt;⑩ 犯罪分子冒充“乐于助人”的 Stack Overflow 用户推送恶意软件&lt;/div&gt;
&lt;div&gt;⑪ 使用 Prettier 对 Django 或 Jinja 模板作格式化&lt;/div&gt;
&lt;div&gt;⑫ 保持修改同步的两种方法：派生与测试&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🐿️项目&amp;amp;资源&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① graphrag：基于图形的模块化 RAG 系统&lt;/div&gt;
&lt;div&gt;② puepy：基于 PyScript 的 Python+Webassembly 前端框架&lt;/div&gt;
&lt;div&gt;③ psqlpy：Rust 写的异步 Python PostgreSQL 驱动&lt;/div&gt;
&lt;div&gt;④ pretzelai：Jupyter Notebook 们的现代替代品&lt;/div&gt;
&lt;div&gt;⑤ meet-libai:  构建李白知识图谱，训练 AI 李白智能体&lt;/div&gt;
&lt;div&gt;⑥ flpc：Rust 开发的 Python 正则表达式库&lt;/div&gt;
&lt;div&gt;⑦ Taiwan-LLM：台湾繁体中文 LLM&lt;/div&gt;
&lt;div&gt;⑧ ttkbootstrap：tkinter 的增强主题，受 Bootstrap 启发的现代平面风格&lt;/div&gt;
&lt;div&gt;⑨ bunkerweb：开源的 Web 应用防火墙（WAF）&lt;/div&gt;
&lt;div&gt;⑩ AI-Math-Notes：交互式的 AI 数学黑板&lt;/div&gt;
&lt;div&gt;⑪ cookiecutter-django：快速启动生产就绪的 Django 项目&lt;/div&gt;
&lt;div&gt;⑫ Linly-Talker：数字化身系统，结合大语言模型与视觉模型&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🐢播客&amp;amp;视频&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① PyCon US 2024 演讲视频列表&lt;/div&gt;
&lt;div&gt;② PyCon Sweden 2024 演讲视频&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;目前周刊实行付费订阅制，年费 128 元，平均每天不到 4 毛钱，但绝对是一笔有眼光的投资。花钱学习知识，花钱提升自己，欢迎订阅这个：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;你绝对不会后悔的专栏&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;订阅后，可免费查看 &lt;a href=&quot;https://xiaobot.net/post/6ea7407f-479d-4dbb-927b-f5a609589c4b&quot;&gt;第 59 期周刊的全文&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PS.本周刊&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;前30期的合集&lt;/a&gt;永久免费，另外，付费期数将在其 50 期后免费开放，例如第 59 期将在第 109 期时免费，敬请留意。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#58：最快运行原型的语言</title>
            <link>https://pythoncat.top/posts/2024-06-29-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-06-29-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目，赠书 5 本</description>
            <pubDate>Sat, 29 Jun 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;本周刊由 Python猫 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;本期周刊分享了 12 篇文章，12 个开源项目，赠书 5 本，全文 2100 字。&lt;/div&gt;
&lt;div&gt;以下是本期摘要：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🦄文章&amp;amp;教程&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① 最快运行原型的语言&lt;/div&gt;
&lt;div&gt;② PEP-2026 提议 Python 采用日历版本号&lt;/div&gt;
&lt;div&gt;③ 优化 Python 的路由和调度：一个新的开源求解器 Timefold&lt;/div&gt;
&lt;div&gt;④ 深入了解 Python 的集合数据结构&lt;/div&gt;
&lt;div&gt;⑤ 使用 weakref 介绍 Python 的弱引用&lt;/div&gt;
&lt;div&gt;⑥ 这就是软件开发现在的样子&lt;/div&gt;
&lt;div&gt;⑦ 在命令行终端使用大语言模型&lt;/div&gt;
&lt;div&gt;⑧ 如何将 Python 包发布到 PyPI？&lt;/div&gt;
&lt;div&gt;⑨ 基本 Python 项目设置&lt;/div&gt;
&lt;div&gt;⑩ 用 Make 提升 Python 开发者体验&lt;/div&gt;
&lt;div&gt;⑪ Notebooks 是代码中的麦当劳&lt;/div&gt;
&lt;div&gt;⑫ 花了 6 个月时间开发 LiveAPI 代理，我得到的 10 个经验教训&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🐿️项目&amp;amp;资源&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① Your-Journey-To-Fluent-Python：你的流畅的 Python 之旅&lt;/div&gt;
&lt;div&gt;② llm：从命令行访问大语言模型&lt;/div&gt;
&lt;div&gt;③ lmdocs：使用 LLM 生成 Python 项目的帮助文档&lt;/div&gt;
&lt;div&gt;④ make-python-devex：使用 Make、Homebrew、pyenv、poetry 等工具的示例&lt;/div&gt;
&lt;div&gt;⑤ vulture：查找无效的 Python 代码&lt;/div&gt;
&lt;div&gt;⑥ CleanMyWechat: 自动删除 PC 端微信缓存数据&lt;/div&gt;
&lt;div&gt;⑦ wxauto：Windows 版微信自动化，可发送/接收消息，简单微信机器人&lt;/div&gt;
&lt;div&gt;⑧ youdaonote-pull：一键导出/备份有道云笔记的所有笔记&lt;/div&gt;
&lt;div&gt;⑨ reladiff：跨数据库对大型数据集作高性能比对&lt;/div&gt;
&lt;div&gt;⑩ hrms：开源人力资源和薪资管理软件&lt;/div&gt;
&lt;div&gt;⑪ burr：构建能够做出决策的应用（聊天机器人、代理、仿真等）&lt;/div&gt;
&lt;div&gt;⑫ thread：AI 驱动的 Jupyter Notebook&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;目前周刊实行付费订阅制，年费 128 元，平均每天不到 4 毛钱，但绝对是一笔有眼光的投资。花钱学习知识，花钱提升自己，欢迎订阅这个：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;你绝对不会后悔的专栏&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;订阅后，可免费查看 &lt;a href=&quot;https://xiaobot.net/post/845615d4-fe5f-4b92-9036-a91e65214f0f&quot;&gt;第 58 期周刊的全文&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PS.本周刊&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;前30期的合集&lt;/a&gt;永久免费，另外，付费期数将在其 50 期后免费开放，例如第 58 期将在第 108 期时免费，敬请留意。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#57：Python 该采用日历版本吗？</title>
            <link>https://pythoncat.top/posts/2024-06-22-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-06-22-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目，赠书 5 本</description>
            <pubDate>Sat, 22 Jun 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;本周刊由 Python猫 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;本期周刊分享了 12 篇文章，12 个开源项目，赠书 5 本，全文 2200 字。&lt;/div&gt;
&lt;div&gt;以下是本期摘要：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🦄文章&amp;amp;教程&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① NumPy 2.0：一个重要的里程碑&lt;/div&gt;
&lt;div&gt;② 2024 年 Python 语言峰会：Python 该采用日历版本吗？&lt;/div&gt;
&lt;div&gt;③ 2024 年 Python 语言峰会：我们应该让 pdb 变得更好吗？&lt;/div&gt;
&lt;div&gt;④ 2024 年 Python 语言峰会：手机端上的 Python&lt;/div&gt;
&lt;div&gt;⑤ Python 项目管理入门&lt;/div&gt;
&lt;div&gt;⑥ 在 Python 中连接字符串：一个“啊哈”时刻&lt;/div&gt;
&lt;div&gt;⑦ 掌握上下文管理器，简化 Python 资源管理&lt;/div&gt;
&lt;div&gt;⑧ 如何从Pandas 迁移到 Polars&lt;/div&gt;
&lt;div&gt;⑨ 向 CPython 添加 JIT 编译器&lt;/div&gt;
&lt;div&gt;⑩ Debug 日志：CPython GH-120437&lt;/div&gt;
&lt;div&gt;⑪ 使用 Rust 将 Python AST 的解析速度提高 20 倍&lt;/div&gt;
&lt;div&gt;⑫ Ruff：Rust 开发的 Python linter-formatter 的内部原理&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🐿️项目&amp;amp;资源&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① pdf-to-podcast：将任何 PDF 转换为播客节目&lt;/div&gt;
&lt;div&gt;② prettypretty：漂亮的终端颜色库&lt;/div&gt;
&lt;div&gt;③ django-render：使用 Django 和 React 构建用户友好的应用&lt;/div&gt;
&lt;div&gt;④ holmesgpt：GPT 支持的 DevOps 助手&lt;/div&gt;
&lt;div&gt;⑤ labelme：用 Python 作图像多边形标注&lt;/div&gt;
&lt;div&gt;⑥ aurora：Python 实现的快速、可扩展的静态站点生成器&lt;/div&gt;
&lt;div&gt;⑦ httpstat：使 CURL 统计变得简单&lt;/div&gt;
&lt;div&gt;⑧ writer-framework：用于创建 AI 应用的全栈框架&lt;/div&gt;
&lt;div&gt;⑨ surya：OCR、布局分析、顺序读取、90+ 种语言的行检测&lt;/div&gt;
&lt;div&gt;⑩ MiniCPM-Llama3-V 2.5：手机上媲美 GPT-4V 的多模态 LLM&lt;/div&gt;
&lt;div&gt;⑪ pyod：用于异常值检测 Python 库&lt;/div&gt;
&lt;div&gt;⑫ warp：用于高性能 GPU 仿真和图形的 Python 框架&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;目前周刊实行付费订阅制，年费 128 元，平均每天不到 4 毛钱，但绝对是一笔有眼光的投资。花钱学习知识，花钱提升自己，欢迎订阅这个：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;你绝对不会后悔的专栏&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;订阅后，可免费查看 &lt;a href=&quot;https://xiaobot.net/post/74f36a66-b748-486c-a3fb-859855b3b002&quot;&gt;第 57 期周刊的全文&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PS.本周刊&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;前30期的合集&lt;/a&gt;永久免费，另外，付费期数将在其 50 期后免费开放，例如第 50 期将在第 100 期时免费，敬请留意。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#56：NumPy 2.0 里更快速的字符串函数</title>
            <link>https://pythoncat.top/posts/2024-06-15-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-06-15-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目，赠书 5 本</description>
            <pubDate>Sat, 15 Jun 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;本周刊由 Python猫 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;本期周刊分享了 12 篇文章，12 个开源项目，赠书 5 本，全文 2100 字。（PS.全新的赠书规则，31 本书籍任选，请查看&lt;a href=&quot;https://xiaobot.net/post/74e91eb9-ad8e-4f38-9d4f-364b8ea87551&quot;&gt;Python猫周刊赠书规则与书单&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;以下是本期摘要：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🦄文章&amp;amp;教程&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① 给 NumPy 2.0 实现更快速的字符串函数&lt;/div&gt;
&lt;div&gt;② Python 中的 __pycache__ 文件夹是什么？&lt;/div&gt;
&lt;div&gt;③ CPython 垃圾回收：内部机制和实现算法&lt;/div&gt;
&lt;div&gt;④ 从零开始搭建自己的相似图片搜索引擎&lt;/div&gt;
&lt;div&gt;⑤ 使用 Pydantic Logfire 满足你的日志记录需求&lt;/div&gt;
&lt;div&gt;⑥ FastAPI 深度揭秘：高效 Web 开发指南&lt;/div&gt;
&lt;div&gt;⑦ 通过用 Python 实现 HTTP 服务器来理解它&lt;/div&gt;
&lt;div&gt;⑧ 我对“Excel 里的 Python”的看法&lt;/div&gt;
&lt;div&gt;⑨ 用 Python 将卷曲文本的图像提取成 PDF&lt;/div&gt;
&lt;div&gt;⑩ Python Celery 的缺陷&lt;/div&gt;
&lt;div&gt;⑪ 事件驱动的 Ansible，是什么、为什么以及如何使用？&lt;/div&gt;
&lt;div&gt;⑫ 我国出版的 Python 教材几乎都有基本概念错误&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🐿️项目&amp;amp;资源&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① WeasyPrint：非常棒的工具，将 Web 生成 PDF 文档&lt;/div&gt;
&lt;div&gt;② oxo：现代的安全扫描编排器&lt;/div&gt;
&lt;div&gt;③ jupyterlab-desktop：JupyterLab 桌面版，基于 Electron&lt;/div&gt;
&lt;div&gt;④ teo：模式驱动的 Web 服务端框架&lt;/div&gt;
&lt;div&gt;⑤ aiosql：Python 中的简单 SQL&lt;/div&gt;
&lt;div&gt;⑥ thread：AI 驱动的 Python 笔记本，使用 React 构建&lt;/div&gt;
&lt;div&gt;⑦ OpenRecall：Windows Recall 的开源替代&lt;/div&gt;
&lt;div&gt;⑧ requests-futures：使用 Futures 实现的异步 Python HTTP Requests&lt;/div&gt;
&lt;div&gt;⑨ websocket-client：Python 的 WebSocket 客户端&lt;/div&gt;
&lt;div&gt;⑩ Freeway：WiFi 渗透测试与审计工具&lt;/div&gt;
&lt;div&gt;⑪ cibuildwheel：以最少的配置为所有平台构建 Python wheel&lt;/div&gt;
&lt;div&gt;⑫ 超过 6000 份免费的速查表&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;目前周刊实行付费订阅制，年费 128 元，平均每天不到 4 毛钱，但绝对是一笔有眼光的投资。花钱学习知识，花钱提升自己，欢迎订阅这个：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;你绝对不会后悔的专栏&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;订阅后，可免费查看 &lt;a href=&quot;https://xiaobot.net/post/6fbda8cf-0374-4953-83ac-93c82dd8d3ed&quot;&gt;第 56 期周刊的全文&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PS.本周刊&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;前30期的合集&lt;/a&gt;永久免费，另外，付费期数将在其 50 期后免费开放，例如第 50 期将在第 100 期时免费，敬请留意。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python猫周刊赠书规则与书单</title>
            <link>https://pythoncat.top/posts/2024-06-15-books/</link>
            <guid>https://pythoncat.top/posts/2024-06-15-books/</guid>
            <description>继续带来超多送书福利，规则更灵活，书单更丰富了</description>
            <pubDate>Sat, 15 Jun 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。在创作《&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;Python潮流周刊&lt;/a&gt;》一年多的时间里，我已累计通过抽奖赠书 80 本！早期周刊是免费分享，所以参与人数很多，现在周刊转为付费后，参与人数较少。&lt;/div&gt;
&lt;div&gt;在人数较少的情况下，我考虑将送福利的方式调整一下，以便能普惠到更多读者，答谢大家对潮流周刊的支持！&lt;/div&gt;
&lt;h2&gt;赠书规则&lt;/h2&gt;
&lt;div&gt;1、仅限周刊的付费订阅读者参与&lt;/div&gt;
&lt;div&gt;2、每期赠书约 5 人，每人可从奖品书单中任选一本书&lt;/div&gt;
&lt;div&gt;3、参与方式一：&lt;strong&gt;在&lt;a href=&quot;https://xiaobot.net/post/74e91eb9-ad8e-4f38-9d4f-364b8ea87551?refer=2fc438e2-33fe-44bd-aa2f-ae7d8e782dea&quot;&gt;小报童的本文&lt;/a&gt;下方留言，说说在过去一年里，对你影响最大的一个东西是什么（比如某本书、电影、思维方法等），它如何影响了你？希望你的留言是对他人也有启发的。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;4、参与方式二：通过小报童的邀请海报或邀请链接，邀请超过 3 人全年订阅本周刊，可获赠任选一本书&lt;/div&gt;
&lt;div&gt;5、参与方式三：可能还有额外的赠书，会在微信福利群中抽奖送出（猫哥微信可从&lt;a href=&quot;https://img.pythoncat.top/python_cat.jpg&quot;&gt;Python猫公众号&lt;/a&gt;获取）&lt;/div&gt;
&lt;div&gt;6、以上每种方式可叠加，预计每期周刊选出 5 人&lt;/div&gt;
&lt;div&gt;7、规则可能会调整，以最新发文时为准&lt;/div&gt;
&lt;h2&gt;推荐书单（感谢人民邮电出版社的赞助）&lt;/h2&gt;
&lt;div&gt;Python工匠&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;流畅的Python&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;（附：可查看我写的一篇书评《&lt;a href=&quot;https://pythoncat.top/posts/2023-04-28-fluent&quot;&gt;《流畅的Python》第二版怎么样？&lt;/a&gt;》）&lt;/div&gt;
&lt;div&gt;Python数据结构与算法分析（第3版）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;明解Python算法与数据结构&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Python语言及其应用（第2版）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Python基础教程（第3版·修订版）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Python编程：从入门到实践（第3版）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;图解TCP/IP（第6版）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Hello算法&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;黑客与画家（10万册纪念版）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;图解IT基础设施&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;网络是怎样连接的&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;程序是怎样跑起来的（第3版）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;计算机是怎样跑起来的（第2版）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;TCP是怎样工作的&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;面向对象是怎样工作的（第3版）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Linux是怎样工作的&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;机器人是怎样工作的（图解版）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Python 3网络爬虫开发实战（第2版）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;用Python动手学机器学习&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;用Python动手学强化学习&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;用Python动手学统计学&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这就是ChatGPT&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;大模型应用开发极简入门：基于GPT-4和ChatGPT&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;深度学习入门：基于Python的理论与实现&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;深度学习入门2：自制框架&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;ChatGPT高效提问：prompt技巧大揭秘&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;ChatGPT：人类新纪元&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;ChatGPT从入门到精通&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;利用ChatGPT进行数据分析&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;只是为了好玩：Linux之父林纳斯自传（修订版）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;最后想说一下，订阅我们周刊的人数越多，送福利的活动就越可持续，未来才有可能增加其它福利。&lt;/div&gt;
&lt;div&gt;所以，&lt;strong&gt;请大家积极留言互动，并将周刊分享给其他朋友~~&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;付费订阅入口，目前只支持三种方式：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;小报童&lt;/a&gt; （需用微信登录，可微信和邮箱接收更新）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://afdian.net/a/python_weekly&quot;&gt;爱发电&lt;/a&gt; （支持邮箱登录）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://flowus.cn/pythoncat/share/1e0b2dc6-fc44-4be9-895b-d87795299b77?code=MX4369&quot;&gt;FlowUs&lt;/a&gt;（支持手机号、邮箱和微信登录）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#55：分享 9 个高质量的技术类信息源！</title>
            <link>https://pythoncat.top/posts/2024-06-10-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-06-10-weekly/</guid>
            <description>特别加更系列，分享几个优质的周刊类信息源</description>
            <pubDate>Mon, 10 Jun 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;大家好，我是猫哥，今天给大家分享几个高质量的技术类信息源。&lt;/div&gt;
&lt;div&gt;本文分享的信息源都是周刊类型的，所谓周刊类，就是以固定每周的频率更新，每期分享很多精华内容的链接。它的特点是信息密度极高，可以节省你去查找信息的时间，高效的学习者都会喜欢这类内容。&lt;/div&gt;
&lt;div&gt;如果不是看了这篇文章，我猜你可能想不到 Python 竟会有那么多的好东西，所以建议你可以收藏起来，总会有用的。&lt;/div&gt;
&lt;div&gt;接下来我会逐一介绍每个信息源，并给出简短的点评。推荐指数从低到高，越往后面的越值得推荐！话不多说，开始吧——&lt;/div&gt;
&lt;h2&gt;1、Awesome Python Weekly&lt;/h2&gt;
&lt;div&gt;一份创刊自 2016 年的老牌周刊，每期分享大约 10 篇文章和 5 个开源项目，只有标题和链接，没有推荐语。已有 22K 订阅。&lt;/div&gt;
&lt;div&gt;我并不推荐订阅，原因是：它是唯二把喂养蟒蛇的文章当成 Python 技术文章分享的；开源项目的链接放的是它网站的链接，需要再点一次才能跳到 Github；每期周刊有 3 则广告，而且是带描述语的，妥妥是所有周刊里含广率最高的……&lt;/div&gt;
&lt;div&gt;虽然不推荐订阅，但我挺佩服周刊作者，因为他有 20 份技术类的周刊矩阵，能挣不少钱吧……&lt;/div&gt;
&lt;div&gt;推荐指数：⭐&lt;/div&gt;
&lt;div&gt;订阅地址：&lt;a href=&quot;https://python.libhunt.com/newsletter&quot;&gt;https://python.libhunt.com/newsletter&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;2、Python weekly newsletter&lt;/h2&gt;
&lt;div&gt;这份周刊跟上一份有不少相似之处：有标题和链接（以及评论数），但没有推荐语；曾把喂养蟒蛇的文章当成技术文章；作者有近 20 份技术类周刊，矩阵化自动化更新。&lt;/div&gt;
&lt;div&gt;它很明显的特点是内容基本抓取自 Hacker News、Reddit、Twitter 和 Mastodon，比较依赖于评论热度，但质量良莠不齐。&lt;/div&gt;
&lt;div&gt;它比上一份更值得推荐的点是：每期分享的文章、项目及视频较多，总数大约 25-30 条，而且很少有广告。&lt;/div&gt;
&lt;div&gt;推荐指数：⭐⭐&lt;/div&gt;
&lt;div&gt;订阅地址：&lt;a href=&quot;https://discu.eu/weekly/python&quot;&gt;https://discu.eu/weekly/python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;3、This Week in Python&lt;/h2&gt;
&lt;div&gt;一份创立自 2022 年 3 月的周刊，每期固定分享 5 篇文章和 5 个开源项目。早期在每篇文章后有一句话简短介绍，现在只剩标题了，内容少而精，但是都能在其它周刊找到。没有广告。&lt;/div&gt;
&lt;div&gt;值得推荐的点有：博主长期纯粹出于热爱的更新，以及偶尔会发布自己原创的文章。建议有自己博客的同学，可以像他一样每周简单分享自己阅读过的一些文章/项目的链接，人人都可以拥有自己的极简版周刊。&lt;/div&gt;
&lt;div&gt;推荐指数：⭐⭐&lt;/div&gt;
&lt;div&gt;订阅链接：&lt;a href=&quot;https://bas.codes&quot;&gt;https://bas.codes&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;4、Python on Microcontrollers Newsletter&lt;/h2&gt;
&lt;div&gt;这是 Python + 硬件方向的周刊，最近达到了 11K 订阅，成绩还不错。几乎没有广告。排版有点伤眼睛。&lt;/div&gt;
&lt;div&gt;周刊以微控制器为题，其实是单板机（如树莓派）。随着物联网和智能家居等领域的发展，Python 与硬件的结合蛮有发展前景，只是这个领域的话题在国内比较小众。&lt;/div&gt;
&lt;div&gt;推荐指数：⭐⭐⭐&lt;/div&gt;
&lt;div&gt;订阅链接：&lt;a href=&quot;https://www.adafruitdaily.com&quot;&gt;https://www.adafruitdaily.com&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;5、Django News&lt;/h2&gt;
&lt;div&gt;创刊于 2019 年 12 月，聚焦于 Django 领域，内容主要是 Django 的新闻、开发版进展、文章、项目、活动和招聘等，不像其它周刊都是比较泛的话题。目前有 3.8K 订阅。&lt;/div&gt;
&lt;div&gt;相比其它周刊，它的订阅数很少，但是广告收入很强。它是唯一公开报价，并可在线预约档期的周刊，每期两个广告位，每个 200 美元。&lt;/div&gt;
&lt;div&gt;推荐指数：⭐⭐⭐&lt;/div&gt;
&lt;div&gt;订阅链接：&lt;a href=&quot;https://django-news.com&quot;&gt;https://django-news.com&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;6、Python Hub Weekly Digest&lt;/h2&gt;
&lt;div&gt;创刊于 2012 年，应该是最早的周刊之一，作者是乌克兰人。每期大约 11 篇文章和 8 个开源项目/话题。&lt;/div&gt;
&lt;div&gt;每期会包含前一两周的热门内容，而且常有一些发布时间很久的、近期没在其它周刊出现的内容。文章后基本都有一段介绍语，但内容经常只是简单摘自原文。它没有视频分类，所以常在“文章”类别下夹带视频。&lt;/div&gt;
&lt;div&gt;页面干净，一直坚持无广告。它的社交账号很活跃，在 X 上有近 140K 关注。&lt;/div&gt;
&lt;div&gt;推荐指数：⭐⭐⭐⭐&lt;/div&gt;
&lt;div&gt;订阅链接：&lt;a href=&quot;https://pythonhub.dev/digest&quot;&gt;https://pythonhub.dev/digest&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;7、Pycoder’s Weekly&lt;/h2&gt;
&lt;div&gt;大概创刊于 2012 年，目前更新到第 630+ 期，订阅数有近 102K，X 账号的关注数有 120K。&lt;/div&gt;
&lt;div&gt;它每期分享的非项目类内容有 15 条左右，项目类有大概 6 则，另外常有 Python 活动类资讯。每期广告数 2-3 则。&lt;/div&gt;
&lt;div&gt;除项目外，它分享的内容之后基本都有一段推荐语，而且在内容下方还有网站或博客名称，以及投稿者的名称，这方面做得比其它周刊细致。内容上偶尔有些读者独家投稿，即没在别的周刊出现过。&lt;/div&gt;
&lt;div&gt;周刊主理人也是 Real Python 的主理人，所以周刊上有很多自家网站上的文章和课程。&lt;/div&gt;
&lt;div&gt;推荐指数：⭐⭐⭐⭐&lt;/div&gt;
&lt;div&gt;订阅链接：&lt;a href=&quot;https://pycoders.com&quot;&gt;https://pycoders.com&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;8、Python Weekly&lt;/h2&gt;
&lt;div&gt;创刊最早的 Python 周刊之一，已更新到 650+ 期。每期的非项目类（新闻、文章、教程、演讲、播客）大概 12-15 则，项目工具类 11-15 则，另外还有很丰富的 Pyhton 活动类资讯。&lt;/div&gt;
&lt;div&gt;非项目类内容的推荐语有些写得不错，也有些仅是简单摘录原文。项目类的数量蛮多的，不过介绍语都是直接取自 Github 简介。&lt;/div&gt;
&lt;div&gt;我很佩服它能更新这么长时间，而且每期的质量都不低。它营利的手段似乎只是广告植入，不确定那些活动类信息是否有收入。作者还有 2 份周刊，分别面向程序员和创业者，办得都不错。&lt;/div&gt;
&lt;div&gt;推荐指数：⭐⭐⭐⭐⭐&lt;/div&gt;
&lt;div&gt;订阅链接：&lt;a href=&quot;https://us2.campaign-archive.com/home/?u=e2e180baf855ac797ef407fc7&amp;amp;id=9e26887fc5&quot;&gt;https://us2.campaign-archive.com/home/?u=e2e180baf855ac797ef407fc7&amp;amp;id=9e26887fc5&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;9、Python Trending Weekly&lt;/h2&gt;
&lt;div&gt;Python 潮流周刊，唯一的中文 Python 周刊，也是唯一会给读者送福利的周刊，也是唯一实行付费订阅的周刊。&lt;/div&gt;
&lt;div&gt;创刊于 2023 年 5 月，是所有周刊里最年轻的。目前每期分享文章/教程类 12 篇，项目/资源类 12 则，偶尔有播客/视频和热门讨论 2-4 则。赠书已超过 80 本。&lt;/div&gt;
&lt;div&gt;周刊分享的内容较多，且都附有认真总结的推荐语，导致每期的篇幅都很长，所花费的时间精力远超其它周刊。&lt;/div&gt;
&lt;div&gt;分享的内容约有一半是直接取材于其它周刊，相当于萃取了一遍；另外的一半内容主要来源于个人博客、技术论坛、Github 趋势等贴近于原作者的第一手信息。&lt;/div&gt;
&lt;div&gt;周刊中偶尔会附上一些精美截图，对读者的阅读体验更佳，这也是其它周刊不具备的特色。周刊每 30 期作为一季，会做出阶段性盘点，并汇集成册，这有利于历史内容发挥长尾效应，沉淀知识。&lt;/div&gt;
&lt;div&gt;其它周刊都是英文，且主要是邮件推送，不太符合国人的阅读习惯。Python 潮流周刊面向中文读者，还有基于微信的推送和阅读方式，更为便利。&lt;/div&gt;
&lt;div&gt;推荐指数：⭐⭐⭐⭐⭐&lt;/div&gt;
&lt;div&gt;订阅链接1：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;订阅链接2：&lt;a href=&quot;https://flowus.cn/pythoncat/share/1e0b2dc6-fc44-4be9-895b-d87795299b77?code=MX4369&quot;&gt;https://flowus.cn/pythoncat/share/1e0b2dc6-fc44-4be9-895b-d87795299b77&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;以上 9 份周刊就是本文想分享的信息源。周刊的信息密度极高，是信息时代里值得推荐给所有人的聪明手段，推荐大家折优订阅。&lt;/div&gt;
&lt;div&gt;有些周刊实现了较高的自动化抓取，作者靠着运营周刊矩阵，不靠质量而凭数量，每周能收获到不菲的广告费；有的周刊坚持十年如一日的更新，让人敬佩的是它始终不接广告；还有的周刊在保证质量的同时，作出多样化的营利尝试，只为可持续的健康发展。&lt;/div&gt;
&lt;div&gt;除了这 9 个外，还有不少的同类周刊，但由于篇幅有限，这里只选取了较有代表性的几个。除了这些周刊外，还有很多值得分享的高质量信息源，本系列会陆续更新，欢迎关注。&lt;/div&gt;
&lt;div&gt;PS. 本文是 &lt;a href=&quot;https://xiaobot.net/creator/python_weekly&quot;&gt;Python潮流周刊&lt;/a&gt;的端午节特别加更。授人以鱼不如授人以渔，从分享信息到分享信息源。如果你也知道一些同类的信息源，欢迎留言分享~~&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#54：ChatTTS 强大的文本生成语音模型</title>
            <link>https://pythoncat.top/posts/2024-06-08-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-06-08-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目，3 则音视频</description>
            <pubDate>Sat, 08 Jun 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;本周刊由 Python猫 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;本期周刊分享了 12 篇文章，12 个开源项目，3 则音视频，全文 2100 字。&lt;/div&gt;
&lt;div&gt;以下是本期摘要：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🦄文章&amp;amp;教程&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① 许多实用的 Python 命令行程序&lt;/div&gt;
&lt;div&gt;② 我最喜欢教的编程问题：数字长度&lt;/div&gt;
&lt;div&gt;③ 修复 Python 循环导入的一种方法&lt;/div&gt;
&lt;div&gt;④ PEP-789：限制异步生成器的 yield，防止任务取消错误&lt;/div&gt;
&lt;div&gt;⑤ 我的 PyCon US 2024 回顾&lt;/div&gt;
&lt;div&gt;⑥ Python 开发游戏如何选择引擎？&lt;/div&gt;
&lt;div&gt;⑦ ChatTTS：语气韵律媲美真人的开源 TTS 模型&lt;/div&gt;
&lt;div&gt;⑧ 使用特定的算法将运行速度提高 15×&lt;/div&gt;
&lt;div&gt;⑨ 用 GPT-4o 生成 Flask 项目代码，能做到多好？&lt;/div&gt;
&lt;div&gt;⑩ 用 Python 开发 Scrapscript 语言的编译器&lt;/div&gt;
&lt;div&gt;⑪ 什么是 Python 的可哈希对象？&lt;/div&gt;
&lt;div&gt;⑫ 用一道算法题比较 Python、Go、C++、C、AWK、Forth 和 Rust 的性能&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🐿️项目&amp;amp;资源&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① Think Python 第三版（免费在线）—Think Python, 3rd edition&lt;/div&gt;
&lt;div&gt;② 关于音乐处理的 Python 基础笔记&lt;/div&gt;
&lt;div&gt;③ ChatTTS：用于日常对话的生成语音模型&lt;/div&gt;
&lt;div&gt;④ 几个与 ChatTTS 相关的项目&lt;/div&gt;
&lt;div&gt;⑤ koheesio：构建高效数据管道的 Python 框架&lt;/div&gt;
&lt;div&gt;⑥ groqbook：使用 Groq 和 Llama3 在几秒内生成整本书&lt;/div&gt;
&lt;div&gt;⑦ cachebox：用 Rust 开发的高性能 Python 缓存库&lt;/div&gt;
&lt;div&gt;⑧ mesop：Google 开源基于 Python 的 UI 框架&lt;/div&gt;
&lt;div&gt;⑨ Qwen2：阿里云开源的大模型系列&lt;/div&gt;
&lt;div&gt;⑩ RSS-Translator：简洁可自部署的 RSS 翻译器&lt;/div&gt;
&lt;div&gt;⑪ farfalle：AI 搜索引擎， 用本地或云 LLM 自托管&lt;/div&gt;
&lt;div&gt;⑫ chsrc：全平台命令行换源工具&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🐢播客&amp;amp;视频&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① 你最喜欢的有关 Python 的 YouTube 频道是什么？&lt;/div&gt;
&lt;div&gt;② PyCon 2024 现场录制的播客&lt;/div&gt;
&lt;div&gt;③ 图灵奖得主巡礼系列播客，已更新 15 期&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;Python潮流周刊从 2023 年 5 月连载至今，已更新超过 10 万字，是绝对不容错过的学习资料。我们的愿景是帮助所有读者精进 Python 技术，拓宽职业发展道路。&lt;/div&gt;
&lt;div&gt;目前周刊实行付费订阅制，年费 128 元，平均每天不到 4 毛钱，但绝对是一笔有眼光的投资。花钱学习知识，花钱提升自己，这买卖绝对不亏，欢迎订阅这个：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;你绝对不会后悔的专栏&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;订阅后，可免费查看 &lt;a href=&quot;https://xiaobot.net/post/0fc8deaa-6607-4df1-8806-93f5fa2f9912&quot;&gt;第 54 期周刊的全文&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PS.本周刊&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;前30期的合集&lt;/a&gt;永久免费，另外，付费期数将在其 50 期后免费开放，例如第 50 期将在第 100 期时免费，敬请留意。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#53：我辈楷模，一个约见诺奖得主，一个成为核心开发者</title>
            <link>https://pythoncat.top/posts/2024-06-01-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-06-01-weekly/</guid>
            <description>分享了 12 篇文章，12 个开源项目，赠书 5 本《程序是怎样跑起来的（第3版）》</description>
            <pubDate>Sat, 01 Jun 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;本周刊由 Python猫 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;本期周刊分享了 12 篇文章，12 个开源项目，赠书 5 本《程序是怎样跑起来的（第3版）》，全文 2200 字。&lt;/div&gt;
&lt;div&gt;以下是本期摘要：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🦄文章&amp;amp;教程&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① 我「接见」了诺奖得主&lt;/div&gt;
&lt;div&gt;② 450 天成为 Python 核心开发者&lt;/div&gt;
&lt;div&gt;③ Python 如何比较浮点数和整数？&lt;/div&gt;
&lt;div&gt;④ JIT 和移除 GIL 都不是我最期待的 Python 3.13 特性&lt;/div&gt;
&lt;div&gt;⑤ 从事 Python 打包工作 6 年的不为人知的故事&lt;/div&gt;
&lt;div&gt;⑥ 庆祝 Beautiful Soup 的 20 周年&lt;/div&gt;
&lt;div&gt;⑦ 曾经最喜欢 Ruby，现在可能是 Python&lt;/div&gt;
&lt;div&gt;⑧ 使用 Postgres 的 Django 异步任务队列（不是 Kafka、Rabbit MQ、Celery 或 Redis）&lt;/div&gt;
&lt;div&gt;⑨ 在 Streamlit 中支持异步 MongoDB 操作&lt;/div&gt;
&lt;div&gt;⑩ LangChain 实战：利用 LangChain SQL Agent 和 GPT 进行文档分析和交互&lt;/div&gt;
&lt;div&gt;⑪ pyo3_asyncio：Python Asyncio 事件循环的 Rust 绑定&lt;/div&gt;
&lt;div&gt;⑫ PyPy 已经悄悄地为我工作了好几年了&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🐿️项目&amp;amp;资源&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① llama-fs：基于 llama 3 的自组织文件系统&lt;/div&gt;
&lt;div&gt;② orjson：快速准确的 JSON 库，支持数据类、日期时间和 Numpy&lt;/div&gt;
&lt;div&gt;③ asyncssh：在 asyncio 上提供 SSHv2 协议的异步客户端和服务器&lt;/div&gt;
&lt;div&gt;④ ipyblender-experimental：Jupyter 中引入 Blender&lt;/div&gt;
&lt;div&gt;⑤ searxng：免费的互联网元搜索引擎，汇总各种搜索服务和数据库的结果&lt;/div&gt;
&lt;div&gt;⑥ rio：纯 Python 的 Web 开发框架，无需 JavaScript、HTML 和 CSS&lt;/div&gt;
&lt;div&gt;⑦ buku：个人的文本迷你网络&lt;/div&gt;
&lt;div&gt;⑧ resume-builder：纯 Python 开发的简历生成工具&lt;/div&gt;
&lt;div&gt;⑨ more-itertools：比 itertools 丰富的可迭代对象操作&lt;/div&gt;
&lt;div&gt;⑩ tach：强制实施模块化、解耦的包架构&lt;/div&gt;
&lt;div&gt;⑪ Zango：构建企业级应用/微服务的 Python Web 框架&lt;/div&gt;
&lt;div&gt;⑫ pdm：支持最新 PEP 标准的 Python 包和依赖项管理工具&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;&lt;strong&gt;🐧 往年回顾&lt;/strong&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-05-27-weekly3&quot;&gt;Python潮流周刊#3：PyPI 的安全问题&lt;/a&gt; （2023.05.27）&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-05-31-weekly4&quot;&gt;Python潮流周刊#4：Python 2023 语言峰会&lt;/a&gt; （2023.05.31）&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;如今大环境依然不好，有些人经历了裁员，有些人虽还在岗却天天焦虑，于是就出现了一种趋势，就是卷学习，让自己更有竞争力。&lt;/div&gt;
&lt;div&gt;Python潮流周刊从 2023 年 5 月连载至今，已更新超过 10 万字，每期内容都十分丰富，是绝对不容错过的学习资料。我们的愿景是帮助所有读者精进 Python 技术，拓宽职业发展道路。&lt;/div&gt;
&lt;div&gt;目前周刊实行付费订阅制，年费 128 元，平均每天不到 4 毛钱，但绝对是一笔有眼光的投资。花钱学习知识，花钱提升自己，这买卖绝对不亏，欢迎订阅这个：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;你绝对不会后悔的专栏&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;订阅后，可免费查看 &lt;a href=&quot;https://xiaobot.net/post/01f3ed19-ec44-403f-b8f3-2a70b6c33a48&quot;&gt;第 53 期周刊的全文&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PS.本周刊&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;前30期的合集&lt;/a&gt;永久免费，另外，付费期数将在其 50 期后免费开放，例如第 50 期将在第 100 期时免费，敬请留意。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#52：Python 处理 Excel 的资源</title>
            <link>https://pythoncat.top/posts/2024-05-25-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-05-25-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目，赠书 5 本《网络是怎样连接的》</description>
            <pubDate>Sat, 25 May 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;本周刊由 Python猫 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;本期周刊分享了 12 篇文章，12 个开源项目，赠书 5 本《网络是怎样连接的》，全文 1900 字。&lt;/div&gt;
&lt;div&gt;以下是本期摘要：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🦄文章&amp;amp;教程&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① 正则表达式匹配可以很简单且高速&lt;/div&gt;
&lt;div&gt;② 如何利用内存中还在运行的代码，恢复已删除的源码？&lt;/div&gt;
&lt;div&gt;③ PEP-667：命名空间的一致视图&lt;/div&gt;
&lt;div&gt;④ 用 100 行代码替换 pyinstaller&lt;/div&gt;
&lt;div&gt;⑤ py.space：免费开发在线的 Python 应用&lt;/div&gt;
&lt;div&gt;⑥ 使用 Python 3.12 作静态类型函数式编程&lt;/div&gt;
&lt;div&gt;⑦ 如何用 Python 动态生成 Github 个人主页 README？&lt;/div&gt;
&lt;div&gt;⑧ 用 pyastgrep 作自定义 linting&lt;/div&gt;
&lt;div&gt;⑨ 使用 pygments 生成代码片段的图片&lt;/div&gt;
&lt;div&gt;⑩ 使用纯 NumPy 实现 Llama 3&lt;/div&gt;
&lt;div&gt;⑪ AI 帮你写的代码，所有权归谁？&lt;/div&gt;
&lt;div&gt;⑫ 聪明的代码可能是你写过最糟糕的代码&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🐿️项目&amp;amp;资源&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① 用于处理 Excel 的 Python 资源&lt;/div&gt;
&lt;div&gt;② yen：Python 虚拟环境管理工具，无需预装 Python&lt;/div&gt;
&lt;div&gt;③ Tensor-Puzzles：21 个张量谜题&lt;/div&gt;
&lt;div&gt;④ dishka：依赖注入框架&lt;/div&gt;
&lt;div&gt;⑤ hstream：将 Python 脚本转换为 Web 应用&lt;/div&gt;
&lt;div&gt;⑥ cover-agent：AI 自动生成测试，提升代码覆盖率&lt;/div&gt;
&lt;div&gt;⑦ pygments：用 Python 开发的通用型语法高亮工具&lt;/div&gt;
&lt;div&gt;⑧ hashquery：在数据仓库中定义和查询 BI 模型&lt;/div&gt;
&lt;div&gt;⑨ Python 有哪些指标监测库？&lt;/div&gt;
&lt;div&gt;⑩ stamina：可用于生产的 Python 重试库&lt;/div&gt;
&lt;div&gt;⑪ piku：支持对自己的服务器作 git 推送部署&lt;/div&gt;
&lt;div&gt;⑫ mql：用自然语言输入生成 SQL 查询&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;如今大环境依然不好，有些人经历了裁员，有些人虽还在岗却天天焦虑，于是就出现了一种趋势，就是卷学习，让自己更有竞争力。&lt;/div&gt;
&lt;div&gt;Python潮流周刊从 2023 年 5 月连载至今，已更新超过 10 万字，每期内容都十分丰富，是绝对不容错过的学习资料。我们的愿景是帮助所有读者精进 Python 技术，拓宽职业发展道路。&lt;/div&gt;
&lt;div&gt;目前周刊实行付费订阅制，年费 128 元，平均每天不到 4 毛钱，但绝对是一笔有眼光的投资。花钱学习知识，花钱提升自己，这买卖绝对不亏，欢迎订阅这个：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;你绝对不会后悔的专栏&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;订阅后，可免费查看 &lt;a href=&quot;https://xiaobot.net/post/b8b87a0e-b5c6-486f-b400-3a9606fa5099&quot;&gt;第 52 期周刊的全文&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PS.本周刊&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;前30期的合集&lt;/a&gt;永久免费，另外，付费期数将在其 50 期后免费开放，例如第 50 期将在第 100 期时免费，敬请留意。&lt;/div&gt;
&lt;div&gt;PS.有些海外的同学表示不用/很少用微信，不便访问小报童。为了照顾这些朋友，我开通了&lt;a href=&quot;https://afdian.net/a/python_weekly&quot;&gt;爱发电&lt;/a&gt;，欢迎使用这个平台来订阅。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#51：用 Python 绘制美观的图表</title>
            <link>https://pythoncat.top/posts/2024-05-18-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-05-18-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目，赠书 5 本《图解IT基础设施》</description>
            <pubDate>Sat, 18 May 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;本周刊由 Python猫 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;本期周刊分享了 12 篇文章，12 个开源项目，赠书 5 本《图解IT基础设施》，全文 2200 字。&lt;/div&gt;
&lt;div&gt;以下是本期摘要：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🦄文章&amp;amp;教程&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① 引人注目的 Python Streamlit：精美的交互式地图和图表&lt;/div&gt;
&lt;div&gt;② 我絕不用 result 作為變數名稱&lt;/div&gt;
&lt;div&gt;③ Python 中使用 Loguru 记录日志&lt;/div&gt;
&lt;div&gt;④ 35 道 Django 技术面试题&lt;/div&gt;
&lt;div&gt;⑤ Python 的集合是没有值的字典&lt;/div&gt;
&lt;div&gt;⑥ 使用 Sliver 渗透测试套件的针对 Mac 的 PyPi 包后门&lt;/div&gt;
&lt;div&gt;⑦ 为什么 TensorFlow 正在缓慢消亡？&lt;/div&gt;
&lt;div&gt;⑧ Python 中的延迟计算是什么？&lt;/div&gt;
&lt;div&gt;⑨ 为什么要看 Python 源码？它的结构长什么样子？&lt;/div&gt;
&lt;div&gt;⑩ 2014 年我的 10 个业余项目&lt;/div&gt;
&lt;div&gt;⑪ 无需数学公式，解释 LLM 的工作原理&lt;/div&gt;
&lt;div&gt;⑫ 替代实现的问题&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🐿️项目&amp;amp;资源&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① The-Python-Graph-Gallery：数百个用 Python 绘制的图表&lt;/div&gt;
&lt;div&gt;② parler-tts：高质量的 TTS 模型&lt;/div&gt;
&lt;div&gt;③ UXsim：道路上的车辆交通流模拟器&lt;/div&gt;
&lt;div&gt;④ Quads：基于四叉树的计算机艺术&lt;/div&gt;
&lt;div&gt;⑤ bilibot：用哔哩哔哩用户评论微调的本地聊天机器人&lt;/div&gt;
&lt;div&gt;⑥ pyaction：带有 Python、git 和 Github CLI 的 Docker 容器&lt;/div&gt;
&lt;div&gt;⑦ firecrawl：将整个网站变成 LLM-ready 的 markdown&lt;/div&gt;
&lt;div&gt;⑧ plotille：使用盲文点在终端中绘图&lt;/div&gt;
&lt;div&gt;⑨ petl：Python 提取、转换和加载数据表&lt;/div&gt;
&lt;div&gt;⑩ FunClip：视频语音识别和剪辑工具，集成 AI 剪辑功能&lt;/div&gt;
&lt;div&gt;⑪ map-machine：OpenStreetMap 的 Python 渲染器&lt;/div&gt;
&lt;div&gt;⑫ IC-Light：给图片加上打光照明&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;如今大环境依然不好，有些人经历了裁员，有些人虽还在岗却天天焦虑，于是就出现了一种趋势，就是卷学习，让自己更有竞争力。&lt;/div&gt;
&lt;div&gt;Python潮流周刊从 2023 年 5 月连载至今，已更新超过 10 万字，每期内容都十分丰富，是绝对不容错过的学习资料。我们的愿景是帮助所有读者精进 Python 技术，拓宽职业发展道路。&lt;/div&gt;
&lt;div&gt;目前周刊实行付费订阅制，年费 128 元，平均每天不到 4 毛钱，但绝对是一笔有眼光的投资。花钱学习知识，花钱提升自己，这买卖绝对不亏，欢迎订阅这个：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;你绝对不会后悔的专栏&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;订阅后，可免费查看 &lt;a href=&quot;https://xiaobot.net/post/a1c64559-1d22-4dd3-a257-285d87ddc2b4&quot;&gt;第 51 期周刊的全文&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PS.本周刊&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;前30期的合集&lt;/a&gt;永久免费，另外，付费期数将在其 50 期后免费开放，例如第 50 期将在第 100 期时免费，敬请留意。&lt;/div&gt;
&lt;div&gt;PS.有些海外的同学表示不用/很少用微信，不便访问小报童。为了照顾这些朋友，我开通了&lt;a href=&quot;https://afdian.net/a/python_weekly&quot;&gt;爱发电&lt;/a&gt;，欢迎使用这个平台来订阅。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#50：我最喜欢的 Python 3.13 新特性！</title>
            <link>https://pythoncat.top/posts/2024-05-12-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-05-12-weekly/</guid>
            <description>本期分享了 12 篇文章，11 个开源项目，2 则音视频，赠书 5 本《黑客与画家（10万册纪念版）》</description>
            <pubDate>Sun, 12 May 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;本周刊由 Python猫 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;本期分享了 12 篇文章，11 个开源项目，2 则音视频，赠书 5 本《黑客与画家（10万册纪念版）》&lt;/div&gt;
&lt;div&gt;全文 2500 字，以下是本期标题摘要：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;🦄文章&amp;amp;教程&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① 我最喜欢的 Python 3.13 新特性&lt;/div&gt;
&lt;div&gt;② Python 3.13 新功能盘点介绍&lt;/div&gt;
&lt;div&gt;③ Python Asyncio 工作原理：从零实现一个简化版 Asyncio&lt;/div&gt;
&lt;div&gt;④ 友好的 Python：封装和复用&lt;/div&gt;
&lt;div&gt;⑤ 零基础入门 Python 文件处理篇——实现一个简单的文件搜索引擎&lt;/div&gt;
&lt;div&gt;⑥ 用 HTMX 和 Django 开发一个 Connect Four 游戏&lt;/div&gt;
&lt;div&gt;⑦ 用 wxPython 开发一个简单的计算器&lt;/div&gt;
&lt;div&gt;⑧ 学生在入门数据科学时常犯的错误&lt;/div&gt;
&lt;div&gt;⑨ 使用“不安全的 Python”加速 Numpy 代码 100 倍&lt;/div&gt;
&lt;div&gt;⑩ Python 字典详细的历史演变过程&lt;/div&gt;
&lt;div&gt;⑪ 重新发明 Python notebook 的经验教训&lt;/div&gt;
&lt;div&gt;⑫ Python 软件基金会新闻：2022 和 2023 资助计划的透明度报告&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;🐿️项目&amp;amp;资源&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① pywinassistant：用自然语言控制 Windows 用户界面&lt;/div&gt;
&lt;div&gt;② chinese-calendar：判断一天是不是法定节假日/工作日&lt;/div&gt;
&lt;div&gt;③ Oven：探索 Python PyPI 包&lt;/div&gt;
&lt;div&gt;④ tetos：适用于多种 TTS 服务的统一接口&lt;/div&gt;
&lt;div&gt;⑤ relax-py：又一个 Python Web 框架&lt;/div&gt;
&lt;div&gt;⑥ 哈佛大学 2024 年 CS50 线上课程&lt;/div&gt;
&lt;div&gt;⑦ portr：专为团队设计的开源的 ngrok 替代方案&lt;/div&gt;
&lt;div&gt;⑧ py-compress-compare：对比分析 zlib、LZ4、Brotli 和 Zstandard&lt;/div&gt;
&lt;div&gt;⑨ pyspread：用 Python 开发的电子表格，可支持 Python 代码&lt;/div&gt;
&lt;div&gt;⑩ PgQueuer：基于 PostgreSQL 的任务队列库&lt;/div&gt;
&lt;div&gt;⑪ 你用人工智能做过的最实用的事情是什么？&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;🐢播客&amp;amp;视频&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① core.py Ep 10：开发者聊 Python 3.13 的 REPL&lt;/div&gt;
&lt;div&gt;② The Python Show 40 - 与 Antonio Cuni 一起聊开源开发&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;如今大环境依然不好，有些人经历了裁员，有些人虽还在岗却天天焦虑，于是就出现了一种趋势，就是卷学习，让自己更有竞争力。&lt;/div&gt;
&lt;div&gt;Python潮流周刊从 2023 年 5 月连载至今，已更新超过 10 万字，每期内容都十分丰富，是绝对不容错过的学习资料。我们的愿景是帮助所有读者精进 Python 技术，拓宽职业发展道路。&lt;/div&gt;
&lt;div&gt;目前周刊实行付费订阅制，年费 128 元，平均每天不到 4 毛钱，但绝对是一笔有眼光的投资。花钱学习知识，花钱提升自己，这买卖绝对不亏，欢迎订阅这个：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;你绝对不会后悔的专栏&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;订阅后，可免费查看 &lt;a href=&quot;https://xiaobot.net/post/bf7a68d3-33a5-4987-afc4-099a7febb869&quot;&gt;第 50 期周刊的全文&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>周刊是聪明人筛选优质知识的聪明手段！</title>
            <link>https://pythoncat.top/posts/2024-05-06-information-gap/</link>
            <guid>https://pythoncat.top/posts/2024-05-06-information-gap/</guid>
            <description>打破信息差，做你高质量的信息筛选器</description>
            <pubDate>Mon, 06 May 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;这是一个信息过载的时代，也是一个信息匮乏的时代。&lt;/div&gt;
&lt;div&gt;这种矛盾的现象在 Python 编程语言上的表现非常明显。&lt;/div&gt;
&lt;div&gt;它是常年高居编程语言排行榜的最流行语言之一，在国外发展得如火如荼，开发者、项目、文章、播客、会议活动等相关信息如海如潮。&lt;/div&gt;
&lt;div&gt;但是，形成鲜明对比的是，它在国内的就业形势一片黯淡，开发者数量与知识社区常年都萎靡不振（除了培训机构的广告满天飞）。&lt;/div&gt;
&lt;div&gt;国内 Python 社区与西方主流社区存在着巨大的信息差。我多年持续观察，对此感受颇深，这里从两个较为直观的维度能看出差距有多大：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;文章的数量。国内做得最好的技术平台是掘金（除公众号不好统计外，其它都差一大截），Python 分类下每天的文章数基本不超过 20 篇；国外的平台有 Medium、DEV社区、Hashnode、Reddit 等，每一个都能压掘金一筹。至于 Python 类个人博客，那就更不用提了&lt;/li&gt;
&lt;li&gt;播客的数量。国内只有“&lt;a href=&quot;https://pythonhunter.org&quot;&gt;捕蛇者说&lt;/a&gt;”一株独苗，更新的内容和频率都很佛系；国外的播客非常多，2019 年&lt;a href=&quot;https://pythoncat.top/posts/2019-04-12-podcast&quot;&gt;有篇文章&lt;/a&gt;介绍了 27 个，如今只会更多，我记得在去年的 Python 潮流周刊里就介绍过 4 档新的播客&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;除此之外，还有开源项目、社区活动、公司招聘、以及最最重要的是创造出这些东西的贡献者，感觉那一边是璀璨若繁星，而这一边微似点点流萤。&lt;/div&gt;
&lt;div&gt;为了弥补这一信息差距，我创办了“&lt;strong&gt;Python潮流周刊&lt;/strong&gt;”。&lt;/div&gt;
&lt;div&gt;周刊自 2023 年 5 月连载至今，到下一期就是第 50 期了，时间正好是一周年！&lt;/div&gt;
&lt;div&gt;我过去有些疑虑，不知道自己能坚持更新多久，对于内容和运营手段也没有考虑得太清楚，因此，既没有写下过什么“创刊语”，也没有好好向大家推销过。&lt;/div&gt;
&lt;div&gt;在《&lt;a href=&quot;https://pythoncat.top/posts/2024-04-14-paid-column&quot;&gt;技术周刊的转变：如何平衡热爱与现实？&lt;/a&gt;》里，我解释了为什么会转向付费专栏。经过最近几期的试运行，正好遇上周岁生日的节点，于是，我决定就从第 50 期开始（预计时间为 5 月 12 日），让我们开启一段新的旅程吧！&lt;/div&gt;
&lt;div&gt;接下来，我将向你隆重介绍 &lt;strong&gt;Python潮流周刊&lt;/strong&gt;，如果你觉得它是你想要的东西，欢迎订阅！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Python潮流周刊是一个专为国内 Python 开发者量身打造的资讯平台，为你挑选最值得分享的文章&amp;amp;教程、开源项目、软件工具、播客和视频、热门话题等丰富内容。&lt;/div&gt;
&lt;div&gt;我通过 RSS 方式订阅了近 400 个与 Python 或编程开发相关的优质信息源，每周从大量信息中精挑细选出 24 则左右的内容，汇集成一期精选周刊。&lt;/div&gt;
&lt;div&gt;我们的初衷之一是打破信息差，让读者以便捷的方式接触到主流技术社区里的优质内容。经过一年的发展，我们这方面做得挺好的。&lt;/div&gt;
&lt;div&gt;人们常说，阅读的内容将塑造你成为什么样的人。但问题是怎样才能接触到最优质的阅读材料呢？&lt;/div&gt;
&lt;div&gt;与其碰运气般被动等待信息流的推荐，不如订阅一个靠谱的信息源。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;我希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;我们的目标是打破知识信息差，为国内的 Python 社区注入活力，愿景是帮助所有读者精进 Python 技术，拓宽职业发展道路。&lt;/div&gt;
&lt;div&gt;国外有很多创办了数年的 Python 周刊，它们既是我们周刊的榜样与素材库，同时也是我们的“竞争对手”。&lt;/div&gt;
&lt;div&gt;Python 潮流周刊与其它同类周刊相比，我们的优势有：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;适应本土化&lt;/strong&gt;。我们周刊会分享很多国内开发者的博客、开源项目、播客与视频等内容，并且去除了不适合国内的内容（例如国外举办的线下活动）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内容更详实&lt;/strong&gt;。我们周刊每则分享内容下都有认真整理的摘要&amp;amp;推荐语，不像其它周刊只放个标题或简单照搬原文的一两句话；另外在分享内容后，常常会添加一些强相关的附录内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;要素更多样&lt;/strong&gt;。我们周刊经常会附上精美的截图，图文并茂，不像其它周刊只有文字；另外对于 star 数超过 1000 的开源项目，我们会作出注释，让你能重点留意&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;毫不夸张地说，&lt;strong&gt;Python 潮流周刊已经是全世界知识密度最高、知识广度最大的 Python 技术周刊，没有之一！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;我们电报频道里每周会汇集其它周刊的更新，如果你经常阅读，对此的感受相信会更加强烈。&lt;/div&gt;
&lt;div&gt;除了上述的优势，我们周刊当然也有一些缺点，以下是被反馈比较多的两个使用门槛：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;需要使用魔法上网&lt;/strong&gt;。周刊里经常有些链接不能直接打开，因此若你的上网技能不足，那道屏障可能会影响到阅读体验&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;需要使用翻译工具&lt;/strong&gt;。周刊里分享的内容大约有 90% 是英文，因此若你只靠自己阅读理解，可能会影响阅读效率&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;关于第一点，这里不能多说，由于读者里泛程序员群体居多，应该问题也不大吧？&lt;/div&gt;
&lt;div&gt;关于第二点，我推荐你使用“沉浸式翻译”，这是一款浏览器插件，很有帮助；另外，如今有了 LLM 加持，翻译和阅读场景都有不少工具，这方面请自行探索了。&lt;/div&gt;
&lt;div&gt;以上主要介绍了 Python潮流周刊是什么、我们想做什么、优势和缺点，简单一句话介绍：&lt;strong&gt;Python潮流周刊是你获取优质技术信息的精选周刊。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;接下来，我将介绍如何订阅专栏，以及订阅后你能获得的权益，最后还有一份不容错过的福利。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;订阅地址：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;你可在浏览器里访问以上链接，或者使用微信扫描下方二维码：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这是在小报童上开通的服务，它支持手机端和 PC 端访问，你可以用微信接收周刊更新，也可以用邮箱接收。&lt;/div&gt;
&lt;div&gt;如果你有使用上的问题，请直接咨询我，或者查阅官方的指南：&lt;a href=&quot;https://help.xiaobot.net/reader.html&quot;&gt;https://help.xiaobot.net/reader.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;订阅后，你可获得的权益：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优质内容&lt;/strong&gt;：每周 1 期，全年 50 期左右，预计总字数 12 万字/年&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;丝滑体验&lt;/strong&gt;：微信接收更新，流畅阅读，无障碍跳转文字链接，不用受限于公众号&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;专属福利&lt;/strong&gt;：授人以鱼不如授人以渔，我会在专栏不定期分享优质的信息源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;学生折扣&lt;/strong&gt;：如果你是在校学生，请加我为好友，可申请半价返现（仅限在周刊前100期订阅有效）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;除此之外，我还开通了合伙人计划，当有人通过你分享的海报或者链接，购买了专栏，那么你将获得 &lt;strong&gt;50%&lt;/strong&gt; 的返利。&lt;/div&gt;
&lt;div&gt;如何分享？在专栏里找到分享按钮，生成海报或复制链接即可。如下图所示：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;专栏目前是试运行期间的最低价，过几天发布第 50 期时会涨价，所以现在加入，最为划算。我们支持 24 小时无理由退款。&lt;/div&gt;
&lt;div&gt;为了感谢大家的支持，我会从 &lt;a href=&quot;https://mp.weixin.qq.com/s/SQgRvYAHb-JNLn1kSMgjaQ&quot;&gt;Python猫&lt;/a&gt; 公众号里本文的精选留言中选出 &lt;strong&gt;5 位幸运儿&lt;/strong&gt;，各免费赠送一年的专栏订阅福利。&lt;/div&gt;
&lt;div&gt;欢迎大家来提出建议、提出问题、分享优质信息源、以及任何有助于周刊专栏发展得更好的内容！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;更新：有些海外的同学表示不用/很少用微信，不便访问小报童。为了照顾这些朋友，我开通了&lt;a href=&quot;https://afdian.net/a/python_weekly&quot;&gt;爱发电&lt;/a&gt;，欢迎使用这个平台来订阅。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#49：谷歌裁员 Python 团队，微软开源 MS-DOS 4.0</title>
            <link>https://pythoncat.top/posts/2024-05-04-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-05-04-weekly/</guid>
            <description>谷歌裁员还未止息</description>
            <pubDate>Sat, 04 May 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;本周刊由 Python猫 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;本期周刊分享了 12 篇文章，12 个开源项目，2 则视频，赠书 5 本《Hello算法》&lt;/div&gt;
&lt;div&gt;全文 2500 字，以下是本期摘要：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🦄文章&amp;amp;教程&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① 谷歌在开发者大会前裁员了 Python、Flutter 和 Dart 团队&lt;/div&gt;
&lt;div&gt;② FastAPI 专家给出的 FastAPI 使用贴士&lt;/div&gt;
&lt;div&gt;③ PEP 686：将 UTF-8 模式设为默认配置&lt;/div&gt;
&lt;div&gt;④ Pydantic：简化 Python 中的数据验证&lt;/div&gt;
&lt;div&gt;⑤ 中小型 Python 项目配置和数据读写的最佳实践&lt;/div&gt;
&lt;div&gt;⑥ 为了乐趣和（并发的）收益而给 requests 库打补丁&lt;/div&gt;
&lt;div&gt;⑦ CPython JIT 内部原理：Python 启动时会发生什么？&lt;/div&gt;
&lt;div&gt;⑧ Sleepsort：在线程休眠时排序&lt;/div&gt;
&lt;div&gt;⑨ Python、JavaScript 和 Ruby 用莱布尼茨公式计算 π 的值&lt;/div&gt;
&lt;div&gt;⑩ 10 年参加 Python 会议&lt;/div&gt;
&lt;div&gt;⑪ 关于 for 循环的一些思考&lt;/div&gt;
&lt;div&gt;⑫ 前 1% 精英工程师的 7 个简单的习惯&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🐿️项目&amp;amp;资源&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① logfire：用于 Python 的可观测性工具&lt;/div&gt;
&lt;div&gt;② pyinfra：用 Python 实现基础设施自动化&lt;/div&gt;
&lt;div&gt;③ pipxu：使用 UV 在隔离环境中安装和运行 Python 程序&lt;/div&gt;
&lt;div&gt;④ tkforge：在 Figma 中拖放创建 Python GUI&lt;/div&gt;
&lt;div&gt;⑤ TagStudio：文件和照片管理系统&lt;/div&gt;
&lt;div&gt;⑥ coredumpy：保存崩溃的站点以作事后调试&lt;/div&gt;
&lt;div&gt;⑦ plane：开源的 JIRA、Linear 和 Asana 替代品&lt;/div&gt;
&lt;div&gt;⑧ Scrapegraph-ai：基于 AI 的 Python 抓取工具&lt;/div&gt;
&lt;div&gt;⑨ tv：自动收集 IPv4 酒店电视直播源&lt;/div&gt;
&lt;div&gt;⑩ netprobe_lite：用 Python 开发的网络性能测试工具&lt;/div&gt;
&lt;div&gt;⑪ dangerzone：将有害的 PDF、office 文档或图像转换为安全的 PDF&lt;/div&gt;
&lt;div&gt;⑫ MS-DOS：MS-DOS 1.25、2.0 和 4.0 的源代码&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;🐢播客&amp;amp;视频&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① 2023 年的 800 多期 Python 演讲视频&lt;/div&gt;
&lt;div&gt;② 教程：使用 Python + HTMX + Tailwind 作 Web 开发&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;如今大环境依然不好，有些人经历了裁员，有些人虽还在岗却天天焦虑，于是就出现了一种趋势，就是卷学习，让自己更有竞争力。&lt;/div&gt;
&lt;div&gt;Python潮流周刊从 2023 年 5 月连载至今，已更新超过 10 万字，每期内容都十分丰富，是绝对不容错过的学习资料。我们的愿景是帮助所有读者精进 Python 技术，拓宽职业发展道路。&lt;/div&gt;
&lt;div&gt;目前周刊实行付费订阅制，年费 128 元，平均每天不到 4 毛钱，但绝对是一笔有眼光的投资。花钱学习知识，花钱提升自己，这买卖绝对不亏，欢迎订阅这个：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;你绝对不会后悔的专栏&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;订阅后，可免费查看 &lt;a href=&quot;https://xiaobot.net/post/83bc7d50-7403-4c33-b2b7-b90b10a8bae5&quot;&gt;第 49 期周刊的全文&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#48：Python 3.14 的发布计划</title>
            <link>https://pythoncat.top/posts/2024-04-27-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-04-27-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，11 个开源项目，赠书 5 本《图解TCP/IP（第6版）》</description>
            <pubDate>Sat, 27 Apr 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;本周刊由 Python猫 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;本期周刊分享了 12 篇文章，11 个开源项目，赠书 5 本《图解TCP/IP（第6版）》&lt;/div&gt;
&lt;div&gt;以下是本期摘要：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;🦄文章&amp;amp;教程&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① 公布 py2wasm：将 Python 程序转换为 Wasm&lt;/div&gt;
&lt;div&gt;② 对比 Ruby 与 Python 的 for 循环&lt;/div&gt;
&lt;div&gt;③ Python 小陷阱：strip、lstrip、rstrip 删除内容比预期的多&lt;/div&gt;
&lt;div&gt;④ 用 Python 讲解进程间通信的核心机制&lt;/div&gt;
&lt;div&gt;⑤ PEP 745 – Python 3.14 的发布计划&lt;/div&gt;
&lt;div&gt;⑥ Python 不同数据结构的时间复杂度&lt;/div&gt;
&lt;div&gt;⑦ 从第一性原理出发理解 Django&lt;/div&gt;
&lt;div&gt;⑧ Python 线程池的源码实现分析与相关问题探讨&lt;/div&gt;
&lt;div&gt;⑨ 如何用 Python 设计和实现插件架构？&lt;/div&gt;
&lt;div&gt;⑩ 浅谈 Python、Go、Rust 的异常处理&lt;/div&gt;
&lt;div&gt;⑪ mpmetrics 内存管理的设计&lt;/div&gt;
&lt;div&gt;⑫ 编程语言中分号的起源和优点&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;🐿️项目&amp;amp;资源&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① llama3：Meta Llama 3 的官方仓库&lt;/div&gt;
&lt;div&gt;② llama3-Chinese-chat：Llama3 中文仓库，各种聚合资料&lt;/div&gt;
&lt;div&gt;③ reader：将 URL 转换为对 LLM 友好的文本&lt;/div&gt;
&lt;div&gt;④ tasktiger：基于 Redis 的 Python 任务队列&lt;/div&gt;
&lt;div&gt;⑤ utt：用 Python 编写的简易命令行时间跟踪器&lt;/div&gt;
&lt;div&gt;⑥ simone：将 YouTube 视频转换为文章进行发布&lt;/div&gt;
&lt;div&gt;⑦ h11：用纯 Python 实现的 HTTP/1.1 库&lt;/div&gt;
&lt;div&gt;⑧ browser-hub：浏览器包装器，可运行多个浏览器实例&lt;/div&gt;
&lt;div&gt;⑨ lingua-py：极准确的自然语言检测库&lt;/div&gt;
&lt;div&gt;⑩ photo-similarity-search：基于苹果芯片的照片相似度 Web 应用&lt;/div&gt;
&lt;div&gt;⑪ Windrecorder：记录屏幕内容，实现记忆搜索&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;如今大环境依然不好，有些人经历了裁员，有些人虽还在岗却天天焦虑，于是就出现了一种趋势，就是卷学习，让自己更有竞争力。&lt;/div&gt;
&lt;div&gt;Python潮流周刊从 2023 年 5 月连载至今，已更新超过 10 万字，每期内容都十分丰富，是绝对不容错过的学习资料。我们的愿景是帮助所有读者精进 Python 技术，拓宽职业发展道路。&lt;/div&gt;
&lt;div&gt;目前周刊实行付费订阅制，年费 128 元，平均每天不到 4 毛钱，但绝对是一笔有眼光的投资。花钱学习知识，花钱提升自己，这买卖绝对不亏，欢迎订阅这个：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;你绝对不会后悔的专栏&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;订阅后，可免费查看 &lt;a href=&quot;https://xiaobot.net/post/630a4d3c-500c-4486-b51c-4f1e8231375c&quot;&gt;第 48 期周刊的全文&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#47：当你的老师希望你去做开源</title>
            <link>https://pythoncat.top/posts/2024-04-20-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-04-20-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目，2 则音视频，赠书 5 本《Python编程：从入门到实践（第3版）》</description>
            <pubDate>Sat, 20 Apr 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;本周刊由 Python猫 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;以下是本期摘要：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;🦄文章&amp;amp;教程&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① 当你的老师希望你去做开源&lt;/div&gt;
&lt;div&gt;② 我每天在用的 Python f-string 代码&lt;/div&gt;
&lt;div&gt;③ 用 Django 和 OpenAI 开发一款语音笔记应用&lt;/div&gt;
&lt;div&gt;④ Python Web 开发者的最佳安全实践&lt;/div&gt;
&lt;div&gt;⑤ Fedora 希望为其 Python 构建作“-O3”优化&lt;/div&gt;
&lt;div&gt;⑥ Ruff v0.4.0：一个手写的 Python 递归下降解析器&lt;/div&gt;
&lt;div&gt;⑦ 给 Django RSS 源设置样式&lt;/div&gt;
&lt;div&gt;⑧ Python 中快捷的概率过滤器&lt;/div&gt;
&lt;div&gt;⑨ Code Review 时，曾被我忽视的 3 件重要小事&lt;/div&gt;
&lt;div&gt;⑩ 用 Python 记录下今天敲了多少次键盘&lt;/div&gt;
&lt;div&gt;⑪ 是否应该使用上界版本约束？&lt;/div&gt;
&lt;div&gt;⑫ 如何开发一个代码格式化工具？&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;🐿️项目&amp;amp;资源&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① pylyzer：快速的 Python 静态代码分析器和语言服务器&lt;/div&gt;
&lt;div&gt;② anthropic-cookbook：一些有趣而有效的使用 Claude 的方法&lt;/div&gt;
&lt;div&gt;③ Flowmium：用 Rust 写的 Python 工作流编排器&lt;/div&gt;
&lt;div&gt;④ github2file：从 Github 下载和处理文件&lt;/div&gt;
&lt;div&gt;⑤ Python 知识备忘录&lt;/div&gt;
&lt;div&gt;⑥ DouZero：通过自玩深度强化学习掌握斗地主&lt;/div&gt;
&lt;div&gt;⑦ dashboard-icons：仪表板图标资源&lt;/div&gt;
&lt;div&gt;⑧ newspaper4k：从新闻网站提取文章、标题和元数据&lt;/div&gt;
&lt;div&gt;⑨ translateLocally：在本机上用 LLM 快速安全地翻译&lt;/div&gt;
&lt;div&gt;⑩ constable：将打印直接插入 AST 进行状态调试&lt;/div&gt;
&lt;div&gt;⑪ TextBlob：情感分析、词性标记、名词短语提取、翻译等&lt;/div&gt;
&lt;div&gt;⑫ wewe-rss：生成微信公众号 RSS，支持私有化部署&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;🐢播客&amp;amp;视频&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;① 2024 年菲律宾 PyCon 演讲视频列表&lt;/div&gt;
&lt;div&gt;② 2024 年构建大语言模型的小指南&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;如今大环境依然不好，有些人经历了裁员，有些人虽还在岗却天天焦虑，于是就出现了一种趋势，就是卷学习，让自己更有竞争力。&lt;/div&gt;
&lt;div&gt;Python潮流周刊从 2023 年 5 月连载至今，已更新超过 10 万字，每期内容都十分丰富，是绝对不容错过的学习资料。我们的愿景是帮助所有读者精进 Python 技术，拓宽职业发展道路。&lt;/div&gt;
&lt;div&gt;目前周刊实行付费订阅制，年费 128 元，平均每天不到 4 毛钱，但绝对是一笔有眼光的投资。花钱学习知识，花钱提升自己，这买卖绝对不亏，欢迎订阅这个：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;你绝对不会后悔的专栏&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;订阅后，可免费查看 &lt;a href=&quot;https://xiaobot.net/post/59d89f40-2a84-40da-84fc-23d085210c23&quot;&gt;第 47 期周刊的全文&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>xxx，一个神奇的 Python 库</title>
            <link>https://pythoncat.top/posts/2024-04-17-comment/</link>
            <guid>https://pythoncat.top/posts/2024-04-17-comment/</guid>
            <description>分享一个挺有意思的现象，可能会引起争议，欢迎你来留言（公众号也支持留言啦！）</description>
            <pubDate>Wed, 17 Apr 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;前几天，我在《&lt;a href=&quot;https://mp.weixin.qq.com/s/YGW0ySLo4WgniDZxiHga1Q&quot;&gt;技术周刊的转变：如何平衡热爱与现实？&lt;/a&gt;》一文里写过国内 Python 自媒体圈在近几年的两个现象（仅个人观感，无科学数据支撑）：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Python 广告投放出现断崖式萎缩&lt;/li&gt;
&lt;li&gt;Python 大号出现很多改名/转行&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;本文想继续分享我观察到的另一个挺有意思的现象。如果你能从中受到一些启发，进而为自己找到一些事情做，那我真心会为你高兴。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;特别声明，本文只是在分享一个行业观察，在描述一种现象趋势，请不要对号入座，不要断章取义，也不要以偏概全！！！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;不知道你最近是否读过类似下面标题的文章：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;xxx，一个神奇的 Python 库&lt;/li&gt;
&lt;li&gt;xxx，一个超酷的 Python 库&lt;/li&gt;
&lt;li&gt;xxx，一个实用的 Python 库&lt;/li&gt;
&lt;li&gt;xxx，一个无敌的 Python 库&lt;/li&gt;
&lt;li&gt;xxx，一个强大的 Python 库&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;其中，“xxx”可能是很知名的库，也可能是比较小众，总之取材范围很广。&lt;/div&gt;
&lt;div&gt;标题中的形容词还可能是“超强的”、“超有用的”、“超神奇的”、“化腐朽为神奇的”，等等等，总之用词大多简短而夸张，传达出强烈的情感色彩。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;以上这些形容词出现频率很高，看多了可能引起视觉疲劳。有一个作者另辟蹊径，用词就比较有文采了：“妙手回春的”、“让你健步如飞的”、“三界通吃的”、“决胜千里的”、“让你为所欲为的”……&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这么起名标题的公众号不少，绝大部分都是陌生面孔，它们有以下的特征：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;基本上注册时间都超过 4 年，近一年左右开始发这类文章&lt;/li&gt;
&lt;li&gt;文章更新频率高，文章格式有较高相似度（毕竟都是在介绍某个库）&lt;/li&gt;
&lt;li&gt;文章阅读量不算低，超过 1 万阅读的有不少&lt;/li&gt;
&lt;li&gt;大概率有用 AI 辅助写作或翻译&lt;/li&gt;
&lt;li&gt;发文主要目的可能是为获取微信的流量主广告费&lt;/li&gt;
&lt;li&gt;出乎意料的是，某些次条擦边内容可能有超高阅读&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;我并不是这些文章的目标读者，老读者应该能从我过往发布的文章以及每期周刊的选材，看出我的阅读偏好完全不同。我之所以会关注到它们，是因为在朋友圈和群里都看到过转发，以及在搜索材料时也看到了。&lt;/div&gt;
&lt;div&gt;这些文章取标题的套路方式当然是值得批判的，相互的借鉴行为也不值得推崇。&lt;/div&gt;
&lt;div&gt;不过，或许是因为我的 Python 文章阅读量够多，我似乎获得了某种程度的阅读免疫力，因此能够较为冷静地看到这些标题党文章好像也有一些可借鉴之处。&lt;/div&gt;
&lt;div&gt;看待事情时往积极的方面想，自然容易得到一些正面的认知。&lt;/div&gt;
&lt;div&gt;我的几点收获/思考：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;利用 AI 提升写作效率，利用公众号平台的推荐机制赚取一些零花钱，这已被证明是完全可行的&lt;/li&gt;
&lt;li&gt;微信的推荐流量有比较难测的规则，但真被推荐的话，流量给得很大方，这对新起步的作者是一种公平照顾&lt;/li&gt;
&lt;li&gt;高阅读量说明感兴趣的读者多，而兴趣是最好的老师，能帮助读者开启或坚持学习，善莫大焉&lt;/li&gt;
&lt;li&gt;文章的积极作用是普及了知识，标题夸张但内容无大问题，填补了上一代 Python 技术号沉寂而留出的一些科普者生态位&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;说完了这些可借鉴之处，我还有一个建议，建议这些文章的作者（以及其他激起了写作念头的朋友）：不要都集中去写 xxx Python 库了，应该拓宽题材，比如做几个同类库的测评、围绕某个领域去写成专题系列、找优质文章翻译成中文、写 Python 书籍推荐……&lt;/div&gt;
&lt;div&gt;最后，宣告一个好消息：&lt;strong&gt;Python猫 公众号终于也有留言功能了！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;欢迎大家前来留言，可以说说你是怎么看文中提到的 Python 自媒体现象的？&lt;/div&gt;
&lt;div&gt;留言入口：公众号的这篇同名文章&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;以上是今天的分享，最后推荐一下我的《Python潮流周刊》专栏。这是一个专为国内 Python 开发者量身打造的资讯平台，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>正则表达式中 “$” 并不是表示 “字符串结束”</title>
            <link>https://pythoncat.top/posts/2024-04-15-re/</link>
            <guid>https://pythoncat.top/posts/2024-04-15-re/</guid>
            <description>如何匹配到字符串结尾？字符串末尾的换行符有什么影响？</description>
            <pubDate>Mon, 15 Apr 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;作者：Seth Larson&lt;/div&gt;
&lt;div&gt;译者：豌豆花下猫@Python猫&lt;/div&gt;
&lt;div&gt;英文：&lt;a href=&quot;https://sethmlarson.dev/regex-$-matches-end-of-string-or-newline&quot;&gt;Regex character “$” doesn’t mean “end-of-string”&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;转载请保留作者及&lt;a href=&quot;https://pythoncat.top&quot;&gt;译者信息&lt;/a&gt;！&lt;/div&gt;
&lt;div&gt;这篇文章写一写我最近在用 Python 的正则表达式模块（&lt;code&gt;re&lt;/code&gt;）开发 CPython 的 SBOM 工具时发现的一个令人惊讶的行为。&lt;/div&gt;
&lt;div&gt;如果用过正则表达式，你可能知道 &lt;code&gt;^&lt;/code&gt; 表示 “字符串开始”，并相应地将 &lt;code&gt;$&lt;/code&gt; 视为 “字符串结束”。因此认为， &lt;code&gt;cat$&lt;/code&gt; 模式会匹配字符串 &lt;code&gt;&quot;lolcat&quot;&lt;/code&gt; ，但不会匹配 &lt;code&gt;&quot;internet cat video&quot;&lt;/code&gt;。&lt;/div&gt;
&lt;div&gt;&lt;code&gt;^&lt;/code&gt; 的行为让我认为 &lt;code&gt;$&lt;/code&gt; 也是类似的，但这并不一定成立，而且这种行为取决于不同编程语言及其写法。&lt;/div&gt;
&lt;div&gt;特别是对于 Python 来说，如果禁用了多行模式（这是默认设置），那么，&lt;code&gt;$&lt;/code&gt; 字符不仅可以匹配字符串的末尾，还可以匹配字符串末尾的换行符。&lt;/div&gt;
&lt;div&gt;所以，如果你试图匹配一个末尾没有换行符的字符串，在 Python 中使用 &lt;code&gt;$&lt;/code&gt; 是做不到的！我本以为禁用多行模式后，就不会有这种匹配换行符的行为，但事实恰恰相反。&lt;/div&gt;
&lt;div&gt;下一个合乎逻辑的问题是，&lt;strong&gt;如何在 Python 中匹配一个末尾不含换行符的字符串？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;在对 &lt;a href=&quot;https://docs.python.org/3/library/re.html#regular-expression-syntax&quot;&gt;Python&lt;/a&gt; 和&lt;a href=&quot;https://www.regular-expressions.info/anchors.html&quot;&gt;其它正则表达式语法&lt;/a&gt;进行多番研究后，我还发现了 &lt;code&gt;\z&lt;/code&gt; 和 &lt;code&gt;\Z&lt;/code&gt; 可以用于匹配 “字符串结束” 字符。&lt;/div&gt;
&lt;div&gt;在 Python 中，可以用 &lt;a href=&quot;https://docs.python.org/3/library/re.html#re.MULTILINE&quot;&gt;&lt;code&gt;re.MULTILINE&lt;/code&gt;&lt;/a&gt; 来启用多行模式，文档的描述如下：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;当指定 &lt;code&gt;re.MULTILINE&lt;/code&gt; 时，模式字符 &lt;code&gt;&apos;$&apos;&lt;/code&gt; 会匹配字符串末尾以及每一行末尾（包含换行符）。默认情况下，’$’ 只匹配字符串末尾以及字符串末尾的换行符之前（如果有的话）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;让我们看看这些特性在不同平台上是什么表现：&lt;/div&gt;





























































&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;模式匹配 “cat\n”？&lt;/th&gt;&lt;th&gt;“cat$” 多行模式&lt;/th&gt;&lt;th&gt;“cat$” 无多行模式&lt;/th&gt;&lt;th&gt;“cat\z”&lt;/th&gt;&lt;th&gt;“cat\Z”&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;PHP&lt;/td&gt;&lt;td&gt;✅&lt;/td&gt;&lt;td&gt;✅&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;✅&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ECMAScript&lt;/td&gt;&lt;td&gt;✅&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;⚠️&lt;/td&gt;&lt;td&gt;⚠️&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Python&lt;/td&gt;&lt;td&gt;✅&lt;/td&gt;&lt;td&gt;✅&lt;/td&gt;&lt;td&gt;⚠️&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Golang&lt;/td&gt;&lt;td&gt;✅&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;⚠️&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Java 8&lt;/td&gt;&lt;td&gt;✅&lt;/td&gt;&lt;td&gt;✅&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;✅&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;.NET 7.0&lt;/td&gt;&lt;td&gt;✅&lt;/td&gt;&lt;td&gt;✅&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;✅&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Rust&lt;/td&gt;&lt;td&gt;✅&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;❌&lt;/td&gt;&lt;td&gt;⚠️&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;✅: 模式与字符串 &lt;code&gt;&quot;cat\n&quot;&lt;/code&gt; 匹配&lt;/li&gt;
&lt;li&gt;❌: 模式与字符串 &lt;code&gt;&quot;cat\n&quot;&lt;/code&gt; 不匹配&lt;/li&gt;
&lt;li&gt;⚠️: 模式无效或不支持该用法&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;综合上述表格，如果要匹配换行符，那么在所有语言中使用多行模式的 &lt;code&gt;$&lt;/code&gt; ，都能匹配成功；但如果不想匹配换行符，事情就会变得复杂起来。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;如果不想匹配换行符，在除了 Python 和 ECMAScript 外的其它语言中，你可以使用 &lt;code&gt;\z&lt;/code&gt;。而在 Python 中，你需要使用 &lt;code&gt;\Z&lt;/code&gt; ，在 ECMAScript 中使用非多行模式的 &lt;code&gt;$&lt;/code&gt;。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;今天这些关于正则表达式的知识，你学会了么？&lt;/div&gt;
&lt;div&gt;注意：上述数据表的信息收集自 &lt;a href=&quot;https://regex101.com/&quot;&gt;regex101.com&lt;/a&gt;，我没有用实际的编程环境进行测试。&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;以上是今天的分享，最后推荐一下我的《Python潮流周刊》专栏。这是一个专为国内 Python 开发者量身打造的资讯平台，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>技术周刊的转变：如何平衡热爱与现实？</title>
            <link>https://pythoncat.top/posts/2024-04-14-paid-column/</link>
            <guid>https://pythoncat.top/posts/2024-04-14-paid-column/</guid>
            <description>聊聊周刊为什么推出付费专栏，以及今后的发展计划</description>
            <pubDate>Sun, 14 Apr 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;大家好，我是那个自己打脸自己的猫哥，本来说周刊不做订阅制的，现在却推出了订阅专栏。今天想为自己辩护一下，同时聊聊技术周刊今后的发展计划。&lt;/div&gt;
&lt;div&gt;首先回顾一下我过去的想法吧，然后再解释为什么会突然出现转变。&lt;/div&gt;
&lt;div&gt;出于对 Python 的热爱以及对国外几个 Python 周刊的效仿，我从一年前开始连载《Python潮流周刊》。在这段时间里，我一直有把商业变现放在心上，只不过它的优先级并没有太靠前。&lt;/div&gt;
&lt;div&gt;我一边想着先把内容做好先积攒影响力，一边看着几份英文 Python 周刊的变现模式而盲目乐观着。&lt;/div&gt;
&lt;div&gt;在发布第 30 期之前，我侥幸接到了一两期商业赞助，那时我得意以为终于要熬出头了，终于可以像那些英文周刊一样，用“免费+品牌赞助”的方式运营了。&lt;/div&gt;
&lt;div&gt;于是意气风发地写了一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/gplCsGO5R8kY_nF8Pd7iXg&quot;&gt;聊聊技术周刊的变现&lt;/a&gt;》，那时的我完全没有意识到下面的话是多么的理想主义：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;我比较在意的回报有两类，而且希望能同时得到，&lt;strong&gt;一类是关注量、阅读量、star 数、点赞量等等数据带来的精神鼓舞，另一类是广告/恰饭带来的实实在在的金钱。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回到周刊变现的话题，因为第一类回报，所以我不打算做私密性周刊，不打算用订阅制，不打算收会员费；因为第二类回报，所以我会坚持探索挣钱之道。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;以上说法归结起来其实就是：&lt;strong&gt;我不想向读者收费，只想向广告主收费。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;如果我的读者群体已经很大了，如果每期阅读量都稳定很高了，比如像《科技爱好者周刊》和《HelloGithub》那样，这条路也许会顺畅很多。&lt;/div&gt;
&lt;div&gt;但现实是，Python 编程在国内的受众还是偏少，能关注到 Python猫的也不算多，而最近两三年来，Python 类广告投放也出现了断崖式萎缩。&lt;/div&gt;
&lt;div&gt;或许因为我的内容太过垂直于 Python 领域，导致其它技术方向的广告主望而却步了，同时又因为不够垂直于爬虫/数据分析/AI等几个热门的培训班方向，也导致了没有进入其它广告主的法眼。&lt;/div&gt;
&lt;div&gt;再考虑周刊内的品牌赞助，我也曾主动联系过自己所知有限的几家金主，结果是没有结果。在文章中植入品牌赞助的方式，国内的接受度还是太低了，除了头部的《科技爱好者周刊》能经常接到广告，其它周刊几乎都在用爱发电。&lt;/div&gt;
&lt;div&gt;我突然开始怀念起“开课吧”、“万门大学”和“奈学教育”还没倒下的日子，在行情最好的时候，我们这个毫不起眼的脚部自媒体的广告档期甚至曾被预约到下下个月。&lt;/div&gt;
&lt;div&gt;关于 Python 技术号如今的接广告难题，有一个现象特别能说明问题。&lt;/div&gt;
&lt;div&gt;大约在 2020-2021 年，出现了很多 Python 公众号，经常有组车互推，相互投稿和转载，我那时写得不错的文章通常能被转载 30 次以上。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;源源不断的广告激发起号主们的热情，驱动着 Python 自媒体圈的繁荣。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;然而，似乎是伴随着互联网圈的裁员潮，Python 圈也开始了节节退潮，越来越多的公众号从降低更新频率到长时间停更，原创不活跃了，转载也没动力了，甚至，有些号已经改名/转型其它方向了。&lt;/div&gt;
&lt;div&gt;最近半年里，就有 3 个体量比 Python猫 大得多的号在转型：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;而且就在我写这篇文章的时候，又有一个做得不错的垂直于 Django 开发的号宣布转型到 AI 方向。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;这并不是全部，也不会是结束。国内互联网的寒冬还在继续，Python 技术圈的春天也不会那么快到来。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;以上是想解释一件事，行业形势严峻，广告模式也变得艰难。我曾经惯性思维下的乐观设想，也许还得等很久，才能迎来下一轮经济爆发期。&lt;/div&gt;
&lt;div&gt;近一年里连续创作周刊，投入的大量时间和精力改变了我过去佛系运营的心态，促使我必须考虑金钱回报的问题，不能只做无偿公益了。&lt;/div&gt;
&lt;div&gt;另外还有一些家庭原因的考虑。我的小孩一天天长大目前将要一岁半了，妻子在怀孕期到现在都是无业状态，房贷和日常开销虽然没有让我们窘迫，但我必须考虑提升工资以外的收入了，无论是为了改善生活还是未雨绸缪。&lt;/div&gt;
&lt;div&gt;更无奈的是，无论我多么不想承认，无论我的长相和心态多么年轻，今年都是我的 35 岁。&lt;strong&gt;程序员职业发展的达摩克利斯之剑嗡嗡作响，未来的不确定性让人不得不产生焦虑。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;最近在 v2ex 和公众号里看到程序员被裁员的分享越来越多。字节的飞书在上个月也突然开启大规模裁员，我在某位失业博主的文章中读到了“&lt;strong&gt;时代的一粒灰，落在个人头上就是一座山，每个人都有被大山压垮的可能&lt;/strong&gt;”，感同身受！&lt;/div&gt;
&lt;div&gt;那位博主一直在大厂工作，也做了财务准备，一经对比，我发现自己啥也不是！在考虑我能做些什么的时候，第一个想到的自然是利用手上已有的资源和自己的优势。&lt;/div&gt;
&lt;div&gt;推出付费专栏是我的第一次尝试。我其实没有明确的规划，也缺乏完全转型的决心，如今试运行的模式只能算在初步摸索。&lt;/div&gt;
&lt;div&gt;周刊从一开始就是在多个平台同时免费发布，还打上了“开源”的旗号，如果突然完全转为封闭的收费模式，我会觉得太过违背初衷。毕竟脸皮薄，打起脸来是很疼的。&lt;/div&gt;
&lt;div&gt;我目前选择了在小报童发布专栏，最直接的好处是它能解决我在《&lt;a href=&quot;https://mp.weixin.qq.com/s/9-FCA-ha1OeBgSTkFBAYKg&quot;&gt;聊聊公众号最让我不爽的两个痛点&lt;/a&gt;》里吐槽的无法打开外链的问题，这对周刊类内容来说是极大利好。所以，今后在公众号基本不会再发周刊全文了，只发标题摘要。&lt;/div&gt;
&lt;div&gt;我打算在每次发布新一期周刊后，都将它设为免费，然后在发布下一期时再替换掉。每 30 期为一季的合集也是如此，即在发布第二季的合集前，&lt;a href=&quot;https://xiaobot.net/post/30e75294-1367-4604-ae6b-620adc78ef26&quot;&gt;第一季的合集&lt;/a&gt; 不会设为收费。&lt;/div&gt;
&lt;div&gt;我打算试运行几期，基本目标是达成 100 个全年订阅。如果完成情况太差，会考虑采用其它方式，目前没想好。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;（更新：目前采用的方式——付费期数将在其 50 期后免费，例如第 50 期将在第 100 期时免费）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;这或许不是一个很好的“商业模式”，但我想尝试一下，万事开头难，给自己一段时间试错。&lt;/div&gt;
&lt;div&gt;最后，我的专栏已开启「合伙人计划」，你可生成专属的邀请链接或海报，当有人通过你的邀请链接或海报订阅时，你将获得 50% 比例的返现。&lt;/div&gt;
&lt;div&gt;欢迎你订阅，也欢迎你邀请好友订阅！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#46：如何用 Python 预测日食的时间和轨迹？</title>
            <link>https://pythoncat.top/posts/2024-04-13-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-04-13-weekly/</guid>
            <description>本期周刊分享了 13 篇文章，12 个开源项目，2 则音视频，赠书 7 本</description>
            <pubDate>Sat, 13 Apr 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯，欢迎关注。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;特别提醒：&lt;/strong&gt; 本期周刊赠书 7 本《Python基础教程（第3版·修订版）》，详情见文末。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://erikbern.com/2024/04/07/predicting-solar-eclipses-with-python.html&quot;&gt;如何用 Python 预测日食的时间和轨迹？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;本周一（04.08）上演了今年唯一一次日全食，作者由此想到如何用编程方法预测日食发生的时间。文章分享了计算的技巧，绘制了本次日全食的轨迹，同时预测了 2020-2030 年间所有的日食。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://mathspp.com/blog/503-days-working-full-time-on-foss-lessons-learned&quot;&gt;我在开源软件上全职工作 503 天的经验分享&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者全职加入 Textualize 公司，参与了流行的 Python 库 Rich 和 Textual 的开发，文章主要分享了四个方面的经验：靠网络形象获得工作机会、你的自我不应该妨碍你的工作、如何与用户及贡献者互动、如何在完全陌生的大型代码库上开发。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.arjancodes.com/blog/best-practices-for-eliminating-python-code-smells/&quot;&gt;修复 Python 代码坏味道的最佳实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;代码坏味道（Code Smells）本身不是错误，但是会影响代码质量和可维护性。文章介绍了5 类常见的代码坏味道，以及修复这些问题的最佳实践。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://compucademy.net/prime-factorization-with-python/&quot;&gt;如何用 Python 作质因式分解？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了几种用 Python 作质因数分解的方法，从暴力解法到经典的埃拉托色尼筛法，重点介绍了后者的算法思路以及代码的优化方法。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://juejin.cn/post/7354406980784373798&quot;&gt;Supervisor-持久化进程部署方案&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Supervisor 是一个 C/S 架构的进程监控与管理工具，文章介绍了其基本用法和部分高级特性，用于解决部署持久化进程的稳定性问题（可克服&lt;code&gt;nohup cmd &amp;amp;&lt;/code&gt; 命令的弊端）。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://peps.python.org/pep-0744/&quot;&gt;PEP-744 – 关于 JIT 编译&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;JIT 编译器已经合入 CPython 3.13 主分支，这个最新发起的 PEP 旨在回答关于它的一些常见问题，主要目标是明确这个 JIT 应满足什么条件才能变为非实验性的特性。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://newsletter.systemdesign.one/p/zapier-architecture&quot;&gt;Zapier 如何能自动执行数十亿个任务？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Zapier 是流行的在线自动化平台，支持数千款 APP。文章介绍了 Zapier 采用的技术架构，包括用 Django 框架作后端，用 RabbitMQ 和 Celery 来创建分布式工作流引擎，用 Kafka 作分布式事件存储和流处理，等等。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://www.infoq.com/news/2024/04/meta-threads-instagram-5-months/&quot;&gt;Meta 使用单体架构仅 5 个月就发布了 Threads&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;去年的一大技术新闻是扎克伯格的 Meta 推出 Threads 与马斯克的 Twitter 竞争。Theads 的技术栈与 Instagram 几乎相同，大型单体架构，Django 框架改造的后端，数据存储在 TAO，用 ZippyDB 作缓存。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://compucademy.net/python-naming-conventions/&quot;&gt;Python 命名约定：最佳实践和示例&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 以其可读性和简单性而闻名，它有一些关于命名的规范，有助于保持代码一致性和清晰度。文章通过示例介绍了 Python 正确的命名风格，并给出了反例。（附：Google 内部专注于代码质量的“Code Health”系列，&lt;a href=&quot;https://testing.googleblog.com/2024/03/whats-in-name.html&quot;&gt;最新一篇&lt;/a&gt;分享了几条命名原则，有 Python 之禅的味道）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://posit-dev.github.io/great-tables/blog/design-philosophy&quot;&gt;Great_Tables 的设计理念&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章回顾了表格的历史（从古代的方格到高度结构化的数据格式），提出表格在当今面临的问题，介绍了如何通过&lt;code&gt;Great Tables&lt;/code&gt; 库创建更美观好用的表格。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://blog.dailydoseofds.com/p/how-python-prevents-us-from-adding&quot;&gt;Python 为什么不能将列表作为字典的键？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;若将列表作为字典的键，会报错&lt;code&gt;TypeError&lt;/code&gt; ，这是为什么呢？在这个过程中，Python 内部是如何执行的呢？文章解答了这个问题，原因跟&lt;code&gt;__hash__()&lt;/code&gt; 魔术方法有关。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://nathanielkaiser.xyz/treehousetemps.html&quot;&gt;使用树莓派+Python+Influxdb 开发温度监测器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者基于 Raspberry Pi 1b 和 DS18B20 温度探头开发了一个温度监测器，使用 Python 将温度数据传给 Influxdb，实现检测温度的变化。（根据文章开头描述，我推测作者现在应该只有11-12岁）&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://ivaniscoding.github.io/posts/codeinterview/&quot;&gt;如何用单行 Python 代码通过面试编码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这篇文章建议在做面试编程时，将答案写成一行代码的形式，文中给出了一些例子如反转二叉树、计算二叉树深度、查找第一个回文等题目，使用各种花销的技巧将代码写成一行。但是，注意文章发布的日期，它只是一个愚人节玩笑，不要当真！&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁每 30 期为一季，第一季的精华内容已整理成一篇，方便你随时查看。在线访问地址：&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;Python 潮流周刊第一季精华合集（1~30）&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/OpenInterpreter/open-interpreter&quot;&gt;open-interpreter：计算机上的自然语言界面&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它可让 LLM 在本地运行代码（Python、Javascript、Shell 等）。安装后运行 &lt;code&gt;$ interpreter&lt;/code&gt; ，即可以通过终端中类似 ChatGPT 的界面与 Open Interpreter 聊天。（star 47.1K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/MarcoGorelli/narwhals&quot;&gt;narwhals：Polars、pandas、cuDF、Modin 的轻量级可扩展兼容层&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;无缝支持 Polars、pandas、modin 和 cuDF，使用 Polars API 的子集，使用 Polars 的表达式，100% 分支覆盖率。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/PhonePe/mantis&quot;&gt;mantis：可自动发现、侦察和扫描漏洞的安全框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个自动扫描安全漏洞的命令行框架。输入顶级域名，它可发现相应的子域名和证书并进行侦察，然后对漏洞、机密、错误配置和网络钓鱼域名进行全面扫描。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/nashsu/FreeAskInternet&quot;&gt;FreeAskInternet：免费私有且本地运行的搜索聚合器与答案生成&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用户提出一个问题，它将用多个引擎搜索，并将搜索结果组合给 LLM，根据搜索结果生成答案。不需要 GPU 或 OpenAI 或 Google API 密钥，即完全免费。使用免费的 ChatGPT3.5 / Qwen / Kimi / ZhipuAI（GLM） API，支持 ollama，支持 Docker 部署。（star 6.6K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://blog.jetbrains.com/pycharm/2024/04/django-learning-resources/&quot;&gt;PyCharm 博客总结的一系列 Django 学习资源&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PyCharm 是最专业的 Python IDE，其官方博客经常发布技术文章，在 YouTube 上也经常发布视频。这篇文章汇聚了一些跟 Django 相关的文章和视频的学习资源。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/posit-dev/great-tables&quot;&gt;great-tables：用 Python 生成信息丰富的精美表格 &lt;/a&gt;&lt;/div&gt;
&lt;div&gt;前文分享了这个库的设计理念。它依照表格各部分而定义了一系列组件，支持灵活调整表格布局。使用  Pandas 或 Polars 的 DataFrame 数据作输入。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/blasty/JiaTansSSHAgent&quot;&gt;jiaTansSSHAgent：实现 XZ sshd 某些后门功能&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;最近有一则爆炸性新闻是“XZ 的后门事件”。这个项目用 Python 实现了部分后门功能，你可以通过 SSH 客户端来探索它们。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/ShayHill/docx2python&quot;&gt;docx2python：提取 docx 的页眉、页脚、文本、脚注、尾注、属性和图像&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它可以将 docx 文件的各项元素提取成 Python 对象，包括文本和图像，实现内容读取、插入、修改等功能。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/tech-shrimp/WechatMoments&quot;&gt;WechatMoments：微信朋友圈导出工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一款运行在 Windows 上的，能备份导出朋友圈为 html 的工具，可下载图片/视频永久保存，支持根据联系人和朋友圈时间进行过滤导出。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/AlexanderKoch-Koch/low_cost_robot&quot;&gt;low_cost_robot：超低成本实现机械臂&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;组装和控制一条机械臂，需要多少成本？这个项目给出的方案成本约 250 美元，且支持增加一条机械臂，总计 430 美元。使用 Dynamixel XL430 和 Dynamixel XL330 伺服电机。（star 2K）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/MerrimanInd/drawpyo&quot;&gt;drawpyo：用 Python 生成 Draw.io 图表&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Draw.io 是一个免费在线的图表工具，可创建流程图、组织结构图、UML 图、ER 图、网络图等。这个库支持创建、添加对象、设置样式等功能。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/drawdb-io/drawdb&quot;&gt;drawdb：免费直观的在线数据库设计工具和 SQL 生成器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;浏览器中的数据库实体关系 （DBER） 编辑器，可构建图表、导出 sql 脚本、自定义编辑器等，无需创建帐户。（star 4.3K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.youtube.com/watch?v=8JSiiPW4S0A&quot;&gt;使用 Django、Channels 和 HTMX  克隆一个流式 ChatGPT&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这则视频使用 Django、websockets 和 HTMX 克隆出一个 ChatGPT。每个功能被分解为一次提交，视频解释了代码作用并演示了效果。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.youtube.com/playlist?list=PLTsu3dft3CWiow7L7WrCd27ohlra_5PGH&quot;&gt;2024 年学习数据科学的系列视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个系列视频有 23 期，主要面向初学者入门数据科学，涵盖 Python 编程基础、数据分析、数据可视化、大数据、机器学习等话题。&lt;/div&gt;
&lt;h2&gt;🐢赠书福利&lt;/h2&gt;
&lt;div&gt;不定期的福利活动，本期赠书 &lt;strong&gt;7&lt;/strong&gt; 本《Python基础教程（第3版·修订版）》，开奖时间 &lt;strong&gt;4 月 19 日&lt;/strong&gt; 。请给 &lt;strong&gt;&lt;a href=&quot;https://img.pythoncat.top/pythoncat.png&quot;&gt;Python猫&lt;/a&gt;&lt;/strong&gt; 公众号发送数字“&lt;strong&gt;8046&lt;/strong&gt;”，获取抽奖小程序码。&lt;/div&gt;
&lt;div&gt;本书Python新手入门经典图书，涵盖了Python编程的方方面面。本书前半部分介绍了基础知识与概念：从安装Python、配置开发环境，到列表、元组、字符串、字典以及各种语句的基础知识，再到抽象、异常、方法、属性、迭代器等核心概念，Python与数据库、网络、C语言等工具结合使用，以及Python程序测试、打包、发布等知识。本书的后半部分，向读者详尽介绍了当下流行的多个Python项目的开发过程。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>聊聊公众号最让我不爽的两个痛点</title>
            <link>https://pythoncat.top/posts/2024-04-07-wechat/</link>
            <guid>https://pythoncat.top/posts/2024-04-07-wechat/</guid>
            <description>它不支持插入外链，且2018年3月后开通的不支持留言</description>
            <pubDate>Sun, 07 Apr 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;微信公众号最让我不爽的地方有两个，而且有很多人虽然也不爽，却不知道原因。&lt;/div&gt;
&lt;div&gt;本文想聊聊公众号的两个痛点，因为我经常收到私信问这两个问题，本文算是一次集中的回复吧。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;第一个不爽的点是公众号会屏蔽外链，导致无法正常跳转文字链接。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;这是什么意思呢？其实就是说在公众号文章里，你添加的文字超链接只能放微信平台内的链接，无法插入其它平台（比如个人博客、技术网站、其它社交媒体等等）的链接。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;由于时不时有读者问询，我前不久就把“公众号只能放内链”的事在朋友圈发了，竟然有很多人评论说根本不知道这回事！顿时感觉有个无形的信息茧房把我笼罩住了……&lt;/div&gt;
&lt;div&gt;在每周发布《Python潮流周刊》时，这个平台级限制迫使我要将所有外链处理为脚注。&lt;/div&gt;
&lt;div&gt;虽然有工具可以一键转换，操作上毫不费力，但是，每期周刊都有 40 个左右的外链，这一方面会导致文章末尾的“参考资料”部分非常冗长，另一方面是读者从正文的序号找内容链接也非常之不便。&lt;/div&gt;
&lt;div&gt;你或许想问：为什么不隐去链接脚注呢？这当然不好，因为周刊很重要的意图就是给出资讯来源，让读者能从信息的源头去阅读。&lt;/div&gt;
&lt;div&gt;你或许想问：为何不在“阅读原文”放其它平台的链接呢？没错，我就是这么做的，但是有多少人会去点击那藏在犄角旮旯里的“阅读原文”呢？&lt;/div&gt;
&lt;div&gt;最近，我在周刊开头位置加了博客版链接，如果你复制链接到浏览器访问，当然会获得无障碍的阅读体验，可是我怀疑这么做的人应该也不多吧？&lt;/div&gt;
&lt;div&gt;有人给我提议：可以在每则分享素材的下方放上链接啊！没错，这方法当然可行，友刊《HelloGithub》月刊就是这么干的。&lt;/div&gt;
&lt;div&gt;但是，我感觉这么操作并不适合放在我的周刊。一方面它是屈服于封闭型平台而作的折中方案，但周刊是以个人博客/Newsletter/Github等开放型平台为主要阵地的，我不想为此编辑出一个特供版本；另一方面是在正文里混杂链接会导致内容非常冗长，更不要提我经常在一则分享里添加多个链接和附注，我难以想象将链接分离在其下方会是怎样的车祸现场。&lt;/div&gt;
&lt;div&gt;还有好心人提议：有 xxx 小程序可以支持插入文字链接。没错，在写公众号的五年里，我至少见到过 3 个这类小程序了，但是，且不要提用它们操作时的麻烦，就说它们可能乱入的广告就不可接受，最最让人顾虑的还有一点，就是这类小程序到底能存活多久呢？&lt;/div&gt;
&lt;div&gt;因此，这个痛点目前无法很好消解。如果你也烦它，请访问我的个人博客阅读。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;接着聊聊第二个让人不爽的点吧：2018 年 3 月后开通的公众号不支持留言功能。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;这个点应该有更多的人是毫不知情的吧？但事实就是这样。而 Python猫 遗憾是在 2018 年 9 月注册的，只是相差了半年而已。&lt;/div&gt;
&lt;div&gt;没有留言功能，就缺了极其重要的读者互动方式。有时候想搞搞“留言赠书”来送福利，做不到。有时候想为正文补充一段注释，也做不到。&lt;/div&gt;
&lt;div&gt;你或许想问：为什么会有这样的情况？抱歉，我同样很费解，同样不知道缘由。&lt;/div&gt;
&lt;div&gt;公众号里可以添加“快捷私信”，也就是你在文章最最底部看到的“发消息”。但是，这里发送的只是普通私信，只有号主能看到和回复，不能像留言功能那样可以精选、可以多轮对话、可以公开给所有读者。&lt;/div&gt;
&lt;div&gt;你或许想说：有 xxx 小程序可以支持留言功能。没错，我也见到过几个，但是我也不会考虑，理由跟前文一样。&lt;/div&gt;
&lt;div&gt;你或许想说：可以去做公众号迁移啊，很多新的公众号都是这样获得留言功能的。&lt;/div&gt;
&lt;div&gt;确实可以，我知道这么做的号就有不少。但是，我有几点考虑：一是我完全不想去注册公司（包括找人代办），二是会导致现账号的数据丢失，三是我就想坚持等到平台正常开放留言功能。&lt;/div&gt;
&lt;div&gt;大概从半年前开始，我已经看到好几个号主分享说他们的号支持留言了，包括隔壁的“古明地觉的编程教室”。&lt;/div&gt;
&lt;div&gt;公众号似乎在悄悄的开放留言功能！但是，它到底会给哪些号开通，会开通多少呢？&lt;/div&gt;
&lt;div&gt;这我属实是丈二和尚摸不着头脑了：明明有的号开通得比 Python猫 晚，但它们却有了留言；明明有的号只是一个人的多个小号，但它们却有了留言；明明有的号已经很久不更新了，却也有了留言……&lt;/div&gt;
&lt;div&gt;我也许要晚人一步了，也可能是晚两步、三步吧，唉。&lt;/div&gt;
&lt;div&gt;也许等真的支持留言了，我会很尴尬地收不到任何留言，就像经常性放了赞赏却没有收获一样，但是，也正像时不时能收到一则赞赏和鼓励性的悄悄话一样，谁说就没有读者会来留下一些积极的鼓舞人心的话呢？&lt;/div&gt;
&lt;div&gt;我期待这一天能早点到来！&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#45：越来越多的 AI 自动开发框架</title>
            <link>https://pythoncat.top/posts/2024-04-06-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-04-06-weekly/</guid>
            <description>本期周刊分享了 13 篇文章，11 个开源项目，2 则音视频</description>
            <pubDate>Sat, 06 Apr 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯，欢迎关注。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;特别提醒：&lt;/strong&gt; 本期周刊赠书 5 本《Python语言及其应用（第2版）》，详情见文末。&lt;/div&gt;
&lt;h2&gt;🐱品牌合作&lt;/h2&gt;
&lt;div&gt;本周刊由公众号“&lt;strong&gt;Python猫&lt;/strong&gt;”出品，这是一个以 Python 技术科普和分享为主的科技自媒体，全网订阅读者数 50000+，品牌合作请私信联系。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://arxiv.org/html/2403.08299v1&quot;&gt;AutoDev：微软发布的自动化 AI 驱动开发框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;微软总部发布的研究论文，介绍了 AutoDev 框架，它使 AI 代理能够自主地编写代码、测试、构建和操作 Git 等，使用 Docker 确保开发环境的安全，并可通过配置来限制 AI 代理的权限和操作。在 HumanEval 数据集上取得了 91.5% 的代码生成准确率和 87.8% 的测试生成准确率。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.david-dahan.com/blog/10-reasons-i-stick-to-django&quot;&gt;我坚持用 Django 而不是 FastAPI 的 10 个原因&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;FastAPI 越来越流行，但是作者还坚持用 Django，文章简短介绍了 10 个原因。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://fly.io/django-beats/asgi-deployment-options-for-django&quot;&gt;Django 与 ASGI 服务器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;ASGI 是异步服务器网关接口规范，允许异步服务器与 Web 应用框架进行通信。文章介绍了几种流行的 ASGI 服务器（Daphne、Uvicorn、Hypercorn 及 Granian），比较了它们的性能和特性，同时给出了如何选择合适的 ASGI 服务器的建议。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://blog.trl.sn/blog/what-is-a-json-number/&quot;&gt;JSON 中的数字到底是什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;JSON 有两个主要的标准定义（Ecma-404 和 RFC-8259），然而现实的各种编程语言和 JSON 库在处理数字的精度和范围时，却存在诸多差异。文章对此作了一些对比和总结。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://codeconfessions.substack.com/p/why-do-python-lists-multiply-oddly&quot;&gt;CPython 源码解析：为什么 Python 列表相乘的结果那么奇怪？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 的列表支持乘法操作，如&lt;code&gt;[[]]*4&lt;/code&gt; ，将得到&lt;code&gt;[[],[],[],[]]&lt;/code&gt; ，但是，这个例子中复制出的 4 个列表只是对同一个对象的引用。文章深入解析 CPython 源码，介绍了列表对象的结构及其内部对象存储机制、星号运算符的实现原理、CPython 具体如何执行列表的乘法操作。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://juejin.cn/column/7352789840351887369&quot;&gt;Celery 源码分析系列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Celery 是 Python 中常用的分布式任务队列库，这个系列文章已更新 9 篇，深入介绍它的基础架构、Worker 启动、重要组件、生命周期、定时任务等等内容。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://outlore.dev/blog/python-dev-2024/&quot;&gt;我在 2024 年如何管理 Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者介绍了自己最新在用的技术栈：用&lt;code&gt;mise&lt;/code&gt; 作 Python 版本和虚拟环境管理、&lt;code&gt;poetry&lt;/code&gt; 或 &lt;code&gt;uv&lt;/code&gt; 作依赖管理、 &lt;code&gt;ruff&lt;/code&gt; 作格式化和 linting，以及 &lt;code&gt;pydantic&lt;/code&gt; 作运行时检查。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://blog.cloudflare.com/python-workers&quot;&gt;使用 Pyodide 和 WebAssembly 将 Python 引入 Cloudflare Workers&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;本周意义重大的一则消息：&lt;strong&gt;Cloudflare 支持用 Python 编写 Workers&lt;/strong&gt;！此举将扩展 Cloudflare 平台的功能，将推动无服务器计算及在浏览器中运行 Python 代码。该功能目前为公测阶段，期待后续的发展。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://austinhenley.com/blog/learningwithai.html&quot;&gt;学习使用和不使用 AI 编码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章提出两个基本问题：AI 代码生成工具对编程入门的新手有什么影响？新手如何在入门编程时使用 AI 代码生成工具？文章介绍了两篇论文的研究结果。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://www.editframe.com/guides/easy-video-transcription-and-subtitling-with-whisper-ffmpeg-and-python&quot;&gt;使用 Whisper、FFmpeg 和 Python 轻松转录视频并添加字幕&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这篇教程介绍了如何用 OpenAI 的 Whisper 模型转录视频，并使用强大的 FFmpeg 工具轻松添加字幕。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://medium.com/data-analytics-at-nesta/how-to-use-github-actions-to-automate-data-scraping-299690cd8bdb&quot;&gt;如何用 GitHub Actions 自动执行数据爬取？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍如何使用 GitHub Actions 的定时功能自动执行数据爬取任务，介绍了 GitHub Actions 的工作原理及几个使用限制。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://www.mostlypython.com/using-breakpoints-to-explore-your-code/&quot;&gt;使用断点调试 Python 代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍如何使用断点来调试和观察代码的执行过程，主要介绍了&lt;code&gt;pdb&lt;/code&gt; 模块的 breakpoint() 方法的使用。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://lwn.net/Articles/964839/&quot;&gt;Python “真正的”匿名函数&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 支持使用&lt;code&gt;lambda&lt;/code&gt; 表达式创建匿名函数，但只支持单个表达式。社区中总是有人提出要支持更灵活的匿名函数，今年又有了，文章介绍了提议者的观点以及相反的观点。（附：&lt;a href=&quot;https://pythoncat.top/posts/2020-09-20-lambda&quot;&gt;Python 之父为什么嫌弃 lambda 匿名函数？&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁每 30 期为一季，第一季的精华内容已整理成一篇，方便你随时查看。在线访问地址：&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;Python 潮流周刊第一季精华合集（1~30）&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/OpenDevin/OpenDevin&quot;&gt;OpenDevin：Devin 的开源实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;开源的 AI 软件工程师，利用了 shell、代码编辑器和 Web 浏览器等工具，充分发挥 LLMs 在软件开发中的潜力。（star 18.4K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/princeton-nlp/SWE-agent&quot;&gt;SWE-agent：可修复 Github 问题的 AI 软件工程师&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;普林斯顿大学推出的 AI 工程师，在 SWE-bench 测试中修复了 12.29% 问题，成绩接近 Devin。（star 6.6K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/wandb/openui&quot;&gt;openui：描述你想要的 UI，它实时帮你生成&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个基于 LLM 生成前端 UI 界面的框架，并可将 HTML 转换为 React、Svelte、Web 组件等。（star 4K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/infiniflow/ragflow&quot;&gt;ragflow：基于深度文档理解的开源 RAG 引擎&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;从复杂格式的非结构化数据中提取基于文档理解的深度知识，可视化的文本分块，自动化且轻松的 RAG 工作流。（star 2.4K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/abersheeran/zibai&quot;&gt;zibai：高性能的纯 Python WSGI 服务器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;中文名是“兹白”，出自山海经。相比于 gunicorn ，它的性能更好，并可在 Windows 上使用。相比于 waitress ，兹白在不使用 gevent 时单进程性能与它相当，在重载情况下比 waitress 更稳定。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/impredicative/podgenai&quot;&gt;podgenai：GPT-4 制作有声读物/播客 mp3 生成器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可使用 GPT-4 生成关于给定主题的大约一小时的单扬声器有声读物/播客 mp3 文件。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/qilingframework/qiling&quot;&gt;qiling：真正可检测的二进制仿真框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;纯 Python 实现的一个高级的二进制仿真框架，支持很多操作系统和硬件架构，支持多种文件格式，支持跨架构和平台调试，具有逆向调试功能。（star 4.8K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/google/maxtext&quot;&gt;maxtext：谷歌推出的简单、高性能及可扩展的 JaxLLM&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用纯 Python/Jax 编写，面向 Google Cloud TPU，可实现 55% 到 60% 的模型翻牌利用率。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/openscilab/nava&quot;&gt;nava：在 Python 中播放声音&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个无任何依赖且支持跨平台的库，用于播放声音。支持异步模式、循环模式，主要支持&lt;code&gt;.wav&lt;/code&gt; 格式。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/TMElyralab/MuseV&quot;&gt;MuseV：无限长度和高保真的虚拟人视频生成&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于视觉条件并行去噪的无限长度和高保真虚拟人视频生成，受 Sora 启发而开源，可配合实时高质量的唇同步模型&lt;code&gt;MuseTalk&lt;/code&gt; ，构建完整的虚拟人生成解决方案。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/apocas/restai&quot;&gt;restai：一个 AIaaS（AI 即服务）开源平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;建立在 LlamaIndex、Ollama 和 HF Pipelines 之上，创建 AI 代理并提供简单的 REST API 来调用。&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.youtube.com/playlist?list=PLpyspNLjzwBnP-906FBRP5qzB4YXjMvnT&quot;&gt;使用 Nextjs、Tailwind 和 Django 克隆一个全栈的 Airbnb&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;油管上的系列视频，介绍如何用流行的前后端技术栈克隆一个 Airbnb 网站，可作练手项目学习。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://djangobrew.com/episodes/14650534-episode-1-fried-green-introverts&quot;&gt;Django Brew：一档新的 Python 播客&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一档聚焦于 Django 框架的播客，第一期节目分享了 DjangoCon 2023 上的一些会议演讲内容，以及其它有趣的东西。&lt;/div&gt;
&lt;h2&gt;🐢赠书福利&lt;/h2&gt;
&lt;div&gt;不定期的福利活动，本期赠书 &lt;strong&gt;5&lt;/strong&gt; 本《Python语言及其应用（第2版）》，开奖时间 &lt;strong&gt;4 月 12 日&lt;/strong&gt; 。请给 &lt;strong&gt;&lt;a href=&quot;https://img.pythoncat.top/pythoncat.png&quot;&gt;Python猫&lt;/a&gt;&lt;/strong&gt; 公众号发送数字“&lt;strong&gt;8045&lt;/strong&gt;”，获取抽奖小程序码。&lt;/div&gt;
&lt;div&gt;全书分两部分，第一部分由浅入深地介绍 Python 的基础知识，第二部分介绍 Python 的应用，涉及领域包括 Web 应用、数据库、网络和机器学习。本书通俗易懂，阅读起来饶有乐趣，十分适合想快速获得 Python 应用经验的新手。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#44：Mojo 本周开源了；AI 学会生成音乐了</title>
            <link>https://pythoncat.top/posts/2024-03-30-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-03-30-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，13 个开源项目，赠书 5 本</description>
            <pubDate>Sat, 30 Mar 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯，欢迎关注。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;特别提醒：&lt;/strong&gt; 本期周刊赠书 5 本《明解Python算法与数据结构》，详情见文末。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://earthly.dev/blog/language-style-czar/&quot;&gt;蒙特利尔效应：为什么编程语言需要有风格沙皇&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;讨论了编程语言在规模扩大时面临的风格多样性问题，提出了“语言风格沙皇”（Style Czar）的概念。作者提到 Scala 过于灵活、C++ 新旧标准共存、Python PEP-8 没有与时俱进，呼吁社区应该有人（例如语言创造者）引导社区发展出统一的风格标准。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://fission.codes/blog/functions-everywhere-only-once/&quot;&gt;去中心化的边缘计算平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了“Everywhere Computer”，旨在将计算任务分布到一个广泛的开放网络上，包括个人设备、局域网中的其他设备、云节点集群等。介绍了如何使用 Rust、JavaScript 和 Python 编写具体的函数，并将它们编译为 Wasm 组件。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://reflex.dev/blog/2024-03-21-reflex-architecture/&quot;&gt;设计一个纯 Python Web 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Reflex 是一个纯 Python 全栈 Web 框架（Github 15K star），其作者介绍了 Reflex 的架构，包括前后端的实现细节和工作原理。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://www.pypy.org/posts/2024/03/fixing-bug-incremental-gc.html&quot;&gt;修复 PyPy 增量 GC 中的 一个 bug&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者用将近一年时间定位 PyPy 中一个奇怪且难以复现的 BUG，文章介绍了他采用的各种定位方法、这个 BUG 出现的原因、以及在调试时发现的其它问题。目前修复已合入 PyPy 主分支。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://bpcreech.com/post/mini-racer/&quot;&gt;复活 PyMiniRacer，Python 中的 V8&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何在 Python 项目中运行 JavaScript？PyMiniRacer 是一种方法，但旧项目年久失修，作者接手了它，做了很多的更新，文章介绍了新版本的变更项以及未来的计划。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://juejin.cn/post/7351690896918003775&quot;&gt;Python 与 Javascript 进行数据通信&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了如何实现两种语言的相互调用，实现数据跨语言项目的传递。Python 调用 JavaScript 用了 &lt;strong&gt;pyjsparser&lt;/strong&gt; 和 &lt;strong&gt;PyV8&lt;/strong&gt;，反向用了 &lt;strong&gt;node-python&lt;/strong&gt;、WebSockets 和 HTTP 请求。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://docs.sweep.dev/blogs/file-cache&quot;&gt;更适合慢函数调用的 Python 缓存实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了一种使用文件而非内存的缓存方案，类似于&lt;code&gt;lru_cache&lt;/code&gt; ，它提供了&lt;code&gt;file_cache&lt;/code&gt; 装饰器，主要优点是能持久化缓存结果。文章详细介绍了实现的代码。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://jasongi.com/2024/03/04/speed-up-djangos-collectstatic-command-with-collectfasta/&quot;&gt;使用 Collectfasta 加速 Django 的 collectstatic 命令&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了一个可加速 Django 框架中 &lt;code&gt;collectstatic&lt;/code&gt; 命令的执行速度的工具，包括如何安装和配置、如何将其集成到 Django 项目中以提高性能。还提供了一些性能提升的指标和最佳实践建议。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://stealthrocket.tech/blog/distributed-coroutines-in-python/&quot;&gt;用原生 Python 扩展和 Dispatch 实现分布式协程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;分布式协程是可以挂起、序列化并在另一个进程中恢复的函数，与分布式调度器（如 Dispatch）结合使用，可简化软件的创建过程。Python 原生支持协程，但协程本身不能被序列化，文章介绍了如何解决这个问题，以及如何处理无法序列化的文件和网络句柄、如何处理大型对象以及如何处理全局对象和代码更新等问题。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://pythonspeed.com/articles/slow-numba/&quot;&gt;使用 Numba 加快代码速度的错误方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果基于 NumPy 的代码太慢，有时可用 Numba 来加速。但由于它的类型注解和编译选项，错误使用将导致性能变慢，文章分析了相关问题，并给出了优化的建议。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://adamj.eu/tech/2024/03/23/django-optimizing-system-checks/&quot;&gt;关于优化 Django 系统检查框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Django 的 &lt;strong&gt;system check framework&lt;/strong&gt; 是一种内置机制，可在运行 Django 命令时自动检查和报告潜在的配置及应用状态问题。作者通过性能分析和代码审查，发现并实现了多项优化措施，提升了示例约 50% 的运行速度。所做优化将在 Django 5.1 版本发布。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://easylang.dev/apps/tutorial_mcarlo.html&quot;&gt;大数定律，为什么去赌场是个坏主意&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章通过数据分析的方法（蒙特卡洛方法）模拟抛硬币、轮盘、大乐透等玩法，结果发现输的概率非常大，这告诉了我们一个道理就是……&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁每 30 期为一季，第一季的精华内容已整理成一篇，方便你随时查看。在线访问地址：&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;Python 潮流周刊第一季精华合集（1~30）&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/modularml/mojo&quot;&gt;mojo：Mojo 编程语言开源了&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Mojo 是一种新的编程语言，试图将 Python 的语法及生态与系统编程及元编程相结合，弥补研究与生产之间的差距。（star 18.5K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/SunoAI-API/Suno-API&quot;&gt;Suno-API：基于 Python 和 FastAPI 的非官方 Suno API&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;目前支持生成歌曲、歌词等。自带维护 token 与保活功能，无需担心 token 过期问题。（附：另一个&lt;a href=&quot;https://github.com/yihong0618/SunoSongsCreator&quot;&gt;suno 逆向工程 API&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/adamchainz/blacken-docs&quot;&gt;blacken-docs：对文档中的 Python 代码块上运行“black”&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个命令行工具，支持在 Markdown、reStructuredText 和 LaTex 文件中用&lt;code&gt;black&lt;/code&gt; 格式化 Python 代码块。（投稿自@Chao）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/thombashi/pathvalidate&quot;&gt;pathvalidate：用于规范化/验证字符串，例如文件名和文件路径&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个用于处理文件名和文件路径字符串的实用工具，支持删除无效字符、替换平台保留字、删除不可打印字符、参数校验、多字节字符、支持多平台，等等。（投稿自@Chao）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/tahitimoon/LunarLink&quot;&gt;LunarLink: 基于HttpRunner + Django + Vue + Element UI 的接口自动化测试平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;除题目所述，它还用到以下技术栈：Nginx、RabbitMQ、Redis、MySQL 和 Docker 等，支持登录、项目管理、接口管理、用例管理、流量录制、配置管理、定时任务、报告管理等功能。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/leapingio/leaping&quot;&gt;leaping：轻量级的 Python 测试调试器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个简单、快速、轻量级的 Python 测试调试器，支持跟踪代码的执行，并允许用基于 LLM 自然语言的调试器追溯检查程序的状态。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/rajtilakjee/keepyourmouthshut&quot;&gt;keepyourmouthshut：用 AI 能力录制播客&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;以面向开发者的方式创建播客，不需要任何昂贵的设备。它从用户处获取输入，以此生成脚本和基于该脚本的音频文件。依赖&lt;code&gt;FFMPEG&lt;/code&gt; 和 &lt;code&gt;llmOS&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/harry0703/MoneyPrinterTurbo&quot;&gt;MoneyPrinterTurbo：利用AI大模型，一键生成高清短视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;只需提供一个视频主题或关键词，就可全自动生成视频文案、视频素材、视频字幕、视频背景音乐，然后合成一个高清的短视频。支持 &lt;strong&gt;OpenAI&lt;/strong&gt;、&lt;strong&gt;moonshot&lt;/strong&gt;、&lt;strong&gt;Azure&lt;/strong&gt;、&lt;strong&gt;gpt4free&lt;/strong&gt;、&lt;strong&gt;one-api&lt;/strong&gt;、&lt;strong&gt;通义千问&lt;/strong&gt; 等多种模型。（star 5.5K）&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/agiresearch/AIOS&quot;&gt;AIOS：LLM 代理操作系统&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;将大语言模型嵌入到操作系统中，使操作系统“有灵魂”。旨在优化资源分配，促进跨代理的上下文切换，实现代理的并发执行，为代理提供工具服务，维护代理的访问控制。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/lavague-ai/LaVague&quot;&gt;LaVague：使用大行动模型框架实现自动化&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;提供了一个将自然语言查询转换为 Selenium 代码的引擎，使用户或其它 AI 能够轻松自动化、轻松描述 Web 工作流程并在浏览器上实现自动化。（star 3.5K）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/Meekdai/Gmeek&quot;&gt;Gmeek：一个完全使用 Github 的博客框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;超轻量级个人博客模板，完全基于&lt;code&gt;Github Pages&lt;/code&gt; 、 &lt;code&gt;Github Issues&lt;/code&gt; 和 &lt;code&gt;Github Actions&lt;/code&gt;。不需本地部署，从搭建到写作，只需要 18 秒，2 步搭建好博客，第 3 步就是写作。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/PostHog/posthog&quot;&gt;posthog：提供开源产品分析、会话录制、功能标记和 A/B 测试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个开源的产品分析工具，支持自托管。旨在为企业提供一个可控制、可定制且符合数据隐私要求的分析解决方案。有免费的 cloud 版本。（star 16.5K）&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://github.com/stitionai/devika&quot;&gt;devika：Cognition AI 的 Devin 的开源替代品&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;最近大火的 Devin 的开源替代品，可理解高级人类指令并分解为步骤，研究相关信息，并编写代码以实现给定的目标。它利用大语言模型、规划和推理算法以及 Web 浏览能力来智能开发软件。（star 13K）&lt;/div&gt;
&lt;h2&gt;🐢赠书福利&lt;/h2&gt;
&lt;div&gt;不定期的福利活动，本期赠书 &lt;strong&gt;5&lt;/strong&gt; 本《明解Python算法与数据结构》，开奖时间 &lt;strong&gt;4 月 5 日&lt;/strong&gt; 。请给 &lt;strong&gt;&lt;a href=&quot;https://img.pythoncat.top/pythoncat.png&quot;&gt;Python猫&lt;/a&gt;&lt;/strong&gt; 公众号发送数字“&lt;strong&gt;8044&lt;/strong&gt;”，获取抽奖小程序码。&lt;/div&gt;
&lt;div&gt;日本编程教育界泰斗，畅销书《明解C语言》作者倾力打造！136 段代码 + 213 幅图表，透彻讲解算法与数据结构基础知识，比课本更生动、更易懂！原版系列累计销量超 120 万册，荣获日本工学教育协会著作奖。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#43：在开源与家庭之间，他选择了家庭</title>
            <link>https://pythoncat.top/posts/2024-03-23-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-03-23-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目，2 则音视频，赠书 5 本</description>
            <pubDate>Sat, 23 Mar 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯，欢迎关注。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;特别提醒：&lt;/strong&gt; 本期周刊赠书 5 本《Python数据结构与算法分析（第3版）》，详情见文末。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://gregoryszorc.com/blog/2024/03/17/my-shifting-open-source-priorities/&quot;&gt;我的开源优先级转变了&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者开源了&lt;code&gt;PyOxidizer&lt;/code&gt; 和&lt;code&gt;python-build-standalone&lt;/code&gt; 等多个 Python 项目，但因为编程语言兴趣已转向 Rust，以及身份成为了丈夫&amp;amp;父亲，时间精力不足，因此选择回归家庭，要给这些开源项目寻求新的维护者了。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://bernsteinbear.com/blog/wakeonlan/&quot;&gt;如何远程唤醒家里的电脑？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;家里的电脑处于休眠模式，如何从其它地方远程唤醒它？作者用树莓派单板计算机 + Python 开发的简单网页 + systemd 服务，通过给电脑的网络控制器发送数据包，实现了机器的远程唤醒。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://codebeez.nl/blogs/the-memory-footprint-of-your-python-application/&quot;&gt;Python 程序的内存占用情况&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;相比静态类型语言，Python 要消耗大量内存。文章探讨了 Python 的内存模型：对象是如何分配的、对象存储在什么地方、最终如何清理对象？介绍了如何使用简单的技巧，显著改善内存的使用。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://sethmlarson.dev/regex-$-matches-end-of-string-or-newline&quot;&gt;正则表达式字符“$”并不意味着“字符串末尾”&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;正则表达式中“$”符号会匹配到什么内容呢？Python &lt;code&gt;re.MULTILINE&lt;/code&gt; 多行模式对字符串匹配的影响？是否不同的编程语言的表现都一样呢？什么时候应该用“\z”和“\Z”？ （附：一篇&lt;a href=&quot;https://pythoncat.top/posts/2024-04-15-re&quot;&gt;中文翻译&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.pythonmorsels.com/every-dunder-method/&quot;&gt;介绍 Python 中所有的双下方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;双下方法即以双下划线开头和结尾的特殊方法，例如&lt;code&gt;__init__()&lt;/code&gt; ，Python 语言中共有 150 多个特殊的双下方法，文章对它们多了分类介绍，并梳理了明细清单。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://juejin.cn/post/7348264185325568036&quot;&gt;Python 多语言支持实现国际化与本地化的最佳实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 有丰富的库可支持国际化和本地化，文章介绍如何用&lt;code&gt;gettext&lt;/code&gt; 库实现语言国际化以及如何管理本地化资源。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://juejin.cn/post/7347670979634167823&quot;&gt;在 Windows 上利用 Qwen 大模型搭建一个 ChatGPT 式的问答小助手&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Qwen 是阿里推出的大语言模型，作者用 Win10 系统搭建了一个基于 Qwen 的 AI 问答助手。内容包括安装环境、下载模型、使用&lt;code&gt;transformers&lt;/code&gt; 实现模型对话功能。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://www.norvig.com/lispy.html&quot;&gt;(如何(用Python)开发一个(Lisp)解释器)&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;“如果你不知道编译器是如何工作的，那你就不知道计算机是如何工作的。“作者通过用 Python 开发一个 Lisp 解释器，详细介绍了 Scheme 的语法，深入探讨解释器/计算机的工作原理。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://tkte.ch/articles/2024/03/15/parsing-urls-in-python.html&quot;&gt;使用 Python 解析 URL&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;正确地解析 URL 要比想象得难，它自 1994 年提出以来已发生巨大变化。Python 标准库&lt;code&gt;urllib&lt;/code&gt; 并不遵循任何 URL 规范，文章介绍了两个符合 WHATWG 规范的解析库&lt;code&gt;ada-python&lt;/code&gt; 和&lt;code&gt;can_ada&lt;/code&gt; ，后者比前者快 2 倍，前者比&lt;code&gt;urllib.parse&lt;/code&gt; 快 2 倍。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://realpython.com/duck-typing-python/&quot;&gt;Python 鸭子类型：编写灵活且解耦的代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;鸭子类型的核心思想是“如果它走起来像鸭子，叫起来像鸭子，那么它就是鸭子”。由对象的行为决定类型，而非是一成不变。这篇长文对鸭子类型作了非常详细的介绍，它是什么、如何使用、有什么优缺点、使用哪些方案来弥补鸭子类型的缺点，等等。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://ivdl.co.za/2024/03/02/pretending-to-be-postgresql-part-one-1/&quot;&gt;用 Python 实现最小可用的 PostgreSQL&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了 PostgreSQL 服务端与客户端通信的流程，使用 Python 实现一个最小化的服务端。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://deven.codes/posts/building-for-builders/&quot;&gt;给框架开发者的建议&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者在去年开发了两个 Python 框架，文章分享了他在开发框架时学到的东西。部分建议有：定义你的反目标、了解已存在的东西、首先考虑你的界面、在没准备好时就使用、1 个样本是不够的、重视文档，等等。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁每 30 期为一季，第一季的精华内容已整理成一篇，方便你随时查看。在线访问地址：&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;Python 潮流周刊第一季精华合集（1~30）&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/xai-org/grok-1&quot;&gt;grok-1：马斯克开源的 Grok&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;本周最最火爆的项目当属马斯克差点跳票的 Grok 大语言模型了，有非常惊人的 314B 参数，8 个专家的混合体，最长上下文 8192 token。（star 43K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/luijait/DarkGPT&quot;&gt;DarkGPT：基于 GPT-4-200K，查询泄露的数据库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于 GPT-4 的开源情报助手，从付费的 DeHashed 高效地搜集和分析信息，对网络安全和数据泄露调查有所帮助。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/hynek/structlog&quot;&gt;structlog：简单、强大、快速的 Python 日志记录库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个 Python 日志库，强调结构化和类型安全的日志记录，兼容 &lt;code&gt;logging&lt;/code&gt; 标准库，支持输出 JSON、logfmt 和漂亮的控制台日志。（star 3.1K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/cocolato/pydumpling&quot;&gt;pydumpling: 针对 Python 的异常调试器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python Debug 工具，与 Linux 中调试 core dump 文件一样，支持在异常发生时/程序任意位置保留当前调用栈帧，然后通过 pdb 进行调试。支持全局 hook，支持服务器远程调试。（投稿自@cocolato）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/tktech/can_ada&quot;&gt;can_ada：快速且符合规范的 URL 解析库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;符合 WHATWG 规范的 URL 解析器，也用在了 Node.js 等项目中。比标准库 urllib 快 4 倍。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/yoheinakajima/mindgraph&quot;&gt;Mindgraph：使用 AI 生成和查询不断扩展的知识图谱&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个验证概念的项目，可作为模板，用于构建和自定义自己的 CRM 解决方案，重点是易于集成和可扩展性。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/speechbrain/speechbrain&quot;&gt;speechbrain：基于 PyTorch 的语音工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个 PyTorch 工具包，专为快速简便地创建先进的语音和文本处理技术而设计，可加速对话式 AI （即语音助手、聊天机器人和大语言模型）开发。（star 7.7K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/ssato/python-anyconfig&quot;&gt;python-anyconfig：以通用 API 加载和转储各种格式的配置文件&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;提供了非常简单和统一的 API 来处理各种格式的配置文件，支持格式有 JSON、ini、Pickle、XML、Java properties、YAML、TOML，等等。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/LlamaFamily/Llama-Chinese&quot;&gt;Llama-Chinese: Llama 中文社区，最好的中文 Llama 大模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;专注于 Llama 模型在中文方面的优化和上层建设的高级技术社区，定期组织线上活动、技术研讨和经验分享，促进成员间的创新交流。（star 9K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/kivy/python-for-android&quot;&gt;python-for-android：将 Python 程序变成 Android APK&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可将 Python 应用打包成在 Android 设备上运行的二进制文件（APK、AAB 和 AAR），支持多种 CPU 架构，支持大多数纯 Python 包和一些流行的依赖于 C 代码的包（如 numpy、sqlalchemy）。（star 8K）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/GaParmar/img2img-turbo&quot;&gt;img2img-turbo：Stable Diffusion turbo 实现的 sketch2image、day2night 等&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于素描快速生成图片、夜晚图片转换为白天（或相反）、晴天图片转换为雨天，等等。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/paveldedik/ludic&quot;&gt;ludic：用纯 Python 构建动态 HTML 页面的轻量级框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用类似于 React 的组件构建 HTML 页面，旨在与 htmx.org 一起使用，几乎不需写任何 JavaScript。后端基于 Starlette 框架。&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.bilibili.com/video/BV1im411R7UB&quot;&gt;带大家感受一下没有 GIL 的 CPython&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;CPython 主线分支已合入了可禁用 GIL 的开关，这则视频带大家体验一下没有 GIL 的 Python 会有什么样的表现。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://podcast.pythontest.com/episodes/ruff-astral-uv-charlie-marsh&quot;&gt;ruff、uv 和 Astral：Python 工具链，使用 Rust 提速&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;ruff 和 uv 出自同一个团队，给 Python 的基础工具链带来了非常有前景的影响。这期播客对话了 Charlie Marsh。（附：另一则相似话题的播客 &lt;a href=&quot;https://talkpython.fm/episodes/show/453/uv-the-next-evolution-in-python-packages&quot;&gt;uv - Python 包的下一次演变？&lt;/a&gt;）&lt;/div&gt;
&lt;h2&gt;🐢赠书福利&lt;/h2&gt;
&lt;div&gt;不定期的福利活动，本期赠书 &lt;strong&gt;5&lt;/strong&gt; 本《Python数据结构与算法分析（第3版）》，开奖时间 &lt;strong&gt;3 月 29 日&lt;/strong&gt; 。请给 &lt;strong&gt;&lt;a href=&quot;https://img.pythoncat.top/pythoncat.png&quot;&gt;Python猫&lt;/a&gt;&lt;/strong&gt; 公众号发送数字“&lt;strong&gt;8043&lt;/strong&gt;”，获取抽奖小程序码。&lt;/div&gt;
&lt;div&gt;书是用 Python 描述数据结构与算法的开山之作，汇聚了作者多年的实战经验，透彻讲解在 Python 中通过一系列存储机制高效地实现各类算法。这本书让你深刻理解 Python 数据结构、递归、搜索、排序、树与图的应用，等等。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#42：小公司用 Python 开发，能做到什么程度？</title>
            <link>https://pythoncat.top/posts/2024-03-16-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-03-16-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目。赠书 6 本《流畅的Python》</description>
            <pubDate>Sat, 16 Mar 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯，欢迎关注。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;特别提醒：&lt;/strong&gt; 本期周刊赠书 6 本《&lt;a href=&quot;https://mp.weixin.qq.com/s/eGDOZYZzSpiWojWkN0mK2Q&quot;&gt;流畅的Python（第2版）&lt;/a&gt;》，详情见文末。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://mp.weixin.qq.com/s/OU38bK4q-KNymXAtx8gZJA&quot;&gt;为什么我们公司还在用 Python 开发项目?&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这篇文章让我有种“你不了解的行业内幕”的感觉。小公司还在坚持用 Python 2.7 + Django 1.8，竟支撑每年几个亿的交易额。作者还分享了几个项目，我的感受是：也许你不需要考虑太多“xx语言更好”，就选自己熟悉的，专注于业务实现就好。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://mp.weixin.qq.com/s/9uIYtQEc-RuNhMY7Ck9IAA&quot;&gt;Python 字符串应该用双引号还是单引号？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 字符串既允许双引号也允许单引号，甚至可以三引号。这很灵活，但是对于有强迫症的标准制定者来说，这也是引发冲突的矛盾点。这篇文章分享的故事很有意思，推荐一读！&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://bjoernricks.github.io/posts/python/context-manager&quot;&gt;介绍 Python 上下文管理器及其语法糖&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;为什么需要用上下文管理器？它能解决哪些问题？文章还介绍了上下文管理器协议、&lt;code&gt;with&lt;/code&gt; 语法糖、使用&lt;code&gt;contextlib&lt;/code&gt; 实现上下文管理器、四个很实用的使用案例。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://mathspp.com/blog/python-deque-tutorial&quot;&gt;Python deque 使用教程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;deque&lt;/code&gt; 是&lt;code&gt;collections&lt;/code&gt; 模块下的一种双向队列数据结构，功能与&lt;code&gt;list&lt;/code&gt; 很相似，适宜需要在两端快速添加或删除的场景。这篇教程介绍了它的基本用法与一些高级使用案例。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://guicommits.com/python-generic-type-function-class/&quot;&gt;Python 的泛型函数和泛型类&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 在运行时才检查类型，而且强调的是对象的行为而非类型，因此不怎么提注重类型安全的“泛型”。但是，Python 也支持泛型，文章介绍了如何用&lt;code&gt;typing&lt;/code&gt; 模块实现泛型函数和泛型类。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://upsun.com/blog/python-gevent-best-practices/&quot;&gt;Python Gevent 实践：常见的陷阱&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;Gevent&lt;/code&gt; 是基于  &lt;code&gt;greenlet&lt;/code&gt; 这个轻量级的协程实现的高性能网络库。文章介绍了 Gevent 的常见陷阱以及解决方案。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://lwn.net/SubscriberLink/964392/498a12fe44f51139/&quot;&gt;Python pickles 的安全问题&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;pickle&lt;/code&gt; 是 Python 用作序列化的标准库，但它作反序列化时存在重大的安全风险！文章介绍了它的工作原理、安全风险的根源、机器学习领域合作设计了&lt;code&gt;safetensors&lt;/code&gt; 格式作安全替代。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/j2qk3b/ebook-demo/blob/main/tutorial.md&quot;&gt;构建开源去中心化的电子书搜索引擎&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这篇教程分别使用 JavaScript 和 Python 开发电子书搜索引擎，依赖&lt;code&gt;Glitter&lt;/code&gt; （一个使用&lt;code&gt;Tendermint&lt;/code&gt; 构建的去中心化数据库服务），使用 React 开发展示搜索结果的页面。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://juejin.cn/post/7345423755948572726&quot;&gt;Python import 跟 Java import 有什么区别？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;很多编程语言都有&lt;code&gt;import&lt;/code&gt; 关键字，其作用也类似，但是它们背后的运行机制会有哪些区别呢？文章分析了 Java 和 Python 中 import 的异同点，可加深你对这个话题的理解。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://frostming.com/2024/pdm-lockfile/&quot;&gt;PDM 的内部实现(1)&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;pdm&lt;/code&gt; 是 Python 中极好用的依赖管理工具，是国内开发者@frostming 的作品。作者计划写一系列关于它内部实现的文章，这是第一篇，介绍了 Lockfile 是什么、Lockfile 是如何生成的？&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://nedbatchelder.com/blog/202403/does_python_have_pointers.html&quot;&gt;Python 中有指针吗？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 有指针么？答案取决于你如何理解“指针”。作者简短回答，却一针见血。Python 没有 C 语言经典的指针操作，但 Python 的每个变量都是一个指针，即一切都是隐含的指针。（附：&lt;a href=&quot;https://github.com/ZeroIntensity/pointers.py&quot;&gt;有个项目&lt;/a&gt; “将指针的地狱引入 Python”，跟下方的花括号版 Python 一样画蛇添足）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://pythonspeed.com/articles/python-gil/&quot;&gt;当 Python 无法线程化时：深入了解 GIL 的影响&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;无 GIL 特性终于在本周&lt;a href=&quot;https://github.com/python/cpython/pull/116338&quot;&gt;合入 Python 的主分支了&lt;/a&gt;！分享一篇深度介绍 GIL 的长文，理解 GIL 的工作原理、帮助预测并行性瓶颈的位置，文中使用了很多线程时序分析图，便于理解。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁每 30 期为一季，第一季的精华内容已整理成一篇，方便你随时查看。在线访问地址：&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;Python 潮流周刊第一季精华合集（1~30）&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/flet-dev/flet&quot;&gt;flet：用 Python 开发实时的 Web、移动端和桌面程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;无需前端经验，快速构建跨平台的、支持多用户、实时的单页应用（SPA）；没有 SDK，基于 IDE或文本编辑器即可开发，前端使用 Flutter UI，后端目前支持 Python，计划支持 Go 和 C#。（star 8.7K）（投稿自@bear）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/serious-scaffold/ss-python&quot;&gt;ss-python：Python 项目模板，涵盖整个开发生命周期&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个包括各种集成、配置和模块的 Python 项目模板，特点有：使用&lt;code&gt;copier&lt;/code&gt; 作项目设置与模板更新、使用&lt;code&gt;pdm&lt;/code&gt; 管理依赖及虚拟环境、使用 dev container 作容器化、使用 mypy 和 ruff 等等常用技术栈。（投稿自@huxuan_org）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/amol-/dukpy&quot;&gt;dukpy：用于 Python 简化版 JavaScript 解释器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;构建在&lt;code&gt;duktape&lt;/code&gt; 引擎上的 JS 解释器，用于在 Python 中执行 JS 代码。无其它外部依赖，内置了常用的转译器（TypeScript、JSX、LESS、CoffeeScript），还支持传参、运行多个脚本、全局解释器、使用&lt;code&gt;require&lt;/code&gt; 加载模块、从 npmjs.org 安装软件包等功能。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import dukpy
&amp;gt;&amp;gt;&amp;gt; dukpy.evaljs(&quot;var o = {&apos;value&apos;: 5}; o[&apos;value&apos;] += 3; o&quot;)
{&apos;value&apos;: 8}&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;4、&lt;a href=&quot;https://pykidos.github.io/&quot;&gt;PyKidos：一个 Python 编程练习网站&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在线的 Python 编程网站，很方便通过游戏方式教育小孩学习编程。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/hatchet-dev/hatchet&quot;&gt;hatchet：分布式的容错的任务队列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;取代难以管理的传统队列和发布/订阅系统，支持故障恢复，可解决并发、公平性和速率限制等问题。具有低延迟和高吞吐量，支持 FIFO、LIFO、循环队列和优先级队列等策略，可自定义重试策略，支持集成错误处理。（star 2.4K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/tiangolo/full-stack-fastapi-template&quot;&gt;full-stack-fastapi-template：全栈的现代 Web 项目模板&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用 FastAPI、React、SQLModel、PostgreSQL、Docker、GitHub Actions、自动 HTTPS 等，支持 JWT 身份验证、基于邮件的密码恢复，使用 Traefik 作反向代理/负载均衡。（star 17.5K）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/mathialo/bython&quot;&gt;bython：带花括号的 Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;我认为 Python 用空格作缩进是最最迷人的设计！奈何有人更喜欢花括号。这个项目为 Python 加上了花括号，基本示例：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;print_message&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;num_of_times&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;num_of_times&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Bython is awesome!&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; __name__ &lt;span&gt;==&lt;/span&gt; &lt;span&gt;&quot;__main__&quot;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    print_message&lt;span&gt;(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;8、&lt;a href=&quot;https://github.com/twisted/treq&quot;&gt;treq：构建在 Twisted 上的 HTTP 请求库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个简单的、风格类似&lt;code&gt;requests&lt;/code&gt; 的 HTTP 客户端，构建在 Twisted 之上。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/Yuukiy/JavSP&quot;&gt;JavSP：汇总多站点数据的视频元数据刮削器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;自动抓取、汇总并按指定规则分类整理影片文件，创建供 Emby、Jellyfin、Kodi 等软件使用的元数据文件。（star 1.6K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/omkarcloud/botasaurus&quot;&gt;botasaurus：强大的网络爬虫框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可用简单的 HTTP 请求访问受 Cloudflare 保护的页面，是唯一为认证代理提供 SSL 支持的爬虫框架，仅一行代码即可集成任何 Chrome 插件，支持 sitemap、支持数据清理、支持缓存、提供了 Selenium 快捷方式，等等。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/r0x0r/pywebview&quot;&gt;pywebview：用 JavaScript、HTML 和 CSS 构建 GUI&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个围绕 WebView 组件的轻量级跨平台包装器，在 GUI 窗口中显示 HTML 内容。可与 Web 框架一起使用，也可单独打通 Python 与 DOM。最新发布的 5.0 版本，开始支持 Andriod。（star 4.2K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/Mayuresh1611/Paper-Piano&quot;&gt;Paper-Piano：在白纸上弹钢琴&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它可让你直接在白纸上练习弹钢琴！目前最多支持两个手指，主要为买不起钢琴的人提供练习。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐢赠书福利&lt;/h2&gt;
&lt;div&gt;不定期的福利活动，本期赠书 &lt;strong&gt;6&lt;/strong&gt; 本《&lt;a href=&quot;https://mp.weixin.qq.com/s/eGDOZYZzSpiWojWkN0mK2Q&quot;&gt;流畅的Python（第2版）&lt;/a&gt;》，开奖时间 &lt;strong&gt;3 月 22 日&lt;/strong&gt; 。请给 &lt;strong&gt;&lt;a href=&quot;https://img.pythoncat.top/pythoncat.png&quot;&gt;Python猫&lt;/a&gt;&lt;/strong&gt; 公众号发送数字“&lt;strong&gt;8042&lt;/strong&gt;”，获取抽奖小程序码。&lt;/div&gt;
&lt;div&gt;如果你想要更加熟练地掌握 Python，想要了解实用的编程技巧，想写出地道、优雅、高效的 Python 代码，想要掌握 Python 最新的语言特性，我强烈推荐这本书。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://img.pythoncat.top/python_cat.jpg&quot;&gt;微信公众号&lt;/a&gt;：除更新周刊外，还发布其它原创作品，并转载一些优质文章。（可加好友，可加读者交流群）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pythoncat.top&quot;&gt;博客&lt;/a&gt; 及 &lt;a href=&quot;https://pythoncat.top/rss.xml&quot;&gt;RSS&lt;/a&gt;：我的独立博客，上面有历年原创/翻译的技术文章，以及从 2009 年以来的一些随笔。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pythoncat.substack.com&quot;&gt;邮件&lt;/a&gt; 及 &lt;a href=&quot;https://pythoncat.substack.com/feed&quot;&gt;RSS&lt;/a&gt;：在 Substack 上开通的频道，满足你通过邮件阅读时事通讯的诉求。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;Github&lt;/a&gt;：你可以获取本周刊的 Markdown 源文件，做任何想做的事！&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;Telegram&lt;/a&gt;：除了发布周刊的通知外，我将它视为一个“副刊”，补充发布更加丰富的资讯。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/chinesehuazhou&quot;&gt;Twitter&lt;/a&gt;：我的关注列表里有大量 Python 相关的开发者与组织的账号。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#41：写代码很简单，但写好代码很难</title>
            <link>https://pythoncat.top/posts/2024-03-09-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-03-09-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目。赠书《Python工匠》5本</description>
            <pubDate>Sat, 09 Mar 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯，欢迎关注。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://coderoasis.com/implementing-rsa-from-scratch-in-python/&quot;&gt;使用 Python 从头开始实现 RSA&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者在一系列文章（4 篇）中使用 Python 实现 RSA 加密算法，介绍了这个算法的基本步骤和数学原理，使用 Python 实现并逐步优化，以及实现对它的安全攻击，最后探索 RSA 加密的未来方向。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://norvig.com/python-iaq.html&quot;&gt;Python IAQ：不常见的问题&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个问题很少被回答，要么是因为很少有人知道答案，要么是因为它涉及一个晦涩的微妙的点。文章里列出了很多问题和解读，因写于 20 年前，有些问题已经在后来的 Python 版本中解决了，还有些问题至今仍未过时（依旧冷门）。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://hynek.me/articles/why-i-like-nox/&quot;&gt;为什么我喜欢 Nox？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;tox&lt;/code&gt; 和 &lt;code&gt;nox&lt;/code&gt; 是两个类似的 Python 工具，主要用途之一是测试你的项目在不同 Python 版本中的运行情况。作者解释了为什么在某些情况下，他更喜欢用 nox 的原因。（附：我在 4 年前写过一篇 &lt;a href=&quot;https://pythoncat.top/posts/2020-01-06-tox&quot;&gt;tox 教程&lt;/a&gt; ，也翻译过 nox 的文档。时间过得真快…）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://jamesg.blog/2024/01/16/trie/&quot;&gt;我最喜欢的数据结构：trie&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Trie（前缀树或字典树）是一种树形数据结构，常用于存储和检索字符串集合中的信息。文章介绍了这种数据结构，使用&lt;code&gt;pygtrie&lt;/code&gt; 库演示基本操作。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://datapythonista.me/blog/how-fast-can-we-process-a-csv-file&quot;&gt;用 Python 处理 CSV 文件的速度能有多快？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 处理 CSV 文件有哪些可选方案？不同方案的执行速度、代码可读性、硬件的影响是怎样的？作者测试了 Pandas 使用不同引擎时的性能、使用 Numpy/DuckDB/DataFusion/Polars 等方案的实现比较。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://medium.com/@sakhawy/multilingual-support-in-django-5706e1e144a8&quot;&gt;Django 项目的多语言支持&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何给 Django 项目添加多语言支持？通过什么方式检测当前语言？如何翻译消息文件、翻译模板文件和翻译 JS 文件？翻译后的内容是如何响应给前端的？&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://eng.lyft.com/python-upgrade-playbook-1479145d52f4&quot;&gt;Python 升级手册：Lyft 如何大规模升级 1500+ 代码仓&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Lyft 将 150+ 团队 1500+ 代码仓从 Python 2 升级到 Python 3.10，总结出一份版本升级手册。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://www.photondesigner.com/articles/tailwind-with-django&quot;&gt;将 Tailwind CSS 添加到 Django 的最简单方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Django 项目如何集成当下火热的 Tailwind CSS？这篇教程给出了实现指导，文中附有视频。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://www.bitecode.dev/p/unexpected-python-traps-for-beginners&quot;&gt;初学者意想不到的 Python 陷阱&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章列出了几个挺常见的 Python “陷阱”，新手们确实容易被绊倒。包括：不显眼的字符串连接、函数返回的 None、不可见的元组、可怕的&lt;code&gt;is&lt;/code&gt; 、列表相乘。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://calbryant.uk/blog/better-pc-cooling-with-python/#&quot;&gt;使用 Python 和 Grafana 更好地冷却我的 PC&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇关于 Python 在现实世界发挥作用的文章：作者用 Python 读取 CPU 和液冷器温度，控制风扇和泵速，通过 Grafana 监控性能，有效提高了 PC 冷却效率、减少了风扇噪声！&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://soulteary.com/2024/02/29/run-large-ai-models-on-android-phones-with-snapdragon-8-gen-3.html&quot;&gt;使用搭载骁龙 8 Gen 3 的安卓手机运行 AI 大模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了在 Android 手机上简单运行 AI 大模型的方法，来体验英文语言模型（Llama2 7B、Mistral 7B、RedPajama 3B、Google Gemma 2B、Microsoft PHI 2B）；中文语言模型（面壁 MiniCPM、多模态模型）；Stable Diffusion。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://www.piglei.com/articles/programming-is-still-hard-after-14-years/&quot;&gt;入行 14 年，我还是觉得编程很难&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python 工匠》作者@piglei 分享的自己关于编程的感触。去年已读过，现在读依然有收获。文章整理了 8 条编程经验，最核心的观点之一是“写好代码”，呼应了“Python工匠”系列文章的初心：像工匠打造完美的手工艺品一样编写优雅而高效的代码。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁每 30 期为一季，第一季的精华内容已整理成一篇，方便你随时查看。在线访问地址：&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;Python 潮流周刊第一季精华合集（1~30）&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/mikeckennedy/umami-python&quot;&gt;umami-python：Python 开发的 Umami 分析客户端&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;很多个人网站（包括我的）不再使用 Google Analytics 作网站流量分析，而是使用开源的 umami。这个项目基于 &lt;code&gt;httpx&lt;/code&gt; 和 &lt;code&gt;pydantic&lt;/code&gt; 开发了客户端，实现登录与验证，可将自定义数据添加到 umami，可查看 umami 上的分析数据等。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/dry-python/returns&quot;&gt;returns：让函数返回有意义、类型化且安全的内容&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它将函数式编程带入 Python 领域，提供很多原语来编写声明式业务逻辑，完全类型化，支持函数和协程且与框架无关。（star 3.2K）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/ivnvxd/pyquest&quot;&gt;pyquest：一系列的 Python 编程教程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个项目收录了一系列的 Python 编程学习资料，涉及 Python 编程的方方面面，系统学习 Python。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/Chaoyingz/flect&quot;&gt;flect：用于构建全栈 Web 应用的 Python 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;通过在后端使用与前端 React 组件属性相对应的 Pydantic 模型来构建用户界面，快速开发具有交互性和美观的用户界面。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/budtmo/docker-android&quot;&gt;docker-android：Docker 里的 Android，支持 noVNC 和视频录制&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个用于 Android 开发与测试的 docker 镜像，有不同设备的模拟器、支持 vnc 可查看容器内部、支持日志通过 Web UI 共享、能使用 adb 从外部控制、支持多种测试框架如 Appnium 和 Espresso 等。（star 7K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/anthropics/anthropic-sdk-python&quot;&gt;anthropic-sdk-python：调用 Claude 3 等大模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;上周的 Claude 3 是热门话题，性能跑分全面超越 GPT-4！这个项目是官方发布的 Python 开发包，支持异步、流式响应、流媒体助手、查看使用量、以 Pydantic 模型返回、重试和超时处理等。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/TencentARC/PhotoMaker&quot;&gt;PhotoMaker：制造逼真的人物照片&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在几秒钟内快速定制，无需额外的 LoRA 培训；确保令人印象深刻的 ID 保真度、提供多样性、高质量生成；可作为适配器与其他基础模型以及 LoRA 模块进行协作。（star 7.8K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/alexta69/metube&quot;&gt;metube：自托管的 YouTube 下载器（youtube-dl/yt-dlp 的 Web UI）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用于 youtube-dl 的 Web GUI（使用 yt-dlp 分支），支持播放列表。可从 YouTube 和其他数十个网站下载视频。（star 3.1K）&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/tkem/cachetools&quot;&gt;cachetools：可扩展的内存化集合和装饰器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;提供了各种内存中的集合和装饰器，包括 Python 标准库的 @lru_cache 函数装饰器的变体。（star 2K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/sivel/speedtest-cli&quot;&gt;speedtest-cli：使用 speedtest.net 测试网络带宽的命令行界面&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个网络性能诊断工具，允许用户从终端或命令行环境中测量到特定服务器的下载和上传速度，以及网络延迟。支持跨平台，容易集成到脚本中作自动化测试。（star 13.2K）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/PKU-YuanGroup/Open-Sora-Plan&quot;&gt;Open-Sora-Plan：旨在重现 Sora（Open AI T2V模型）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Sora 是 OpenAI 推出的文本到视频模型，代表了视频生成技术的一个重大飞跃。该项目希望通过开源社区的力量复现 Sora，目前搭建了基础架构，但未能进行完整训练。（star 5.2K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/mini-sora/minisora&quot;&gt;minisora：旨在探索 Sora 的实施路径和未来发展方向&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;同样试图复现 Sora，目标是 GPU 友好、提升训练和推理效率。定期举行圆桌讨论、共读论文，深入研究现有的视频生成技术。&lt;/div&gt;
&lt;h2&gt;🐢赠书福利&lt;/h2&gt;
&lt;div&gt;不定期的福利活动，本期赠书 &lt;strong&gt;5&lt;/strong&gt; 本《Python工匠：案例、技巧与工程实践》，开奖时间 &lt;strong&gt;3 月 15 日&lt;/strong&gt;。请给 &lt;strong&gt;&lt;a href=&quot;https://img.pythoncat.top/pythoncat.png&quot;&gt;Python猫&lt;/a&gt;&lt;/strong&gt; 公众号发送数字“&lt;strong&gt;8041&lt;/strong&gt;”，获取抽奖小程序码。&lt;/div&gt;
&lt;div&gt;这本书从工程实践角度出发，通过剖析核心知识、展示典型案例与总结实用技巧，帮助大家系统进阶 Python，写好工程代码，做好实践项目。全书分为五大部分：变量与基础类型、语法结构、函数与装饰器、面向对象编程、总结与延伸，涵盖 Python 编程的方方面面。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>用 Rust 开发的 Python 包管理工具 uv，可替换 pip、pip-tools 和 virtualenv</title>
            <link>https://pythoncat.top/posts/2024-03-05-uv/</link>
            <guid>https://pythoncat.top/posts/2024-03-05-uv/</guid>
            <description>uv：一个极其快速的 Python 包安装器和解析器</description>
            <pubDate>Tue, 05 Mar 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;最近，我在 &lt;a href=&quot;https://pythoncat.top/posts/2024-02-24-weekly&quot;&gt;Python 潮流周刊&lt;/a&gt; 中分享了一个超级火爆的 Python 包管理工具，这还不到一个月，它在 Github 上已经拿下了 8K star 的亮眼成绩，可见其受欢迎程度极高！国内还未见有更多消息，我趁着周末把一篇官方博客翻译出来了，分享给大家。&lt;/div&gt;
&lt;div&gt;作者：&lt;a href=&quot;https://twitter.com/charliermarsh&quot;&gt;@charliermarsh&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;译者：豌豆花下猫@Python猫&lt;/div&gt;
&lt;div&gt;英文：uv: Python packaging in Rust (&lt;a href=&quot;https://astral.sh/blog/uv&quot;&gt;https://astral.sh/blog/uv&lt;/a&gt;)&lt;/div&gt;
&lt;div&gt;声明：本翻译是出于交流学习的目的，为便于阅读，部分内容略有改动。转载请保留作者信息。&lt;/div&gt;
&lt;h2&gt;摘要&lt;/h2&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/astral-sh/uv&quot;&gt;uv&lt;/a&gt; 是一个极其快速的 Python 包安装器和解析器，用 Rust 编写，旨在作为 pip 和 pip-tools 工作流的替代品。&lt;/div&gt;
&lt;div&gt;它代表了我们追求“Python 的 Cargo”的里程碑：一个全面、快速、可靠且易于使用的 Python 项目和包管理器。&lt;/div&gt;
&lt;div&gt;作为此次发布的一部分，我们还将接管 Rye，这是 Armin Ronacher 开发的一个实验性 Python 打包工具。我们将维护它，直到我们将 uv 扩展成统一的后继项目，以实现我们对 Python 打包的共同愿景。&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;在 Astral，我们为 Python 生态系统构建高性能的开发工具。我们最出名的是 &lt;a href=&quot;https://github.com/astral-sh/ruff&quot;&gt;Ruff&lt;/a&gt;，一个极其快速的 Python linter 和格式化工具。（译注：如果你没听过 Ruff，强烈建议阅读这篇对 Ruff 的介绍 &lt;a href=&quot;https://pythoncat.top/posts/2023-04-09-ruff&quot;&gt;性能最快的代码分析工具，Ruff 正在席卷 Python 圈！&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;今天，我们发布了 Astral 工具链中的下一个工具：uv，一个用 Rust 开发的高性能的 Python 包解析器和安装器。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;图注：使用热缓存来解析（左）和安装（右）Trio 依赖项，以模拟重新创建虚拟环境或向现有项目添加依赖项&lt;/div&gt;
&lt;div&gt;uv 旨在作为 pip、pip-tools 和 virtualenv 的直接替代品，现在就可以用于生产环境中那些围绕这些工作流构建的项目。&lt;/div&gt;
&lt;h2&gt;产品原则&lt;/h2&gt;
&lt;div&gt;与 Ruff 一样，uv 的实现也遵循我们的核心产品原则：&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;痴迷于高性能&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;在上述基准测试中，uv 在没有缓存的情况下比 pip 和 pip-tools 快 8-10 倍，而在有热缓存的情况下（例如，重新创建虚拟环境或更新依赖项），则快 80-115 倍。&lt;/div&gt;
&lt;div&gt;uv 使用全局模块缓存来避免重新下载和构建依赖项，并在支持的文件系统上利用 Copy-on-Write 和硬链接来最小化磁盘空间使用。&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;优化以便于采用&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;尽管我们对 Python 打包的未来有着宏大的愿景，但 uv 的初始版本聚焦于支持我们 &lt;code&gt;uv pip&lt;/code&gt; 接口背后的 pip 和 pip-tools，使其可以零配置地被现有项目所采用。&lt;/div&gt;
&lt;div&gt;相似地，uv 可以“仅仅”当作一个解析器（&lt;code&gt;uv pip compile&lt;/code&gt; 锁定你的依赖项），“仅仅”当作一个虚拟环境创建器（&lt;code&gt;uv venv&lt;/code&gt;），“仅仅”当作一个包安装器（&lt;code&gt;uv pip sync&lt;/code&gt;），等等。它既是统一的，又是模块化的。&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;简化的工具链&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;uv 作为一个单一的静态二进制文件发布，能够替代 pip、pip-tools 和 virtualenv。uv 没有直接的 Python 依赖，因此你可以跟 Python 本身分别安装，避免了在多个 Python 版本（例如，pip vs. pip3 vs. pip3.7）之间选择 pip 安装程序。&lt;/div&gt;
&lt;h2&gt;安装使用&lt;/h2&gt;
&lt;div&gt;虽然 uv 将演变成一个完整的 Python 项目和包管理器（“Cargo for Python”），但像&lt;code&gt;pip-tools&lt;/code&gt; 这样较狭窄的聚焦范围，让我们得以解决构建此类工具所涉及的低级问题（如包安装），同时立即提供有用的东西，最小化社区的使用障碍。&lt;/div&gt;
&lt;div&gt;你可以通过我们的独立安装程序安装 uv，或者从 PyPI 安装。&lt;/div&gt;
&lt;div&gt;使用 curl：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;curl&lt;/span&gt; &lt;span&gt;-LsSf&lt;/span&gt; https://astral.sh/uv/install.sh &lt;span&gt;|&lt;/span&gt; &lt;span&gt;sh&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;对 Windows：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;powershell &lt;span&gt;-c&lt;/span&gt; &lt;span&gt;&quot;irm https://astral.sh/uv/install.ps1 | iex&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;使用 pip 或 pipx：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;pip install uv
pipx install uv&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;uv 能满足你对现代 Python 打包工具的所有期望：可编辑安装、Git 依赖项、URL 依赖项、本地依赖项、约束文件、源码分发、自定义索引等，所有这些都设计成与你现有的工具无缝兼容。&lt;/div&gt;
&lt;div&gt;uv 支持 Linux、Windows 和 macOS，并已针对公共的 PyPI 索引进行了大规模测试。&lt;/div&gt;
&lt;h2&gt;即插即用的兼容性 API&lt;/h2&gt;
&lt;div&gt;这个初始版本主要实现了 uv 的&lt;code&gt;pip&lt;/code&gt; 命令。对于使用过 pip 和 pip-tools 的人来说，这将会很熟悉：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;类似于&lt;code&gt;pip install&lt;/code&gt;，运行&lt;code&gt;uv pip install&lt;/code&gt; ，可从命令行、requirements 文件或 pyproject.toml 来安装 Python 依赖项&lt;/li&gt;
&lt;li&gt;类似于&lt;code&gt;pip-compile&lt;/code&gt;，运行&lt;code&gt;uv pip compile&lt;/code&gt; 来生成锁定的 requirements.txt&lt;/li&gt;
&lt;li&gt;类似于&lt;code&gt;pip-sync&lt;/code&gt;，运行&lt;code&gt;uv pip sync&lt;/code&gt; 来同步带有锁定的 requirements.txt 的虚拟环境&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;通过将这些“低级”命令放在&lt;code&gt;uv pip&lt;/code&gt;下，我们在 CLI 中预留了空间，用于我们打算在未来发布的更“有主见”的项目管理 API，它看起来将更像 Rye、Cargo 或 Poetry。（想象一下 &lt;code&gt;uv run&lt;/code&gt; 、&lt;code&gt;uv build&lt;/code&gt; 等等）&lt;/div&gt;
&lt;div&gt;uv 也可以通过&lt;code&gt;uv venv&lt;/code&gt; 作为虚拟环境管理器使用。它比&lt;code&gt;python -m venv&lt;/code&gt; 快大约 80 倍，比&lt;code&gt;virtualenv&lt;/code&gt; 快 7 倍，且不依赖于 Python。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;图注：创建一个虚拟环境，有（左）和没有（右）pip 及 setuptools 种子包&lt;/div&gt;
&lt;div&gt;uv 的虚拟环境符合标准，可以与其他工具互换使用——没有锁定机制或定制。&lt;/div&gt;
&lt;h2&gt;新功能&lt;/h2&gt;
&lt;div&gt;从头开始构建我们自己的包管理工具栈，这还为新功能开辟了空间。例如：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;uv 支持替换解析策略。&lt;/strong&gt; 默认情况下，uv 遵循标准的 Python 依赖解析策略，即优先选择每个包的最新兼容版本。但通过传入&lt;code&gt;--resolution=lowest&lt;/code&gt;，库作者可以测试他们的包与依赖项的最低兼容版本。（这类似于 Go 的最小版本选择。）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;uv 允许针对任意 Python 目标版本进行解析。&lt;/strong&gt; pip 和 pip-tools 默认针对当前安装的 Python 版本进行解析（例如，在 Python 3.12 下运行，将生成兼容于 Python 3.12 的解析），uv 支持&lt;code&gt;--python-version&lt;/code&gt; 参数，使你能够在运行较新版本的情况下，生成兼容较低版本（例如 Python 3.7）的解析。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;uv 允许依赖项“覆盖”。&lt;/strong&gt; uv 通过覆盖（&lt;code&gt;-o overrides.txt&lt;/code&gt;）将 pip 的“约束”概念向前推了一步，允许用户通过覆盖包的声明依赖项来引导解析器。覆盖为用户提供了一个逃生舱口，用于解决错误的上限和其他错误声明的依赖项。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;在当前形式下，uv 并不适合所有项目。pip 是一个成熟且稳定的工具，支持非常广泛的场景，并且专注于兼容性。虽然 uv 支持 pip 的大部分功能，但它缺乏对一些传统特性的支持，比如 .egg 分发。&lt;/div&gt;
&lt;div&gt;同样，uv 目前还不支持生成与平台无关的锁定文件。这与 pip-tools 相符，但与 Poetry 和 PDM 不同，这使得 uv 更适合围绕 pip 和 pip-tools 工作流构建的项目。&lt;/div&gt;
&lt;div&gt;对于那些深入打包生态系统的人来说，uv 还用 Rust 实现了符合标准的更多功能，例如 PEP 440（版本标识符）、PEP 508（依赖项说明符）、PEP 517（与构建系统无关的构建前端）、PEP 405（虚拟环境）等。&lt;/div&gt;
&lt;h2&gt;“Python 的 Cargo”：uv 和 Rye&lt;/h2&gt;
&lt;div&gt;uv 代表着我们追求 “Python 的 Cargo” 的一个中间里程碑：一个统一的 Python 包和项目管理器，它极其快速、可靠且易于使用。&lt;/div&gt;
&lt;div&gt;想象一下：一个单一的二进制文件，它可为你安装 Python，并为你提供使用 Python 所需的一切，不仅包括 pip、pip-tools 和 virtualenv，还有 pipx、tox、poetry、pyenv、ruff 等等。&lt;/div&gt;
&lt;div&gt;使用 Python 工具链可能是一种低信心体验：为新项目或现有项目搭建环境需要大量的工作，而且命令通常以令人费解的方式报错。相比之下，在 Rust 生态中做事时，你信任工具会成功。Astral 工具链的目标是将 Python 从低信心体验转变为高信心体验。&lt;/div&gt;
&lt;div&gt;我们对 Python 打包的愿景与 Rye 的愿景相去不远，Rye 是由 Armin Ronacher 开发的一个实验性的项目与包管理工具。&lt;/div&gt;
&lt;div&gt;在与 Armin 的交流中，我们清楚地认识到我们的愿景非常接近，但实现这些愿景需要在基础工具上作大量投入。例如：构建这样的工具需要一个非常快速的、端到端集成的、跨平台的解析器和安装器。&lt;strong&gt;在 uv 里，我们已经构建出了这样的基础工具。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;我们认为这是一个难得的合作机会，可以避免 Python 生态破碎。&lt;strong&gt;因此，我们与 Armin 合作，很高兴地接管了 Rye。&lt;/strong&gt; 我们的目标是将 uv 发展成一个生产就绪的 “Python 的 Cargo”，并在适当的时候提供一个将 Rye 平滑迁移到 uv 的路径。&lt;/div&gt;
&lt;div&gt;在此之前，我们将维护 Rye，将其迁移成在幕后使用 uv，宽泛地说，它将成为我们正在构建的最终用户体验的实验性测试床。&lt;/div&gt;
&lt;div&gt;虽然合并项目带来了一些挑战，但我们致力于在 Astral 的旗帜下构建一个单一的且统一的工具，并在我们发展 uv 成为一个合适且全面的继任者的同时，支持现有的 Rye 用户。&lt;/div&gt;
&lt;h2&gt;我们的路线图&lt;/h2&gt;
&lt;div&gt;在此次发布之后，我们的首要任务是支撑好那些在考察 uv 的用户，重点是提高跨平台的兼容性、性能和稳定性。&lt;/div&gt;
&lt;div&gt;然后，我们将着手把 uv 扩展为一个完整的 Python 项目与包的管理器：一个单一的二进制文件，为你提供使用 Python 提高生产力所需的一切。&lt;/div&gt;
&lt;div&gt;我们对 uv 有一个雄心勃勃的路线图。但在当下，我认为它对 Python 来说，感觉像是提供了一种非常不同的体验。我希望你们能尝试一下。&lt;/div&gt;
&lt;h2&gt;致谢&lt;/h2&gt;
&lt;div&gt;最后，我们要感谢所有直接或间接为 uv 的开发做出贡献的人。其中最重要的是 &lt;a href=&quot;https://github.com/pubgrub-rs/pubgrub&quot;&gt;pubgrub-rs&lt;/a&gt; 的维护者 Jacob Finkelman 和 Matthieu Pizenberg。uv 使用了 PubGrub 作为其底层版本解析器，我们感谢 Jacob 和 Matthieu 在过去对 PubGrub 所做的工作，以及他们作为合作者对整个项目的关键助力。&lt;/div&gt;
&lt;div&gt;我们还要感谢那些启发了我们的打包项目，尤其是 Cargo，以及来自 JavaScript 生态的 Bun、Orogene 和 pnpm，以及来自 Python 生态的 Posy、Monotrail 和 Rye。特别感谢 Armin Ronacher 与我们合作完成这项工作。&lt;/div&gt;
&lt;div&gt;最后，我们还要感谢 pip 的维护者们以及更广泛的 PyPA 的成员，感谢他们为使 Python 打包成为可能所做的所有工作。&lt;/div&gt;
&lt;div&gt;猫哥注：&lt;/div&gt;
&lt;div&gt;最最后附上潮流周刊第 27 期的一篇&lt;a href=&quot;https://alpopkes.com/posts/python/packaging_tools/&quot;&gt;对 Python 环境管理和包管理工具的公正分析&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 中的虚拟环境管理和包管理工具实在是太多了！但是应该如何选择最适合自己需求的工具呢？作者全面分析了 5 个类别的 10 多款工具，希望减少用户在抉择上的困惑。（附：作者针对此主题的两场演讲 &lt;a href=&quot;https://www.youtube.com/watch?v=MsJjzVIVs6M&quot;&gt;PyCon DE 2023&lt;/a&gt; 和 &lt;a href=&quot;https://www.youtube.com/watch?v=3-drZY3u5vo&quot;&gt;EuroPython 2023&lt;/a&gt;）&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#40：白宫建议使用 Python 等内存安全的语言</title>
            <link>https://pythoncat.top/posts/2024-03-02-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-03-02-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，11 个开源项目</description>
            <pubDate>Sat, 02 Mar 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯，欢迎关注。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pyfound.blogspot.com/2024/02/white-house-recommends-.html&quot;&gt;白宫建议使用 Python 等内存安全语言&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;最近，白宫发布了一份报告，建议使用内存安全的编程语言。去年 CISA、NSA 等机构联合发布的报告列出了内存安全的语言有 C#、Go、Java、&lt;strong&gt;Python&lt;/strong&gt;、Rust 及 Swift。PSF 这篇文章介绍了 Python 在内存安全性方面所做的工作，包括封装底层代码、从 C 向 Rust 迁移、使用编译器选项强化 C 代码构建。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://blog.ian.stapletoncordas.co/2024/02/a-retrospective-on-requests&quot;&gt;回顾 Requests 库的问题&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章作者是 Requests 的核心维护者之一，他列举了这个库做得糟糕的多个地方，也指出了很多想改进却没有做到的原因。文末的结语说：“the project feels dead”。这让人感觉很难受。本周刊&lt;a href=&quot;https://pythoncat.top/posts/2023-11-11-weekly&quot;&gt;第26期&lt;/a&gt; 分享过该库作者 KR 的道歉文，然而社区内几无波澜，后来看到 KR 失业，从推文感觉他精神状态很糟糕，更让人难受了。（投稿by@frostming90）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://micro.webology.dev/2024/02/29/pythons-uv-tool.html&quot;&gt;Python 的 UV 工具确实相当不错&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;上期周刊分享的可替换&lt;code&gt;pip&lt;/code&gt;的&lt;code&gt;uv&lt;/code&gt; 库，你用了么？感觉如何啊？文章作者给出了积极反馈，分享了自己一些配置文件的前后对比。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://www.slashtmp.io/posts/generators/&quot;&gt;Python 生成器未得到充分利用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 生成器的作用是能节省内存，这篇文章用很明白的例子对比了两种内存使用情况，让我们感受到生成器的好处，同时，文章也指出了需要避免的一些使用陷阱。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://jacobpadilla.com/articles/advanced-web-scraping-techniques&quot;&gt;使用 Python 作高级 Web 抓取：从任意网站抓取数据&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章讨论了从 Web 抓取内容的一些高级技术，话题包括如何更好处理 Cookie 及自定义请求头、什么是 TLS 指纹以及如何避免它、需要注意的常见 HTTP 请求头、在发出 HTTP 请求时如何集成指数回退重试，等等。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://testdriven.io/blog/drf-vue-vs-django-htmx/&quot;&gt;Django REST 框架 + Vue 对比 Django + HTMX&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;两种 Web 开发框架的组合：DRF + Vue 以及 Django + HTMX，它们分别是如何使用的，各自又有哪些优势和劣势呢？文章用这两个组合分别实现同样的功能，分析了两组技术栈的差异，罗列了一份比对清单，可方便我们更好地作技术选型。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://wesmckinney.com/blog/looking-back-15-years/&quot;&gt;可组合数据系统之路：对过去 15 年和未来的思考&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章出自&lt;code&gt;pandas&lt;/code&gt; 库兼《Python数据分析》一书的作者 Wes McKinney，回顾了他从 2008 年以来在数据科学领域所做的事情和转变，同时分析和思考了模块化、互操作性和可组合性的未来趋势。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://blog.pecar.me/django-sqlite-benchmark&quot;&gt;用 Django 作 SQLite 基准测试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者分别调整 SQLite 的一些主要配置项来作基准测试，另外也比较了 SQLite 和 PostgreSQL 的性能。简短结论：启用 WAL 模式、使用 IMMEDIATE 事务、&lt;code&gt;synchronous=NORMAL&lt;/code&gt; 和内存映射 I/O 对吞吐量的影响很小。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://zhuanlan.zhihu.com/p/682997904&quot;&gt;Python 3.13 的 JIT 是如何实现的？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了 Python 最新正在开发中的 JIT 是如何实现的，并尝试安装了开发版本，然后与无 JIT 版本作性能比较。目前 JIT 版本的性能反而慢于普通版本，官方仍需继续努力优化。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://proxiesapi.com/articles/web-scraping-in-python-the-complete-guide&quot;&gt;Python 网页抓取的终极指南&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇详细的爬虫教程，介绍了如何使用 BeautifulSoup、Scrapy 和 Selenium 等库实现网页抓取，如何克服复杂网页、限速、反爬、动态 javascript 等挑战。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://danluu.com/simple-architectures/&quot;&gt;为简单架构作辩护&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Wave 是一家仅有 70 名工程师但估值 17 亿美元的公司，其产品只是一款标准的 CRUD 程序，是构建在 Postgres 之上的 Python 单体架构。文章解释了为什么要选择这样的架构，解释了这样选型的合理性，以及为了保持它而克服的相关难题和选用的技术方案。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://tontinton.com/posts/scheduling-internals/&quot;&gt;关于“调度”的内部原理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇非常深度的长文，深入探讨了“并发”，解释了单线程服务器如何通过异步 IO 和事件驱动编程来处理数以百万计的任务。讨论了实现并发的各种方法和工具，不同编程语言的实现。文中有不少动画，可方便读者理解。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁每 30 期为一季，第一季的精华内容已整理成一篇，方便你随时查看。在线访问地址：&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;Python 潮流周刊第一季精华合集（1~30）&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/bruin-data/ingestr&quot;&gt;ingestr：用单个命令在任何数据库间无缝复制数据&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个 CLI 工具，使用简单的命令即可实现跨数据库的内容复制。支持增量加载：&lt;code&gt;append&lt;/code&gt; 、 &lt;code&gt;merge&lt;/code&gt; 和 &lt;code&gt;delete+insert&lt;/code&gt; 模式。（star 1.3K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/epogrebnyak/justpath&quot;&gt;justpath：在 Windows 和 Linux 上检查和优化 PATH 环境变量&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个用于管理操作系统 PATH 环境变量的命令行工具，典型功能包括：筛选目录、识别和清理无效配置、PATH 转储为 JSON、创建新的环境变量、统计数量。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/piercefreeman/mountaineer&quot;&gt;mountaineer：用于 Python 和 React 的自带电池的 Web 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;全栈的 Web 开发框架，主要特点：全栈的类型提示、友好的服务通信及数据绑定、服务器端渲染、对网页作静态分析的增强校验、等等。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/wangyuxinwhy/generate&quot;&gt;generate：一个 API 访问国内外大模型平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用一个统一的 API 访问大模型，特点：统一的 API、支持多模态、支持 10+ 大模型平台、异步&amp;amp;流式和并发、自带电池、轻量化、高质量代码。（投稿by@wangyuxinwhy）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/ashvardanian/StringZilla&quot;&gt;StringZilla：将 C、C++、Python、Rust 和 Swift 的字符串速度提高 10 倍&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;“由于低效的字符串操作，世界每年至少浪费 1 亿美元”。这个项目可替换编程语言原生的字符串类型，提高性能。可加速精确和模糊字符串匹配、编辑距离计算、排序、延迟计算范围以避免内存分配，甚至随机字符串生成器。（star 1.4K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/g1879/DrissionPage&quot;&gt;DrissionPage: 网页自动化工具，能控制浏览器，也能收发数据包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;采用全自研内核，对比 Selenium 有以下优点：无 webdriver 特征、跨 iframe 查找元素、把 iframe  看作普通元素、可同时操作多个标签页、可直接读取浏览器缓存来保存图片、可对整个网页截图，等等。（star 4.1K）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/Eventual-Inc/Daft&quot;&gt;Daft：Rust 开发的面向云的分布式 Python DataFrame&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用 Rust 开发的用于大规模数据处理的分布式查询引擎，熟悉的交互式 API、专注于查询优化、集成数据目录、丰富的多模态类型系统、专为云而构建。（star 1.4K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/google/magika&quot;&gt;magika：使用深度学习来检测文件内容的类型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;谷歌最新开源作品，使用 AI 来检测文件类型，具有 99% 的精确度。可作为 Python 命令行和 API 使用，支持超过 100 中文件类型，每个文件的推理时间约为 5 毫秒。（star 7K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/frappe/frappe&quot;&gt;frappe：低代码 Web 框架，使用 Python 和 Javascript&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;自带电池的全栈 Web 框架，低代码，服务器端使用 Python 和 MariaDB，特点：元数据优先、管理员界面、开箱即用的角色和权限、支持插件、支持任务调度、邮箱管理、多租户，等等。（star 6.3K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/hiroi-sora/Umi-OCR&quot;&gt;Umi-OCR: 开源、免费的离线 OCR 软件，支持截屏/批量导入图片&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;解压即用，离线运行，无需网络；自带高效率的离线OCR引擎，内置多种语言识别库；支持命令行、HTTP接口等多种调用方式；截图OCR / 批量OCR / PDF识别 / 二维码。（star 19.4K）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/xonsh/xonsh&quot;&gt;xonsh：Python 开发的跨平台的类 Unix 的 shell&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个项目是 Python 3.6+ 的超集，带有 shell 原语。可以作为 shell 和 Python 单独使用，也可以在 Python 里写 shell，在 shell 里写 Python。（star 7.8K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#39：Rust 开发的性能超快的打包工具</title>
            <link>https://pythoncat.top/posts/2024-02-24-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-02-24-weekly/</guid>
            <description>本期周刊分享了 13 篇文章，13 个开源项目，2 则播客</description>
            <pubDate>Sat, 24 Feb 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯，欢迎关注。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://astral.sh/blog/uv&quot;&gt;uv：Rust 开发的 Python 打包工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;Ruff&lt;/code&gt; 所属团队用 Rust 开发的一个利器：Python 的包解析与安装器&lt;code&gt;uv&lt;/code&gt; ！它被设计为 &lt;code&gt;pip&lt;/code&gt; 和 &lt;code&gt;pip-tools&lt;/code&gt; 的直接替代品，不使用缓存时比它们快 8-10 倍。也可通过 &lt;code&gt;uv venv&lt;/code&gt; 用作虚拟环境管理器，比 &lt;code&gt;python -m venv&lt;/code&gt; 快 80 倍，比&lt;code&gt;virtualenv&lt;/code&gt; 快 7 倍。（附：&lt;a href=&quot;https://pythoncat.top/posts/2024-03-05-uv&quot;&gt;一篇中文翻译&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://lucumr.pocoo.org/2024/2/4/rye-a-vision/&quot;&gt;Rye：愿景延续&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Rye 是 Flask 作者在去年 4 月发布的 Python 打包和项目管理工具，作者在文章中总结了它已实现的功能（下载 Python、管理虚拟环境、构建和发布包、linting 和格式化、依赖管理等） ，介绍了自己的设计想法。（附1：作者的 16 分钟教程视频 &lt;a href=&quot;https://www.youtube.com/watch?v=q99TYA7LnuA&quot;&gt;Rye: a Hassle-Free Python Experience&lt;/a&gt;）（附2：上一则分享的 uv 团队已接管了 Rye，将来会融合成一个。&lt;a href=&quot;https://lucumr.pocoo.org/2024/2/15/rye-grows-with-uv/&quot;&gt;Rye Grows With UV&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://baincapitalventures.com/insight/why-more-python-developers-are-using-rust-for-building-libraries/&quot;&gt;为什么越来越多用 Rust 开发的库？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Rust 正在逐步取代 C 语言成为 Python 的高性能后端支撑。文章介绍了 Rust 相比 C 的优势所在，介绍了用 Rust 开发的一些知名的 Python 库。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://www.alexmolas.com/2024/02/05/a-search-engine-in-80-lines.html&quot;&gt;80 行 Python 实现一个搜索引擎&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这篇文章略微标题党了，但是文章介绍的内容很完整：基于 RSS 的异步爬虫、倒排索引、搜索排名、基于 FastAPI 的 Web 网页。可以学习搜索引擎的工作原理，学习从数据获取、数据解析、开放接口、到网页呈现的项目开发流程。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://blog.mattstuchlik.com/2024/02/08/counting-cpu-instructions-in-python.html&quot;&gt;如何计算 Python 中的 CPU 指令数？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;你知道执行 Python 的 &lt;code&gt;print(&quot;Hello&quot;)&lt;/code&gt; 大约需要多少个 CPU 指令么？答案是 17000。导入 &lt;code&gt;seaborn&lt;/code&gt; 则需要大约 20 亿个。作者开发了 &lt;a href=&quot;https://github.com/s7nfo/Cirron&quot;&gt;Cirron&lt;/a&gt; 库以计算 CPU 指令数、分支未命中数及代码的时间损耗等指标。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://www.kawabangga.com/posts/5757&quot;&gt;Python 复用装饰器代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;有多个装饰器要加在不同的函数上，而且相同的装饰器可能有不同传参，如何复用这些装饰器？问题初看可能不好理解，文章中有直观示例和解决过程，可以加深你对装饰器的理解和掌握高阶运用。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://jacobpadilla.com/articles/handling-asyncio-tasks&quot;&gt;像专业人士一样处理 Asyncio 任务&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何理解 Asyncio 中的 Task 对象？Asyncio 协程的工作原理是什么？如何等待一个任务，又如何等待多个或一组任务？文章介绍了 Asyncio 的工作原理以及任务处理相关的函数用法。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://martinheinz.dev/blog/108&quot;&gt;使用 textwrap 模块操作字符串&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了 &lt;code&gt;textwrap&lt;/code&gt; 库的几个主要功能，例如 shorten() 裁剪字符串长度、wrap() 将字符串等宽分割、dedent() 处理字符串缩进等。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://www.nicholashairs.com/posts/major-changes-between-python-versions/&quot;&gt;总结 Python 版本间的主要变更点&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 的一些新特性是在什么版本引入的？作者为了方便，梳理了一些重要语法和标准库的变更记录，同时也指出了每个版本终止维护的时间（例如 Python 3.8 将在今年 10 月 EOL）。（附：这个&lt;a href=&quot;https://endoflife.date/python&quot;&gt;网站&lt;/a&gt;可以查看 Python 及很多项目的 EOL 时间）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://leontrolski.github.io/postgres-as-queue.html&quot;&gt;将 Postgres 作为队列使用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;直接将数据库作为队列使用，性能会不会很受影响？作者测试的结果是影响很小。具体该如何实现将 Postgres 作为队列使用？如何处理锁和事务、任务重试、处理任务超时等问题？&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://learndjango.com/tutorials/20-django-packages-i-use-every-project&quot;&gt;我在所有 Django 项目中都用的 20 个包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Django 框架适用于构建复杂的 Web 项目，作者介绍了自己常用的 20 软件包，在 Django 自身的核心功能之外，提供了更丰富的功能。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://dev.to/anbagu/real-case-of-python-metaclass-application-2pj8&quot;&gt;Python 元类的真实案例&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 中的元类是什么？为什么要学习元类？这个高级特性并不常用，但值得学习了解。文章介绍了元类的工作原理，并用现实例子演示它的强大用途。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://blog.coiled.io/blog/1trc.html&quot;&gt;一万亿行气象数据的编程挑战&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个编程挑战项目：有 100,000 个文件，每个文件 1000 万行，计算每个气象站的最低、平均和最高温度。数据存储在 S3 上，总大小 2.5 TB。作者给出了自己的实现（运行 8.5 分钟），以及优化成本的方案。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁每 30 期为一季，第一季的精华内容已整理成一篇，方便你随时查看。在线访问地址：&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;Python 潮流周刊第一季精华合集（1~30）&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/astral-sh/uv&quot;&gt;uv：性能极快的 Python 包安装和解析器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用 Rust 开发的速度极快的 Python 包安装器和解析器。Ruff 团队作品。可直接替换 &lt;code&gt;pip&lt;/code&gt; 、 &lt;code&gt;pip-tools&lt;/code&gt; 和 &lt;code&gt;virtualenv&lt;/code&gt; 常用命令。（star 6.6K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/coleifer/sqlite-web&quot;&gt;sqlite-web：基于 Web 的 SQLite 数据库工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于 Flask 开发的 Web 端 SQLite 管理工具，可视化管理数据库、数据表、数据项和索引等，支持 JSON 和 CSV 格式文件的导入导出。（star 2.6K）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/danihodovic/celery-exporter&quot;&gt;celery-exporter：导出 Celery 指标用于 Prometheus&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;实时获取 Celery 的任务状态、工作线程、活动任务数等监控指标，遵循 Prometheus 导出器最佳实践，并利用 Celery-mixin 提供了 Grafana 仪表板及 Prometheus 告警功能。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/asottile/pyupgrade&quot;&gt;pyupgrade：自动升级 Python 较新版本的语法 &lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个强力的工具和 pre-commit 钩子，可以自动删除冗余写法、用新语法重写过时的代码、用更优雅的写法重构代码，等等。项目文档中给出了很多例子，推荐阅读。（star 3.2K）&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 两个重写成字典推导式的示例&lt;/span&gt;
&lt;span&gt;-&lt;/span&gt;&lt;span&gt;dict&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; b&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; a&lt;span&gt;,&lt;/span&gt; b &lt;span&gt;in&lt;/span&gt; y&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;a&lt;span&gt;:&lt;/span&gt; b &lt;span&gt;for&lt;/span&gt; a&lt;span&gt;,&lt;/span&gt; b &lt;span&gt;in&lt;/span&gt; y&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;-&lt;/span&gt;&lt;span&gt;dict&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; b&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; a&lt;span&gt;,&lt;/span&gt; b &lt;span&gt;in&lt;/span&gt; y&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;a&lt;span&gt;:&lt;/span&gt; b &lt;span&gt;for&lt;/span&gt; a&lt;span&gt;,&lt;/span&gt; b &lt;span&gt;in&lt;/span&gt; y&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;5、&lt;a href=&quot;https://github.com/ollama/ollama-python&quot;&gt;ollama-python： Ollama Python 库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;支持 Python 3.8+，简单快速集成 Llama 2、Code Llama、mistral、gemma 等大语言模型，可自定义客户端，还可创建异步客户端。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/dvcoolarun/web2pdf&quot;&gt;web2pdf：将网页转换为 PDF 的 CLI&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个命令行工具，可将网页转换为格式精美的 pdf。支持批量转换、自定义样式、附加 CSS、复杂布局、页码、目录和分页符等功能。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/cfahlgren1/natural-sql&quot;&gt;natural-sql：文本生成 SQL 的大语言模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;NaturalSQL-7B 是拥有超高准确性的文本生成 SQL 大模型，在 SQL-Eval 基准测试中领先 GPT-3.5-turbo 和 claude-2，也领先于同数据规模的 sqlcoder-7b。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/AbanteAI/rawdog&quot;&gt;rawdog：在 CLI 中自动生成并执行 Python 脚本&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Rawdog（具有确定性输出生成的递归增强）是 RAG（检索增强生成）的一种新颖替代方案，可以自己运行脚本并获取输出作为上下文，然后再次调用自己。演示视频的例子很惊艳。（star 1.6K）&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/microsoft/UFO&quot;&gt;UFO：基于 UI 与 Windows 系统交互的 AI 代理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;微软新推出的 AI 代理框架，可无缝跨多应用操作，完成用户的复杂任务。使用 GPT-Vision 的多模态功能来理解应用 UI，使用 Windows UI 自动化控件交互。（star 1.9K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/Textualize/toolong&quot;&gt;toolong：查看、跟踪、合并和搜索日志文件（以及 JSONL）的终端应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在命令行终端快速查看日志文件，支持实时尾随、语法高亮、快捷搜索、自动检测时间戳合并日志等功能，支持 JSONL 文件，可自动打开 .bz 和 .bz2 文件。（star 2K）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/OwlAIProject/Owl&quot;&gt;Owl：在本地运行的个人可穿戴 AI&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在可穿戴设备上搭载 AI，倾听和观察你生活中发生的一切。支持 ESP 平台、Sony Spresense 或 Apple Watch 等硬件，支持本地和在线模型，多模态采集，说话人验证等。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/hyperdiv/hyperdiv&quot;&gt;hyperdiv：用 Python 构建响应式 Web UI&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个用 Python 快速开发响应式 UI 应用的框架，具有内置组件、简洁的即时模式语法和少量的工具样板。支持 Shoelace 组件，支持 Markdown，集成 Chart.js 图表，支持读写浏览器缓存，支持表单验证等。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://github.com/danielmiessler/fabric&quot;&gt;fabric：使用 AI 增强人类&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个项目旨在使每个人能将 AI 用于解决日常问题。它的方法是将问题拆解成很多独立组件，使用结构化的清晰提示让 AI 完成任务。（star 5.6K）&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://engineering.fb.com/2024/02/12/developer-tools/meta-loves-python/&quot;&gt;Meta 喜欢 Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Meta 官方的一期播客节目，讨论了开发团队对最新 Python 版本的贡献，包括允许自定义 JIT（如 Cinder）的新钩子、永生对象、对类型系统的改进、更快的推导式等等。Meta 对 Python 社区的贡献确实很足哦~（附：&lt;a href=&quot;https://pythoncat.top/posts/2022-11-21-sponsors&quot;&gt;谷歌、微软、Meta？谁才是 Python 最大的金主？&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://talkpython.fm/episodes/show/449/building-uis-in-python-with-fastui&quot;&gt;Talk Python To Me #449：使用 FastUI 构建 UI&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;FastUI 是一个 Web 界面开发框架，可使用 React 构建响应式 Web 应用，而无需编写任何 JavaScript 或接触 npm。这期播客的嘉宾是该框架的作者。&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#38：Django + Next.js 构建全栈项目</title>
            <link>https://pythoncat.top/posts/2024-02-03-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-02-03-weekly/</guid>
            <description>Python 全栈项目的教程</description>
            <pubDate>Sat, 03 Feb 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯，欢迎关注。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://dev.to/koladev/building-a-fullstack-application-with-django-django-rest-nextjs-3e26&quot;&gt;使用 Django、Django REST 和 Next.js 构建全栈项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Django 和 Nextjs 是后端和前端开发中非常强大 Web 框架，这篇教程用 Django 4.2 和 Next.js 13 开发了一个餐厅菜单管理项目。Python 全栈项目的入门级教程。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://dev.to/andrewbaisden/a-day-in-the-life-of-a-developer-building-a-dashboard-app-with-sql-nodejs-django-and-nextjs-5en7&quot;&gt;使用 SQL、Node.js、Django 和 Next.js 构建仪表板项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;比上一则分享更为全面的 Python 全栈项目教程，除了实现 CURD 操作，还涉及仪表板、表单筛选、Tailwind CSS、不同数据库的使用，以及分别使用 Node.js 和 Django 构建后端等内容。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://pythonspeed.com/articles/numba-profiling/&quot;&gt;用 Profila 分析你的 Numba 代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Numba 是提升 Python 代码性能的常见方案。作者开源了一个 &lt;a href=&quot;https://github.com/pythonspeed/profila&quot;&gt;Profila&lt;/a&gt; 库，专用于分析 Numba 代码本身的性能问题，文章介绍了它的使用方法，以及关于性能分析的三点局限性。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://dev.arie.bovenberg.net/blog/python-datetime-pitfalls/&quot;&gt;Python datetime 标准库的 10 个陷阱&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者分析了&lt;code&gt;datetime&lt;/code&gt; 模块的 10 个陷阱，同时介绍了主流的三方库的情况（例如 &lt;code&gt;arrow&lt;/code&gt; 、&lt;code&gt;pendulum&lt;/code&gt; 、&lt;code&gt;DateType&lt;/code&gt;、&lt;code&gt;heliclockter&lt;/code&gt;），发现它们大多存在同样的问题。什么样才是更好的日期时间库？作者开源了一个库，试图解决文中的问题。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.listendata.com/2024/01/4-ways-to-correct-grammar-with-python.html&quot;&gt;使用 Python 纠正语法的 4 种方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这里的“语法”指的是写作语法，不是编程语法。文章介绍了&lt;code&gt;language-tool-python&lt;/code&gt; 、&lt;code&gt;Gramformer&lt;/code&gt; 、&lt;code&gt;Ginger&lt;/code&gt; 和 &lt;code&gt;pyaspeller&lt;/code&gt; 4 个库用于检查和自动纠正语法错误。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://www.syntaxerror.tech/syntax-error-11-debugging-python/&quot;&gt;Python 调试技巧&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是作者在 2023 PyCon Sweden 演讲的文字版，分享了他的调试思维、调试工具和技术，工具例如&lt;code&gt;snoop&lt;/code&gt;、&lt;code&gt;pdb/ipdb&lt;/code&gt;、&lt;code&gt;PuDB&lt;/code&gt;、&lt;code&gt;web-pdb&lt;/code&gt;、&lt;code&gt;birdseye&lt;/code&gt;、&lt;code&gt;Kolo&lt;/code&gt; 等等。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://developer.nvidia.com/blog/debugging-mixed-python-and-c-language-stack/&quot;&gt;调试 Python 与 C 语言混合的项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;调试很难，跨多语言调试更难。文章介绍了如何调试多语言问题，使用 GDB 来调试 Python+C 语言，定位和解决死锁问题，分享了一些调试的经验。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://www.bitecode.dev/p/analyzing-sorting-a-million-32-bit&quot;&gt;分析“使用 Python 和 2MB RAM 对一百万个 32 位整数进行排序”&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Guido 在 2008 年写了 &lt;a href=&quot;http://neopythonic.blogspot.com/2008/10/sorting-million-32-bit-integers-in-2mb.html&quot;&gt;Sorting a million 32-bit integers in 2MB of RAM using Python&lt;/a&gt; ，这篇文章是对它作的分析解读。解决方案中用到了不太常见的模块：&lt;code&gt;struct&lt;/code&gt;、&lt;code&gt;array&lt;/code&gt;、&lt;code&gt;heapq&lt;/code&gt; ，也用了上下文管理器和生成器等技术。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://tomassetti.me/implement-parsers-with-pylasu/&quot;&gt;使用 Python + Pylasu 实现语言解析器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何用 Python 开发一个解析器？这篇教程用&lt;code&gt;Pylasu&lt;/code&gt; 定义 AST，使用&lt;code&gt;ANTLR&lt;/code&gt; 生成解析器，实现从 ANTLR 解析树到 Pylasu AST 的转换，最后构建出带 CLI 的玩具编程语言解析器。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://qsantos.fr/2024/01/04/dynamic-programming-is-not-black-magic/&quot;&gt;动态规划不是黑魔法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;动态规划什么编程技术？相比其它方案，它的特点和优势是什么？文章从常见编程问题出发，使用缓存、优化缓存、动态规划逐步深入，揭开动态规划的神秘面纱。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://typing.readthedocs.io/en/latest/source/typing_anti_pitch.html&quot;&gt;什么时候应避免静态类型检查？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 支持用类型提示，但这并不是强制的。事实上，有很多情况下并不建议使用类型提示。&lt;code&gt;typing&lt;/code&gt; 模块的这篇文档列举了一些不推荐使用类型提示的原因。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://christophergs.com/blog/running-open-source-llms-in-python&quot;&gt;实用指南：用 Python 运行开源的 LLM&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在个人笔记本电脑上如何运行大语言模型？这篇教程介绍了在不同操作系统上运行&lt;code&gt;llama.cpp&lt;/code&gt; 的完整过程，例如选择和下载模型、提示词设置、使用 GBNF 语法格式化 LLM 输出、流式响应、多模态模型等。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁每 30 期为一季，第一季的精华内容已整理成一篇，方便你随时查看。在线访问地址：&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;Python 潮流周刊第一季精华合集（1~30）&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/InkboxSoftware/excelCPU&quot;&gt;excelCPU：用 Excel 实现的 16 位 CPU 和相关文件&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;才发布一周就已近 3K star 的火爆项目！&lt;code&gt;CPU.xlsx&lt;/code&gt; 文件提供了 16 位 CPU、16 个通用寄存器、128KB RAM 和 128x128 显示区域。使用 Python 进行编译。（star 3K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/ariebovenberg/whenever&quot;&gt;whenever：万无一失的 Python 日期时间&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;前文提及过的日期时间库，克服了标准库和其它三方库没有很好解决的一些问题。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/deepseek-ai/deepseek-coder/&quot;&gt;DeepSeek-Coder：让代码自己编写&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它由一系列代码语言模型组成，每个模型都用 2T token 训练，提供多种型号尺寸，拥有高级代码补全能力，在各项基准测试中表现亮眼。（star 4.3K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/igorbenav/fastcrud&quot;&gt;fastcrud：FastAPI 的异步 CRUD 操作&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;特性有：完全异步、SQLAlchemy 2.0、强大的 CRUD、动态构建复杂查询、高级 SQL 联结、基于偏移或光标的分页、模块化可扩展、自动生成接口。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/leptonai/leptonai&quot;&gt;leptonai：简化 AI 服务构建的 Pythonic 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;让你轻松用 Python 代码构建 AI 服务，主要特性：良好的抽象、仅需几行代码即可启动模型、内置常见模型（如 Llama、SDXL、Whisper 等）的示例、自动批处理、后台任务等。（star 1.9K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/assafelovic/gpt-newspaper&quot;&gt;gpt-newspaper：用 GPT 创建个性化报纸&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;让 AI 根据你的个人品味和兴趣来策划选题、撰写、设计和编辑内容，由 6 个专业 agent 组成，支持搜索网络最新内容，聚合知名的新闻源。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/caronc/apprise&quot;&gt;apprise：几乎适用于所有平台的通知推送&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;纯 Python 开发的轻量型消息推送库，支持通过大多数服务发送通知，例如 Telegram、Discord、Slack、Amazon SNS、Gotify 等等等，支持短信、邮件、系统桌面等多种形式。（star 9.7K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/procrastinate-org/procrastinate&quot;&gt;procrastinate：基于 PostgreSQL 的 Python 任务队列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个基于 PostgreSQL 的分布式任务处理库，提供 Django 集成，易于与 ASGI 框架一起使用。支持异步、周期任务、重试、任意任务锁等功能。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/tohojo/flent&quot;&gt;flent：灵活的网络基准测试工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它可以同时运行多个 netperf/iperf/ping 实例并聚合结果，通过交互式 GUI 和可扩展的绘图功能展示数据，支持本地和远程主机，支持采集 CPU 使用率、WiFi、qdisc 和 TCP 套接字统计信息等。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/urllib3/urllib3/releases/tag/2.2.0&quot;&gt;urllib3：新版本支持在浏览器发起 HTTP 请求&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;urllib3&lt;/code&gt; 发布了 2.2.0 版本，支持在&lt;code&gt;Pyodide&lt;/code&gt; 运行时中使用！后者是用在浏览器中的 Python 解释器，也是&lt;code&gt;PyScript&lt;/code&gt; 和 &lt;code&gt;Jupyterlite&lt;/code&gt; 框架的技术基础。这对 Python 的前端开发有重大作用，未来可期。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/dkogan/gnuplotlib&quot;&gt;gnuplotlib：基于 gnuplot 的 numpy 绘图后端&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;Gnuplot&lt;/code&gt; 是一个强大的开源绘图工具，用于生成各种类型的二维和三维图表。这个项目将它与 Numpy 结合，充分利用数据处理和绘图能力。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/wxywb/history_rag&quot;&gt;history_rag：用 RAG 搭建中国历史问答应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;RAG（检索增强生成）+向量数据库搭建一个中国历史知识问答应用，支持“Milvus方案“（本地）和“Zilliz Cloud Pipelines方案”（云上），提供基于&lt;code&gt;gradio&lt;/code&gt;的 Web UI 界面。默认使用 GPT4 模型，可轻松切换其它 LLM。&lt;/div&gt;
&lt;h2&gt;🐢赠书福利&lt;/h2&gt;
&lt;div&gt;不定期的福利活动，本期赠书 &lt;strong&gt;5&lt;/strong&gt; 本《AI 绘画实战：Midjourney从新手到高手》，开奖时间 &lt;strong&gt;2 月 10 日&lt;/strong&gt;（春节）。请给 &lt;strong&gt;Python猫&lt;/strong&gt;公众号发送数字“&lt;strong&gt;8038&lt;/strong&gt;”，获取抽奖小程序码。&lt;/div&gt;
&lt;div&gt;这本书介绍了 Midjourney 绘画的各种使用方法与技巧，从基础理论到实战应用，一本书轻松玩转当下最火的 AI 绘画，带你领略无限艺术可能。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#37：Python “令人失望”的动态类型超能力</title>
            <link>https://pythoncat.top/posts/2024-01-27-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-01-27-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目</description>
            <pubDate>Sat, 27 Jan 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯，欢迎关注。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.bitecode.dev/p/xmas-decorations-part-3&quot;&gt;Python 装饰器的 3 个真实案例&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是作者装饰器系列文章的第三篇，从很多开源库的现实用法中提取出了三个通用型用法：拦截调用、作函数注册、丰富函数行为。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://death.andgravity.com/lru-cache&quot;&gt;这不是面试建议：Python 不用堆和树实现按优先级过期的 LRU 缓存&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;假如这是一家超级大公司的面试题，不使用堆和二叉搜索树，如何实现标题的算法？文章通过最小合理方案，一步步提出问题再优化代码，并比较各种方案的时间复杂度，可以学到很多东西。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://madebyme.today/blog/python-dict-vs-curly-brackets/&quot;&gt;Python dict() 和 {} 的性能分析&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 创建字典的两种写法 dict() 与 {} 有什么区别？文章通过它们的字节码和 CPython 解释器源码进行了深度分析。单纯看性能，结论是：{} 要比 dict() 快。（附：Python 为什么系列曾写过 &lt;a href=&quot;https://pythoncat.top/posts/2020-10-14-list&quot;&gt;Python 疑难问题：[] 与 list() 哪个快？为什么快？快多少呢？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://www.taipy.io/posts/augmenting-the-markdown-language-for-great-python-graphical-interfaces&quot;&gt;增强 Markdown 语言以实现出色的 Python 图形界面&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Taipy&lt;/strong&gt; 团队开发了增强型 Markdown API，通过添加标签在内容中生成图形界面元素。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://medium.com/techtofreedom/7-python-memory-optimization-tricks-to-enhance-your-codes-efficiency-5ef65bf415e7&quot;&gt;7 个 Python 内存优化技巧&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了 Python 中 7 个可以优化内存的技巧：在类定义中使用__slots__、使用生成器、使用&lt;code&gt;mmap&lt;/code&gt; 作大文件处理、减少使用全局变量、利用逻辑运算符的短路求值、选择合适的数据类型、使用字符串驻留技术。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://rushter.com/blog/python-garbage-collector/&quot;&gt;Python 中的垃圾回收：你需要知道的事情&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 垃圾回收是如何实现的？CPython 为什么使用引用计数？分代垃圾回收器可以解决什么问题？如何查看和调试引用周期？&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://testdriven.io/blog/postgres-vs-dynamodb/&quot;&gt;Postgres 与 DynamoDB：该选择哪个数据库？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Postgres&lt;/strong&gt; 和 &lt;strong&gt;DynamoDB&lt;/strong&gt; 两种数据库分别是如何使用的？应该如何选择？文章比较了它们的 ORM、查询、性能、备份、迁移等方面，并根据不同场景给出了方案选型的建议。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://blog.streamlit.io/crafting-a-dashboard-app-in-python-using-streamlit/&quot;&gt;使用 Streamlit 在 Python 中创建仪表板&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇详细的官方博客教程，使用 Pandas 作数据整理，用 Altair/Plotly 作数据可视化，用 Streamlit 作前端。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://bernsteinbear.com/blog/scrapscript/&quot;&gt;scrapscript.py 编程语言的实现过程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;Scrapscript&lt;/code&gt; 是一种小型、纯粹、函数型、内容可寻址、网络优先的编程语言，作者介绍了它的设计原则、特性、已实现和开发中的功能，以及使用 Python 实现的过程。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://blog.trailofbits.com/2024/01/25/we-build-x-509-chains-so-you-dont-have-to/&quot;&gt;Python Cryptography 已支持 X.509&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;X.509 是一种 PKI 标准，用于定义数字证书的格式和标准化证书的属性。&lt;strong&gt;Cryptography&lt;/strong&gt; 的 42.0.0 版本提供了 X.509 相关 API，文章介绍了它的重要意义、解决的相关问题。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://buttondown.email/hillelwayne/archive/i-am-disappointed-by-dynamic-typing/&quot;&gt;我对动态类型感到失望&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者感到失望的原因不是动态类型相比静态类型有什么缺点，而是认为 Python 没有充分利用动态类型的优势。动态不是静态的对立面，动态是可在运行时变更类型。作者希望增强动态分析的能力，希望动态类型的“test amplification”更容易，而不是转向类型注释或静态类型。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://lukeplant.me.uk/blog/posts/pythons-disappointing-superpowers/&quot;&gt;Python “令人失望”的超能力&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这篇文章是对上一则分享的回应，通过 Werkzeug、Pony、Django、fluent-compile、Pytest 等库使用到的神奇技术（猴子补丁和动态元编程），说明 Python 动态类型的超能力。Python 能做的事或许超出你想象。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁每 30 期为一季，第一季的精华内容已整理成一篇，方便你随时查看。在线访问地址：&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;Python 潮流周刊第一季精华合集（1~30）&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/cheshire-cat-ai/core&quot;&gt;core：可用于生产的 AI 助手框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个基于任意大语言模型构建自定义 AI 的框架，使用 Docker 部署。API 优先，支持插件扩展，带管理面板，记忆对话和文档。（star 1.6K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/JoshuaKasa/van-gonography&quot;&gt;van-gonography：将任意类型的文件隐藏在一张图像中&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;支持将任意类型文件隐藏在一张图像中，不影响图像的视觉效果。支持图像解码、图像比较、CLI、UI、跨平台、加密与压缩等功能。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/mpmath/mpmath&quot;&gt;mpmath：任意精度的浮点数运算&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;支持高精度的实数和复数浮点数运算，提供了大量特殊的用于数学运算的函数。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/roshanlam/sqlite-worker&quot;&gt;sqlite-worker：在多线程应用中轻松管理 SQLite&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;为 SQLite 数据库操作提供线程安全的接口，基于队列的语句执行。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/emmett-framework/granian&quot;&gt;granian：用于 Python 程序的 Rust HTTP server&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用 Rust 实现的单一 HTTP 实现，避免常见的 Gunicorn + uvicorn + http-tools 依赖组合。支持 ASGI/3、RSGI 和 WSGI 接口应用，支持 HTTP/1 和 HTTP/2 协议。（star 1.5K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/volfpeter/fasthx&quot;&gt;fasthx：FastAPI + HTMX 开发框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;FastAPI + HTMX 的组合，主要特点：装饰器语法、支持任意模板引擎和服务器端渲染库、内置 Jinja2、同时支持 HTMX 请求和普通请求、支持同步和异步路由……&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/stas00/ml-engineering&quot;&gt;ml-engineering：机器学习工程开源书籍&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一本适合 LLM/VLM 训练工程师和操作员的技术手册，可帮助成功训练大型语言模型和多模态模型。（star 6.9K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/sgl-project/sglang&quot;&gt;sglang：专为大型语言模型设计的结构化生成语言&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;通过同时设计前端语言和运行时系统，使交互 LLMs 更快、更可控。支持多个链式生成调用、高级提示技术、控制流、多模态、并行和外部交互，具有 RadixAttention 的高性能运行时。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/father-bot/chatgpt_telegram_bot&quot;&gt;chatgpt_telegram_bot：ChatGPT Telegram 机器人，无限制用 GPT-4 &lt;/a&gt;&lt;/div&gt;
&lt;div&gt;将 ChatGPT 部署成自己的 Telegram 机器人，支持 GPT-4、GPT-4 Turbo 和 DALLE 2，支持群聊，内置 15 种特殊对话模式，支持查看 OpenAI API 花费等功能。 （star 4.5K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/InternLM/HuixiangDou&quot;&gt;HuixiangDou：基于 LLM 的领域知识助手&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它的中文名是“茴香豆”，提出一套解答技术问题的算法 pipeline，部署成本低，支持群聊这类复杂场景，支持微信群、lark 群组、飞书群、钉钉机器人等 IM。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/ZHO-ZHO-ZHO/ComfyUI-InstantID&quot;&gt;ComfyUI-InstantID：ComfyUI 的 InstantID 的非官方实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用 ID Base 模型、InsightFace 模型、ID ControlNet 模型、Ipadapter_instantid 等模型，官方提供 8 种风格。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/ZHO-ZHO-ZHO/ComfyUI-PhotoMaker-ZHO&quot;&gt;ComfyUI-PhotoMaker-ZHO：ComfyUI 的 PhotoMaker 的非官方实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;支持 lora、支持多批次、支持通用的 styler，官方提供 10 种风格。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#36：Python 打包生态依然不乐观</title>
            <link>https://pythoncat.top/posts/2024-01-20-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-01-20-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目</description>
            <pubDate>Sat, 20 Jan 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯，欢迎关注。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://chriswarrick.com/blog/2024/01/15/python-packaging-one-year-later/&quot;&gt;一年后的 Python 打包：回顾 2023 年 Python 的打包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者一年前吐槽了 Python 打包的悲惨状况，一年后再看，有什么改善么？还是变得更糟糕了呢？文章讨论了社区里主流的打包工具、PEP 标准及其落实情况，尽管有不少新东西，但看起来还是很黯淡。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://techtalksweekly.substack.com/p/all-pycon-2023-talks-sorted-by-views&quot;&gt;PyCon 2023（美国和澳大利亚）所有演讲视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章整理了去年 PyCon US 和 Python AU 的 243 个视频，按照 Youtube 播放数排序。都不算多，而且第一名和第二名的差距非常之大。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://thiagowfx.github.io/2024/01/synchronized-in-python/&quot;&gt;Python 的 Synchronized&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Java 中用&lt;code&gt;synchronized&lt;/code&gt; 关键字可以保证变量是线程安全的，Python 中有什么东西可以达到相同效果么？文章介绍了&lt;code&gt;threading &lt;/code&gt; 模块的 Lock + 上下文管理器 + 装饰器的实现方案。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://bernsteinbear.com/blog/typed-c-extensions/&quot;&gt;更快的 Python C 扩展的类型信息&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PyPy 是一个 Python 解释器，它的 C API 兼容层存在一些性能问题，作者正在研究使 PyPy 的 C API 变快方法，文章介绍了他们所做的工作。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://medium.com/@ms.carmen.alvarez/comparing-coroutines-by-example-in-kotlin-and-python-7e60746eae18&quot;&gt;通过示例比较 Kotlin 和 Python 中的协程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者在用 Python 和 Kotlin 开发时，都接触了协程，因此写了几篇文章来比较它们的用法、分析它们的细节和工作原理，涉及文件读写、HTTP 请求、序列和生成器，可以加深你对协程的理解。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://dev.arie.bovenberg.net/blog/pydantic-timestamps/&quot;&gt;Pydantic 处理 1970 年代时间的奇特问题&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Pydantic 在处理 Unix 时间戳时会猜测是以秒还是毫秒为单位，但这遇到 1970 年的时间就有问题啦！众所周知，计算机世界的时间戳从 1970-1-1 开始（UNIX 纪元），这意味着早期的时间戳位数少，若当成秒级换算的话，谬之几十年！&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://antonz.org/in-browser-code-playgrounds/&quot;&gt;浏览器上的代码游乐场&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何在浏览器上实时执行代码片段？作者基于 WASI，开源了一个工具，可以在浏览器上执行 Python、PHP、Ruby、Lua、Javascript 和 SQLite 代码片段。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://blog.pecar.me/django-sqlite-dblock&quot;&gt;SQLite 的“database is locked”错误&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;多线程环境中使用 SQLite，可能会出现“database is locked”错误，文章分析了两大原因（SQLite 等待锁超时、在事务读取后写入），介绍了对应的解决方案，特别提及 Django 本身提供的解决方案。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://www.cnblogs.com/traditional/p/17959796&quot;&gt;数据处理神器可不止 Pandas 哦，还有 Polars，全方位解析 Polars&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Polars 是基于 Rust + Arrow 实现的高性能 Python 数据处理库，这篇教程全方位介绍了 Polars 的相关知识。（附：另一篇同样主题的文章 &lt;a href=&quot;https://pbpython.com/polars-intro.html&quot;&gt;Polars 实用教程&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://ricardoanderegg.com/posts/python-build-html-components-lxml/&quot;&gt;用 Python 函数构建 HTML 组件&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何在 Python 中实现类似 React 的组件？作者准备用纯 Python 函数生成 HTML，使用&lt;code&gt;lxml&lt;/code&gt; 库来渲染，文章介绍了一些基本的尝试，验证可行性。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://explainextended.com/2023/12/31/happy-new-year-15/&quot;&gt;500 行 SQL 实现一个 GPT&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用 SQL 能否实现一个大语言模型呢？ChatGPT 说这超出了 SQL 的能力。但是，作者不这样认为！文章详细介绍了实现 GPT 所需的相关知识，最终用 500 行 SQL 实现了出来！（附：作者从 2010 年以来每年用 SQL 实现一件不可思议的事，比如 &lt;a href=&quot;https://explainextended.com/2022/12/31/happy-new-year-14/&quot;&gt;用 SQL 求解魔方&lt;/a&gt; 、&lt;a href=&quot;https://explainextended.com/2021/12/31/happy-new-year-13/&quot;&gt;用 SQL 实现量子计算机模拟器&lt;/a&gt; ……）&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁每 30 期为一季，第一季的精华内容已整理成一篇，方便你随时查看。在线访问地址：&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;Python 潮流周刊第一季精华合集（1~30）&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/jawah/niquests&quot;&gt;niquests：使用 HTTP/3、HTTP/2，支持异步的 requests&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;requests 库的直接替代，具有 HTTP/3、HTTP/2、多路复用连接、系统 CA、证书吊销、HTTPS/TLS/QUIC 或 UDP 上的 DNS、异步、DNSSEC，消除了 requests 的很多缺点。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/ariebovenberg/slotscheck/&quot;&gt;slotscheck：确保你的__slots__正常工作&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 的 &lt;code&gt;__slot__&lt;/code&gt; 变量可以减少实例内存，防止添加动态属性。但要正常工作，所有基类都要实现它。这个库可以检查它是否损坏、重叠、冗余，提供了 pre-commit 钩子。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/holoviz/panel&quot;&gt;panel：强大的数据探索和 Web 应用框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;支持拖拽小部件、绘图、表格和其它可查看的 Python 对象组合到自定义分析工具和仪表板中，支持大量可视化工具，支持 &lt;strong&gt;ipywidgets&lt;/strong&gt; 。（star 3.7K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/netease-youdao/QAnything&quot;&gt;QAnything：基于任何东西的问答&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;支持任意格式文件或数据库的本地知识库问答系统，可断网安装使用。一键安装部署，支持跨语种问答，支持选择多知识库问答。（star 1.9K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/see2023/Bert-VITS2-ext&quot;&gt;Bert-VITS2-ext: 基于 Bert-VITS2 做的表情、动画测试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;TTS 同步产生脸部表情数据、声音到表情、生成身体动画。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/drunkdream/weread-exporter&quot;&gt;weread-exporter: 将微信读书中的书籍导出成 epub、pdf、mobi 等格式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;通过 Hook Web 页面中的 Canvas 函数，获取文本及样式等信息，转换成 Markdown 格式，最终转换成 Epub、PDF 和 Mobi 格式。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/hogan-tech/leetcode-solution&quot;&gt;leetcode-solution：用 Python 解各种 LeetCode 问题&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个项目收录了 400 多道 LeetCode 题目和不同语言的答案。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/HaujetZhao/CapsWriter-Offline&quot;&gt;CapsWriter-Offline: CapsWriter 离线版，好用的 PC 端语音输入工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个 PC 端的语音输入、字幕转录工具，完全离线、无限时长、低延迟、高准确率、中英混输、自动阿拉伯数字、自动调整中英间隔。支持热词功能、日记功能、转录功能等。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/VikParuchuri/surya&quot;&gt;surya：任何语言的准确行级文本检测和识别 （OCR）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个多语言文档 OCR 工具包，支持准确的行级文本检测。缺点是不适用于图片和手写文本。（star 3.6K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/RVC-Boss/GPT-SoVITS&quot;&gt;GPT-SoVITS：1分钟的语音也可训练一个好的 TTS 模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;强大的短镜头语音转换和文本转语音 WebUI，Zero-shot TTS、Few-shot TTS、跨语言支持、W	ebUI 工具。（star 2.7K）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/NVIDIA/trt-llm-rag-windows&quot;&gt;trt-llm-rag-windows：使用 TensorRTLLM 在 Windows 上创建 RAG 聊天机器人&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个 Windows 上的 RAG 演示项目，基于 LLaMa 2 13B 模型、TensorRT-LLM 和 FAISS 向量搜索库。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/EmbraceAGI/LangGPT&quot;&gt;LangGPT：让每个人都能成为提示词专家&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;以结构化、模板化的方式编写高质量 ChatGPT prompt，克服普通 Prompt 创建时缺乏系统性、缺乏灵活性等缺点。（star 2.8K）&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#35：Python JIT 编译器和 Numpy2 即将推出</title>
            <link>https://pythoncat.top/posts/2024-01-13-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-01-13-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目，2 则热门讨论</description>
            <pubDate>Sat, 13 Jan 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯，欢迎关注。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://tonybaloney.github.io/posts/python-gets-a-jit.html&quot;&gt;Python 3.13 也有了 JIT 编译器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;JIT（Just in Time）是什么？它的工作原理是怎样的？Python + JIT 能带来什么好处？copy-and-patch JIT 是 2021 年提出的设计，专为动态语言运行时而设计的高速算法。Python 3.13 有望实现它！上期周刊的第一则分享是关于它，本期我们继续哈~&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://pythonspeed.com/articles/numpy-2/&quot;&gt;NumPy 2 即将推出：防止破坏，更新你的代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;NumPy 2 是一个重要的大版本，预计于 2024 年 3-4 月发布。它是一个不向后兼容版本，为了确保我们的应用不被破坏，有必要提前做些准备。文章介绍了新版本的不兼容修改、如何确保在合适的时机再安装新版本、如何轻松升级你的代码。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://cerfacs.fr/coop/fortran-vs-python&quot;&gt;Python 反直觉地在科学计算中兴起&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章提出了一个疑问：在关注性能的科学计算领域，以前很流行 Fortran，为什么现在越来越多使用性能较慢的 Python？原因也许是人们高估了执行速度的重要性，编程的敏捷性和项目的可维护性更重要，而且替代方案的性能也不差。（附：&lt;a href=&quot;https://fortran-lang.discourse.group/t/the-counter-intuitive-rise-of-python-in-scientific-computing/469&quot;&gt;Fortran 社区的讨论&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://samukweku.github.io/data-wrangling-blog/notebooks/Fast-and-Efficient-Inequality-Joins-in-Pandas.html&quot;&gt;在 Pandas 中实现快速高效的不等价连接&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Pandas 支持用 &lt;strong&gt;merge&lt;/strong&gt; 和 &lt;strong&gt;join&lt;/strong&gt; 函数实现等价连接，但是不等价连接怎么办呢？文章介绍了两种比常规笛卡尔连接更好的方案：使用&lt;code&gt;pyjanitor&lt;/code&gt; 库的 conditional_join 函数，既节省内存又不损性能；使用&lt;code&gt;DuckDB&lt;/code&gt; 的 SQL 查询 DataFrame，性能极高。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.influxdata.com/blog/pandas-profiling-tutorial/&quot;&gt;Pandas Profiling：详细介绍它的使用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;Pandas profiling&lt;/code&gt; 是一个很流行的库（已改名&lt;code&gt;ydata-profiling&lt;/code&gt;），仅需一行代码就能生成数据集的分析报告。这篇教程介绍了它的工作原理、如何导入和生成报告、分析和处理敏感数据、分析大数据、它的替代库及它的缺点等内容。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://jacobpadilla.com/articles/Functools-Deep-Dive&quot;&gt;深入了解 Python 的 functools.wraps 装饰器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 装饰器是我最爱的特性之一。在我们自定义装饰器时，需要考虑元数据的丢失问题，&lt;code&gt;functools.wraps&lt;/code&gt; 很关键。文章介绍了它的用处、如何使用它，以及如何传递自定义参数。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://www.da.vidbuchanan.co.uk/blog/python-swar.html&quot;&gt;纯 Python 实现的 SIMD&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者分享了如何用纯 Python 实现 &lt;strong&gt;Game of Life&lt;/strong&gt;（用&lt;code&gt;pysdl2&lt;/code&gt; 作图形输出），以 180fps 的 4K 分辨率运行，比传统的实现加速了 ~3800 倍。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://escape.tech/blog/best-practices-protect-flask-applications/&quot;&gt;保护 Flask 程序的最佳实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;想要提升 Flask 项目的安全性，免受安全漏洞侵害，有哪些最佳的技术实践？文章基于 &lt;strong&gt;OWASP Top 10&lt;/strong&gt; 最常见漏洞，介绍了&lt;code&gt;yaml.safe_load&lt;/code&gt; 加载 JSON、&lt;code&gt;defusedxml&lt;/code&gt; 解析 XML、&lt;code&gt;flask_wtf&lt;/code&gt; 保护表单、 &lt;code&gt;secure_filename&lt;/code&gt; 处理文件路径、防 XSS 和 CSRF 的一些方法、构建安全 API 的 9 个建议，等等内容。涉及 &lt;strong&gt;Flask-SSLify、Flask-RESTful、Flask-HTTPAuth、Flask-JWT-Extended 和 Flask-Limiter&lt;/strong&gt; 等库。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://rednafi.com/python/server_sent_events/&quot;&gt;使用服务器发送事件 （SSE） 将实时更新推送到客户端&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;服务器发送事件 SSE 是 Web 服务器向网页发送实时信息的一种方式，无需页面重复请求。文章用完整的例子介绍了如何用 Python 实现它，最后也指出了它的两点局限性。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://tolkunov.dev/posts/ai-powered-todo-app/&quot;&gt;开发用 AI 驱动的 TODO 应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在人工智能时代，TODO 应用会是什么样子的？作者用 Django + 简单的 HTML + Whisper + mixtral-8x7b-instruct + SQLite 实现了一个 TODO 项目，值得借鉴学习！&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://peps.python.org/pep-0736/&quot;&gt;PEP-736 调用时关键字参数的简写语法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个 PEP 提议引入一个语法糖 &lt;code&gt;f(x=)&lt;/code&gt; ，作为命名参数和值的变量名相同时&lt;code&gt;f(x=x)&lt;/code&gt; 的简写。它与 f-string 的 &lt;code&gt;f&apos;{x=}&apos;&lt;/code&gt; 相似，在 Ruby、JavaScript 和 Rust 中能找到类似的简写。据统计，这种模式占关键字参数用法的 10-20%。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://pythonguides.com/remove-background-from-image-in-python/&quot;&gt;如何用 Python 删除图像中的背景？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这篇教程介绍了如何用&lt;code&gt;Tkinter&lt;/code&gt; 和&lt;code&gt;rembg&lt;/code&gt; 实现移除图像的背景，效果挺不错。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁每 30 期为一季，第一季的精华内容已整理成一篇，方便你随时查看。在线访问地址：&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;Python 潮流周刊第一季精华合集（1~30）&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/ydataai/ydata-profiling&quot;&gt;ydata-profiling：用于 Pandas 和 Spark DataFrame 的数据分析&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;与 Pandas 的&lt;code&gt;df.describe()&lt;/code&gt; 函数一样，ydata-profiling 非常好用，只要一行代码，提供了对 DataFrame 的扩展分析，支持以 html 和 json 等格式输出分析报告。（star 11.7K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/desgeeko/pdfsyntax&quot;&gt;pdfsyntax：检查和修改 PDF 文件内部结构&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是用纯 Python 实现的轻量级库，用于检查和修改 PDF 文件，支持 CLI 和 API 用法。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/tconbeer/harlequin&quot;&gt;harlequin：终端里的 SQL IDE&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在命令行终端里可视化操作 SQL。（star 1.6K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/BerriAI/litellm&quot;&gt;litellm：使用 OpenAI 格式调用所有 LLM API&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用统一的方式调用 LLM，支持 Bedrock、Azure、OpenAI、Cohere、Anthropic、Ollama、Sagemaker、HuggingFace、Replicate 等 100+ LLMs。（star 4.4K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/Unstructured-IO/unstructured&quot;&gt;unstructured：用于 AI 模型的非结构化数据预处理工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;对文档（如 PDF、HTML、WORD等）和图像等非结构化数据作预处理，提供分区、清洗、暂存、提取、分块和嵌入等方法。（star 4.2K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/zhayujie/chatgpt-on-wechat&quot;&gt;chatgpt-on-wechat: 基于大模型搭建的聊天机器人，支持微信、企业微信、公众号、飞书&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可选择 GPT3.5/GPT4.0/Claude/文心一言/讯飞星火/通义千问/Gemini/LinkAI，能处理文本、语音和图片，访问操作系统和互联网，支持基于自有知识库进行定制企业智能客服。（star 19.9K）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/m-bain/whisperX&quot;&gt;whisperX：具有单词级时间戳的自动语音识别&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;对语音识别模型 Whisper 的增强，拥有更准确的时间戳、多说话人检测，并通过增强语音活动检测来减少幻觉，速度更快，占用内存更少。（star 7.4K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://inventwithpython.com/pythongently/&quot;&gt;42 道在线的 Python 编程练习题&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个编程练习网站，提供了 42 道 Python 小项目练习题，有解答思路分析和参考答案。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/mealie-recipes/mealie&quot;&gt;mealie：自托管的食谱管理和膳食计划项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个食谱管理项目，具有 RestAPI 后端和用 Vue 开发的反应式前端。支持 PC、平板和移动端，可使用 url 轻松添加食谱，支持用户管理和群组管理。（star 4.3K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/guardrails-ai/guardrails&quot;&gt;guardrails：给大语言模型添加护栏&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;大语言模型没有按预期回应，有什么办法？这个库可以指定输出结构和类型，可验证和更正大模型的输出，提升内容质量。（star 2.7K）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/Chainlit/chainlit&quot;&gt;chainlit：在几分钟内构建 Python LLM 应用程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;快速构建类型 ChatGPT 的 Web 应用，集成了 Langchain、Autogen、OpenAI Assistant、Llama、Haystack，可自定义前端实现全部功能，包括监控和观测、身份校验机制、多用户、各种工具无缝集成等。（star 4.3K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/functime-org/functime&quot;&gt;functime：用 Polars 构建的时间序列机器学习&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可在大型数据集上进行生产就绪的全局预测和时间序列特征提取，支持时间序列预处理、交叉验证拆分器和预测指标（MASE、SMAPE 等）。&lt;/div&gt;
&lt;h2&gt;🥂讨论&amp;amp;问题&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.v2ex.com/t/1007645&quot;&gt;为什么 Python 会有.venv 虚拟环境的概念？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 为什么需要用虚拟环境？为什么 Python 会用这种包管理机制？包管理软件需要解决什么样的问题？&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.v2ex.com/t/1003544&quot;&gt;Java 如何调用含有第三方依赖的 Python 项目？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在不能调用 API 的情况下，如何让 Java 项目调用 Python 项目？JNI-CPython-Python 方案有什么问题？打包成 EXE 和 so 实现如何？&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#34：Python 3.13 的 JIT 方案又新又好！</title>
            <link>https://pythoncat.top/posts/2024-01-06-weekly/</link>
            <guid>https://pythoncat.top/posts/2024-01-06-weekly/</guid>
            <description>Python 3.13 JIT 的方案出炉了，很喜欢这类的新特性</description>
            <pubDate>Sat, 06 Jan 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯，欢迎关注。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.manjusaka.blog/posts/2024/01/03/a-simple-introduction-about-python-jit/&quot;&gt;简单聊聊 Python 3.13 的 JIT 方案&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 3.13 将引入一个 &lt;strong&gt;copy-and-patch&lt;/strong&gt; JIT 编译器，这项新功能尽可能地利用了 LLVM 生态的东西，编译器用 clang，编译参数开 -o3 获取最大的性能，二进制工具用 llvm-objdump 和 llvm-readelf，方案可谓是又新又好。（附：&lt;a href=&quot;https://coderslegacy.com/python-jit-compilers/&quot;&gt;Python JIT 编译器 - 即时编译&lt;/a&gt; ，分析了主流的 Python JIT 编译器的优缺点（如 PyPy、Numba 和 Cython））&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://hakibenita.com/fast-excel-python&quot;&gt;在 Python 中读取 Excel 的最快方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何用 Python 读取 Excel 文件？文章从速度、类型、正确性三个维度，分别用 &lt;strong&gt;Pandas、Tablib、Openpyxl、LibreOffice、DuckDB 和 Calamine&lt;/strong&gt; 读取 Excel，得出了性能上的排名。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://realpython.com/flask-project/&quot;&gt;Flask 教程：从头开始构建可扩展的 Web 项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Flask 是强大且灵活的 Web 框架，这篇入门教程介绍了如何设置 Flask 项目、开发入门级项目、使用蓝图添加多页面、使用 Jinja 模板、存储静态文件等内容。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://ashvardanian.com/posts/python-c-assembly-comparison/&quot;&gt;Python、C、汇编 - 提高 2500 倍余弦相似度运算&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;余弦相似度是机器学习和信息检索中广泛使用的指标，文章以它为例，介绍了一些底层优化方法，从纯 Python 版本开始，Numpy 导致性能变慢、Scipy 提升 2-5x、C 语言提升 200x、SIMD 内部函数提升 400x、结合 AVX-512 与 BMI2 后 747x、增加 AVX-512FP16 后升至 1260x、使用 AVX-512VNNI 提升 2521x。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://tolkunov.dev/posts/ai-or-not/&quot;&gt;使用 AI 检测 AI 生成的照片&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Stable Diffusion XL&lt;/strong&gt; 和 &lt;strong&gt;Midjourney v6&lt;/strong&gt; 等最新的 AI 模型可以生成极其逼真的图像，人眼已经越来越难以分辨真假。作者训练了一个能够检测 AI 生成图像的分类器，可获得 99% 准确率的结果。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://mathspp.com/blog/max-is-broken&quot;&gt;Python 内置函数 max 有毛病&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者敏锐地发现 &lt;strong&gt;sum、all、any 和 math.prod&lt;/strong&gt; 几个函数在入参为空列表时，都有恰当的默认值，然而 &lt;strong&gt;max&lt;/strong&gt; 和 &lt;strong&gt;min&lt;/strong&gt; 函数却会报错！作者认为它应该等于负无穷大，你们怎么看？&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://juejin.cn/post/7318952376593006633&quot;&gt;App 自动化测试之 Appium 应用篇| Appium 常用 API 及操作&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Appium 是常用的 Android UI 自动化测试工具，文章出自一个 Appium 自动化测试系列教程。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://www.photondesigner.com/articles/instant-messenger&quot;&gt;使用 Django 构建一个实时消息应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何给 Django 应用添加异步的实时事件？不使用 Redis，使用 Django 最新的异步特性。文章演示开发了一个极简的 Web 端即时通讯应用。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://fullspeedpython.com/articles/understanding-numeric-data-types/&quot;&gt;了解 Python 中的数值数据类型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 有哪些常用的数值数据类型？它们有哪些特点，CPython 内部是如何实现的？文章介绍了整数、浮点数和复数类型，以及 &lt;strong&gt;math、decimal 和 fractions&lt;/strong&gt; 三个模块。（附：&lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn/blob/master/StandardsTrack/3141--%E6%95%B0%E5%AD%97%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%B1%82%E7%BA%A7.md&quot;&gt;PEP-3141—数字的类型层级&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://superfastpython.com/asyncio-log-blocking/&quot;&gt;非阻塞的 Asyncio 日志记录&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何在 asyncio 程序中实现非阻塞记录日志？文章介绍了如何用共享的 &lt;strong&gt;Queue&lt;/strong&gt; 和 &lt;strong&gt;QueueHandler&lt;/strong&gt; 来记录日志，并使用 &lt;strong&gt;QueueListener&lt;/strong&gt; 来存储日志。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://read.engineerscodex.com/p/how-instagram-scaled-to-14-million&quot;&gt;Instagram 如何仅凭 3 名工程师实现用户规模 1400 万&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Instagram 在 2010-2011 年从 0 到 1400 万用户，那时仅仅有 3 名工程师！他们用了什么技术栈，有什么成功经验可给我们借鉴的？文章介绍了它使用到的相关技术和实现方案。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/bazelbuild/starlark/blob/master/design.md&quot;&gt;Google 设计的类 Python 编程语言 Starlark&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Google 设计出 Starlark 旨在取代 Python 作为构建描述语言，语法非常相似。这份文档说明了它的一些设计原则，以及跟 Python 语言的诸多差异，比如它的布尔值不是整数、字符串不可迭代、没有“is”运算符、for/if 语句不允许在函数外部使用，等等。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://www.dedp.online/part-1/1-introduction/history-and-state-of-data-engineering.html&quot;&gt;数据工程的历史和现状&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章出自正在连载的免费在线电子书《数据工程设计模式》（Data Engineering Design Patterns）。数据工程经历了 SQL、维度建模、商业智能和大数据、MapReduce 和 Hadoop、云革命等阶段。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁每 30 期为一季，第一季的精华内容已整理成一篇，方便你随时查看。在线访问地址：&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;Python 潮流周刊第一季精华合集（1~30）&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/samuelcolvin/watchfiles&quot;&gt;watchfiles：简单快速的文件监听和代码重新加载&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;简单快速实现对文件的监听，使用 Rust 的&lt;code&gt;Notify&lt;/code&gt; 库处理底层文件系统通知，支持同步和异步监听处理。（star 1.4K）&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; watchfiles &lt;span&gt;import&lt;/span&gt; watch

&lt;span&gt;for&lt;/span&gt; changes &lt;span&gt;in&lt;/span&gt; watch&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;./path/to/dir&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;changes&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;2、&lt;a href=&quot;https://github.com/hylang/hy&quot;&gt;hy：嵌入在 Python 中的 Lisp 方言&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;hy 是 Python 的一种替代语法，与 Python 相比，它提供了各种额外的功能、泛化和语法简化。与其它 Lisp 相比，它提供了对 Python 内置和第三方库的直接访问。（star 4.7K）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/ofek/pyapp&quot;&gt;pyapp：Python 应用的运行时安装器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用 Rust 开发的工具，可构建运行时自启动的 Python 应用程序，为每个平台构建独立的二进制包。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/aio-libs/yarl&quot;&gt;yarl：一个 URL 解析工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;提供了 URL 类，可便利解析和修改 URL，支持通过属性方式访问 url 的每个部分。（star 1K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/marshmallow-code/apispec&quot;&gt;apispec：可插拔的 API 规范生成器，支持 OpenAPI 规范&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;自动生成 API 接口规范文档，支持 OpenAPI 规范（即 Swagger 规范），与框架无关，内置对&lt;code&gt;marshmallow&lt;/code&gt; 的支持。（star 1.1K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/marshmallow-code/marshmallow&quot;&gt;marshmallow：支持复杂对象与简单数据类型相互转换&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;简单的对象序列化库，与 ORM/ODM/框架无关，可用于验证输入数据、序列化与反序列化，提供有丰富的字段类型，支持多种数据格式。（star 6.8K）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/thevahidal/jake&quot;&gt;jake：在 GitHub 上轻松创建和部署自己的单链接网站&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;单链接网站（one-link website）适合用作个人主页，这个网站模板使用 Github Pages 部署，让你轻松省力地构建美观的个人主页。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/jiisanda/docflow&quot;&gt;docflow：功能强大的文档管理 API，无缝上传、下载、组织、版本控制、共享&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;简化文档类的处理操作，支持身份验证和授权、列表权限控制、文档的增删改查、文档预览、版本控制等。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/Frrrrrrrrank/auto_job__find__chatgpt__rpa&quot;&gt;auto_job__find__chatgpt__rpa：基于 ChatGPT 的自动投简历助手&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;国人作品。利用 ChatGPT 根据你的简历和某招聘网站的职位描述，自动匹配和生成求职信息，自动发送给招聘人员。求职寒冬季，祝你好运！&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/davep/oshit&quot;&gt;oshit：放在命令行终端的 Hacker News&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;简化的 Hacker News 阅读客户端，没有登录、投票、发布等功能，支持查看用户和评论信息。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/dvmazur/mixtral-offloading&quot;&gt;mixtral-offloading：在 Colab 或个人电脑上运行 Mixtral-8x7B 模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;实现了对 Mixtral-8x7B 模型的高效推理，需要大约 16 GB 的 VRAM 和 11 GB 的 RAM。（star 1.4K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/PabloLec/RecoverPy&quot;&gt;RecoverPy：以交互方式从终端查找和恢复已删除或覆盖的文件&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文件的数据被覆盖或删除了，还能找回么？这是一个 Linux 上的文件&amp;amp;数据恢复工具，支持文本搜索，支持交互式操作。（star 1.1K）&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://github.com/Meituan-AutoML/MobileVLM&quot;&gt;MobileVLM：美团开源的移动设备视觉语言助手&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在移动设备上运行的多模态视觉语言模型 （MMVLM），有 1.4B 和 2.7B 参数规模，在高通骁龙 888 CPU 和 NVIDIA Jeston Orin GPU 上分别获得每秒 21.5 个 token 和 65.3 个 token 的优秀性能。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.xiaoyuzhoufm.com/episode/65945c8c1e736aa25c935885&quot;&gt; 捕蛇者说 Ep 44. 与 Tualatrix 聊聊独立开发使用的技术栈&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;独立开发者怎么做技术选型？为什么图拉鼎会用 Python 作为自己项目的后端语言？（附：两年前的另一期播客 &lt;a href=&quot;https://www.xiaoyuzhoufm.com/episode/618c9897fad86a854205b2a0&quot;&gt;ByteTalk 3. 跟图拉鼎聊聊独立开发者的那些事&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.youtube.com/watch?v=MoqtsYLGCC4&quot;&gt;给 Pythonistas 的 Rust 编程入门教程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;以面向 Python 开发者的视角来对比和学习 Rust 编程，介绍了主要特性的差异（比如 Python 的类和 Rust 的 struct）。&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 猫的 2023 年终回顾</title>
            <link>https://pythoncat.top/posts/2024-01-01-review/</link>
            <guid>https://pythoncat.top/posts/2024-01-01-review/</guid>
            <description>Python猫已创立5年，我对Python的热情依旧</description>
            <pubDate>Mon, 01 Jan 2024 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;2023 年是 &lt;strong&gt;Python猫&lt;/strong&gt; 创办的第 5 年，2024 年已经到来了，我们照例做一个简短的年终回顾吧。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;1、30000 订阅与 200 原创。&lt;/strong&gt; 2020 的年终总结时，公众号订阅数刚破 20000，3 年后，我们终于也达成了 30K 成就。另外原创文章数也突破了 200 篇。如果你已经关注了，记得加个星标，否则有可能无法及时看到推送。如果你是在其它平台关注的，欢迎也到公众号上&lt;a href=&quot;https://img.pythoncat.top/python_cat.jpg&quot;&gt;点个关注&lt;/a&gt; 呢~~&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;2、Python 潮流周刊。&lt;/strong&gt; 潮流周刊是我们过去一年最大的变化，是我最主要的精力投注之处。现在已更新到第 33 期，我的长期目标是坚持个 5 年。每周一期的周刊目前还需要耗费我比较多时间精力，新一年里计划会做一些自动化和效率提升。周刊里绝大部分内容是英文，中文内容偏少，主要原因是中文的内容创作者偏少/我接触有限，欢迎大家来推荐/自荐。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;3、个人博客。&lt;/strong&gt; 周刊中主要就是分享信息链接，但某些封闭的平台却不支持，这促使我搭建了&lt;a href=&quot;https://pythoncat.top/&quot;&gt;个人博客&lt;/a&gt;，把它作为了自己文章的首发平台。博客每月的浏览量在 10K 左右，新的一年希望能更上一步。Github、Vercel 和 Cloudflare，现在搭建个人博客真是太简单方便了，建议没有博客的同学都去了解和动手一下。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;4、Github 项目。&lt;/strong&gt; &lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;Python 潮流周刊&lt;/a&gt;和 &lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;Python 为什么&lt;/a&gt; 两个项目有幸得到@Barret李靖 的推荐，星星数双双破千了！两个都算是技术科普类项目，希望能让一些新接触 Python 的人增加知识面，真的喜欢上这门语言。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;5、Telegram、Twitter 和 Feedly。&lt;/strong&gt; 过去我不用 Telegram，少用 Twitter，Feedly 则停用了很多年。没有特殊的原因，就是某项上网技能不足。目前电报频道&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;@pythontrendingweekly&lt;/a&gt; 有 1.6K 关注，&lt;a href=&quot;https://twitter.com/chinesehuazhou&quot;&gt;Twitter&lt;/a&gt; 有 1.4K 关注，在新一年里有了不错的起步。Feedly 里的订阅源已经飙升到 450+，重塑了我的信息摄取习惯，对写作周刊帮助极大。我感觉打开了新世界的大门，以后有时间会详细聊聊这些。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;6、即刻与小红书，头条与星球。&lt;/strong&gt; 过去几年里，我会持续分享一些文章之外的微头条/短小内容，不知不觉，今日头条获得了 28K 关注，Python知识星球也有 2.6K 关注。但断崖式的阅读和互动让我寒心，我下定了决心，会逐渐抛弃它们。即刻和小红书是新的尝试，作为观察席的替代补充。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;7、2023 + 2022 年的文章。&lt;/strong&gt; 近两年创作/翻译的文章依然是很少，一个原因是自己胸无点墨，另一原因感觉已被这张图精准概括了……&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;2023 年的周刊为我增加了不少内容输出量，曾梳理过《&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-iweekly&quot;&gt;Python 潮流周刊第一季完结（1~30）&lt;/a&gt;》，这里就不罗列所有文章了。以下是 2023 年的文章合集：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/277YOO79iQwXjYhp93lf9w&quot;&gt;Python 潮流周刊第一季完结（1~30）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/gplCsGO5R8kY_nF8Pd7iXg&quot;&gt;聊聊技术周刊的变现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/hExsYhkjyDHs_YBGCErAxg&quot;&gt;对比编程语言的四种错误处理方法，哪种才是最优方案？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/eGDOZYZzSpiWojWkN0mK2Q&quot;&gt;《流畅的Python》第二版上市了，值得入手么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/5jtrz0LIoz-cCPmI2XpT9g&quot;&gt;性能最快的代码分析工具，Ruff 正在席卷 Python 圈！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/wfK7SpRqre2n5IEUAHLQ8Q&quot;&gt;为什么 Python、Go 和 Rust 都不支持三元运算符？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/LwbgiDoI6pdTy8DNaAz7CA&quot;&gt;ChatGPT 开源了第一款插件，都来学习一下源码吧！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/HHSjv0ZlAjq0ZvLHMI-W9g&quot;&gt;这一次，Python 真的有望告别 GIL 锁了？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/g-Wo5lM8Icsbhb5kArI2aw&quot;&gt;我经常读的 9 个英文 Python 网站&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/_qcUu-PzjUtmX0uktZbNQw&quot;&gt;Python 发展趋势：与 Rust 深度融合、更易于编写 Web 应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;2022 年末，由于个人状态不佳/实在是懒，没有写年终总结。这里也把过去的文章罗列记录出来。以下是 Python猫 2022 年的文章：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/eSUfrdC0YsPCzJsvdZ2h1A&quot;&gt;Python 为什么如此设计？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/vUkBUAcRvD59w2IbntgV4A&quot;&gt;Python 缩进语法的起源：上世纪 60-70 年代的大胆创意！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/0cohhN737cfaI8gSCYo0ew&quot;&gt;谷歌、微软、Meta？谁才是Python最大的金主？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/NoZniWQU3dUA_0TmZ2kHzw&quot;&gt;Python冷知识：如何找出新版本增加或删除了哪些标准库？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/AbpE-QJ64Q4iShMyXAygaQ&quot;&gt;万万没想到，除了香农计划，Python3.11竟还有这么多性能提升！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/fZoYuiK6HzCjyStRnwu2Ig&quot;&gt;如何免安装使用 Python？推荐 17 个在线的 Python 解释器！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/GWByw61O56gJ7qUisAGQNw&quot;&gt;Python 3.12 目标：还可以更快！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/kiZ7QWAPNKY8QlWL7I_vbQ&quot;&gt;继GitHub的Copilot收费后，亚马逊推出了 CodeWhisperer，感觉不错哟！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/4lehHrznHL5Yt52Mmbi17Q&quot;&gt;Spring 使用 Mypy 检查 30 万行代码，总结出 3 大痛点与 6 个技巧&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/3UD7vOwdV9j0F5yjW5X8KA&quot;&gt;PyCharm 2022.2 发布了，支持最新 Python 3.11 和 PyScript 框架！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/LspP7UQanxTtvVpgh8Pwrw&quot;&gt;7 行代码搞崩溃 B 站，原因令人唏嘘！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/CdXMOPfFMe7LvDwn9w5PDA&quot;&gt;警惕！Python 中少为人知的 10 个安全陷阱！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/bpp_lwSxqRSHS71NslAWBQ&quot;&gt;Python 为什么不设计 do-while 循环结构？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;最后附往年回顾：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/d8_5R1R4I-wm2nCSW7ubtQ&quot;&gt;Python猫 2021 文章小结，翻译竟比原创多！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/DgYP8TBg2kEWRx6A-cXjgA&quot;&gt;2020年Python文章盘点，我选出了个人TOP10&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/GPMkOE1ZR9bbCjFWkhndDg&quot;&gt;我的 2019 年 Python 文章榜单&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#33：FastAPI 很好，Flask 也没死，它们都有未来</title>
            <link>https://pythoncat.top/posts/2023-12-30-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-12-30-weekly/</guid>
            <description>本期周刊分享了 15 篇文章，13 个开源项目，1 则视频</description>
            <pubDate>Sat, 30 Dec 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://zhuanlan.zhihu.com/p/672806587&quot;&gt;Flask 已死，FastAPI 是未来&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇标题十分吸睛引战的文章。说实话因见过太多“xxx 已死”、“再见了 xxx”这种煽动情绪的标题，我已经习惯绕道不读。比较框架优缺点，这非常合理，但刻意往贬低一方的角度引，就显狭隘了。（附：一篇回应文 &lt;a href=&quot;https://greyli.com/flask-fastapi-2023/&quot;&gt;Flask 已死，FastAPI 永生&lt;/a&gt;、对回应文的回应文 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/673847164&quot;&gt;理性参与讨论《Flask 已死，FastAPI 永生》&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://xz.aliyun.com/t/12980&quot;&gt;Python + Flask 打造属于自己的 RSS 安全信息流&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何用 Python 搭建属于自己的 RSS 信息流网站？文章介绍了一个完整的 Flask 项目，支持对接 RSS、解析文章、自动更新，最后部署上线并使用 Nginx 作反向代理。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://blog.miguelgrinberg.com/post/microdot-yet-another-python-web-framework&quot;&gt;Microdot：又一个 Python Web 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者介绍了自己开源的一个语法类似于 Flask 的 Web 框架，完全支持 asyncio 异步，支持 Websocket、SSE、CORS、Jinja 和 uTemplate 模板等功能。非常小（核心框架代码 700 多行），可以跟 MicroPython 一起使用。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://ai.plainenglish.io/a-weekend-ai-project-running-a-7b-large-language-model-on-a-nokia-9500-from-2004-04f77e123194&quot;&gt;周末 AI 项目：在 2004 年的诺基亚 9500 上运行 7B 大型语言模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在近 20 年前的早期智能手机上运行当下最火的大语言模型，这事感觉蛮有趣！作者使用大小为 4GB 的&lt;code&gt;Llama-2–7B-Chat-GPTQ&lt;/code&gt; 模型，最先尝试用 Streamlit 创建应用，但发现它的浏览器不支持，最后用 Flask 开发一个简单的网页，实现与 LLM 的交互！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://so1n.me/2023/12/28/python_asyncio_lib_how_to_use_it_correctly/&quot;&gt;Python Asyncio 之常见的三个坑&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Asyncio 出现晚，不像&lt;code&gt;go&lt;/code&gt; 、&lt;code&gt;Dart&lt;/code&gt; 、&lt;code&gt;js&lt;/code&gt;一样隐式的运行事件循环，又使用了&lt;code&gt;async&lt;/code&gt; 、&lt;code&gt;await&lt;/code&gt;的语法，所以很容易用错。文章介绍了三个坑，以及正确的避坑方法。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://dev.to/proteusiq/to-code-and-beyond-a-neverland-adventure-in-bash-lua-python-and-rust-1jon&quot;&gt;Bash、Lua、Python 和 Rust 的梦幻岛冒险&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;原文很短，推荐阅读。文章是三段“冒险故事”，主旨是让我们看到 Bash、Lua、Python 和 Rust 在实现常规 for 循环及推导式和迭代器写法时的相似性与差异性。（附：作者的另一篇 &lt;a href=&quot;https://dev.to/proteusiq/down-the-data-rabbit-hole-alices-adventure-from-pandas-to-duckdb-wonderland-25h0&quot;&gt;数据兔子洞：爱丽丝从 Pandas 到 DuckDB 仙境的冒险&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://yamlscript.org/posts/advent-2023/dec-21/&quot;&gt;YAML、Python 和 Holy Graal&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://yamlscript.org/&quot;&gt;YAMLScript&lt;/a&gt; 是一种函数式编程语言，其语法使用 YAML 编码。它提供了 Python 的&lt;code&gt;yamlscript&lt;/code&gt; 库，可与&lt;code&gt;PyYAML&lt;/code&gt; 一样操作 YAML 文件，支持最新的 YAML 1.2 规范，还可使用 YAMLScript 函数来生成或操作数据。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://www.blog.dailydoseofds.com/p/python-m-the-coolest-python-flag&quot;&gt;“Python -m”：最酷的 Python 标记，真的值得更多关注&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 有不少命令行标记，文章主要介绍了“-m”标记的用法。我非常认可原文标题中用“Coolest”形容这个标记。早在 2019 年，我写过一篇更为详尽的文章《&lt;a href=&quot;https://pythoncat.top/posts/2019-11-10-m&quot;&gt;Python 中 -m 的典型用法、原理解析与发展演变&lt;/a&gt;》，若你没读过，我诚心推荐！&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://switowski.com/blog/ci-101/&quot;&gt;Python CI 的初学者指南&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;持续集成（简称 CI）是将开发者的代码合并到主存储库中的过程，它涉及的环节不少：提交前测试、代码格式化、静态分析、解决冲突等。很多任务需要用自动化方式，文章详细介绍了 CI 入门、CI 平台选择、CI 任务实践、CI 任务扩展等话题。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://zhuanlan.zhihu.com/p/464979921&quot;&gt;Python Type Hints 简明教程（基于 Python 3.12）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇很详细的 Type Hints 教程，大部分内容是对《流畅的 Python 第二版》与官方文档的总结，后续基于 Python 3.12 重新编排并新增了一些内容。（投稿自@&lt;a href=&quot;https://github.com/JayYoung2021&quot;&gt;JayYoung2021&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://coderslegacy.com/pyinstaller-exe-detected-as-virus-solutions/&quot;&gt;Pyinstaller EXE 被检测为病毒？解决方案和替代方案&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Pyinstaller 可以将 Python 脚本转换为 Windows 可执行文件。为什么实际没问题的代码，却可能被检测为病毒呢？如何避免被防病毒软件误伤呢？文章介绍的解决方案有：避免单文件模式、自行构建 Pyinstaller 的引导加载程序、使用代码签名证书、使用 Nuitka/Inno Setup 等替代工具。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://daveon.design/introducing-fontimize-subset-fonts-to-exactly-and-only-your-websites-used-characters.html&quot;&gt;Fontimize 简介|精确字体子集，仅使用你网站的字符&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;“字体子集”指的是一个字体文件的部分，它有助于优化性能，减少下载时间。作者介绍了自己开源的用于生成字体子集的 Python 库&lt;code&gt;fontimize &lt;/code&gt; ，可以减少字体文件约 95% 的大小。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://github.com/python/cpython/pull/113465&quot;&gt;GH-113464：copy-and-patch 的 JIT 编译器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;周刊第 27 期分享过 Python 3.13 正在开发一个 JIT 编译器的消息，现在 @brandtbucher 已经提交了 PR 啦（恰在圣诞节前）！commit 信息像是一首诗，蛮有意思。&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://www.jefftk.com/p/losing-metaphors-zip-and-paste&quot;&gt;消失的隐喻：Zip 和 Paste&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 中用&lt;code&gt;zip&lt;/code&gt; 将两个列表合并，就像一个拉链， Unix 中的&lt;code&gt;paste&lt;/code&gt; 命令可执行相同操作，它的比喻是粘贴：将一列放到另一列旁边。&lt;code&gt;paste&lt;/code&gt; 可追溯到 1978 年，&lt;code&gt;zip&lt;/code&gt; 则追溯到 1988 年，但现在这两个词通常被视作其它含义：&lt;code&gt;paste&lt;/code&gt; 总是用于“复制和粘贴”，&lt;code&gt;zip&lt;/code&gt; 是压缩文件格式。&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;https://andreasjhkarlsson.github.io//jekyll/update/2023/12/27/4-billion-if-statements.html&quot;&gt;40 亿个 IF 语句&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者做了一个看似很无聊的尝试，成功将 40 亿个 if 语句写入到 40GB 文件中，可以快速判断任意 32 位数字是偶数还是奇数。这当然是没有现实用处的，但阅读文章你会了解做成这件事并不简单：如何高效写出这么多 if 语句？如何控制文件大小避免编译错误？如何加载和执行才能提升性能？&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁每 30 期为一季，第一季的精华内容已整理成一篇，方便你随时查看。在线访问地址：&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;Python 潮流周刊第一季精华合集（1~30）&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/zauberzeug/nicegui&quot;&gt;nicegui：使用 Python 开发 Web 用户界面&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个基于 Python 的 UI 框架，可以创建按钮、对话框、Markdown、3D 场景、绘图等前端标准元素，内置定时器定时刷新数据，支持 Tailwind CSS 自动补全，支持在 Jupyter Notebook 运行。（star 6.2K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/wireservice/csvkit&quot;&gt;csvkit：用于转换和处理 CSV 的命令行工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一套用于转换和处理 CSV 的命令行工具，一行命令实现一种常见功能，包括 Excel 转 CSV、JSON 转 CSV、CSV 转 JSON、打印列名、查找匹配单元格的行、生成统计信息、使用 SQL 方式查询表数据、导入和查询数据库数据。（star 5.7K）&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 从 PostgreSQL 中提取数据到 CSV 文件&lt;/span&gt;
sql2csv &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;db postgresql&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;database &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;query &lt;span&gt;&quot;select * from data&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; new&lt;span&gt;.&lt;/span&gt;csv&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;3、&lt;a href=&quot;https://github.com/scriptiot/evue&quot;&gt;evue：基于 html/css 的高性能 GUI 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于 Flutter/LVGL 开发，支持多种操作系统，支持深色/浅色主题，支持响应式。采用编译时代码生成技术，性能卓越；原生支持 MVVM, 数据驱动 UI。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/AlexandreSajus/JARVIS&quot;&gt;JARVIS：自己的个人语音助手&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;开发个人语音助手，将你的语音转成文本给 GPT-3 以生成响应，使用 ElevenLabs 将大模型的响应转为语音，使用 Pygame 播放，使用 Taipy 呈现在网页上。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/chriskiehl/Gooey&quot;&gt;Gooey：只需一行即可将几乎任何 Python 命令行程序转换为完整的 GUI 程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;你敢相信么，只需加上这个库的一行装饰器代码，就能将 CLI 程序转换成用户友好的 GUI 程序？这个项目已存在多年，star 数很多。（star 20K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/better-mojo/mod&quot;&gt;mod：Mojo 的包管理器工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Mojo 还没有官方的包管理工具，因此作者用 Python 开发了一个。主要借鉴 Rust &lt;code&gt;cargo&lt;/code&gt; 和 Python &lt;code&gt;poetry&lt;/code&gt; ，规划提供的能力是：mod = cargo + rustup + poetry + pyenv。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/pinecone-io/canopy&quot;&gt;canopy：由 Pinecone 提供支持的 RAG 框架和上下文引擎&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;建立在 Pinecone 矢量数据库之上的 RAG 框架，只需简单的命令即可与文档数据聊天。包含文本数据分块与嵌入、聊天记录管理、查询优化、上下文检索（包括提示工程）和增强生成等功能。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/damianstone/toogether-backend&quot;&gt;toogether-backend：Django REST 社交约会 APP 项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;手机端社交约会 APP 项目，这是后端程序。使用 Django 框架，使用 Gdal、Geos 和 Postgis 进行地理定位。支持推荐匹配、聊天、群聊等功能。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/ihmily/DouyinLiveRecorder&quot;&gt;DouyinLiveRecorder: 可循环值守和多人录制的直播录制软件&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;支持抖音、Tiktok、快手、虎牙、斗鱼、B站、小红书等平台直播录制，抓取多平台直播源地址，抖音无水印解析，快手无水印解析。基于 FFmpeg 实现，支持自定义配置录制以及直播状态推送。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/cumulo-autumn/StreamDiffusion&quot;&gt;StreamDiffusion：用于实时交互式生成的管道级解决方案&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用创新的方案，为当前基于扩散的图像生成技术引入了显著的性能增强。（star 6.4K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/tobymao/sqlglot&quot;&gt;sqlglot：SQL 解析器和转译器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个无依赖的 SQL 解析器、转译器、优化器和引擎。可用于格式化 SQL 或在 20 种不同的方言之间进行翻译，例如 DuckDB、Presto / Trino、Spark / Databricks、Snowflake 和 BigQuery。（star 4.4K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/VikParuchuri/texify&quot;&gt;texify：输出 LaTeX 和 Markdown 的数学 OCR 模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;将包含数学公式的图像或 pdf 转换为 Markdown 和 LaTeX 格式，可以在 CPU、GPU 或 MPS 上运行。与同类的 &lt;strong&gt;Pix2tex&lt;/strong&gt; 和 &lt;strong&gt;nougat&lt;/strong&gt; 项目不同，它支持更多样化的 Web 场景。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://github.com/talebook/talebook&quot;&gt;talebook：一个简单的在线版个人书库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个基于 Calibre 的个人图书管理系统，支持在线阅读。后端采用 Tornado 框架，前端采用 Vue.js 和 Readium.js。界面美观，支持多用户、在线阅读、批量导入、邮件推送、书籍信息自动更新、私人模式等功能。（star 2K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.bilibili.com/video/BV1v64y1J7hS&quot;&gt;为什么 Python, Go, Rust, Kotlin 没有三元运算符？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是 UP 主@今天晚放学 基于我的文章制作的视频，算得上是一份 2024 年元旦贺礼了！相信很多读者已经看过&lt;a href=&quot;https://pythoncat.top/posts/2023-04-03-condition&quot;&gt;文章版&lt;/a&gt;（毕竟上期周刊我还心血来潮分享过），但我还是推荐你再看看这则视频版。另外，作者的“编程美学”系列视频，做的真不错。&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#32：打造个人的新闻聚合阅读器</title>
            <link>https://pythoncat.top/posts/2023-12-23-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-12-23-weekly/</guid>
            <description>本期周刊分享了 10 篇文章，10 个开源项目，3 则音视频</description>
            <pubDate>Sat, 23 Dec 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pythonspeed.com/articles/cpu-thread-pool-size/&quot;&gt;在并行程序中实际最多能用多少个 CPU？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在 CPU 密集型任务中，通常要根据 CPU 核心数来设置线程/进程池的大小。但如何确定实际用多少个 CPU 最合适呢？物理 CPU 和逻辑 CPU 是什么？如何测试设置多少 CPU 数比较合适？&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://frostming.com/2019/03-13/where-do-your-packages-go/&quot;&gt;你的 Python 包都装到哪了？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 新手经常会遇到包相关的问题，主要原因之一是不清楚 Python 是如何找包的。文章介绍了 Python 查找包的顺序、它是如何安装包的、虚拟环境的作用、脚本运行方式对搜索路径的影响等。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://vstinner.github.io/remove-c-api-funcs-313.html&quot;&gt;移除 CPython 中的私有 C API 函数&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Victor Stinner 是很活跃的核心开发者，他在 Python 3.13 alpha 1 中删除了 300 多个私有 C API 函数，收到了一些负面反馈，在 alpha 2 版本中又恢复了 50 个函数。文章记录他所做的事情，以及社区中大家的反馈。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://andrewwegner.com/python-gotcha-list-copy.html&quot;&gt;Python 小陷阱：复制列表时的问题&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何给 list 这种可变对象创建副本？对于一维列表，文章介绍了三种方法；但是对于二维列表，就涉及浅拷贝与深拷贝问题，需要使用 &lt;strong&gt;copy.deepcopy()&lt;/strong&gt; 。（附注：作者的“&lt;strong&gt;Python Gotcha&lt;/strong&gt; ”系列短文，介绍了 Python 的一些使用注意事项。）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://superfastpython.com/asyncio-task-cancellation-best-practices/&quot;&gt;取消 Asyncio 任务的最佳实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Asyncio 任务有手工取消和自动取消，文章介绍了 6 项最佳实践，给出了相应的示例。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://robertrode.com/2023/10/02/configuration-in-python-applications-no-magic-just-necessary-practice.html&quot;&gt;Python 项目中的配置：没有魔法，只是必要的实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;我们通常将可变或敏感的参数放到配置文件中，可以使用哪些方式呢？有 ini、json、toml、yaml 等文件，也有环境变量等方式。在什么时候做配置的初始化呢？测试时如何修改配置呢？文章分享了一些使用技巧。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://tonybaloney.github.io/posts/fine-tuning-wsgi-and-asgi-applications.html&quot;&gt;优化 Python 的 Flask、Django 和 FastAPI 程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了一些配置 Web 服务器的最佳实践（涉及 &lt;strong&gt;Gunicorn、Uvicorn 和 Hypercorn&lt;/strong&gt;）。针对 ASGI 和 WSGI 两类标准接口的差异，如何设置 worker 数和线程数，如何使用 Locust 等工具来作测试，不同 Web 开发框架该用什么方案？&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://pythoncat.top/posts/2023-04-03-condition&quot;&gt;为什么 Python、Go 和 Rust 都不支持三元运算符？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 不支持三元运算符，但它有一个很特殊的&lt;strong&gt;条件选择语法&lt;/strong&gt; ，为什么会这样设计呢？文章梳理了 Python 波折的语法设计故事，同时介绍了 Go 和 Rust 不谋而合的做法，让人思考什么才是编程语言中更好的语法设计？&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://www.thepythoncodingstack.com/p/the-key-to-the-key-parameter-in-python&quot;&gt;Python 中的“key”参数的关键&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;你也许在 sorted() 和 list.sort() 函数中看到过“key”参数，除此之外，还有很多函数带有这个参数，比如 max() 和 min()，文章介绍了相关函数中对这个参数的用法&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://rednafi.com/python/dataclasses_and_methods/&quot;&gt;从 Python 数据类中消除状态突变方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 中可以使用&lt;code&gt;@dataclass&lt;/code&gt; 装饰器来定义数据类，它会自动添加 &lt;code&gt;__init__&lt;/code&gt;、&lt;code&gt;__repr__&lt;/code&gt;、&lt;code&gt;__eq__&lt;/code&gt; 等魔术方法，减少代码量。作者建议定义不可变的数据类，不用将它像普通类一样作变更属性的操作，如果在普通类中要用&lt;code&gt;__repr__&lt;/code&gt; 等方法，建议是手写实现。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁每 30 期为一季，第一季的精华内容已整理成一篇，方便你随时查看。在线访问地址：&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;Python 潮流周刊第一季精华合集（1~30）&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/facundoolano/feedi&quot;&gt;feedi：打造个人的新闻聚合阅读器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;想不想拥有个人定制化的内容阅读器？它支持解析 RSS 源、拉取 Mastodon 消息、阅读标记、本地文章阅读和预览、支持发送到 Kindle。（附：作者为什么以及如何开发这个项目 &lt;a href=&quot;https://olano.dev/2023-12-12-reclaiming-the-web-with-a-personal-reader/&quot;&gt;Reclaiming the Web with a Personal Reader&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/google/generative-ai-python&quot;&gt;generative-ai-python：用 Google AI SDK，开发 Gemini 和 PaLM 应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Google 推出的生成式 AI 开发工具，可快速基于 Gemini 和 PaLM 大模型开发 AI 应用。支持文本生成、多轮对话、嵌入等。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/luckrnx09/python-guide-for-javascript-engineers&quot;&gt;python-guide-for-javascript-engineers：开源电子书《JavaScript工程师的Python指南》&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一本基于 &lt;a href=&quot;https://github.com/luckrnx09/abook&quot;&gt;abook&lt;/a&gt; 编写的开源电子书，涵盖了从 Python 环境安装到项目开发的方方面面。通过大量案例对比 JavaScript 和 Python 语言的异同，帮助 JavaScript 工程师快速掌握 Python 语言。（投稿自@&lt;a href=&quot;https://github.com/luckrnx09&quot;&gt;luckrnx09&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/sqlmapproject/sqlmap&quot;&gt;sqlmap：SQL 注入和渗透测试工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可自动检测和利用 SQL 注入缺陷而入侵数据库。具有强大的检测引擎、数据库指纹识别、从数据库查询数据、访问底层文件系统、在操作系统上执行命令等。（star 29.4K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/JoeanAmier/TikTokDownloader&quot;&gt;TikTokDownloader: TikTok 和抖音数据采集工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于 Requests 模块实现的数据采集工具，功能非常齐全！支持命令行模式、Web UI 模式和接口调用模式。（star 1.5K）（附：第 25 期分享过作者的小红书采集工具 &lt;strong&gt;XHS_Downloader&lt;/strong&gt;）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/CircleRadon/Osprey&quot;&gt;Osprey：通过视觉指导微调实现对像素的理解&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个靠演示效果把我惊艳到的项目！直接看下方的演示图吧：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/ephes/django-cast&quot;&gt;django-cast：基于 Django 和 Wagtail 的博客/播客项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用  Django 快速搭建个人博客和播客网站，Wagtail 作为 CMS 可方便管理文章和播客节目。支持播放播客和视频，支持评论和垃圾邮件过滤，可自定义网站主题。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/Qexo/Qexo&quot;&gt;Qexo：快速、强大且漂亮的 Hexo 编辑器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Hexo 博客后台管理，自定义图床上传图片、在线页面管理、开放 API、一键更新、快速接入友情链接。（star 1.2K）&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/practical-tutorials/project-based-learning&quot;&gt;project-based-learning：精选的基于项目的教程列表&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;星星数超多的资源收集类项目，分不同编程语言和技术领域，收集了很多实战项目类的教程。（star 142K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/open-mmlab/Amphion&quot;&gt;Amphion：用于音频、音乐和语音生成的工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它的目标是提供一个平台来研究将任意输入转换为音频。已支持 TTS 文本转语音、SVC 歌声转换、TTA 文本到音频，支持广泛使用的神经声码器。（star 2.2K）&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://space.bilibili.com/474764697/video&quot;&gt;PyConChina 2023 的演讲视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;今年 PyConChina 活动的一部分视频已发布了，可在 B 站上观看。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://realpython.com/podcasts/rpp/184/&quot;&gt;Episode #184：PyCoder’s Weekly 的 2023 年总结&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PyCoder’s Weekly 是我长期在看的周刊，这期播客聊了它的一些总结性话题，比如点击量前 5 的链接、今年一些重要的新闻、今年的重要主题和趋势、有意思的项目，等等。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.youtube.com/watch?v=OPyoXx0yA0I&quot;&gt;Requests vs Httpx vs Aiohttp 该选哪一个呢？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;视频比较了使用 requests、httpx 和 aiohttp 的情况，讨论了异步请求的使用等话题。&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#31：继 iOS 后，新 PEP 提议官方添加 Android 为支持平台</title>
            <link>https://pythoncat.top/posts/2023-12-16-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-12-16-weekly/</guid>
            <description>本期周刊分享了 13 篇文章，12 个开源项目，3 则音视频</description>
            <pubDate>Sat, 16 Dec 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pep-previews--3586.org.readthedocs.build/pep-0738/#&quot;&gt;PEP-738：将 Android 添加为第 3 层支持的平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;周刊第 24 期分享过 &lt;a href=&quot;https://peps.python.org/pep-0730/&quot;&gt;PEP-730 CPython 提供对 iOS 的官方支持&lt;/a&gt; ，这个 PEP-738 则是将目标转到了 Android 系统。目前两个 PEP 都是草案状态，但 Android 使用的是 Linux 内核，也许这个 PEP 被采纳的可能性会更大些吧？（附：今年 Python 语言峰会上的 &lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-python.html&quot;&gt;Python on Mobile: State of the Union&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://journal.hexmos.com/marker-pdf-document-ai/&quot;&gt;深度解析 Marker：AI 驱动的 PDF 布局检测引擎的源码解读&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;第 29 期分享的 PDF 转 Markdown 工具 &lt;strong&gt;Marker&lt;/strong&gt; 短短两周时间已经逼近 5K star了。这篇文章解读了它的工作原理，介绍了它的 6 个阶段及所依赖到的工具（PyMuPDF、OCRMyPDF、Tesseract 等等）。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://nedbatchelder.com/blog/202312/realworld_matchcase.html&quot;&gt;现实世界的 match/case&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 3.10 引入了 &lt;strong&gt;match-case&lt;/strong&gt; 模式匹配语法，你们在项目中用过了么？这篇文章介绍了一种使用场景，是处理 Github 机器人返回的复杂 JSON 数据，相比传统的写法，它使得代码变得简单了。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://discord.com/blog/pytest-daemon-10x-local-test-iteration-speed&quot;&gt;pytest 守护进程：提升 10 倍本地测试迭代速度&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Discord 的官方博客文章，分享了他们将某个测试从 20 秒提升到 2 秒的故事！做法是使用“&lt;strong&gt;pytest 守护进程&lt;/strong&gt;”和热加载，确保在需要测试时马上有进程可用，省去了即时准备工作的耗时。文章还提到了一个实现同样功能的开源项目 &lt;a href=&quot;https://github.com/JamesHutchison/pytest-hot-reloading/&quot;&gt;pytest-hot-reloading&lt;/a&gt; 。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://vra.github.io/2023/10/14/android-ai-app-in-88-lines-of-python-code/&quot;&gt;使用 Python 88 行代码写一个简易的 Android AI 程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;开发一个在手机上 SDXL &lt;strong&gt;text-to-image&lt;/strong&gt; 的 Demo，这听起来就不是一件简单的事情，但这篇文章介绍说只用 88 行 Python 代码就能实现？！用的技术是 &lt;strong&gt;Beeware&lt;/strong&gt; 和 &lt;strong&gt;LeptonAI&lt;/strong&gt;，前者在我们周刊中出现过多次（例如上文中的两个 PEP 都与它有很深的联系），后者是知名 AI 专家 @贾扬清 的创业项目。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://www.bitecode.dev/p/you-dont-need-this-in-python&quot;&gt;在 Python 中不需要这些无谓的操作&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者指出了一些常见的 Python 多余/错误用法，包括&lt;code&gt;# -*- coding: utf-8 -*-&lt;/code&gt; 、&lt;code&gt;range(len(xx))&lt;/code&gt; 、追踪循环的位置、用 index() 判断是否包含、单独的 getter 和 setter。其中第一个关于编码的确实很常见，它也让我想起另一个经常被无意识使用的&lt;code&gt;if __name__ == &apos;__main__&apos;&lt;/code&gt; 。（附：&lt;a href=&quot;https://pythoncat.top/posts/2020-06-03-main&quot;&gt;为什么我不推荐写所谓的 main 函数？&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://vickiboykis.com/2023/12/11/why-if-type_checking/&quot;&gt;为什么要用“if TYPE_CHECKING”？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;if TYPE_CHECKING&lt;/code&gt; 的作用是为了实现条件式导入模块，基本示例如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Sequence

def func(value: Sequence[int]) -&amp;gt; None:
    pass&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在什么情况下要这样用呢？文章介绍了这种模式的必要性，简单结论：在 mypy 强制执行的类型检查和运行时的类型检查之间作出权衡，特别是在有大量循环依赖的情况下。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://st4lk.github.io/en/blog/2023/12/09/sqlalchemy-vs-django-orm/&quot;&gt;对比 SQLALchemy 与 Django ORM&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它们都是关系型数据库的对象关系映射（ORM）框架，作者基于从 &lt;strong&gt;Django ORM&lt;/strong&gt; 切换到 &lt;strong&gt;SQLAlchemy&lt;/strong&gt; 的视角，介绍了两者的一些差异和正确用法，避免在使用时犯错。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://coderslegacy.com/python-init-py-best-practices/&quot;&gt;Python __init__.py 的最佳实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;__init__.py&lt;/code&gt; 是 Python 中特有的一个文件，为什么会需要用到这样的文件呢？它的作用是什么？如何自定义这个文件，又有哪些使用技巧和最佳实践呢？推荐阅读这篇很详细的教程。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://augierpi.gricad-pages.univ-grenoble-alpes.fr/mojo-the-point-of-view-of-a-researcher-using-python.html&quot;&gt;Mojo：来自一位 Python 研究员的观点&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇系统分析 Mojo 的文章，作者想研究的问题是：Mojo 是什么，未来会如何发展？Mojo 对通用科学计算（即不仅是 AI）有用么？它什么时候才真正可用，目前还缺少什么？作者不认可流传的“&lt;strong&gt;Mojo==Python++&lt;/strong&gt; ”说法，而是把它视为一门新颖的静态语言来研究。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://www.b-list.org/weblog/2023/dec/04/python-http-status-codes/&quot;&gt;Python 中的简单 HTTP 状态码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;不要在代码中直接用数字表示 HTTP 请求的状态码，这属于“魔术数字”，并不规范。Django、Starlette 和 Litestar 等框架都提供有枚举值，但更推荐的是使用标准库的&lt;code&gt;http.HTTPStatus&lt;/code&gt; ，另外从 Python 3.12 开始，还可以用&lt;code&gt;HTTPStatus.is_success&lt;/code&gt; 表示 2xx 状态码。（附：本文出自作者日更的“降临节日历”系列文章，多是些编程小技巧，&lt;a href=&quot;https://www.b-list.org/weblog/&quot;&gt;去博客阅读&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://juejin.cn/post/7310101543776829440&quot;&gt;CPython 开发实战：实现 None 感知运算符 ?. 和 ??&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://peps.python.org/pep-0505/&quot;&gt;PEP-505 None 感知运算符&lt;/a&gt; 是一份被推迟的提案，它的用途是简化判空时的条件处理。文章介绍了 PEP 里的三种 None 感知运算符，并做了一个简单版实现。文末还提及了不支持这份提案的两个评论，我想附和一句：还是不要加了，继续 Deferred 吧！&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://olano.dev/2023-11-30-code-is-run-more-than-read/&quot;&gt;代码的运行多于被阅读&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;“&lt;strong&gt;Code is read more than written&lt;/strong&gt;”是编程的基本常识之一，提醒着程序员要关注代码的可读性和可维护性。作者将它提炼为“maintainer &amp;gt; author”，但是，编码只是达成目标的手段，它为用户提供服务，因此是“user &amp;gt; dev”，而且最终目的是为业务创造价值，因此初步推出“biz &amp;gt; user &amp;gt; ops &amp;gt; dev”。这个结论对么？作者逐一考虑/权衡各项因素的重要性，又列出了多组关系，最终简明的结论是：user &amp;gt; ops &amp;gt; dev，biz &amp;gt; ops &amp;gt; dev，biz ≹ user。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁每 30 期为一季，第一季的精华内容已整理成一篇 6.2 万字的长文，方便你随时查看和下载。在线访问地址：&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;Python 潮流周刊第一季精华合集（1~30）&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/magic-research/magic-animate&quot;&gt;magic-animate：使用扩散模型的时间一致的人像动画&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;由新加坡国立大学和字节跳动联合推出，利用一张人像和动作图生成人物的运动视频。（star 7.8K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/swoole/phpy&quot;&gt;phpy：连通 Python 和 PHP 的生态系统&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;让你在 PHP 中使用 Python 的函数和类库，或者在 Python 中使用 PHP 的包。实现原理是在进程内同时创建了 &lt;code&gt;ZendVM&lt;/code&gt; 和 &lt;code&gt;CPython VM&lt;/code&gt;，直接在进程堆栈空间内使用 &lt;code&gt;C&lt;/code&gt; 函数互相调用。目前不支持 Python 多线程和异步 IO 特性。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/Vaibhavs10/insanely-fast-whisper&quot;&gt;insanely-fast-whisper：快到极致的 Whisper&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于 OpenAI 的 Whisper Large v3 的音频转录工具，转录 150 分钟的音频仅需 98 秒。（star 4.2K）（附：另一个 &lt;a href=&quot;https://github.com/SYSTRAN/faster-whisper&quot;&gt;faster-whisper：使用 CTranslate2 作更快的 Whisper 转录&lt;/a&gt; ，star 6.2K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/Coframe/coffee&quot;&gt;coffee：使用 AI 将 UI 的构建和迭代速度提高 10 倍&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;非常有创意的项目。在前端项目中引入它的组件，用自然语言描述你想实现的效果，它就会辅助生成实现代码。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/pydantic/FastUI&quot;&gt;FastUI：更快构建更好的 UI&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Pydantic 推出的 Web 界面开发框架，可使用 React 构建响应式 Web 应用程序，而无需编写一行 JavaScript。（star 2.7K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/mistralai/mistral-src&quot;&gt;mistral-src：Mistral AI 7B v0.1 模型的参考实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Mistral AI 7B 的表现极为亮眼，在评分上接近了 Llama 70B 版本。这个项目是官方开源，用于快速部署和使用这个模型。（star 5.4K）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/hardbyte/netchecks&quot;&gt;netchecks：查验网络运行条件的工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用于测试网络条件是否符合预期，支持验证 DNS 和 HTTP 连接，可配置断言条件，支持自定义验证内容。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/facebookresearch/Pearl&quot;&gt;Pearl：Meta 推出的强化学习 AI 代理库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;由 Meta 的应用强化学习团队开源，采用模块化设计，为生产环境提供了一系列独特的功能，包括动态行为空间、离线学习、智能神经探索、安全决策制定、历史总结和数据增强。（star 1.4K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/pytorch-labs/gpt-fast&quot;&gt;gpt-fast：简单高效的 PyTorch 原生 Transformer 文本生成&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个 PyTorch 的展示项目，用不到 1000 行 Python 代码，实现简单高效的文本生成。（star 4.1K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/krishnaik06/The-Grand-Complete-Data-Science-Materials&quot;&gt;The-Grand-Complete-Data-Science-Materials：数据科学的视频和材料&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个资源收集型仓库，包含数据分析、数据科学、机器学习、生成式 AI 等专题的大量视频列表。（star 4.2K）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/wgwang/awesome-LLMs-In-China&quot;&gt;awesome-LLMs-In-China：中国的大模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;中国大模型列表大全，全面收集有明确来源的大模型情况，包括机构、来源信息和分类等，目前列表中有 189 个国内大模型。（star 2.6K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/jcrist/msgspec&quot;&gt;msgspec：高性能的序列化和校验库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;支持对 JSON、MessagePack、YAML 和 TOML 等格式的序列化与校验，拥有超高性能。（star 1.5K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已开源在 Github 上，目前获得 940 star，如果周刊对你有帮助，可以给颗 star 支持下么？（有没有可能在 2023 年的最后两周突破 1K star 呢？）&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pyfound.blogspot.com/2023/12/announcing-hidden-figures-of-python-pypodcats.html&quot;&gt;PSF 官宣一档播客节目：Python 的隐藏人物&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;“Hidden Figures of Python”播客的目标是展示 Python 社区中少数群体的声音。第一期节目是四名女性主播介绍播客的起源和对 Top Python 播客中女性嘉宾稀少的现象分析。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://talkpython.fm/episodes/show/442/ultra-high-speed-message-parsing-with-msgspec&quot;&gt;Talk Python To Me #442 使用 msgspec 作超高速的消息解析&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这期播客的嘉宾是上文 msgspec 的作者 Jim Crist-Harif。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.youtube.com/playlist?list=PL2NFhrDSOxgX41jqYSi0HmO9Wsf6WDSmf&quot;&gt;DjangoCon US 2023 的视频列表，60 个视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;DjangoCon US 是一个专注于 Django Web 框架的年度性大会，今年的视频已发布。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊第一季精华合集（1~30）</title>
            <link>https://pythoncat.top/posts/2023-12-11-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-12-11-weekly/</guid>
            <description>30 期周刊的精华内容合集，全文共计 62K 字</description>
            <pubDate>Mon, 11 Dec 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;Python 潮流周刊&lt;/a&gt;每 30 期为一季，以下是第 1~30 期周刊的内容合集，全文共计 62K 字！&lt;/div&gt;
&lt;div&gt;为了给大家省流/提升网页加载速度，原周刊中大部分的图片及无关内容均已删除，建议你收藏慢慢看！&lt;/div&gt;
&lt;div&gt;本文在线链接：&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;https://pythoncat.top/posts/2023-12-11-weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你想获取本文的 PDF 版本，请在公众号“&lt;strong&gt;Python猫&lt;/strong&gt;”里发送“&lt;strong&gt;W30&lt;/strong&gt;”，获取下载链接。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;我还针对这 30 期内容做了一些总结分享，如果你感兴趣的话，可访问 &lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-iweekly&quot;&gt;这个地址&lt;/a&gt; 阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你不方便或不习惯使用微信，无法访问上述平台，欢迎访问以下地址（支持邮箱登录）：&lt;a href=&quot;https://afdian.net/a/python_weekly&quot;&gt;https://afdian.net/a/python_weekly&lt;/a&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-05-13-weekly1&quot;&gt;第1期（2023-05-13）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pythoncat.top/posts/2023-05-08-error&quot;&gt;编程语言的错误处理模式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章讨论了编程中处理错误的四种常见方法：返回错误代码（C、Go）、异常（Java、C＃、Python、C++）、回调函数（JavaScript）和 Result 对象（Haskell、Rust、Kotlin）。对每种方法进行了分析，介绍了它们的优缺点以及使用时需要注意的地方。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/Chang-LeHung/dive-into-cpython/blob/master/obsy/03decriptor.md&quot;&gt;深入理解 Python 虚拟机：描述器实现原理与源码分析&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了描述器的实现原理，分析了 CPython 源码中描述器相关的字节码指令，并使用 Python 代码解释了描述器的执行逻辑。文章出自 Github 上的《深入理解 Python 虚拟机系列》，该系列已含 20+ 文章。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://v3u.cn/a_id_310&quot;&gt;人工智能 AI 孙燕姿模型应用实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;最近 AI 孙燕姿太火了！文章基于 Python3.10 和开源库 so-vits-svc（高表现力的语音合成模型）、Spleeter（人声和伴奏分离）和 FFMPEG（声音与伴奏合并），手把手演示了让 AI 孙燕姿演唱歌曲。（PS.由于担心侵权风险，so-vits-svc 项目已经归档了）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://juejin.cn/post/7229485914219642941&quot;&gt;用 C 语言写一个 Python 包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了 Python 的 C 语言 API 相关特性，最后实现了一个模仿官方 &lt;code&gt;datetime&lt;/code&gt; 的 C 扩展模块。文章出自《Python 之 C 语言 API 系列教程》的第一篇，该系列目前已更新两篇。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.cnblogs.com/shanxihualu/p/17391082.html&quot;&gt;Python 工具箱系列文章&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个系列文章，目前包含 31 篇文章，最近介绍的几个工具是数据库相关的：Neo4j（一个 NoSQL 图数据库，使用 Py2neo 操作）、PostgreSQL（一个关系型数据库，使用 Psycopg2 操作）、MongoDB、Access、ClickHouse、Redis 等。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://peps.python.org/pep-0713&quot;&gt;PEP-713：可调用的模块&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;Łukasz Langa 发起的新提案，提议支持在模块的全局命名空间中定义一个__call__对象以使模块可直接调用，__call__对象可以是一个标准函数或任意可调用对象。提案目前是草稿状态，未采纳。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://pythonspeed.com/articles/externally-managed-environment-pep-668&quot;&gt;“Externally managed environments”：当 PEP-668 影响了 pip&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;在较新 Linux 系统上使用 pip install 时可能遇到“externally managed environment”错误。原因：Linux 发行版已预装某些 Python 包，pip install 可能导致系统包冲突。解决方法：开发时用虚拟环境；Docker 里不用系统 Python；需最新工具时用 pipx。Python 包管理较为痛苦，短时间内难以改善。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://blog.zech.codes/bevy-v2&quot;&gt;Bevy v2.0：Python 的依赖注入框架&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;Bevy v2.0 是一个强大的依赖注入框架，可以帮助简化 Python 应用程序的管理。文章介绍了三种解决依赖关系的方法：全局变量、参数传递和依赖注入。Bevy v2.0 使用的方法包括参数注入、属性注入、仓库和依赖构造函数等。&lt;/div&gt;
&lt;h3&gt;项目&amp;amp;代码&lt;/h3&gt;
&lt;div&gt;最近几个月，乘着人工智能的东风，Github 上天天都被 AI 相关的项目屠榜，相信读者们已经从各种渠道看到过那些知名的以 Python 为主的开源项目了。因此，为了不撞车，本周刊主要收录一些小而美的项目。本期以中文开发者的项目为主。&lt;/div&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/zixiiu/Digital_Life_Server&quot;&gt;「数字生命」的服务端&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个“有生命的”语音助手 Python 项目，支持与前端通信、语音识别、chatGPT 接入和语音合成。前端部分可渲染人物动画、录音和播放声音。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/RVC-Project/Retrieval-based-Voice-Conversion-WebUI&quot;&gt;一个基于VITS的简单易用的语音转换（变声器）框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;具有以下特点：使用 top1 检索替换输入源特征为训练集特征来杜绝音色泄漏；即便在相对较差的显卡上也能快速训练；使用少量数据进行训练也能得到较好结果（推荐至少收集 10 分钟低底噪语音数据）；可以通过模型融合来改变音色（借助 ckpt 处理选项卡中的 ckpt-merge）；简单易用的网页界面；可调用 UVR5 模型来快速分离人声和伴奏。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/bookfere/Ebook-Translator-Calibre-Plugin&quot;&gt;电子书翻译器（Calibre 插件）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个可以将电子书翻译成指定语言（原文译文对照）的 Calibre 插件。支持多种翻译引擎，包括 Google 翻译、ChatGPT 以及 DeepL。支持所有 Calibre 所支持的电子书格式（输入格式 48 种，输出格式 20 种）。支持批量翻译、支持缓存续译、提供大量自定义设置。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/pikasTech/PikaPython/blob/master/README_zh.md&quot;&gt;跨平台的超轻量级嵌入式 Python 引擎&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个完全重写的超轻量级 Python 引擎，零依赖，零配置，可以在 Flash ≤ 64KB，RAM≤ 4KB 的平台下运行，极易部署和扩展，具有大量的中文文档和视频资料。&lt;/div&gt;
&lt;h3&gt;播客&amp;amp;视频&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.xiaoyuzhoufm.com/episode/6446499294d78eb3f74a01d8&quot;&gt;硬地骇客：大厂程序员构建 “小生意”，更加从容应对裁员潮&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;“每一位 hacker，每一位开发者，每一位程序员，都值得拥有一个属于自己的小生意”。这档播客已发布了几期关于独立开发者的话题，对作为程序员的我们，在技术、产品、创业等方面会有所启发。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://talkpython.fm/episodes/show/414/a-stroll-down-startup-lane&quot;&gt;Talk Python To Me #414：漫步创业之路&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;在 4 月的 PyCon 上，有一个专门展示新型 Python 创业公司的展台，叫做 Startup Row。在这期节目中，主播与这些公司的创始人分别聊了 5-10 分钟，这期节目同时包含了播客和视频。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://pythonbytes.fm/episodes/show/335/should-you-get-your-mojo-on&quot;&gt;PythonBytes #335：应该开始用 mojo 了么？&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;Mojo 是 LLVM 及 Swift 之父新开发的 AI 编程语言，号称比 Python 快 35000 倍。Mojo 已支持 Python 的许多核心特性，包括 async/await、错误处理、可变参数等等，但是它仍然处于早期阶段，缺少许多功能，比如还不支持类！&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://www.bilibili.com/video/BV14M4y147yH&quot;&gt;ChatGPT提示工程师｜AI大神吴恩达教你写提示词&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;鼎鼎大名的吴恩达联合 OpenAI，推出了一个面向开发者的 ChatGPT 提示词课程。这是 B 站上的链接，配有双语字幕。&lt;/div&gt;
&lt;h3&gt;问题&amp;amp;讨论&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.zhihu.com/question/29138020&quot;&gt;如何系统地自学Python？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;知乎上的一个热门问题，已有 7.4 万人关注和 1200+ 回答。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.v2ex.com/t/938669#reply88&quot;&gt;[吐槽] conda 真是太难用了！ 如何优雅地管理 Python 环境？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;v2ex 上的一个帖子，吐槽使用 Conda 遇到了各种问题，包括安装后找不到命令、安装依赖卡住不动、影响系统更新等等。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://discuss.python.org/t/allow-comprehension-syntax-in-loop-header-of-for-loop/25864&quot;&gt;允许在 for 循环的循环头中使用推导式语法&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;这个帖子提出了一个想法：让 Python 的 for 循环支持推导式语法“for i in x if i % 2 == 0:”。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-05-20-weekly2&quot;&gt;第2期（2023-05-20）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;http://coolshell.cn/articles/11265.html&quot;&gt;Python修饰器的函数式编程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了装饰器的实现原理、带参装饰器、多装饰器、类装饰器和几个典型的示例。文章发布于 2014 年，代码用的还是 Python 2。之所以分享这篇文章，因为它是&lt;a href=&quot;https://coolshell.cn/haoel&quot;&gt;左耳朵耗子&lt;/a&gt;唯一以 Python 为话题的文章，而且写得详细到位。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.cnblogs.com/traditional/p/17403428.html&quot;&gt;asyncio 的一些高级用法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;出自我们的老朋友@&lt;strong&gt;古明地觉&lt;/strong&gt; 的新系列《asyncio 系列》，半个月内已连载 14 篇。真想问问他是如何做到如此高产又高质量的？！文章回答了：如何设计既能接收协程又能接收普通 Python 函数的 API，如何强制事件循环的迭代，如何在不传递参数的情况下在任务之间传递状态……&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://segmentfault.com/a/1190000043790186&quot;&gt;Nginx+uWSGI 部署 Django 以及负载均衡操作&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了 uWSGI 和 Nginx 的配置，实现对 Django 服务的反向代理及负载均衡。该文出自仍在连载的《Django 系列》，目前该系列包含 44 篇文章，能作为系统学习 Django 的参考材料。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;http://vra.github.io/2023/05/17/rye-intro/&quot;&gt;Rye:一个实验性质的Python包管理系统&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 目前的包管理工具多得让人眼花缭乱，而 Conda 和操作系统的包管理器也存在诸多问题（本周刊第一期就有两则相关内容）。Flask 作者 Armin Ronacher 用 Rust 开发的 rye，借鉴了 Rust 包管理的经验，试图提供一个标准化的解决方案。这篇文章介绍了 rye 的安装及使用。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://juejin.cn/post/7232571353123487802&quot;&gt;PyInstaller：将你的Python代码打包成独立应用程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PyInstaller 可将 Python 程序打包为一个可执行文件，支持多个平台如 Windows、Mac 和 Linux。这是一篇简单清晰的使用教程，除了基础介绍外，难得的是它还介绍了两种打包方式的优缺点，以及打包后常见的 5 个问题。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://martinheinz.dev/blog/97&quot;&gt;如何在 Python 中实现真正的多线程&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;Python 3.12 即将推出“Per-Interpreter GIL（PEP-684）”特性，它允许 Python 实现真正的并行处理。代码虽然已在 alpha 版本中，但目前只能通过 C-API 使用。文章使用 CPython 的&lt;code&gt;test&lt;/code&gt; 模块演示了子解释器的示例。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://www.backblaze.com/blog/python-gil-vs-nogil-boost-i-o-performance-10x-with-one-line-change/&quot;&gt;GIL vs. nogil: 改动一行代码，提升十倍 I/O 性能&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://pythoncat.top/posts/2021-11-14-GIL&quot;&gt;nogil 项目&lt;/a&gt;是另一个试图实现真正多线程的方案，这篇文章测试发现 CPython 3.9-nogil 在单文件和多文件的情况下，比未修改的 CPython 3.9 分别快 2.5 倍和 10 倍。nogil 项目最新的进展是形成了正式的 PEP-703，相关介绍&lt;a href=&quot;https://pythoncat.top/posts/2023-02-20-GIL&quot;&gt;在此&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://blog.jetbrains.com/pycharm/2023/05/create-passphrase-generator-in-pycharm/&quot;&gt;如何在 PyCharm 中创建一个密码生成器？&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;PyCharm 官方推出的文章教程，指导在 PyCharm 中创建项目、导入包、使用 Typer 库创建 CLI 应用、运行和调试代码、创建和编辑运行配置，适合于新人学习练手。另外，PyCharm 2023.1.2 版本刚刚发布，可以去尝鲜！&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://coderslegacy.com/python-metaclass-tutorial/&quot;&gt;Python 元类教程（带示例）&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;在 Python 中，一切都是对象，包括&lt;strong&gt;类&lt;/strong&gt;。元类是 Python 的一项强大功能，允许你在运行时动态地创建类（实际是创建一个&lt;code&gt;type&lt;/code&gt; 类型的对象）。文章探讨元类的基础知识，以及更高级的功能和示例。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://www.warp.dev/blog/what-happens-when-you-open-a-terminal-and-enter-ls&quot;&gt;当在终端输入“ls”后会发生什么？&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;有一道很常见的面试题：“当在浏览器输入 google.com 后会发生什么？”由于见得多了，每个人都能回答个一二，但是，经常跟终端打交道的我们，能否回答这个问题呢：当在终端输入命令后会发生什么？文章主要介绍了终端的历史、启动过程、命令的解析和执行过程。&lt;/div&gt;
&lt;h3&gt;项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/marticliment/WingetUI&quot;&gt;WingetUI：更好用的包管理器 UI&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;该项目的目标是为 Win 10-11 中最常见的 CLI 包管理器（如 Winget、Scoop 和 Chocolatey）创建一个直观的 GUI。已支持软件包的安装、更新和卸载、排队安装、消息通知、黑暗模式、导入/导出等功能。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/gventuri/pandas-ai&quot;&gt;pandas-ai：支持 AI 功能的 Pandas&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;Pandas 无疑是目前最流行的数据分析和处理工具，当它结合了生成式 AI 的能力后，会不会更好用呢？答案似乎是的！pandasai 项目支持用文字的方式操作 Pandas 的数据对象，可简化很多 Pandas 库的操作。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/Undertone0809/promptulate&quot;&gt;promptulate：一个强大的 LLM Prompt Layer 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个专为 Prompt Engineer 设计的 LLM Prompt Layer 框架，支持连续对话、角色预设、对话存储、工具扩展等功能，可以无需代理直接访问，开箱即用。 通过 promptulate，你可以轻松构建起属于自己的 GPT 应用程序。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/micropython/micropython/releases/tag/v1.20.0&quot;&gt;MicroPython：面向微控制器和嵌入式系统的 Python&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;MicroPython 新发布了 1.20 版本，引入了一个新的轻量级包管理器，减小了代码大小，并增加了对许多新板的支持。另外，LWN 的&lt;a href=&quot;https://lwn.net/Articles/931051&quot;&gt;这篇文章&lt;/a&gt;对此版本做了介绍，文章还提到 Anaconda 有可能在 Q2 将 PyScript 的运行时从 Pyodide 替换为 MicroPython。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/csunny/DB-GPT&quot;&gt;DB-GPT：以数据库为基础的 GPT 实验项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用本地化的 GPT 大模型与你的数据和环境交互，无数据泄露风险，100% 私密，100% 安全。基于 FastChat 构建大模型运行环境，并提供 vicuna 作为基础的大语言模型，通过 LangChain 提供私域知识库问答能力，支持插件模式，在设计上原生支持 Auto-GPT 插件。&lt;/div&gt;
&lt;h3&gt;播客&amp;amp;视频&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pythonhunter.org/episodes/ep40&quot;&gt;Ep 40. Rust 和 PyO3：让 Python 再次伟大&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;断更许久的《捕蛇者说》播客回归了！本期的嘉宾是 PyO3 项目的维护者，他的另一个身份是 wechatpy 的作者。Rust 和 PyO3 项目能放大 Python 的优势，并能改造 Python 的应用生态。我们曾推荐过性能最快的代码分析工具 &lt;a href=&quot;https://pythoncat.top/posts/2023-04-09-ruff&quot;&gt;Ruff&lt;/a&gt;，另外 Flask 作者新开发的包管理工具 &lt;a href=&quot;https://github.com/mitsuhiko/rye&quot;&gt;rye&lt;/a&gt;，它们都是 Rust 与 Python 结合的产物。（题外话：看到了捕蛇者说的三位主播发推/发博缅怀左耳朵耗子，想不到他对 Python 圈子有这么多渊源。R.I.P）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://talkpython.fm/episodes/show/415/future-of-pydantic-and-fastapi&quot;&gt;Talk Python to Me #415: Future of Pydantic and FastAPI&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;Pydantic 2.0 使用 Rust 重写了核心及顶层的代码，将对构建在其之上的库产生积极的影响，比如 FastAPI。播客邀请了 Pydantic 的 Samuel Colvin 以及 FastAPI 的 Sebastián Ramírez 一起采访，话题度很新！&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.thoughtworks.com/insights/podcasts/technology-podcasts/fluent-python-revisited&quot;&gt;再访《流畅的 Python》作者 Luciano Ramalho&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;我在上个月推荐过新上市的《流畅的 Python》中文第二版（&lt;a href=&quot;https://pythoncat.top/posts/2023-04-28-fluent&quot;&gt;链接&lt;/a&gt;），这里补充两则相关材料。这期播客来自 thoughtworks，是在《Fluent Python》英文第二版上市前的访谈，介绍了关于 Python 发展、不同语言的对比、新书的变化等。另外，他们还在 2020 年新书写作期间录了&lt;a href=&quot;https://www.thoughtworks.com/insights/podcasts/technology-podcasts/future-python&quot;&gt;一期“The future of Python”&lt;/a&gt;，两期播客都有完整的文字稿。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://youtu.be/nH4qjmP2KEE&quot;&gt;最常用的七种分布式系统模式&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;一则简短的科普视频，介绍了七种分布式系统模式：Ambassador、Circuit Breaker、CQRS、Event Sourcing、Leader Election、Publisher/Subscriber、Sharding。视频中的动画和图例都非常直观和舒适，让人赏心悦目。&lt;/div&gt;
&lt;h3&gt;问题&amp;amp;讨论&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.v2ex.com/t/940584&quot;&gt;作为程序员，有什么提升生活/工作体验的 App、硬件、服务？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;V2ex 上的一个帖子，大家对这样的话题似乎很有发言欲。我在此最想推荐的 APP 是 Feedly 和 Substack，用于阅读 RSS 和 Newsletter。Feedly 对本周刊的素材采集帮助极大！（心愿：依靠读者的打赏，让我用上 Feedly Pro+ 的 AI 功能！）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/mitsuhiko/rye/discussions/6&quot;&gt;rye 应该存在么？&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;前文已提到过 rye，那么，mitsuhiko 是出于什么考虑而开发了它呢？它想解决什么样的问题，想打造出一款什么样的工具呢？Python 官方对包管理会有什么发展支持呢？Github 上的这个问题引起了广泛的讨论。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.v2ex.com/t/940195&quot;&gt;你是怎样开始程序员职业生涯的？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;V2ex 上的帖子，楼主分享了自己从读书到就业前几年的故事，评论区有不少人分享了自己的经历。你是如何开始自己的程序员之路的呢？&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-05-27-weekly3&quot;&gt;第3期（2023-05-27）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://segmentfault.com/a/1190000043822529&quot;&gt;掌握Python面向对象编程的关键：类与对象&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍类和对象概念，通过示例展示 Python 中的类和对象如何工作，包括定义、实例化和继承等。文章出自《Python全景系列》，目前已更新七篇。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://juejin.cn/post/7232977661207085117&quot;&gt;umongo + motor: 构建高效 MongoDB 应用的最佳组合&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍如何在 Tornado 中集成 umongo 和 motor，实现用异步非阻塞的方式与 MongoDB 进行交互。文章出自《tornado 并发编程系列》，目前已更新六篇。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://juejin.cn/post/7234821431804002365&quot;&gt;徒手使用 LangChain 搭建一个 ChatGPT PDF 知识库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;演示了如何使用 langchain 和 ChatGPT 搭建一个本地的 PDF 知识库，文中使用了 pdfplumber 处理 PDF 文件、使用 streamlit 绘制 UI 界面。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://laike9m.com/blog/python-zhen-de-shi-kao-yi-ge-switch-lai-zhi-xing-zi-jie-ma-de-ma,138&quot;&gt;Python 真的是靠一个 switch 来执行字节码的吗？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个流行的观点说：CPython 有一个大&lt;strong&gt;switch&lt;/strong&gt;，会根据不同的 opcode 跳到相应的 case 分支去执行字节码。文章提出了质疑，最后的结论是：只要 Python 启用了 computed goto （比如在 Mac 和 Linux 上），字节码的执行就不依赖 switch。而这个功能在 Python 3.2 中就已是默认开启的。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.bmpi.dev/dev/renaissance-sqlite&quot;&gt;SQLite 的文艺复兴&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章的开头把我震惊了：“SQLite 源码有 15 多万行，但测试代码和脚本竟有九千多万行”！文章介绍了 SQLite 的架构，以及多个基于它的开源项目，如 Litefs、sql.js、absurd-sql、postlite、sqlite3vfshttp 等等，回答了为什么 SQLite 能在如此多领域有创新的项目出现？&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://soulteary.com/2023/04/05/eighty-lines-of-code-to-implement-the-open-source-midjourney-and-stable-diffusion-spell-drawing-tool.html#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2&quot;&gt;八十行代码实现开源的 Midjourney、Stable Diffusion “咒语”作图工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;通过 Docker 和 80 行左右的 Python 代码，实现一款类似 Midjourney 官方图片解析功能 Describe 的 Prompt 工具。提供了两个版本的工具，分别支持 CPU 和 GPU 推理使用。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://kobzol.github.io/rust/python/2023/05/20/writing-python-like-its-rust.html&quot;&gt;像写 Rust 一样写 Python&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;分享了从 Rust 中学到的一些编程习惯：使用类型提示、使用数据类代替元组或字典、使用代数数据类型、使用“newtype”、使用构造函数、使用互斥锁等。总体而言，它们并不是那些“个人喜好式”的编程风格，而是切实能提升代码健壮性和可维护性的编程经验。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://www.patricksoftwareblog.com/flask_tips.html&quot;&gt;一系列的 Flask 小贴士&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;这个《Flask Tips》栏目已分享了 58 个使用 Flask 的小知识，另外其作者在最新的博文《&lt;a href=&quot;https://www.patricksoftwareblog.com/my_favorite_python_packages_for_flask.html&quot;&gt;我开发 Flask 程序时最喜欢用的库&lt;/a&gt;》中，介绍了 APIFairy、Frozen-Flask、Flask-SQLAlchemy 等 10 个常用的库。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://steve.dignam.xyz/2023/05/20/many-problems-with-celery/&quot;&gt;Celery 的诸多问题&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;Celery 是一个分布式任务队列库，用于实现异步处理和定时任务等功能。但它有很多“问题”，这篇文章一口气列出了 15 个，是一份避坑指南。不过，并非所有问题都有解决方案，比如说它 API 接口不够 Pythonic、没有类型检查等，这些就只能“Live with it”了……&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://last9.io/blog/using-golang-package-in-python-using-gopy/&quot;&gt;Python 借助 Gopy 库实现调用 Go 包&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;作者遇到一个静态验证 PromQL 查询的需求，但没有可用的 Python 库。文章介绍了使用  Gopy 将 Go 代码编译成 wheel 文件的方法，另外也提醒几个注意事项，比如对错误的处理、操作系统的兼容性问题、调试和测试的问题。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://pythonspeed.com/articles/best-file-format-for-pandas/&quot;&gt;最适用于 Pandas 的文件格式&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;使用 Pandas 前需要加载数据，它支持非常多种数据格式，但哪种才最合适呢？文中给出了三个衡量标准（类型支持、磁盘格式、读写速率），并测试了三种数据文件（CSV、JSON 和 Parquet），你猜最后的结论是什么呢？&lt;/div&gt;
&lt;div&gt;12、关于 PyPI 的一系列新闻/文章（英文）&lt;/div&gt;
&lt;div&gt;PyPI 在 3 月上线了官方博客，5 月初刚宣布获得了 AWS 的 14.4 万美元赞助，用于开设一个新的安全工程师职位。巧的是本周密集出现了几件与安全相关的事情。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;5.21，PyPI 在连续一周受到恶意软件的侵扰后，&lt;a href=&quot;https://status.python.org/incidents/qy2t9mjjcc7g&quot;&gt;临时暂停&lt;/a&gt;了新用户的注册及新项目的上传。（这有&lt;a href=&quot;https://programmingeeksclub.com/pypi-security-threats-implications-python-community&quot;&gt;一篇文章&lt;/a&gt;，提到一则有相关性的新闻，这些恶意软件可能是趁 ChatGPT 的热点，通过窃取剪贴板内容从而劫持加密货币交易）&lt;/li&gt;
&lt;li&gt;5.23，PyPI &lt;a href=&quot;https://blog.pypi.org/posts/2023-05-23-removing-pgp/&quot;&gt;宣布移除 PGP 签名&lt;/a&gt;，因为近三年上传的签名仅有 36% 为有效的，移除这项功能有利于降低维护成本。（这有&lt;a href=&quot;https://blog.yossarian.net/2023/05/21/PGP-signatures-on-PyPI-worse-than-useless&quot;&gt;一篇文章&lt;/a&gt;，使用大量数据和统计图分析了 PyPI 上糟糕的 PGP 情况）&lt;/li&gt;
&lt;li&gt;5.24，PyPI 发了&lt;a href=&quot;https://blog.pypi.org/posts/2023-05-24-pypi-was-subpoenaed&quot;&gt;一篇博客&lt;/a&gt;，披露 PSF 收到了美国司法部的三张要求提供 PyPI 用户数据的传票，在律师的建议下，他们提供了司法部索要的数据，并公开了传票的相关细节。&lt;/li&gt;
&lt;li&gt;5.25，PyPI 发布《&lt;a href=&quot;https://blog.pypi.org/posts/2023-05-25-securing-pypi-with-2fa&quot;&gt;通过双因素身份验证保护 PyPI 帐户&lt;/a&gt;》，宣布在 2023 年底前，PyPI 上的帐户都必须启用双重验证（2FA），以此提升账户的安全性。&lt;/li&gt;
&lt;li&gt;5.26，PyPI 发布《&lt;a href=&quot;https://blog.pypi.org/posts/2023-05-26-reducing-stored-ip-data&quot;&gt;减少 PyPI 中存储的 IP 数据&lt;/a&gt;》，介绍了团队出于不存储用户 IP 的目的而做的一些事情，试图既要保护用户的隐私，又能更好地运维管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/Syan-Lin/CyberWaifu&quot;&gt;CyberWaifu：使用 LLM 和 TTS 实现的聊天机器人&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用 LangChain 作为 LLM 主体框架，使用 go-cqhttp 进行 QQ 机器人部署，TTS 支持 vits、edge-tts，语言模型支持ChatGPT 和 Claude。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/c121914yu/FastGPT&quot;&gt;FastGPT：基于 openai 搭建的知识库平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;技术栈: NextJs + TS + ChakraUI + Mongo + Postgres，支持私有化部署，可以在线体验。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/pyrustic/jesth&quot;&gt;jesth：更具可读性的数据序列化格式&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;文档将这种新格式与 TOML、YAML 和 JSON 分别做了对比，并详细展示了在 Python 中的使用方法。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/Textualize/trogon&quot;&gt;trogon：为 CLI 程序生成友好的用户界面&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;命令行程序本就是无界面的，但是这对于用户来说不够友好。这个项目可以生成美观的界面，用于编辑和运行命令。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/ipyflow/ipyflow&quot;&gt;ipyflow：用于 Jupyter 笔记本的响应式 Python 内核&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;可在交互式会话期间，跟踪符号和单元格之间的数据流关系，支持的功能：显示执行建议、支持响应式执行、语法拓展、集成了 ipywidgets，等等。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/widgetti/solara&quot;&gt;solara：一个纯 python、React-风格的框架&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;solara 可使用 Reacton（纯 Python 实现的 React）创建基于 ipywidget 的程序。可用在 Jupyter Notebook，也可以作为独立的 Web 程序在 FastAPI 等框架中使用。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://pythoninsider.blogspot.com/2023/05/python-3120-beta-1-released.html&quot;&gt;Python 3.12 的 beta 1 版本已发布&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;3.12 的最终版本计划在 10 月 2 日发布，目前发布了 beta 1 版本，意味着不会再加入新功能。总体而言，这个版本更为精简了（删除了很多函数、类和方法），性能方面也有很多优化。值得一提的是，这个版本虽然引入了 PEP-684（每个子解释器的独立 GIL），但需要等 3.13 版本实现 PEP-554（标准库中的多解释器）后，才真正的可用。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://programming-idioms.org/cheatsheet/Python/Rust&quot;&gt;对比 Python 与 Rust 的编程习惯用法&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;这是一个有意思的网站，可比较不同编程语言在 300 多项习惯用法上的区别，提升学习效率。我们这里比较了 Python 和 Rust，在网站首页可选的语言有 30 种。&lt;/div&gt;
&lt;h3&gt;播客&amp;amp;视频&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.edx.org/course/cs50s-introduction-to-programming-with-python&quot;&gt;哈佛大学的 Python 编程入门课程&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;哈佛大学计算机科学专业的入门课程，向初学者介绍计算机科学和编程基础，以及如何使用 Python 进行编程。目前已有 50 万人参与学习。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://pybit.es/articles/django-plugin-recommendations-by-antonio-mele-top-10-picks-for-web-development/&quot;&gt;推荐 10 个最好用的 Django 插件&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;这期视频中，《Django by Example》书籍的作者推荐了 10 个 Django 插件，例如 Django Debug Toolbar、Django REST Framework、Django Channels，等等。&lt;/div&gt;
&lt;h3&gt;问题&amp;amp;讨论&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://tech.slashdot.org/story/23/05/23/1940217/28-years-later-windows-finally-supports-rar-files&quot;&gt;Windows 要支持 tar、7-zip、rar、gz 等格式啦？&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;来自一则匿名爆料，Windows 要利用开源项目 libarchive 实现对 rar 等格式的支持了。这会是真的么？&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.reddit.com/r/Python/comments/13nfyir/best_language_for_building_apis_tsjs_vs_py/&quot;&gt;构建 API 的最佳语言——TS/JS vs. Python&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;从可维护性、优雅性、灵活性和开发速度的角度来看，这两种语言的 API 开发体验哪种更好？&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-05-31-weekly4&quot;&gt;第4期（2023-05-31）&lt;/a&gt;&lt;/h2&gt;
&lt;div&gt;本期是特别加更版，聚焦于 Python 官方 2023 年语言峰会的系列博客。&lt;/div&gt;
&lt;div&gt;每年在 PyCon US 开始之前，Python 核心开发者、维护者和特邀嘉宾都会聚在一起参加 Python 语言峰会：这是一个为期一天的会谈活动，讨论 Python 的未来方向。&lt;/div&gt;
&lt;div&gt;今年的活动刚结束一个月，PSF 在本周一发布了多篇博客，回顾了峰会上的一些演讲内容。本期周刊将这些文章进一步作了摘要，分享给大家：&lt;/div&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-three.html&quot;&gt;Three Talks on the C API&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是关于 C API 的三场演讲。首先，Mark Shannon 和 Guido van Rossum 提及当前 C API 对第三方扩展的支持不够，经常在升级版本时破坏它们的功能。会上的结论是收集 C API 的问题清单，再制定解决方案。&lt;/div&gt;
&lt;div&gt;另一场演讲是关于 HPy，它是一个用于编写 Python 扩展模块的新的 API，旨在解决 CPython C API 的一些限制和问题。它的好处是编写的扩展模块可以在不同的 Python 实现中运行，例如 CPython 和 PyPy。但是，演讲者想要官方将它作为推荐方案的想法没有得到支持，一方面的原因是它还不够完善，更重要的原因则是 Guido 评论的自上而下的方法行不通。HPy 似乎是挺不错的克服 C API 问题的方案，但它要取代 C API 的地位，还为时尚早。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-making.html&quot;&gt;Making the Global Interpreter Lock Optional&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;我们曾多次介绍过 nogil 项目，比如在周刊第二期就分享了一篇文章。在本次峰会上，nogil 的作者 Sam Gross 介绍了过去一年的进展，给出了 nogil 在性能上取得的令人满意的数据，还提出了更明确的路线图。大家最担心的依然是它提出编译成两个发行版、以及导致的调试困难等问题。（我们曾在 2 月份的&lt;a href=&quot;https://mp.weixin.qq.com/s/HHSjv0ZlAjq0ZvLHMI-W9g&quot;&gt;一篇文章&lt;/a&gt; 中讨论过）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-towards.html&quot;&gt;Towards Native Profiling for Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Joannah Nanjekye 的演讲介绍了 Scalene，这是一个基于采样的 Python 分析器，可以在报告中区分机器代码和 Python 代码。使用 C、C++ 或 Rust 编写的 Python 扩展会被编译为机器代码，因此很难用采样的方式分析。Scalene 解决了一些技术难题，是最受欢迎的 Python 分析工具之一。演讲者试探性提出将 Scalene 的成果集成到标准库 &lt;code&gt;cProfile&lt;/code&gt; 中，但没有得到响应。最后，这个库还被拿来跟 Python 3.12 中引入的 &lt;code&gt;perf&lt;/code&gt; 分析器作比对。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-what-is.html&quot;&gt;What is the stdlib for?&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Brett Cannon 提出的问题实际是：标准库应该扮演什么样的角色？Python 在发展初期自诩“自带电池”，包含了很多标准库，但随着第三方库越来越丰富以及 PyPI 使得安装库非常便利，很多标准库就不再有价值了。与会者的共识是：标准库应该专注于帮助用户编写更好的 Python 代码。这意味正在进行的标准库“瘦身计划”不会停，同时，未来的新标准库会更加规范引入。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-pattern.html&quot;&gt;Pattern Matching, __match__, and View Patterns&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;模式匹配语法是 3.10 版本的重大特性，但是 Sullivan 认为它的能力相当有限，因此提出了模式匹配的后续发展方向。与会者们普遍认同要增强模式匹配语法，然而，是否要引入一个新的魔术方法 __match__，或者采用别的方案，暂无定论。文中附有很多代码示例以及关于模式匹配的参考资料，对此话题感兴趣的同学可以去了解下。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-python.html&quot;&gt;Python on Mobile: State of the Union&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Russell Keith-Magee 介绍了 BeeWare，它的目标是在 Android 和 iOS 等移动平台上轻松运行 Python。项目已得到 Anaconda 的投资支持，演讲者的诉求是希望得到 CPython 的“Tier-3”支持。会上讨论了 CI 测试套对移动平台的支持、sys.platform 在移动平台应该得到什么值、以及如何在移动平台发布 CPython 二进制文件，等等。手机上的 Python，这值得期待！&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-burnout.html&quot;&gt;Burnout is Real&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Guido 在峰会上聊了开源倦怠、解决倦怠的策略、以及如何避免倦怠等话题。很多时候，开源贡献者都是在用爱发电，然而大型开源项目还常常有复杂的场景、琐碎的讨论、多样的人际协作、时常冲突的观点或想法等，这些都容易让人疲倦、消磨人的热情。（PS.如果你关注技术新闻的话，会看到 Rust 社区最近闹得沸沸扬扬的核心开发者内讧事件。开源社区的发展也是一大难题，庆幸的是这届峰会反映出 Python 社区是在健康发展中）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023.html&quot;&gt;Lightning Talks&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了三场简短的闪电演讲，主题有：让我们支持 LLVM-BOLT 作为官方功能、在 Python 中实现延迟导入的机制、让模块支持调用（已提出 PEP-713）。&lt;/div&gt;
&lt;div&gt;以上就是今年峰会上讨论的重大议题，可以说都是非常有意义的话题。&lt;/div&gt;
&lt;div&gt;有不少内容其实已经有了最新进展（毕竟活动已结束一个月），还有一些可能仍需较长时间才能尘埃落定（比如 nogil 和手机上的 Python）。&lt;/div&gt;
&lt;div&gt;这里再补充两篇文章，有关于 Fast CPython 项目的进展：《&lt;a href=&quot;https://lwn.net/Articles/930705&quot;&gt;Faster CPython at PyCon, part one&lt;/a&gt;》、《&lt;a href=&quot;https://lwn.net/Articles/931197/&quot;&gt;Faster CPython at PyCon, part two&lt;/a&gt;》，Python 3.11 已经让大家看到了非常多的性能提升，未来版本更值得期待。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-06-03-weekly5&quot;&gt;第5期（2023-06-03）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pkolaczk.github.io/memory-consumption-of-async/&quot;&gt;并发一百万个任务要用多少内存？&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;文中测试了主流的编程语言（Rust、Go、Java、C#、Python、Node.js 和 Elixir），依次运行 1 个、1 万、10 万和 100 万个任务，统计了这些语言所消耗的内存。随着任务量增加，它们的排名出现了较大变化，让我感觉挺意外的。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://towardsdatascience.com/use-these-methods-to-make-your-python-concurrent-tasks-perform-better-b693b7a633e1&quot;&gt;使用这些方法让你的 Python 并发任务执行得更好&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;使用 asyncio 有什么最佳实践呢？这篇文章介绍了 asyncio.gather、asyncio.as_completed 和 asyncio.wait API，还介绍了 Python 3.11 中引入的新 asyncio.TaskGroup 特性。（附一篇&lt;a href=&quot;https://juejin.cn/post/7237424021768011834&quot;&gt;不完整的译文&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;3、原推荐文章为拼凑且非原创，已删&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://programmingeeksclub.com/ultimate-python-multithreading-guide&quot;&gt;Python 多线程编程的终极指南&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;也是一篇长文，介绍了 Python 多线程编程的方方面面，真的是一份终极指南。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.bmpi.dev/dev/deep-in-program-language/how-to-implement-concurrency/concurrency-model/&quot;&gt;编程语言是如何实现并发的之并发模型篇&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;依然是长文，介绍了常见的并发模型及不同编程语言是如何实现的。它的姊妹篇是《&lt;a href=&quot;https://www.bmpi.dev/dev/deep-in-program-language/how-to-implement-concurrency/os-scheduling/&quot;&gt;编程语言是如何实现并发的之操作系统篇&lt;/a&gt;》，都是图文并茂，资料翔实。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://segmentfault.com/a/1190000043833549&quot;&gt;鹅厂程序员的 9 个生存法则&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者分享了自己工作多年对代码设计、架构设计和工作思维的经验，比如 DRY 原则、SOLID 原则、高可用设计、如何想尽一切办法“偷懒”，等等。（文中提到了面向对象编程的原则，这里顺便推荐另一位鹅厂程序员的《&lt;a href=&quot;https://github.com/piglei/one-python-craftsman&quot;&gt;Python工匠&lt;/a&gt;》系列的第 12-14 章）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://juejin.cn/post/7238274120881422392&quot;&gt;一览 Python 3.12！PEP 701 —— f-string 语法规范化&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;f-string 是 Python 最好用的特性之一，但它也有诸多限制。即将发布的 3.12 会对 f-string 作语法规范化，详情可查看 &lt;a href=&quot;https://peps.python.org/pep-0701/&quot;&gt;PEP-701&lt;/a&gt; 。这里分享的文章带大家直观地感受了这个改动在代码的词法解析（lexing）层面的不同。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://blog.jetbrains.com/pycharm/2023/05/five-things-to-love-about-the-new-ui/&quot;&gt;PyCharm：新用户界面的五大亮点&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;大家都用上 PyCharm 新的 UI 了么？这份官方教程介绍了新 UI 的使用方法及亮点。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://discuss.python.org/t/pep-594-has-been-implemented-python-3-13-removes-20-stdlib-modules/27124&quot;&gt;PEP-594 已被实现：Python 3.13 将移除 20 个标准库&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;Python 3.12 正式版本还要几个月才发布，这边 3.13 已经迫不及待地移除了 20 个标准库。值得一提的是，2to3 项目及 lib2to3 模块也将会被移除。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://innovation.alteryx.com/introducing-grasshopper-an-open-source-python-library-for-load-testing/&quot;&gt;Grasshopper：一个用于负载测试的开源 Python 库&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;Locust 是 Python 最主流的分布式负载测试库，而文章介绍的 &lt;a href=&quot;https://github.com/alteryx/locust-grasshopper&quot;&gt;Grasshopper&lt;/a&gt; 是新开源的基于 Locust 与 Pytest 的更全面的性能测试库。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://hackthedeveloper.com/python-decorator/&quot;&gt;Python 装饰器：用包装巫术增强你的代码&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;Python 装饰器是增强代码行为和灵活性的强大工具，文章内容从基础到高阶，是不错的学习材料。&lt;/div&gt;
&lt;div&gt;12、三个练手项目的实战教程：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://swiftuser.hashnode.dev/how-to-telegram-bot-with-python&quot;&gt;用 Python 开发 Telegram 机器人&lt;/a&gt; （英文）：开发 tg 机器人，教程使用 Tornado 作后端，项目部署在 Render 平台上&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://implement-dns.wizardzines.com/index.html&quot;&gt;花一周末用 Python 实现 DNS&lt;/a&gt; （英文）：教程指导实现一个 DNS 解析器，总代码仅约 200 行，但作者给出了很多学习材料和代码讲解，你能学到的绝对够多。另外，教程最后还有 7 个练习题，可以进一步开发 DNS 解析器的功能。（Julia Evans 是一个宝藏作者，&lt;a href=&quot;https://jvns.ca/&quot;&gt;博客&lt;/a&gt;、&lt;a href=&quot;https://wizardzines.com&quot;&gt;网站&lt;/a&gt; 、&lt;a href=&quot;https://github.com/jvns/pandas-cookbook&quot;&gt;pandas-cookbook&lt;/a&gt; ，等等，强烈推荐！！！）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.leshenko.net/p/ugit/&quot;&gt;用 Python 构建你自己的 Git&lt;/a&gt; （英文）：这个项目我要给它满分！教程网站设计得独特而酷炫，从最小可行项目起步，逐渐添加代码，手把手教你实现 Git 的各种功能。每章都使用 Git 的差异比对方式，明确告诉你增删了哪些代码，良心满满，全网估计找不着第二家！&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/Textualize/frogmouth&quot;&gt;frogmouth：一个在终端中浏览 Markdown 的工具&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;frogmouth 可以打开本地或 URL 中的 md 文件，具有类似浏览器的导航条、历史记录、书签和目录。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/dibrale/samist&quot;&gt;使用 Meta AI 的 SAM 进行图像分割的 Python GUI&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;一个 Python 桌面程序，为 Meta 公司的 AI 模型 SAM 提供了图形界面，可以提取照片里面的物体。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/EniasCailliau/GirlfriendGPT&quot;&gt;GirlfriendGPT：你的人工智能伴侣&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;你有对象了么？这个入门项目使用 ChatGPT 构建一个 AI 伴侣， 拥有个性化的人格、声音以及自拍照！&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://www.slideshare.net/Manjusaka1/python-pptx-258083055&quot;&gt;Python 进化之路.pptx&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一份技术分享的 PPT 材料，介绍了 Python 3.7-3.11 在性能、类型体验及开发者体验方面的优化。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/lucidrains/soundstorm-pytorch&quot;&gt;soundstorm-pytorch：在 Pytorch 中实现 SoundStorm &lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;SoundStorm 是 Google Deepmind 新提出的一个高效的、非自回归的音频并行生成模型。soundstorm-pytorch 使用 Pytorch 实现了这个模型。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/quora/asynq&quot;&gt;asynq：Python 的异步编程库&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;asynq 是 Quora 开发的异步编程库，专注于对外部服务的批处理请求。对于 memcache、redis 等存储服务，它发起一次请求批量获取多个 key，比发出多次请求每次获取一个 key 要快得多。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/Lancetnik/Propan&quot;&gt;Propan：功能强大且易用的 Python 异步 Web 框架&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;一个基于 pydantic、fastapi 和 pytest 的异步框架，简化了 MQ 的代码集成，并提供了一个有用的开发工具包。其特点是基于消息架构（Messaging Architecture）设计，所以它还是个声明式的 MQ 框架。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://vra.github.io/2023/05/27/talkgpt4all-2-0/&quot;&gt;talkGPT4All：基于 GPT4All 的一个语音聊天程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它利用 OpenAI 的 Whisper 模型将用户输入的语音转换为文本，再调用 GPT4All 的语言模型得到回答文本，最后利用文本转语音（TTS）的程序将回答文本朗读出来。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/lightly-ai/lightly&quot;&gt;lightly：一个用于图像自监督学习的 Python 库&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;这是一个用于自我监督学习的计算机视觉框架，以类似 PyTorch 的风格编写，支持使用 PyTorch Lightning 进行分布式训练。&lt;/div&gt;
&lt;h3&gt;播客&amp;amp;视频&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.xiaoyuzhoufm.com/episode/647456af6752b5f9de6bd99c&quot;&gt;硬地骇客：独立开发赚钱难？你需要正确的build策略&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;探讨了在海外独立开发者中最常用的 &lt;strong&gt;build in public&lt;/strong&gt; 策略。我对这期节目很有共鸣，打算针对本周刊的一些数据、周刊的创作流程、个人知识输入及创作体系等话题，不久会做一些分享。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.xiaoyuzhoufm.com/episode/646af4a66752b5f9dec561c6&quot;&gt;代码之外：离开微软、人生在于体验？阅读的意义、主动和被动的人生&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一档新上线的程序员闲聊播客节目，主题很随性，但常常有能打动人的片段。这里分享的是第一期，它目前已更新到第三期，第三期请的嘉宾是 Vue 的作者尤雨溪！&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://changelog.com/podcast/526&quot;&gt;Changelog #526：与你的朋友一起 Git&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;这期播客聊了一些 Git 工具，如 Git-Heat-Map、Git-Sim、git-bug、GitUI，等等。因为有两个工具是用 Python 编写的，因此也聊了一些 Python 安装依赖包的话题。Brett Cannon 针对主播们的错误用法，写了一篇&lt;a href=&quot;https://snarky.ca/in-response-to-the-changelog-526/&quot;&gt;回应博客&lt;/a&gt; ，主要介绍了 pipx、.pyz 文件以及系统包管理器的正确使用。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://talkpython.fm/episodes/show/418/how-to-keep-a-secret-in-python-apps&quot;&gt;#418：如何在 Python 程序中加密保存&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;“Talk Python To Me”的这期播客探讨如何处理程序要用到的敏感信息，同时也聊到了日常个人密码的保存方案。我正巧本周还看到一篇《&lt;a href=&quot;https://xuanwo.io/reports/2023-21/&quot;&gt;2023-21: 我的 1Password 密钥管理实践&lt;/a&gt;》，它系统介绍了密码管理、SSH/Shell 集成和 CI/CD 应用等内容。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.deeplearning.ai/short-courses/?continueFlag=40c2724537472cbb3553ce1582e0db80&quot;&gt;吴恩达三门新的生成式 AI 课程&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;使用 OpenAI 的 ChatGPT API 构建系统、LangChain 用于开发 LLM 应用、Diffusion模型是如何工作的。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://twitter.com/python_spaces/status/1663976856578822144&quot;&gt;MIT 的三门 Python 相关课程&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;麻省理工学院的免费课程：Python 计算机科学和编程简介、经典机器学习、深度学习。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-06-10-weekly6&quot;&gt;第6期（2023-06-10）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://zhuanlan.zhihu.com/p/634654153&quot;&gt;CPython 贡献日记：Python 3.12 有什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章出自群友@孙孟越，介绍了 Python 3.12 中他深度参与的几个大更新，比如 PEP-701 定型 f-字符串的句法、PEP-688 给 Python Buffer Protocol 暴露 Python 接口、PEP-695 类型参数语法，等等。另外，他在前一篇《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/623602662&quot;&gt;CPython 贡献日记&lt;/a&gt;》中介绍了给开源社区做贡献的相关知识，比如提 PR 的小技巧、提/解决 Issue 的小技巧，等等。（你也想给 Python 贡献代码么？请参考：&lt;a href=&quot;https://devguide.python.org/&quot;&gt;Python Developer’s Guide&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://topbook.cc/overview?selectedArticle=1975&quot;&gt;有哪些值得关注的 AI 工具？我们整理了这 67 个&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了目前流行的 67 个工具，包括大语言模型、搜索引擎、办公、内容生成、精神需求、提示词学习等方向，它还梳理了下面这张思维导图：&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://juejin.cn/post/7240248679515963451&quot;&gt;我买了本豆瓣 9.6 分的 Python 书，发现里面每 5 页一个错误？！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章从一本 Python 入门书籍中找出了 30 个有代表性的错误，并给出了“离谱程度”评分。作者批判性阅读了那本书，同理，读者们也应该批判性阅读这篇文章，因为它说得也并不都对。（@TheFry 投稿）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://borretti.me/article/sketch-post-orm&quot;&gt;Sketch of a Post-ORM&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;通常我们使用纯 SQL 或者 ORM 框架来操作数据库，作者比较了这两种方案，指出了它们的诸多缺陷，然后提出了一种新的技术设想。作者从 8 个方面介绍了自己的思路，包括迁移优先、声明式迁移、跨语言移植、更好的 SQL，等等。作者还演示了一个工作流以及 Python 代码示例。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://martinheinz.dev/blog/98&quot;&gt;Python 中运行 Shell 命令的正确做法&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;作者先介绍了 Python 与操作系统交互的一些常用库，比如 pathlib、tempfile、shutil、os、subprocess 等等，最后再介绍了他最为推荐的 &lt;a href=&quot;https://github.com/amoffat/sh&quot;&gt;sh&lt;/a&gt; 库的相关用法。这个库的方法对熟悉 shell 命令的同学非常友好。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://www.vidavolta.io/how-to-upgrade-your-flask-application-using-async/&quot;&gt;如何使用 async 升级 Flask 程序&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章使用 Locust 作负载测试，简单演示了将同步的 Flask 程序修改为异步后，性能数据上的变化。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://snarky.ca/proposing-a-struct-syntax/&quot;&gt;提议给 Python 添加一个结构语法&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;核心开发者 Brett Cannon 的博客介绍了他的思考，提议增加一个&lt;code&gt;struct&lt;/code&gt; 关键字，用于更方便地创建数据类，类似于 C、Rust 与 Go 的结构语法。文中介绍了他的目标以及这个关键字的实现原理，目前在收集意见阶段，未来不排除会提成一个 PEP。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://juejin.cn/post/7240380161555234876&quot;&gt;类属性和实例属性是怎样的关系？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;出自《从 1 到 ∞ 精通 Python》系列，已包含 17 篇文章。作者参考了《Python 源码剖析》的分析方法及结论，深度探析了 Python 解释器源码，讲解 Python 重要特性的实现原理。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://dev.to/lambdatest/39-top-python-frameworks-to-look-for-in-2023-3hdb&quot;&gt;2023 年 39 个顶级 Python 框架&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章梳理介绍了 39 个用于开发及测试的 Python 框架，内容很长，介绍的范围很全面。&lt;/div&gt;
&lt;div&gt;10、内容删除&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://www.pythonguis.com/tutorials/getting-started-kivy/&quot;&gt;使用 Kivy 库进行 GUI 开发&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这是一篇入门教程。Kivy 是一个用于开发图形用户界面的库，支持桌面的跨平台开发，也支持为移动设备创建多点触控的程序。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://pythonspeed.com/articles/speeding-up-numba/&quot;&gt;了解 CPU 有助于提升 Numba 和 NumPy 代码的速度&lt;/a&gt;  (英)&lt;/div&gt;
&lt;div&gt;当需要加快 NumPy 速度或减少其运行内存时，通常使用即时编译器 Numba。文章针对现代 CPU 的特点来优化 代码，将一个去除图像中的噪点程序的耗时从 48 ms 降到了 2 ms。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://www.reversinglabs.com/blog/when-python-bytecode-bites-back-who-checks-the-contents-of-compiled-python-files&quot;&gt;当字节码咬人时：谁检查 Python 文件编译后的内容？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;ReversingLabs 研究团队发现了一种针对 PyPI 的新型攻击，它使用编译后的 Python 代码来规避检测——可能是第一个利用 PYC 文件直接执行的攻击。&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;http://arthurchiao.art/blog/gpt-as-a-finite-state-markov-chain-zh/&quot;&gt;GPT 是如何工作的：200 行 Python 代码实现一个极简 GPT&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一篇译文，原文作者是 OpenAI 的创始成员 Andrej Karpathy。文章使用 PyTorch 实现了一个极简 GPT，让读者对其内部工作机制有个直观理解。&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;http://arthurchiao.art/blog/transformers-from-scratch-zh/&quot;&gt;600 行 Python 代码实现两个 Transformer（文本分类+文本生成）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这也是一篇译文，原文作者是阿姆斯特丹自由大学的助理教授。原文最早写于 2019 年，那时大语言模型还没有如今火爆。在文章末尾，作者希望 transformer  扩展到其它领域，因为它有很强的通用性。&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/neodb-social/neodb&quot;&gt;neodb：标记你喜欢的东西&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;NeoDB 是一个用 Django 写的开源项目，也是一个联邦宇宙书影音游戏标注平台，可简单理解成 Web3 的开源的无审查的豆瓣，但支持标记的内容比豆瓣多得多。（这个库是在@laike9m 的博客看到的。以及非常感谢他在 Twitter 上推荐了本周刊！！）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://blog.jupyter.org/jupyterlab-4-0-is-here-388d05e03442&quot;&gt;JupyterLab 4.0 已发布&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;JupyterLab 4.0 主要的新功能有：性能更快、升级的文本编辑器、新的扩展管理器、UI 改进，等等。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/bloomberg/pystack&quot;&gt;pystack&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;pstack 是 Linux 系统上常用的命令行工具，用于显示一个进程的函数调用栈，可诊断进程卡死、死锁等问题，以及分析进程的性能瓶颈。pystack 是用 Python 写成的类 pstack 库。值得一提的是，它竟然还可以显示线程是否持有、是否在等待或正在释放 GIL。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://gpython.aibang.run/&quot;&gt;GPYTHON：你的专属 Python 学习助手&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个基于 ChatGPT 的 Python 在线学习平台，内置了 AI 助手以及在线代码运行模块，允许你随时修改示例代码，一键运行，一键查错。（@Stanaaa 投稿）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://huggingface.co/moka-ai/m3e-base&quot;&gt;M3E 模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;M3E 是一个中文开源的 Embedding 模型，使用千万级 (2200w+) 的中文句对数据集进行训练，在文本分类和文本检索的任务上都超越了 openai-ada-002 模型。（@王宇昕投稿）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/reactive-python/reactpy&quot;&gt;reactpy：Python 的 React&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;ReactPy 是一个库，用于在 Python 中构建用户界面，且不使用 Javascript。它的接口类似于 ReactJS 中的组件，可供没有 Web 开发经验的人使用。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/mouday/domain-admin&quot;&gt;domain-admin: 域名 SSL 证书监测平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于 Python + Vue3.js 技术栈实现的域名和 SSL 证书监测平台，核心功能：到期自动邮件提醒。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/NaiboWang/EasySpider&quot;&gt;EasySpider：一个可视化爬虫软件&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个可视化爬虫软件，只需在网页上选择想爬的内容，并根据提示框操作即可完成爬虫设计和执行。也支持以命令行方式执行，可以方便地嵌入到其他系统中。这个项目源于原作者的浙江大学硕士论文，已获得国家发明专利，相关资料可在仓库查看。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/camenduru/text-to-video-synthesis-colab&quot;&gt;text-to-video-synthesis-colab：文本生成视频的模型&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一个开源的文本生成视频模型，整体模型参数约 17 亿，使用英文输入。放出来的演示视频非常惊艳。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/opengeos/segment-geospatial&quot;&gt;segment-geospatial：使用 SAM 分割地理空间数据&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;SAM 即“分割任意物体模型”（Segment Anything Model），是计算机视觉领域中非常有用和先进的模型，用于需要精确识别和分割任意物体的应用场景。这个项目使用它来分割地理空间数据。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/andy-landy/traceback_with_variables&quot;&gt;traceback_with_variables：Python 回溯（错误消息）打印变量&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;该项目可以在 Python 的回溯信息中添加变量。通过记录日志或打印彩色的变量上下文信息，方便调试异常的原因，并显示堆栈跟踪中每个帧的变量值。&lt;/div&gt;
&lt;h3&gt;🐢播客&amp;amp;视频&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.bilibili.com/video/BV1XX4y1y7s4&quot;&gt;当你用Python3.12的时候，或许就跑了我写的代码呢！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;视频来自 B 站@码农高天，他从 3 月份起，有 20 几个 pr 已合入 Python 3.12。这期视频详细介绍了他做出的几个贡献，主要有完善 pdb 文档、修复了几个 bug、引入 convenience variable 特性，等等。（作者在第一次 pr 被合入后，录了一期《&lt;a href=&quot;https://b23.tv/7zZFshm&quot;&gt;我给Python修了个bug！从今天起，也算是Python开发者了？&lt;/a&gt;》）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.youtube.com/playlist?list=PL2Uw4_HvXqvY2zhJ9AMUa_Z6dtMGF3gtb&quot;&gt;PyCon US 2023 - YouTube&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;今年 PyCon US 活动的视频已经可以看了，共用 142 个视频！PyCon 是全球性的最大的 Python 开发者会议之一，由 PSF 主办，通常在 PyCon 活动期间会举行“Python 语言峰会”，今年的峰会议题详见《&lt;a href=&quot;https://pythoncat.top/posts/2023-05-31-weekly4&quot;&gt;Python潮流周刊#4：Python 2023 语言峰会&lt;/a&gt;》。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.youtube.com/@PyCascades/videos&quot;&gt;PyCascades - 2023 视频&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;2023 年 PyCascades 活动上的视频在上个月发布了，有 20 几个视频。PyCascades 是一个专注于 Python 编程语言的会议，通常在北美地区举行，每年一次。它类似于 PyCon，但是由独立的组织者和志愿者自发组织，规模更小。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-06-17-weekly7&quot;&gt;第7期（2023-06-17）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://charlesleifer.com/blog/asyncio&quot;&gt;AsyncIO&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章的作者讨厌 asyncio 库，认为使用 &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; 的设计十分糟糕，它与大多数库不兼容，也不满足“Python之禅”的一些标准。作者的推荐方案是 gevent，提及了它的几点好处。另外，作者还推荐了两篇相关的文章：Flask 作者 Armin Ronacher 的《&lt;a href=&quot;https://lucumr.pocoo.org/2016/10/30/i-dont-understand-asyncio&quot;&gt;I don’t understand Python’s Asyncio&lt;/a&gt;》，SQLAlchemy 作者 Mike Bayer 的《&lt;a href=&quot;https://techspot.zzzeek.org/2015/02/15/asynchronous-python-and-databases/&quot;&gt;Asynchronous Python and Databases&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://eng.lyft.com/what-the-heck-is-gevent-4e87db98a8&quot;&gt;gevent 到底是什么？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;gevent 是一个基于协程的协作式多任务 Python 框架，使用猴子补丁来协调所有代码。这篇文章是一个系列的第一篇，介绍了 gevent 的基本实现原理，第二篇是《&lt;a href=&quot;https://eng.lyft.com/gevent-part-2-correctness-22e3b7998382&quot;&gt;Gevent Correctness&lt;/a&gt;》，第三篇是《&lt;a href=&quot;https://eng.lyft.com/gevent-part-3-performance-e64303fa102b&quot;&gt;Gevent Performance&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.kdnuggets.com/2023/06/getting-started-reactpy.html&quot;&gt;ReactPy 的入门教程&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;上期周刊推荐过的 ReactPy 最近很火，它支持用 Python 写 React 风格的前端应用。这里是一篇简单的入门教程。另外，建议感兴趣的同学去看&lt;a href=&quot;https://reactpy.dev/docs/guides/getting-started/index.html&quot;&gt;官方文档&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://qin.news/python-circular-dependency-and-global-contexts&quot;&gt;Python 业务框架循环依赖和全局上下文的一些思考&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何简单而优雅地解决 Python 的循环依赖问题呢？作者考察了主流 API 框架（Django、Flask、FastAPI）的上下文管理方案，然后介绍了自己框架采用的方案：借鉴了 Ray 社区中对象所有权的概念，在一个协程上实现一个简易的所有权字典。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://amakelov.github.io/blog/deps&quot;&gt;Python 函数调用的实际依赖关系跟踪&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;跟踪 Python 函数调用时访问的代码和数据是一种很有用的操作，比如绘制依赖图、调试和分析性能、缓存失效。这篇文章考察了一种可能的实现方式，包含了一个少于 100 行代码的最小可行实现。作者是 MIT 的计算机科学博士。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://juejin.cn/post/7244033665209073725&quot;&gt;Python 3.x从基础到实战 - typing类型提示&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一篇入门教程，通过简短的示例，介绍了 Python Typing 模块的基础用法和进阶用法。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://www.pythonpapers.com/p/an-intro-to-wxpython&quot;&gt;wxPython 入门教程&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;wxPython 是跨平台的图形用户界面框架，基于 wxWidgets 库开发，在 1998 年发布。它最新发展到了 4.x 版本，这篇文章基于最新的特性作了详细的入门介绍。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://juejin.cn/post/7241943960083546171&quot;&gt;Python 装饰器的用法指导&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇很认真的文章，介绍了装饰器的基本概念和进阶用法。在示例部分介绍了 Django 的几个很常用的装饰器（&lt;code&gt;@login_required&lt;/code&gt;、&lt;code&gt;@permission_required&lt;/code&gt;、&lt;code&gt;@csrf_exempt&lt;/code&gt;、&lt;code&gt;@cache_page&lt;/code&gt;）。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://superfastpython.com/numpy-share-array-processes&quot;&gt;在进程间共享 Numpy 数组的 7 种方式&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;多进程编程时最麻烦的事情之一就是共享数据，这篇文章介绍了 7 种共享 Numpy 数组的方式：传递参数、使用全局变量、使用队列 Queue、使用管道 Pipe、使用基于 ctypes 的 RawArray、使用 Python 3.8 的 SharedMemory、使用多进程的管理器。这是一篇系统性的长文，里面还引用了作者的一些相关文章，十分推荐阅读。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://www.timescale.com/blog/tools-for-working-with-time-series-analysis-in-python&quot;&gt;在 Python 中作时间序列分析的工具&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;时间序列数据（&lt;strong&gt;Time-Series Data&lt;/strong&gt;）是指在不同时间点上收集的数据，这篇文章介绍了在 Python 中分析时间序列数据的工具，包括常用的 NumPy、pandas 和 Matplotlib，以及 Tsfresh、Sktime、AutoTS、Prophet、Timescale 等。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://neuronize.dev/learn-handling-missing-data-in-10-minutes&quot;&gt;如何快速处理缺失的数据&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;在数据分析和机器学习领域，需要尽量确保数据集的完整性和准确性，因此处理缺失值是必不可少的环节。文章先介绍了数据缺失的原因和模式（完全随机丢失 、随机丢失和不随机丢失），然后介绍了处理缺失值的常用方法：删除、填充、插补。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://coderslegacy.com/cython-vs-cpython-comparing-speed&quot;&gt;Cython 与 CPython：对比性能差异&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这篇文章用 10 个不同的基准作性能比较，涵盖了多种场景及边缘情况，包括斐波那契数列、斐波那契数列（迭代）、矩阵乘法、质数生成、字符串拼接、计算均值、计算均值（未优化）、算术运算、文件操作、线性搜索、冒泡排序。猜猜最后的结论是什么呢？&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://www.vidavolta.io/streaming-with-fastapi&quot;&gt;使用 FastAPI 进行流式处理&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;服务器推送事件 （&lt;strong&gt;Server-Sent Events&lt;/strong&gt;） 是一种基于 HTTP 的单向通信协议，允许服务器向客户端实时推送数据。这篇文章解释了如何使用 FastAPI 实现流式处理 JSON 事件。文章出自“&lt;em&gt;FastAPI Pro 系列&lt;/em&gt;”，另外两篇文章关于&lt;a href=&quot;https://www.vidavolta.io/dynamically-configure-python-apps-fastapi&quot;&gt;如何使用动态配置&lt;/a&gt;、&lt;a href=&quot;https://www.vidavolta.io/fastapi-api-keys&quot;&gt;如何加密保护 API&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://techwasti.com/fastapi-interview-questions-on-middleware&quot;&gt;20 道关于 FastAPI 中间件的面试题&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;中间件（&lt;strong&gt;middleware&lt;/strong&gt;）是 FastAPI 中的一种机制，允许在 HTTP 请求和响应到达路由处理程序之前拦截和修改它们。文章包含 20 个与中间件、身份验证和授权相关的面试题。&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;https://github.com/python/cpython/issues/101632&quot;&gt;CPython 添加返回常量指令&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;上期周刊引发了“国内 Python 贡献者数量”的话题，@yihong0618 在推特上留言分享了 @penguin-wwy 给 CPython 提交的这个贡献。该作者发现 LOAD_CONST + RETURN_VALUE 高频出现在 pystats 文档中，因此提交了一个新的 &lt;strong&gt;RETURN_CONST&lt;/strong&gt; 指令，此项贡献在 Python 3.12 基准测试中获得约 10% 的性能提升。&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/kislyuk/argcomplete&quot;&gt;argcomplete：命令行自动补全库&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;在使用 Python 命令或者命令行工具时，一个痛点是没有补全。使用 argcomplete 后，按 tab 键就可以自动补全。它需要与 argparse 模块一起使用，目前支持 bash 和 zsh 两种 shell。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/AndrewZhe/lawyer-llama&quot;&gt;Lawyer LLaMA：中文法律 LLaMA&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个系统性学习了中国的法律知识体系的大语言模型，能够正确理解民法、刑法、行政法、诉讼法等常见领域的法律概念，可进行基础的法律咨询，涵盖婚姻、借贷、海商、刑事等。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/OpenBMB/CPM-Bee&quot;&gt;CPM-Bee：百亿参数的中英文双语基座大模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个完全开源、允许商用的百亿参数中英文基座模型，采用 Transformer 自回归架构，在超万亿（trillion）高质量语料上进行预训练。在中文的 Zero-CLUE 评测基准上，它大幅超越其他模型，位列中文大模型第一。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/TigerResearch/TigerBot&quot;&gt;TigerBot：多语言多任务 LLM&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;也是国内团队开源的大语言模型，根据 OpenAI InstructGPT 论文在公开 NLP 数据集上的自动评测，TigerBot-7B 达到 OpenAI 同样大小模型的综合表现的 96%。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/xbzstudio/BingAI-Client&quot;&gt;BingAI-Client：突破限制的 New Bing&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;New Bing 集成了 ChatGPT，但是在国内使用的门槛有点高！这个项目的客户端基于 Angular，服务端基于 FastAPI 和 &lt;a href=&quot;https://github.com/acheong08/EdgeGPT&quot;&gt;EdgeGPT&lt;/a&gt;。在本地部署好后，运行服务端程序即可开始使用客户端。（另外推荐一个项目 &lt;a href=&quot;https://github.com/adams549659584/go-proxy-bingai&quot;&gt;go-proxy-bingai&lt;/a&gt;，是用 Vue3 和 Go 搭建的 New Bing 演示站点，国内可用，无需登录即可畅聊）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/TabbyML/tabby&quot;&gt;tabby：可自托管的 AI 编码助手&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这是 GitHub Copilot 的开源/本地替代品，无需 DBMS 或云服务，拥有 Web UI，支持消费级的 GPU。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/ahui2016/pyboke&quot;&gt;pyboke：极简博客生成器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个功能极简、代码极简、自带四种主题、支持生成 RSS 的静态博客生成器。项目基于 Python 3.10，主要使用的库有 arrow、click、jinja2、mistune 等。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/AntonOsika/gpt-engineer&quot;&gt;gpt-engineer&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这是一个基于 ChatGPT4 的 AI 工程师，你只用告诉它需求，然后它会问几个问题，接着生成整个项目代码。提供出来的演示视频非常惊艳！&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/facebookresearch/audiocraft&quot;&gt;audiocraft：音频处理和生成库&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这是 FaceBook 开源的一个 PyTorch 库，有最先进的 EnCodec 音频压缩器/分词器，内含文本到音乐模型 MusicGen，使用了 10K 高质量音乐曲目的内部数据集，以及 ShutterStock 和Pond5 的音乐数据。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://www.pythonguis.com&quot;&gt;PythonGUI 教程网站&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Python 中有很多开发 GUI 的库，除了前文提到的 wxPython，还有 Tkinter、PyQt、PySide、Kivy 等等。这个网站上提供了很多 GUI 相关的学习资料。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://hai-shi.gitbook.io/cpython-internals&quot;&gt;CPython 实现原理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一本用 GitBook 制作的在线电子书，翻译自微软独立研究员 Anthony Shaw 的《CPython Internals》。&lt;/div&gt;
&lt;h3&gt;🐢播客&amp;amp;视频&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pybit.es/articles/importance-of-refactoring&quot;&gt;pybites：&lt;/a&gt;&lt;a href=&quot;https://pybit.es/articles/importance-of-refactoring&quot;&gt;定期重构的重要性&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这期播客聊了关于重构的相关话题。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://b23.tv/cw3Ai8V&quot;&gt;三个看似一样的列表，占用内存空间竟然不一样多？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;有三个看起来完全一样的列表：[0]*3、[0,0,0]、[0 for _ in range(3)]，但是使用 sys.getsizeof() 计算的内存却完全不同。这是为什么呢？这期 B 站视频通过分析字节码和 CPython 解释器源码，非常硬核地分析出了根本原因，值得一看！&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://b23.tv/2XeGXwI&quot;&gt;asyncio的理解与入门，搞不明白协程？看这个视频就够了&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这里呼应一下本期标题及第一则内容。asyncio 依然是最主流的异步编程库，近几年也在逐渐发展成熟，很有必要深入学习。这是一则 B 站视频，适合用于入门与加深理解。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-06-24-weekly&quot;&gt;第8期（2023-06-24）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/faster-cpython/ideas/blob/main/3.13/README.md&quot;&gt;Python 3.13 版本的计划&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;Faster CPython 项目（即香农计划）有了关于 3.13 版本的最新计划，这次的性能目标是减少解释器 50% 的耗时。涵盖三项主要工作：第 2 层的优化器、启用子解释器（PEP-554）、内存管理。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://superfastpython.com/why-numpy-parallelism/&quot;&gt;为什么 Numpy 并行性很重要？&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;Numpy 是作科学计算和数据分析的最重要的库之一，并行性是提升其性能的重要手段。文章介绍了 5 种可以实现 Numpy 并行性的场景和方法：加载/保存 Numpy 数组数据、高效地计算数学函数、高效地初始化数组、并行执行数组的元素级数学运算、在进程间高效共享 Numpy 数组数据。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ohadravid.github.io/posts/2023-03-rusty-python/&quot;&gt;用少于 100 行的 Rust 使 Python 变快 100 倍&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;文章针对一个有性能问题的 Python 库，使用 Rust 重写并作了三轮优化后，提升了性能 100 倍。文中使用了 py-spy 库绘制火焰图，分析出了代码的瓶颈点，并以此作为优化的依据，可以看到前后火焰图的差别很大。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jelmer.uk/port-py-to-rust.html&quot;&gt;将 Python 项目移植到 Rust&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;文章指出“一步到位的移植”方式存在一些问题，从而提出“迭代式移植”的方法，并给出了一个代码示例。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://benhoyt.com/writings/python-api-design/&quot;&gt;设计 Pythonic 的库 API&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;如何设计出一个 Pythonic 的 API？在设计上有什么方法和基本原则呢？文章从代码结构、变量命名、错误处理、版本控制、类型注解等方面，给出了非常详细的介绍。文章较长，最后总结出 18 条 takeaways。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://bernsteinbear.com/blog/typed-python/&quot;&gt;编译类型化的 Python&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;Python 已支持类型提示，那能否编译 Python 代码为本地代码以提升性能呢？虽然类型提示可以提供一些性能优化，但由于 Python 的动态特性和灵活性，使得静态分析和编译非常困难。因此目前还没有一种方法可以将 Python 代码编译成本地代码以提高性能。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.revsys.com/tidbits/pytest-fixtures-are-magic/&quot;&gt;pytest 的夹具很神奇！&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;夹具（fixture）是在测试前设置和准备必要数据的一种机制，可以将测试数据和测试代码分离。文章介绍了 pytest 中夹具的基本用法，以及与 Django 项目的结合使用。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://just-taking-a-ride.com/inside_python_dict/chapter1.html&quot;&gt;探析 Python 字典的实现原理&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;这是一个系列文章，支持用可视化的调试方式探析 Python字典的实现原理。这篇文章介绍了如何通过哈希表实现字典，以及如何解决哈希冲突。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://djangocentral.com/flask-vs-django-selecting-the-perfect-python-web-framework/&quot;&gt;Flask vs Django：选择完美的 Python Web 框架&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;Python 最主流的两个 Web 框架是 Flask 和 Django，文章深入比较了它们的主要功能、优势与缺点、流行的插件和使用场景等，让读者更方便做出自己的选择。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bitecode.dev/p/why-not-tell-people-to-simply-use&quot;&gt;为什么不告诉人们“简单地”使用 pyenv、poetry、anaconda&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;文章的要点是：介绍一个基本的 Python 打包流程，尽可能减少依赖和要求，并解决大多数用户的打包问题。文中列出了一些常见的打包问题，并提供了一些解决方案，同时指出了一些常见的打包工具（如 homebrew、pyenv、anaconda、poetry）的缺点。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://jeff.glass/post/pyscript-asyncio/&quot;&gt;PyScript 中的 Asyncio&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;文章介绍了在 PyScript/Pyodide 中使用 &lt;code&gt;async/await/asyncio&lt;/code&gt; 来编写并发代码，还介绍了 Pyodide.Webloop 的实现，该实现允许 async/await 与浏览器事件循环一起使用。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://glyph.twistedmatrix.com/2014/02/unyielding.html&quot;&gt;线程的问题及其解决方案&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-06-17-weekly7&quot;&gt;上期周刊&lt;/a&gt;第一则分享中的三篇文章偏向于支持隐式的 async，有读者建议再呈现一些支持显式 async 的观点。这篇文章的要点是：线程会使本地推理变得困难，而本地推理是软件开发中最重要的事情之一。因此，应该避免使用线程，而使用异步编程模型，如回调、promise、协程等。同时，文章还提到了使用隐式协程的风险，因为它们可能会导致与线程相同的问题。（@Plutonium 投稿）&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zhiyiYo/PyQt-Fluent-Widgets/blob/master/docs/README_zh.md&quot;&gt;PyQt-Fluent-Widgets：基于 PyQt5 的 Fluent Design 风格组件库&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;目前开源且美观实用的 PyQt/PySide 组件库很少，所以作者照着 WinUI3 的设计稿写了这个 Fluent Design 风格的组件库，支持亮暗主题无缝切换和自定义主题色，支持 PyQt5/PyQt6/PySide2/PySide6 ，搭配 QtDesigner 可以快速设计出美观的界面。（来自@shokokawaii）&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/pycob/pyvibe&quot;&gt;pyvibe：使用 Python 生成样式化的 HTML 页面&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;PyVibe是一个用于创建网页的 Python 库，让 Python 开发者快速构建前端页面，简化 UI 开发。PyVibe 返回一个 HTML 字符串，可用于静态页面、Flask 函数、Pyodide 动态客户端呈现。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/pynecone-io/pynecone&quot;&gt;pynecone：纯 Python 的 Web 框架&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;Pynecone 发布于 2022 年 12 月，已获得 9K 星星，可谓十分火爆。它是一个用于构建和部署 Web 程序的全栈框架，提供了 50+ 内置组件，支持创建复杂的布局和使用 CSS 的全部功能来设置样式。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/norvig/pytudes&quot;&gt;pytudes：短小精悍的 Python 编程练习内容&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;这个项目包含了一些短小却很有挑战性的项目代码，既有“Advent of Code”历年的年度编程挑战活动的题目，也有“The Riddler”的系列数学谜题，还有文字谜题、概率问题等，甚至有使用 Python 解任何的数独题、实现一个 lisp 解释器，等等。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/xinyu1205/recognize-anything&quot;&gt;recognize-anything：Recognize Anything 模型和 Tag2Text 模型&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;Recognize Anything Model 是一种图像标记模型，可以高精度地识别任何常见类别；Tag2Text 是一种以标签为指导的视觉语言模型，可以支持字幕、检索和标签。这个项目是这两个模型的代码实现。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/alejandro-ao/ask-multiple-pdfs&quot;&gt;ask-multiple-pdfs：支持与多个 PDF 聊天的 Langchain 程序&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;支持使用自然语言同时与多个 PDF 文件进行对话。项目使用了 streamlit，可在浏览器中显示用户界面。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zjunlp/DeepKE&quot;&gt;DeepKE：用于知识图谱提取和及构建的开放工具包&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;DeepKE 是用于知识图谱构建的知识提取工具包，支持 cnSchema、低资源、文档级和多模态场景的实体、关系和属性提取。三个主要功能：命名实体识别、关系提取、属性提取。项目提供了详细的文档、教程和在线演示。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/wmariuss/awesome-devops&quot;&gt;awesome-DevOps：精选的 DevOps 平台、工具、实践和资源的列表&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;一个“awesome”系列仓库，收录了关于 DevOps 的方方面面的内容，包含各种平台、自动化、CI/CD、代码管理、网络服务器、数据库、监控工具、网关、混沌工程，等等。&lt;/div&gt;
&lt;h3&gt;🥂讨论&amp;amp;问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=36339777&quot;&gt;Hacker News：Our Plan for Python 3.13&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;一则热门讨论，话题关于 Python 3.13 版本的开发计划。不出意外，大部分的留言都围绕着 GIL，赞成与反对声皆有。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=36370684&quot;&gt;在你最喜欢的编程语言中，有哪些很优雅的代码库？&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;这也是一则 HN 上的帖子，既引起了关于编程语言本身的讨论，也涉及不同编程语言生态中的一些优秀的项目。有趣的是，有三则关于 Python 的留言都推荐了我们在上文中分享的&lt;code&gt;pytudes&lt;/code&gt; 项目！&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-07-01-weekly&quot;&gt;第9期（2023-07-01）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ai.plainenglish.io/%EF%B8%8F-langchain-streamlit-llama-bringing-conversational-ai-to-your-local-machine-a1736252b172&quot;&gt;本地部署开源大模型的完整教程：LangChain + Streamlit+ Llama&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;一篇步骤清晰的教程，它使用 LangChain 及 Facebook 开源的 LLaMA 大语言模型搭建了一个基于文档的问答助手，另外使用 Streamlit 构建出一个美观的用户界面。（附一篇中文的&lt;a href=&quot;https://segmentfault.com/a/1190000043935266&quot;&gt;翻译文&lt;/a&gt; ）&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://so1n.me/2023/05/29/python_asyncio_lib_overhead/&quot;&gt;Python Asyncio 协程对象开销成本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;一个 Python Asyncio 协程会占用有多少内存呢？文章的测试结论是约 2Kb。另外，文中还测试了以下的问题：每秒可创建多少个裸协程？每秒可处理多少个协程？使用&lt;code&gt;uvloop&lt;/code&gt; 后，创建及处理协程任务，能有多少提升？&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://superfastpython.com/asyncio-runner/&quot;&gt;如何使用 asyncio.Runner 执行多个协程&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;asyncio.Runner 是 Python 3.11 中新增的功能，支持在同一事件循环中执行多个协程。文章主要内容：如何使用 asyncio.run() 运行多个协程，如何使用包装方法运行多个协程，以及如何使用 asyncio.Runner 类在同一个事件循环中以自适应甚至有条件的方式执行协程。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://hakibenita.com/django-concurrency&quot;&gt;不使用锁的并发实现&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;在并发编程中，通常需要使用锁，但是不应该滥用锁。这篇文章探讨了如何尽量不依赖锁来实现并发，演示的例子是生成短链接，主要的思想是“请求宽恕”而不是“提前检查”、使用 PostgreSQL 数据库提供的功能。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/639119164&quot;&gt;贡献 CPython 日记 (3) CPython 是如何运行的&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;文章介绍了 CPython 是如何把 Python 代码跑起来的，主要过程：词法分析、语法分析、编译到字节码、执行字节码。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://coderslegacy.com/python-jit-compilers/&quot;&gt;Python JIT 编译器 - 即时编译&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;文章探讨了 JIT 编译的概念及其优点，并深入分析了主流的 Python JIT 编译器的优缺点（如 PyPy、Numba 和 Cython），介绍了在 Python 中使用 JIT 编译器的最佳实践和准则。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bitecode.dev/p/whats-the-deal-with-cpython-pypy&quot;&gt;CPython、Pypy、MicroPython、Jython……都是些什么？&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;当我们说 Python 时，通常指的是官方实现的 CPython，但还有很多的“Python”，比如 Pypy、Jython、MicroPython、Brython、RustPython 等等，还有很多像是新“Python”的东西，比如 Nuitka、WinPython、Psyco、Pyjion 等等。文章解释了相关的概念和工具。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://coderslegacy.com/python-apscheduler-asyncioscheduler/&quot;&gt;Python APScheduler：感受 AsyncIOScheduler 的强大&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;APScheduler 是一个调度和自动化任务工具，它的 AsyncIOScheduler 支持调度异步函数和协程，文章介绍了它的功能、优点以及如何优化异步任务调度需求。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://sourcery.ai/blog/chatgpt-maintainable-code/&quot;&gt;在生成代码时避免产生技术债务&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;GPT 和其它大语言模型可以快速生成大量代码，但这也可能导致很多的混乱代码。文章探讨了如何改进这些工具生成的代码，并将其融入到项目中的几种方法，包括采用专家角色、提供示例、遵循最佳实践、遵循标准和明确指南以及代码放置的恰当位置等。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://pythonspeed.com/articles/numpy-is-slow/&quot;&gt;当 NumPy 太慢时&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;在不考虑并行处理的情况下，如何提升 Numpy 性能？NumPy 有三个固有瓶颈（急切执行、通用编译代码和向量化导致的高内存使用率）。针对这些瓶颈，文章介绍四种解决方案：手动优化代码、使用 JAX 作即时编译、使用 Numba 作即时编译，以及使用提前编译。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://coderslegacy.com/python-numba-tutorial/&quot;&gt;Numba 教程：使用 JIT 编译加速 Python 代码&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;Numba 是一个专用的即时编译器，通过将 Python 代码编译为高效的机器代码来消除解释执行的开销，从而提升性能。文章介绍了 Numba 的功能、内部原理、主要用法和常见问题。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.fidelramos.net/software/python-code-quality&quot;&gt;自动化提升 Python 代码质量&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;如何使用较少的时间和精力来提升代码的质量？文章介绍了一些提升代码质量的工具（flake8、Black、isort、mypy、bandit等），以及使用 IDE、CI 和 pre-commit 等方式自动化调用这些工具。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cognibits.hashnode.dev/enhancing-data-analysis-with-pandasai&quot;&gt;使用 PandasAI 增强数据分析&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;PandasAI 是最近火爆的库，为 Pandas 集成了 AI 对话功能，可简化数据操作。文章介绍了 PandasAI 作复杂查询与图表可视化的方法，以及介绍了它提供的十几个方便好用的函数。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.codium.ai/blog/best-practices-for-writing-unit-tests/&quot;&gt; 写单元测试的最佳实践&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;单元测试的好处无须赘述，但是写单测却是开发者最讨厌的事情之一。文章罗列了 10 条写单元测试的最佳实践，介绍了手工写单元测试的步骤，最后介绍了使用 Codium.AI 自动化编写测试的方法。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://netflixtechblog.com/migrating-netflix-to-graphql-safely-8e1e4d4f1e72&quot;&gt;Netflix 如何安全地迁移到 GraphQL&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;Netflix 官方的一篇博客，介绍了在将手机 APP 安全地从 Falcor 迁移到 GraphQL 的过程中，所采用的三种测试策略：AB 测试、Replay 测试和 Sticky Canaries。AB 测试用于评估新功能对客户的影响，Replay 测试用于验证迁移的正确性，Sticky Canaries 用于验证性能和业务指标。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁访问下方链接，即可查看全部内容：&lt;a href=&quot;https://pythoncat.top/tags/weekly&quot;&gt;https://pythoncat.top/tags/weekly&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Kanaries/pygwalker&quot;&gt;PyGWalker：将 pandas 数据转换为 Tableau 样式的可视化界面&lt;/a&gt; (中英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;一个在 Jupyter Notebook 环境中运行的可视化探索式分析工具，仅一条命令即可生成一个可交互的图形界面，以类似 Tableau/PowerBI 的方式，通过拖拽字段进行数据分析。（star 6.5K）&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Suzhou-Tongyuan/jnumpy&quot;&gt;jnumpy：快速用 Julia 编写 Python C 扩展&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;用 Julia 为 Python 写高性能的 C 扩展，提速约 200x。（@xgdgsc 投稿）&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jupyterlab/jupyter-ai&quot;&gt;jupyter-ai：JupyterLab 的生成式 AI 扩展&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;JupyterLab 官方提供的生成式 AI 扩展，主要提供了：&lt;code&gt;%%ai&lt;/code&gt; 指令、原生的聊天 UI 页面、支持大量平台的大语言模型（AI21、Anthropic、Cohere、Hugging Face、OpenAI、SageMaker 等）。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Undertone0809/broadcast-service&quot;&gt;broadcast-service: 一个强大的 Python 发布订阅者框架&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;一个发布订阅者框架，支持同步异步调度、定时任务、主题管理、发布订阅者回调等功能。（@Zeeland 投稿）&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Undertone0809/cushy-storage&quot;&gt;cushy-storage: 一个基于磁盘缓存的 ORM 框架&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;一个基于磁盘缓存的 ORM 框架，可对基本数据类型及自定义的数据通过 ORM 进行增删改查，支持多种序列化操作和数据压缩方式。（@Zeeland 投稿）&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Giskard-AI/giskard&quot;&gt;giskard：专用于 ML 模型的测试框架&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;如何测试机器学习模型、要涵盖哪些问题、如何实施测试？这个框架可扫描数十种漏洞（性能偏差、数据泄漏、不鲁棒性、虚假关联、过度自信、信心不足、不道德问题等），并基于结果生成特定领域的测试套件。（star 1K）&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/XingangPan/DragGAN&quot;&gt;DragGAN：基于点的交互式图像编辑&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;本周最火项目，可在图像上通过拖动点的方式，生成想要的新图像，非常惊艳！（star 28K）&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tomerfiliba/plumbum&quot;&gt;plumbum: 永远不要再写 shell 脚本&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;除了类似 shell 的语法和方便的快捷方式外，这个库还提供了本地和远程命令执行（通过 SSH）、本地和远程文件系统路径、简单的目录和环境操作、以及一个可编程的 CLI 工具包。（star 2.6K）&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/threestudio-project/threestudio&quot;&gt;threestudio：用于生成 3D 内容的统一框架&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;支持用文本提示、单个图像和少量镜头图像创建 3D 内容。支持多种模型，如 ProlificDreamer、DreamFusion、Magic3D、Score Jacobian Chaining，等等。（star 1.8K）&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/danielgatis/rembg&quot;&gt;rembg：一个删除图像背景的工具&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;支持删除图像的背景，支持多种使用方式（cli、库、docker）和多种强大的功能。（star 10.5K）&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-07-08-weekly&quot;&gt;第10期（2023-07-08）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.yance.wiki/gc_go_py&quot;&gt;聊一聊 Python 和 Golang 的垃圾回收&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;常见的垃圾回收算法有哪些，它们的优缺点是什么？Python 的垃圾回收机制由什么组成，如何解决内存泄漏问题？Golang 的垃圾回收机制又是怎样的，如何解决内存泄漏问题？&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://albexl.substack.com/p/a-tale-of-debugging-the-competitive&quot;&gt;像竞赛程序员一样调试&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;编程竞赛需要在限定时间内解决一系列难题，这篇文章介绍了在编程竞赛中作自动调试的方法。它的方法除了可以提升成绩，对于现实的软件开发也有所启示。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://realpython.com/python312-perf-profiler/&quot;&gt;Python 3.12 预览版：支持 Linux 性能分析器&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Python 3.12 最终版将在今年 10 月发布，其中最大的变化之一是支持 Linux &lt;code&gt;perf&lt;/code&gt; 分析器。这篇文章介绍了什么是 Linux perf 分析器、perf 能给 Python 带来什么好处、如何在 Python 3.12 中使用 perf、如何分析性能数据、性能数据可视化……&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://lukasz.langa.pl/40b601fc-2b24-4629-91d9-3b32c58365c6/&quot;&gt;CPython 招聘一名全职工程师&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Łukasz Langa 是 PSF 的首个全职开发者（由 Meta 赞助），近日发文表示要新招聘一名“副手”工程师（由彭博社赞助）！两周前，PSF 官网刚公布了&lt;a href=&quot;https://pyfound.blogspot.com/2023/06/announcing-our-new-security-developer.html&quot;&gt;首个全职的安全开发工程师&lt;/a&gt; （由 OpenSSF 赞助），现在又有了新的赞助，真的要感谢慷慨的赞助者们！&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://lukasz.langa.pl/61df599c-d9d8-4938-868b-36b67fdb4448/&quot;&gt;PEP 563 和 PEP 649&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;PEP-563 注解的延迟求值，PEP-649 使用描述符作注解的延迟求值。这篇 2021 年的文章出自 PEP-563 的作者 Łukasz Langa，介绍和对比了这两个 PEP。它们都是 Accepted 状态，然而原计划在 3.10 发布的 PEP-563 已被&lt;a href=&quot;https://docs.python.org/zh-cn/3/whatsnew/3.11.html#pep-563-may-not-be-the-future&quot;&gt;宣告无限期搁置&lt;/a&gt; ，所以它似乎需要更多的关注？（@Plutonium 投稿）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://ritwikmath.hashnode.dev/python-design-patterns-cookbook-recipes-for-clean-and-reusable-code-observer&quot;&gt;Python 设计模式：简洁及可重用代码（观察者）&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;在构建复杂软件时通常会使用设计模式。文章介绍了观察者设计模式、其使用场景与 Python 代码示例，另外与事件驱动架构（EDA）作了几项对比。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://jamesturk.net/posts/you-dont-need-all/&quot;&gt;你并不需要写__all__&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章介绍了 Python 中三种导入模块的方式和__all__的用法，重点介绍了一种替代__all__的方法，即在 __init__.py 文件中直接导入所需的名称。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://blog.miguelgrinberg.com/post/building-a-toy-programming-language-in-python&quot;&gt;用 Python 实现一门简易的编程语言&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;如何用 Python 来实现一门编程语言呢？这是一个系列教程，第一篇中实现了一个非常基础的编程语言，可以执行 print 语句，第二篇则拓展成支持变量和数学表达式。涉及词法分析、语法分析、代码生成及执行等知识。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://www.pythonmorsels.com/using-counter/&quot;&gt;使用 Python 的 collections.Counter 计算出现次数&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Counter 是 Python 中最好用的数据结构之一。这篇文章介绍了一些很有用的操作：获取出现次数最多的 N 个内容、添加内容到 Counter、移除内容、删除负计数内容、Counter 作算术运算、Counter 传入生成器表达式。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://coderslegacy.com/python-code-with-numba-vectorize/&quot;&gt;使用 Numba Vectorize 加速 Python 代码&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Numba 是用于提升 Python 性能的常用手段，这篇文章介绍了它的重要功能 Vectorize（矢量化），包括它的内部原理，了解它如何充分利用单指令多数据（SIMD）操作的强大功能。文中展示了 5 个使用场景的代码示例。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://emmmme.com/greatwork&quot;&gt;Paul Graham：如何做出伟大的工作？&lt;/a&gt; (中译)&lt;/div&gt;
&lt;div&gt;Paul Graham 是《黑客与画家》的作者，最近发布了文章《&lt;a href=&quot;http://paulgraham.com/greatwork.html&quot;&gt;How to Do Great Work ?&lt;/a&gt;》。一句话概括要点：做出伟大的工作需要好奇心、努力和适合自己的工作类型。文章较长，关键的几个问题：什么是做伟大工作的关键？如何找到适合自己的工作类型？如何保持好奇心？什么是伟大工作的标准？为什么要努力做伟大工作？&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://emmmme.com/workhard&quot;&gt;Paul Graham：如何努力工作？&lt;/a&gt; (中译)&lt;/div&gt;
&lt;div&gt;翻译自 Paul Graham 写于 2021 年的《&lt;a href=&quot;http://paulgraham.com/hwh.html&quot;&gt;How to Work Hard ?&lt;/a&gt;》，可与上一则内容关联阅读。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://www.pythonmorsels.com/django-june-2023/&quot;&gt;Django 2023 年 6 月：技巧和讨论&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这是一篇关于 Django 的聚合类月刊，分享了一些学习 Django 的技巧、资源、文章，等等。&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/facebookincubator/cinder&quot;&gt;cinder：Meta 内部以性能为导向的 CPython 版本&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;本周重大新闻：Meta 推出了 Twitter 的竞品 Threads，仅两天的注册量就已突破三千万。它的后端使用了 Cinder，这是基于 Python 3.10 构建的高性能版本，包含许多性能优化，包括字节码内联缓存、协程的预先求值、每个方法一次的 JIT，以及一种实验性的字节码编译器。（star 2.6K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/sdan/vlite&quot;&gt;vlite：用 NumPy 制作的简易矢量数据库&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;用不到 200 行代码编写的快速、轻量级和简易的矢量数据库。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/0xpayne/gpt-migrate&quot;&gt;gpt-migrate：将代码仓从一种框架或语言迁移成其它&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;使用 GPT 将少量代码从一种编程语言转换成其它语言，这已非难事。但是，整个代码仓级别的语言/框架迁移，听起来就不是一件容易的事！这个项目需要使用 GPT-4，目前在 Python 和 Javascript 这种“简单”的语言上有不错的效果。（star 5.4K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/lancetnik/FastDepends&quot;&gt;FastDepends：从 FastAPI 中提取的依赖注入框架，异步和同步模式都支持&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这是将 FastAPI 移除所有 HTTP 逻辑后改造成的依赖注入框架。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/zwq2018/Data-Copilot&quot;&gt;Data-Copilot：通过自主工作流程桥接数十亿数据和人类&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个基于 LLM 的系统，连接中国金融市场，目前可以访问中国的股票、基金、经济及金融数据、实时新闻。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/readthedocs-examples/awesome-read-the-docs&quot;&gt;awesome-read-the-docs：精选的项目文档列表&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;&lt;code&gt;Read the Docs&lt;/code&gt; 是一个用于构建和发布文档的开源平台（你肯定见过它家的 Sphinx 或 MkDocs 生成的文档），这个仓库收录了一些开源项目的文档，可以学习它们是如何构建出酷炫效果的。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/Wangt-CN/DisCo&quot;&gt;DisCo：通过指示生成现实世界的人类舞蹈&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这是一个通用的人类舞蹈生成工具包，可以根据参考图片和姿势，生成人类舞蹈图片和视频。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://theses.gla.ac.uk/2975/1/2011shannonphd.pdf&quot;&gt;Mark Shannon 博士论文：为动态语言构建高性能虚拟机&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Mark Shannon 由于“&lt;a href=&quot;https://pythoncat.top/posts/2021-05-16-Guido&quot;&gt;香农计划&lt;/a&gt;”而被很多人所知。这里分享的是他 2011 年在格拉斯哥大学的博士论文（可下载的 PDF），描述了一种用于构建动态语言虚拟机的方法，并解释了如何通过围绕一个抽象机器来构建虚拟机工具包的设计。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/guofei9987/blind_watermark&quot;&gt;blind_watermark：图片加盲水印，提取水印无须原图&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;盲水印（Blind Watermark）是一种数字水印技术，可以在不需要原图或文本的情况下，将水印嵌入到数据中。这个项目是基于频域的数字盲水印，在多种攻击方式下仍能有效提取。（star 3.6K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/OpenBMB/VisCPM&quot;&gt;VisCPM：基于 CPM 基础模型的中英双语多模态大模型系列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个开源的多模态大模型系列，支持中英双语的多模态对话能力（&lt;code&gt;VisCPM-Chat&lt;/code&gt;模型）和文到图生成能力（&lt;code&gt;VisCPM-Paint&lt;/code&gt;模型）。基于百亿参数量语言大模型 CPM-Bee（10B）训练（&lt;a href=&quot;https://pythoncat.top/posts/2023-06-17-weekly7&quot;&gt;周刊第 7 期&lt;/a&gt;曾介绍过），融合视觉编码器（Q-Former）和视觉解码器（Diffusion-UNet）以支持视觉信号的输入和输出。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/escobar-west/polars-cookbook&quot;&gt;polars-cookbook：Python polars 库的教程&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;polars 是用 Rust 写成的 Python 库，用于进行数据分析。这个仓库包含有 9 个章节的使用教程。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://www.evidentlyai.com/ml-system-design&quot;&gt;ML 系统设计：200 个研究案例&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;像 Netflix、Airbnb 和 Doordash 这样的公司如何运用机器学习来改善其产品和流程？这个网站整理了 64 家公司的 200 个案例，可以了解到机器学习的现实用例，学习如何设计机器学习系统。&lt;/div&gt;
&lt;h3&gt;🥂讨论&amp;amp;问题&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://news.ycombinator.com/item?id=36581241&quot;&gt;Ask HN：关于技术史的好书？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Hacker News 上的问题，有哪些关于技术历史的好书推荐？&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://news.ycombinator.com/item?id=36560950&quot;&gt;Ask HN：最有价值的计算机科学书籍？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;也是 HN 上的问题，有哪些关于编程语言、符号逻辑、算法、操作系统等 CS 书籍推荐？&lt;/div&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-07-15-weekly&quot;&gt;第11期（2023-07-15）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://soulteary.com/2023/05/21/run-python-code-with-golang-and-docker.html&quot;&gt;使用 Golang 和 Docker 运行 Python 代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何使用 Golang 来运行 Python 代码呢？关于 Python 版本和硬件，有哪些使用限制呢？这篇文章使用 Docker 解决环境依赖问题，使用开源项目 &lt;strong&gt;cpy3&lt;/strong&gt;，成功用 Golang 运行 Python 代码。它有一篇续文《&lt;a href=&quot;https://soulteary.com/2023/05/22/using-golang-and-docker-to-implement-python-computing-services.html&quot;&gt;使用 Golang 和 Docker 实现 Python 计算服务&lt;/a&gt;》，将普通的 Python 软件包封装为高性能的可通过 &lt;strong&gt;gRPC&lt;/strong&gt; 方式调用的服务。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.piglei.com/articles/the-answer-is-in-the-code-fulfill-requirements/&quot;&gt;答案在代码中：“实现需求”的双重含义&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;很多程序员容易忽略一件事：那就是阅读代码的时间会远多于写下它们的时间！这意味着&lt;strong&gt;代码的可读性&lt;/strong&gt;非常重要，因此当我们在“实现需求”时，除了要考虑用户的功能需求外，更应多加关注如何写出可读性高的代码。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.bitecode.dev/p/relieving-your-python-packaging-pain&quot;&gt;减轻 Python 包管理的痛苦&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;@NoHeartPen 投稿：在看了第一期中&lt;a href=&quot;https://www.v2ex.com/t/938669#reply88&quot;&gt;对 conda 的吐槽&lt;/a&gt; 后，开始关注这个问题，但一直没有找到比较系统的总结，看了这篇文章后终于有了大致的思路（这篇文章不仅写了「怎么做」，还写了「为什么」，让我改掉了不建虚拟环境的陋习和放弃折腾 conda）。另外，附上翻译版 &lt;a href=&quot;https://blog.csdn.net/csdnnews/article/details/131546123&quot;&gt;如何减轻 Python 打包之痛&lt;/a&gt; 。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://www.cnblogs.com/traditional/p/17536459.html&quot;&gt;CuPy：将 NumPy 数组调度到 GPU 上运行&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;NumPy 的作者 Travis Oliphant 曾说，如果当时给 NumPy 添加了 GPU 的支持，就没有后来的 Tensorflow、Torch 等深度学习框架什么事了。&lt;a href=&quot;https://github.com/cupy/cupy&quot;&gt;CuPy&lt;/a&gt; 是一个兼容 Numpy 且支持 GPU 的库（star 7K），这篇文章介绍了它的安装及数组的基础知识。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://segmentfault.com/a/1190000044006618&quot;&gt;Python 源码剖析：深度探索 Cpython 对象&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;为什么说 Python 中一切皆对象？为什么 Python 用起来比其它静态类型语言慢很多？这篇文章从 CPython 的对象构造器入手，介绍了 CPython 底层数据结构、对象创建的过程、动态性的实现方式等内容。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://juejin.cn/post/7252976055093592120&quot;&gt;使用 Flask + Flask RESTful 快速搭建 API 服务&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇长文，使用 Flask + Flask RESTful 搭建一个 API 应用，使用 &lt;strong&gt;Flask-SQLAlchemy&lt;/strong&gt; 扩展实现 ORM 操作 MySQL 数据库，基于 JWT 验证实现注册、登录以及登出接口，解决跨域问题，并使用 Docker 部署该应用。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://segmentfault.com/a/1190000043988232&quot;&gt;详解 Django 请求与响应：深入理解 Web Http 交互的核心机制&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;探讨了 Django 中的请求与响应处理，包含基础知识、生命周期、HttpRequest 和 HttpResponse 对象的详细介绍。同时，讨论了 Django 的视图和请求、响应处理，以及安全性和异步处理的考虑。最后，对比了 Django 与 Flask、FastAPI 等框架在请求响应处理上的异同。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://dev.to/derlin/when-plans-go-astray-my-unsuccessful-journey-of-migrating-a-large-django-project-to-mypy-3l23&quot;&gt;将大型 Django 项目迁移到 Mypy 的失败之旅&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;作者在给一个生产项目添加 Mypy 类型检查时遇到了诸多问题：很多库不提供 pyi 类型、TypedDict 使用受限、Optional 类型需要许多断言、混合类需要实现协议、Django 模型不支持泛型。简而言之，给历史项目加上类型检查是一件痛苦的事，最好是从一开始就考虑。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://www.python-engineer.com/posts/notion-api-python/&quot;&gt;如何在 Python 中使用 Notion API？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Notion 是一款强大的知识管理软件，这篇教程教你如何用 Python 操作 Notion 的数据库：创建集成、在数据库中创建页面、查询数据库与页面、更新页面、删除页面。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://pythonspeed.com/articles/easiest-rust-python/&quot;&gt;最简单的使用 Rust 加速 Python 的方法&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;如何将 Rust 代码打包为 Python 可使用的扩展？&lt;a href=&quot;https://www.maturin.rs/&quot;&gt;maturin&lt;/a&gt; 和 &lt;a href=&quot;https://setuptools-rust.readthedocs.io/&quot;&gt;setuptools-rust&lt;/a&gt; 是主流的两种方式。但是，在做原型设计时，打包与集成过程还是挺麻烦，这篇文章介绍了一个新的库 &lt;a href=&quot;https://pypi.org/project/rustimport/&quot;&gt;rustimport&lt;/a&gt; ，可以直接从 Python 中导入 Rust 代码！文章介绍了它的使用方法、Rust 初学者最常见的性能错误、以及使用 &lt;strong&gt;rustimport&lt;/strong&gt; 时的一些陷阱。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://jayconrod.com/posts/101/how-python-parses-white-space&quot;&gt;Python 是如何解析空格的？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Python 的换行与缩进是程序结构的基础部分。空格在 Python 的语法解析中起到什么作用，词法分析器如何处理换行和缩进？Python 的空格有哪些优点和缺点？Python 如何解析代码并生成抽象语法树？&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://pythonguides.com/remove-duplicate-values-from-a-python-dictionary/&quot;&gt;如何从 Python 字典中删除重复的值？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;介绍了 7 种从 Python 字典中删除重复值的方法：使用 for 循环、使用字典解析式、使用 setdefault() 方法、使用 values() 和 set() 方法、使用 collections.defaultdict()、使用列表解析式、使用 dict.fromkeys() 和 values()。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://realpython.com/python-profiling/&quot;&gt;如何找出 Python 代码中的性能瓶颈？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;什么时候该给项目作性能优化？性能调优前该关注哪些内容，应该使用什么工具？这篇文章介绍了&lt;code&gt;time&lt;/code&gt; 、&lt;code&gt;timeit&lt;/code&gt; 、&lt;code&gt;cProfile&lt;/code&gt; 、&lt;code&gt;Pyinstrument&lt;/code&gt; 、&lt;code&gt;perf&lt;/code&gt; 等工具以及一些性能优化的技巧。&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://samuel-vidovich.medium.com/3-cool-python-libraries-that-will-save-you-time-and-effort-27fcdc6762d5&quot;&gt;3 个很酷的 Python 库，节省你的时间和精力&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;介绍了 3 个非常好用的库：&lt;a href=&quot;https://github.com/jmespath/jmespath.py&quot;&gt;JMESPath&lt;/a&gt; 可以很方便查询 Json 中的元素（star 1.9k），&lt;a href=&quot;https://github.com/jpvanhal/inflection&quot;&gt;inflection&lt;/a&gt; 可以很方便处理字符串（比如批量将驼峰式变量名修改成蛇形命名），&lt;a href=&quot;https://github.com/more-itertools/more-itertools&quot;&gt;more-itertools&lt;/a&gt; 类似于标准库的&lt;code&gt;itertools&lt;/code&gt; 提供了很多操作可迭代对象的方法（star 3.1k）。&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;https://blog.europython.eu/kraken-technologies-how-we-organize-our-very-large-pythonmonolith/&quot;&gt;如何管理有近 3 万个文件的超大型 Python 代码仓？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;你见过接近 3 万个文件（不含测试）的 Python 单体代码仓么？全球有 400 开发者共同开发，如何避免混乱？作者介绍了分层管理代码仓的做法、使用的架构和工具（&lt;a href=&quot;https://github.com/seddonym/import-linter&quot;&gt;import-linter&lt;/a&gt;）、以及克服过的一些困难。&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/dmytrostriletskyi/threads-net&quot;&gt;threads-net：逆向工程 Threads 的 Python API&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;新上线的 Threads 依然是本周最火爆的科技话题之一。这个项目通过逆向工程获得了它的 API，可让你使用 Python 操作 Threads 的很多功能。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/ishan0102/engblogs&quot;&gt;engblogs：用 AI 为科技公司官博作摘要，并部署成网站&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这个项目用 RSS 抓取 AWS、Apple、DeepMind、Google、Meta、Stripe 等科技公司的博客，调用 gpt-3.5 生成摘要，将数据存储在 supabase 中，并在 Vercel 上托管了一个 Next.js &lt;a href=&quot;https://www.engblogs.dev/&quot;&gt;网站&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/adamghill/django-unicorn&quot;&gt;django-unicorn：Django 全栈的响应式组件框架&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;可以为 Djiango 模板添加现代响应式的组件功能，无需使用 Javascript 框架。支持表单验证、重定向、加载状态、部分更新、滚动触发、消息、Javascript 集成等等丰富的功能。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/Undertone0809/imarkdown&quot;&gt;imarkdown：轻量级的 Markdown 图片链接转换器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可以批量将图片的链接进行本地到图片服务器、图片服务器到本地、图片服务器到图片服务器的转换。（@Zeeland 投稿）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/198808xc/Pangu-Weather&quot;&gt;Pangu-Weather：盘古天气的官方实现&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;可以通过人工智能来提升天气预报的准确度啦？！Pangu-Weather 是一个快速而准确预报全球天气的 3D 高分辨率模型。这个仓库提供了伪代码、预训练模型、推理代码等资源。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/openmedlab/PULSE&quot;&gt;PULSE：中文医疗大语言模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于 4 百万个中文医学领域和通用领域的指令微调，支持医学领域的各种自然语言处理任务，包括健康教育、医师考试问题、报告解读、医疗记录结构化以及模拟诊断和治疗。基于这个大模型，已经有不少应用，比如与 X-ray 图像模型结合的应用 &lt;strong&gt;XrayPULSE&lt;/strong&gt; ：&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/fredrikaverpil/creosote&quot;&gt;creosote：识别虚拟环境中未使用的依赖库&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;可扫描虚拟环境中未使用的依赖库，支持 Poetry、Pipenv、PDM、 &lt;code&gt;requirements.txt&lt;/code&gt; 文件以及 PEP-621 的 &lt;code&gt;pyproject.toml&lt;/code&gt; 文件。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/IMOSR/MediaGPT&quot;&gt;MediaGPT：中文的自媒体大语言模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个面向自媒体创作、直播和运营等领域的大语言模型，能够理解抖音运营、短视频创作、巨量千川投放、直播运营等领域的核心概念和策略，支持内容创作、平台运营、广告投放等。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/geekan/MetaGPT&quot;&gt;MetaGPT：给定一行需求，返回 PRD、设计、任务、代码&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一个元编程框架，可以为 GPT 分配不同的角色（如产品经理/架构师/项目经理/工程师），共同协作完成复杂的软件开发任务。仅需一句话需求，就能输出用户故事/竞争分析/需求/数据结构/API/文档等。（star 3.7k）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/khoj-ai/khoj&quot;&gt;khoj：数字大脑的 AI 个人助理&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;基于个人的 Markdown 笔记、PDF 文件、Github 代码仓和照片，打造支持搜索与聊天的 AI 助理，可通过浏览器、Emacs、Obsidian 和移动设备等多种界面进行交互。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/paul-gauthier/aider&quot;&gt;aider：基于命令行的 AI 编码助手&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一个命令行聊天工具，可以让 GPT 创建新项目，或修改现有 git 代码仓中的代码。它可以轻松完成 git 提交、比较和撤消更改，无需人工复制/粘贴。（star 2.3k）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/allenai/visprog&quot;&gt;visprog：可视化编程，无需训练的合成视觉推理&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一篇 CVPR 2023 最佳论文的官方实现，可以实现：基于图片内容的自然语言问答与推理、图片内对象标注、自然语言图片编辑等功能。&lt;/div&gt;
&lt;h3&gt;🐢播客&amp;amp;视频&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://talkpython.fm/episodes/show/421/python-at-netflix&quot;&gt;Talk Python To Me Podcast #421 Python at Netflix&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Python 在 Netflix 中有大量的使用场景，比如 CDN、需求预测和容灾、安全、机器学习等等。这期播客节目聊了 Netflix 在使用 Python 时的相关话题。另外，分享它官博上获得 8k 赞的一篇旧文《&lt;a href=&quot;https://netflixtechblog.com/python-at-netflix-bba45dae649e&quot;&gt;Python at Netflix&lt;/a&gt;》。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://pythonbytes.fm/episodes/show/343/so-much-pydantic&quot;&gt;Python Bytes #343 So Much Pydantic!&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这期播客聊了很多话题，其中关于 Pydantic 的有两则：V2 版本已发布、一个&lt;a href=&quot;https://github.com/Kludex/awesome-pydantic&quot;&gt;awesome-pydantic&lt;/a&gt; 清单，后者收录了很多使用 Pydantic 的开源项目。&lt;/div&gt;
&lt;h3&gt;🥂讨论&amp;amp;问题&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.zhihu.com/question/274635237&quot;&gt;Pytorch有什么节省显存的小技巧？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;知乎上的一个问题，前排有很多高赞的回答，八仙过海各显神通！&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://discuss.python.org/t/a-fast-free-threading-python/27903/99&quot;&gt;如果 PEP-703 被采纳，Meta 将投入人力支持&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Python 社区今年最受瞩目的提案当属 PEP-703 了吧（我曾&lt;a href=&quot;https://pythoncat.top/posts/2023-02-20-GIL&quot;&gt;在年初介绍过&lt;/a&gt;）！Guido 上个月在论坛中说要是能得到 Meta 等科技公司的支持就太好了。好消息来了，上周 Meta 承诺可以提供人力支持。消息在 Twitter 和 Hacker News（&lt;a href=&quot;https://news.ycombinator.com/item?id=36643670&quot;&gt;查看 HN 帖子&lt;/a&gt;）等平台上，获得了激烈的讨论。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-07-22-weekly&quot;&gt;第12期（2023-07-22）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://martinheinz.dev/blog/101&quot;&gt;使用 PyStack 调试 Python 中的崩溃和死锁&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;介绍了一款强大的工具 &lt;strong&gt;PyStack&lt;/strong&gt;，可以解决一些难以调试的问题，如死锁、程序挂起、段错误、Python 和 C/C++ 混合应用调试等。它支持两种调试方法：附加到运行中的进程，或分析崩溃进程的核心转储文件。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://bitestreams.com/blog/fastapi_template/&quot;&gt;介绍一个 FastAPI 项目模板&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一个非常完备的 FastAPI 项目模板，带有 CI/CD、Docker、PostgreSQL、Makefile、单元/集成测试、linting及类型检查。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://davidvujic.blogspot.com/2023/07/python-fastapi-microservices-with-polylith.html&quot;&gt;Python FastAPI 微服务与 Polylith 架构&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Polylith&lt;/strong&gt; 是一种软件架构框架，核心思想是将系统分解为一个个可测试的、可重用的独立单元。作者结合 FastAPI 与 Polylith 架构，开发了一个项目模板。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://juejin.cn/post/7257321872425058359&quot;&gt;Python日志模块：实战应用与最佳实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;详细解析了 &lt;strong&gt;logging&lt;/strong&gt; 模块，从基本介绍到实际应用和最佳实践，介绍了如何高效地用它记录日志，以及如何避免常见的陷阱。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://codesolid.com/benchmarking-python-and-rust-async-web-server-performance/&quot;&gt;测量 Python 和 Rust 异步 Web 服务的性能&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章使用 &lt;strong&gt;JMeter&lt;/strong&gt; 分别测试了 Rust 的 &lt;strong&gt;Axum&lt;/strong&gt; 框架以及 Python 的 &lt;strong&gt;Blacksheep&lt;/strong&gt; 框架。猜猜最终的测试结论是什么呢？&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;http://vra.github.io/2023/07/14/dinov2-retrieval/&quot;&gt;dinov2_retrieval：一个基于 DINOv2 的图片检索应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Meta 发布了 &lt;strong&gt;DINOv2&lt;/strong&gt; 视觉预训练模型，能够准确地理解图片中的语义信息。这篇文章用它开发了一个 Python工具，能够检索若干张图片在测试数据集中最相似的图。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://til.simonwillison.net/python/stdlib-cli-tools&quot;&gt;隐藏在 Python 标准库中的 CLI 工具&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Python 标准库中有哪些实用的小工具，可以直接写 &lt;code&gt;python -m xxx&lt;/code&gt; 调用？这篇文章使用 &lt;strong&gt;ripgrep&lt;/strong&gt; 查找出几十个模块，并重点介绍了&lt;code&gt;http.server&lt;/code&gt; 、&lt;code&gt;base64&lt;/code&gt; 、&lt;code&gt;asyncio&lt;/code&gt; 、&lt;code&gt;tokenize&lt;/code&gt; 、&lt;code&gt;ast&lt;/code&gt; 、&lt;code&gt;json.tool&lt;/code&gt; 、&lt;code&gt;random&lt;/code&gt; 等工具。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://www.abdulmumin.com/how-to-use-tailwindcss-in-any-python-project&quot;&gt;如何在 Python 项目中使用 TailwindCSS ？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Tailwind 是近几年在前端很火的一个 CSS 框架，如何将它运用到 Python Web 项目中呢？文章主要介绍了&lt;code&gt;tailwindpie&lt;/code&gt; 这个库，并演示如何在 Flask 项目中使用它，实现自动安装及配置 TailwindCSS。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://dev.to/karishmashukla/a-practical-guide-to-metaprogramming-in-python-691&quot;&gt;Python 元编程实用指南&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;介绍 Python 中元编程的几种机制：装饰器、元类、函数及类装饰器、动态代码生成，以及常用于元编程的关键字与内置函数。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://blog.stealthrocket.tech/how-cpython-prints-stack-traces/&quot;&gt;CPython 是如何打印堆栈信息的？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一篇硬核长文，介绍了 CPython 如何表示程序的调用栈以及如何将字节码地址解析为源代码行号。文章剖析了 CPython 的内部机制，提供了 CPython 性能分析和调试的有用信息。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://switowski.com/blog/pathlib/&quot;&gt;用于路径操作的 Pathlib&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Pathlib 是 Python 中作目录相关操作的库，而且应该是最好用的一个。文章详细介绍了它的常见用法，对比了其它常用工具，并且针对一些场景作了性能分析。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://newsletter.techworld-with-milan.com/p/stack-overflow-architecture&quot;&gt;Stack Overflow、Shopify 及 Levels.fyi 的软件架构&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章分享了三家大型网站的软件架构。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://dev.to/alexomeyer/10-must-know-patterns-for-writing-clean-code-with-python-56bf&quot;&gt;10 条编写干净 Python 代码的建议&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;代码的可读性与可维护性，再怎么强调也不为过！这篇文章介绍了一些基础的原则，但却非常体现程序员的编程素养。&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://engineering.fb.com/2023/06/27/developer-tools/meta-developer-tools-open-source/&quot;&gt;Meta 开发者工具：支撑大规模协作的编程体系&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Meta 的几千名开发者使用了哪些支撑大规模协作的工具呢？文章介绍了几款开源工具（&lt;a href=&quot;https://engineering.fb.com/2022/11/15/open-source/sapling-source-control-scalable/&quot;&gt;Sapling&lt;/a&gt; 版本控制、 &lt;a href=&quot;https://engineering.fb.com/2023/04/06/open-source/buck2-open-source-large-scale-build-system/&quot;&gt;Buck2&lt;/a&gt; 构建系统、 &lt;a href=&quot;https://fbinfer.com/&quot;&gt;Infer&lt;/a&gt;/ &lt;a href=&quot;https://engineering.fb.com/2017/10/19/android/open-sourcing-racerd-fast-static-race-detection-at-scale/&quot;&gt;RacerD&lt;/a&gt;/&lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt; 测试与静态分析），另外 Meta 官博还有一篇介绍开发者工作流的文章 &lt;a href=&quot;https://developers.facebook.com/blog/post/2022/11/15/meta-developers-workflow-exploring-tools-used-to-code/&quot;&gt;Meta 开发者工作流：探索大规模编码工具&lt;/a&gt; 。&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.reddit.com/r/Python/comments/111y9o2/python_projects_with_best_practices_on_github/&quot;&gt;GitHub 上有哪些值得推荐学习的 Python 项目？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Github 上有哪些运用了最佳实践，并且有强大而良好架构的项目？这是 Reddit 上的帖子，可去看看大家推荐了什么。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/gto76/python-cheatsheet&quot;&gt;python-cheatsheet: Python 知识点速查表&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一份非常全面的 Python 知识手册，除了 Github 仓库，还有在线网站及 PDF 版本。（star 33K）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/pengzhile/pandora&quot;&gt;pandora：潘多拉，一个让你呼吸顺畅的ChatGPT&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;国人开源的项目，实现了网页版 ChatGPT 的主要操作，能解决国内访问 ChatGPT 的诸多痛点。（star 18.6K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/web2py/py4web&quot;&gt;py4web：数据库驱动的 Web 开发框架&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这个框架可以快速开发由数据库驱动的 Web 应用，它基于流行的全栈框架 &lt;a href=&quot;https://github.com/web2py/web2py&quot;&gt;web2py&lt;/a&gt; ，但比后者快 10-20 倍。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.oschina.net/p/fastapi-vue-admin&quot;&gt;FastAPI-Vue-Admin：基于 FastAPI+Vue 的敏捷开发框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于 FastAPI、Vue2.x、ElementUI、MySQL 等框架精心打造的一款模块化、高性能、企业级的敏捷开发框架，实现了可插拔的组件式开发方式。国人作品（收费），有完善的中文支持。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/sunner/ChatALL&quot;&gt;ChatALL：同时与ChatGPT、Bing Chat、Bard、Alpaca、Claude、讯飞星火、文心一言等聊天&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个项目的中文名叫“&lt;strong&gt;齐叨&lt;/strong&gt;”，可同时与多个 AI 对话，方便取得最佳答案。（star 8.2K）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/jina-ai/vectordb&quot;&gt;vectordb：一个 Python 向量数据库&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;纯 Python 开发的向量数据库，支持 CURD 及强大的可扩展能力（分片与复制）。使用了  &lt;a href=&quot;https://github.com/docarray/docarray&quot;&gt;DocArray&lt;/a&gt; 充当驱动向量搜索逻辑的引擎，使用  &lt;a href=&quot;https://github.com/jina-ai/jina&quot;&gt;Jina&lt;/a&gt; 保证高效和可扩展的索引服务。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/grantjenks/python-sortedcontainers&quot;&gt;python-sortedcontainers：有序容器类型（有序列表、有序字典和有序集合）&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一个纯 Python 实现的有序容器库，提供了列表、集合与字典的有序版本，API 兼容，号称经常比 C 实现更快。用户指南中提供了几份性能对比报告，数据很可观。（star 3K）&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/pallets/quart&quot;&gt;quart：一个支持异步的 Python Web 框架&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这是基于 Flask 框架而作的异步版实现，支持快速将 Flask 项目改造成支持异步。（star 2K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/RayVentura/ShortGPT&quot;&gt;ShortGPT：自动生成短视频内容的 AI 框架&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一个强大的自动化内容生成框架，简化了视频创建、素材获取、字幕生成、画外音合成和编辑任务。（star 1.4K）&lt;/div&gt;
&lt;h3&gt;🐢播客&amp;amp;视频&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pythonhunter.org/episodes/ep41&quot;&gt;捕蛇者说 Ep 41：和 Penguin 聊聊 CPython 优化和大厂编译器组的工作&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这期播客的嘉宾曾出现在我们周刊的第 7 期，他给 &lt;a href=&quot;https://github.com/python/cpython/issues/101632&quot;&gt;CPython 添加返回常量指令&lt;/a&gt; ，节目聊了他给 CPython 做的这项工作以及在腾讯做编译器开发的情况。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.pythonshow.com/p/07-the-robyn-python-web-framework#details&quot;&gt;The Python Show 07 - 访谈 Robyn Web 框架的作者&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Robyn&lt;/strong&gt; 是用 Rust 开发的轻量级、高性能 Python Web 框架。这期播客聊了关于 Robyn 的相关话题。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.youtube.com/playlist?list=PLt4L3V8wVnF4GJb8dekLGTNx44FNIFwdv&quot;&gt;2023 年 Python 网络大会的 80 个视频&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Python 网络大会（Python Web Conf）今年举办了第 5 届，上周发布了相关的视频材料，涵盖主题有人工智能/机器学习、大数据、CI/CD、Serverless、安全、容器等等。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://thecreatorsai.com/p/what-to-watch-about-ai-6-youtube&quot;&gt;关于 AI 内容：推荐 6 个 YouTube 频道&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;想要了解 AI？想观看关于 ChatGPT 的相关视频？想发现最新潮的 AI 工具？这里推荐了 6 个油管频道。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.xiaoyuzhoufm.com/episode/64b4f4c5d0844ea812ce31e9&quot;&gt;除你武器 013｜我也不想工作啊，只是想找个岸上一上&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是我本周听到最喜欢的一档播客！这期节目聊了就业与人生选择的相关话题。（如果你是高考毕业生，可去听第 11 期高考特辑 &lt;a href=&quot;https://www.xiaoyuzhoufm.com/episode/647c8bb653a5e5ea14dbffad&quot;&gt;成为状元 9 年后，我还在做高考的噩梦&lt;/a&gt;）&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-07-29-weekly&quot;&gt;第13期（2023-07-29）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://blog.jupyter.org/announcing-jupyter-notebook-7-8d6d66126dcf&quot;&gt;Jupyter Notebook 7 隆重发布&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Jupyter Notebook 大版本更新，亮点包括实时协作、交互式调试、目录、主题和深色模式、国际化、改进的可访问性、移动设备上的紧凑视图。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://juejin.cn/post/7258881840823615544&quot;&gt;Python 中的弱引用与基础类型支持情况探究&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 的基础类型 Int、List、Dict、Tuple、Str 不支持弱引用，而 Object、Type、Set 等类型却支持弱引用，为什么会出现这种情况呢？文章给出了自己的分析。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;http://so1n.me/2023/07/23/distributed_lock_lntroduction_and_lmplementation/&quot;&gt;分布式锁的介绍与 Python 实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;什么情况下要使用分布式锁？如何用 py-redis 实现分布式锁，加锁与解锁的流程是怎样的？加锁的超时时间有什么注意点，如何实现 WatchDog 给锁自动续约？&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://scofield.hashnode.dev/unlocking-the-power-of-pyscript-a-guide-to-running-python-code-in-your-html&quot;&gt;释放 PyScript 的力量：在 HTML 中运行 Python 代码&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一篇 PyScript 入门教程，介绍了安装、基础知识、配合 Flask 的使用以及高级功能。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://superfastpython.com/faster-file-io-with-concurrency/&quot;&gt;通过并发实现更快的文件 I/O&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;什么是文件 I/O，为什么它会比主内存 I/O 慢很多？文件 I/O 的速度与哪些因素有关？有哪些提升文件 I/O 性能的方法？&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://dev.to/atkumar/how-to-write-impeccably-clean-code-that-will-save-your-sanity-4np9&quot;&gt;如何编写完美干净的 Python 代码？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章介绍了一些最佳编程实践，涵盖代码结构、pre-commit、类型提示、文档字符串、lint、Pydantic、拼写检查、测试等方面。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://betterstack.com/community/guides/logging/best-python-logging-libraries/&quot;&gt;Python 日志记录：对比最流行的 6 个库&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章详细对比了当前最为流行的 6 种日志框架：&lt;strong&gt;logging、loguru、structlog、Eliot、logbook 与 picologging&lt;/strong&gt; 。最推荐的无疑是前两个，其它权当兴趣尝鲜吧。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://adamj.eu/tech/2023/07/23/python-profile-section-cprofile/&quot;&gt;使用 cProfile 分析模块级代码&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;如何使用 &lt;strong&gt;cProfile&lt;/strong&gt; 来对 Python 代码进行性能分析？文章简单介绍了它的用法，并给出了上下文管理器与装饰器两种高级用法。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://www.codium.ai/blog/mastering-functional-programming-in-python/&quot;&gt;掌握 Python 函数式编程&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章介绍了函数式编程的优点、Python 对函数式编程的支持、最佳实践以及编写 Python 程序时要避免的错误。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://realpython.com/python312-f-strings/&quot;&gt;Python 3.12 预览版：更直观和一致的 f-string&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;在 Python 3.12 之前，f-string 有什么限制？即将发布的 3.12 版本会带来哪些变化呢？新功能前瞻：嵌入表达式可以重用引号、f-string 中允许使用反斜杠、多行表达式中可写注释、任意级别的 f-string 嵌套、优化了 f-string 的错误提示……&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://dev.to/akarshan/asynchronous-python-magic-how-to-create-awaitable-constructors-with-asyncmixin-18j5&quot;&gt;使用 AsyncMixin 创建可等待的构造函数&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;介绍了如何使用名为 &lt;code&gt;AsyncMixin&lt;/code&gt; 的 mixin 在 Python 中创建异步构造函数。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://snyk.io/blog/insecure-direct-object-references-python/&quot;&gt;在 Python 中查找并修复不安全的直接对象引用&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;不安全的直接对象引用 (IDOR) 是一种安全漏洞，文章介绍了这种漏洞的危害，如何识别并修复 IDOR 漏洞。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://medium.com/@DorIndivo/overcoming-performance-bottlenecks-with-async-python-a-deep-dive-into-cpu-bound-code-b604a400255a&quot;&gt;使用异步 Python 克服性能瓶颈：深入研究 CPU 密集型代码&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;作者介绍了如何识别和优化特征存储中 CPU 密集型代码，从而提升核心模型的性能。事件循环延迟是什么，如何监控异步代码消耗的时间？&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://peps.python.org/pep-0720/&quot;&gt;PEP-720 交叉编译 Python 包&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;交叉编译是指在一台计算机上编译适用于另一种体系结构的程序。这份 PEP 试图揭示交叉编译遇到的挑战，并以此进行改进。&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;https://pep-previews--3210.org.readthedocs.build/pep-0722/&quot;&gt;PEP-722 单文件脚本的依赖关系规范&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;在项目中记录和管理第三方库，这有很多解决方案。但是，如何给单文件管理三方库依赖呢？这份 PEP 提出了一种很简单的规范格式。&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/srbhr/Resume-Matcher&quot;&gt;Resume-Matcher：比较简历与职位描述，按照打分排名&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;基于 AI 的简历匹配器，根据 JD 的关键词给简历打分。使用 Qdrant（一种高效的向量相似度搜索工具）来衡量简历与 JD 的匹配程度。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/PyHAT-stack/awesome-python-htmx&quot;&gt;awesome-python-htmx：Python 中使用 htmx 作 Web 开发的精选内容&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;PyHAT 旨在 Python 中推广 htmx+ASGI+TailwindCSS，这个项目列出了一些入门资源、教程、设计理论、周边生态等等。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/THUDM/CodeGeeX2&quot;&gt;CodeGeeX2: 更强大的多语言代码生成模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于 ChatGLM2-6B 基座语言模型，在 Python 上达到 35.9% 的 Pass@1 一次通过率，超越规模更大的 StarCoder-15B。CodeGeeX 插件支持 VS Code、 IntelliJ IDEA、PyCharm、GoLand、WebStorm、Android Studio 等IDE。（star 1K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/LinkSoul-AI/Chinese-Llama-2-7b&quot;&gt;Chinese-Llama-2-7b: 第一个能下载运行的中文 LLaMA2 模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;开源可商用的&lt;strong&gt;中文版 Llama2 模型及中英文 SFT 数据集&lt;/strong&gt;，兼容适配所有针对原版 &lt;em&gt;llama-2-chat&lt;/em&gt; 模型的优化。（star 1K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/soulteary/docker-llama2-chat&quot;&gt;docker-llama2-chat: LLaMA2 (official / 中文版 / INT4 / llama2.cpp)&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;中文开源项目，三步上手 LLaMA2，作者写了一系列教程博客。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/Avaiga/taipy&quot;&gt;taipy：将数据和 AI 算法转变为完整的 Web 应用&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一个全栈项目，快速将数据和 AI 构建出 Web 应用。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/lmacken/pyrasite&quot;&gt;pyrasite：将代码注入正在运行的 Python 进程&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;允许在运行中的 Python 进程里注入自定义代码，以实现动态调试、修改变量值、破解加密、分析运行时行为等功能。支持多种注入方式，包括注入到 Python 解释器、注入到指定函数、注入到特定线程等。（star 2.7K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/ionelmc/python-manhole&quot;&gt;python-manhole：调试运行中的 Python 程序&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;在运行中的 Python 进程里提供交互式的调试和监控功能，利用 Python 的”ptrace”机制，通过在目标进程中注入代码，可通过 SSH 或 telnet 等协议连接，实现远程交互。与 gevent 和 eventlet 兼容，有少许限制。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/RamiKrispin/vscode-python&quot;&gt;vscode-python：使用 VScode 和 Docker 设置 Python 开发环境&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一个非常完备的教程项目，指导在 Docker 上运行 Python、设置开发环境与容器扩展、测试与部署等。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/SergeyPirogov/webdriver_manager&quot;&gt;webdriver_manager：Python 的 Webdriver 管理器&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;使用 &lt;strong&gt;Selenium&lt;/strong&gt; 与 &lt;strong&gt;Playwright&lt;/strong&gt; 等框架时，要管理各种浏览器驱动。这个项目简化了浏览器驱动的管理与使用方式。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/JetBrains/lets-plot&quot;&gt;lets-plot：用于统计数据的开源绘图库&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;JetBrains&lt;/strong&gt; 开源的一个绘图库，可创建美观、交互式的统计图表和数据可视化。为 Python 和 Kotlin 开发者提供类似 &lt;strong&gt;ggplot2&lt;/strong&gt; 的绘图 API。（star 1.1K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/pdfarranger/pdfarranger&quot;&gt;pdfarranger：在图形界面合并或拆分 PDF 文档，支持旋转、裁剪和重排&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一个小型 python-gtk 程序，通过直观的方式编辑 PDF 文档。它的后端基于 &lt;a href=&quot;https://github.com/pikepdf/pikepdf&quot;&gt;pikepdf&lt;/a&gt; ，这是一个用于读写 PDF 文件的库。（star 2.3K）&lt;/div&gt;
&lt;h3&gt;🥂讨论&amp;amp;问题&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://discuss.python.org/t/a-steering-council-notice-about-pep-703-making-the-global-interpreter-lock-optional-in-cpython/30474?s=35&quot;&gt;关于 PEP-703 的指导委员会通知（使 CPython 的 GIL 成为可选）&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;在第 11 期周刊中，我们分享过“如果 PEP-703 被采纳，Meta 将投入人力支持”，现在又有进展啦，指导委员会打算接受 PEP-703 了！这篇帖子列出几个基本原则与三个阶段的开发计划。向后兼容性是重中之重，这不会是 Python 4。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-08-05-weekly&quot;&gt;第14期（2023-08-05）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://lpython.org/blog/2023/07/lpython-novel-fast-retargetable-python-compiler/&quot;&gt;LPython：新颖、高性能、适用于多平台的 Python 编译器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;最新发布的一个Python 编译器（当前为 alpha 版本），目标是打造高性能的 Python。可以将带有类型提示的 Python 代码编译为优化的机器代码，支持提前编译（AOT）与即时编译（JIT），支持与 CPython 互操作，支持多种后端，例如 LLVM、C、C++、WASM、Julia 和 x86。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://cython.readthedocs.io/en/latest/src/changes.html&quot;&gt;Cython 3.0.0 的文档&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Cython 是一门专用于提升 Python 性能的编程语言，最近从 0.29.x 版本直接升到了 3.0.0 版本，带来了大量的问题修复以及新特性，这份 changelog 文档非常丰富。（附一篇&lt;a href=&quot;https://mp.weixin.qq.com/s/CcC1QEojybyRpzUUiJxdAw&quot;&gt;详解历时五年的 Cython3.0 都发生了哪些变化&lt;/a&gt; ，总结了这个版本的几项较大的变化点。）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.marsja.se/coefficient-of-variation-in-python-with-pandas-numpy/&quot;&gt;Python 中使用 Pandas 和 NumPy 计算变异系数&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;变异系数（Coefficient of Variation，CoV）是一种统计量，用于评估数据集相对于其均值的相对变异性或离散程度。文章介绍了变异系数的公式、解释、意义和实际用途，以及如何用 Pandas 和 Numpy 来计算变异系数。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://blog.jupyter.org/generative-ai-in-jupyter-3f7174824862&quot;&gt;Jupyter 中的生成式 AI&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Jupyter Notebook 也支持 AI 功能了，目前免费提供。官博这篇教程指导了如何在聊天界面使用 Jupyter AI 完成各项任务。支持来自 AI21、Anthropic、AWS、Cohere、HuggingFace Hub 和 OpenAI 的大语言模型。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.tartley.com/posts/structured-pattern-matching-in-python/&quot;&gt;Python 中的结构化模式匹配&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 3.10 版本的模式匹配语法，你用过了么？这篇文章探究了这种语法的相关要素（基本结构、每种模式的演示），也思考了是否真必要用模式匹配语法替换&lt;code&gt;elif&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://textual.textualize.io/blog/2023/07/27/using-rich-inspect-to-interrogate-python-objects/&quot;&gt;使用 Rich 的 Inspect 查看 Python 对象属性&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Rich 是一个在终端使用富文本和美观样式的库（本期周刊的“项目&amp;amp;资源”中有介绍），这篇文章介绍了它的 inspect() 函数，可以查看 Python 对象的属性以及可用的 API。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://sethmlarson.dev/pep-440&quot;&gt;Python 包版本控制的怪癖&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个冷门话题，讨论了 Python 包的版本号。我才知道 Python 包版本命名竟有 6 个组成部分！文章大部分内容是对 &lt;a href=&quot;https://peps.python.org/pep-0440/&quot;&gt;PEP-440（版本标识和依赖规范）&lt;/a&gt; 的介绍与解读，最后也介绍到了 Wheel 包的版本命名规则。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://superfastpython.com/file-io-concurrent-patterns/&quot;&gt;文件 I/O 并发编程的模式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用并发编程来提升文件 I/O 操作的性能，具体有哪些使用手段呢？文章介绍了四种模式（单线程、线程池/进程池、批处理任务、在进程池中使用线程池），并讨论了该如何选择更合适的模式。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://mostlypython.substack.com/p/reading-code?nthPub=581&quot;&gt;如何高效地阅读 Python 代码？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;对于所有程序员来说，阅读代码都是一项必备能力。但是，如何高效地阅读与理解别人的代码呢？这篇文章介绍了一些阅读策略与技巧，同时站在阅读者的视角，也有助于我们写出更具可读性、可理解性的代码。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://www.askpython.com/python/examples/call-java-using-python&quot;&gt;如何在 Python 中用 JPype 与 Pyjnius 调用 Java 代码？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Java 和 Python 各有优点，如何能将它们结合起来呢？这篇文章介绍了如何用 &lt;strong&gt;JPype&lt;/strong&gt; 和 &lt;strong&gt;Pyjnius&lt;/strong&gt; 等方式来调用 Java，同时指出实现方案所面临的挑战和限制。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://dev.to/willp/call-javascript-code-in-python-551a&quot;&gt;如何在 Python 中调用 JavaScript 代码？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了 &lt;a href=&quot;https://github.com/Distributive-Network/PythonMonkey&quot;&gt;PythonMonkey&lt;/a&gt; 库的用法，实现在 Python 中加载与运行 JavaScript 代码，以及在 Python 中使用 WASM。（附作者的其它文章：&lt;a href=&quot;https://medium.com/@willkantorpringle/executing-rust-in-python-using-webassembly-d361eb5583da&quot;&gt;使用 WebAssembly 在 Python 中执行 Rust 代码&lt;/a&gt; 、&lt;a href=&quot;https://medium.com/@willkantorpringle/calling-c-function-from-python-using-webassembly-63a305248951&quot;&gt;使用 WebAssembly 在 Python 中调用 C 函数&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://chaoticengineer.hashnode.dev/textual-and-chatgpt&quot;&gt;使用 Textual 构建 ChatGPT TUI 应用程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;本期周刊有好几则内容与 &lt;a href=&quot;https://github.com/Textualize/textual&quot;&gt;Textual&lt;/a&gt; 相关！与图形用户界面（GUI）相比，文本用户界面（TUI）响应更快、系统要求更低和更易自动化。这篇文章使用 Textual 构建了一个 ChatGPT 对话工具。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://code.dblock.org/2023/06/16/getting-started-with-vector-dbs-in-python.html&quot;&gt;Python 中的向量数据库入门&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何在 Python 中使用当前热门的向量数据库呢？这篇文章介绍了使用 10 多种数据库来索引及搜索向量数据，包括 ClickHouse、OpenSearch、pgVector、Pinecone、Redis 等等。&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://dev.to/cwprogram/a-tour-of-cpython-compilation-cd5&quot;&gt;CPython 的编译过程是怎样的？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;CPython 是 Python 官方的解释器实现，这篇长文介绍了它的编译过程，包括语法解析、抽象语法树、字节码、pyc 解析等内容。&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;https://dev.to/mintzworld/the-new-pdbp-pdb-python-debugger-2blc&quot;&gt;介绍新开源的 Python 调试器 pdbp (Pdb+)！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者指出了 Python 内置的 &lt;strong&gt;pdb&lt;/strong&gt; 与其它调试器（如 &lt;strong&gt;ipdb、pdbpp&lt;/strong&gt;）的缺点，介绍了他开发的 pdbp 所作的修复和改进，以及简单的入门使用。这个库依赖项很少，功能强大，值得一试。&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pyflo.net/&quot;&gt;PyFlo：一个很有趣的 Python 入门教学网站&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个网站非常惊艳，推荐大家去体验下！主页是一幅学习线路图，画了不同的学习分支和内容分类，还有几个编程项目挑战，点击每个节点则跳转到对应内容的页面。（借鉴此网站的创意，开发面向中文读者的教学网站，应该会挺有趣）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://pandastutor.com/&quot;&gt;Pandas Tutor：可视化 Pandas 执行过程的网站&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;你或许已知道 &lt;a href=&quot;https://pythontutor.com/&quot;&gt;Python Tutor&lt;/a&gt;，它是一个提供了在线交互式 Python 编程环境的教学工具。这里介绍的 Pandas Tutor 也是类似的网站，它允许在浏览器中编写 Pandas 代码，并可视化数据的转换过程。 （附一篇文章，两位作者介绍了他们将 &lt;a href=&quot;https://blog.pyodide.org/posts/pandastutor/&quot;&gt;Pandas Tutor 移植到 Pyodide &lt;/a&gt; 的工作，以便大规模推广数据科学的教学）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://ploomber-sql.readthedocs.io/en/latest/index.html&quot;&gt;ploomber-sql：使用 SQL 和 Jupyter 开发端到端的应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是托管在 Read The Docs 上的一个教学课程，介绍了如何使用 SQL 和 Jupyter 作数据分析，包含操作数据库、高级查询技术、数据可视化（&lt;strong&gt;seaborn、plotly、ggplot&lt;/strong&gt;）、项目打包部署与监控等章节。它出自于开源项目 &lt;a href=&quot;https://github.com/ploomber/ploomber&quot;&gt;ploomber&lt;/a&gt; （star 3.1K），后者是一个快速构建数据管道的项目。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/bloomberg/memray&quot;&gt;memray：Python 的内存分析器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是周刊&lt;a href=&quot;https://pythoncat.top/posts/2023-07-22-weekly&quot;&gt;第 12 期&lt;/a&gt;介绍过的 &lt;strong&gt;pystack&lt;/strong&gt; 的姊妹项目，可以跟踪 Python 代码、C/C++ 扩展模块和 Python 解释器本身中的内存分配，支持本机模式与实时查看模式，可生成多种类型的报告。提供了 Pytest 插件 &lt;a href=&quot;https://github.com/bloomberg/pytest-memray&quot;&gt;pytest-memray&lt;/a&gt;，可以在运行测试套后查看内存报告。（star 11K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/1j01/textual-paint&quot;&gt;textual-paint：终端中的 MS Paint&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;MS Paint&lt;/strong&gt; 是微软公司开发的一款简单的图像编辑软件。这个项目是 MS Paint 风格的 TUI 图像编辑器，支持在终端中打开与保存图像、MS Paint 中的所有工具、调色板、画笔预览等等功能。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/Textualize/rich&quot;&gt;rich：在终端中提供富文本和美观的样式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Rich 让终端不再单调，可以绘制漂亮的表格、进度条、markdown、源代码语法高亮以及栈回溯信息等。（star 44.2K）下面这张效果图，囊括了它的主要特色：&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/Salaah01/json-lineage&quot;&gt;json-lineage：支持解析大型 JSON 文件的工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是用 Rust 开发的 JSON 解析库，主要解决大文件无法加载到内存的痛点，通过将 JSON 转化成 JSONL 格式，解决内存消耗问题。测试表明，处理一个 500MB 文件，Python 标准库要用 2GB 内存，但这个库仅需 1.5MB，而且速度差异很小。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/Distributive-Network/PythonMonkey&quot;&gt;PythonMonkey：嵌入到 Python VM 中的 JavaScript 引擎&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;前文已出现过 PythonMonkey，它将 Mozilla 的 SpiderMonkey JavaScript 引擎嵌入到 Python 虚拟机中，利用Python 引擎提供 JS 主机环境。这个项目的目标包括在 Python 中调用 JavaScript 库和在 JavaScript 中调用 Python 库，如果能有效打通这两种语言的生态，前途不可估量！&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/rapidsai/cudf&quot;&gt;cudf：GPU 数据帧库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;cuDF 基于 &lt;strong&gt;Apache Arrow&lt;/strong&gt; 列式内存格式构建，是一个 GPU DataFrame 库，用于加载、连接、聚合、过滤和以其它方式操作数据。提供了类似 pandas 的 API，无需了解 CUDA 编程的细节。（star 5.8K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/segmind/distill-sd&quot;&gt;distill-sd：更小更快的 Stable Diffusion&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;对 Stable Diffusion 作“知识蒸馏”后的小型化版本，可生成与 SD 质量相当的图像，同时速度更快、空间占用更少。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/jiawen-zhu/HQTrack&quot;&gt;HQTrack：高质量追踪视频中的任何事物&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个对视频中对象作高性能跟踪和分割的框架，由视频多目标分割器（VMOS）和掩模优化器（MR）组成，可以同时跟踪多个目标物体并输出准确的物体掩模。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/kelvins/awesome-mlops&quot;&gt;awesome-mlops：很棒的 MLOps 工具精选列表&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个 awesome 系列的 MLOps 精选列表，包含各种各样的项目/工具，以及文章、书籍、活动、播客和网站等等资源。&lt;/div&gt;
&lt;h3&gt;🐢播客&amp;amp;视频&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://talkpython.fm/episodes/show/425/memray-the-endgame-python-memory-profiler&quot;&gt;Talk Python To Me #425：终极的 Python 内存分析器 Memray&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;本期的“项目&amp;amp;资源”介绍了 Memray，这里的播客节目邀请了两位嘉宾深入聊了这个项目。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-08-12-weekly&quot;&gt;第15期（2023-08-12）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、 &lt;a href=&quot;https://blog.balthazar-rouberol.com/how-to-profile-a-fastapi-asynchronous-request&quot;&gt;如何分析 FastAPI 异步请求的性能？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;cProfile&lt;/strong&gt; 这种基于函数调用的分析工具无法有效分析异步操作的执行时间，文章介绍了 &lt;a href=&quot;https://github.com/joerick/pyinstrument&quot;&gt;pyinstrument&lt;/a&gt; 这个分析库，结合 &lt;strong&gt;FastAPI.middleware&lt;/strong&gt; 装饰器，并使用 &lt;a href=&quot;https://github.com/jlfwong/speedscope&quot;&gt;speedscope&lt;/a&gt; 来可视化 FastAPI 程序的耗时情况。&lt;/div&gt;
&lt;div&gt;2、 &lt;a href=&quot;https://noplacelikelocalhost.medium.com/leveraging-background-tasks-in-fastapi-enhancing-performance-and-responsiveness-6e4ad64c7d16&quot;&gt;利用 FastAPI 的后台任务：增强性能和响应能力&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了 FastAPI 的 BackgroundTasks，可以创建后台任务，用于管理长时间运行的任务，而不阻塞主进程。&lt;/div&gt;
&lt;div&gt;3、 &lt;a href=&quot;https://compucademy.net/creating-histograms-with-python/&quot;&gt;使用 Python 创建直方图&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;直方图又名“柱状图”，可直观查看数据的分布趋势、离散程度和异常值等信息。文中介绍了 Matplotlib、Plotly、Seaborn、Numpy 和 Pandas 等工具绘制直方图的方法，介绍各种直方图的样式和风格、处理异常值、分析时间序列数据等。&lt;/div&gt;
&lt;div&gt;4、 &lt;a href=&quot;https://mypy-lang.blogspot.com/2023/08/mypy-15-released.html&quot;&gt;Mypy 1.5 发布了&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Mypy 是 Python 的静态类型检查工具，1.5 版本主要功能有：不再支持 Python 3.7、更灵活的 TypedDict 创建和更新、可显示错误代码的文档链接、实验性改进了泛型函数的类型推断、对 Python 3.12 的部分支持，等等。&lt;/div&gt;
&lt;div&gt;5、 &lt;a href=&quot;https://jvns.ca/blog/2023/08/03/behind--hello-world/&quot;&gt;在 Linux 上运行 Python 的“Hello World”脚本时，会发生什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在 py 文件中写上一句&lt;code&gt;print(&quot;hello world&quot;)&lt;/code&gt;，然后在命令行执行这个文件，幕后都发生了什么呢？文章使用了 &lt;code&gt;readelf&lt;/code&gt; 、&lt;code&gt;strace&lt;/code&gt; 、&lt;code&gt;ldd&lt;/code&gt; 、&lt;code&gt;debugfs&lt;/code&gt; 、&lt;code&gt;/proc&lt;/code&gt; 、&lt;code&gt;ltrace&lt;/code&gt; 、&lt;code&gt;dd&lt;/code&gt; 和 &lt;code&gt;stat&lt;/code&gt; 等工具，详细解释了脚本被执行的过程。主要涉及操作系统相关的内容，而不是 CPython 解释器。（附：文章还引用了最近很火的 &lt;a href=&quot;https://cpu.land/&quot;&gt;Putting the “You” in CPU &lt;/a&gt; ，介绍计算机是如何运行程序的，强烈推荐！）&lt;/div&gt;
&lt;div&gt;6、 &lt;a href=&quot;https://kenschutte.com/postscript-vs-python&quot;&gt;通过对比 Python 来学习 PostScript&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PostScript 是电子出版和桌面出版领域的页面描述语言，广泛用于打印机、出版和图形设备。文章将一段 PostScript 程序直译成 Python 代码，可以让你快速了解这门语言的语法。&lt;/div&gt;
&lt;div&gt;7、 &lt;a href=&quot;https://www.nathom.dev/blog/casual_performance_optimization_python/&quot;&gt;Python 中不那么随意的性能优化&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者的一段代码，用 Rust 花了 950 毫秒，而 Python 却花 70 秒！这怎么能忍！将生成器写法改成 for 循环后，只是轻微提速，使用 Numpy 和多进程做了一些优化后，终于看到了比较可观的数据。不同代码方案的对比、Python 底层工作原理、内存使用效率问题，以及语言特性的差异。&lt;/div&gt;
&lt;div&gt;8、 &lt;a href=&quot;https://www.pythonmorsels.com/creating-a-context-manager/&quot;&gt;在 Python 中创建上下文管理器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何用 Python 创建自己的上下文管理器？上下文管理器是可以在 &lt;code&gt;with&lt;/code&gt; 代码块中使用的对象，在进入和退出时做一些操作。文章介绍了上下文管理器的实现细节。&lt;/div&gt;
&lt;div&gt;9、 &lt;a href=&quot;https://kenschutte.com/python-swap-ints&quot;&gt;一个简单的模块，可以篡改 Python 解释器的数字&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇有意思的文章。导入一个模块后，可以将 8 和 9 互换，即&lt;code&gt;print(8)&lt;/code&gt; 会打印出 9。文章展示了如何用 C 编写一个简单的模块，介绍了 CPython 中整数对象池的实现，并通过修改两个整数的引用，实现一个简单的篡改数字的效果。&lt;/div&gt;
&lt;div&gt;10、 &lt;a href=&quot;https://josvisser.substack.com/p/why-python-is-terrible&quot;&gt;为什么说 Python 很糟糕……&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇给 Python 泼冷水的文章，主要观点是认为 Python 不适合于开发大型应用。批评的点包括动态和鸭子类型、性能问题、代码维护和重构难等问题。&lt;/div&gt;
&lt;div&gt;11、 &lt;a href=&quot;https://pybit.es/articles/python-errors-should-not-pass-silently/&quot;&gt;Python 中错误处理的最佳实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 之禅说“错误不应该悄无声息地被忽略”，强调了应该直面错误和透明处理。文章指出了一些糟糕的错误处理写法，给出了尽早检查错误、快速失败处理等编程建议。&lt;/div&gt;
&lt;div&gt;12、 &lt;a href=&quot;https://www.pythongasm.com/build-gpt-powered-chatbots-around-enterprise-data-with-python&quot;&gt;使用企业数据和 Python 构建 GPT 对话机器人&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这篇教程介绍了搭建企业中 GPT 对话机器人的完整流程，包括数据索引、查询检索、集成 LLM、使用 FastAPI 开发接口、uvicorn 作部署。&lt;/div&gt;
&lt;div&gt;13、 &lt;a href=&quot;https://www.bitecode.dev/p/python-cocktail-mix-a-context-manager&quot;&gt;Python 鸡尾酒：将上下文管理器和迭代器等量混合&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;tenacity&lt;/strong&gt; 库提供了一种用迭代器和上下文管理器组合的写法，实现重试机制。这篇文章演示了如何用自定义的迭代器和上下文管理器，来实现同样的功能，可以让你更深入理解这两个好用的特性。&lt;/div&gt;
&lt;div&gt;14、 &lt;a href=&quot;https://stackabuse.com/the-power-of-indexing-boosting-data-wrangling-efficiency-with-pandas/&quot;&gt;索引的力量：利用 Pandas 提高数据整理效率&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Pandas 被广泛用于数据处理，文章介绍了如何高效利用索引技术，提升它整理数据的速度和效率。介绍了多种索引技术，例如基于整数的索引、布尔索引、设置新索引并重置旧索引、排序索引。&lt;/div&gt;
&lt;div&gt;15、 &lt;a href=&quot;https://www.tinybird.co/blog-posts/killing-the-processpoolexecutor&quot;&gt;杀死 ProcessPoolExecutor&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 不适合处理 CPU 密集型任务，文章中项目原本使用进程池来规避 GIL 问题，后使用线程、C++ 扩展和更精细调整的 GIL 控制，将内存使用量减少 50%，CPU 使用量减少约 20%，线程和进程减少约 70%，I/O 流量减少 100%。&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、 &lt;a href=&quot;https://github.com/joerick/pyinstrument&quot;&gt;pyinstrument：Python 的调用堆栈分析器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个轻量级、无侵入的 Python 代码性能分析库，支持分析异步任务和事件循环代码，可生成多种格式的分析报告，包括文本、HTML 和火焰图。（star 5.5K）&lt;/div&gt;
&lt;div&gt;2、 &lt;a href=&quot;https://github.com/gaogaotiantian/viztracer&quot;&gt;viztracer：低开销的日志记录/调试/分析工具，可视化 Python 代码的执行&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;国人开源的日志记录/调试/分析工具，支持线程、多进程、子进程和异步，支持火焰图、远程连接、虚拟调试等，有强大的前端，可流畅渲染 GB 级堆栈信息。（star 3.5K）&lt;/div&gt;
&lt;div&gt;3、 &lt;a href=&quot;https://github.com/jd/tenacity&quot;&gt;tenacity：Python 重试库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可提供简单而灵活的方式来实现可靠的重试机制，支持指定重试次数、重试间隔时间、重试的回调函数、根据不同的错误条件进行重试等功能，减少手动处理错误和异常的麻烦。（star 5.1K）&lt;/div&gt;
&lt;div&gt;4、 &lt;a href=&quot;https://github.com/litestar-org/litestar&quot;&gt;litestar：轻量、灵活且可扩展的 ASGI API 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个高性能的 ASGI API 框架，其早期版本是基于 &lt;a href=&quot;https://github.com/encode/starlette&quot;&gt;Starlette&lt;/a&gt; 开发的，命名为 &lt;strong&gt;Starlite&lt;/strong&gt;，但从 2.0 版本起已完全移除 Starlette 依赖，并改名为 litestar。核心特性：基于类的控制器、依赖注入、分层中间件、插件系统、OpenAPI 3.1、内置 Trio，等等。（star 2.5K）&lt;/div&gt;
&lt;div&gt;5、 &lt;a href=&quot;https://github.com/junshutang/Make-It-3D&quot;&gt;Make-It-3D：利用单个图像创建高保真 3D 模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;从图片中分割物体，创建高保真的 3D 几何形状，可作 360° 旋转展示。（star 1.2K）&lt;/div&gt;
&lt;div&gt;6、 &lt;a href=&quot;https://github.com/ErwannMillon/Color-diffusion&quot;&gt;Color-diffusion：对黑白图像进行着色的扩散模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用 diffusion  模型对黑白图像进行着色，使用 LAB 色彩空间实现，这是 RGB 色彩空间的 3 通道替代方案。&lt;/div&gt;
&lt;div&gt;7、 &lt;a href=&quot;https://github.com/kuafuai/DevOpsGPT&quot;&gt;DevOpsGPT：AI 驱动的自动化软件开发系统&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;将 LLM 与 DevOps 工具相结合，将自然语言需求转换为可工作的软件。无需繁琐的需求文档编写与沟通，缩短开发与交付时间，加速软件部署和迭代。（star 1.2K）&lt;/div&gt;
&lt;div&gt;8、 &lt;a href=&quot;https://github.com/Instagram/LibCST&quot;&gt;ILibCST：Python 的具体语法树解析器和序列化器库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;具体语法树（Concrete Syntax Tree）是在词法分析和语法分析阶段后生成的一种数据结构，可用于分析代码结构，执行语义分析、重构优化和代码生成等操作。（star 1.2K）&lt;/div&gt;
&lt;div&gt;9、 &lt;a href=&quot;https://github.com/HypothesisWorks/hypothesis&quot;&gt;hypothesis：功能强大、灵活且易于使用的库，用于基于属性的测试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于属性的测试（Property-based Testing）是一种软件测试方法，其中测试用例的生成和验证是基于定义的属性或规约。传统的单元测试要给定具体的测试用例，而基于属性的测试则是随机生成大量的测试数据。（star 6.8K）&lt;/div&gt;
&lt;h3&gt;🐢播客&amp;amp;视频&lt;/h3&gt;
&lt;div&gt;1、 &lt;a href=&quot;https://pythonpeople.fm/&quot;&gt;Python People 播客&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一档新上线一个月的播客栏目，每周访谈 Python 社区里一位有突出贡献的大佬。目前已访谈的嘉宾有 Michael Kennedy（Talk Python to Me 和 Python Bytes 的主理人）、Paul Everitt（ JetBrains 和 PyCharm 的开发者倡导者）、Brett Cannon（Python 核心开发者）、Barry Warsaw（Python 核心开发者，非常早的成员）、Bob Belderbos（Pybites 的主理人）。&lt;/div&gt;
&lt;div&gt;2、 &lt;a href=&quot;https://talkpython.fm/episodes/show/426/whats-new-in-pyscript-august-2023&quot;&gt;Talk Python To Me #426：PyScript 的新增功能&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Pyscript 使 Python 能够在浏览器中运行。这期播客聊了它的最新进展。&lt;/div&gt;
&lt;div&gt;3、 &lt;a href=&quot;https://stackoverflow.blog/2023/08/08/understanding-sre-ep-597/&quot;&gt;Stack Overflow Blog #597：了解 SRE&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;网站可靠性工程（Site Reliability Engineering，SRE）是什么？它和 DevOps 有什么关系？如何平衡 SRE 的原则与组织结构的关系？生成式 AI 对 SRE 会带来什么影响？&lt;/div&gt;
&lt;div&gt;4、 &lt;a href=&quot;https://stackoverflow.blog/2023/07/25/how-the-python-team-is-adapting-the-language-for-an-ai-future-ep-593/&quot;&gt;Stack Overflow Blog #593：Python 团队如何调整语言以适应 AI 的未来&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;播客嘉宾是 Python 核心开发者和指导委员会成员 Pablo Galindo Salgado，讨论了如何平衡语言设计中的一致性和新功能、为什么收集社区对新版本的反馈很重要，以及为何他要专注于让 Python 更快。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-08-19-weekly&quot;&gt;第16期（2023-08-19）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://mathspp.com/blog/pydonts/does-elegance-matter&quot;&gt;写代码时，优雅有意义吗？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者强调使用 Python 的核心特性来编写惯用的、富有变现力的、优雅的代码很重要，提出优雅不是可有可无的奢侈品。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://so1n.me/2023/08/14/python_asyncio_concunrrency_result_share/&quot;&gt;Python Asyncio实践—高并发下如何防止缓存击穿&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了如何基于&lt;code&gt;Asyncio.Future&lt;/code&gt;的特性编写一个语言级别的防缓存击穿的工具——&lt;code&gt;Share&lt;/code&gt;，并介绍它的使用和高并发下的处理方法。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://juejin.cn/post/7266663176980185144&quot;&gt;高效定时任务处理：深入学习 Python 中 APScheduler 库的奥秘&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;APScheduler 是一个强大的定时任务处理库，这篇长文详细介绍了从入门到精通的相关知识，包括创建定时任务、定时任务触发器、任务存储、并发执行、阻塞和非阻塞调度器、错误处理、立即执行任务、调度器持久化、任务监听器和移除定时任务等。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://juejin.cn/post/7266037480750071848&quot;&gt;CPython 开发实战：魔改 lambda 函数&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章尝试将 Python 的 lambda 函数改成 Javascript 风格的箭头函数。在编译 CPython 时，通过修改 &lt;code&gt;.asdl&lt;/code&gt; 文件，重新构造抽象语法树，修改语法分析文件，并利用 &lt;strong&gt;pegen&lt;/strong&gt; 重新生成语法分析器。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://codeconfessions.substack.com/p/cpython-reference-counting-internals&quot;&gt;CPython 是如何实现引用计数的？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;你是否对 CPython 的底层运行原理及其内部结构感到好奇？文章通过分析源码，介绍了 CPython 是如何实现引用计数和内存管理的，涉及引用计数的机制、关键数据结构的解释、字节码指令的执行、引用计数的局限性等。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://coderslegacy.com/python-lazy-loading-with-importlib/&quot;&gt;使用 Importlib 实现 Python 延迟加载&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;延迟加载指的是在使用时再导入模块，而不是在程序刚执行时就加载。它的好处：减少启动时间、降低内存消耗、提高性能、优化资源、运行时加载。文章介绍了&lt;code&gt;importlib&lt;/code&gt; 实现延迟加载的用法。。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://sixfeetup.com/blog/end-to-end-testing-python-playwright&quot;&gt;使用 Python 和 Playwright 进行端到端测试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;端到端测试（end-to-end）指的是对程序的整个使用流程从头到尾作测试，可能发现单元测试与集成测试都无法发现的问题。这是一篇详细的入门教程，介绍了 &lt;strong&gt;Playwright&lt;/strong&gt; 的相关用法。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://lwn.net/Articles/939981/&quot;&gt;nogil 项目和 Faster CPython 项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 官方虽已宣布会接受 &lt;strong&gt;PEP-703&lt;/strong&gt;，但是最终版本或许要等到 5 年后的 3.17 版本。从 2021 年起，nogil 和 Faster CPython 项目持续吸引大家的关注，这篇文章梳理了它们两年来的发展情况、一些关键性问题的处理方案和重要进展、近期社区和大公司的回应等。（附：&lt;a href=&quot;https://pythoncat.top/posts/2021-11-14-GIL&quot;&gt;Python 官方第一次针对 nogil 的研讨会&lt;/a&gt;、&lt;a href=&quot;https://pythoncat.top/posts/2021-05-16-Guido&quot;&gt;Faster CPython 项目的首次亮相&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://engineering.fb.com/2023/08/15/developer-tools/immortal-objects-for-python-instagram-meta/&quot;&gt;简单介绍 Python 的永生对象&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Instagram 向 Python 贡献了 3.12 版本中的 &lt;a href=&quot;https://peps.python.org/pep-0683/&quot;&gt;PEP-683&lt;/a&gt;（永生对象，使用固定的引用计数），它可以绕过引用计数检查，这是多核 Python 并行处理的重要基础。文章介绍了 Instagram 遇到的内存使用问题、为解决问题而引入永生对象、并最终贡献到 CPython 的故事。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://pybit.es/articles/why-you-should-avoid-import-in-python/&quot;&gt;为什么要避免在 Python 中用“import *”？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 中一个文件是一个模块，拥有自己的命名空间。当使用“import *”时，这会导致“&lt;strong&gt;命名空间污染&lt;/strong&gt;”！文章指出了遵循 PEP-8 风格的正确写法，同时建议应该用&lt;code&gt;__all__&lt;/code&gt; 来定义模块中可被导出的变量名。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://prefix.dev/blog/launching_pixi&quot;&gt;让我们终结 Python 的依赖地狱&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/prefix-dev/pixi&quot;&gt;pixi&lt;/a&gt; 是最新发布的用 Rust 编写的 Python 包管理器，这篇文章出自其官方博客，主要介绍为什么要开发这个项目、它提供了哪些功能、它的基本执行过程。项目当前基于 Conda 生态，暂不支持 PyPI。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://pythonguides.com/jwt-authentication-using-django-rest-framework/&quot;&gt;使用 Django Rest Framework 实现 JWT 身份验证&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇非常详细的教程，介绍了 JWT 是什么以及它的工作原理，演示了如何用 DRF 实现 JWT 身份验证的全过程。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://johnnymetz.com/posts/slow-django-database-queries/&quot;&gt;增强 Django 程序：提升数据库查询的 7 个妙招&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;数据库查询是影响 Web 程序性能的主要因素之一，这篇文章介绍了 7 个提升性能的技巧：设置查询语句的超时时间、使用&lt;code&gt;assertNumQueries&lt;/code&gt; 测试查询数、使用&lt;code&gt;nplusone&lt;/code&gt; 捕获 N+1 查询、使用&lt;code&gt;django-zen-queries&lt;/code&gt; 捕获 N+1 查询、避免对预取对象作新的查询、使用 &lt;code&gt;defer()&lt;/code&gt; 防止获取大的未使用字段、避免在大字段上使用 &lt;code&gt;distinct()&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://martinheinz.dev/blog/103&quot;&gt;可能让你大吃一惊的奇怪的 Python “特性”&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;有时候我们会在编程语言中看到一些奇怪的现象，它们可能是一些非常冷门的“特性”，也可能会让人误以为是 bug 或者因理解错误而造成 bug。作者介绍了他的几个小发现。&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;https://blog.quastor.org/p/khan-academy-rewrote-backend&quot;&gt;可汗学院如何将 Python 后端重写成 Go？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可汗学院使用 Python 做了 10 年的主力语言，然而在 2020 年前后彻底转向了 Go 阵营。这篇文章介绍了它为什么以及如何将 Python 2 后端整体重构成 Go 服务。文中引用了可汗学院总结性的一系列博客，可作延伸阅读。&lt;/div&gt;
&lt;div&gt;16、&lt;a href=&quot;https://hirrolot.github.io/posts/why-static-languages-suffer-from-complexity.html#the-unfortunate-consequences-of-being-static&quot;&gt;为什么静态语言会面临复杂性的挑战？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一篇思考编程语言该如何设计的长文！作者指出现代编程语言存在“&lt;strong&gt;静态-动态双形性&lt;/strong&gt;”问题，提出理想的编程语言应该同时具有静态和动态的特性。文章分析了 &lt;strong&gt;Idris&lt;/strong&gt; 和 &lt;strong&gt;Zig&lt;/strong&gt; 两种语言的做法，并指出其局限性，最后提出应该重新思考编程语言。&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/prefix-dev/pixi&quot;&gt;pixi：Rust 开发的基于 Conda 的包管理器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个基于 Conda 生态的包管理器，支持所有操作系统，支持多种语言的 Conda 包，拥有类似 Cargo 的命令行界面，完全用 Rust 编写。支持按照项目来安装包，也支持全局安装，此行为类似于 &lt;strong&gt;pipx&lt;/strong&gt; 和 &lt;strong&gt;condax&lt;/strong&gt;。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/beeware/briefcase&quot;&gt;briefcase：将 Python 项目转换为独立的应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;支持打包成 Mac、Windows、Linux、Android 和 iPhone 的应用，以及使用了 PyScript 作客户端的静态 Web 站点。（star 2K）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/modelscope/facechain&quot;&gt;facechain：可生成数字分身的深度学习工具链&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;上周的热门项目，仅需三张照片即可生成个人的数字分身。底层使用了 Stable Diffusion 的文生图功能，训练时可选择多种风格的 LoRA 模型，也支持添加个性化的 prompt，实现变装效果。（star 3.2K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/modelscope/modelscope&quot;&gt;modelscope：将 Model-as-a-Service 概念变为现实&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;“模型即服务”（MaaS）汇集 AI 社区中最先进的机器学习模型，并简化在实际应用中使用 AI 模型的流程。它已有 700+ 模型，涵盖自然语言处理、计算机视觉、语音、多模态等。（star 3.6K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/veekaybee/viberary&quot;&gt;viberary：基于语义的书籍搜索引擎&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;不是根据体裁和书名等常规条件，而是根据提示语来搜索相关的书籍。基于&lt;a href=&quot;https://blog.reachsumit.com/posts/2023/03/two-tower-model/&quot;&gt;双塔语义检索模型&lt;/a&gt; ，使用 DuckDB 在本地训练数据，使用 Redis Search 模块作检索，通过 Flask API 和 Bootstrap 前端展示结果。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/polarsource/polar&quot;&gt;polar：帮助开源维护者获得更好的资助&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它为开源维护者搭建一个平台，可便捷地设置、运营、推广面向支持者的增值及订阅服务，帮助开发者从开源项目中获取收入。这个项目已获得 180 万美元的种子轮投资。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/plbrault/youre-the-os&quot;&gt;youre-the-os：一个游戏，让你扮演操作系统！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个很有意思的游戏！你需要扮演操作系统，管理进程、内存和 I/O 事件，不能让进程空闲太久，不然就 game over！项目依赖 Python 3.11 和 &lt;strong&gt;pipenv&lt;/strong&gt;，也可以上这个网站&lt;a href=&quot;https://plbrault.github.io/youre-the-os/&quot;&gt;在线体验&lt;/a&gt; 。（star 1K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/spandanb/learndb-py&quot;&gt;learndb-py：通过从头实现数据库来学习&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个项目从头实现一个关系型数据库，借鉴了 &lt;strong&gt;sqlite&lt;/strong&gt; 数据库。关键的特性：支持丰富的 sql、使用&lt;code&gt;lark&lt;/code&gt; 构建自定义词法分析与解析器、支持用户和代理方式连接、实现 BTree 作数据存储。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/sybrenjansen/mpire&quot;&gt;mpire：比标准库更快的多进程开发库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;比其它多进程库更快，且功能更多：结合了 &lt;code&gt;multiprocessing.Pool&lt;/code&gt; 使用写时复制的共享对象的优点、有丰富的状态管理功能、使用 tqdm 实现进度条、支持在仪表板查看进度，等等。（star 1.5K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/joxeankoret/diaphora&quot;&gt;diaphora：二进制文件的差异比对工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何比对一个软件在两个版本间的差异？比较二进制软件的差异时，涉及哪些匹配技术？这个项目号称是目前最强的软件差异比对工具！（star 3.1K）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/beartype/beartype&quot;&gt;beartype：近实时的静态类型检查工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个近实时（NRT）的纯 Python 运行时类型检查工具，将 Rust 和 C++ 的零成本对象带入动态类型的 Python 世界。它可有选择性地将 Python 的鸭子类型转换成静态类型，同时默认保留前者的优点。项目文档中称“你可以同时像鸭子一样嘎嘎叫，以及像熊一样咆哮”！（star 2K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/AzatAI/cs_books&quot;&gt;cs_books：AzatAI 推荐的计算机科学书籍&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个仓库收录了 200 多本计算机科学类书籍，仅限教育用途！&lt;/div&gt;
&lt;h3&gt;🐢播客&amp;amp;视频&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.youtube.com/watch?v=wf-BqAjZb8M&quot;&gt;超越 PEP-8 — 漂亮易懂代码的最佳实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个视频出自 PyCon 2015，介绍如何写出优雅的 Python 代码。在油管上已有 8200+ 点赞。演讲者 Raymond Hettinger 参与贡献了大家熟知的很多 Python 特性，比如 enumerate() 函数、生成器表达式、OrderedDict()、条件表达式、set 对象等。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.youtube.com/watch?v=spi0N_PNznE&quot;&gt;只需 5 个步骤，将“勉强能用”的代码变成 Pythonic&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;写出能用的代码不应该成为最终目标，这只是一个开始！这个视频使用了__getitem__、__len__、__enter__ 和 __exit__ 等魔术方法，将难以维护的代码重构得 Pythonic。作者自称这是对上一则分享的 8 分钟浓缩版。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-08-26-weekly&quot;&gt;第17期（2023-08-26）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://techcommunity.microsoft.com/t5/microsoft-365-blog/introducing-python-in-excel-the-best-of-both-worlds-for-data/ba-p/3905482&quot;&gt;Excel 终于支持 Python 了！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;本周的重磅新闻！微软将 Python 引入到 Excel 中，支持在 Excel 中使用 Python 强大的数据分析、统计建模以及数据可视化库（&lt;strong&gt;pandas、statsmodels、Matplotlib 和 seaborn&lt;/strong&gt; 等）。Guido 发推表示他参与了这个项目。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://juejin.cn/post/7269969188391600128&quot;&gt;如何使用 FastAPI 与 aiohttp 进行 SSE 响应开发？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Server-Sent Events（服务器推送事件）可以让服务端一边生成内容，一边将数据返回给客户端。文章介绍了 FastAPI 如何使用 SSE 方式返回数据，并用 &lt;strong&gt;requests 和 aiohttp&lt;/strong&gt; 来获取与展示接口数据。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://blog.dagworks.io/p/containerized-pdf-summarizer-with&quot;&gt;用 FastAPI 和 Hamilton 实现的 PDF 摘要工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章使用 FastAPI、Hamilton、Streamlit 和 ChatGPT 开发了一个 PDF 文件摘要工具，介绍了项目的设计思路、架构设计与编程实现，效果图如下：&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://juejin.cn/post/7270363281117102099&quot;&gt;放弃 Python 拥抱 Mojo？鹅厂工程师真实使用感受&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Mojo 是 &lt;strong&gt;LLVM&lt;/strong&gt; 作者发布的一门新语言，完全兼容 Python 的语法。这篇文章上手体验了 Mojo 编程，对比 Python 讨论了它的一些语法、特性以及当前存在的问题。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.modular.com/blog/how-mojo-gets-a-35-000x-speedup-over-python-part-1&quot;&gt;Mojo 如何获得比 Python 快 35000 倍的加速？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Mojo 在生成曼德博集合时比 Python 快 35000 倍，这篇文章介绍了为什么要选用曼德博算法作衡量，以及 Mojo 语言做了哪些优化来实现高性能？（附：Mojo 所属的公司 &lt;strong&gt;Modular&lt;/strong&gt; 本周宣布获得 1 亿美元融资，总融资已达到 1.3 亿美元！！）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://mathspp.com/blog/what-learning-apl-taught-me-about-python&quot;&gt;APL 语言教会我的那些 Python 知识&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;APL 是在 1960 年代开发的一种高度符号化的编程语言，作者在学习这门语言后，反而加深了对 Python 编程的理解。作者受到触动的只是简单的一行代码，但它包含了内置函数、布尔值、数据驱动、列表推导式等 Python 优雅编程的要素。（附：&lt;a href=&quot;https://pythoncat.top/posts/2021-12-13-languages&quot;&gt;从这 27 门编程语言中，也可以加深对 Python 的理解&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://www.romaglushko.com/blog/jupyter-kernel-architecture/&quot;&gt;深度解析 Jupyter 的内核架构&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Jupyter Notebooks 非常强大，它是如何做到的呢？这篇文章分析了 Jupyter 架构的内核以及一些有趣的实现细节，包括代码的执行工作流、代码解析执行、自动补全、代码检查、调试、虚拟输入、客户端和网关等。作者预告后续还会解析 &lt;strong&gt;Jupyter Server、JupyterLab、JupyterHub、Jupyter Enterprise Gateway&lt;/strong&gt; 等项目。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://engineering.fb.com/2023/08/07/developer-tools/fixit-2-linter-meta/&quot;&gt;Fixit 2：Meta 的下一代自动修复 linter&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Meta 开源的 linter 工具 &lt;a href=&quot;https://github.com/Instagram/Fixit&quot;&gt;Fixit&lt;/a&gt; 发布了2.0 版本，它支持自动修复问题，支持用户自定义 lint 规则。这篇文章介绍了 Meta 在使用 Flake8 时遇到的问题、为什么要开发 FIXit，以及为什么要重构出 Fixit 2 这个新版本？&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://realpython.com/python-code-image-generator/&quot;&gt;使用 Python 构建代码图像生成器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇超级详细的全栈实战教程，涉及技术有 &lt;strong&gt;Flask、Jinja、Playwright、Pygments 和 Javascript&lt;/strong&gt;，实现的是一个代码-图片生成器，也就是可以给代码片段添加样式并生成美观的图片。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://coderslegacy.com/apipkg-tutorial-enhanced-lazy-loading-in-python/&quot;&gt;apipkg 教程：Python 中的增强延迟加载&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;周刊第 16 期分享了一篇 importlib 实现延迟加载的文章，这篇文章中的 apipkg 也能实现同样的效果，但用法稍有不同，可以对照学习。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://www.bitecode.dev/p/asyncio-twisted-tornado-gevent-walk&quot;&gt;当 asyncio、twisted、tornado 和 gevent 一起走进酒吧…&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;当谈到 Python 并发时，就离不开标题的这些库。文章介绍和对比了这几个库，讨论了它们的设计与使用。那么，该使用哪个异步库呢？&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://snarky.ca/state-of-standardized-lock-files-for-python-august-2023/&quot;&gt;Python 标准化锁定文件的现状&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者想给 Python 提供一种标准化的依赖包锁定文件，曾在 2021 年发起了 &lt;a href=&quot;https://peps.python.org/pep-0665/&quot;&gt;PEP-665&lt;/a&gt; ，但因为缺少对 sdist 的支持而被拒绝了。作者现在做了一些概念验证的事情，计划有 5 步，目前进展到第 3 步。（附：本月新发起的 &lt;a href=&quot;https://peps.python.org/pep-0725/&quot;&gt;PEP-725 – 在 pyproject.toml 中指定外部依赖项&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://joaodlf.com/python-just-write-sql&quot;&gt;Python：只需编写 SQL&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者看到 Go 编程时不喜欢用 ORM，因此也想尝试不用 ORM 而在 Python 中直接写 SQL。这种回归传统做法的主要问题是会混淆数据库操作与业务逻辑，但并不是不可行。&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://stackabuse.com/incompatible-type-comparisons-in-python/&quot;&gt;Python 中如何比较不兼容的类型？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇很详细的基础教程，探讨了&lt;code&gt;TypeError&lt;/code&gt; 的含义、出现的原因以及解决方法。文章非常之细致，介绍了 20 多种容易出错的场景，有些是初学者问题，但也有些是老手也易忽视的编程细节。&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;https://florian-dahlitz.de/articles/create-your-own-diff-tool-using-python&quot;&gt;使用 Python 开发一个文件比较工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;有很多版本管理和差异比较工具，但是能否用 Python 开发一个简单的工具实现呢？文章使用 &lt;strong&gt;difflib、argparse 和 HtmlDiff&lt;/strong&gt; 分别开发了命令行工具和 HTML 网页两个版本的文件比较工具。&lt;/div&gt;
&lt;div&gt;16、&lt;a href=&quot;https://eli.thegreenplace.net/2023/my-favorite-prime-number-generator/&quot;&gt;我最喜欢的素数生成函数&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;埃拉托斯特尼筛法是一种生成素数的算法，作者提供了一个 Python 实现，但是代码的性能和内存占用是主要的问题，因此作者做了一些优化改进，最后给出了一个有详细注释的优化版本。&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/facebookresearch/codellama&quot;&gt;codellama：Meta 最新开源的代码生成模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;本周最火的开源项目！&lt;strong&gt;Code Llama&lt;/strong&gt; 基于 &lt;strong&gt;Llama 2&lt;/strong&gt;，可免费商用，可预见不久的将来会出现大量的编程工具！目前支持的语言包括 Python、C++、Java、PHP、Typescript/Javascript、C# 和 Bash。值得一提的是，它包含一个“&lt;strong&gt;Code Llama – Python&lt;/strong&gt;”专用版本，基于 100B  token 微调！（star 4K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/facebookresearch/seamless_communication&quot;&gt;seamless_communication：最先进的语音和文本翻译的基础模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;SeamlessM4T&lt;/strong&gt; 也是 Meta 开源的项目，旨在提供高质量的翻译，让不同语言的人通过语音和文本轻松交流。支持 101 种语言的语音输入、96 种语言的文本输入与输出、35 种语言的语音输出。（star 3.7K）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/microsoft/torchscale&quot;&gt;Torchscale：(M)LLM 的基础架构&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;微软开源的一个 PyTorch 库，可让开发者高效地扩展 &lt;strong&gt;Transformers&lt;/strong&gt;，聚焦于提升建模的能力与通用性，同时提升训练的稳定性与效率。（star 2.4K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/zhanymkanov/fastapi-best-practices&quot;&gt;fastapi-best-practices：FastAPI 的最佳实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个 Github 项目是一篇集合了 20 多项 FastAPI 最佳实践的长文，包括项目结构、数据校验、解耦与重用依赖、遵循 REST、文档、linter 等等话题。（star 4.5K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/sumerc/yappi&quot;&gt;yappi：又一个 Python Profiler，支持多线程、asyncio 和 gevent&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;yappi 是 PyCharm 默认的性能分析器之一，它是用 C 编写的，支持多线程、asyncio 和 gevent，可以显示挂机时间与实际 CPU 时间。（star 1.2K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/fighting41love/funNLP&quot;&gt;funNLP：几乎最全的中文 NLP 资源库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个非常丰富的资料库，包含 NLP/人工智能的大量内容。（star 55.7K）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/chrieke/prettymapp&quot;&gt;prettymapp：在 Web 应用中创建精美的地图&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个 Web 应用和 Python 包，可从 &lt;strong&gt;OpenStreetMap&lt;/strong&gt; 获取数据生成漂亮的地图作品。它基于另一个有 10K star 的项目 &lt;a href=&quot;https://github.com/marceloprates/prettymaps&quot;&gt;prettymaps&lt;/a&gt; ，主要简化了配置、降低代码复杂性、并使用 streamlit 开发了 Web 端应用。（star 1.7K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/eliben/pycparser&quot;&gt;pycparser：纯 Python 实现的完整 C99 解析器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个用 Python 写的 C 语言解析器，可轻松集成到需要解析 C 源代码的程序中。它最主要的用途是在 &lt;strong&gt;cffi&lt;/strong&gt; 库中，用于解析 C 函数和类型的声明。（star 3K）&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/StanGirard/quivr&quot;&gt;quivr：生成式 AI 打造你的第二大脑&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;利用生成式 AI 来存储和检索非结构化的信息，可以理解成支持人工智能的  Obsidian。可以处理各种形式的文件如文本、图片、代码、音频和视频等，依赖于 ChatGPT、Docker、Supabase，只支持操作系统是 Ubuntu 22+。（star 21.7K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/taojy123/KeymouseGo&quot;&gt;KeymouseGo: 类似按键精灵的鼠标键盘录制和自动化操作&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个中文项目。记录用户的鼠标键盘操作，通过触发按钮自动执行之前记录的操作，可设定执行的次数，可以理解为精简绿色版的&lt;strong&gt;按键精灵&lt;/strong&gt;。支持 Windows、Linux 和 Mac 系统。（star 4.3K）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/CodeOptimist/ahkunwrapped&quot;&gt;ahkunwrapped：集成 AutoHotkey，用 Python 执行自动化&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;AutoHotkey&lt;/strong&gt; 是一种自动化脚本语言和工具，用于在 Windows 上创建快捷键、宏和自动化任务，例如模拟按键和鼠标操作、窗口管理、剪贴板操作、自动化表单填写等。这个项目覆盖了 AutoHotkey API，使用 Python 来桥接，扩展 AutoHotkey 的能力。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/ashishpatel26/500-AI-Machine-learning-Deep-learning-Computer-vision-NLP-Projects-with-code&quot;&gt;100+ AI/机器学习/深度学习/计算机视觉/NLP 项目与代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个仓库收录了很多学习资源，其中很多也是一些聚合类的项目，也就是说实际包含的项目与资料有上万之多。（star 13.2K）&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://github.com/adbar/trafilatura&quot;&gt;trafilatura：一个采集 Web 文本的工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个 Python 包和命令行工具，可以处理 Web 的文本信息，并转化成各种常用格式输出。包含爬虫功能、HTML 解析、网页内容萃取等等。（star 1.9K）&lt;/div&gt;
&lt;h3&gt;🐢播客&amp;amp;视频&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://m.youtube.com/playlist?list=PLs4CJRBY5F1KwxIxbTmhN9jX4hBtE-OKJ&quot;&gt;2023 年 PyCon 澳大利亚的 84 个视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;澳大利亚今年 PyCon 上的演讲视频。目前已发布 84 个视频。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.youtube.com/playlist?list=PLnOlTVPC-yFwhpiyjsC0V_98pqRbtwNgh&quot;&gt;2023 年 Pycon 以色列的 23 个视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;以色列今年 PyCon 上的演讲视频。目前已发布 23 个视频。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.youtube.com/playlist?list=PL1PbeFStIOoOd01KhBeba-byU5E5dJ716&quot;&gt;2023 年 SciPy Talk 的 44 个视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;SciPy Talk 是科学计算领域的年度会议，通常涵盖数据分析、机器学习、人工智能、科学可视化等话题。目前已发布 44 个视频。&lt;/div&gt;
&lt;h3&gt;🥂讨论&amp;amp;问题&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.reddit.com/r/Python/comments/15z1amc/how_to_build_the_front_end_of_a_web_app_if_you/&quot;&gt;如果只懂 Python，如何构建 Web 程序的前端？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;独自一人开发，想要快速实现全栈的 SaaS 应用，支持用户身份验证、订阅、付款等业务功能，前端该如何选择呢？Reddit 上的这个帖子，或许能给你提供一些思路/方法。&lt;/div&gt;
&lt;div&gt;2、V2EX 上三则关于 Python 后端的热门讨论&lt;/div&gt;
&lt;div&gt;近期在 Python 节点下最热闹的三篇帖子：&lt;a href=&quot;https://www.v2ex.com/t/962899&quot;&gt;Python 后端该如何提升自己呢？&lt;/a&gt; 、&lt;a href=&quot;https://www.v2ex.com/t/965956&quot;&gt;深夜睡不着，思考为什么国内 Python Web 后端太少&lt;/a&gt; 、&lt;a href=&quot;https://www.v2ex.com/t/966460&quot;&gt;Python 做后端，相对于 Java 或者 go 来说，到底差在哪？&lt;/a&gt; 从就业的角度来看，Python 后端在国内确实偏少，不仅后端，其它领域也有一种“热度退潮”的感觉（除了 AI 相关）。Python 潮流周刊的创刊想法之一就是去欧美盗火，为国内 Python 社区注入活力。愿论坛里将来能少一些沮丧性的、要抛弃 xx 另附高枝的情绪吧。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-09-02-weekly&quot;&gt;第18期（2023-09-02）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://testdriven.io/guides/flask-deep-dive&quot;&gt;一份深入探索 Flask 的指南&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;由系列文章组成的 Flask 学习指南，深入了解 Flask 的内部结构、核心特性和功能，涵盖主题有程序和请求上下文、Werkzeug、会话、安全（防CSRF）、测试、2.0 版本的异步等。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://artifex.com/blog/table-recognition-extraction-from-pdfs-pymupdf-python&quot;&gt;使用 PyMuPDF 识别与提取表格&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;识别和处理 PDF 文件中的表格是件困难的事，PyMuPDF 最新版本 1.23.0 提供了从 PDF 中提取表格的功能！可以将提取内容交给 pandas 处理，可以导出 Excel 和 CSV 格式的文件。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://codeconfessions.substack.com/p/understanding-immortal-objects-in&quot;&gt;深入介绍 Python 3.12 中的永生对象&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;周刊&lt;a href=&quot;https://pythoncat.top/posts/2023-08-19-weekly&quot;&gt;第 16 期&lt;/a&gt;分享了 Instagram 在 Python 3.12 引入永生对象的故事，而这里分享的文章深入剖析解释器源码，为我们回答了以下问题：为什么要引入永生对象？它对性能有什么影响？它是如何实现的（如 None 对象和小整数），如何做到兼容旧版本的接口的？&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://mathspp.com/blog/pydonts/usages-of-underscore&quot;&gt;Python 中下划线的十种用法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;你知道 Python 中的下划线有哪些用法么？这篇文章介绍了：REPL 中的用法、作变量名的前缀和后缀时的四种用法、作为赋值“接收器”的两种用法、新 match-case 语法中的用处、用作频繁调用的函数别名、大额数字中增加可读性。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://so1n.me/2023/08/29/python_asyncio_lib_network/&quot;&gt;Python Asyncio 之网络编程方法详解&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Asyncio 不仅提供了简单的&lt;code&gt;Socket&lt;/code&gt;接口，还基于它提供了&lt;code&gt;Protocol&lt;/code&gt;&amp;amp;&lt;code&gt;Transport&lt;/code&gt;接口以及更高级的&lt;code&gt;Stream&lt;/code&gt;接口，大大的减轻了开发者进行网络编程的心理负担。文章主要介绍了这几个接口的简单使用以及对应的原理分析。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://dev.to/codemaker2015/streamlit-cheatsheet-for-beginners-706&quot;&gt;给初学者的 Streamlit 学习指南&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Streamlit 是一个用于创建和部署 Web 程序的框架，广泛用于机器学习和数据科学领域。这篇教程介绍了它的安装以及常用组件的使用。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://ezzeddin.hashnode.dev/fastapi-tailwind-sqlalchemy&quot;&gt;如何在 FastAPI 应用中使用 Tailwind CSS 和 SQLAlchemy&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;FastAPI 是一个轻量级框架，通常需要集成其它组件搭配使用。这篇文章介绍了如何将 FastAPI 与 Jinja2 模板引擎、Tailwind CSS 以及 &lt;strong&gt;SQLAlchemy&lt;/strong&gt; 结合，创建出一个好用的开发脚手架。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://www.bitecode.dev/p/how-not-to-sort-in-python&quot;&gt;Python 如何不作排序但保持数据有序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了 Python 堆排序/优先队列、二分查找、有序容器的相关使用，它们有更好的时间复杂度或适用场景，是比暴力搜索和暴力排序更值得采用的解决方案。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://delighto.hashnode.dev/send-verification-email-django&quot;&gt;用 Django 发送带有验证链接的电子邮件&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;我们经常会在注册一些账号后收到一封验证邮件，只有在链接的有效期内点击它才能完成账号注册。这篇教程介绍了如何用 Django 来实现这个功能，这是一个简短而完整的练手项目。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://medium.com/@i18nsolutionspy/exploring-global-diversity-pyetho-python-library-for-language-and-country-insights-4a688958ea83&quot;&gt;探索全球多样性：Pyetho — 用于了解国家及其语言的 Python 库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了&lt;a href=&quot;https://github.com/i18nsolutionspy/Pyetho&quot;&gt;Pyetho&lt;/a&gt; 这个库的基本使用，它主要包含了全球国家及其语言的相关信息，采用 ISO 标准。收录有 195 个国家，我查询了下，中国有 285 种语言。除了国家和语言基本信息外，其它功能包括：查询某种语言的使用人数、查询某种语言在哪些国家使用、查询某种语言的谱系家族、查询所有的语言家族，等等。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://realpython.com/polars-python/&quot;&gt;Polars：快如闪电的 DataFrame 库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Polars 是数据分析领域的新秀，底层是用 Rust 写的，拥有超高性能。这是一篇详细的教程，内容包括：它的 DataFrame、表达式和上下文、惰性 API（LazyFrame）、与外部数据源集成、与 Numpy 和 pandas 的集成，等等。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://dev.to/khaledhosseini/data-structures-and-algorithms-for-multi-language-programmers-c-swift-python-java-c-javascript-alp&quot;&gt;深入学习数据结构与算法：C++、Swift、Python、Java、C#、JavaScript&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;超长文预警！文章探索了不同编程语言中常见数据结构的实现，使用简洁的动画和图表直观介绍了相关的知识。主要涉及线性数据结构，如数组、动态数组、链表、循环链表、栈、队列、哈希表、集合，等等。数据结构当然离不开算法和时间复杂度，文中也有对应介绍。&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/fastapi-users/fastapi-users&quot;&gt;fastapi-users：开箱即用的 FastAPI 用户管理库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;为 FastAPI 添加用户注册与身份验证模块，主要特性有：可扩展的用户模型、注册/登录/重置密码/邮箱验证、OAuth2 登录流程、可定制的数据库后端、支持多种身份验证，等等。（star 3.3K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/eliasdorneles/upiano&quot;&gt;upiano：命令行里的钢琴&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在命令行里弹钢琴是种什么体验？！安装这个库后，你就可以用鼠标和键盘来弹钢琴了。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/daijro/hrequests&quot;&gt;hrequests：requests 库的替代品&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个比 requests 库更简单、可配置、功能丰富的库，使用 gevent 实现高性能并发，支持 HTTP/2，JSON 序列化比标准库快 10 倍，代码使用类型提示，100% 线程安全。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/zhihaiLLM/wisdomInterrogatory&quot;&gt;wisdomInterrogatory：智海-录问法律大模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;由浙江大学、阿里巴巴达摩院以及华院计算共同设计研发的法律大模型，以“普法共享和司法效能提升”为目标。模型基座是 Baichuan-7B，预训练的数据包括法律文书、司法案例以及法律问答数据，共 40 G。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/edarchimbaud/awesome-systematic-trading&quot;&gt;awesome-systematic-trading：一个精选的系统化交易列表&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;系统化交易/量化交易是依据规则和算法进行自动化交易的策略，这个仓库收录了一系列资源：库、软件、策略、书籍、博客、论文、视频，等等。（star 1.1K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/QwenLM/Qwen-VL&quot;&gt;Qwen-VL：阿里通义千问-VL 模型的官方库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Qwen-VL&lt;/strong&gt; 是阿里云研发的大规模视觉语言模型，可以以图像、文本、检测框作为输入，并以文本和检测框作为输出。支持多语言、多图交错对话。评测结果显示，Qwen-VL 在多个 VL 任务上相比目前 SOTA 的 Generalist Models 都有明显优势。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/h2oai/h2ogpt&quot;&gt;h2ogpt：私人文档+图像的问答&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;查询和总结你的文档，或者与本地私有的 GPT LLM 聊天。支持大部分文档，支持 LLaMa2、Falcon、Vicuna、AutoGPTQ、LORA 等，支持 Linux、Docker、MAC 和 Windows。（star 7.2K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/smallcloudai/refact&quot;&gt;refact：开源编码助手，支持自动补全、代码重构、代码分析&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Copilot 的开源替代方案，可自托管或使用云服务。支持 starcoder、starchat、llama2、wizardlm 等开源模型，支持代码补全、重构、解释、分析、优化与修复错误等功能。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/langgenius/dify&quot;&gt;dify：创建自己的 AI 应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;dify 是 Do It For You 的简写，是一个易用的 LLMOps 平台，支持快速创建出自己的 AI 应用。核心能力：通过 Langchain 支持主流的大语言模型（包括讯飞星火、文心一言、通义千问）、可视化编排 Prompt、支持添加数据集、支持插件、支持数据标注与改进。（star 8K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/causalens/dara&quot;&gt;dara：轻松创建交互式 Web 应用程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个低代码开发框架，与 Plotly Dash、Streamlit 和 Shiny 相似，支持快速创建仪表板应用。后端使用 FastAPI，前端是一个基于 React  的 UI。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-09-09-weekly&quot;&gt;第19期（2023-09-09）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.modular.com/blog/mojo-its-finally-here&quot;&gt;Mojo🔥 终于提供下载了！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Mojo 语言是今年发布的“高性能的 Pyhton++”，周刊第 17 期刚分享过它获得了 1 亿美元融资，这周它就发布了 Linux 版本的安装包。除了编译器功能，它还提供了一些 IDE 工具（终端 shell、VS Code 插件、Jupyter 内核），暂不支持调试，暂无 Mac 和 Windows 版本。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.cnblogs.com/apocelipes/p/17679741.html&quot;&gt;我们能从 PEP-703 中学到什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PEP-703 是 no-gil 项目的提案，我们曾多次介绍过。作者讨论了该 PEP 中的一些话题，例如尽量少依赖原子操作的引用计数、延迟的引用计数、gc 不再会分代、对象锁等，从中能看出 Python 社区在性能和兼容性上的权衡。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://vgel.me/posts/c500/&quot;&gt;用 500 行 Python 代码写一个 C 语言编译器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;实现一个 C 语言编译器需要多少行 Python 代码？文章介绍了编译器的架构、代码解析与生成流程，尝试用 500 行代码实现了一个简易的 C 编译器。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://www.blog.pythonlibrary.org/2023/08/30/an-intro-to-protocol-buffers-with-python&quot;&gt;简单介绍如何用 Python 作协议缓冲区编程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;协议缓冲区（&lt;strong&gt;Protocol buffer&lt;/strong&gt;）是一种与语言无关的数据序列化格式，类似于 Python 的 pickle 格式。文章介绍了如何用 Python 创建与编译协议缓冲区文件，并与支持该协议的其它语言进行通信。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://dev.to/oscarleo/how-to-create-a-beautiful-polar-histogram-with-python-and-matplotlib-400l&quot;&gt;用 Python 和 matplotlib 创建漂亮的极坐标直方图&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;极坐标直方图（&lt;strong&gt;Polar Histogram&lt;/strong&gt;）是一种用于可视化和分析数据分布的图表形式，它将数据划分为多个扇区，每个扇区的长度或面积表示该角度范围内数据的频率或数量。文章介绍了如何 Python 绘制极坐标直方图。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://codeconfessions.substack.com/p/bloom-filters-and-beyond&quot;&gt;布隆过滤器图解与 Python 实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;布隆过滤器（&lt;strong&gt;Bloom Filter&lt;/strong&gt;）是一种数据结构，可用于快速判断一个元素是否存在于一个集合中，场景的使用场景：去重、缓存与快速查询、防止缓存穿透、过滤垃圾邮件等。文章介绍了它是什么、如何操作、Python 实现、如何调整布隆过滤器等。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://favtutor.com/blogs/heap-in-python&quot;&gt;Python 中的堆数据结构：最小和最大堆实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;堆（&lt;strong&gt;Heap&lt;/strong&gt;）是一种重要的数据结构，常用于快速访问最值、堆排序、调度与分配任务、图算法、数据压缩与编码等。文章介绍了它的基本概念、如何用 Python 实现最大堆和最小堆、它们的区别。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://developers.redhat.com/articles/2023/09/05/beginners-guide-python-containers&quot;&gt;Python 容器化部署教程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;容器是一种轻量级的虚拟化技术，可实现 Python 程序的高效打包与部署。Red Hat 的这篇教程介绍了如何用 &lt;strong&gt;Podman&lt;/strong&gt; 来构建、运行和管理 Python 容器。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://robamu.github.io/posts/packaging-python-in-2023/&quot;&gt;2023 年 Python 包管理的实践指南&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这篇文章梳理了当前 Python 包管理时比较适用的一些最佳实践，例如使用 pyproject.toml、使用 setuptools 作分发和构建工具、用 Sphinx + reStructuredText + sphinx-rtd-theme 编写文档、用 CHANGELOG 列出版本更改、使用 black 和 flake8 等。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://juejin.cn/post/7274626136328536116&quot;&gt;记一次 Python 应用内存泄漏问题定位&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者使用 Airflow 作为任务调度器，上线后每隔一段时间就出现 Scheduler 内存 OOM 问题，这篇文章详细记录了问题定位分析的过程。介绍了三个工具：&lt;strong&gt;objgraph、pympler、tracemalloc&lt;/strong&gt;。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://adamj.eu/tech/2023/09/07/introducing-flake8-logging/&quot;&gt;介绍 flake8-logging&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者认为标准库&lt;code&gt;logging&lt;/code&gt; 比较难用，加上在程序错误时经常会缺少必要的日志，因此开发了 flake8-logging 插件。它有 12 条规则，这篇文章介绍了 3 条：使用 logging.getLogger() 实例化记录器、在异常处理时使用 exception()、避免预先格式化日志信息。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://segmentfault.com/a/1190000044189692&quot;&gt;Falcon 180B 正式在 Hugging Face Hub 上发布&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Falcon 作为当前最大的开源大模型，有 180B 参数并且是在在 3.5 万亿 token 的 TII RefinedWeb 数据集上进行训练，是目前开源模型里最长的单波段预训练。文章介绍了它的优势以及入门使用。&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/lancopku/PKUSeg-python&quot;&gt;pkuseg-python：多领域中文分词工具，比 jieba 准确性更高&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;不同于其它通用中文分词工具，它支持多领域分词、有更高的分词准确率、支持用户自训练模型、支持词性标注。准确性超过 &lt;strong&gt;jieba、THULAC&lt;/strong&gt; 两个中文分词工具。（star 6.2K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/mimseyedi/pysentation&quot;&gt;pysentation：在 CLI 里显示演示文稿&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在命令行终端里制作和展示 presentation，支持标题、颜色、主题、放大、解释、快捷键等功能。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/eschluntz/compress&quot;&gt;compress：基于个人语料库的快捷输入工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;导入个人的语料库后，可以用缩写方式输入长串的内容。使用了 &lt;strong&gt;Autokey&lt;/strong&gt; 来实现 Linux 的键盘快捷键。（star 1.3K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/cofactoryai/textbase&quot;&gt;textbase：用于构建 AI 聊天机器人的简单框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个使用 NLP 和 ML 构建聊天机器人的框架，轻松开发和部署 Web 应用。计划集成短信、本地集成大语言模型（Claude、Llama）。（star 1.2K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/lemon24/reader&quot;&gt;reader：Python 开发的 feed 阅读器库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;功能丰富的 feed 阅读器，支持检索、存储和管理 Atom、RSS 和 JSON 源，支持标记文章为已读或重要、支持过滤 feed 和文章、支持全文搜索、支持统计用户活动、支持插件。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/baichuan-inc/Baichuan2&quot;&gt;Baichuan2：百川 53B 大模型在线对话平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;百川智能推出的新一代开源大语言模型，采用 2.6 万亿 Tokens 的高质量语料训练。在通用、法律、医疗、数学、代码和多语言翻译六个领域的中英文和多语言权威数据集上对模型进行了广泛测试。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/hynek/svcs/&quot;&gt;svcs：灵活的 Python 服务定位器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 的依赖注入容器，提供了一个注册类型/接口工厂的机制，通过自动清理和运行状况检查强制获取这些类型的实例。使用依赖注入和服务定位来实现控制反转，消除大量重复的样板代码。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/binary-husky/gpt_academic&quot;&gt;gpt_academic: 为 ChatGPT/GLM 提供实用化交互界面&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;GPT 学术优化，特别优化论文阅读/润色/写作体验，模块化设计，支持自定义快捷按钮&amp;amp;函数插件，支持 Python 和 C++ 等项目剖析&amp;amp;自译解功能，PDF/LaTex 论文翻译&amp;amp;总结功能，支持并行问询多种 LLM 模型，支持 chatglm2 等本地模型。兼容文心一言, moss, llama2, rwkv, claude2, 通义千问, 书生, 讯飞星火等。（star 41K）&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-09-16-weekly&quot;&gt;第20期（2023-09-16）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://superfastpython.com/benchmark-python-code/&quot;&gt;三种对 Python 作基准测试的方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了使用标准库对 Python 作基准测试的几种方法：time、timeit、cProfile 与 profile，详细介绍了几个工具的使用方法及测试数据的解读。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://andrich.me/2023/08/switching-to-hatch/&quot;&gt;舍弃 Poetry 和 PDM，切换成 Hatch&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者“移情别恋”了 Hatch，开始在项目中使用它。文章介绍了他喜欢 Hatch 的一些小亮点：环境隔离、命令脚本、可替代 &lt;strong&gt;Tox&lt;/strong&gt;、可选的依赖项等。（附：&lt;a href=&quot;https://pythoncat.top/posts/2020-01-06-tox&quot;&gt;Python 任务自动化工具 tox 教程&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://hitchdev.com/strictyaml/why-not/toml/&quot;&gt;TOML 文件格式有什么问题？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;TOML 是“改进的” INI 文件，是 Python 推荐的配置文件格式。文章提到，连 TOML 的作者也认为它是一种糟糕的格式！文章指出了它的问题：非常冗长、层次结构很难仅从语法推断、像 YAML 一样过于复杂、具有语法类型。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://joseprupi.github.io/misc/2023/08/19/playing_with_genetic_algorithms_in_python.html&quot;&gt;用 Python 玩转遗传算法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;遗传算法（Genetic Algorithm）是一种受生物进化理论启发的优化算法，用于解决复杂的搜索和优化问题。文章用 Python 演示了这种算法的使用例子。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://codebeez.nl/blogs/type-hinting-in-modern-python-the-protocol-class/&quot;&gt;现代 Python 的类型提示：Protocal 类&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Protocol 类是 Python 3.8 版本中引入的，用于指定一个类应该实现哪些方法，与 Java 的 Interface 相似。在保持 Python 动态类型用法的情况，使用 Protocal 可以获得部分静态类型检查的效果。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://dev.to/caipi/tornado-de-xie-cheng-diao-du-yuan-li-2h34&quot;&gt;tornado 的协程调度原理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Tornado 是一个高性能的 Web 框架，文章解读它的源码，主要想搞清楚：yield 暂存的状态到哪去了、重新恢复执行的“合适的时机”到底是什么、具体是怎么恢复执行的？&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://sethmlarson.dev/security-developer-in-residence-weekly-report-9&quot;&gt;可视化 CPython 发布过程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章基于 PEP-101 梳理了 CPython 的发布过程，绘制出了详细的流程图并给出关键步骤的解释。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://yasoob.me/posts/how-to-use-vision-framework-via-pyobjc/&quot;&gt;如何用 PyObjC 与 Apple Vision 框架作文本识别&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Apple 的 Vision 框架提供了一系列预训练的模型和 API，可快速在应用中添加图像分析和计算机视觉功能。PyObjC 可实现 Python 与 Objective-C 的交互。文章将它们结合，开发了一个文本处理项目。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://krishnanchandra.com/posts/regex-catastrophic-backtracking/&quot;&gt;调试 Python 中正则表达式的灾难性回溯&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者使用 py-spy 定位一个 CPU 100% 占用问题，找出了罪魁祸首的正则表达式，进而探讨灾难性回溯及其解决方法，并给出了优化性能的建议写法。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://www.photondesigner.com/articles/database-search-django-htmx&quot;&gt;使用 Django 和 HTMX 开发一个数据库搜索项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇详细的 Django 项目教程，实现一个全栈的项目。文中有作者的教程视频。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://python-bloggers.com/2023/09/asynchronous-sqlalchemy-and-multiple-databases/&quot;&gt;异步 SqlAlchemy 和多数据库管理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;利用 asyncio 和 SqlAlchemy 库，文章探讨了如何有效地连接和管理多个数据库，获得可扩展且具有弹性的架构。文章介绍了两种实现方法。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://juejin.cn/post/7278246015193464847&quot;&gt;Python Fire：自动生成命令行接口&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Fire 是谷歌开源的一个用于生成 CLI 的库，Github 25K star。这篇文章介绍了它的一般命令、组合命令、链式命令、复杂命令等用法。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://www.jjinux.com/2022/08/python-my-favorite-python-tricks-for.html&quot;&gt;我最爱的解 LeetCode 问题的 Python 技巧&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了 Python 中的一些小技巧，从初级到高级，多数与数据结构相关，在解 LeetCode 问题时很有用。&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://stackabuse.com/why-does-python-code-run-faster-in-a-function/&quot;&gt;为什么 Python 代码在函数中运行得更快？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 代码分别在函数和全局模块中运行，哪个更快呢？为什么是在函数中更快呢？Python 代码执行的工作原理是什么？如何测试与优化 Python 函数的性能？&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/pypa/hatch&quot;&gt;hatch：时髦的可扩展的 Python 项目管理库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个 Python 项目管理工具，有标准化构建系统、强大的环境管理、轻松发布到 PyPI、版本管理、响应式 CLI、比 pipenv 和 poetry 同类工具快约 2-3 倍。（star 4.4K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/keephq/keep&quot;&gt;keep：开源的告警管理和自动化执行平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可以将所有告警整合到一个管理平台中，并编排工作流以自动化执行端到端的流程。支持对接多种数据采集平台、数据库、办公软件等，可视化编排告警处理工作流。（star 2.2K）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://py-code.org/stats&quot;&gt;PyPI Data 网站：查看 PyPI 的各项数据&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个神奇的网站！包含 PyPI 的各类统计数据、曲线图和饼图，例如文件总数、总大小、一些功能特性的流行趋势等等。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/crdoconnor/strictyaml&quot;&gt;strictyaml：类型安全的 YAML 解析和校验库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用于解析 YAML 的受限子集，拒绝解析丑陋的、难以阅读和不安全的 YAML 特性，有严格的标记验证和直接的类型转换，可替代 pyyaml、ruamel.yaml 和 poyo，有清晰可读的异常信息。（star 1.3K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/facefusion/facefusion&quot;&gt;facefusion：更先进的换脸工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;最新开源的一个人像换脸库，star 涨得飞快！（star 6.9K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/deshaw/pyflyby&quot;&gt;pyflyby：一套 Python 的生产力工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;包含一系列的小工具，功能包含用于命令行的 py、用于 IPython 的自动导入、添加缺失的 import、删除不用的 import、格式化 import、打印一组文件的 import、重命名导入，等等。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/yoheinakajima/instagraph&quot;&gt;instagraph：将文本内容或 URL 转换为可视化的知识图谱&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可以提取复杂信息中的实体，生成它们的关系图谱。使用了 GPT-3.5，以及 Flask 来生成色彩友好的图例；响应式设计，可在任何设备上使用。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/Textualize/textual-web&quot;&gt;textual-web：在浏览器中运行 TUI 和终端&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;将 &lt;strong&gt;Textual&lt;/strong&gt; 开发的 app 发布到网页上，也可以在浏览器中使用命令行终端。是个很有意思的项目。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/fulcrum-so/ziggy-pydust&quot;&gt;ziggy-pydust：用 Zig 语言构建 Python 扩展&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个开发框架，可打包用 Zig 编写的 Python 扩展模块，还包含一个 Pytest 插件可发现与运行 Zig 测试。集成了 Poetry，方便构建 wheel 和发布。支持缓冲区协议，可以实现零拷贝提升 Numpy 计算。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/codefuse-ai/MFTCoder&quot;&gt;MFTCoder：多任务微调代码大模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个开源的多任务代码大语言模型项目，包含代码大模型的模型、数据、训练等。在 HumanEval Benchmarks 的 Python Pass@1 取得了 &lt;strong&gt;74.4%&lt;/strong&gt; 的开源 SOTA 成绩，超过 GPT-4。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-09-23-weekly&quot;&gt;第21期（2023-09-23）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pythonspeed.com/articles/optimizing-dithering/&quot;&gt;在单核情况下加快 Python 代码速度&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章使用弗洛伊德-斯坦伯格抖动算法为例，使用各种技巧来提升代码性能，实现将耗时从 2339 微秒逐步降低到 554 微秒。涉及的一些概念：指令级并行 （ILP）、分支预测、单指令多数据（SIMD）、内存层次结构等。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.blog.pythonlibrary.org/2023/09/20/learning-about-code-metrics-in-python-with-radon/&quot;&gt;使用 Radon 作 Python 的代码度量&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇基础的入门教程，了解如何用 Radon 来衡量 Python 的代码复杂度，即计算圈复杂度等指标，介绍了相关命令的使用。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://lwn.net/Articles/942767/&quot;&gt;Python（大部分）由语法糖组成&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Brett Cannon 写了一系列关于“语法糖”的博客，解析了 80 多个语法糖特性。文章基于他在 PyCon 的演讲及博客，介绍了其中的部分内容。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://oscarbenjamin.github.io/blog/czi/post1.html&quot;&gt;迎接新的 SymPy&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;SymPy 是一个用于符号计算（symbolic computation）的库，可以处理代数、微积分、离散数学等领域的问题。这是一个系列文章，介绍它将迎来的重大变化。文章描述了 SymPy 当前存在的速度问题、为加速它而作的工作、将来的提速计划。（附：&lt;a href=&quot;https://oscarbenjamin.github.io/blog/czi/post2.html&quot;&gt;系列第二篇：SymPy 多项式计算&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.piglei.com/articles/use-import-linter-to-lint-proj-arch/&quot;&gt;使用 import-linter 让你的 Python 项目架构更整洁&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在依赖关系治理方面，&lt;a href=&quot;https://github.com/seddonym/import-linter&quot;&gt;import-linter&lt;/a&gt; 是一个非常有用的工具。它通过提供各种类型的“契约”，让我们得以将项目内隐式的复杂依赖关系，通过配置文件显式的表达出来。文章介绍了它的入门使用，以及 6 种修复依赖关系的技巧。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://codeconfessions.substack.com/p/cpython-bloom-filter-usage&quot;&gt;CPython 如何用布隆过滤器作字符串处理？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;CPython 在处理字符串时使用了布隆过滤器，比如 splitlines()、strip() 两个函数，文章介绍了它们的实现原理。文章还介绍了典型布隆过滤器的实现原理，以及 CPython 中布隆过滤器的实现（不到 50 行 C 代码）。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://medium.com/@m____b____/uuids-with-python-b133cead1b4c&quot;&gt;Python 中 UUID 的使用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了&lt;code&gt;uuid&lt;/code&gt; 库的几个方法：uuid1() 利用系统 MAC 地址与时间戳生成 uuid；uuid4() 生成完全随机的 uuid；uuid3() 和 uuid5() 基于常量命名空间和变量名生成 uuid，前者使用 MD5 算法，后者使用 SHA-1 算法。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://ponder.io/why-are-there-so-many-python-dataframes/&quot;&gt;为什么有这么多 Python Dataframe？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;为什么会有 Pandas、Polars、Dask 和 PySpark 等大量的 Dataframe 库？作者认为主要的原因是它的四种角色模型：电子表格、关系数据库、二维数组/矩阵、对象，以及由此衍生出的一系列问题。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://www.dataschool.io/python-probability-simulation/&quot;&gt;使用 Python 模拟“三门问题”&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Monty Hall 问题也被称为三门问题，是一道挑战人们直觉的概率问题。文章使用 Python 来模拟这个问题，看看需要多久才能赢取奖品。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://pybit.es/articles/6-cool-things-you-can-do-with-the-functools-module/&quot;&gt;6 件可以用 Functools 模块做的很酷的事&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了 functools 标准库的 6 个使用场景：@cache 缓存、@total_ordering 让你少写双下方法、partial() 冻结函数、@singledispatch 泛型函数、@wraps 装饰器、reduce() 函数。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://juejin.cn/post/7281491804736831542&quot;&gt;深入理解 pytest.main()：Python 测试框架的核心功能解析&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;pytest.main&lt;/code&gt; 是 Pytest 框架中一个非常实用的函数，用于从命令行运行测试集或者以编程方式运行测试。文章探讨了它的用法和一些常见的应用场景。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://python.plainenglish.io/7-best-python-authentication-libraries-you-should-use-in-your-next-project-c07b668d5348&quot;&gt;7 个极佳的 Python 身份验证库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了 7 个不错的身份验证库：&lt;strong&gt;Authlib、Pyjwt、Flask-login、Django-allauth、ItsDangerous、Python Social Auth、Flask-security&lt;/strong&gt;。（附：&lt;a href=&quot;https://juejin.cn/post/7281150086351732751&quot;&gt;中文翻译&lt;/a&gt;）&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/rubik/radon&quot;&gt;radon：Python 代码的各种指标&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个 Python 代码指标分析工具，可以计算圈复杂度、原始指标、Halstead 指标、可维护性指数，可用于 CI 集成，可与 Jupyter Notebook 一起使用。（star 1.5K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/aiwaves-cn/agents&quot;&gt;agents：自主语言代理的开源框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;自主语言代理（Autonomous Language Agents）指的是能够独立执行自然语言处理任务的智能代理系统。这个库支持长期短期记忆、工具使用、Web 导航、多 agent 通信、人机交互和符号控制等功能。（star 2.6K）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/tedivm/quasiqueue&quot;&gt;quasiqueue：一个多进程库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个用于 Python 多进程的库，便于管理长时间运行的多进程作业。可处理进程创建和清理、信号管理、跨进程通信以及其它在处理多进程时的麻烦事。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/nicolas-hbt/pygraft&quot;&gt;pygraft：可配置的模式和知识图谱生成&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可根据用户指定的参数生成逼真的模式和知识图谱，通过使用 DL 推理器（HermiT）来确保逻辑一致性。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/pwwang/toml-bench&quot;&gt;toml-bench：在 Python 中该用哪个 toml 库？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个仓库主要从多个维度比较了 &lt;strong&gt;toml、tomli/tomli_w、tomlkit、pytomlpp、rtoml 和 qtoml&lt;/strong&gt; 这几个库，考察它们在处理数据时的行为表现以及性能。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/liuyuan-pal/SyncDreamer&quot;&gt;SyncDreamer：以单视角图像生成多视角一致的图像&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;提供一张图片，使用 Paint3D 分割前景对象，通过推理生成多个视角的图像。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/NVIDIA-AI-IOT/nanosam&quot;&gt;nanosam：使用 NVIDIA TensorRT 实时运行的 SAM 模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Segment Anything（SAM）是在计算机视觉领域中对图像或视频中的任何对象进行分割的任务，以提取出具有语义或视觉特征的子区域或对象。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/logpai/logparser&quot;&gt;logparser：用于日志解析的机器学习工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;国人开源作品。可自动从非结构化的日志信息中提取出结构化的关键信息。（star 1.2K）&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/tairov/llama2.mojo&quot;&gt;llama2.mojo：纯 Mojo 版本的 Llama 2&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者将 Python 版本的 llama2.py 移植成 Mojo 版本，将性能提高了近 250 倍。（star 1.1K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/dataelement/bisheng&quot;&gt;bisheng：一个开放的 LLM DevOps 平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一款领先的开源大模型应用开发平台，中文“毕昇”，可以搭建各类丰富的大模型应用：分析报告生成、知识库问答、对话、要素提取等。&lt;/div&gt;
&lt;h3&gt;🐢播客&amp;amp;视频&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.youtube.com/playlist?list=PL8uoeex94UhFcwvAfWHybD7SfNgIUBRo-&quot;&gt;EuroPython 2023 的 146 个视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;今年 EuroPython 活动的演讲视频。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://realpython.com/podcasts/rpp/172/&quot;&gt;Real Python 播客 #172：使用 Scalene 测量 Python 性能&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Scalene&lt;/strong&gt; 是一款高性能的 CPU、GPU 和内存分析器，可以从单个函数或代码行级别分析代码，并比较在 Python 和 C 代码中花费的时间。播客嘉宾是马萨诸塞大学教授，他与学校实验室的学生开发了 Scalene。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-10-12-weekly&quot;&gt;第22期（2023-10-12）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.python.org/downloads/release/python-3120/&quot;&gt;Python 3.12.0 版本发布了&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 最新大版本 3.12 发布了！包含许多新功能和优化，本期周刊有几篇文章涉及相关内容。（附：&lt;a href=&quot;https://realpython.com/python312-new-features/&quot;&gt;Python 3.12 新功能的详细介绍&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://realpython.com/python312-subinterpreters/&quot;&gt;Python 3.12 速览：子解释器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 子解释器是什么？3.12 版本的 PEP-684 做了什么？3.13 版本可能会出现什么变化？&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.manjusaka.blog/posts/2023/10/05/the-perf-feature-python-312/&quot;&gt;聊聊 Python 3.12 中 perf 的原生支持&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了 Python 的栈帧基本知识、3.12 之前对于 trace 和 perf 的实现、以及 3.12 新引入的 Linux 原生 perf 的实现。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://realpython.com/python312-typing/&quot;&gt;Python 3.12 速览：静态类型的改进&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;3.12 版本带来了一些调整和改进：使用类型变量来注释泛型类和函数、类型变量的新语法、使用新的 @override 装饰器作模型继承、用类型化的字典更精确注解 **kwargs。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://juejin.cn/post/7283461184514572349&quot;&gt;FastAPI 中的依赖注入：构建可维护的高性能 Web 应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;依赖注入是一种强大的设计模式，FastAPI 中如何利用依赖注入来构建可维护的高性能 Web 应用？涉及内容：使用依赖注入管理配置、数据库访问和 ORM 的依赖注入、高级依赖注入技巧、测试依赖注入、性能优化和缓存的依赖注入、安全性和依赖注入等。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://juejin.cn/post/7286670786563244090&quot;&gt;深入理解 python 虚拟机：原来虚拟机是这么实现闭包的&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了闭包的使用例子和使用原理，主要从虚拟机层面讨论函数闭包是如何实现的？&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://juejin.cn/post/7287418444647677986&quot;&gt;探索 Pexpect 库：深入理解 expect_list 方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/pexpect/pexpect&quot;&gt;pexpect&lt;/a&gt; 可用于交互式应用的自动化，如 ssh、ftp、passwd、telnet 等，Github star 2.4K。文章介绍了它的 expect_list 方法的使用。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://textual.textualize.io/blog/2023/10/04/announcing-textual-plotext/&quot;&gt;介绍 textual-plotext，在终端里绘图&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了 textual-plotext 库的用法，它可以在终端里用 &lt;a href=&quot;https://github.com/piccolomo/plotext&quot;&gt;Plotext&lt;/a&gt; 绘图。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://bbc.github.io/cloudfit-public-docs/&quot;&gt;Python Asyncio 系列文章 5 篇&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;BBC R&amp;amp;D Cloudfit 团队的系列博客文章，Asyncio 系列已更新 5 篇，内容有基础概念及模式、异步上下文管理器和异步迭代器、库支持、混合异步和同步代码。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://www.polarsignals.com/blog/posts/2023/10/04/profiling-python-and-ruby-with-ebpf&quot;&gt;使用 eBPF 分析 Python 和 Ruby&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用 eBPF 从内存结构中读取抽象堆栈数据，实现堆栈跟踪及代码执行分析。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://www.bitecode.dev/p/python-312-what-didnt-make-the-headlines&quot;&gt;Python 3.12: 不那么热门的改动&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了 3.12 版本中不那么引入关注的改动：pathlib 库的改进、更好的调试体验、切片对象现在是可哈希的、意外出现的 math.sumprod()、新的命令行界面。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://sethmlarson.dev/security-developer-in-residence-weekly-report-13&quot;&gt;从供应链安全角度看 Python 3.12.0&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 版本的发布流程是怎样的？版本构建的过程有哪些可改进的地方？文章另外介绍了用软件物料清单 （SBOM） 来跟踪软件分发的子组件以及它们在版本之间的变化。&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/mwmbl/mwmbl&quot;&gt;mwmbl：用 Python 实现的开源非营利搜索引擎&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个非营利、无广告、免费的搜索引擎，专注于可用性和速度。目前仅是概念验证版本，索引的页面还比较少。（star 1K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/Dataherald/dataherald&quot;&gt;dataherald：自然语言转 SQL 引擎&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于结构化数据进行企业级问答，允许设置一个 API，可用简单的英语回答问题。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/stanfordnlp/dspy&quot;&gt;dspy：使用基础模型编程的框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个使用语言模型 （LM） 和检索模型 （RM） 解决高级任务的框架。它统一了提示和微调 LM 的技术，以及推理、自我改进和使用检索和工具增强的方法。（star 3.5K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/coqui-ai/TTS&quot;&gt;TTS：文本到语音转换的深度学习工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个用高级文本生成语音的库，使用 1100 中语言的预训练模型，可用于训练新模型和微调任何语言的现有模型。（star 20.3K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/Qiskit/rustworkx&quot;&gt;rustworkx：用 Rust 实现的高性能 Python 图形库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用 Rust 编写的通用 Python 图形库，拥有高性能和安全性。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/airtai/faststream&quot;&gt;faststream：构建与事件流交互的异步服务&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个用于构建与 Apache Kafka、RabbitMQ 和 NATS 等事件流交互的异步服务框架，简化了为消息队列编写生产者和使用者的过程。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/aio-libs/aiohttp&quot;&gt;aiohttp：异步 HTTP 客户端/服务器框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;流行的异步 HTTP 框架，主要特点：支持客户端和服务端的 HTTP 协议、开箱即用的 Websocket、支持中间件和可插拔路由。（star 14K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/AliRn76/Panther&quot;&gt;panther：高性能的 Python Web框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于 Python 3.11 的 Web 框架，特点有面向文档的数据库 ODM、支持 Websocket、提供缓存 API、内置身份验证类、内置权限类、自定义中间件、可视化的 API 监控等。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/Qiskit/qiskit&quot;&gt;qiskit：用于量子计算机的开源 SDK&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;未来有可能人人都可以轻松使用量子计算机么？&lt;a href=&quot;https://qiskit.org/documentation/&quot;&gt;Qiskit&lt;/a&gt; 项目的目标是这样。这个库是 Qiskit 的核心组件，包含用于创建和使用量子电路、量子算子和基元函数的构建块。（star 3.9K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/mckinsey/vizro&quot;&gt;vizro：用于创建模块化数据可视化应用的工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用几行简单的配置就能创建复杂的仪表板，利用 Plotly 和 Dash 等库绘图。支持多种格式编写配置，包括 Pydantic 模型、JSON、YAML 或 Python 字典。（star 1.5K）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/ddbourgin/numpy-ml&quot;&gt;numpy-ml：用 numpy 作机器学习&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个由大量机器学习模型、算法和工具组成的集合，专门用 NumPy 和 Python 标准库编写。（star 14K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/jsvine/pdfplumber&quot;&gt;pdfplumber：PDF 解析库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可解析 PDF 每个文本字符、矩形和线条的详细信息，支持提取表格和可视化调试。（star 4.6K）&lt;/div&gt;
&lt;h3&gt;🐢播客&amp;amp;视频&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.youtube.com/watch?v=5Sm9IVMet9c&quot;&gt;Mojo 编程语言的新手入门教程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;FreeCodeCamp 推出的一个 Mojo 入门学习视频，已接近 10 万播放量。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.youtube.com/watch?v=udHmeAmOlbI&quot;&gt;Python 3.12: 你需要知道的新特性&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;探讨 Python 3.12 中令人兴奋的新功能和改进，也讨论了即将发布的版本将删除的一些元素。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-10-22-weekly&quot;&gt;第23期（2023-10-22）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://dev.to/praise002/20-exciting-python-project-ideas-3la9&quot;&gt;20 个令人兴奋的 Python 项目创意&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;经常看到有人问：有没有简单易上手的 Python 项目推荐？不妨看看这篇文章，它介绍了 20 个小项目的想法，另外原作者已经实现了很多项目，源码可从文中的&lt;a href=&quot;https://github.com/praise002/20-python-project&quot;&gt;仓库地址&lt;/a&gt;获取。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://en.lewoniewski.info/2023/python-3-11-vs-python-3-12-performance-testing/&quot;&gt;Python 3.11 vs Python 3.12 之性能测试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章在配备 AMD 锐龙 7000 系列和第 13 代英特尔酷睿处理器的不同机器上共进行了 91 种基准测试，详细给出了各项数值。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://blog.adarshd.dev/posts/when-i-met-guido-van-rossum/&quot;&gt;当我遇见了 Guido van Rossum&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者在今年 Pycascades 上做了演讲“Python 中用元类作元编程”，并遇见 Guido，他们聊了一些 Python 使用中的话题以及如何成为 CPython 核心开发者。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://death.andgravity.com/stdlib&quot;&gt;通过阅读代码学习：Python 标准库设计决策解释&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;程序员提升能力的一个方法是大量阅读优秀的代码，Python 标准库就是很好的选择。但标准库茫茫之多，该选择哪些呢？文章作者推荐了这些：&lt;strong&gt;statistics、pathlib、dataclasses、graphlib&lt;/strong&gt;。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://testdriven.io/blog/accepting-payments-with-stripe-vuejs-and-flask/&quot;&gt;使用 Stripe、Vue.js 和 Flask 开发收款功能&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;国人的付费意愿差，独立开发者选择出海掘金的话，大多会选择用 Stripe 账号。这篇教程使用 Stripe 实现网站的收款功能，前后端技术栈为 Vue 和 Flask。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://blog.frankel.ch/rust-from-python/&quot;&gt;使用 Python 调用 Rust 的三种方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了 Python 调用 Rust 的三种方法：HTTP、IPC（进程间通信） 和 FFI（外部函数接口）。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://semaphoreci.com/blog/custom-middleware-fastapi&quot;&gt;如何开发 FastAPI 的中间件？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;FastAPI 内置了一些中间件，但你可能还需要量身定制自己的中间件。文章介绍了 FastAPI 中间件原理及内置的中间件，然后基于函数和基于类来实现自定义中间件，给出了最佳实践建议以及相应的测试用例。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://www.honeybadger.io/blog/options-for-passwordless-authentication-in-django/&quot;&gt;Django 项目实现无密码身份验证&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了三种无密码的身份验证方法：基于邮件的身份验证、使用 OAuth 进行身份验证和使用超链接进行身份验证；介绍了它们的优点、局限性以及使用的注意事项。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://thetechbuffet.substack.com/p/improve-python-development-workflow&quot;&gt;在发布 Python 项目前，建议用上这 4 个工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;有什么工具可以简化开发工作流程，遵循行业构建良好软件的最佳实践？文章分享了 4 种好用的工具：&lt;strong&gt;Poetry、Pre-commit 钩子、Makefiles、python-dotenv&lt;/strong&gt;。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://blog.miguelgrinberg.com/post/we-have-to-talk-about-flask&quot;&gt;我们必须聊聊 Flask&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Flask 最近发布了 3.0 版本，Werkzeug 也同时发了 3.0 版本，但它引入了不向后兼容的更改！作者吐槽 Flask 总是出现版本不兼容的问题，给出了不少例子和原因分析，希望 Flask 核心开发不要做无端的重构，要三思而行。（文章出自《Flask Web Development》一书的作者）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://juejin.cn/post/7288998044020326415&quot;&gt;基于 ProPainter 技术去除图片以及视频水印&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍使用 ProPainter 框架来解决视频去水印问题，它引入了双域传播的新方法和一种高效的遮罩引导视频 Transformers，增强了视频修复的性能，同时保持了计算效率，成本更低。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://thenewstack.io/python-comes-to-google-sheets/&quot;&gt;Google Sheets 也能用 Python 了&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;微软在 8 月让 Excel 支持了 Python，现在一家名为 Neptyne 的公司推出了一款在 Google Sheets 中使用 Python 功能的产品。文章介绍了它的基本情况。&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;http://python.jpglomot.com/#/questions&quot;&gt;一个 Python 知识问答网站&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个很简洁的网站，有近百道选择题，大多是 Python 基础语法相关的内容。来测一下你都学会了么？&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/benjie-git/CardStock&quot;&gt;CardStock：跨平台的 GUI 构建工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它提供了一个类似于绘图程序的编辑器，用于构建图形用户界面，支持文本、图形、图像、按钮、输入框和 Web 视图等元素；提供了一个代码编辑器，可添加事件驱动的 Python 代码。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/Undertone0809/python-package-template&quot;&gt;python-package-template：标准化的 Python package模板&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它内置了单元测试、代码检查、格式化、包管理、pre-commit 配置、Github Actions 等众多方便的工具，可以很方便的管理 Python 项目。（投稿自@Undertone0809）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/pipeless-ai/pipeless&quot;&gt;pipeless：一个计算机视觉框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;轻松构建与部署可实时分析及操作视频流的应用，无需构建和维护多媒体 pipeline。支持插件，例如使用 Kafka 实时处理事件、使用 YOLOv8 模型等。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/KoljaB/RealtimeSTT&quot;&gt;RealtimeSTT：强大、高效、低延迟的语音转文本库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它具有高级语音活动检测、唤醒词激活和即时转录功能，使用的技术栈有：语音活动检测（&lt;strong&gt;WebRTCVAD、SileroVAD&lt;/strong&gt;）、语音转文本（&lt;strong&gt;Faster Whisper&lt;/strong&gt;）、唤醒词检测（&lt;strong&gt;Porcupine&lt;/strong&gt;）。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/richardyc/Chrome-GPT&quot;&gt;Chrome-GPT：可控制 Chrome 的 AutoGPT 代理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它利用 Langchain 和 Selenium 使 AutoGPT 代理能够控制 Chrome 会话。支持以交互方式滚动、单击和输入网页上的文本，从而可以导航和操作 Web 内容。（star 1.4K）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/rohankishore/ZenNotes&quot;&gt;ZenNotes：Windows 记事本，支持翻译和TTS&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个简约的 Windows 记事本程序，支持翻译、TTS、Markdown，基于 &lt;a href=&quot;https://github.com/zhiyiYo/PyQt-Fluent-Widgets&quot;&gt;PyQt-Fluent-Widgets&lt;/a&gt; 开发而成。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/kr8s-org/kr8s&quot;&gt;kr8s：用于 Kubernetes 的客户端库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用于 k8s 的一个简单、可扩展的 Python 客户端库，如果你用过 &lt;strong&gt;kubectl&lt;/strong&gt;，就会觉得它很熟悉。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/swirlai/swirl-search&quot;&gt;swirl-search：用 AI 同时搜索多个数据源&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可搜索多个内容源并返回 AI 的排名结果，支持连接到数据库（SQL、NoSQL、Google BigQuery）、公共数据（谷歌、Arxiv）、企业数据源（Microsoft 365、Jira、Miro等）。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/getsentry/sentry&quot;&gt;sentry：面向开发者的错误跟踪和性能监控平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个强大的错误跟踪和性能监控平台，还支持定期任务监控、代码覆盖率、会话重播、告警、安全策略等功能，支持 100 多种平台和框架，支持 30+ 编程语言。（star 35.4K）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/zhiwehu/100_plus_Python_Projects_Challenge&quot;&gt;15 个 Python 小项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个仓库收录了一些 Python 小项目及其实现代码，跟本期周刊的第一则分享相似。（star 1K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/jtesta/ssh-audit&quot;&gt;ssh-audit：SSH 服务器和客户端安全审计&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用于审查 SSH 的配置，支持 SSH1 和 SSH2 协议，支持 Linux 和 Windows，可识别安全漏洞、不安全密钥、不安全算法等，并给出安全建议。另外它也有&lt;a href=&quot;https://www.ssh-audit.com/&quot;&gt;在线版本&lt;/a&gt; 。（star 2.6K）&lt;/div&gt;
&lt;h3&gt;🐢播客&amp;amp;视频&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.youtube.com/playlist?list=PLEpW1LzVyQWgtT_i_IlUmx2FSP2jHcroX&quot;&gt;哥本哈根 2023 Django Day 演讲视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Django Day 是一个专门围绕 Django 框架和 Django 社区的活动，目前视频列表中有 11 则视频。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://talkpython.fm/episodes/show/434/building-mobile-apps-backed-with-python&quot;&gt;Talk Python To Me  #434：用 Python 构建移动 APP&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 能够用于开发移动端应用么？能不能用 Python 实现端到端的移动应用开发？这期播客邀请了几个移动端 APP 的开发者聊了相关话题。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-10-29-weekly&quot;&gt;第24期（2023-10-29）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://lwn.net/Articles/947138/&quot;&gt;PEP-703 无 GIL CPython 的进展&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PEP-703 是 no-GIL 项目形成的提案，就在本周，Python 指导委员会宣布采纳了这个提案！这篇文章写于消息宣布的两周前，总结了过去一段时间里发生的技术思考和进展。（附：&lt;a href=&quot;https://discuss.python.org/t/pep-703-making-the-global-interpreter-lock-optional/22606/123&quot;&gt;PEP-703 的讨论&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://peps.python.org/pep-0730/&quot;&gt;PEP-730 CPython 提供对 iOS 的官方支持&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个新提案，建议 CPython 提供对 iOS 系统的 Tier 3 级支持。如果提案被采纳，则 Python 将会有更广泛的使用。 &lt;a href=&quot;https://beeware.org/&quot;&gt;BeeWare&lt;/a&gt; 和 &lt;a href=&quot;https://kivy.org/&quot;&gt;Kivy&lt;/a&gt; 是支持 iOS 的 Python APP 开发框架，说明了技术的可行性。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.pythoncentral.io/the-next-step-in-django-development-advanced-features-to-consider/&quot;&gt;Django 进阶：开发高级的功能&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章探讨在 Django 应用中集成一些高级的特性，例如：实现所见即所得编辑器、用户认证授权、实时通信功能、异步任务、集成 Elasticsearch 作全文搜索、自动化测试与持续集成。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://testdriven.io/blog/developing-an-asynchronous-task-queue-in-python/&quot;&gt;在 Python 中开发异步的任务队列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了使用 multiprocessing.Pool、multiprocessing.Queue 和 Redis 实现简单的任务队列，实现基础的任务调度处理。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://pgjones.dev/blog/flask-ecosystem-compatibility-2023/&quot;&gt;Flask、它的生态和向后兼容性&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;上期周刊分享了一则吐槽 Flask 向后兼容性不好的文章（见下），这篇是对它的回应，作者是 Flask 的维护者之一。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://blog.miguelgrinberg.com/post/some-more-to-talk-about-flask&quot;&gt;继续关于 Flask 的讨论&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是上周《&lt;a href=&quot;https://blog.miguelgrinberg.com/post/we-have-to-talk-about-flask&quot;&gt;我们必须聊聊 Flask&lt;/a&gt;》的后续，作者收到了一些正面和反面的回应，文章延续了之前的话题，并主要反驳了一些观点。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://prefix.dev/blog/introducing_rip&quot;&gt;介绍 rip - 快速而简约的 pip 实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;rip 是用 Rust 开发的 PyPI 包解析及安装库，即 Rust 版本 pip。它试图在 Conda 和 PyPI 间架起一座坚固的桥梁，文章介绍它为了克服这两者的主要区别（元数据提取、Wheel 文件元数据、依赖项规范）而做的一些工作。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://willcrichton.net/notes/k-corrset/&quot;&gt;使用 Rust 将数据分析速度提高 180,000 倍&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何使用 Rust 实现关键代码来提升 Python 程序的性能？文章从多个方面优化 k-CorrSet 问题的实现，得到了很高的速度提升。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://www.pythonmorsels.com/lambda-expressions/&quot;&gt;什么是 lambda 表达式？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;什么是 lambda 表达式和 lambda 函数？lambda 函数与 Python 的其它函数有何不同？它有什么局限性、什么时候应该避免使用、通常使用在什么场景？&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://juejin.cn/post/7293420609088798731&quot;&gt;手撸个视频翻译和配音工具玩玩 结果不太妙&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;视频翻译是对原始语言的视频处理后，显示为其它语言的字幕及配音。文章是一个低成本的尝试，技术栈：语音识别使用 openai-whisper 离线模型、文字翻译使用 Google 接口、文字合成语音使用 Microsoft Edge tts。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://alex-jacobs.com/posts/fastapitests/&quot;&gt;掌握使用 FastAPI 进行集成测试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;集成测试是指将各个代码单元作为一个整体进行测试。文章介绍基于 FastAPI 的集成测试方法，包括如何模拟身份验证、如何模拟外部 API、如何模拟 MangoDB 相关操作、如何模拟 AWS S3。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://www.biaodianfu.com/latexify-python.html&quot;&gt;Python 代码转为 LATEX 公式工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;latexify_py 是一个 Google 开源的 Python 包，可以将 Python 源代码片段编译为相应的 LaTeX 表达式。文章介绍了它的使用方法，包括如何将 Python 函数转为公式、Latexify 参数设定、Latexify 生成伪代码。&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/celery/celery&quot;&gt;celery：分布式任务队列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 中比较成熟的任务队列库，支持 RabbitMQ、Redis 等中间件，很容易与主流 Web 框架集成。（star 22.4K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/rq/rq&quot;&gt;rq：简单的任务队列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;RQ（Redis Queue）是基于 Redis 的任务作业库，使用门槛低，支持排队、定时、重试等功能。（star 9.2K）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/coleifer/huey&quot;&gt;huey：轻量级的任务队列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;简单轻量级的任务队列库，支持 Redis、SQLite、文件系统和内存存储，支持多进程、多线程或 Greenlet 任务执行模型。（star 4.7K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/prefix-dev/rip&quot;&gt;rip：快速解决和安装 Python 包（Rust 版 pip）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用 Rust 实现的 pip，支持下载、解析和安装 PyPI 包，支持 wheel （部分支持），计划将 sdist 文件。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/mherrmann/selenium-python-helium&quot;&gt;Selenium-python-helium：Web 自动化库，让 Selenium 更好用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Selenium 是 Web 自动化的最优库之一，Helium 是在其基础上的封装，使 Web 自动化更为方便。除了高级 API，它还简化了 Web 驱动管理、支持与嵌套的 iFrame 中元素交互、支持隐式等待、支持显式等待。（star 3.6K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/sinaatalay/rendercv&quot;&gt;rendercv：用 YAML/JSON 文件创建 PDF 格式的简历&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它支持解析 YAML 及 JSON 文件的简历，创建 latex 文件，然后渲染成 PDF 格式。目前仅有一款主题。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/google/latexify_py&quot;&gt;latexify_py：用 Python 代码生成 LaTeX 表达式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可以将 Python 源码或 AST 编译为 LaTex，使用 IPython 来漂亮地打印编译的函数。（star 6.5K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/danielgross/localpilot&quot;&gt;localpilot：Mac 上的 Github Copilot&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在 Macbook 本机上使用的编程助手，配置及使用非常简易。（star 2.6K）&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/spotify/annoy&quot;&gt;annoy：C++/Python 的近似最近邻搜索&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用于搜索空间中靠近给定查询点的点，与其它同类库的最大不同是可使用静态文件作为索引，可实现跨进程共享索引。被 Spotify 用作音乐推荐。（star 12.1K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/spotify/voyager&quot;&gt;voyager：用于 Python 和 Java 的近似邻搜索库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可对内存中的向量集合执行快速的近似最近邻搜索。也是出自 Spotify，每天被查询数亿次，扛得住海量用户的请求。召回率比 annoy 高。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/codefuse-ai/Test-Agent&quot;&gt;Test-Agent：国内首个测试行业大模型工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它旨在构建测试领域的“智能体”，融合大模型和质量领域工程化技术，促进质量技术代系升级。开源了测试领域模型 TestGPT-7B，该模型以 CodeLlama-7B 为基座。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/waymo-research/waymax&quot;&gt;waymax：用于自动驾驶研究的基于 JAX 的模拟器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Waymo 是 Google 旗下的自动驾驶公司，Waymax 是其开源的轻量级、多智能体、基于 JAX 的自动驾驶模拟器，可轻松分发和部署在 GPU 和 TPU 等硬件加速器上。&lt;/div&gt;
&lt;h3&gt;🐢播客&amp;amp;视频&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.youtube.com/watch?v=jXlR0Icvvh8&quot;&gt;Python 的代码生成：拆解 Jinja&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Jinja 的主要作者 Armin Ronacher 在 2012 年的演讲视频，介绍了 Jinja 编译器基础结构的设计，为什么这样设计，以及不同版本的迭代发展过程。（附：&lt;a href=&quot;https://speakerdeck.com/mitsuhiko/code-generation-in-python-dismantling-jinja&quot;&gt;演讲的 PPT&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.youtube.com/watch?v=rHmljD-oZrY&quot;&gt;让我们聊一聊模板&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Armin Ronacher 在 2014 年的演讲视频，比较了 Jinja 和 Django 的模板，分析它们产生截然不同设计的历史原因。（附：&lt;a href=&quot;https://speakerdeck.com/mitsuhiko/lets-talk-about-templates&quot;&gt;演讲的 PPT&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.youtube.com/playlist?list=PL_1BH3ug7n1Ih_Yy2TmM7MZ2zogSLZvzE&quot;&gt;JupyterCon 2023 视频 86 个&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;JupyterCon 是一个专注于 Jupyter 应用和工具的年度活动，包括数据科学、机器学习、科学计算、数据可视化、教育和科学研究等领域。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-11-04-weekly&quot;&gt;第25期（2023-11-04）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://astral.sh/blog/the-ruff-formatter&quot;&gt;Ruff：一款极其快、兼容 Black 的 Python 格式化工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;我在今年 4 月份介绍过 &lt;a href=&quot;https://pythoncat.top/posts/2023-04-09-ruff&quot;&gt;性能最快的代码分析工具&lt;/a&gt; Ruff，当时发现它不局限于 Linter 的定位，还提供了部分 Formatter 的功能。现在，它发布了重大更新，正式成为性能最快的 Python 代码格式化工具，比 &lt;strong&gt;Black&lt;/strong&gt; 快 30 倍以上，比 &lt;strong&gt;YAPF&lt;/strong&gt; 快 100 倍！&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://pythonspeed.com/articles/upgrade-python-3.12/&quot;&gt;你应该什么时候升级到 Python 3.12？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 3.12 已经发布了，你是否迫切想要升级了呢？现在是最佳的升级到 3.12 的时候么？文章建议你等到 12 月，等发布 3.12.1 错误修复版本后，因为新版本存在这些问题：不兼容的软件包、缺少二进制包、每次大版本总有大量的问题要修复。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.manjusaka.blog/posts/2023/10/29/the-most-important-thing-in-python-3-12/&quot;&gt;Python 3.12：一个被人忽略的史诗级版本&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者认为 3.12 对于 Python 的意义，大于 3.5 的“async/await” 和 3.6 的 “Type Hint” 对于 Python 的意义！主要分析了三个方面提升：PEP-669 带来的可观测性、PEP-684 为 non-GIL 带来的性能提升、PEP-697 全新 C API 保证跨版本兼容性。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://quanttype.net/posts/2023-10-31-do-not-use-requirements.txt.html&quot;&gt;不要再用 requirements.txt 了&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者给了两个建议：不要使用 pip 和 &lt;code&gt;requirements.txt&lt;/code&gt; 来管理 Python 依赖项，推荐使用 Poetry。pip 的主要问题是没有 lockfile 和手工管理虚拟环境麻烦。除了 Poetry，作者也提及了 Hatch 和 PDM。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.coderedcorp.com/blog/why-is-the-django-admin-ugly/&quot;&gt;为什么 Django 后台管理系统那么“丑陋”？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Django 提供了一个默认的后台管理系统，即 Django Admin，它的 UI 很多年没有变化，显得设计过时了。为什么 Django 维护者们不改善它呢？作者通过询问多位维护者，得出了它的历史及如此设计的原因，主要观点是 Django Admin 面向内部管理员，不应该暴露给终端用户。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://gregoryszorc.com/blog/2023/10/30/my-user-experience-porting-off-setup.py/&quot;&gt;我迁移弃用 setup.py 的糟糕体验&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PyOxidizer 作者的一篇长文，他在将 Python 3.12 用于另一个库时，CI 运行&lt;code&gt;python setup.py&lt;/code&gt; 提示 setuptools 无法导入。作者在寻求解决方案时，发现 Python 的打包生态非常让人困惑，他经历了一系列复杂而耗时的过程。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://realpython.com/ptpython-shell/&quot;&gt;使用 Ptpython 提高你的编码效率&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Ptpython 是一个功能丰富且对用户友好的 Python REPL，这是一篇非常详细的使用教程。重点介绍的功能包括历史记录、输入验证、自动补全、自动处理缩进、自定义交互式 shell、在脚本中嵌入 ptpython 等。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://blog.robertroskam.com/p/100-test-coverage-is-not-enough&quot;&gt;100%的测试覆盖率是不够的：Python 中基于属性的测试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;测试覆盖率固然重要，但这项指标并不足以解决所有问题。文章通过示例揭示测试覆盖率的不足，简单介绍了如何用 Hypothesis  作基于属性的测试。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://www.cnblogs.com/hanabi-cnblogs/p/17792740.html&quot;&gt;从零开始编写一个 Python 异步 ASGI Web 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;从零开始编写一个异步 ASGI Web 框架难么？需要了解哪些知识、实现哪些功能、思考哪些问题？这篇循序渐进的教程是很好的学习材料，让你了解 Web 框架设计、异步编程、功能封装与项目管理。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://www.cnblogs.com/frankming/p/17762591.html&quot;&gt;Python 如何在日志中隐藏明文密码？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;不在日志中打印明文密码是安全需求，但是有太多可能出现打印密码的情况，如何能高效地隐藏明文密码呢？文章介绍了基于 &lt;strong&gt;logging&lt;/strong&gt; 模块的两种实现方案：自定义 filter 和自定义 formatter，使用特定规则过滤明文密码。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://monadical.com/posts/from-chaos-to-cohesion.html&quot;&gt;从混沌到凝聚：构建你自己的 Monorepo&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;monorepo 是将所有项目都放到一个代码仓管理，可能包含不同语言和框架。这意味着对它的依赖管理和 CI/CD 等都与普通代码仓不同。文章介绍如何使用 GitHub Actions 作为 CI/CD 工具构建简单的 Python monorepo。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://eddieantonio.ca/blog/2023/10/25/python-is-a-compiled-language/&quot;&gt;Python 是一种编译型语言&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;我们通常习惯将 Python 称为一种解释型语言，因为它在运行时逐行解释和执行代码。很多人还知道 Python 其实也有编译的过程，解释器会先编译再执行。然而作者不止步于此，他通过苏格拉底式对话和几轮实验，引导读者重新思考“解释”与“编译”：它们是错误的二分法、限制了编程语言的可能性。Python 既是解释型语言，也是编译型语言！&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/ccxt/ccxt&quot;&gt;ccxt：加密货币交易 API，支持 100 多个交易所&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用于加密货币交易的 JavaScript/Python/PHP/C# 库，支持许多比特币/以太币/山寨币交易市场和商家 API。（star 29.5K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/pauloxnet/uDjango&quot;&gt;uDjango：单文件的 Django 微型项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个项目是 DjangoCon US 2023 的演示项目，使用单文件不到 10 行代码，演示一个最小的 Django 应用。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/dymmond/esmerald&quot;&gt;esmerald：高度可扩展、高性能的 Web 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于 Starlette 和 Pydantic 之上构建的开箱即用的 Web 框架，用于构建现代可扩展的 API 应用，支持同步和异步，提供 DAO、ORM、ODM、依赖注入、权限管理等功能。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/laike9m/Python-Type-Challenges&quot;&gt;Python-Type-Challenges：通过在线挑战来学习 Python 类型提示&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个很有意思的项目，它包含从初级到高级的一系列挑战题目，让你在线练习 type hint 的使用。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/mify-io/mify&quot;&gt;mify：微服务基础架构，代码生成工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可生成 OpenAPI http 服务端，内置 Prometheus 指标，提供结构化日志记录，支持多种语言代码生成。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/Fadi002/de4py&quot;&gt;de4py：Python 逆向工程工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一款高级的 Python 反混淆器，面向恶意软件分析师和逆向工程师，它拥有精美的 UI 和一些高级功能。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/public-apis-dev/public-apis&quot;&gt;public-apis：面向开发者的公共 API 列表&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;非常非常丰富的公共 API 清单，内容应有尽有。（star 2K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/alibaba-damo-academy/FunASR&quot;&gt;FunASR：端到端语音识别工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;阿里达摩院开源的语音识别工具包，功能包括语音识别（ASR）、语音端点检测（VAD）、标点恢复、语言模型、说话人验证、说话人分离和多人对话语音识别等。（star 1.2K）&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/JoeanAmier/XHS_Downloader&quot;&gt;XHS_Downloader: 小红书图文/视频作品采集工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;支持采集和下载小红书图文/视频作品，支持批量下载，有作品文件完整性处理机制。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/yinan-c/RSS-GPT&quot;&gt;RSS-GPT：使用 ChatGPT 为你的 RSS 订阅源生成摘要&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用 GitHub workflow 自动运行一个简单的 Python 脚本，调用 OpenAI API 为 RSS 订阅源生成摘要，然后将新生成的 RSS 订阅源推送到 GitHub Pages。配置简单快速，无需服务器。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/codespell-project/codespell&quot;&gt;codespell：检查代码是否存在常见拼写错误&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用于检查源代码中拼写错误的单词，支持多种运行方式，可指定忽略单词和文件，可用于 pre-commit。（star 1.5K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/WisdomShell/codeshell&quot;&gt;codeshell：多语言代码大模型基座&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;具有 70 亿参数，在五千亿 Tokens 进行了训练，上下文窗口长度为 8192。在权威的代码评估Benchmark 上，CodeShell 取得同等规模最好的性能。（star 1.2K）&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-11-11-weekly&quot;&gt;第26期（2023-11-11）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://kennethreitz.org/essays/why-im-not-collaborating-with-kenneth-reitz&quot;&gt;Kenneth Reitz：迟来的道歉，以及 requests 3 的进展&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;2019 年时 requests 3 的筹款闹出了不小的风波，后来似乎没什么消息。现在作者发了一篇道歉文，看来项目是要重启了！文中列举了目前已经完成的一些事情，包括给所有公开接口加上了类型提示、重构所有命名空间和调整成兼容异步编程等。（附：筹款风波之《&lt;a href=&quot;https://vorpus.org/blog/why-im-not-collaborating-with-kenneth-reitz/&quot;&gt;Why I’m not collaborating with Kenneth Reitz&lt;/a&gt;》）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://coderslegacy.com/python-grequests-making-asynchronous-http-requests/&quot;&gt;grequests：异步的 HTTP 请求&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;grequests&lt;/code&gt; 构建在 &lt;code&gt;gevent&lt;/code&gt; 库之上，可以并发多个请求，有效利用异步编程的强大功能。这篇基础教程介绍了它的基本使用方法，以及一个提升性能的建议。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://mathspp.com/blog/tag:bpci&quot;&gt;开发一个 Python 编译器和解释器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一系列博文，目前已更新 6 篇，目标是探索和研究实现 Python 等编程语言所需的概念和算法，将会涉及分词器、解析器、编译器和解释器。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://levelup.gitconnected.com/build-an-ai-tool-to-summarize-books-instantly-828680c1ceb4&quot;&gt;使用 Python+ChatGPT 开发一个书籍摘要 AI&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇教程，用 Python、Langchain 和 OpenAI embedding 开发一个书籍摘要工具。另外，作者使用 Streamlit 发布了一个&lt;a href=&quot;https://gptsummarizer.streamlit.app/&quot;&gt;在线体验网站&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.paulox.net/2023/11/07/database-generated-columns-part-1-django-and-sqlite/&quot;&gt;数据库生成的列 ：Django &amp;amp; SQLite&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;GeneratedField&lt;/code&gt; 是正在开发的 Django 5.0 的新功能，利用数据库的能力自动计算数据列的值。作者是 Django 的贡献者，测试了在 SQLite 中使用这个新功能的各种场景。（附：这篇文章还介绍了一些 &lt;a href=&quot;https://fly.io/django-beats/new-goodies-in-django-50/&quot;&gt;Django 5.0 中的新东西&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://martinheinz.dev/blog/106&quot;&gt;你能用 Python 的 bisect 模块做到这些事&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;bisect&lt;/code&gt; 模块只有两个函数，但可以做很多事，文章介绍了：二分搜索、前缀搜索、在列表中查找连续的相等值、查找字典中最接近的键、自定义对象的排序、按照字典 key 搜索。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://labs.quansight.org/blog/building-scipy-with-flang&quot;&gt;为什么说在 Windows 上为 Python 3.12 构建的 SciPy 是一个小奇迹？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;每当 Python 发布新版本时，三方库的维护者们也要紧锣密鼓开发兼容的对应版本，这不是轻松的事。作者介绍了他们遇到的严峻挑战，其实就是 Python 社区老大难的打包问题。好在维护者们已经找到了适用的解决方案。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://serpapi.com/blog/web-scraping-and-parsing-experiment-with-ai-openai/&quot;&gt;使用 AI 进行网页抓取实验（使用 GPT-4 解析 HTML）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;OpenAI 发布了新的模型，它的能力到底如何呢？使用 GPT-4 作网页抓取，具有哪些优点和缺点呢？文章分别实验了抓取结构良好的网站、抓取 Google 自然搜索结果、抓取 Google SERP、以及抓取 Google MAPS 结果。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://blog.jetbrains.com/pycharm/2023/11/django-vs-flask-which-is-the-best-python-web-framework/&quot;&gt;Django vs Flask：哪个是最好的 Python Web 框架？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 圈最为流行的两大 Web 框架，到底应该如何取舍呢？这是一篇细致的长文，详细对比了它们在模板系统、URL 调度器、数据库支持、身份验证及授权、测试、软件架构、学习曲线等方面的差异。没有更好的，只有是否适合你的。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://marvelousmlops.substack.com/p/the-right-way-to-install-python-on&quot;&gt;在 Mac 上安装 Python 的正确方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何在新的 M2 MacBook 上安装 Python 呢？这篇手把手的指导教程中，作者给出的建议是 &lt;strong&gt;Pyenv + pyenv-virtualenv&lt;/strong&gt; 。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://www.techbeamers.com/simple-android-data-analytics-app-in-python/&quot;&gt;用 Python 开发简单的 Android 数据分析应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这篇教程指导你开发一个 Android 数据分析应用，其作用是记录和显示你全天在屏幕上花费的时间。使用的 GUI 框架是&lt;code&gt;kivy&lt;/code&gt; ，数据分析使用了&lt;code&gt;Pandas&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://labs.quansight.org/blog/numpy-python-api-cleanup&quot;&gt;改进 Numpy 的 Python API，为 2.0 版本准备&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;NEP-52 是 Numpy 的一则增强提案，旨在识别 Numpy 中过时、重复和弃用的 Python API，并作重构优化。这项工作是为了顺利迁移到 Numpy 2.0 而做的准备。作者介绍了他在其中遇到的挑战和取得的部分成就。&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/jianchang512/pyvideotrans&quot;&gt;pyvideotrans：视频的语言翻译，并添加配音&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个视频翻译工具，可将一种语言的视频翻译为另一种语言和配音的视频。（star 1.4K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/google/pyink&quot;&gt;pyink：Google 内部修改 Black 而成的代码格式化工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;由 Black 派生而成，用于解决 Google 数千名工程师在 monorepo 上工作产生的问题。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/tiangolo/sqlmodel&quot;&gt;sqlmodel：Python 中的 SQL 数据库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;由 FastAPI 作者开源的 SQL 数据库，结合了 SQLAlchemy 和 Pydantic，旨在实现简单性、兼容性和稳健性。（star 11.2K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/wagtail/wagtail&quot;&gt;wagtail：一个 Django 内容管理系统&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个专注于用户体验的后台管理系统，上期分享了关于“&lt;a href=&quot;https://www.coderedcorp.com/blog/why-is-the-django-admin-ugly/&quot;&gt;Django Admin 丑陋&lt;/a&gt;”的文章，wagtail 是可提供给终端用户使用的最佳推荐。（star 16.2K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/kyleskom/NBA-Machine-Learning-Sports-Betting&quot;&gt;NBA-Machine-Learning-Sports-Betting：使用机器学习的 NBA 比赛预测&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个机器学习 AI，用于预测 NBA 比赛胜负。包含 2007-08 赛季到本赛季的所有球队数据。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/FarhaKousar1601/Python_EBook_Free&quot;&gt;Python_EBook_Free：Python 电子书和资源&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个仓库归档了一些 Python 电子书和学习资源，都是 PDF 格式。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/pathwaycom/pathway&quot;&gt;pathway：高吞吐量和低延迟实时数据处理框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个数据处理框架，结合了 LLM 程序的批处理、流式处理和实时 API，可与各种数据源交互（如 Kafka、CSV 文件、SQL/noSQL 数据库和 REST API）。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/PrefectHQ/prefect&quot;&gt;prefect：一个工作流编排工具，构建数据管道&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它是数据密集型工作流的编排器，可将 Python 函数转换为可观察和编排的工作单元。支持自动重试、分布式执行、调度、缓存等功能，拥有强大的仪表板进行监控。（star 13.2K）&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/AILab-CVC/VideoCrafter&quot;&gt;VideoCrafter：生成高质量视频模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个支持高清晰度的视频生成和编辑工具，目前包括文字生成视频及图片生成视频两种模型。（star 3K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://madza.hashnode.dev/42-developer-resources-to-kickstart-your-coding-journey&quot;&gt;程序员值得看的 42 个学习资源&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这篇文章收集了一系列基础资源、课程和教程、编码游戏、书籍、播客、YouTube 频道、最佳实践等等。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/networkx/networkx&quot;&gt;networkx：Python 的网络分析库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用于创建、操作和研究复杂网络的结构、动力学和功能，适用于复杂网络的分析。（star 13.4K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/jgu-bytes/PythonFrameworks&quot;&gt;PythonFrameworks：Python 的各种框架汇总&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个项目收录了 Python 中的各种框架，有 Web 框架、API 框架、CMS、ML&amp;amp;DL&amp;amp;AI、任务/消息队列、并行&amp;amp;分布式计算、工作流&amp;amp;管道、DevOps、爬虫、GUI&amp;amp;TUI，等等。提供有一个&lt;a href=&quot;https://pythonframeworks.com/&quot;&gt;在线网站&lt;/a&gt;。&lt;/div&gt;
&lt;h3&gt;🐢播客&amp;amp;视频&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://podcasters.spotify.com/pod/show/corepy&quot;&gt;core.py：一档新的 Python 播客&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;由 Python 核心开发者 Pablo Galindo 和 Łukasz Langa 主理的播客，已推出两期节目：&lt;a href=&quot;https://podcasters.spotify.com/pod/show/corepy/episodes/Episode-1---Core-Sprint-in-Brno--Python-3-13-0-alpha-1-e2apebk&quot;&gt;核心开发者 Sprint 及 Python 3.13.0 alpha 1&lt;/a&gt;、&lt;a href=&quot;https://podcasters.spotify.com/pod/show/corepy/episodes/Episode-2---PEP-703-Removing-the-GIL-e2b8egi&quot;&gt;PEP-703：移除 GIL&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.youtube.com/watch?v=Tml94je2edk&quot;&gt;为什么静态类型又流行起来了？ &lt;/a&gt;&lt;/div&gt;
&lt;div&gt;上世纪 90 年代诞生的 Python、Ruby、PHP 和 JavaScript 这些动态编程语言都在拥抱静态类型（mypy、Sorbet、Hack 和 TypeScript），诞生不算久的 Go、Kotlin、Dart 和 Rust 等都是静态类型。为什么静态类型卷土重来？这对未来意味着什么？&lt;/div&gt;
&lt;div&gt;3、《Boost your Git DX》作者的两期播客&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://twitter.com/AdamChainz&quot;&gt;Adam Johnson&lt;/a&gt; 新书《提升你的 Git 开发者体验》上市后，分别参加了&lt;a href=&quot;https://realpython.com/podcasts/rpp/179/&quot;&gt;Real Python Podcast #179&lt;/a&gt; 和 &lt;a href=&quot;https://pybit.es/articles/maximizing-your-dx-with-adam-johnson/&quot;&gt;Pybites #139&lt;/a&gt; 两期播客节目。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-11-18-weekly&quot;&gt;第27期（2023-11-18）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.inngest.com/blog/python-errors-as-values&quot;&gt;将 Python 错误作为值：比较 Go 和 Rust 的使用模式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章比较了两种处理错误的方法：抛出错误和将错误作为返回值，并参照 Go 和 Rust 的处理模式，介绍如何在 Python 中实现将错误作为值返回。（附1：&lt;a href=&quot;https://frostming.com/error-handling/&quot;&gt;两种风格的错误处理&lt;/a&gt; 分析了两种风格的优缺点及其适用场景；附2：周刊第一期的 &lt;a href=&quot;https://pythoncat.top/posts/2023-05-08-error&quot;&gt;编程语言的四种错误处理方法&lt;/a&gt; 从语法、代码可读性、演变过程、运行效率角度对比了不同方案）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.better-simple.com/django/2023/11/04/debugging-csrf-error-in-production/&quot;&gt;调试 Django 中的 CSRF 失败/403 禁止错误&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;部署 Django 程序时的一个常见错误是 &lt;code&gt;403 Forbidden&lt;/code&gt; ，通常由 CSRF 错误导致，文章介绍了导致这种错误的 7 种原因，并解读 Django 源码，详细梳理了它们的校验逻辑。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://alpopkes.com/posts/python/packaging_tools/&quot;&gt;对 Python 环境和包管理工具的公正分析&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 中的虚拟环境和包管理工具实在是太多了！但是应该如何选择最适合自己需求的工具呢？作者全面分析了 5 个类别的 10 多款工具，希望减少用户在抉择上的困惑。（附：作者针对此主题的两场演讲 &lt;a href=&quot;https://www.youtube.com/watch?v=MsJjzVIVs6M&quot;&gt;PyCon DE 2023&lt;/a&gt; 和 &lt;a href=&quot;https://www.youtube.com/watch?v=3-drZY3u5vo&quot;&gt;EuroPython 2023&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://mostlynerdless.de/blog/2023/09/20/lets-create-a-python-debugger-together-part-1/&quot;&gt;让我们一起创建一个 Python 调试器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;你是否好奇一个代码调试器是如何工作的？当设置断点后，程序触发它时会发生什么？调试器是程序员日常必备工具之一，但极少有人知道它是如何实现的。这是一个系列教程，已更新 5 篇文章。值得一提的是，作者使用了最新的 Python 3.12  PEP-669 功能。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://blog.jetbrains.com/pycharm/2023/11/python-3-12/&quot;&gt;揭开 Python 3.12 的面纱：Python 世界有哪些新东西？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 3.12 已发布一个半月，你开始尝鲜了么？这篇内容全面的文章重点解读了新的几个 PEP，让你对这个版本有更清晰的认识。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://stackabuse.com/hash-tables-in-python/&quot;&gt;Python 的哈希表指南&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 的字典是一种“哈希表”，提供了高效灵活的数据存储和检索方法。文章介绍了这种数据结构及其工作原理，探讨了如何用 Python 实现哈希表并解决哈希冲突。这是一个系列文章，作者还写了堆、队列、栈、数组等数据结构的指南。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://healeycodes.com/running-untrusted-python-code&quot;&gt;运行不可信的 Python 代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者想自己实现一个简化版的不太安全的沙盒，文章介绍了它的运作方式，以及一些关键性问题的解决方案，即独立的进程 + &lt;code&gt;seccomp&lt;/code&gt; + &lt;code&gt;setrlimit&lt;/code&gt; 。（附：&lt;a href=&quot;https://www.kingname.info/2023/11/11/python-run-other-code/&quot;&gt;如何安全运行别人上传的Python代码？&lt;/a&gt; 这篇文章的方案是使用 Docker 的 Python SDK 来构建镜像，在 Docker 中执行代码）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://muhammadraza.me/2023/linux-cp/&quot;&gt;了解 Linux cp 命令并用 Python 编程实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;深入探讨了 Linux 中 &lt;code&gt;cp&lt;/code&gt; 命令的工作原理，然后用 Python 实现了一个基础版本。从中可以看到高级编程语言提供的强大功能和简单性。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://www.bitecode.dev/p/beginners-should-use-django-not-flask&quot;&gt;初学者应该用 Django，而不是 Flask&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者认为 Flask 虽然简单易用，但它可能会让初学者忽视 Web 开发的复杂性。Django 功能全面、生态系统成熟，更适合新手学习与提升生产力。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://peps.python.org/pep-0733/&quot;&gt;PEP-733：对 Python 公共 C API 的评估&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一则信息型的 PEP，用于分享 C API 的信息，包括定义 C API 的用途、利益相关者及其使用场景和要求、C API 的优势、C API 的 9 项薄弱的问题。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://arunmani.in/articles/silly-json-parser/&quot;&gt;让我们做一个类 JSON 语法的解析器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者出于编程乐趣的目的，定义了一组类似 JSON 的语法规则，然后使用 Python 逐一实现不同内容的提取与解析，开发了一个解析器。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://tratt.net/laurie/blog/2023/how_big_should_a_programming_language_be.html&quot;&gt;一门编程语言应该有多大？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在作者眼中，Python 1.5 是他能完全理解的最后一个版本，而之后的版本则使得语言越来越大。语言设计时添加新功能，如何权衡取舍？作者建议学习 C 语言的例子，让语言处于“最小进化”模式。&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/THUDM/CogVLM&quot;&gt;CogVLM：多模态预训练模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个强大的开源可视化语言模型 （VLM），CogVLM-17B 有 100 亿个视觉参数和 70 亿个语言参数，具有高性能，在多项跨模态基准测试中排名领先。（star 2.1K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/rezoo/movis&quot;&gt;movis：用于生成与编辑视频的库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;让你通过 Python 代码生成各类视频，包括但不限于演示视频、动态图形、着色器艺术编码和游戏解说视频。支持视频编辑、音频剪辑、图层转换及添加特效等。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/cocktailpeanut/mirror&quot;&gt;mirror：基于摄像头内容，实时回答问题&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个 Web APP，可将摄像头视频流传给 AI，让它分析内容并实时回答你提出的问题。100% 本地和私有，Web UI 是用 &lt;a href=&quot;https://www.gradio.app/&quot;&gt;gradio&lt;/a&gt; 构建，多模态 AI 模型是 &lt;a href=&quot;https://huggingface.co/SkunkworksAI/BakLLaVA-1&quot;&gt;Bakllava&lt;/a&gt; 。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/ishan0102/vimGPT&quot;&gt;vimGPT：使用 GPT-4V 和 Vimium 浏览网页&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Vimium&lt;/strong&gt; 是一个 Chrome 插件，可让你仅用键盘浏览网页，借助它，可以不将浏览器 DOM 传给大模型，仅用 GPT-4V 的视觉功能来浏览网页。（star 1.8K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/kaixinol/twitter_user_tweet_crawler&quot;&gt;twitter_user_tweet_crawler：无需调用 Twitter API，爬取用户推文&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用 selenium 模拟浏览器操作，可抓取用户推文并保存静态资源到本地，无需调用 Twitter API。（投稿自@kaixinol）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/AboutRSS/RSS-OPML-to-Markdown&quot;&gt;RSS-OPML-to-Markdown：将 OPML 文件转化为易读的 Markdown 格式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;经常有人分享自己 RSS 列表导出的 OPML 文件，但这难以阅读也不宜直接拿去导入自己的阅读器。这个项目将 RSS 源的概要和一些统计信息输出成 markdown 表格，方便你按需订阅。（投稿自@AboutRSS）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/AIFSH/MyHeyGen&quot;&gt;MyHeyGen：视频翻译工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个平民版视频翻译工具，音频翻译、翻译校正、视频唇纹合成全流程解决方案。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/emanuelef/awesome-python-repo-stats&quot;&gt;awesome-python-repo-stats：统计“awesome-python”列表中项目的信息&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/vinta/awesome-python&quot;&gt;awesome-python&lt;/a&gt; 是一个拥有 187K star 超火爆的项目，收录了大量框架、库、软件和资源。这个项目是对它收录内容的统计分析，每日更新，可在线查看统计表。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/outlines-dev/outlines&quot;&gt;outlines：引导式文本生成&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个用于生成神经文本的库，可视为 transformers 库中 &lt;code&gt;generate&lt;/code&gt; 方法的替代品。（star 3.3K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/marimo-team/marimo&quot;&gt;marimo：下一代 Python notebook&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;全新的 notebook 项目，其每个 notebook 都可作为交互式 Web 程序共享，可浏览数据、运行实验、构建工具和部署应用。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/shashankvemuri/Finance&quot;&gt;Finance：150+ 量化金融 Python 程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个资源集合项目，帮助你收集、操纵和分析股市数据。（star 1.2K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/amidaware/tacticalrmm&quot;&gt;tacticalrmm：一个远程监控和管理工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个远程监控和管理工具，使用 Django、Vue 和 Go 构建。类似 Teamviewer 的远程桌面控制、远程文件传输、远程执行命令和脚本、查看日志、告警管理、支持自动化。（star 2.3K）&lt;/div&gt;
&lt;h3&gt;🐢播客&amp;amp;视频&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.youtube.com/watch?v=HxSHIpEQRjs&quot;&gt;CPython 的 JIT 编译器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Guido 本周在 X 上分享了这则视频，视频作者介绍了他们规划给 Python 3.13 开发一个 JIT 编译器！（附：&lt;a href=&quot;https://github.com/brandtbucher/brandtbucher/blob/master/2023/10/10/a_jit_compiler_for_cpython.pdf&quot;&gt;演讲视频的文稿&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.blog.pythonlibrary.org/2023/11/10/episode-21-sanic-the-async-python-web-framework/&quot;&gt;The Python Show 第 21 期：Sanic - 异步 Web 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Sanic 是支持异步编程的 Python Web 框架，能够快速构建和运行。这期播客的嘉宾是 Sanic 的维护者之一，话题包括 Web 框架对比、消息规范、&lt;a href=&quot;https://github.com/ahopkins/mayim&quot;&gt;Mayim&lt;/a&gt;（单向 ORM）。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-11-25-weekly&quot;&gt;第28期（2023-11-25）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://tratt.net/laurie/blog/2023/four_kinds_of_optimisation.html&quot;&gt;四种优化程序的方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;很值得推荐的文章。正文部分介绍了优化程序的四种方法：使用更好的算法、使用更好的数据结构、使用底层的编程语言、以及接受不太精确的解决方案。文章开头和结尾则提出了一些教训：我们对于性能优化问题容易过度乐观、我们可能只顾性能而牺牲了正确性、不该作过早和复杂的优化、优化的广度比优化的深度更重要。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://pythonspeed.com/articles/two-thread-pools/&quot;&gt;两种线程池，以及为什么需要这两种线程池？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;由于 GIL 的限制，因此在 Python 中使用线程池需要注意业务是 CPU 密集型任务还是 IO 密集型任务，这将导致在线程数量和线程池目标上的不同选择。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://blog.miguelgrinberg.com/post/it-s-time-for-a-change-datetime-utcnow-is-now-deprecated&quot;&gt;是时候改变了：datetime.utcnow() 现已被弃用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 3.12 版本中&lt;code&gt;datetime.datetime&lt;/code&gt; 的 &lt;code&gt;utcnow()&lt;/code&gt; 与 &lt;code&gt;utcfromtimestamp()&lt;/code&gt; 方法已被标注为“deprecated”，将在未来版本中删除。文章介绍了它们的缺陷，解释了为什么它们会被弃用。替代的方法分别是：&lt;code&gt;datetime.now()&lt;/code&gt; 和 &lt;code&gt;datetime.fromtimestamp()&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://www.biaodianfu.com/python-web-server-deployment.html&quot;&gt;Python Web 应用的线上部署&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了如何使用 Nginx+Gunicorn+Supervisor、Nginx+uWSGI+Supervisor、Waitress、Meinheld 等不同方案部署 Flask 应用，分析了它们的优缺点。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://stefan-marr.de/2023/11/python-global-interpreter-lock/&quot;&gt;Python GIL 作出的不断变化的“保证”&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了 CPython 全局解释器锁的实现细节，介绍了从 Python 3.9 到目前 3.13 开发版之间的变化。其中有一项很大的差别，在 3.9 及早期版本，GIL 在执行很多字节码时会释放，而在 3.13 版本，只在少数字节码上检查是否释放 GIL。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://learndjango.com/tutorials/django-dependency-management-pip-compile-and-pip-t&quot;&gt;使用 pip-compile 和 pip-tools 作 Django 的依赖项管理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 的依赖管理有很多选择，文章介绍了 pip-compile 和 pip-tools 的组合方案。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://threeofwands.com/the-types-of-errors-in-python-apps/&quot;&gt;Python 程序的 bug 分类&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者将程序的 bug 分成四类：类型错误和 linting 错误、导入时异常、运行时异常、静默的错误。处理的策略是减少出现后面的错误类型，将其变为前面的错误处理。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://blog.orsinium.dev/posts/py/core-devs-typing/&quot;&gt;有多少 Python 核心开发者使用类型提示？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 的类型提示正在逐渐流行，但是，它在核心开发者群体中已经普及到什么程度了呢？作者经过分析，给出了这样的数据：所有核心开发者中，大约 53% 的人最近有开源项目，其中 39% 的人使用类型提示。近 3 年里加入团队的人中，有 76% 使用类型提示。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://juejin.cn/post/7304706387645071395&quot;&gt;记一次用 Python 的 ast 模块将 Flask 项目转为 Quart 的尝试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者为了使用 OpenAI 返回的异步迭代器内容，将不支持异步的 Flask 项目重构成了支持异步的 Quart。但手动修改的工作量太大，因此他想到通过解析 ast 来修改，提升项目转换的效率。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://solothought.com/tutorial/python-numpy/&quot;&gt;Python NumPy 库的可视化解释&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章使用了大量直观的图形展示 Numpy 数据的分布以及数据变化过程，让你轻松掌握 Numpy 数据操作。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://coady.github.io/posts/composition-vs-inheritance.html&quot;&gt;用组合还是继承？我有不同看法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;传统观点认为组合优于继承，但作者认为 Python 不能很好地支持，若教条式使用组合，只会引入问题，因此作者提供了一种简单实现的思路。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://python-bloggers.com/2023/10/choosing-the-right-data-dashboard-tool-the-unique-strengths-of-streamlit-and-shiny/&quot;&gt;选择正确的数据仪表板工具：Streamlit 和 Shiny 的独特优势&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在数据驱动关键决策的时代，交互式仪表板已成为商业、科学研究等行业不可或缺的工具。Streamlit 和 Shiny（包括 RShiny 及 PyShiny）是功能强大的框架，文章介绍了它们各自的优势。&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/abi/screenshot-to-code&quot;&gt;screenshot-to-code：利用截图生成 HTML/Tailwind/JS 代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;超级火爆的新项目，它使用 GPT-4 Vision 生成代码，使用 DALL-E 3 生成与截图相似的外观。甚至可以输入 URL 来实时克隆一个网站！（star 19.4K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/Dicklesworthstone/sqlalchemy_data_model_visualizer&quot;&gt;sqlalchemy_data_model_visualizer：将SQLalchemy数据模型转换为漂亮的SVG图表&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;将 SQLAlchemy ORM 模型生成高质量的可视化效果，使用 Graphviz 将每个模型呈现为有向图，更容易理解数据库表之间的关系。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/lastmile-ai/aiconfig&quot;&gt;aiconfig：配置驱动的 AI 应用开发框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它通过将提示、模型参数及模型密切相关的逻辑与应用代码分离，降低复杂度。SDK 是与模型无关的，可扩展到任何生成式 AI 模型。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/PythonNest/PyNest&quot;&gt;PyNest：基于 FastAPI 构建的框架，遵循 NestJS 的模块化架构&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可以让你轻松构建可扩展且可维护的 API，支持依赖注入、类型注释、装饰器和代码生成。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/yl4579/StyleTTS2&quot;&gt;StyleTTS2：近乎人类水平的文本转语音库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它利用风格扩散和对抗训练与大型语音语言模型 （SLM） 来实现人类水平的 TTS 合成。（star 2.7K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/pyjokes/pyjokes&quot;&gt;pyjokes：程序员的一句话笑话（笑话即服务） (github.com)&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;安装后，只需从命令行调用 pyjoke 或将其添加到 .bashrc 文件中，每次打开终端时都会看到一个笑话。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/pndurette/gTTS&quot;&gt;gTTS：用于与 Google 的文本转语音 API 交互&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用于调用 Google Translate 的文本转语音 API，提供可定制的语音特定的句子分词器，以及可定制的文本预处理器。（star 2K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/yuxiaoy1/chatfairy&quot;&gt;chatfairy：极简的网页版聊天室，只依赖 Flask&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;极简的聊天室应用，前后端代码在仅 115 行的单文件中，使用 SSE 作后端消息推送，不依赖websocket，支持用户认证、多用户聊天、上下线通知、路由保护。（投稿自@yuxiaoy1）&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/ObservedObserver/streamlit-shadcn-ui&quot;&gt;streamlit-shadcn-ui：在 streamlit 中使用 shadcn-ui 组件&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Streamlit 的组件选择相对局限，且样式比较古老。这个项目将前端流行的 shadcn 组件库引入到 Streamlit 当中，UI 更为美观。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/YaoFANGUK/video-subtitle-remover&quot;&gt;video-subtitle-remover：用 AI 去除图片/视频的硬字幕/水印&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可无损分辨率将视频中的硬字幕去除，生成去除字幕后的文件，利用 AI 填充原字幕区域；支持自定义字幕位置，支持全视频自动去除所有文本。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/flowtyone/flowty-realtime-lcm-canvas&quot;&gt;flowty-realtime-lcm-canvas：使用 LCM 和 gradio 库的草图到图像演示&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;将你的草稿图实时变成生动的图像，可更改 UI 中的模型 ID 来使用不同的模型。（star 1.5K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/brandon-rhodes/pyephem&quot;&gt;pyephem：科学级的天文学计算库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可执行高精度天文学计算，用于查找行星、彗星或小行星的位置，确定特定星体的位置，计算月球各阶段的日期，天文坐标系转换，确定春分和冬至的日期，等等。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-12-02-weekly&quot;&gt;第29期（2023-12-02）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://mp.weixin.qq.com/s/m-IBomxu88DlNcEyOgyOew&quot;&gt;Rust std fs 比 Python 慢！真的吗！？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇长文，由一个诡异的问题开始：Rust 写的程序竟然比 Python 慢？！作者在定位根因的过程中，多次得到 Rust 方案比 Python 慢的结果，甚至 C 版本代码也比 Python 的慢！层层深入，用上各种定位手段，最后发现竟然是 AMD CPU 内核的问题！&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.dataroc.ca/blog/most-performant-timestamp-functions-python&quot;&gt;Python 中性能最快的时间戳函数是哪个？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 中有哪些获取时间戳的函数？它们的性能表现如何？文章取了 7 种函数进行性能测算，发现 time.time() 是最快的。文章发布后引起了一些争议，于是作者写了第二篇，做了 Win10、WSL2 和 Ubuntu20 的对比，也增加了 Python 3.10 和 3.12 的对比。（附：&lt;a href=&quot;https://www.dataroc.ca/blog/most-performant-timestamp-functions-python-2&quot;&gt;第二篇性能对比的文章&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://preslav.me/2023/11/27/python-is-easy-golang-is-simple-simple-is-not-easy/&quot;&gt;Python 是 Easy，Go 是 Simple，但 Simple != Easy&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 简单易用门槛低，因为它把很多复杂的工作交给了解释器，这使得它适合用作原型设计，快速开发应用。Go 语言也简单，但相比 Python 的规则要多一些，性能也更高。作者的建议是同时发挥两者的优势。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://labs.quansight.org/blog/unlocking-c-level-performance-in-df-apply&quot;&gt;使用 Numba 提升 pandas.DataFrame.apply 的 C 级别性能&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在 Pandas 2.2.0 中，DataFrame.apply 可以指定一个新的 numba 引擎，实现并行化的操作。文章介绍了这个引擎的工作原理、它支持的应用场景及无法做到的事，同时给出了多项性能测试的数据。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://davidism.com/maintainer-notes/&quot;&gt;一份杂乱的 Flask 维护任务清单&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者是 Flask 的维护者之一，列出了一份任务清单，提供给 Flask 的贡献者们方便着手处理。我们多数人没有维护开源项目的经验，或许无法想象项目维护者们要做那一大堆与编码完全无关的事。（题外话：Flask 的 star 数在本周已落后于 FastAPI，失去了 Web 框架第二高 star 的位置）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://tonybaloney.github.io/posts/sub-interpreter-web-workers.html&quot;&gt;用子解释器运行 Python 并行程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 3.12 开放了子解释器的一个 API，它有什么用呢？子解释器与多线程、多进程有什么区别，它们的性能差距有多少？将子解释器用于 Web 开发，会有什么效果？作者用开发中的 Python 3.13 做了一些实验，结果有惊喜也有程序异常。期待明年真正无-GIL 的 Python 吧！&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://dev.to/taipy/new-open-source-vs-old-open-source-33k7&quot;&gt;新的开源库 VS. 旧的开源库 &lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章选取了 10 组在 Python 社区很知名的库，同时给出它们相对应的替代库，这里最没争议的估计是 Ruff 替代 Pylint，其它则还有：Taipy/Streamlit、Polars/Pandas、Dask/PySpark、PyTorch/TensorFlow ……&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://pythonspeed.com/articles/polars-pandas-interopability/&quot;&gt;在 Pandas 的世界中使用 Polars&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Polars 是速度更快、内存效率更高、更易于使用的数据处理库，可作为 Pandas 的替换。但是替换后如何与第三方库更好地集成呢？文章介绍了几种处理方法，实现从 Pandas 到 Polars 的无缝切换。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://mathspp.com/blog/til/pythons-soft-keywords&quot;&gt;Python 的软关键字有哪些？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;软关键字（soft keyword）指的是可以被重新赋值的关键字。作者想利用正则表达式从 Python 最新的语法文件中找出所有的软关键字。最后得知只需下面两行代码就能做到（以下是 Python 3.12 的结果，即现在有 4 个软关键字）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; keyword
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; keyword&lt;span&gt;.&lt;/span&gt;softkwlist
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;_&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;case&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;match&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;type&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;10、&lt;a href=&quot;https://blog.untrod.com/2023/11/robot-dad.html&quot;&gt;用 Python 实现机器人爸爸&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;为了应对小孩的提问，作者开发了一个“机器人爸爸”。用到了 Eleven Labs 作声音克隆，用 Picovoice 语音转文字提取唤醒词，最后调用 ChatGPT 接口获取答案。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/stickfigure/blog/wiki/How-to-(and-how-not-to)-design-REST-APIs&quot;&gt;如何（以及如何不）设计 REST API&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章列出了十多项 REST API 的最佳实践规则，解释了规则的含义及实现，另外，作者嘲笑了几家公司被广泛使用的 API，将它们作为规则的反例。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://superfastpython.com/debug-asyncio/&quot;&gt;如何调试 Asyncio 程序？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了几种调试 Asyncio 代码的方法，包括启用它的调试日志、在调试模式下运行事件循环、自定义调试信息等。（附：文章的姊妹篇 &lt;a href=&quot;https://superfastpython.com/profile-asyncio-programs/&quot;&gt;如何分析 Asyncio 程序？&lt;/a&gt; 分析慢程序和高频函数）&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/VikParuchuri/marker&quot;&gt;marker：高效将 PDF/EPUB/MOBI 转换为 Markdown&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;支持将多种文件格式转换为 markdown，可删除页眉/页脚，将方程式转换为 latex，格式化处理代码块和表格，另外也支持多种语言。（star 2.3K）（附：将整本 PDF 版《Think Python》&lt;a href=&quot;https://github.com/VikParuchuri/marker/blob/master/data/examples/marker/thinkpython.md&quot;&gt;转换后的效果&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/st3v3nmw/awesome-django-performance&quot;&gt;awesome-django-performance：精选资源，用于分析和优化 Django 项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个项目整理了一些库、工具、文章和书籍，主要集中在 profile、数据库、缓存、序列化、任务处理和监测等方面。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/koxudaxi/datamodel-code-generator&quot;&gt;datamodel-code-generator：将 JSON/YAML 转换为 Pydantic 模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个数据模型代码生成器，支持多种输入类型（OpenAPI、JSON、YAML、CSV、Python 字典、GraphQL），输出 Pydantic、dataclass、TypeDict 等类型。（star 2K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/koxudaxi/fastapi-code-generator&quot;&gt;fastapi-code-generator：用 openapi 文件创建 FastAPI 程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它利用 datamodel-code-generator 生成 pydantic 模型，基于 OpenAPI 格式的接口文件，快速生成 FastAPI 项目。支持自定义模板，允许将自定义变量传给自定义模板。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/Zaloog/kanban-python&quot;&gt;kanban-python：终端中的看板应用程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在命令行窗口中实现的看板应用工具，有漂亮的表格、配置与数据分离、可自动创建任务、可作任务跟踪。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/tobymao/saq&quot;&gt;saq：简单的异步队列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个基于 Asyncio 和 Redis 之上的简单且高性能的任务队列框架。提供有一个简单的 UI，可查看任务队列、状态及执行详情等信息。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/pyqtgraph/pyqtgraph&quot;&gt;pyqtgraph：用于科学/工程应用的数据可视化及 GUI 工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个高性能的绘图工具库，利用 Numpy 作数值运算、用 Qt 的 GraphicsView 框架作 2D 显示和 OpenGL 作 3D 显示。（star 3.5K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/beeware/toga&quot;&gt;toga：Python 原生、OS 原生的 GUI 工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个用于创建跨平台桌面应用的 GUI 工具，支持 MacOS、Windows、Linux (GTK)、Android、iOS 和单页 Web 应用。（star 3.9K）&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/autometrics-dev/autometrics-py&quot;&gt;autometrics-py：函数级的指标监测工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它提供了一个装饰器，可检测函数的请求率、错误率和延迟等指标，方便你识别和调试程序的问题。支持用 Prometheus 查询与分析、开箱即用的 Grafana 仪表板、自定义告警、运行开销小。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/pycompiled/compiled&quot;&gt;compiled：Python 标准库的编译后的变体&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 中有些标准库是用纯 Python 实现的，可能会成为性能瓶颈。这个项目将经过 mypyc 类型检查的标准库编译成 C 代码版本，比原始版本快 2-4 倍。目前已完成 tomllib 和 difflib，计划中还有 asyncio、urllib、zipfile、argparse 和 uuid。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/frostming/transpyler-gpt&quot;&gt;transpyler-gpt：GPT 驱动的 Python 转译器，让代码在旧版本上运行&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它借助 GPT 将高版本 Python 代码转译成目标环境的 Python 版本代码，实现向下兼容执行。例如将 Python 3.10+ 的 match-case 代码转译成 if-else 代码，可在更低 Python 版本中执行。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/jianchang512/clone-voice&quot;&gt;clone-voice: 一个带 web 界面的声音克隆工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;支持中文、英文、日语、韩语 4 种语言，可在线从麦克风录制声音。支持文字转语音和语音变声。（star 1.3K）&lt;/div&gt;
&lt;h3&gt;🐢播客&amp;amp;视频&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://talkpython.fm/episodes/show/439/pixi-a-fast-package-manager&quot;&gt;Talk Python To Me #439：Pixi 一个高性能的包管理器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Pixi 是用 Rust 开发的基于 Conda 的包管理器。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.blog.pythonlibrary.org/2023/11/27/episode-23-the-ruff-formatter-with-charlie-marsh/&quot;&gt;Mouse Vs Python #23：与 Charlie Marsh 聊 Ruff Formatter&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Ruff 是一个用 Rust 编写的 Python linter+formatter，而且两方面都是性能最快的。&lt;/div&gt;
&lt;h3&gt;🥂讨论&amp;amp;问题&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.reddit.com/r/Python/comments/17upt2f/whats_the_coolest_things_youve_done_with_python/&quot;&gt;你用 Python 做过最酷的事情是什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Reddit 上的热门讨论帖，也有近 700 条评论，需要刷很久才能看完。。。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://discuss.python.org/t/syntactic-sugar-to-encourage-use-of-named-arguments/36217&quot;&gt;鼓励使用命名参数的语法糖&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;函数的命名参数提高了可读性，但也可能使代码重复和冗长。作者提出了一个简化变量写法的语法糖，得到了不少核心开发者的支持。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-12-09-weekly&quot;&gt;第30期（2023-12-09）&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;🦄文章&amp;amp;教程&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pythonafrica.blogspot.com/2023/12/an-open-letter-to-python-software_5.html&quot;&gt;Python 非洲：致 Python 软件基金会的一封公开信&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;非洲十多个国家的 Python 社区组织者们联名给 PSF 的一封公开信。信件的起因是 PSF 给非洲首届 DjangoCon 的 9000 美元拨款延迟了，由此引出 PSF 内部存在的其它问题：人种歧视、对边缘群体缺乏关注、不遵守当地法律等。（题外话：PSF 在 2022 年给亚洲的拨款占比 1%，远低于给非洲的 16%……）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://docs.djangoproject.com/en/5.0/releases/5.0&quot;&gt;Django 5.0 发布了！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Django 5.0 在本周发布了，只支持 Python 3.10 及以上版本。主要新功能：新增&lt;code&gt;Field.db_default&lt;/code&gt; 参数，可设置由数据库计算的默认值；&lt;code&gt;GeneratedField&lt;/code&gt; 可以创建由数据库生成的列；引入了字段组和字段组模板，简化了表单字段相关元素的呈现。（附：一则介绍&lt;a href=&quot;https://www.youtube.com/watch?v=lPl5Q5gv9G8&quot;&gt;Django 新特性的视频&lt;/a&gt; ）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.skywind.me/blog/archives/2761&quot;&gt;56 行代码用 Python 实现一个 Flex/Lex&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Lex/Flex 可用于生成词法分析器，用于处理源代码中的词法结构。作者通过改造 Python 官方文档中的一段程序，实现了一个通用的基于规则的词法分析器，可用于处理简单的词法分析需求。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://so1n.me/2023/12/07/how-to-use-dependency-injection-in-fastapi/&quot;&gt;如何在 FastAPI 正确地使用依赖注入？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章指出了人们在 FastAPI 中使用依赖注入时的两种错误方式，介绍了如何在 FastAPI 中使用&lt;code&gt;python-dependency-injector&lt;/code&gt; 实现依赖注入的方法。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.kdnuggets.com/why-you-should-not-overuse-list-comprehensions-in-python&quot;&gt;为什么不应该在 Python 中过度使用列表解析式？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;适当使用列表解析式，可以让你的代码更简洁优雅，但是过度使用的话，将严重破坏代码的可读性。作者给出了三个例子，分别用列表解析式与常规方案实现，让读者感受到易理解的代码胜过花哨的炫技。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://lucumr.pocoo.org/2023/12/1/the-python-that-was/&quot;&gt;非类型化的 Python：曾经的 Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Flask 的作者 Armin Ronacher 在最新文章中讨论了 Python 的类型话题。核心观点认为 Python 的内在哲学在于它的动态类型，这是它的优势，这与类型化是冲突的，类型化有其价值，但也会带来成本。作者怀念曾经的 Python。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://idiomaticprogrammers.com/post/django-watson-full-text-search-guide&quot;&gt;用 django-watson 给 Django 项目添加全文搜索&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇非常详细的教程，使用 &lt;a href=&quot;https://github.com/etianen/django-watson&quot;&gt;django-watson&lt;/a&gt; 和 PostgreSQL 给 Django 项目添加全文搜索功能。这个库支持跨多个 model 进行搜索，支持按相关性排序。（star 1.2K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://www.better-simple.com/django/2023/12/06/fanout-pattern-explained/&quot;&gt;解析 Celery 的扇出模式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Celery 的扇出模式（Fanout）是一种任务分发的模式，由一个任务触发多个并行执行的子任务。作者介绍了这种模式的实践运用，认为这是在任务签名中实现动态工作流的好方法。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://superfastpython.com/asyncio-alternatives/&quot;&gt;Python Asyncio 的 7 个替代库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Asyncio 是 Python 用作异步编程的标准库，但它不是你唯一的选择。文章介绍和对比了 7 个同类的库，有比 Asyncio 更早发布的 Tornado、Twisted 及 Gevent，也有更为年轻的 Curio、Trio、AnyIO 与 UVloop。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://codeconfessions.substack.com/p/cpython-dynamic-dispatch-internals&quot;&gt;解密 CPython：当执行 a+b 时，背后发生了什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇深度剖析 CPython 解释器的动态分发机制的文章。动态分发（Dynamic Dispatch）指的是在程序运行时（而不是在编译时）确定调用哪个方法或函数的过程。a+b 看似简单，但是它们可能有多种类型组合，实际的计算过程可能完全不同。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://www.blog.pythonlibrary.org/2023/12/05/viewing-an-animated-gif-with-python/&quot;&gt;如何使用 Python 播放 GIF？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;GIF 是一种图像格式，是无声的动画视频。有什么 Python 库可以通过代码来播放 GIF 动画么？文章分别介绍了 tkinter、PySimpleGUI 和 Jupyter Notebook 这三种方式。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://bernsteinbear.com//blog/simple-python-repl/&quot;&gt;用 Python 开发一个微型的 REPL&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;REPL（Read-Eval-Print Loop）是指编程语言的交互式环境。Python 标准库中有个&lt;code&gt;code&lt;/code&gt; 模块，提供了实现 REPL 的功能，文章逐步提出需求，演示了如何用它开发一个简单的 REPL。&lt;/div&gt;
&lt;h3&gt;🐿️项目&amp;amp;资源&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/OthersideAI/self-operating-computer&quot;&gt;self-operating-computer：使多模态模型能够操作计算机&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是近期基于 GPT-4v 的最火项目之一。让大语言模型像人类一样查看屏幕内容，操作鼠标和键盘来实现特定的目标。当前的挑战是 GPT-4v 在鼠标点击位置方面的错误率很高。（star 5.1K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/frostming/marko&quot;&gt;marko：具有高扩展性的 markdown 解析器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个专注于扩展开发体验的 Markdown 解析器，遵循 CommonMark 规范 v0.30 规范。速度不是它的优势，但能方便观察 AST、实现自己的元素和渲染器。（投稿自@frostming）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/LC044/WeChatMsg&quot;&gt;WeChatMsg：导出微信聊天记录成 HTML/Word/CSV文档&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;本周火爆朋友圈的项目，作者是一名在校大学生。支持导出微信聊天记录，支持生成年度聊天报告。Slogan 不错：“我的数据我做主”。可以导出数据用于训练个人 AI！（star 12.5K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/xaoyaoo/PyWxDump&quot;&gt;PyWxDump：获取微信账号信息、导出聊天记录&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是上一个项目的依赖，可解密数据库，查看和导出聊天记录，支持微信多开场景获取多用户信息。（star 1.6K）（PS. 总感觉这两个项目会被某信针对，你觉得呢？）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/ml-explore/mlx&quot;&gt;mlx：适用于 Apple 芯片的阵列框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Apple 推出的基于自家芯片的机器学习阵列框架，拥有跟 Numpy 相近的 Python API。（star 7.2K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/SamirPaulb/DSAlgo&quot;&gt;DSAlgo：数据结构和算法的面试题集锦&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个精选仓库，收录了大量数据结构和算法题，使用 Python 解答。另外它还收录了不少大公司的面试题与计算机类学习笔记等资料。（star 1.7K）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://pythononlinecompiler.com/&quot;&gt;Python 在线编译器网站&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个网页在线版本的 Python 解释器，支持 Python 2.7、3.3-3.10 版本，预装了大部分的常用库，包括 Turtle、Tkinter、Pygame、Numpy、Matplotlib、Pandas、Scipy，等等。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/aio-libs&quot;&gt;aio-libs：65 个基于 Asyncio 的库/项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它收录了 Python 社区中与异步 IO 相关的库，包括 aiohttp、aiopg、aiomysql、yarl、aiokafka 等等。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/kolofordjango/kolo&quot;&gt;kolo：查看 Django 应用的执行过程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一款 VSCode 插件，具有帧可视化、漂亮的火焰图、显示执行了 SQL 查询的代码行、支持直接跳转到异常位置等。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/m57/dnsteal&quot;&gt;dnsteal：DNS 渗透工具，通过 DNS 请求隐秘发送文件&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个只有 200 多行代码的小工具，伪造 DNS 服务器，隐秘截取请求中的文件。支持多文件、支持 Gzip 压缩、支持自定义子域信息等。（star 1.6K）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/avgupta456/github-trends&quot;&gt;github-trends：使用自定义卡片美化 GitHub 个人主页&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可生成你在 Github 的贡献日历、代码行数分析、多种维度下的个人贡献统计图等，轻松将动态图标嵌入到你的个人资料页面中。（star 6.4K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/spipm/Depix&quot;&gt;Depix：还原打了马赛克的截图信息&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在截图上打了马赛克就安全了么？不！这个库能以较高的准确度还原图片中的纯文本信息。仓库中有技术原理解释，以及对使用缺陷的说明。（star 24.7K）&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://img.pythoncat.top/python_cat.jpg&quot;&gt;微信公众号&lt;/a&gt;：除更新周刊外，还发布其它原创作品，并转载一些优质文章。（可加好友，可加读者交流群）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://pythoncat.top&quot;&gt;博客&lt;/a&gt; 及 &lt;a href=&quot;https://pythoncat.top/rss.xml&quot;&gt;RSS&lt;/a&gt;：我的独立博客，上面有历年原创/翻译的技术文章，以及从 2009 年以来的一些随笔。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://pythoncat.substack.com&quot;&gt;邮件&lt;/a&gt; 及 &lt;a href=&quot;https://pythoncat.substack.com/feed&quot;&gt;RSS&lt;/a&gt;：在 Substack 上开通的频道，满足你通过邮件阅读时事通讯的诉求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;Github&lt;/a&gt;：你可以获取本周刊的 Markdown 源文件，做任何想做的事！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;Telegram&lt;/a&gt;：除了发布周刊的通知外，我将它视为一个“副刊”，补充发布更加丰富的资讯。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://twitter.com/chinesehuazhou&quot;&gt;Twitter&lt;/a&gt;：我的关注列表里有大量 Python 相关的开发者与组织的账号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;🐱赞助支持&lt;/h2&gt;
&lt;div&gt;如果你喜欢本周刊，欢迎分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;div&gt;内容创作要花费大量的时间和精力，如果你觉得有帮助，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt; 或 &lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊第一季完结（1~30）</title>
            <link>https://pythoncat.top/posts/2023-12-11-iweekly/</link>
            <guid>https://pythoncat.top/posts/2023-12-11-iweekly/</guid>
            <description>前30期周刊正好花了 210 天，这里给大家做一个小小的总结分享！</description>
            <pubDate>Mon, 11 Dec 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。庆祝 Python 潮流周刊在几天前顺利更新到了第 30 期！&lt;/div&gt;
&lt;div&gt;我觉得这是一个很有意义的时间节点，不太短也不漫长，很适合作一个小小的总结。&lt;/div&gt;
&lt;div&gt;我打算今后每 30 期作为一季，都给大家做一些总结和分享。&lt;/div&gt;
&lt;div&gt;首先，给大家公开一些数据吧。&lt;/div&gt;
&lt;div&gt;本季时间从 2023.05.13 到 2023.12.09，共 &lt;strong&gt;210 天&lt;/strong&gt;。曾有 1 期是加更，以及停更过 2 周，没想到时间正正好就是 7*30=210 天，太巧了！&lt;/div&gt;
&lt;div&gt;本季周刊共分享了：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;文章/教程：378 篇&lt;/li&gt;
&lt;li&gt;项目/资源：270 个&lt;/li&gt;
&lt;li&gt;播客/视频：54 则（有不少是视频列表）&lt;/li&gt;
&lt;li&gt;热门讨论：20 个&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;实际的数目远不止这些，因为周刊在分享时会提及一些相关材料和补充附录，这些内容也很多，难以一一统计，故未算入到总数中。&lt;/div&gt;
&lt;div&gt;我在多个平台上发布了周刊，阅读量更加不好统计，因此这里只公布公众号里的数据吧：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;公众号共获得 6.9 万阅读，去除最高和最低后，平均阅读量为 2100。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;总共获得 840+ 赞同数，130+ 在看数。平均每篇点赞数接近 30，这数据在技术号里我感觉挺可以自豪的！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;阅读量排名前十的分别是：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;公众号里是在文章最底部才可以点赞，因此点赞数可以很好体现读者对内容的赞许程度。&lt;/div&gt;
&lt;div&gt;点赞比例（点赞数/阅读量）最高的前十期是：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;另外比较有参考意义的是博客里的阅读量，大致能看到的数据在 1000-2000 之间。&lt;/div&gt;
&lt;div&gt;但遗憾的是我先后在三个平台上用了 umami 作统计，导致数据分割严重，无法很好地统计。&lt;/div&gt;
&lt;div&gt;（至于为何会这么折腾，这是一个十分曲折的故事，而且余波未平，等以后再细说吧……）&lt;/div&gt;
&lt;div&gt;自发布周刊以来，得到过很多小伙伴的赞赏，我仔细计算了来自周刊的微信赞赏金额共有 &lt;strong&gt;879.74 元&lt;/strong&gt;！&lt;/div&gt;
&lt;div&gt;非常感谢小伙伴们的鼎力支持，你们的心意我都收下了！&lt;/div&gt;
&lt;div&gt;另外，我还非常开心的是破天荒收到了 2 笔美元的赞赏，很有纪念意义：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;前不久，我们周刊也开始接到了第一家广告赞助。这是我第一次尝试的方式，引发了对周刊未来发展的思考，因此写了一篇《&lt;a href=&quot;https://pythoncat.top/posts/2023-12-06-future&quot;&gt;聊聊技术周刊的变现&lt;/a&gt;》。&lt;/div&gt;
&lt;div&gt;我们周刊的传统是每期内容的质量都很高，信息量充足，有一两位小伙伴反馈过，上一期内容还没消化完，新一期就来了……&lt;/div&gt;
&lt;div&gt;为了方便老读者们回看及检索，也为了方便新关注的读者从第一季内容中寻宝，我把全部 30 期周刊的正文汇总成了一篇，共 &lt;strong&gt;6.2 万字&lt;/strong&gt;！&lt;/div&gt;
&lt;div&gt;访问地址：&lt;a href=&quot;https://pythoncat.top/posts/2023-12-11-weekly&quot;&gt;https://pythoncat.top/posts/2023-12-11-weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;另外，我也制作了 PDF 版本，请在公众号“&lt;strong&gt;Python猫&lt;/strong&gt;”里发送“&lt;strong&gt;W30&lt;/strong&gt;”，获取下载链接。&lt;/div&gt;
&lt;div&gt;本次小结完毕。欢迎大家反馈问题和建议！&lt;/div&gt;
&lt;div&gt;咱们下期周刊见！&lt;/div&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#30：非洲 Python 社区给 PSF 的一封公开信</title>
            <link>https://pythoncat.top/posts/2023-12-09-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-12-09-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目</description>
            <pubDate>Sat, 09 Dec 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯。&lt;/div&gt;
&lt;h2&gt;🐱播客推荐&lt;/h2&gt;
&lt;div&gt;2023 年即将过去，给大家推荐一下我个人年度最喜爱的播客节目《&lt;a href=&quot;https://www.xiaoyuzhoufm.com/podcast/62694abdb221dd5908417d1e&quot;&gt;纵横四海&lt;/a&gt;》！！它主要分享读书，探讨个人成长/职业成长，探索如何处理感情问题等。每期都在 90 分钟以上，好几期还超过了 4 个小时，但是听了完全不会觉着冗长！&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pythonafrica.blogspot.com/2023/12/an-open-letter-to-python-software_5.html&quot;&gt;Python 非洲：致 Python 软件基金会的一封公开信&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;非洲十多个国家的 Python 社区组织者们联名给 PSF 的一封公开信。信件的起因是 PSF 给非洲首届 DjangoCon 的 9000 美元拨款延迟了，由此引出 PSF 内部存在的其它问题：人种歧视、对边缘群体缺乏关注、不遵守当地法律等。（题外话：PSF 在 2022 年给亚洲的拨款占比 1%，远低于给非洲的 16%……）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://docs.djangoproject.com/en/5.0/releases/5.0&quot;&gt;Django 5.0 发布了！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Django 5.0 在本周发布了，只支持 Python 3.10 及以上版本。主要新功能：新增&lt;code&gt;Field.db_default&lt;/code&gt; 参数，可设置由数据库计算的默认值；&lt;code&gt;GeneratedField&lt;/code&gt; 可以创建由数据库生成的列；引入了字段组和字段组模板，简化了表单字段相关元素的呈现。（附：一则介绍&lt;a href=&quot;https://www.youtube.com/watch?v=lPl5Q5gv9G8&quot;&gt;Django 新特性的视频&lt;/a&gt; ）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.skywind.me/blog/archives/2761&quot;&gt;56 行代码用 Python 实现一个 Flex/Lex&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Lex/Flex 可用于生成词法分析器，用于处理源代码中的词法结构。作者通过改造 Python 官方文档中的一段程序，实现了一个通用的基于规则的词法分析器，可用于处理简单的词法分析需求。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://so1n.me/2023/12/07/how-to-use-dependency-injection-in-fastapi/&quot;&gt;如何在 FastAPI 正确地使用依赖注入？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章指出了人们在 FastAPI 中使用依赖注入时的两种错误方式，介绍了如何在 FastAPI 中使用&lt;code&gt;python-dependency-injector&lt;/code&gt; 实现依赖注入的方法。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.kdnuggets.com/why-you-should-not-overuse-list-comprehensions-in-python&quot;&gt;为什么不应该在 Python 中过度使用列表解析式？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;适当使用列表解析式，可以让你的代码更简洁优雅，但是过度使用的话，将严重破坏代码的可读性。作者给出了三个例子，分别用列表解析式与常规方案实现，让读者感受到易理解的代码胜过花哨的炫技。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://lucumr.pocoo.org/2023/12/1/the-python-that-was/&quot;&gt;非类型化的 Python：曾经的 Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Flask 的作者 Armin Ronacher 在最新文章中讨论了 Python 的类型话题。核心观点认为 Python 的内在哲学在于它的动态类型，这是它的优势，这与类型化是冲突的，类型化有其价值，但也会带来成本。作者怀念曾经的 Python。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://idiomaticprogrammers.com/post/django-watson-full-text-search-guide&quot;&gt;用 django-watson 给 Django 项目添加全文搜索&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇非常详细的教程，使用 &lt;a href=&quot;https://github.com/etianen/django-watson&quot;&gt;django-watson&lt;/a&gt; 和 PostgreSQL 给 Django 项目添加全文搜索功能。这个库支持跨多个 model 进行搜索，支持按相关性排序。（star 1.2K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://www.better-simple.com/django/2023/12/06/fanout-pattern-explained/&quot;&gt;解析 Celery 的扇出模式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Celery 的扇出模式（Fanout）是一种任务分发的模式，由一个任务触发多个并行执行的子任务。作者介绍了这种模式的实践运用，认为这是在任务签名中实现动态工作流的好方法。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://superfastpython.com/asyncio-alternatives/&quot;&gt;Python Asyncio 的 7 个替代库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Asyncio 是 Python 用作异步编程的标准库，但它不是你唯一的选择。文章介绍和对比了 7 个同类的库，有比 Asyncio 更早发布的 Tornado、Twisted 及 Gevent，也有更为年轻的 Curio、Trio、AnyIO 与 UVloop。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://codeconfessions.substack.com/p/cpython-dynamic-dispatch-internals&quot;&gt;解密 CPython：当执行 a+b 时，背后发生了什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇深度剖析 CPython 解释器的动态分发机制的文章。动态分发（Dynamic Dispatch）指的是在程序运行时（而不是在编译时）确定调用哪个方法或函数的过程。a+b 看似简单，但是它们可能有多种类型组合，实际的计算过程可能完全不同。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://www.blog.pythonlibrary.org/2023/12/05/viewing-an-animated-gif-with-python/&quot;&gt;如何使用 Python 播放 GIF？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;GIF 是一种图像格式，是无声的动画视频。有什么 Python 库可以通过代码来播放 GIF 动画么？文章分别介绍了 tkinter、PySimpleGUI 和 Jupyter Notebook 这三种方式。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://bernsteinbear.com//blog/simple-python-repl/&quot;&gt;用 Python 开发一个微型的 REPL&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;REPL（Read-Eval-Print Loop）是指编程语言的交互式环境。Python 标准库中有个&lt;code&gt;code&lt;/code&gt; 模块，提供了实现 REPL 的功能，文章逐步提出需求，演示了如何用它开发一个简单的 REPL。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已顺利更新到第 30 期啦！我在几天前写了一篇《&lt;a href=&quot;https://pythoncat.top/posts/2023-12-06-future&quot;&gt;聊聊技术周刊的变现&lt;/a&gt;》分享了对未来发展的思考，近期也会对所有周刊再作一次总结，敬请期待！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/OthersideAI/self-operating-computer&quot;&gt;self-operating-computer：使多模态模型能够操作计算机&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是近期基于 GPT-4v 的最火项目之一。让大语言模型像人类一样查看屏幕内容，操作鼠标和键盘来实现特定的目标。当前的挑战是 GPT-4v 在鼠标点击位置方面的错误率很高。（star 5.1K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/frostming/marko&quot;&gt;marko：具有高扩展性的 markdown 解析器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个专注于扩展开发体验的 Markdown 解析器，遵循 CommonMark 规范 v0.30 规范。速度不是它的优势，但能方便观察 AST、实现自己的元素和渲染器。（投稿自@frostming）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/LC044/WeChatMsg&quot;&gt;WeChatMsg：导出微信聊天记录成 HTML/Word/CSV文档&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;本周火爆朋友圈的项目，作者是一名在校大学生。支持导出微信聊天记录，支持生成年度聊天报告。Slogan 不错：“我的数据我做主”。可以导出数据用于训练个人 AI！（star 12.5K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/xaoyaoo/PyWxDump&quot;&gt;PyWxDump：获取微信账号信息、导出聊天记录&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是上一个项目的依赖，可解密数据库，查看和导出聊天记录，支持微信多开场景获取多用户信息。（star 1.6K）（PS. 总感觉这两个项目会被某信针对，你觉得呢？）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/ml-explore/mlx&quot;&gt;mlx：适用于 Apple 芯片的阵列框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Apple 推出的基于自家芯片的机器学习阵列框架，拥有跟 Numpy 相近的 Python API。（star 7.2K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/SamirPaulb/DSAlgo&quot;&gt;DSAlgo：数据结构和算法的面试题集锦&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个精选仓库，收录了大量数据结构和算法题，使用 Python 解答。另外它还收录了不少大公司的面试题与计算机类学习笔记等资料。（star 1.7K）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://pythononlinecompiler.com/&quot;&gt;Python 在线编译器网站&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个网页在线版本的 Python 解释器，支持 Python 2.7、3.3-3.10 版本，预装了大部分的常用库，包括 Turtle、Tkinter、Pygame、Numpy、Matplotlib、Pandas、Scipy，等等。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/aio-libs&quot;&gt;aio-libs：65 个基于 Asyncio 的库/项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它收录了 Python 社区中与异步 IO 相关的库，包括 aiohttp、aiopg、aiomysql、yarl、aiokafka 等等。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/kolofordjango/kolo&quot;&gt;kolo：查看 Django 应用的执行过程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一款 VSCode 插件，具有帧可视化、漂亮的火焰图、显示执行了 SQL 查询的代码行、支持直接跳转到异常位置等。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/m57/dnsteal&quot;&gt;dnsteal：DNS 渗透工具，通过 DNS 请求隐秘发送文件&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个只有 200 多行代码的小工具，伪造 DNS 服务器，隐秘截取请求中的文件。支持多文件、支持 Gzip 压缩、支持自定义子域信息等。（star 1.6K）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/avgupta456/github-trends&quot;&gt;github-trends：使用自定义卡片美化 GitHub 个人主页&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可生成你在 Github 的贡献日历、代码行数分析、多种维度下的个人贡献统计图等，轻松将动态图标嵌入到你的个人资料页面中。（star 6.4K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/spipm/Depix&quot;&gt;Depix：还原打了马赛克的截图信息&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在截图上打了马赛克就安全了么？不！这个库能以较高的准确度还原图片中的纯文本信息。仓库中有技术原理解释，以及对使用缺陷的说明。（star 24.7K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>聊聊技术周刊的变现</title>
            <link>https://pythoncat.top/posts/2023-12-06-future/</link>
            <guid>https://pythoncat.top/posts/2023-12-06-future/</guid>
            <description>周刊天然是长期主义的，我把它每次不多的变现视为一笔基金定投，坚信只要长期持有，总会享受到复利效应的收益。</description>
            <pubDate>Wed, 06 Dec 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;看过我最近几期《&lt;a href=&quot;https://pythoncat.top/tags/weekly&quot;&gt;Python 潮流周刊&lt;/a&gt;》的同学，你们应该会注意到它们开头多了一则“产品推荐”吧？&lt;/div&gt;
&lt;div&gt;没错，这是恰饭了！我们周刊终于开张有了第一个商业赞助！撒花花～～（虽然更早的时候有与出版社合作的赠书，但那些书是给读者们的福利，严格来说不能算“恰饭”吧？）&lt;/div&gt;
&lt;div&gt;然而，在开心激动过后，想想那惨淡的“带货”数据，我又要开始发愁了。虽开张了第一家，它却难以有持续合作的希望。技术周刊的变现出路到底在哪？&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;我做了一些反思，在此要跟大家分享这一次合作赞助的故事，以及我观察到的出乎意料的现象，也聊一聊我对周刊未来商业变现的想法。&lt;/strong&gt;&lt;/div&gt;
&lt;h2&gt;一&lt;/h2&gt;
&lt;div&gt;Python 潮流周刊是深受其它周刊影响而诞生的，以后我会补上一篇本应作为开端的“创刊语”，聊聊我从其它周刊上学到的东西和自己的创作理念。&lt;/div&gt;
&lt;div&gt;这些周刊对我影响最深的一个方面是让我看到了&lt;strong&gt;文章变现的一种新形式&lt;/strong&gt;！&lt;/div&gt;
&lt;div&gt;作为一个五岁的自媒体博主，我偶尔能接到公众号里的软文推广，曾参与过卖书返佣活动，也见识过一些号主卖 xx 星球和 xx 小册，这些都是我比较熟悉的变现方式。另外，我知道国内有一些纯付费订阅的周刊，也知道一些免费订阅的（过去没留意它们如何变现）。&lt;/div&gt;
&lt;div&gt;但对我触动最深的是几个免费订阅的英文周刊里的品牌植入类赞助。比如我每周必看的几个 Python Weekly，它们每期不断的有 2-3 个赞助。这些赞助通常很契合，文案也比较友好，基本不让人反感，几乎不会影响阅读。&lt;/div&gt;
&lt;div&gt;我认为这是很完美的广告模式！周刊作者与品牌方应该是互选合作，并不是谷歌广告联盟或者公众号内文广告那种，这样一来，作者能获得相比广告联盟高的报价收入，品牌方也能以较低的投放而接触到更精准的目标群体。&lt;/div&gt;
&lt;div&gt;从创办 Python 周刊起，我就畅想将来要像那些偶像周刊一样，&lt;strong&gt;要站着恰饭，用免费加赞助的模式，持续且体面地运营下去！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;国内有没有比较成功的案例呢，让我去学习学习？我首先想到了《科技爱好者周刊》，它也是我的一个启蒙周刊，是国内技术圈里标杆级的存在。&lt;/div&gt;
&lt;div&gt;我发现当时它在周刊末尾推荐了一个生产力工具，而我也从其它途径了解过它且正在使用中，于是我就把这列为了自己第一个合作目标。（下称 F 产品）&lt;/div&gt;
&lt;div&gt;记得那时是 6 月中旬，趁着高温天气和前面几期周刊的高热度，我在发布完第 6 期后，主动出击联系了 F 产品的客服，然后是产品运营的负责人，由此开始了第一次的商务探索。&lt;/div&gt;
&lt;h2&gt;二&lt;/h2&gt;
&lt;div&gt;我失败了。&lt;/div&gt;
&lt;div&gt;没有达成自己预期要建立合作的目标。&lt;/div&gt;
&lt;div&gt;我总结当时没有合作成的原因：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;品牌方在面对我这个小透明自媒体和效果未知的邀约时，必然持有谨慎的态度，无法给出明确的方案&lt;/li&gt;
&lt;li&gt;我并没有摆正自己身份转变的位置，在几天后逐渐失去了洽谈的耐心，加上那几天其它因素干扰，突然对自己的目标变得犹犹豫豫&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;是不是时机还没到呢？要不要再等等啊，等各项数据再发展发展？&lt;/div&gt;
&lt;div&gt;我自己打起了退堂鼓。出师不利！&lt;/div&gt;
&lt;h2&gt;三&lt;/h2&gt;
&lt;div&gt;好消息出现在 11 月初。我在朋友圈发了电报频道破千的消息，F 产品的对接人 W 看到后，就来联系我。但他们不是想合作上文提到的 F 产品，只是想宣传一款 AI 工具（下称 A 产品）。&lt;/div&gt;
&lt;div&gt;我看过介绍后觉得非常契合！不到半小时，我们就达成了合作约定。三小时后，文案预览也好了。第二天一大早，公众号就发推文了！&lt;/div&gt;
&lt;div&gt;有了推文合作后。我们很快也谈好了在周刊里的合作，所以才有了文章开头说的“恰饭”！&lt;/div&gt;
&lt;div&gt;也就是说，种子是在 6 月份埋下的，5 个月后才涌现生机破土而出。这算不算是好事多磨啊？&lt;/div&gt;
&lt;div&gt;从整件事中，我得出的经验：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;机会靠自己主动发现，从同领域大佬那里寻找线索&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;失败是常有的事，机会在眼前但你可能把握不住&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持续积蓄力量并让自己的成绩被人看到&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;四&lt;/h2&gt;
&lt;div&gt;接着聊聊让人尴尬的事……&lt;/div&gt;
&lt;div&gt;周刊的阅读量处于正常水平，然而，通过我的邀请链接注册了 A 产品的人数要比预期少很多！&lt;/div&gt;
&lt;div&gt;在我的设想里，A 产品的卖点很足，尽管它是一款浏览器插件，通常需要在 PC 端上安装（手机端也有浏览器可以支持，不知道用的人多么？），但最起码该有个 1% 的安装量吧？&lt;/div&gt;
&lt;div&gt;无情的数据嘲笑了我的盲目乐观！我突然发现自己对于阅读转化率是那么的无知，以前在接培训机构的推广时，我知道数据不会很好，因为它们频繁在同类公众号中投放，早已让大部分读者免疫/厌恶。&lt;/div&gt;
&lt;div&gt;但是，这一款符合潮流的能提升个人效率的免费的 AI 工具，不该是乏人问津的待遇啊！&lt;/div&gt;
&lt;div&gt;前些天里，我耿耿于怀。现在释怀了，我想到了两个自认为挺合理的解释：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;手机端读者占了很大比重。&lt;/strong&gt; 我看到博客里统计的手机访客占比达 48%，而公众号就更不必说了。能特意记录链接再转到 PC 上访问的人，数量应该用稀少形容吧&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大家对 AI 产品早已司空见惯。&lt;/strong&gt; ChatGPT 推出刚好一年，也持续火爆了一年，AI 工具早已普及，新产品想要获客，难度可不低&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;无论如何，我们周刊总算是迈出了变现的第一步，尽管只是摇摇晃晃的一小步！&lt;/div&gt;
&lt;h2&gt;五&lt;/h2&gt;
&lt;div&gt;创作周刊是一件很消磨人的事。它所需的工序极少，无非就是：收集素材+整理素材。&lt;/div&gt;
&lt;div&gt;在信息采集方面，&lt;strong&gt;Feedly&lt;/strong&gt; 帮了我大忙，让我从 400+ 订阅源里高效获取信息；但是，随后的阅读、筛选、提炼等环节就需要耗费我大量的时间。&lt;/div&gt;
&lt;div&gt;我有时候会让 AI 做总结辅助，但经常得自己重读确认、用自己的思路做摘要以及将不同素材串联起来，所以时间几乎无法节省。&lt;/div&gt;
&lt;div&gt;然而对于我这个时常 996 的社畜，以及遭到过老婆埋怨没有多陪小孩的新手爸爸来说，时间是种稀缺资源。&lt;/div&gt;
&lt;div&gt;以前写文章时，拖稿两三周是常有的事，有时也会因为精力分散就弃稿了。可是周刊带有&lt;strong&gt;时间承诺的属性&lt;/strong&gt;，我对自己的要求也是尽量按期交付，因此只能加班加点。&lt;/div&gt;
&lt;div&gt;紧张更新后，休息一两天，很快又得进入新一轮的筹备环节。&lt;/div&gt;
&lt;div&gt;整个过程有点像西西弗斯循环往复推石头上山的感觉。&lt;/div&gt;
&lt;h2&gt;六&lt;/h2&gt;
&lt;div&gt;我不想做一份草草放弃的周刊，为了抵消时间和精力的投入，就需要获得一些正向的能量以让自己坚持不懈。&lt;/div&gt;
&lt;div&gt;我比较在意的回报有两类，而且希望能同时得到，&lt;strong&gt;一类是关注量、阅读量、star 数、点赞量等等数据带来的精神鼓舞，另一类是广告/恰饭带来的实实在在的金钱。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;回到周刊变现的话题，因为第一类回报，所以我不打算做私密性周刊，不打算用订阅制，不打算收会员费；因为第二类回报，所以我会坚持探索挣钱之道。&lt;/div&gt;
&lt;div&gt;两相结合，我们周刊想走的显然是免费加赞助的模式，正是英文榜样周刊最开始触动我的模式。&lt;/div&gt;
&lt;div&gt;周刊不同于其它内容，它&lt;strong&gt;有时间规律&lt;/strong&gt;，一个星期是一个节点，一期内容是一颗积木，以缓慢却可预期的节奏延伸和积攒，需要拉长时间维度才能看清拼起来的全貌。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;周刊天然是长期主义的，我把它每次不多的变现视为一笔基金定投，坚信只要长期持有，总会享受到复利效应的收益。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;涓涓细流，长长流水（出自《左传》）。细小的水流，最终汇聚成为长长的河流。&lt;/div&gt;
&lt;div&gt;这些就是我对于周刊未来商业变现的思考。&lt;/div&gt;
&lt;div&gt;路漫漫其修远兮，吾将上下而求索。与诸君共勉！&lt;/div&gt;
&lt;div&gt;最后，如果你对文中的周刊感兴趣，可通过以下方式订阅：&lt;/div&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#29：Rust 会比 Python 慢？！</title>
            <link>https://pythoncat.top/posts/2023-12-02-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-12-02-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目，2 则播客，2 个热门讨论</description>
            <pubDate>Sat, 02 Dec 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯。&lt;/div&gt;
&lt;h2&gt;🐱产品推荐&lt;/h2&gt;
&lt;div&gt;&lt;a href=&quot;https://flowus.cn/login?code=MX4369&quot;&gt;FlowUs 息流&lt;/a&gt;是新一代知识管理与协作平台，支持云文档、多维表、文件夹、团队空间，提供 100+ 模板，可用于管理笔记、安排计划、文档协作、制作个人主页等。猫哥邀请你一起使用 FlowUs 提升个人生产力：&lt;a href=&quot;https://flowus.cn/login?code=MX4369&quot;&gt;https://flowus.cn/login?code=MX4369&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://mp.weixin.qq.com/s/m-IBomxu88DlNcEyOgyOew&quot;&gt;Rust std fs 比 Python 慢！真的吗！？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇长文，由一个诡异的问题开始：Rust 写的程序竟然比 Python 慢？！作者在定位根因的过程中，多次得到 Rust 方案比 Python 慢的结果，甚至 C 版本代码也比 Python 的慢！层层深入，用上各种定位手段，最后发现竟然是 AMD CPU 内核的问题！&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.dataroc.ca/blog/most-performant-timestamp-functions-python&quot;&gt;Python 中性能最快的时间戳函数是哪个？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 中有哪些获取时间戳的函数？它们的性能表现如何？文章取了 7 种函数进行性能测算，发现 time.time() 是最快的。文章发布后引起了一些争议，于是作者写了第二篇，做了 Win10、WSL2 和 Ubuntu20 的对比，也增加了 Python 3.10 和 3.12 的对比。（附：&lt;a href=&quot;https://www.dataroc.ca/blog/most-performant-timestamp-functions-python-2&quot;&gt;第二篇性能对比的文章&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://preslav.me/2023/11/27/python-is-easy-golang-is-simple-simple-is-not-easy/&quot;&gt;Python 是 Easy，Go 是 Simple，但 Simple != Easy&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 简单易用门槛低，因为它把很多复杂的工作交给了解释器，这使得它适合用作原型设计，快速开发应用。Go 语言也简单，但相比 Python 的规则要多一些，性能也更高。作者的建议是同时发挥两者的优势。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://labs.quansight.org/blog/unlocking-c-level-performance-in-df-apply&quot;&gt;使用 Numba 提升 pandas.DataFrame.apply 的 C 级别性能&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在 Pandas 2.2.0 中，DataFrame.apply 可以指定一个新的 numba 引擎，实现并行化的操作。文章介绍了这个引擎的工作原理、它支持的应用场景及无法做到的事，同时给出了多项性能测试的数据。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://davidism.com/maintainer-notes/&quot;&gt;一份杂乱的 Flask 维护任务清单&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者是 Flask 的维护者之一，列出了一份任务清单，提供给 Flask 的贡献者们方便着手处理。我们多数人没有维护开源项目的经验，或许无法想象项目维护者们要做那一大堆与编码完全无关的事。（题外话：Flask 的 star 数在本周已落后于 FastAPI，失去了 Web 框架第二高 star 的位置）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://tonybaloney.github.io/posts/sub-interpreter-web-workers.html&quot;&gt;用子解释器运行 Python 并行程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 3.12 开放了子解释器的一个 API，它有什么用呢？子解释器与多线程、多进程有什么区别，它们的性能差距有多少？将子解释器用于 Web 开发，会有什么效果？作者用开发中的 Python 3.13 做了一些实验，结果有惊喜也有程序异常。期待明年真正无-GIL 的 Python 吧！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://dev.to/taipy/new-open-source-vs-old-open-source-33k7&quot;&gt;新的开源库 VS. 旧的开源库 &lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章选取了 10 组在 Python 社区很知名的库，同时给出它们相对应的替代库，这里最没争议的估计是 Ruff 替代 Pylint，其它则还有：Taipy/Streamlit、Polars/Pandas、Dask/PySpark、PyTorch/TensorFlow ……&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://pythonspeed.com/articles/polars-pandas-interopability/&quot;&gt;在 Pandas 的世界中使用 Polars&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Polars 是速度更快、内存效率更高、更易于使用的数据处理库，可作为 Pandas 的替换。但是替换后如何与第三方库更好地集成呢？文章介绍了几种处理方法，实现从 Pandas 到 Polars 的无缝切换。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://mathspp.com/blog/til/pythons-soft-keywords&quot;&gt;Python 的软关键字有哪些？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;软关键字（soft keyword）指的是可以被重新赋值的关键字。作者想利用正则表达式从 Python 最新的语法文件中找出所有的软关键字。最后得知只需下面两行代码就能做到（以下是 Python 3.12 的结果，即现在有 4 个软关键字）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; keyword
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; keyword&lt;span&gt;.&lt;/span&gt;softkwlist
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;_&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;case&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;match&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;type&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;10、&lt;a href=&quot;https://blog.untrod.com/2023/11/robot-dad.html&quot;&gt;用 Python 实现机器人爸爸&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;为了应对小孩的提问，作者开发了一个“机器人爸爸”。用到了 Eleven Labs 作声音克隆，用 Picovoice 语音转文字提取唤醒词，最后调用 ChatGPT 接口获取答案。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/stickfigure/blog/wiki/How-to-(and-how-not-to)-design-REST-APIs&quot;&gt;如何（以及如何不）设计 REST API&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章列出了十多项 REST API 的最佳实践规则，解释了规则的含义及实现，另外，作者嘲笑了几家公司被广泛使用的 API，将它们作为规则的反例。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://superfastpython.com/debug-asyncio/&quot;&gt;如何调试 Asyncio 程序？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了几种调试 Asyncio 代码的方法，包括启用它的调试日志、在调试模式下运行事件循环、自定义调试信息等。（附：文章的姊妹篇 &lt;a href=&quot;https://superfastpython.com/profile-asyncio-programs/&quot;&gt;如何分析 Asyncio 程序？&lt;/a&gt; 分析慢程序和高频函数）&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/VikParuchuri/marker&quot;&gt;marker：高效将 PDF/EPUB/MOBI 转换为 Markdown&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;支持将多种文件格式转换为 markdown，可删除页眉/页脚，将方程式转换为 latex，格式化处理代码块和表格，另外也支持多种语言。（star 2.3K）（附：将整本 PDF 版《Think Python》&lt;a href=&quot;https://github.com/VikParuchuri/marker/blob/master/data/examples/marker/thinkpython.md&quot;&gt;转换后的效果&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/st3v3nmw/awesome-django-performance&quot;&gt;awesome-django-performance：精选资源，用于分析和优化 Django 项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个项目整理了一些库、工具、文章和书籍，主要集中在 profile、数据库、缓存、序列化、任务处理和监测等方面。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/koxudaxi/datamodel-code-generator&quot;&gt;datamodel-code-generator：将 JSON/YAML 转换为 Pydantic 模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个数据模型代码生成器，支持多种输入类型（OpenAPI、JSON、YAML、CSV、Python 字典、GraphQL），输出 Pydantic、dataclass、TypeDict 等类型。（star 2K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/koxudaxi/fastapi-code-generator&quot;&gt;fastapi-code-generator：用 openapi 文件创建 FastAPI 程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它利用 datamodel-code-generator 生成 pydantic 模型，基于 OpenAPI 格式的接口文件，快速生成 FastAPI 项目。支持自定义模板，允许将自定义变量传给自定义模板。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/Zaloog/kanban-python&quot;&gt;kanban-python：终端中的看板应用程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在命令行窗口中实现的看板应用工具，有漂亮的表格、配置与数据分离、可自动创建任务、可作任务跟踪。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/tobymao/saq&quot;&gt;saq：简单的异步队列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个基于 Asyncio 和 Redis 之上的简单且高性能的任务队列框架。提供有一个简单的 UI，可查看任务队列、状态及执行详情等信息。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/pyqtgraph/pyqtgraph&quot;&gt;pyqtgraph：用于科学/工程应用的数据可视化及 GUI 工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个高性能的绘图工具库，利用 Numpy 作数值运算、用 Qt 的 GraphicsView 框架作 2D 显示和 OpenGL 作 3D 显示。（star 3.5K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/beeware/toga&quot;&gt;toga：Python 原生、OS 原生的 GUI 工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个用于创建跨平台桌面应用的 GUI 工具，支持 MacOS、Windows、Linux (GTK)、Android、iOS 和单页 Web 应用。（star 3.9K）&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/autometrics-dev/autometrics-py&quot;&gt;autometrics-py：函数级的指标监测工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它提供了一个装饰器，可检测函数的请求率、错误率和延迟等指标，方便你识别和调试程序的问题。支持用 Prometheus 查询与分析、开箱即用的 Grafana 仪表板、自定义告警、运行开销小。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/pycompiled/compiled&quot;&gt;compiled：Python 标准库的编译后的变体&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 中有些标准库是用纯 Python 实现的，可能会成为性能瓶颈。这个项目将经过 mypyc 类型检查的标准库编译成 C 代码版本，比原始版本快 2-4 倍。目前已完成 tomllib 和 difflib，计划中还有 asyncio、urllib、zipfile、argparse 和 uuid。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/frostming/transpyler-gpt&quot;&gt;transpyler-gpt：GPT 驱动的 Python 转译器，让代码在旧版本上运行&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它借助 GPT 将高版本 Python 代码转译成目标环境的 Python 版本代码，实现向下兼容执行。例如将 Python 3.10+ 的 match-case 代码转译成 if-else 代码，可在更低 Python 版本中执行。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/jianchang512/clone-voice&quot;&gt;clone-voice: 一个带 web 界面的声音克隆工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;支持中文、英文、日语、韩语 4 种语言，可在线从麦克风录制声音。支持文字转语音和语音变声。（star 1.3K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://talkpython.fm/episodes/show/439/pixi-a-fast-package-manager&quot;&gt;Talk Python To Me #439：Pixi 一个高性能的包管理器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Pixi 是用 Rust 开发的基于 Conda 的包管理器。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.blog.pythonlibrary.org/2023/11/27/episode-23-the-ruff-formatter-with-charlie-marsh/&quot;&gt;Mouse Vs Python #23：与 Charlie Marsh 聊 Ruff Formatter&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Ruff 是一个用 Rust 编写的 Python linter+formatter，而且两方面都是性能最快的。&lt;/div&gt;
&lt;h2&gt;🥂讨论&amp;amp;问题&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.reddit.com/r/Python/comments/17upt2f/whats_the_coolest_things_youve_done_with_python/&quot;&gt;你用 Python 做过最酷的事情是什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Reddit 上的热门讨论帖，也有近 700 条评论，需要刷很久才能看完。。。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://discuss.python.org/t/syntactic-sugar-to-encourage-use-of-named-arguments/36217&quot;&gt;鼓励使用命名参数的语法糖&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;函数的命名参数提高了可读性，但也可能使代码重复和冗长。作者提出了一个简化变量写法的语法糖，得到了不少核心开发者的支持。&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#28：两种线程池、四种优化程序的方法</title>
            <link>https://pythoncat.top/posts/2023-11-25-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-11-25-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目</description>
            <pubDate>Sat, 25 Nov 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯。&lt;/div&gt;
&lt;h2&gt;🐱产品推荐&lt;/h2&gt;
&lt;div&gt;&lt;strong&gt;Walles.AI&lt;/strong&gt; 是一款适用于所有网站的浏览器插件，支持 GPT4 问答、ChatPDF、网页内容解释及翻译、生成高质量文章、与 Notion 等工具协同、在线摘要 Youtube 视频等。立即前往官网，免费使用（请在 PC 端访问）：&lt;a href=&quot;https://walles.ai?invite_code=CGZP5W&quot;&gt;安装地址&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://tratt.net/laurie/blog/2023/four_kinds_of_optimisation.html&quot;&gt;四种优化程序的方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;很值得推荐的文章。正文部分介绍了优化程序的四种方法：使用更好的算法、使用更好的数据结构、使用底层的编程语言、以及接受不太精确的解决方案。文章开头和结尾则提出了一些教训：我们对于性能优化问题容易过度乐观、我们可能只顾性能而牺牲了正确性、不该作过早和复杂的优化、优化的广度比优化的深度更重要。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://pythonspeed.com/articles/two-thread-pools/&quot;&gt;两种线程池，以及为什么需要这两种线程池？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;由于 GIL 的限制，因此在 Python 中使用线程池需要注意业务是 CPU 密集型任务还是 IO 密集型任务，这将导致在线程数量和线程池目标上的不同选择。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://blog.miguelgrinberg.com/post/it-s-time-for-a-change-datetime-utcnow-is-now-deprecated&quot;&gt;是时候改变了：datetime.utcnow() 现已被弃用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 3.12 版本中&lt;code&gt;datetime.datetime&lt;/code&gt; 的 &lt;code&gt;utcnow()&lt;/code&gt; 与 &lt;code&gt;utcfromtimestamp()&lt;/code&gt; 方法已被标注为“deprecated”，将在未来版本中删除。文章介绍了它们的缺陷，解释了为什么它们会被弃用。替代的方法分别是：&lt;code&gt;datetime.now()&lt;/code&gt; 和 &lt;code&gt;datetime.fromtimestamp()&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://www.biaodianfu.com/python-web-server-deployment.html&quot;&gt;Python Web 应用的线上部署&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了如何使用 Nginx+Gunicorn+Supervisor、Nginx+uWSGI+Supervisor、Waitress、Meinheld 等不同方案部署 Flask 应用，分析了它们的优缺点。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://stefan-marr.de/2023/11/python-global-interpreter-lock/&quot;&gt;Python GIL 作出的不断变化的“保证”&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了 CPython 全局解释器锁的实现细节，介绍了从 Python 3.9 到目前 3.13 开发版之间的变化。其中有一项很大的差别，在 3.9 及早期版本，GIL 在执行很多字节码时会释放，而在 3.13 版本，只在少数字节码上检查是否释放 GIL。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://learndjango.com/tutorials/django-dependency-management-pip-compile-and-pip-t&quot;&gt;使用 pip-compile 和 pip-tools 作 Django 的依赖项管理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 的依赖管理有很多选择，文章介绍了 pip-compile 和 pip-tools 的组合方案。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://threeofwands.com/the-types-of-errors-in-python-apps/&quot;&gt;Python 程序的 bug 分类&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者将程序的 bug 分成四类：类型错误和 linting 错误、导入时异常、运行时异常、静默的错误。处理的策略是减少出现后面的错误类型，将其变为前面的错误处理。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://blog.orsinium.dev/posts/py/core-devs-typing/&quot;&gt;有多少 Python 核心开发者使用类型提示？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 的类型提示正在逐渐流行，但是，它在核心开发者群体中已经普及到什么程度了呢？作者经过分析，给出了这样的数据：所有核心开发者中，大约 53% 的人最近有开源项目，其中 39% 的人使用类型提示。近 3 年里加入团队的人中，有 76% 使用类型提示。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://juejin.cn/post/7304706387645071395&quot;&gt;记一次用 Python 的 ast 模块将 Flask 项目转为 Quart 的尝试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者为了使用 OpenAI 返回的异步迭代器内容，将不支持异步的 Flask 项目重构成了支持异步的 Quart。但手动修改的工作量太大，因此他想到通过解析 ast 来修改，提升项目转换的效率。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://solothought.com/tutorial/python-numpy/&quot;&gt;Python NumPy 库的可视化解释&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章使用了大量直观的图形展示 Numpy 数据的分布以及数据变化过程，让你轻松掌握 Numpy 数据操作。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://coady.github.io/posts/composition-vs-inheritance.html&quot;&gt;用组合还是继承？我有不同看法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;传统观点认为组合优于继承，但作者认为 Python 不能很好地支持，若教条式使用组合，只会引入问题，因此作者提供了一种简单实现的思路。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://python-bloggers.com/2023/10/choosing-the-right-data-dashboard-tool-the-unique-strengths-of-streamlit-and-shiny/&quot;&gt;选择正确的数据仪表板工具：Streamlit 和 Shiny 的独特优势&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在数据驱动关键决策的时代，交互式仪表板已成为商业、科学研究等行业不可或缺的工具。Streamlit 和 Shiny（包括 RShiny 及 PyShiny）是功能强大的框架，文章介绍了它们各自的优势。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁我会在 &lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt; 分享很多不收录在周刊里的内容，目前已有 1200+ 同学关注，欢迎你的加入！&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/abi/screenshot-to-code&quot;&gt;screenshot-to-code：利用截图生成 HTML/Tailwind/JS 代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;超级火爆的新项目，它使用 GPT-4 Vision 生成代码，使用 DALL-E 3 生成与截图相似的外观。甚至可以输入 URL 来实时克隆一个网站！（star 19.4K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/Dicklesworthstone/sqlalchemy_data_model_visualizer&quot;&gt;sqlalchemy_data_model_visualizer：将SQLalchemy数据模型转换为漂亮的SVG图表&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;将 SQLAlchemy ORM 模型生成高质量的可视化效果，使用 Graphviz 将每个模型呈现为有向图，更容易理解数据库表之间的关系。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/lastmile-ai/aiconfig&quot;&gt;aiconfig：配置驱动的 AI 应用开发框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它通过将提示、模型参数及模型密切相关的逻辑与应用代码分离，降低复杂度。SDK 是与模型无关的，可扩展到任何生成式 AI 模型。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/PythonNest/PyNest&quot;&gt;PyNest：基于 FastAPI 构建的框架，遵循 NestJS 的模块化架构&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可以让你轻松构建可扩展且可维护的 API，支持依赖注入、类型注释、装饰器和代码生成。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/yl4579/StyleTTS2&quot;&gt;StyleTTS2：近乎人类水平的文本转语音库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它利用风格扩散和对抗训练与大型语音语言模型 （SLM） 来实现人类水平的 TTS 合成。（star 2.7K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/pyjokes/pyjokes&quot;&gt;pyjokes：程序员的一句话笑话（笑话即服务）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;安装后，只需从命令行调用 pyjoke 或将其添加到 .bashrc 文件中，每次打开终端时都会看到一个笑话。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/pndurette/gTTS&quot;&gt;gTTS：用于与 Google 的文本转语音 API 交互&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用于调用 Google Translate 的文本转语音 API，提供可定制的语音特定的句子分词器，以及可定制的文本预处理器。（star 2K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/yuxiaoy1/chatfairy&quot;&gt;chatfairy：极简的网页版聊天室，只依赖 Flask&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;极简的聊天室应用，前后端代码在仅 115 行的单文件中，使用 SSE 作后端消息推送，不依赖websocket，支持用户认证、多用户聊天、上下线通知、路由保护。（投稿自@yuxiaoy1）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/ObservedObserver/streamlit-shadcn-ui&quot;&gt;streamlit-shadcn-ui：在 streamlit 中使用 shadcn-ui 组件&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Streamlit 的组件选择相对局限，且样式比较古老。这个项目将前端流行的 shadcn 组件库引入到 Streamlit 当中，UI 更为美观。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/YaoFANGUK/video-subtitle-remover&quot;&gt;video-subtitle-remover：用 AI 去除图片/视频的硬字幕/水印&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可无损分辨率将视频中的硬字幕去除，生成去除字幕后的文件，利用 AI 填充原字幕区域；支持自定义字幕位置，支持全视频自动去除所有文本。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/flowtyone/flowty-realtime-lcm-canvas&quot;&gt;flowty-realtime-lcm-canvas：使用 LCM 和 gradio 库的草图到图像演示&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;将你的草稿图实时变成生动的图像，可更改 UI 中的模型 ID 来使用不同的模型。（star 1.5K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/brandon-rhodes/pyephem&quot;&gt;pyephem：科学级的天文学计算库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可执行高精度天文学计算，用于查找行星、彗星或小行星的位置，确定特定星体的位置，计算月球各阶段的日期，天文坐标系转换，确定春分和冬至的日期，等等。&lt;/div&gt;
&lt;div&gt;本文首发于：&lt;a href=&quot;https://pythoncat.top/posts/2023-11-25-weekly&quot;&gt;https://pythoncat.top/posts/2023-11-25-weekly&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#27：应该如何处理程序的错误？</title>
            <link>https://pythoncat.top/posts/2023-11-18-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-11-18-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目，2 则视频</description>
            <pubDate>Sat, 18 Nov 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯。&lt;/div&gt;
&lt;h2&gt;🐱产品推荐&lt;/h2&gt;
&lt;div&gt;&lt;strong&gt;Walles.AI&lt;/strong&gt; 是一款适用于所有网站的浏览器插件，支持 GPT4 问答、ChatPDF、网页内容解释及翻译、生成高质量文章、与 Notion 等工具协同、在线摘要 Youtube 视频等。前往官网体验：&lt;a href=&quot;https://walles.ai?invite_code=CGZP5W&quot;&gt;安装地址&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.inngest.com/blog/python-errors-as-values&quot;&gt;将 Python 错误作为值：比较 Go 和 Rust 的使用模式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章比较了两种处理错误的方法：抛出错误和将错误作为返回值，并参照 Go 和 Rust 的处理模式，介绍如何在 Python 中实现将错误作为值返回。（附1：&lt;a href=&quot;https://frostming.com/error-handling/&quot;&gt;两种风格的错误处理&lt;/a&gt; 分析了两种风格的优缺点及其适用场景；附2：周刊第一期的 &lt;a href=&quot;https://pythoncat.top/posts/2023-05-08-error&quot;&gt;编程语言的四种错误处理方法&lt;/a&gt; 从语法、代码可读性、演变过程、运行效率角度对比了不同方案）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.better-simple.com/django/2023/11/04/debugging-csrf-error-in-production/&quot;&gt;调试 Django 中的 CSRF 失败/403 禁止错误&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;部署 Django 程序时的一个常见错误是 &lt;code&gt;403 Forbidden&lt;/code&gt; ，通常由 CSRF 错误导致，文章介绍了导致这种错误的 7 种原因，并解读 Django 源码，详细梳理了它们的校验逻辑。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://alpopkes.com/posts/python/packaging_tools/&quot;&gt;对 Python 环境和包管理工具的公正分析&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 中的虚拟环境和包管理工具实在是太多了！但是应该如何选择最适合自己需求的工具呢？作者全面分析了 5 个类别的 10 多款工具，希望减少用户在抉择上的困惑。（附：作者针对此主题的两场演讲 &lt;a href=&quot;https://www.youtube.com/watch?v=MsJjzVIVs6M&quot;&gt;PyCon DE 2023&lt;/a&gt; 和 &lt;a href=&quot;https://www.youtube.com/watch?v=3-drZY3u5vo&quot;&gt;EuroPython 2023&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://mostlynerdless.de/blog/2023/09/20/lets-create-a-python-debugger-together-part-1/&quot;&gt;让我们一起创建一个 Python 调试器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;你是否好奇一个代码调试器是如何工作的？当设置断点后，程序触发它时会发生什么？调试器是程序员日常必备工具之一，但极少有人知道它是如何实现的。这是一个系列教程，已更新 5 篇文章。值得一提的是，作者使用了最新的 Python 3.12  PEP-669 功能。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://blog.jetbrains.com/pycharm/2023/11/python-3-12/&quot;&gt;揭开 Python 3.12 的面纱：Python 世界有哪些新东西？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 3.12 已发布一个半月，你开始尝鲜了么？这篇内容全面的文章重点解读了新的几个 PEP，让你对这个版本有更清晰的认识。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://stackabuse.com/hash-tables-in-python/&quot;&gt;Python 的哈希表指南&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 的字典是一种“哈希表”，提供了高效灵活的数据存储和检索方法。文章介绍了这种数据结构及其工作原理，探讨了如何用 Python 实现哈希表并解决哈希冲突。这是一个系列文章，作者还写了堆、队列、栈、数组等数据结构的指南。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://healeycodes.com/running-untrusted-python-code&quot;&gt;运行不可信的 Python 代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者想自己实现一个简化版的不太安全的沙盒，文章介绍了它的运作方式，以及一些关键性问题的解决方案，即独立的进程 + &lt;code&gt;seccomp&lt;/code&gt; + &lt;code&gt;setrlimit&lt;/code&gt; 。（附：&lt;a href=&quot;https://www.kingname.info/2023/11/11/python-run-other-code/&quot;&gt;如何安全运行别人上传的Python代码？&lt;/a&gt; 这篇文章的方案是使用 Docker 的 Python SDK 来构建镜像，在 Docker 中执行代码）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://muhammadraza.me/2023/linux-cp/&quot;&gt;了解 Linux cp 命令并用 Python 编程实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;深入探讨了 Linux 中 &lt;code&gt;cp&lt;/code&gt; 命令的工作原理，然后用 Python 实现了一个基础版本。从中可以看到高级编程语言提供的强大功能和简单性。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://www.bitecode.dev/p/beginners-should-use-django-not-flask&quot;&gt;初学者应该用 Django，而不是 Flask&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者认为 Flask 虽然简单易用，但它可能会让初学者忽视 Web 开发的复杂性。Django 功能全面、生态系统成熟，更适合新手学习与提升生产力。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://peps.python.org/pep-0733/&quot;&gt;PEP-733：对 Python 公共 C API 的评估&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一则信息型的 PEP，用于分享 C API 的信息，包括定义 C API 的用途、利益相关者及其使用场景和要求、C API 的优势、C API 的 9 项薄弱的问题。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://arunmani.in/articles/silly-json-parser/&quot;&gt;让我们做一个类 JSON 语法的解析器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者出于编程乐趣的目的，定义了一组类似 JSON 的语法规则，然后使用 Python 逐一实现不同内容的提取与解析，开发了一个解析器。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://tratt.net/laurie/blog/2023/how_big_should_a_programming_language_be.html&quot;&gt;一门编程语言应该有多大？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在作者眼中，Python 1.5 是他能完全理解的最后一个版本，而之后的版本则使得语言越来越大。语言设计时添加新功能，如何权衡取舍？作者建议学习 C 语言的例子，让语言处于“最小进化”模式。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;PyCon China 2023&lt;/strong&gt;🎁今年国内 PyCon 将于 12 月在北京、上海、成都、杭州、重庆、深圳、广州联动举办。现在购票可享 7 折优惠：&lt;a href=&quot;https://mp.weixin.qq.com/s/lfrFoIiNuUYzgXPklQPLmg&quot;&gt;详情介绍&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/THUDM/CogVLM&quot;&gt;CogVLM：多模态预训练模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个强大的开源可视化语言模型 （VLM），CogVLM-17B 有 100 亿个视觉参数和 70 亿个语言参数，具有高性能，在多项跨模态基准测试中排名领先。（star 2.1K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/rezoo/movis&quot;&gt;movis：用于生成与编辑视频的库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;让你通过 Python 代码生成各类视频，包括但不限于演示视频、动态图形、着色器艺术编码和游戏解说视频。支持视频编辑、音频剪辑、图层转换及添加特效等。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/cocktailpeanut/mirror&quot;&gt;mirror：基于摄像头内容，实时回答问题&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个 Web APP，可将摄像头视频流传给 AI，让它分析内容并实时回答你提出的问题。100% 本地和私有，Web UI 是用 &lt;a href=&quot;https://www.gradio.app/&quot;&gt;gradio&lt;/a&gt; 构建，多模态 AI 模型是 &lt;a href=&quot;https://huggingface.co/SkunkworksAI/BakLLaVA-1&quot;&gt;Bakllava&lt;/a&gt; 。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/ishan0102/vimGPT&quot;&gt;vimGPT：使用 GPT-4V 和 Vimium 浏览网页&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Vimium&lt;/strong&gt; 是一个 Chrome 插件，可让你仅用键盘浏览网页，借助它，可以不将浏览器 DOM 传给大模型，仅用 GPT-4V 的视觉功能来浏览网页。（star 1.8K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/kaixinol/twitter_user_tweet_crawler&quot;&gt;twitter_user_tweet_crawler：无需调用 Twitter API，爬取用户推文&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用 selenium 模拟浏览器操作，可抓取用户推文并保存静态资源到本地，无需调用 Twitter API。（投稿自@kaixinol）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/AboutRSS/RSS-OPML-to-Markdown&quot;&gt;RSS-OPML-to-Markdown：将 OPML 文件转化为易读的 Markdown 格式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;经常有人分享自己 RSS 列表导出的 OPML 文件，但这难以阅读也不宜直接拿去导入自己的阅读器。这个项目将 RSS 源的概要和一些统计信息输出成 markdown 表格，方便你按需订阅。（投稿自@AboutRSS）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/AIFSH/MyHeyGen&quot;&gt;MyHeyGen：视频翻译工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个平民版视频翻译工具，音频翻译、翻译校正、视频唇纹合成全流程解决方案。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/emanuelef/awesome-python-repo-stats&quot;&gt;awesome-python-repo-stats：统计“awesome-python”列表中项目的信息&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/vinta/awesome-python&quot;&gt;awesome-python&lt;/a&gt; 是一个拥有 187K star 超火爆的项目，收录了大量框架、库、软件和资源。这个项目是对它收录内容的统计分析，每日更新，可在线查看统计表。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/outlines-dev/outlines&quot;&gt;outlines：引导式文本生成&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个用于生成神经文本的库，可视为 transformers 库中 &lt;code&gt;generate&lt;/code&gt; 方法的替代品。（star 3.3K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/marimo-team/marimo&quot;&gt;marimo：下一代 Python notebook&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;全新的 notebook 项目，其每个 notebook 都可作为交互式 Web 程序共享，可浏览数据、运行实验、构建工具和部署应用。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/shashankvemuri/Finance&quot;&gt;Finance：150+ 量化金融 Python 程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个资源集合项目，帮助你收集、操纵和分析股市数据。（star 1.2K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/amidaware/tacticalrmm&quot;&gt;tacticalrmm：一个远程监控和管理工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个远程监控和管理工具，使用 Django、Vue 和 Go 构建。类似 Teamviewer 的远程桌面控制、远程文件传输、远程执行命令和脚本、查看日志、告警管理、支持自动化。（star 2.3K）&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.youtube.com/watch?v=HxSHIpEQRjs&quot;&gt;CPython 3.13 的 JIT 编译器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Guido 本周在 X 上分享了这则视频，视频作者介绍了他们规划给 Python 3.13 开发一个 JIT 编译器！（附：&lt;a href=&quot;https://github.com/brandtbucher/brandtbucher/blob/master/2023/10/10/a_jit_compiler_for_cpython.pdf&quot;&gt;演讲视频的文稿&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.blog.pythonlibrary.org/2023/11/10/episode-21-sanic-the-async-python-web-framework/&quot;&gt;The Python Show 第 21 期：Sanic - 异步 Web 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Sanic 是支持异步编程的 Python Web 框架，能够快速构建和运行。这期播客的嘉宾是 Sanic 的维护者之一，话题包括 Web 框架对比、消息规范、&lt;a href=&quot;https://github.com/ahopkins/mayim&quot;&gt;Mayim&lt;/a&gt;（单向 ORM）。&lt;/div&gt;
&lt;div&gt;本文首发于：&lt;a href=&quot;https://pythoncat.top/posts/2023-11-18-weekly&quot;&gt;https://pythoncat.top/posts/2023-11-18-weekly&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#26：requests3 的现状</title>
            <link>https://pythoncat.top/posts/2023-11-11-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-11-11-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目，1 则视频和 4 期播客</description>
            <pubDate>Sat, 11 Nov 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。本周刊开源，欢迎&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;投稿&lt;/a&gt;。另有&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;电报频道&lt;/a&gt;作为副刊，补充发布更加丰富的资讯。&lt;/div&gt;
&lt;h2&gt;🐱品牌赞助&lt;/h2&gt;
&lt;div&gt;本周刊由“&lt;strong&gt;Python猫&lt;/strong&gt;”出品，这是一个以 Python 技术科普和分享为主的科技自媒体，欢迎关注同名公众号。品牌合作请私信联系。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://kennethreitz.org/essays/why-im-not-collaborating-with-kenneth-reitz&quot;&gt;Kenneth Reitz：迟来的道歉，以及 requests 3 的进展&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;2019 年时 requests 3 的筹款闹出了不小的风波，后来似乎没什么消息。现在作者发了一篇道歉文，看来项目是要重启了！文中列举了目前已经完成的一些事情，包括给所有公开接口加上了类型提示、重构所有命名空间和调整成兼容异步编程等。（附：筹款风波之《&lt;a href=&quot;https://vorpus.org/blog/why-im-not-collaborating-with-kenneth-reitz/&quot;&gt;Why I’m not collaborating with Kenneth Reitz&lt;/a&gt;》）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://coderslegacy.com/python-grequests-making-asynchronous-http-requests/&quot;&gt;grequests：异步的 HTTP 请求&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;grequests&lt;/code&gt; 构建在 &lt;code&gt;gevent&lt;/code&gt; 库之上，可以并发多个请求，有效利用异步编程的强大功能。这篇基础教程介绍了它的基本使用方法，以及一个提升性能的建议。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://mathspp.com/blog/tag:bpci&quot;&gt;开发一个 Python 编译器和解释器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一系列博文，目前已更新 6 篇，目标是探索和研究实现 Python 等编程语言所需的概念和算法，将会涉及分词器、解析器、编译器和解释器。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://levelup.gitconnected.com/build-an-ai-tool-to-summarize-books-instantly-828680c1ceb4&quot;&gt;使用 Python+ChatGPT 开发一个书籍摘要 AI&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇教程，用 Python、Langchain 和 OpenAI embedding 开发一个书籍摘要工具。另外，作者使用 Streamlit 发布了一个&lt;a href=&quot;https://gptsummarizer.streamlit.app/&quot;&gt;在线体验网站&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.paulox.net/2023/11/07/database-generated-columns-part-1-django-and-sqlite/&quot;&gt;数据库生成的列 ：Django &amp;amp; SQLite&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;GeneratedField&lt;/code&gt; 是正在开发的 Django 5.0 的新功能，利用数据库的能力自动计算数据列的值。作者是 Django 的贡献者，测试了在 SQLite 中使用这个新功能的各种场景。（附：这篇文章还介绍了一些 &lt;a href=&quot;https://fly.io/django-beats/new-goodies-in-django-50/&quot;&gt;Django 5.0 中的新东西&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://martinheinz.dev/blog/106&quot;&gt;你能用 Python 的 bisect 模块做到这些事&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;bisect&lt;/code&gt; 模块只有两个函数，但可以做很多事，文章介绍了：二分搜索、前缀搜索、在列表中查找连续的相等值、查找字典中最接近的键、自定义对象的排序、按照字典 key 搜索。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://labs.quansight.org/blog/building-scipy-with-flang&quot;&gt;为什么说在 Windows 上为 Python 3.12 构建的 SciPy 是一个小奇迹？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;每当 Python 发布新版本时，三方库的维护者们也要紧锣密鼓开发兼容的对应版本，这不是轻松的事。作者介绍了他们遇到的严峻挑战，其实就是 Python 社区老大难的打包问题。好在维护者们已经找到了适用的解决方案。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://serpapi.com/blog/web-scraping-and-parsing-experiment-with-ai-openai/&quot;&gt;使用 AI 进行网页抓取实验（使用 GPT-4 解析 HTML）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;OpenAI 发布了新的模型，它的能力到底如何呢？使用 GPT-4 作网页抓取，具有哪些优点和缺点呢？文章分别实验了抓取结构良好的网站、抓取 Google 自然搜索结果、抓取 Google SERP、以及抓取 Google MAPS 结果。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://blog.jetbrains.com/pycharm/2023/11/django-vs-flask-which-is-the-best-python-web-framework/&quot;&gt;Django vs Flask：哪个是最好的 Python Web 框架？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 圈最为流行的两大 Web 框架，到底应该如何取舍呢？这是一篇细致的长文，详细对比了它们在模板系统、URL 调度器、数据库支持、身份验证及授权、测试、软件架构、学习曲线等方面的差异。没有更好的，只有是否适合你的。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://marvelousmlops.substack.com/p/the-right-way-to-install-python-on&quot;&gt;在 Mac 上安装 Python 的正确方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何在新的 M2 MacBook 上安装 Python 呢？这篇手把手的指导教程中，作者给出的建议是 &lt;strong&gt;Pyenv + pyenv-virtualenv&lt;/strong&gt; 。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://www.techbeamers.com/simple-android-data-analytics-app-in-python/&quot;&gt;用 Python 开发简单的 Android 数据分析应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这篇教程指导你开发一个 Android 数据分析应用，其作用是记录和显示你全天在屏幕上花费的时间。使用的 GUI 框架是&lt;code&gt;kivy&lt;/code&gt; ，数据分析使用了&lt;code&gt;Pandas&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://labs.quansight.org/blog/numpy-python-api-cleanup&quot;&gt;改进 Numpy 的 Python API，为 2.0 版本准备&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;NEP-52 是 Numpy 的一则增强提案，旨在识别 Numpy 中过时、重复和弃用的 Python API，并作重构优化。这项工作是为了顺利迁移到 Numpy 2.0 而做的准备。作者介绍了他在其中遇到的挑战和取得的部分成就。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python开发者调查&lt;/strong&gt;🎁官方第七次开发者调查，旨在了解 Python 开发社区的现状，鼓励你花费几分钟来填写：&lt;a href=&quot;https://survey.alchemer.com/s3/7554174/python-developers-survey-2023&quot;&gt;填写地址&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/jianchang512/pyvideotrans&quot;&gt;pyvideotrans：视频的语言翻译，并添加配音&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个视频翻译工具，可将一种语言的视频翻译为另一种语言和配音的视频。（star 1.4K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/google/pyink&quot;&gt;pyink：Google 内部修改 Black 而成的代码格式化工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;由 Black 派生而成，用于解决 Google 数千名工程师在 monorepo 上工作产生的问题。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/tiangolo/sqlmodel&quot;&gt;sqlmodel：Python 中的 SQL 数据库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;由 FastAPI 作者开源的 SQL 数据库，结合了 SQLAlchemy 和 Pydantic，旨在实现简单性、兼容性和稳健性。（star 11.2K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/wagtail/wagtail&quot;&gt;wagtail：一个 Django 内容管理系统&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个专注于用户体验的后台管理系统，上期分享了关于“&lt;a href=&quot;https://www.coderedcorp.com/blog/why-is-the-django-admin-ugly/&quot;&gt;Django Admin 丑陋&lt;/a&gt;”的文章，wagtail 是可提供给终端用户使用的最佳推荐。（star 16.2K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/kyleskom/NBA-Machine-Learning-Sports-Betting&quot;&gt;NBA-Machine-Learning-Sports-Betting：使用机器学习的 NBA 比赛预测&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个机器学习 AI，用于预测 NBA 比赛胜负。包含 2007-08 赛季到本赛季的所有球队数据。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/FarhaKousar1601/Python_EBook_Free&quot;&gt;Python_EBook_Free：Python 电子书和资源&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个仓库归档了一些 Python 电子书和学习资源，都是 PDF 格式。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/pathwaycom/pathway&quot;&gt;pathway：高吞吐量和低延迟实时数据处理框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个数据处理框架，结合了 LLM 程序的批处理、流式处理和实时 API，可与各种数据源交互（如 Kafka、CSV 文件、SQL/noSQL 数据库和 REST API）。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/PrefectHQ/prefect&quot;&gt;prefect：一个工作流编排工具，构建数据管道&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它是数据密集型工作流的编排器，可将 Python 函数转换为可观察和编排的工作单元。支持自动重试、分布式执行、调度、缓存等功能，拥有强大的仪表板进行监控。（star 13.2K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/AILab-CVC/VideoCrafter&quot;&gt;VideoCrafter：生成高质量视频模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个支持高清晰度的视频生成和编辑工具，目前包括文字生成视频及图片生成视频两种模型。（star 3K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://madza.hashnode.dev/42-developer-resources-to-kickstart-your-coding-journey&quot;&gt;程序员值得看的 42 个学习资源&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这篇文章收集了一系列基础资源、课程和教程、编码游戏、书籍、播客、YouTube 频道、最佳实践等等。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/networkx/networkx&quot;&gt;networkx：Python 的网络分析库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用于创建、操作和研究复杂网络的结构、动力学和功能，适用于复杂网络的分析。（star 13.4K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/jgu-bytes/PythonFrameworks&quot;&gt;PythonFrameworks：Python 的各种框架汇总&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个项目收录了 Python 中的各种框架，有 Web 框架、API 框架、CMS、ML&amp;amp;DL&amp;amp;AI、任务/消息队列、并行&amp;amp;分布式计算、工作流&amp;amp;管道、DevOps、爬虫、GUI&amp;amp;TUI，等等。提供有一个&lt;a href=&quot;https://pythonframeworks.com/&quot;&gt;在线网站&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://podcasters.spotify.com/pod/show/corepy&quot;&gt;core.py：一档新的 Python 播客&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;由 Python 核心开发者 Pablo Galindo 和 Łukasz Langa 主理的播客，已推出两期节目：&lt;a href=&quot;https://podcasters.spotify.com/pod/show/corepy/episodes/Episode-1---Core-Sprint-in-Brno--Python-3-13-0-alpha-1-e2apebk&quot;&gt;核心开发者 Sprint 及 Python 3.13.0 alpha 1&lt;/a&gt;、&lt;a href=&quot;https://podcasters.spotify.com/pod/show/corepy/episodes/Episode-2---PEP-703-Removing-the-GIL-e2b8egi&quot;&gt;PEP-703：移除 GIL&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.youtube.com/watch?v=Tml94je2edk&quot;&gt;为什么静态类型又流行起来了？ &lt;/a&gt;&lt;/div&gt;
&lt;div&gt;上世纪 90 年代诞生的 Python、Ruby、PHP 和 JavaScript 这些动态编程语言都在拥抱静态类型（mypy、Sorbet、Hack 和 TypeScript），诞生不算久的 Go、Kotlin、Dart 和 Rust 等都是静态类型。为什么静态类型卷土重来？这对未来意味着什么？&lt;/div&gt;
&lt;div&gt;3、《Boost your Git DX》作者的两期播客&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://twitter.com/AdamChainz&quot;&gt;Adam Johnson&lt;/a&gt; 新书《提升你的 Git 开发者体验》上市后，分别参加了&lt;a href=&quot;https://realpython.com/podcasts/rpp/179/&quot;&gt;Real Python Podcast #179&lt;/a&gt; 和 &lt;a href=&quot;https://pybit.es/articles/maximizing-your-dx-with-adam-johnson/&quot;&gt;Pybites #139&lt;/a&gt; 两期播客节目。&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#25：性能最快的代码格式化工具 Ruff！</title>
            <link>https://pythoncat.top/posts/2023-11-04-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-11-04-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目</description>
            <pubDate>Sat, 04 Nov 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。标题取自其中一则分享，不代表全部内容都是该主题，特此声明。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://astral.sh/blog/the-ruff-formatter&quot;&gt;Ruff：一款极其快、兼容 Black 的 Python 格式化工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;我在今年 4 月份介绍过 &lt;a href=&quot;https://pythoncat.top/posts/2023-04-09-ruff&quot;&gt;性能最快的代码分析工具&lt;/a&gt; Ruff，当时发现它不局限于 Linter 的定位，还提供了部分 Formatter 的功能。现在，它发布了重大更新，正式成为性能最快的 Python 代码格式化工具，比 &lt;strong&gt;Black&lt;/strong&gt; 快 30 倍以上，比 &lt;strong&gt;YAPF&lt;/strong&gt; 快 100 倍！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://pythonspeed.com/articles/upgrade-python-3.12/&quot;&gt;你应该什么时候升级到 Python 3.12？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 3.12 已经发布了，你是否迫切想要升级了呢？现在是最佳的升级到 3.12 的时候么？文章建议你等到 12 月，等发布 3.12.1 错误修复版本后，因为新版本存在这些问题：不兼容的软件包、缺少二进制包、每次大版本总有大量的问题要修复。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.manjusaka.blog/posts/2023/10/29/the-most-important-thing-in-python-3-12/&quot;&gt;Python 3.12：一个被人忽略的史诗级版本&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者认为 3.12 对于 Python 的意义，大于 3.5 的“async/await” 和 3.6 的 “Type Hint” 对于 Python 的意义！主要分析了三个方面提升：PEP-669 带来的可观测性、PEP-684 为 non-GIL 带来的性能提升、PEP-697 全新 C API 保证跨版本兼容性。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://quanttype.net/posts/2023-10-31-do-not-use-requirements.txt.html&quot;&gt;不要再用 requirements.txt 了&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者给了两个建议：不要使用 pip 和 &lt;code&gt;requirements.txt&lt;/code&gt; 来管理 Python 依赖项，推荐使用 Poetry。pip 的主要问题是没有 lockfile 和手工管理虚拟环境麻烦。除了 Poetry，作者也提及了 Hatch 和 PDM。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.coderedcorp.com/blog/why-is-the-django-admin-ugly/&quot;&gt;为什么 Django 后台管理系统那么“丑陋”？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Django 提供了一个默认的后台管理系统，即 Django Admin，它的 UI 很多年没有变化，显得设计过时了。为什么 Django 维护者们不改善它呢？作者通过询问多位维护者，得出了它的历史及如此设计的原因，主要观点是 Django Admin 面向内部管理员，不应该暴露给终端用户。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://gregoryszorc.com/blog/2023/10/30/my-user-experience-porting-off-setup.py/&quot;&gt;我迁移弃用 setup.py 的糟糕体验&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PyOxidizer 作者的一篇长文，他在将 Python 3.12 用于另一个库时，CI 运行&lt;code&gt;python setup.py&lt;/code&gt; 提示 setuptools 无法导入。作者在寻求解决方案时，发现 Python 的打包生态非常让人困惑，他经历了一系列复杂而耗时的过程。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://realpython.com/ptpython-shell/&quot;&gt;使用 Ptpython 提高你的编码效率&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Ptpython 是一个功能丰富且对用户友好的 Python REPL，这是一篇非常详细的使用教程。重点介绍的功能包括历史记录、输入验证、自动补全、自动处理缩进、自定义交互式 shell、在脚本中嵌入 ptpython 等。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://blog.robertroskam.com/p/100-test-coverage-is-not-enough&quot;&gt;100%的测试覆盖率是不够的：Python 中基于属性的测试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;测试覆盖率固然重要，但这项指标并不足以解决所有问题。文章通过示例揭示测试覆盖率的不足，简单介绍了如何用 Hypothesis  作基于属性的测试。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://www.cnblogs.com/hanabi-cnblogs/p/17792740.html&quot;&gt;从零开始编写一个 Python 异步 ASGI Web 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;从零开始编写一个异步 ASGI Web 框架难么？需要了解哪些知识、实现哪些功能、思考哪些问题？这篇循序渐进的教程是很好的学习材料，让你了解 Web 框架设计、异步编程、功能封装与项目管理。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://www.cnblogs.com/frankming/p/17762591.html&quot;&gt;Python 如何在日志中隐藏明文密码？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;不在日志中打印明文密码是安全需求，但是有太多可能出现打印密码的情况，如何能高效地隐藏明文密码呢？文章介绍了基于 &lt;strong&gt;logging&lt;/strong&gt; 模块的两种实现方案：自定义 filter 和自定义 formatter，使用特定规则过滤明文密码。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://monadical.com/posts/from-chaos-to-cohesion.html&quot;&gt;从混沌到凝聚：构建你自己的 Monorepo&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;monorepo 是将所有项目都放到一个代码仓管理，可能包含不同语言和框架。这意味着对它的依赖管理和 CI/CD 等都与普通代码仓不同。文章介绍如何使用 GitHub Actions 作为 CI/CD 工具构建简单的 Python monorepo。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://eddieantonio.ca/blog/2023/10/25/python-is-a-compiled-language/&quot;&gt;Python 是一种编译型语言&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;我们通常习惯将 Python 称为一种解释型语言，因为它在运行时逐行解释和执行代码。很多人还知道 Python 其实也有编译的过程，解释器会先编译再执行。然而作者不止步于此，他通过苏格拉底式对话和几轮实验，引导读者重新思考“解释”与“编译”：它们是错误的二分法、限制了编程语言的可能性。Python 既是解释型语言，也是编译型语言！&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已免费发布了 25 期，访问下方链接，即可查看全部内容：&lt;a href=&quot;https://pythoncat.top/tags/weekly&quot;&gt;https://pythoncat.top/tags/weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;周末不休息，又更新了一期周刊，我想明天喝杯奶茶了~~&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/ccxt/ccxt&quot;&gt;ccxt：加密货币交易 API，支持 100 多个交易所&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用于加密货币交易的 JavaScript/Python/PHP/C# 库，支持许多比特币/以太币/山寨币交易市场和商家 API。（star 29.5K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/pauloxnet/uDjango&quot;&gt;uDjango：单文件的 Django 微型项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个项目是 DjangoCon US 2023 的演示项目，使用单文件不到 10 行代码，演示一个最小的 Django 应用。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/dymmond/esmerald&quot;&gt;esmerald：高度可扩展、高性能的 Web 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于 Starlette 和 Pydantic 之上构建的开箱即用的 Web 框架，用于构建现代可扩展的 API 应用，支持同步和异步，提供 DAO、ORM、ODM、依赖注入、权限管理等功能。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/laike9m/Python-Type-Challenges&quot;&gt;Python-Type-Challenges：通过在线挑战来学习 Python 类型提示&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个很有意思的项目，它包含从初级到高级的一系列挑战题目，让你在线练习 type hint 的使用。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/mify-io/mify&quot;&gt;mify：微服务基础架构，代码生成工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可生成 OpenAPI http 服务端，内置 Prometheus 指标，提供结构化日志记录，支持多种语言代码生成。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/Fadi002/de4py&quot;&gt;de4py：Python 逆向工程工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一款高级的 Python 反混淆器，面向恶意软件分析师和逆向工程师，它拥有精美的 UI 和一些高级功能。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/public-apis-dev/public-apis&quot;&gt;public-apis：面向开发者的公共 API 列表&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;非常非常丰富的公共 API 清单，内容应有尽有。（star 2K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/alibaba-damo-academy/FunASR&quot;&gt;FunASR：端到端语音识别工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;阿里达摩院开源的语音识别工具包，功能包括语音识别（ASR）、语音端点检测（VAD）、标点恢复、语言模型、说话人验证、说话人分离和多人对话语音识别等。（star 1.2K）&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/JoeanAmier/XHS_Downloader&quot;&gt;XHS_Downloader: 小红书图文/视频作品采集工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;支持采集和下载小红书图文/视频作品，支持批量下载，有作品文件完整性处理机制。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/yinan-c/RSS-GPT&quot;&gt;RSS-GPT：使用 ChatGPT 为你的 RSS 订阅源生成摘要&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用 GitHub workflow 自动运行一个简单的 Python 脚本，调用 OpenAI API 为 RSS 订阅源生成摘要，然后将新生成的 RSS 订阅源推送到 GitHub Pages。配置简单快速，无需服务器。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/codespell-project/codespell&quot;&gt;codespell：检查代码是否存在常见拼写错误&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用于检查源代码中拼写错误的单词，支持多种运行方式，可指定忽略单词和文件，可用于 pre-commit。（star 1.5K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/WisdomShell/codeshell&quot;&gt;codeshell：多语言代码大模型基座&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;具有 70 亿参数，在五千亿 Tokens 进行了训练，上下文窗口长度为 8192。在权威的代码评估Benchmark 上，CodeShell 取得同等规模最好的性能。（star 1.2K）&lt;/div&gt;
&lt;h2&gt;🐱赞助&amp;amp;支持&lt;/h2&gt;
&lt;div&gt;如果你喜欢周刊，请分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有价值，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt; 或 &lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！&lt;/div&gt;
&lt;div&gt;如果你想帮助周刊办得更好，欢迎向我们投稿或提出建议：&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly/issues/new&quot;&gt;投稿/建议通道&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你是品牌方或广告主，欢迎私信我，洽谈赞助与合作事项。&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#24：no-GIL 提案正式被采纳了！</title>
            <link>https://pythoncat.top/posts/2023-10-29-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-10-29-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，12 个开源项目，3 则音视频</description>
            <pubDate>Sun, 29 Oct 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。标题取自其中两则分享，不代表全部内容都是该主题，特此声明。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://lwn.net/Articles/947138/&quot;&gt;PEP-703 无 GIL CPython 的进展&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PEP-703 是 no-GIL 项目形成的提案，就在本周，Python 指导委员会宣布采纳了这个提案！这篇文章写于消息宣布的两周前，总结了过去一段时间里发生的技术思考和进展。（附：&lt;a href=&quot;https://discuss.python.org/t/pep-703-making-the-global-interpreter-lock-optional/22606/123&quot;&gt;PEP-703 的讨论&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://peps.python.org/pep-0730/&quot;&gt;PEP-730 CPython 提供对 iOS 的官方支持&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个新提案，建议 CPython 提供对 iOS 系统的 Tier 3 级支持。如果提案被采纳，则 Python 将会有更广泛的使用。 &lt;a href=&quot;https://beeware.org/&quot;&gt;BeeWare&lt;/a&gt; 和 &lt;a href=&quot;https://kivy.org/&quot;&gt;Kivy&lt;/a&gt; 是支持 iOS 的 Python APP 开发框架，说明了技术的可行性。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.pythoncentral.io/the-next-step-in-django-development-advanced-features-to-consider/&quot;&gt;Django 进阶：开发高级的功能&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章探讨在 Django 应用中集成一些高级的特性，例如：实现所见即所得编辑器、用户认证授权、实时通信功能、异步任务、集成 Elasticsearch 作全文搜索、自动化测试与持续集成。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://testdriven.io/blog/developing-an-asynchronous-task-queue-in-python/&quot;&gt;在 Python 中开发异步的任务队列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了使用 multiprocessing.Pool、multiprocessing.Queue 和 Redis 实现简单的任务队列，实现基础的任务调度处理。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://pgjones.dev/blog/flask-ecosystem-compatibility-2023/&quot;&gt;Flask、它的生态和向后兼容性&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;上期周刊分享了一则吐槽 Flask 向后兼容性不好的文章（见下），这篇是对它的回应，作者是 Flask 的维护者之一。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://blog.miguelgrinberg.com/post/some-more-to-talk-about-flask&quot;&gt;继续关于 Flask 的讨论&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是上周《&lt;a href=&quot;https://blog.miguelgrinberg.com/post/we-have-to-talk-about-flask&quot;&gt;我们必须聊聊 Flask&lt;/a&gt;》的后续，作者收到了一些正面和反面的回应，文章延续了之前的话题，并主要反驳了一些观点。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://prefix.dev/blog/introducing_rip&quot;&gt;介绍 rip - 快速而简约的 pip 实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;rip 是用 Rust 开发的 PyPI 包解析及安装库，即 Rust 版本 pip。它试图在 Conda 和 PyPI 间架起一座坚固的桥梁，文章介绍它为了克服这两者的主要区别（元数据提取、Wheel 文件元数据、依赖项规范）而做的一些工作。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://willcrichton.net/notes/k-corrset/&quot;&gt;使用 Rust 将数据分析速度提高 180,000 倍&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何使用 Rust 实现关键代码来提升 Python 程序的性能？文章从多个方面优化 k-CorrSet 问题的实现，得到了很高的速度提升。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://www.pythonmorsels.com/lambda-expressions/&quot;&gt;什么是 lambda 表达式？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;什么是 lambda 表达式和 lambda 函数？lambda 函数与 Python 的其它函数有何不同？它有什么局限性、什么时候应该避免使用、通常使用在什么场景？&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://juejin.cn/post/7293420609088798731&quot;&gt;手撸个视频翻译和配音工具玩玩 结果不太妙&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;视频翻译是对原始语言的视频处理后，显示为其它语言的字幕及配音。文章是一个低成本的尝试，技术栈：语音识别使用 openai-whisper 离线模型、文字翻译使用 Google 接口、文字合成语音使用 Microsoft Edge tts。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://alex-jacobs.com/posts/fastapitests/&quot;&gt;掌握使用 FastAPI 进行集成测试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;集成测试是指将各个代码单元作为一个整体进行测试。文章介绍基于 FastAPI 的集成测试方法，包括如何模拟身份验证、如何模拟外部 API、如何模拟 MangoDB 相关操作、如何模拟 AWS S3。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://www.biaodianfu.com/latexify-python.html&quot;&gt;Python 代码转为 LATEX 公式工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;latexify_py 是一个 Google 开源的 Python 包，可以将 Python 源代码片段编译为相应的 LaTeX 表达式。文章介绍了它的使用方法，包括如何将 Python 函数转为公式、Latexify 参数设定、Latexify 生成伪代码。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已免费发布了 24 期，访问下方链接，即可查看全部内容：&lt;a href=&quot;https://pythoncat.top/tags/weekly&quot;&gt;https://pythoncat.top/tags/weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有价值，请表达小小心意，赞赏一下猫哥吧~~&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/celery/celery&quot;&gt;celery：分布式任务队列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 中比较成熟的任务队列库，支持 RabbitMQ、Redis 等中间件，很容易与主流 Web 框架集成。（star 22.4K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/rq/rq&quot;&gt;rq：简单的任务队列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;RQ（Redis Queue）是基于 Redis 的任务作业库，使用门槛低，支持排队、定时、重试等功能。（star 9.2K）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/coleifer/huey&quot;&gt;huey：轻量级的任务队列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;简单轻量级的任务队列库，支持 Redis、SQLite、文件系统和内存存储，支持多进程、多线程或 Greenlet 任务执行模型。（star 4.7K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/prefix-dev/rip&quot;&gt;rip：快速解决和安装 Python 包（Rust 版 pip）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用 Rust 实现的 pip，支持下载、解析和安装 PyPI 包，支持 wheel （部分支持），计划将 sdist 文件。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/mherrmann/selenium-python-helium&quot;&gt;Selenium-python-helium：Web 自动化库，让 Selenium 更好用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Selenium 是 Web 自动化的最优库之一，Helium 是在其基础上的封装，使 Web 自动化更为方便。除了高级 API，它还简化了 Web 驱动管理、支持与嵌套的 iFrame 中元素交互、支持隐式等待、支持显式等待。（star 3.6K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/sinaatalay/rendercv&quot;&gt;rendercv：用 YAML/JSON 文件创建 PDF 格式的简历&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它支持解析 YAML 及 JSON 文件的简历，创建 latex 文件，然后渲染成 PDF 格式。目前仅有一款主题。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/google/latexify_py&quot;&gt;latexify_py：用 Python 代码生成 LaTeX 表达式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可以将 Python 源码或 AST 编译为 LaTex，使用 IPython 来漂亮地打印编译的函数。（star 6.5K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/danielgross/localpilot&quot;&gt;localpilot：Mac 上的 Github Copilot&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在 Macbook 本机上使用的编程助手，配置及使用非常简易。（star 2.6K）&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/spotify/annoy&quot;&gt;annoy：C++/Python 的近似最近邻搜索&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用于搜索空间中靠近给定查询点的点，与其它同类库的最大不同是可使用静态文件作为索引，可实现跨进程共享索引。被 Spotify 用作音乐推荐。（star 12.1K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/spotify/voyager&quot;&gt;voyager：用于 Python 和 Java 的近似邻搜索库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可对内存中的向量集合执行快速的近似最近邻搜索。也是出自 Spotify，每天被查询数亿次，扛得住海量用户的请求。召回率比 annoy 高。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/codefuse-ai/Test-Agent&quot;&gt;Test-Agent：国内首个测试行业大模型工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它旨在构建测试领域的“智能体”，融合大模型和质量领域工程化技术，促进质量技术代系升级。开源了测试领域模型 TestGPT-7B，该模型以 CodeLlama-7B 为基座。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/waymo-research/waymax&quot;&gt;waymax：用于自动驾驶研究的基于 JAX 的模拟器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Waymo 是 Google 旗下的自动驾驶公司，Waymax 是其开源的轻量级、多智能体、基于 JAX 的自动驾驶模拟器，可轻松分发和部署在 GPU 和 TPU 等硬件加速器上。&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.youtube.com/watch?v=jXlR0Icvvh8&quot;&gt;Python 的代码生成：拆解 Jinja&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Jinja 的主要作者 Armin Ronacher 在 2012 年的演讲视频，介绍了 Jinja 编译器基础结构的设计，为什么这样设计，以及不同版本的迭代发展过程。（附：&lt;a href=&quot;https://speakerdeck.com/mitsuhiko/code-generation-in-python-dismantling-jinja&quot;&gt;演讲的 PPT&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.youtube.com/watch?v=rHmljD-oZrY&quot;&gt;让我们聊一聊模板&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Armin Ronacher 在 2014 年的演讲视频，比较了 Jinja 和 Django 的模板，分析它们产生截然不同设计的历史原因。（附：&lt;a href=&quot;https://speakerdeck.com/mitsuhiko/lets-talk-about-templates&quot;&gt;演讲的 PPT&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.youtube.com/playlist?list=PL_1BH3ug7n1Ih_Yy2TmM7MZ2zogSLZvzE&quot;&gt;JupyterCon 2023 视频 86 个&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;JupyterCon 是一个专注于 Jupyter 应用和工具的年度活动，包括数据科学、机器学习、科学计算、数据可视化、教育和科学研究等领域。&lt;/div&gt;
&lt;h2&gt;🐱赞助&amp;amp;支持&lt;/h2&gt;
&lt;div&gt;如果你喜欢周刊，请分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有价值，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt; 或 &lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！&lt;/div&gt;
&lt;div&gt;如果你想帮助周刊办得更好，欢迎向我们投稿或提出建议：&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly/issues/new&quot;&gt;投稿/建议通道&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你是品牌方或广告主，欢迎私信我，洽谈赞助与合作事项。&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#23：35 个容易上手的 Python 小项目</title>
            <link>https://pythoncat.top/posts/2023-10-22-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-10-22-weekly/</guid>
            <description>用于Python学习和Python应聘工作，有什么Python项目可推荐的？</description>
            <pubDate>Sun, 22 Oct 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。标题取自其中两则分享，不代表全部内容都是该主题，特此声明。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://dev.to/praise002/20-exciting-python-project-ideas-3la9&quot;&gt;20 个令人兴奋的 Python 项目创意&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;经常看到有人问：有没有简单易上手的 Python 项目推荐？不妨看看这篇文章，它介绍了 20 个小项目的想法，另外原作者已经实现了很多项目，源码可从文中的&lt;a href=&quot;https://github.com/praise002/20-python-project&quot;&gt;仓库地址&lt;/a&gt;获取。Python练手项目很多，不一定都合适你，但胜在不需要耗时太多，不妨试试看。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://en.lewoniewski.info/2023/python-3-11-vs-python-3-12-performance-testing/&quot;&gt;Python 3.11 vs Python 3.12 之性能测试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章在配备 AMD 锐龙 7000 系列和第 13 代英特尔酷睿处理器的不同机器上共进行了 91 种基准测试，详细给出了各项数值。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://blog.adarshd.dev/posts/when-i-met-guido-van-rossum/&quot;&gt;当我遇见了 Guido van Rossum&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者在今年 Pycascades 上做了演讲“Python 中用元类作元编程”，并遇见 Guido，他们聊了一些 Python 使用中的话题以及如何成为 CPython 核心开发者。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://death.andgravity.com/stdlib&quot;&gt;通过阅读代码学习：Python 标准库设计决策解释&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;程序员提升能力的一个方法是大量阅读优秀的代码，Python 标准库就是很好的选择。但标准库茫茫之多，该选择哪些呢？文章作者推荐了这些：&lt;strong&gt;statistics、pathlib、dataclasses、graphlib&lt;/strong&gt;。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://testdriven.io/blog/accepting-payments-with-stripe-vuejs-and-flask/&quot;&gt;使用 Stripe、Vue.js 和 Flask 开发收款功能&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;国人的付费意愿差，独立开发者选择出海掘金的话，大多会选择用 Stripe 账号。这篇教程使用 Stripe 实现网站的收款功能，前后端技术栈为 Vue 和 Flask。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://blog.frankel.ch/rust-from-python/&quot;&gt;使用 Python 调用 Rust 的三种方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了 Python 调用 Rust 的三种方法：HTTP、IPC（进程间通信） 和 FFI（外部函数接口）。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://semaphoreci.com/blog/custom-middleware-fastapi&quot;&gt;如何开发 FastAPI 的中间件？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;FastAPI 内置了一些中间件，但你可能还需要量身定制自己的中间件。文章介绍了 FastAPI 中间件原理及内置的中间件，然后基于函数和基于类来实现自定义中间件，给出了最佳实践建议以及相应的测试用例。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://www.honeybadger.io/blog/options-for-passwordless-authentication-in-django/&quot;&gt;Django 项目实现无密码身份验证&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了三种无密码的身份验证方法：基于邮件的身份验证、使用 OAuth 进行身份验证和使用超链接进行身份验证；介绍了它们的优点、局限性以及使用的注意事项。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://thetechbuffet.substack.com/p/improve-python-development-workflow&quot;&gt;在发布 Python 项目前，建议用上这 4 个工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;有什么工具可以简化开发工作流程，遵循行业构建良好软件的最佳实践？文章分享了 4 种好用的工具：&lt;strong&gt;Poetry、Pre-commit 钩子、Makefiles、python-dotenv&lt;/strong&gt;。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://blog.miguelgrinberg.com/post/we-have-to-talk-about-flask&quot;&gt;我们必须聊聊 Flask&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Flask 最近发布了 3.0 版本，Werkzeug 也同时发了 3.0 版本，但它引入了不向后兼容的更改！作者吐槽 Flask 总是出现版本不兼容的问题，给出了不少例子和原因分析，希望 Flask 核心开发不要做无端的重构，要三思而行。（文章出自《Flask Web Development》一书的作者）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://juejin.cn/post/7288998044020326415&quot;&gt;基于 ProPainter 技术去除图片以及视频水印&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍使用 ProPainter 框架来解决视频去水印问题，它引入了双域传播的新方法和一种高效的遮罩引导视频 Transformers，增强了视频修复的性能，同时保持了计算效率，成本更低。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://thenewstack.io/python-comes-to-google-sheets/&quot;&gt;Google Sheets 也能用 Python 了&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;微软在 8 月让 Excel 支持了 Python，现在一家名为 Neptyne 的公司推出了一款在 Google Sheets 中使用 Python 功能的产品。文章介绍了它的基本情况。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已免费发布了 23 期，访问下方链接，即可查看全部内容：&lt;a href=&quot;https://pythoncat.top/tags/weekly&quot;&gt;https://pythoncat.top/tags/weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有价值，请表达小小心意，赞赏一下猫哥吧~~&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;http://python.jpglomot.com/#/questions&quot;&gt;一个 Python 知识问答网站&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个很简洁的网站，有近百道选择题，大多是 Python 基础语法相关的内容。来测一下你都学会了么？&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/benjie-git/CardStock&quot;&gt;CardStock：跨平台的 GUI 构建工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它提供了一个类似于绘图程序的编辑器，用于构建图形用户界面，支持文本、图形、图像、按钮、输入框和 Web 视图等元素；提供了一个代码编辑器，可添加事件驱动的 Python 代码。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/Undertone0809/python-package-template&quot;&gt;python-package-template：标准化的 Python package模板&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它内置了单元测试、代码检查、格式化、包管理、pre-commit 配置、Github Actions 等众多方便的工具，可以很方便的管理 Python 项目。（投稿自@Undertone0809）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/pipeless-ai/pipeless&quot;&gt;pipeless：一个计算机视觉框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;轻松构建与部署可实时分析及操作视频流的应用，无需构建和维护多媒体 pipeline。支持插件，例如使用 Kafka 实时处理事件、使用 YOLOv8 模型等。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/KoljaB/RealtimeSTT&quot;&gt;RealtimeSTT：强大、高效、低延迟的语音转文本库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它具有高级语音活动检测、唤醒词激活和即时转录功能，使用的技术栈有：语音活动检测（&lt;strong&gt;WebRTCVAD、SileroVAD&lt;/strong&gt;）、语音转文本（&lt;strong&gt;Faster Whisper&lt;/strong&gt;）、唤醒词检测（&lt;strong&gt;Porcupine&lt;/strong&gt;）。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/richardyc/Chrome-GPT&quot;&gt;Chrome-GPT：可控制 Chrome 的 AutoGPT 代理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它利用 Langchain 和 Selenium 使 AutoGPT 代理能够控制 Chrome 会话。支持以交互方式滚动、单击和输入网页上的文本，从而可以导航和操作 Web 内容。（star 1.4K）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/rohankishore/ZenNotes&quot;&gt;ZenNotes：Windows 记事本，支持翻译和TTS&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个简约的 Windows 记事本程序，支持翻译、TTS、Markdown，基于 &lt;a href=&quot;https://github.com/zhiyiYo/PyQt-Fluent-Widgets&quot;&gt;PyQt-Fluent-Widgets&lt;/a&gt; 开发而成。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/kr8s-org/kr8s&quot;&gt;kr8s：用于 Kubernetes 的客户端库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用于 k8s 的一个简单、可扩展的 Python 客户端库，如果你用过 &lt;strong&gt;kubectl&lt;/strong&gt;，就会觉得它很熟悉。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/swirlai/swirl-search&quot;&gt;swirl-search：用 AI 同时搜索多个数据源&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可搜索多个内容源并返回 AI 的排名结果，支持连接到数据库（SQL、NoSQL、Google BigQuery）、公共数据（谷歌、Arxiv）、企业数据源（Microsoft 365、Jira、Miro等）。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/getsentry/sentry&quot;&gt;sentry：面向开发者的错误跟踪和性能监控平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个强大的错误跟踪和性能监控平台，还支持定期任务监控、代码覆盖率、会话重播、告警、安全策略等功能，支持 100 多种平台和框架，支持 30+ 编程语言。（star 35.4K）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/zhiwehu/100_plus_Python_Projects_Challenge&quot;&gt;15 个 Python 小项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个仓库收录了一些 Python 小项目及其实现代码，跟本期周刊的第一则分享相似。（star 1K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/jtesta/ssh-audit&quot;&gt;ssh-audit：SSH 服务器和客户端安全审计&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用于审查 SSH 的配置，支持 SSH1 和 SSH2 协议，支持 Linux 和 Windows，可识别安全漏洞、不安全密钥、不安全算法等，并给出安全建议。另外它也有&lt;a href=&quot;https://www.ssh-audit.com/&quot;&gt;在线版本&lt;/a&gt; 。（star 2.6K）&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.youtube.com/playlist?list=PLEpW1LzVyQWgtT_i_IlUmx2FSP2jHcroX&quot;&gt;哥本哈根 2023 Django Day 演讲视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Django Day 是一个专门围绕 Django 框架和 Django 社区的活动，目前视频列表中有 11 则视频。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://talkpython.fm/episodes/show/434/building-mobile-apps-backed-with-python&quot;&gt;Talk Python To Me  #434：用 Python 构建移动 APP&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 能够用于开发移动端应用么？能不能用 Python 实现端到端的移动应用开发？这期播客邀请了几个移动端 APP 的开发者聊了相关话题。&lt;/div&gt;
&lt;h2&gt;🐱赞助&amp;amp;支持&lt;/h2&gt;
&lt;div&gt;如果你喜欢周刊，请分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有价值，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt; 或 &lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！&lt;/div&gt;
&lt;div&gt;如果你想帮助周刊办得更好，欢迎向我们投稿或提出建议：&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly/issues/new&quot;&gt;投稿/建议通道&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你是品牌方或广告主，欢迎私信我，洽谈赞助与合作事项。&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#22：Python 3.12.0 发布了！！</title>
            <link>https://pythoncat.top/posts/2023-10-12-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-10-12-weekly/</guid>
            <description>本期周刊分享了 13 篇文章，12 个开源项目，2 则视频</description>
            <pubDate>Thu, 12 Oct 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。标题取自其中一则分享，不代表全部内容都是该主题，特此声明。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.python.org/downloads/release/python-3120/&quot;&gt;Python 3.12.0 版本发布了&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 最新大版本 3.12 发布了！包含许多新功能和优化，本期周刊有几篇文章涉及相关内容。（附：&lt;a href=&quot;https://realpython.com/python312-new-features/&quot;&gt;Python 3.12 新功能的详细介绍&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://realpython.com/python312-subinterpreters/&quot;&gt;Python 3.12 速览：子解释器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 子解释器是什么？3.12 版本的 PEP-684 做了什么？3.13 版本可能会出现什么变化？&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.manjusaka.blog/posts/2023/10/05/the-perf-feature-python-312/&quot;&gt;聊聊 Python 3.12 中 perf 的原生支持&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了 Python 的栈帧基本知识、3.12 之前对于 trace 和 perf 的实现、以及 3.12 新引入的 Linux 原生 perf 的实现。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://realpython.com/python312-typing/&quot;&gt;Python 3.12 速览：静态类型的改进&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;3.12 版本带来了一些调整和改进：使用类型变量来注释泛型类和函数、类型变量的新语法、使用新的 @override 装饰器作模型继承、用类型化的字典更精确注解 **kwargs。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://juejin.cn/post/7283461184514572349&quot;&gt;FastAPI 中的依赖注入：构建可维护的高性能 Web 应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;依赖注入是一种强大的设计模式，FastAPI 中如何利用依赖注入来构建可维护的高性能 Web 应用？涉及内容：使用依赖注入管理配置、数据库访问和 ORM 的依赖注入、高级依赖注入技巧、测试依赖注入、性能优化和缓存的依赖注入、安全性和依赖注入等。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://juejin.cn/post/7286670786563244090&quot;&gt;深入理解 python 虚拟机：原来虚拟机是这么实现闭包的&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了闭包的使用例子和使用原理，主要从虚拟机层面讨论函数闭包是如何实现的？&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://juejin.cn/post/7287418444647677986&quot;&gt;探索 Pexpect 库：深入理解 expect_list 方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/pexpect/pexpect&quot;&gt;pexpect&lt;/a&gt; 可用于交互式应用的自动化，如 ssh、ftp、passwd、telnet 等，Github star 2.4K。文章介绍了它的 expect_list 方法的使用。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://textual.textualize.io/blog/2023/10/04/announcing-textual-plotext/&quot;&gt;介绍 textual-plotext，在终端里绘图&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了 textual-plotext 库的用法，它可以在终端里用 &lt;a href=&quot;https://github.com/piccolomo/plotext&quot;&gt;Plotext&lt;/a&gt; 绘图。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://bbc.github.io/cloudfit-public-docs/&quot;&gt;Python Asyncio 系列文章 5 篇&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;BBC R&amp;amp;D Cloudfit 团队的系列博客文章，Asyncio 系列已更新 5 篇，内容有基础概念及模式、异步上下文管理器和异步迭代器、库支持、混合异步和同步代码。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://www.polarsignals.com/blog/posts/2023/10/04/profiling-python-and-ruby-with-ebpf&quot;&gt;使用 eBPF 分析 Python 和 Ruby&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用 eBPF 从内存结构中读取抽象堆栈数据，实现堆栈跟踪及代码执行分析。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://www.bitecode.dev/p/python-312-what-didnt-make-the-headlines&quot;&gt;Python 3.12: 不那么热门的改动&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了 3.12 版本中不那么引入关注的改动：pathlib 库的改进、更好的调试体验、切片对象现在是可哈希的、意外出现的 math.sumprod()、新的命令行界面。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://sethmlarson.dev/security-developer-in-residence-weekly-report-13&quot;&gt;从供应链安全角度看 Python 3.12.0&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 版本的发布流程是怎样的？版本构建的过程有哪些可改进的地方？文章另外介绍了用软件物料清单 （SBOM） 来跟踪软件分发的子组件以及它们在版本之间的变化。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已免费发布了 22 期，访问下方链接，即可查看全部内容：&lt;a href=&quot;https://pythoncat.top/tags/weekly&quot;&gt;https://pythoncat.top/tags/weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有价值，请表达小小心意，赞赏一下猫哥吧~~&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/mwmbl/mwmbl&quot;&gt;mwmbl：用 Python 实现的开源非营利搜索引擎&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个非营利、无广告、免费的搜索引擎，专注于可用性和速度。目前仅是概念验证版本，索引的页面还比较少。（star 1K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/Dataherald/dataherald&quot;&gt;dataherald：自然语言转 SQL 引擎&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于结构化数据进行企业级问答，允许设置一个 API，可用简单的英语回答问题。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/stanfordnlp/dspy&quot;&gt;dspy：使用基础模型编程的框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个使用语言模型 （LM） 和检索模型 （RM） 解决高级任务的框架。它统一了提示和微调 LM 的技术，以及推理、自我改进和使用检索和工具增强的方法。（star 3.5K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/coqui-ai/TTS&quot;&gt;TTS：文本到语音转换的深度学习工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个用高级文本生成语音的库，使用 1100 中语言的预训练模型，可用于训练新模型和微调任何语言的现有模型。（star 20.3K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/Qiskit/rustworkx&quot;&gt;rustworkx：用 Rust 实现的高性能 Python 图形库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用 Rust 编写的通用 Python 图形库，拥有高性能和安全性。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/airtai/faststream&quot;&gt;faststream：构建与事件流交互的异步服务&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个用于构建与 Apache Kafka、RabbitMQ 和 NATS 等事件流交互的异步服务框架，简化了为消息队列编写生产者和使用者的过程。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/aio-libs/aiohttp&quot;&gt;aiohttp：异步 HTTP 客户端/服务器框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;流行的异步 HTTP 框架，主要特点：支持客户端和服务端的 HTTP 协议、开箱即用的 Websocket、支持中间件和可插拔路由。（star 14K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/AliRn76/Panther&quot;&gt;panther：高性能的 Python Web框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于 Python 3.11 的 Web 框架，特点有面向文档的数据库 ODM、支持 Websocket、提供缓存 API、内置身份验证类、内置权限类、自定义中间件、可视化的 API 监控等。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/Qiskit/qiskit&quot;&gt;qiskit：用于量子计算机的开源 SDK&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;未来有可能人人都可以轻松使用量子计算机么？&lt;a href=&quot;https://qiskit.org/documentation/&quot;&gt;Qiskit&lt;/a&gt; 项目的目标是这样。这个库是 Qiskit 的核心组件，包含用于创建和使用量子电路、量子算子和基元函数的构建块。（star 3.9K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/mckinsey/vizro&quot;&gt;vizro：用于创建模块化数据可视化应用的工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用几行简单的配置就能创建复杂的仪表板，利用 Plotly 和 Dash 等库绘图。支持多种格式编写配置，包括 Pydantic 模型、JSON、YAML 或 Python 字典。（star 1.5K）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/ddbourgin/numpy-ml&quot;&gt;numpy-ml：用 numpy 作机器学习&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个由大量机器学习模型、算法和工具组成的集合，专门用 NumPy 和 Python 标准库编写。（star 14K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/jsvine/pdfplumber&quot;&gt;pdfplumber：PDF 解析库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可解析 PDF 每个文本字符、矩形和线条的详细信息，支持提取表格和可视化调试。（star 4.6K）&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.youtube.com/watch?v=5Sm9IVMet9c&quot;&gt;Mojo 编程语言的新手入门教程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;FreeCodeCamp 推出的一个 Mojo 入门学习视频，已接近 10 万播放量。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.youtube.com/watch?v=udHmeAmOlbI&quot;&gt;Python 3.12: 你需要知道的新特性&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;探讨 Python 3.12 中令人兴奋的新功能和改进，也讨论了即将发布的版本将删除的一些元素。&lt;/div&gt;
&lt;h2&gt;🐱赞助&amp;amp;支持&lt;/h2&gt;
&lt;div&gt;如果你喜欢周刊，请分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有价值，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt; 或 &lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！&lt;/div&gt;
&lt;div&gt;如果你想帮助周刊办得更好，欢迎向我们投稿或提出建议：&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly/issues/new&quot;&gt;投稿/建议通道&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你是品牌方或广告主，欢迎私信我，洽谈赞助与合作事项。&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#21：如何提升及测量 Python 代码的性能？</title>
            <link>https://pythoncat.top/posts/2023-09-23-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-09-23-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，10 个开源项目，2 则音视频</description>
            <pubDate>Sat, 23 Sep 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。标题取自其中三则分享，不代表全部内容都是该主题，特此声明。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pythonspeed.com/articles/optimizing-dithering/&quot;&gt;在单核情况下加快 Python 代码速度&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章使用弗洛伊德-斯坦伯格抖动算法为例，使用各种技巧来提升代码性能，实现将耗时从 2339 微秒逐步降低到 554 微秒。涉及的一些概念：指令级并行 （ILP）、分支预测、单指令多数据（SIMD）、内存层次结构等。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.blog.pythonlibrary.org/2023/09/20/learning-about-code-metrics-in-python-with-radon/&quot;&gt;使用 Radon 作 Python 的代码度量&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇基础的入门教程，了解如何用 Radon 来衡量 Python 的代码复杂度，即计算圈复杂度等指标，介绍了相关命令的使用。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://lwn.net/Articles/942767/&quot;&gt;Python（大部分）由语法糖组成&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Brett Cannon 写了一系列关于“语法糖”的博客，解析了 80 多个语法糖特性。文章基于他在 PyCon 的演讲及博客，介绍了其中的部分内容。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://oscarbenjamin.github.io/blog/czi/post1.html&quot;&gt;迎接新的 SymPy&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;SymPy 是一个用于符号计算（symbolic computation）的库，可以处理代数、微积分、离散数学等领域的问题。这是一个系列文章，介绍它将迎来的重大变化。文章描述了 SymPy 当前存在的速度问题、为加速它而作的工作、将来的提速计划。（附：&lt;a href=&quot;https://oscarbenjamin.github.io/blog/czi/post2.html&quot;&gt;系列第二篇：SymPy 多项式计算&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.piglei.com/articles/use-import-linter-to-lint-proj-arch/&quot;&gt;使用 import-linter 让你的 Python 项目架构更整洁&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在依赖关系治理方面，&lt;a href=&quot;https://github.com/seddonym/import-linter&quot;&gt;import-linter&lt;/a&gt; 是一个非常有用的工具。它通过提供各种类型的“契约”，让我们得以将项目内隐式的复杂依赖关系，通过配置文件显式的表达出来。文章介绍了它的入门使用，以及 6 种修复依赖关系的技巧。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://codeconfessions.substack.com/p/cpython-bloom-filter-usage&quot;&gt;CPython 如何用布隆过滤器作字符串处理？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;CPython 在处理字符串时使用了布隆过滤器，比如 splitlines()、strip() 两个函数，文章介绍了它们的实现原理。文章还介绍了典型布隆过滤器的实现原理，以及 CPython 中布隆过滤器的实现（不到 50 行 C 代码）。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://medium.com/@m____b____/uuids-with-python-b133cead1b4c&quot;&gt;Python 中 UUID 的使用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了&lt;code&gt;uuid&lt;/code&gt; 库的几个方法：uuid1() 利用系统 MAC 地址与时间戳生成 uuid；uuid4() 生成完全随机的 uuid；uuid3() 和 uuid5() 基于常量命名空间和变量名生成 uuid，前者使用 MD5 算法，后者使用 SHA-1 算法。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://ponder.io/why-are-there-so-many-python-dataframes/&quot;&gt;为什么有这么多 Python Dataframe？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;为什么会有 Pandas、Polars、Dask 和 PySpark 等大量的 Dataframe 库？作者认为主要的原因是它的四种角色模型：电子表格、关系数据库、二维数组/矩阵、对象，以及由此衍生出的一系列问题。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://www.dataschool.io/python-probability-simulation/&quot;&gt;使用 Python 模拟“三门问题”&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Monty Hall 问题也被称为三门问题，是一道挑战人们直觉的概率问题。文章使用 Python 来模拟这个问题，看看需要多久才能赢取奖品。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://pybit.es/articles/6-cool-things-you-can-do-with-the-functools-module/&quot;&gt;6 件可以用 Functools 模块做的很酷的事&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了 functools 标准库的 6 个使用场景：@cache 缓存、@total_ordering 让你少写双下方法、partial() 冻结函数、@singledispatch 泛型函数、@wraps 装饰器、reduce() 函数。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://juejin.cn/post/7281491804736831542&quot;&gt;深入理解 pytest.main()：Python 测试框架的核心功能解析&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;pytest.main&lt;/code&gt; 是 Pytest 框架中一个非常实用的函数，用于从命令行运行测试集或者以编程方式运行测试。文章探讨了它的用法和一些常见的应用场景。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://python.plainenglish.io/7-best-python-authentication-libraries-you-should-use-in-your-next-project-c07b668d5348&quot;&gt;7 个极佳的 Python 身份验证库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了 7 个不错的身份验证库：&lt;strong&gt;Authlib、Pyjwt、Flask-login、Django-allauth、ItsDangerous、Python Social Auth、Flask-security&lt;/strong&gt;。（附：&lt;a href=&quot;https://juejin.cn/post/7281150086351732751&quot;&gt;中文翻译&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已免费发布了 21 期，访问下方链接，即可查看全部内容：&lt;a href=&quot;https://pythoncat.top/tags/weekly&quot;&gt;https://pythoncat.top/tags/weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有价值，请表达小小心意，赞赏一下猫哥吧~~&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/rubik/radon&quot;&gt;radon：Python 代码的各种指标&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个 Python 代码指标分析工具，可以计算圈复杂度、原始指标、Halstead 指标、可维护性指数，可用于 CI 集成，可与 Jupyter Notebook 一起使用。（star 1.5K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/aiwaves-cn/agents&quot;&gt;agents：自主语言代理的开源框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;自主语言代理（Autonomous Language Agents）指的是能够独立执行自然语言处理任务的智能代理系统。这个库支持长期短期记忆、工具使用、Web 导航、多 agent 通信、人机交互和符号控制等功能。（star 2.6K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/tedivm/quasiqueue&quot;&gt;quasiqueue：一个多进程库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个用于 Python 多进程的库，便于管理长时间运行的多进程作业。可处理进程创建和清理、信号管理、跨进程通信以及其它在处理多进程时的麻烦事。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/nicolas-hbt/pygraft&quot;&gt;pygraft：可配置的模式和知识图谱生成&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可根据用户指定的参数生成逼真的模式和知识图谱，通过使用 DL 推理器（HermiT）来确保逻辑一致性。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/pwwang/toml-bench&quot;&gt;toml-bench：在 Python 中该用哪个 toml 库？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个仓库主要从多个维度比较了 &lt;strong&gt;toml、tomli/tomli_w、tomlkit、pytomlpp、rtoml 和 qtoml&lt;/strong&gt; 这几个库，考察它们在处理数据时的行为表现以及性能。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/liuyuan-pal/SyncDreamer&quot;&gt;SyncDreamer：以单视角图像生成多视角一致的图像&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;提供一张图片，使用 Paint3D 分割前景对象，通过推理生成多个视角的图像。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/NVIDIA-AI-IOT/nanosam&quot;&gt;nanosam：使用 NVIDIA TensorRT 实时运行的 SAM 模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Segment Anything（SAM）是在计算机视觉领域中对图像或视频中的任何对象进行分割的任务，以提取出具有语义或视觉特征的子区域或对象。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/logpai/logparser&quot;&gt;logparser：用于日志解析的机器学习工具包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;国人开源作品。可自动从非结构化的日志信息中提取出结构化的关键信息。（star 1.2K）&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/tairov/llama2.mojo&quot;&gt;llama2.mojo：纯 Mojo 版本的 Llama 2&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者将 Python 版本的 llama2.py 移植成 Mojo 版本，将性能提高了近 250 倍。（star 1.1K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/dataelement/bisheng&quot;&gt;bisheng：一个开放的 LLM DevOps 平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一款领先的开源大模型应用开发平台，中文“毕昇”，可以搭建各类丰富的大模型应用：分析报告生成、知识库问答、对话、要素提取等。&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.youtube.com/playlist?list=PL8uoeex94UhFcwvAfWHybD7SfNgIUBRo-&quot;&gt;EuroPython 2023 的 146 个视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;今年 EuroPython 活动的演讲视频。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://realpython.com/podcasts/rpp/172/&quot;&gt;Real Python 播客 #172：使用 Scalene 测量 Python 性能&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Scalene&lt;/strong&gt; 是一款高性能的 CPU、GPU 和内存分析器，可以从单个函数或代码行级别分析代码，并比较在 Python 和 C 代码中花费的时间。播客嘉宾是马萨诸塞大学教授，他与学校实验室的学生开发了 Scalene。&lt;/div&gt;
&lt;h2&gt;🐱赞助&amp;amp;支持&lt;/h2&gt;
&lt;div&gt;如果你喜欢周刊，请分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有价值，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt; 或 &lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！&lt;/div&gt;
&lt;div&gt;如果你想帮助周刊办得更好，欢迎向我们投稿或提出建议：&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly/issues/new&quot;&gt;投稿/建议通道&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你是品牌方或广告主，欢迎私信我，洽谈赞助与合作事项。&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#20：三种基准测试的方法、为什么代码在函数中运行得更快？</title>
            <link>https://pythoncat.top/posts/2023-09-16-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-09-16-weekly/</guid>
            <description>本期周刊分享了 14 篇文章，10 个开源项目</description>
            <pubDate>Sat, 16 Sep 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。标题取自其中两则分享，不代表全部内容都是该主题，特此声明。&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://superfastpython.com/benchmark-python-code/&quot;&gt;三种对 Python 作基准测试的方法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了使用标准库对 Python 作基准测试的几种方法：time、timeit、cProfile 与 profile，详细介绍了几个工具的使用方法及测试数据的解读。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://andrich.me/2023/08/switching-to-hatch/&quot;&gt;舍弃 Poetry 和 PDM，切换成 Hatch&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者“移情别恋”了 Hatch，开始在项目中使用它。文章介绍了他喜欢 Hatch 的一些小亮点：环境隔离、命令脚本、可替代 &lt;strong&gt;Tox&lt;/strong&gt;、可选的依赖项等。（附：&lt;a href=&quot;https://pythoncat.top/posts/2020-01-06-tox&quot;&gt;Python 任务自动化工具 tox 教程&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://hitchdev.com/strictyaml/why-not/toml/&quot;&gt;TOML 文件格式有什么问题？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;TOML 是“改进的” INI 文件，是 Python 推荐的配置文件格式。文章提到，连 TOML 的作者也认为它是一种糟糕的格式！文章指出了它的问题：非常冗长、层次结构很难仅从语法推断、像 YAML 一样过于复杂、具有语法类型。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://joseprupi.github.io/misc/2023/08/19/playing_with_genetic_algorithms_in_python.html&quot;&gt;用 Python 玩转遗传算法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;遗传算法（Genetic Algorithm）是一种受生物进化理论启发的优化算法，用于解决复杂的搜索和优化问题。文章用 Python 演示了这种算法的使用例子。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://codebeez.nl/blogs/type-hinting-in-modern-python-the-protocol-class/&quot;&gt;现代 Python 的类型提示：Protocal 类&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Protocol 类是 Python 3.8 版本中引入的，用于指定一个类应该实现哪些方法，与 Java 的 Interface 相似。在保持 Python 动态类型用法的情况，使用 Protocal 可以获得部分静态类型检查的效果。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://dev.to/caipi/tornado-de-xie-cheng-diao-du-yuan-li-2h34&quot;&gt;tornado 的协程调度原理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Tornado 是一个高性能的 Web 框架，文章解读它的源码，主要想搞清楚：yield 暂存的状态到哪去了、重新恢复执行的“合适的时机”到底是什么、具体是怎么恢复执行的？&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://sethmlarson.dev/security-developer-in-residence-weekly-report-9&quot;&gt;可视化 CPython 发布过程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章基于 PEP-101 梳理了 CPython 的发布过程，绘制出了详细的流程图并给出关键步骤的解释。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://yasoob.me/posts/how-to-use-vision-framework-via-pyobjc/&quot;&gt;如何用 PyObjC 与 Apple Vision 框架作文本识别&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Apple 的 Vision 框架提供了一系列预训练的模型和 API，可快速在应用中添加图像分析和计算机视觉功能。PyObjC 可实现 Python 与 Objective-C 的交互。文章将它们结合，开发了一个文本处理项目。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://krishnanchandra.com/posts/regex-catastrophic-backtracking/&quot;&gt;调试 Python 中正则表达式的灾难性回溯&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者使用 py-spy 定位一个 CPU 100% 占用问题，找出了罪魁祸首的正则表达式，进而探讨灾难性回溯及其解决方法，并给出了优化性能的建议写法。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://www.photondesigner.com/articles/database-search-django-htmx&quot;&gt;使用 Django 和 HTMX 开发一个数据库搜索项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇详细的 Django 项目教程，实现一个全栈的项目。文中有作者的教程视频。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://python-bloggers.com/2023/09/asynchronous-sqlalchemy-and-multiple-databases/&quot;&gt;异步 SqlAlchemy 和多数据库管理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;利用 asyncio 和 SqlAlchemy 库，文章探讨了如何有效地连接和管理多个数据库，获得可扩展且具有弹性的架构。文章介绍了两种实现方法。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://juejin.cn/post/7278246015193464847&quot;&gt;Python Fire：自动生成命令行接口&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Fire 是谷歌开源的一个用于生成 CLI 的库，Github 25K star。这篇文章介绍了它的一般命令、组合命令、链式命令、复杂命令等用法。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://www.jjinux.com/2022/08/python-my-favorite-python-tricks-for.html&quot;&gt;我最爱的解 LeetCode 问题的 Python 技巧&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了 Python 中的一些小技巧，从初级到高级，多数与数据结构相关，在解 LeetCode 问题时很有用。&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://stackabuse.com/why-does-python-code-run-faster-in-a-function/&quot;&gt;为什么 Python 代码在函数中运行得更快？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 代码分别在函数和全局模块中运行，哪个更快呢？为什么是在函数中更快呢？Python 代码执行的工作原理是什么？如何测试与优化 Python 函数的性能？&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已免费发布了 20 期，访问下方链接，即可查看全部内容：&lt;a href=&quot;https://pythoncat.top/tags/weekly&quot;&gt;https://pythoncat.top/tags/weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有价值，请表达小小心意，赞赏一下猫哥吧~~&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/pypa/hatch&quot;&gt;hatch：时髦的可扩展的 Python 项目管理库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个 Python 项目管理工具，有标准化构建系统、强大的环境管理、轻松发布到 PyPI、版本管理、响应式 CLI、比 pipenv 和 poetry 同类工具快约 2-3 倍。（star 4.4K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/keephq/keep&quot;&gt;keep：开源的告警管理和自动化执行平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可以将所有告警整合到一个管理平台中，并编排工作流以自动化执行端到端的流程。支持对接多种数据采集平台、数据库、办公软件等，可视化编排告警处理工作流。（star 2.2K）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://py-code.org/stats&quot;&gt;PyPI Data 网站：查看 PyPI 的各项数据&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个神奇的网站！包含 PyPI 的各类统计数据、曲线图和饼图，例如文件总数、总大小、一些功能特性的流行趋势等等。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/crdoconnor/strictyaml&quot;&gt;strictyaml：类型安全的 YAML 解析和校验库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;用于解析 YAML 的受限子集，拒绝解析丑陋的、难以阅读和不安全的 YAML 特性，有严格的标记验证和直接的类型转换，可替代 pyyaml、ruamel.yaml 和 poyo，有清晰可读的异常信息。（star 1.3K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/facefusion/facefusion&quot;&gt;facefusion：更先进的换脸工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;最新开源的一个人像换脸库，star 涨得飞快！（star 6.9K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/deshaw/pyflyby&quot;&gt;pyflyby：一套 Python 的生产力工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;包含一系列的小工具，功能包含用于命令行的 py、用于 IPython 的自动导入、添加缺失的 import、删除不用的 import、格式化 import、打印一组文件的 import、重命名导入，等等。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/yoheinakajima/instagraph&quot;&gt;instagraph：将文本内容或 URL 转换为可视化的知识图谱&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可以提取复杂信息中的实体，生成它们的关系图谱。使用了 GPT-3.5，以及 Flask 来生成色彩友好的图例；响应式设计，可在任何设备上使用。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/Textualize/textual-web&quot;&gt;textual-web：在浏览器中运行 TUI 和终端&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;将 &lt;strong&gt;Textual&lt;/strong&gt; 开发的 app 发布到网页上，也可以在浏览器中使用命令行终端。是个很有意思的项目。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/fulcrum-so/ziggy-pydust&quot;&gt;ziggy-pydust：用 Zig 语言构建 Python 扩展&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个开发框架，可打包用 Zig 编写的 Python 扩展模块，还包含一个 Pytest 插件可发现与运行 Zig 测试。集成了 Poetry，方便构建 wheel 和发布。支持缓冲区协议，可以实现零拷贝提升 Numpy 计算。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/codefuse-ai/MFTCoder&quot;&gt;MFTCoder：多任务微调代码大模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个开源的多任务代码大语言模型项目，包含代码大模型的模型、数据、训练等。在 HumanEval Benchmarks 的 Python Pass@1 取得了 &lt;strong&gt;74.4%&lt;/strong&gt; 的开源 SOTA 成绩，超过 GPT-4。&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#19：Mojo 终于提供下载了！</title>
            <link>https://pythoncat.top/posts/2023-09-09-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-09-09-weekly/</guid>
            <description>Mojo 又有新进展了，想要去尝试一下，但暂无 Windows 版本</description>
            <pubDate>Sat, 09 Sep 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。标题取自其中两则分享，不代表全部内容都是该主题，特此声明。&lt;/div&gt;
&lt;div&gt;本周刊由 &lt;strong&gt;Python猫&lt;/strong&gt; 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img.pythoncat.top/python_cat.jpg&quot;&gt;微信&lt;/a&gt; | &lt;a href=&quot;https://pythoncat.top&quot;&gt;博客&lt;/a&gt; | &lt;a href=&quot;https://pythoncat.substack.com&quot;&gt;邮件&lt;/a&gt; | &lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;Github&lt;/a&gt; | &lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;Telegram&lt;/a&gt; | &lt;a href=&quot;https://twitter.com/chinesehuazhou&quot;&gt;Twitter&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;为了方便读者获取原始内容，我已将周刊的 Markdown 文件归档在 Github，请通过以下链接获取：&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;https://github.com/chinesehuazhou/python-weekly&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.modular.com/blog/mojo-its-finally-here&quot;&gt;Mojo🔥 终于提供下载了！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Mojo 语言是今年发布的“高性能的 Pyhton++”，周刊第 17 期刚分享过它获得了 1 亿美元融资，这周它就发布了 Linux 版本的安装包。除了编译器功能，它还提供了一些 IDE 工具（终端 shell、VS Code 插件、Jupyter 内核），暂不支持调试，暂无 Mac 和 Windows 版本。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.cnblogs.com/apocelipes/p/17679741.html&quot;&gt;我们能从 PEP-703 中学到什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PEP-703 是 no-gil 项目的提案，我们曾多次介绍过。作者讨论了该 PEP 中的一些话题，例如尽量少依赖原子操作的引用计数、延迟的引用计数、gc 不再会分代、对象锁等，从中能看出 Python 社区在性能和兼容性上的权衡。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://vgel.me/posts/c500/&quot;&gt;用 500 行 Python 代码写一个 C 语言编译器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;实现一个 C 语言编译器需要多少行 Python 代码？文章介绍了编译器的架构、代码解析与生成流程，尝试用 500 行代码实现了一个简易的 C 编译器。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://www.blog.pythonlibrary.org/2023/08/30/an-intro-to-protocol-buffers-with-python&quot;&gt;简单介绍如何用 Python 作协议缓冲区编程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;协议缓冲区（&lt;strong&gt;Protocol buffer&lt;/strong&gt;）是一种与语言无关的数据序列化格式，类似于 Python 的 pickle 格式。文章介绍了如何用 Python 创建与编译协议缓冲区文件，并与支持该协议的其它语言进行通信。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://dev.to/oscarleo/how-to-create-a-beautiful-polar-histogram-with-python-and-matplotlib-400l&quot;&gt;用 Python 和 matplotlib 创建漂亮的极坐标直方图&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;极坐标直方图（&lt;strong&gt;Polar Histogram&lt;/strong&gt;）是一种用于可视化和分析数据分布的图表形式，它将数据划分为多个扇区，每个扇区的长度或面积表示该角度范围内数据的频率或数量。文章介绍了如何 Python 绘制极坐标直方图。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://codeconfessions.substack.com/p/bloom-filters-and-beyond&quot;&gt;布隆过滤器图解与 Python 实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;布隆过滤器（&lt;strong&gt;Bloom Filter&lt;/strong&gt;）是一种数据结构，可用于快速判断一个元素是否存在于一个集合中，场景的使用场景：去重、缓存与快速查询、防止缓存穿透、过滤垃圾邮件等。文章介绍了它是什么、如何操作、Python 实现、如何调整布隆过滤器等。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://favtutor.com/blogs/heap-in-python&quot;&gt;Python 中的堆数据结构：最小和最大堆实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;堆（&lt;strong&gt;Heap&lt;/strong&gt;）是一种重要的数据结构，常用于快速访问最值、堆排序、调度与分配任务、图算法、数据压缩与编码等。文章介绍了它的基本概念、如何用 Python 实现最大堆和最小堆、它们的区别。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://developers.redhat.com/articles/2023/09/05/beginners-guide-python-containers&quot;&gt;Python 容器化部署教程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;容器是一种轻量级的虚拟化技术，可实现 Python 程序的高效打包与部署。Red Hat 的这篇教程介绍了如何用 &lt;strong&gt;Podman&lt;/strong&gt; 来构建、运行和管理 Python 容器。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://robamu.github.io/posts/packaging-python-in-2023/&quot;&gt;2023 年 Python 包管理的实践指南&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这篇文章梳理了当前 Python 包管理时比较适用的一些最佳实践，例如使用 pyproject.toml、使用 setuptools 作分发和构建工具、用 Sphinx + reStructuredText + sphinx-rtd-theme 编写文档、用 CHANGELOG 列出版本更改、使用 black 和 flake8 等。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://juejin.cn/post/7274626136328536116&quot;&gt;记一次 Python 应用内存泄漏问题定位&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者使用 Airflow 作为任务调度器，上线后每隔一段时间就出现 Scheduler 内存 OOM 问题，这篇文章详细记录了问题定位分析的过程。介绍了三个工具：&lt;strong&gt;objgraph、pympler、tracemalloc&lt;/strong&gt;。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://adamj.eu/tech/2023/09/07/introducing-flake8-logging/&quot;&gt;介绍 flake8-logging&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者认为标准库&lt;code&gt;logging&lt;/code&gt; 比较难用，加上在程序错误时经常会缺少必要的日志，因此开发了 flake8-logging 插件。它有 12 条规则，这篇文章介绍了 3 条：使用 logging.getLogger() 实例化记录器、在异常处理时使用 exception()、避免预先格式化日志信息。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://segmentfault.com/a/1190000044189692&quot;&gt;Falcon 180B 正式在 Hugging Face Hub 上发布&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Falcon 作为当前最大的开源大模型，有 180B 参数并且是在在 3.5 万亿 token 的 TII RefinedWeb 数据集上进行训练，是目前开源模型里最长的单波段预训练。文章介绍了它的优势以及入门使用。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已免费发布了 19 期，访问下方链接，即可查看全部内容：&lt;a href=&quot;https://pythoncat.top/tags/weekly&quot;&gt;https://pythoncat.top/tags/weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有价值，请表达小小心意，赞赏一下猫哥吧~~&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/lancopku/PKUSeg-python&quot;&gt;pkuseg-python：多领域中文分词工具，比 jieba 准确性更高&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;不同于其它通用中文分词工具，它支持多领域分词、有更高的分词准确率、支持用户自训练模型、支持词性标注。准确性超过 &lt;strong&gt;jieba、THULAC&lt;/strong&gt; 两个中文分词工具。（star 6.2K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/mimseyedi/pysentation&quot;&gt;pysentation：在 CLI 里显示演示文稿&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在命令行终端里制作和展示 presentation，支持标题、颜色、主题、放大、解释、快捷键等功能。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/eschluntz/compress&quot;&gt;compress：基于个人语料库的快捷输入工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;导入个人的语料库后，可以用缩写方式输入长串的内容。使用了 &lt;strong&gt;Autokey&lt;/strong&gt; 来实现 Linux 的键盘快捷键。（star 1.3K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/cofactoryai/textbase&quot;&gt;textbase：用于构建 AI 聊天机器人的简单框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个使用 NLP 和 ML 构建聊天机器人的框架，轻松开发和部署 Web 应用。计划集成短信、本地集成大语言模型（Claude、Llama）。（star 1.2K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/lemon24/reader&quot;&gt;reader：Python 开发的 feed 阅读器库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;功能丰富的 feed 阅读器，支持检索、存储和管理 Atom、RSS 和 JSON 源，支持标记文章为已读或重要、支持过滤 feed 和文章、支持全文搜索、支持统计用户活动、支持插件。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/baichuan-inc/Baichuan2&quot;&gt;Baichuan2：百川 53B 大模型在线对话平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;百川智能推出的新一代开源大语言模型，采用 2.6 万亿 Tokens 的高质量语料训练。在通用、法律、医疗、数学、代码和多语言翻译六个领域的中英文和多语言权威数据集上对模型进行了广泛测试。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/hynek/svcs/&quot;&gt;svcs：灵活的 Python 服务定位器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 的依赖注入容器，提供了一个注册类型/接口工厂的机制，通过自动清理和运行状况检查强制获取这些类型的实例。使用依赖注入和服务定位来实现控制反转，消除大量重复的样板代码。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/binary-husky/gpt_academic&quot;&gt;gpt_academic: 为 ChatGPT/GLM 提供实用化交互界面&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;GPT 学术优化，特别优化论文阅读/润色/写作体验，模块化设计，支持自定义快捷按钮&amp;amp;函数插件，支持 Python 和 C++ 等项目剖析&amp;amp;自译解功能，PDF/LaTex 论文翻译&amp;amp;总结功能，支持并行问询多种 LLM 模型，支持 chatglm2 等本地模型。兼容文心一言, moss, llama2, rwkv, claude2, 通义千问, 书生, 讯飞星火等。（star 41K）&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#18：Flask、Streamlit、Polars 的学习教程</title>
            <link>https://pythoncat.top/posts/2023-09-02-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-09-02-weekly/</guid>
            <description>本期周刊分享了 12 篇文章，10 个开源项目</description>
            <pubDate>Sat, 02 Sep 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。标题取自其中三则分享，不代表全部内容都是该主题，特此声明。&lt;/div&gt;
&lt;div&gt;本周刊由 &lt;strong&gt;Python猫&lt;/strong&gt; 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img.pythoncat.top/python_cat.jpg&quot;&gt;微信&lt;/a&gt; | &lt;a href=&quot;https://pythoncat.top&quot;&gt;博客&lt;/a&gt; | &lt;a href=&quot;https://pythoncat.substack.com&quot;&gt;邮件&lt;/a&gt; | &lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;Github&lt;/a&gt; | &lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;Telegram&lt;/a&gt; | &lt;a href=&quot;https://twitter.com/chinesehuazhou&quot;&gt;Twitter&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;为了方便读者获取原始内容，我已将周刊的 Markdown 文件归档在 Github，请通过以下链接获取：&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;https://github.com/chinesehuazhou/python-weekly&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://testdriven.io/guides/flask-deep-dive&quot;&gt;一份深入探索 Flask 的指南&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;由系列文章组成的 Flask 学习指南，深入了解 Flask 的内部结构、核心特性和功能，涵盖主题有程序和请求上下文、Werkzeug、会话、安全（防CSRF）、测试、2.0 版本的异步等。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://artifex.com/blog/table-recognition-extraction-from-pdfs-pymupdf-python&quot;&gt;使用 PyMuPDF 识别与提取表格&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;识别和处理 PDF 文件中的表格是件困难的事，PyMuPDF 最新版本 1.23.0 提供了从 PDF 中提取表格的功能！可以将提取内容交给 pandas 处理，可以导出 Excel 和 CSV 格式的文件。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://codeconfessions.substack.com/p/understanding-immortal-objects-in&quot;&gt;深入介绍 Python 3.12 中的永生对象&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;周刊&lt;a href=&quot;https://pythoncat.top/posts/2023-08-19-weekly&quot;&gt;第 16 期&lt;/a&gt;分享了 Instagram 在 Python 3.12 引入永生对象的故事，而这里分享的文章深入剖析解释器源码，为我们回答了以下问题：为什么要引入永生对象？它对性能有什么影响？它是如何实现的（如 None 对象和小整数），如何做到兼容旧版本的接口的？&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://mathspp.com/blog/pydonts/usages-of-underscore&quot;&gt;Python 中下划线的十种用法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;你知道 Python 中的下划线有哪些用法么？这篇文章介绍了：REPL 中的用法、作变量名的前缀和后缀时的四种用法、作为赋值“接收器”的两种用法、新 match-case 语法中的用处、用作频繁调用的函数别名、大额数字中增加可读性。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://so1n.me/2023/08/29/python_asyncio_lib_network/&quot;&gt;Python Asyncio 之网络编程方法详解&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Asyncio 不仅提供了简单的&lt;code&gt;Socket&lt;/code&gt;接口，还基于它提供了&lt;code&gt;Protocol&lt;/code&gt;&amp;amp;&lt;code&gt;Transport&lt;/code&gt;接口以及更高级的&lt;code&gt;Stream&lt;/code&gt;接口，大大的减轻了开发者进行网络编程的心理负担。文章主要介绍了这几个接口的简单使用以及对应的原理分析。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://dev.to/codemaker2015/streamlit-cheatsheet-for-beginners-706&quot;&gt;给初学者的 Streamlit 教程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Streamlit 是一个用于创建和部署 Web 程序的框架，广泛用于机器学习和数据科学领域。这篇 streamlit 教程介绍了它的安装以及常用组件的使用，是不错的 streamlit 资料。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://ezzeddin.hashnode.dev/fastapi-tailwind-sqlalchemy&quot;&gt;如何在 FastAPI 应用中使用 Tailwind CSS 和 SQLAlchemy&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;FastAPI 是一个轻量级框架，通常需要集成其它组件搭配使用。这篇文章介绍了如何将 FastAPI 与 Jinja2 模板引擎、Tailwind CSS 以及 &lt;strong&gt;SQLAlchemy&lt;/strong&gt; 结合，创建出一个好用的开发脚手架。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://www.bitecode.dev/p/how-not-to-sort-in-python&quot;&gt;Python 如何不作排序但保持数据有序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了 Python 堆排序/优先队列、二分查找、有序容器的相关使用，它们有更好的时间复杂度或适用场景，是比暴力搜索和暴力排序更值得采用的解决方案。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://delighto.hashnode.dev/send-verification-email-django&quot;&gt;用 Django 发送带有验证链接的电子邮件&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;我们经常会在注册一些账号后收到一封验证邮件，只有在链接的有效期内点击它才能完成账号注册。这篇教程介绍了如何用 Django 来实现这个功能，这是一个简短而完整的练手项目。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://medium.com/@i18nsolutionspy/exploring-global-diversity-pyetho-python-library-for-language-and-country-insights-4a688958ea83&quot;&gt;探索全球多样性：Pyetho — 用于了解国家及其语言的 Python 库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了&lt;a href=&quot;https://github.com/i18nsolutionspy/Pyetho&quot;&gt;Pyetho&lt;/a&gt; 这个库的基本使用，它主要包含了全球国家及其语言的相关信息，采用 ISO 标准。收录有 195 个国家，我查询了下，中国有 285 种语言。除了国家和语言基本信息外，其它功能包括：查询某种语言的使用人数、查询某种语言在哪些国家使用、查询某种语言的谱系家族、查询所有的语言家族，等等。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://realpython.com/polars-python/&quot;&gt;Polars：快如闪电的 DataFrame 库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Polars 是数据分析领域的新秀，底层是用 Rust 写的，拥有超高性能。这是一篇详细的教程，内容包括：它的 DataFrame、表达式和上下文、惰性 API（LazyFrame）、与外部数据源集成、与 Numpy 和 pandas 的集成，等等。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://dev.to/khaledhosseini/data-structures-and-algorithms-for-multi-language-programmers-c-swift-python-java-c-javascript-alp&quot;&gt;深入学习数据结构与算法：C++、Swift、Python、Java、C#、JavaScript&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;超长文预警！文章探索了不同编程语言中常见数据结构的实现，使用简洁的动画和图表直观介绍了相关的知识。主要涉及线性数据结构，如数组、动态数组、链表、循环链表、栈、队列、哈希表、集合，等等。数据结构当然离不开算法和时间复杂度，文中也有对应介绍。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已免费发布了 18 期，访问下方链接，即可查看全部内容：&lt;a href=&quot;https://pythoncat.top/tags/weekly&quot;&gt;https://pythoncat.top/tags/weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有价值，请表达小小心意，赞赏一下猫哥吧~~&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/fastapi-users/fastapi-users&quot;&gt;fastapi-users：开箱即用的 FastAPI 用户管理库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;为 FastAPI 添加用户注册与身份验证模块，主要特性有：可扩展的用户模型、注册/登录/重置密码/邮箱验证、OAuth2 登录流程、可定制的数据库后端、支持多种身份验证，等等。（star 3.3K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/eliasdorneles/upiano&quot;&gt;upiano：命令行里的钢琴&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在命令行里弹钢琴是种什么体验？！安装这个库后，你就可以用鼠标和键盘来弹钢琴了。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/daijro/hrequests&quot;&gt;hrequests：requests 库的替代品&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个比 requests 库更简单、可配置、功能丰富的库，使用 gevent 实现高性能并发，支持 HTTP/2，JSON 序列化比标准库快 10 倍，代码使用类型提示，100% 线程安全。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/zhihaiLLM/wisdomInterrogatory&quot;&gt;wisdomInterrogatory：智海-录问法律大模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;由浙江大学、阿里巴巴达摩院以及华院计算共同设计研发的法律大模型，以“普法共享和司法效能提升”为目标。模型基座是 Baichuan-7B，预训练的数据包括法律文书、司法案例以及法律问答数据，共 40 G。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/edarchimbaud/awesome-systematic-trading&quot;&gt;awesome-systematic-trading：一个精选的系统化交易列表&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;系统化交易/量化交易是依据规则和算法进行自动化交易的策略，这个仓库收录了一系列资源：库、软件、策略、书籍、博客、论文、视频，等等。（star 1.1K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/QwenLM/Qwen-VL&quot;&gt;Qwen-VL：阿里通义千问-VL 模型的官方库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Qwen-VL&lt;/strong&gt; 是阿里云研发的大规模视觉语言模型，可以以图像、文本、检测框作为输入，并以文本和检测框作为输出。支持多语言、多图交错对话。评测结果显示，Qwen-VL 在多个 VL 任务上相比目前 SOTA 的 Generalist Models 都有明显优势。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/h2oai/h2ogpt&quot;&gt;h2ogpt：私人文档+图像的问答&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;查询和总结你的文档，或者与本地私有的 GPT LLM 聊天。支持大部分文档，支持 LLaMa2、Falcon、Vicuna、AutoGPTQ、LORA 等，支持 Linux、Docker、MAC 和 Windows。（star 7.2K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/smallcloudai/refact&quot;&gt;refact：开源编码助手，支持自动补全、代码重构、代码分析&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Copilot 的开源替代方案，可自托管或使用云服务。支持 starcoder、starchat、llama2、wizardlm 等开源模型，支持代码补全、重构、解释、分析、优化与修复错误等功能。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/langgenius/dify&quot;&gt;dify：创建自己的 AI 应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;dify 是 Do It For You 的简写，是一个易用的 LLMOps 平台，支持快速创建出自己的 AI 应用。核心能力：通过 Langchain 支持主流的大语言模型（包括讯飞星火、文心一言、通义千问）、可视化编排 Prompt、支持添加数据集、支持插件、支持数据标注与改进。（star 8K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/causalens/dara&quot;&gt;dara：轻松创建交互式 Web 应用程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个低代码开发框架，与 Plotly Dash、Streamlit 和 Shiny 相似，支持快速创建仪表板应用。后端使用 FastAPI，前端是一个基于 React  的 UI。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#17：Excel 终于支持 Python 了、Meta 重磅开源新项目、Mojo 新得 1 亿美元融资</title>
            <link>https://pythoncat.top/posts/2023-08-26-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-08-26-weekly/</guid>
            <description>微软在 Python 之父 Guido 的帮助下，在 Excel 中集成了 Python；Meta 开源了 Code Llama，让程序员看到拥有自己编码助手的福音；Mojo 宣布 1 亿美元的巨额融资，势头之猛让人惊叹。本期周刊还分享了几则关于 FastAPI 的内容、大量学习资源、100 多个新鲜出炉的演讲视频等等</description>
            <pubDate>Sat, 26 Aug 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。标题取自其中两则分享，不代表全部内容都是该主题，特此声明。&lt;/div&gt;
&lt;div&gt;本周刊由 &lt;strong&gt;Python猫&lt;/strong&gt; 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img.pythoncat.top/python_cat.jpg&quot;&gt;微信&lt;/a&gt; | &lt;a href=&quot;https://pythoncat.top&quot;&gt;博客&lt;/a&gt; | &lt;a href=&quot;https://pythoncat.substack.com&quot;&gt;邮件&lt;/a&gt; | &lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;Github&lt;/a&gt; | &lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;Telegram&lt;/a&gt; | &lt;a href=&quot;https://twitter.com/chinesehuazhou&quot;&gt;Twitter&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;本周的大新闻一个接一个啊！微软在 Python 之父 Guido 的帮助下，在 Excel 中集成了 Python；Meta 开源了 Code Llama，让程序员看到拥有自己编码助手的福音；Mojo 宣布 1 亿美元的巨额融资，势头之猛让人惊叹。本期周刊还分享了几则关于 FastAPI 的内容、大量学习资源、100 多个新鲜出炉的演讲视频等等，不容错过哟~~&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://techcommunity.microsoft.com/t5/microsoft-365-blog/introducing-python-in-excel-the-best-of-both-worlds-for-data/ba-p/3905482&quot;&gt;Excel 终于支持 Python 了！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;本周的重磅新闻！微软将 Python 引入到 Excel 中，支持在 Excel 中使用 Python 强大的数据分析、统计建模以及数据可视化库（&lt;strong&gt;pandas、statsmodels、Matplotlib 和 seaborn&lt;/strong&gt; 等）。Guido 发推表示他参与了这个项目。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://juejin.cn/post/7269969188391600128&quot;&gt;如何使用 FastAPI 与 aiohttp 进行 SSE 响应开发？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Server-Sent Events（服务器推送事件）可以让服务端一边生成内容，一边将数据返回给客户端。文章介绍了 FastAPI 如何使用 SSE 方式返回数据，并用 &lt;strong&gt;requests 和 aiohttp&lt;/strong&gt; 来获取与展示接口数据。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://blog.dagworks.io/p/containerized-pdf-summarizer-with&quot;&gt;用 FastAPI 和 Hamilton 实现的 PDF 摘要工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章使用 FastAPI、Hamilton、Streamlit 和 ChatGPT 开发了一个 PDF 文件摘要工具，介绍了项目的设计思路、架构设计与编程实现，效果图如下：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://juejin.cn/post/7270363281117102099&quot;&gt;放弃 Python 拥抱 Mojo？鹅厂工程师真实使用感受&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Mojo 是 &lt;strong&gt;LLVM&lt;/strong&gt; 作者发布的一门新语言，完全兼容 Python 的语法。这篇文章上手体验了 Mojo 编程，对比 Python 讨论了它的一些语法、特性以及当前存在的问题。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.modular.com/blog/how-mojo-gets-a-35-000x-speedup-over-python-part-1&quot;&gt;Mojo 如何获得比 Python 快 35000 倍的加速？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Mojo 在生成曼德博集合时比 Python 快 35000 倍，这篇文章介绍了为什么要选用曼德博算法作衡量，以及 Mojo 语言做了哪些优化来实现高性能？（附：Mojo 所属的公司 &lt;strong&gt;Modular&lt;/strong&gt; 本周宣布获得 1 亿美元融资，总融资已达到 1.3 亿美元！！）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://mathspp.com/blog/what-learning-apl-taught-me-about-python&quot;&gt;APL 语言教会我的那些 Python 知识&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;APL 是在 1960 年代开发的一种高度符号化的编程语言，作者在学习这门语言后，反而加深了对 Python 编程的理解。作者受到触动的只是简单的一行代码，但它包含了内置函数、布尔值、数据驱动、列表推导式等 Python 优雅编程的要素。（附：&lt;a href=&quot;https://pythoncat.top/posts/2021-12-13-languages&quot;&gt;从这 27 门编程语言中，也可以加深对 Python 的理解&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://www.romaglushko.com/blog/jupyter-kernel-architecture/&quot;&gt;深度解析 Jupyter 的内核架构&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Jupyter Notebooks 非常强大，它是如何做到的呢？这篇文章分析了 Jupyter 架构的内核以及一些有趣的实现细节，包括代码的执行工作流、代码解析执行、自动补全、代码检查、调试、虚拟输入、客户端和网关等。作者预告后续还会解析 &lt;strong&gt;Jupyter Server、JupyterLab、JupyterHub、Jupyter Enterprise Gateway&lt;/strong&gt; 等项目。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://engineering.fb.com/2023/08/07/developer-tools/fixit-2-linter-meta/&quot;&gt;Fixit 2：Meta 的下一代自动修复 linter&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Meta 开源的 linter 工具 &lt;a href=&quot;https://github.com/Instagram/Fixit&quot;&gt;Fixit&lt;/a&gt; 发布了2.0 版本，它支持自动修复问题，支持用户自定义 lint 规则。这篇文章介绍了 Meta 在使用 Flake8 时遇到的问题、为什么要开发 FIXit，以及为什么要重构出 Fixit 2 这个新版本？&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://realpython.com/python-code-image-generator/&quot;&gt;使用 Python 构建代码图像生成器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇超级详细的全栈实战教程，涉及技术有 &lt;strong&gt;Flask、Jinja、Playwright、Pygments 和 Javascript&lt;/strong&gt;，实现的是一个代码-图片生成器，也就是可以给代码片段添加样式并生成美观的图片。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://coderslegacy.com/apipkg-tutorial-enhanced-lazy-loading-in-python/&quot;&gt;apipkg 教程：Python 中的增强延迟加载&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;周刊第 16 期分享了一篇 importlib 实现延迟加载的文章，这篇文章中的 apipkg 也能实现同样的效果，但用法稍有不同，可以对照学习。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://www.bitecode.dev/p/asyncio-twisted-tornado-gevent-walk&quot;&gt;当 asyncio、twisted、tornado 和 gevent 一起走进酒吧…&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;当谈到 Python 并发时，就离不开标题的这些库。文章介绍和对比了这几个库，讨论了它们的设计与使用。那么，该使用哪个异步库呢？&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://snarky.ca/state-of-standardized-lock-files-for-python-august-2023/&quot;&gt;Python 标准化锁定文件的现状&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者想给 Python 提供一种标准化的依赖包锁定文件，曾在 2021 年发起了 &lt;a href=&quot;https://peps.python.org/pep-0665/&quot;&gt;PEP-665&lt;/a&gt; ，但因为缺少对 sdist 的支持而被拒绝了。作者现在做了一些概念验证的事情，计划有 5 步，目前进展到第 3 步。（附：本月新发起的 &lt;a href=&quot;https://peps.python.org/pep-0725/&quot;&gt;PEP-725 – 在 pyproject.toml 中指定外部依赖项&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://joaodlf.com/python-just-write-sql&quot;&gt;Python：只需编写 SQL&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者看到 Go 编程时不喜欢用 ORM，因此也想尝试不用 ORM 而在 Python 中直接写 SQL。这种回归传统做法的主要问题是会混淆数据库操作与业务逻辑，但并不是不可行。&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://stackabuse.com/incompatible-type-comparisons-in-python/&quot;&gt;Python 中如何比较不兼容的类型？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇很详细的基础教程，探讨了&lt;code&gt;TypeError&lt;/code&gt; 的含义、出现的原因以及解决方法。文章非常之细致，介绍了 20 多种容易出错的场景，有些是初学者问题，但也有些是老手也易忽视的编程细节。&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;https://florian-dahlitz.de/articles/create-your-own-diff-tool-using-python&quot;&gt;使用 Python 开发一个文件比较工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;有很多版本管理和差异比较工具，但是能否用 Python 开发一个简单的工具实现呢？文章使用 &lt;strong&gt;difflib、argparse 和 HtmlDiff&lt;/strong&gt; 分别开发了命令行工具和 HTML 网页两个版本的文件比较工具。&lt;/div&gt;
&lt;div&gt;16、&lt;a href=&quot;https://eli.thegreenplace.net/2023/my-favorite-prime-number-generator/&quot;&gt;我最喜欢的素数生成函数&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;埃拉托斯特尼筛法是一种生成素数的算法，作者提供了一个 Python 实现，但是代码的性能和内存占用是主要的问题，因此作者做了一些优化改进，最后给出了一个有详细注释的优化版本。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已免费发布了 17 期，访问下方链接，即可查看全部内容：&lt;a href=&quot;https://pythoncat.top/tags/weekly&quot;&gt;https://pythoncat.top/tags/weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有价值，请表达小小心意，赞赏一下猫哥吧~~&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/facebookresearch/codellama&quot;&gt;codellama：Meta 最新开源的代码生成模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;本周最火的开源项目！&lt;strong&gt;Code Llama&lt;/strong&gt; 基于 &lt;strong&gt;Llama 2&lt;/strong&gt;，可免费商用，可预见不久的将来会出现大量的编程工具！目前支持的语言包括 Python、C++、Java、PHP、Typescript/Javascript、C# 和 Bash。值得一提的是，它包含一个“&lt;strong&gt;Code Llama – Python&lt;/strong&gt;”专用版本，基于 100B  token 微调！（star 4K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/facebookresearch/seamless_communication&quot;&gt;seamless_communication：最先进的语音和文本翻译的基础模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;SeamlessM4T&lt;/strong&gt; 也是 Meta 开源的项目，旨在提供高质量的翻译，让不同语言的人通过语音和文本轻松交流。支持 101 种语言的语音输入、96 种语言的文本输入与输出、35 种语言的语音输出。（star 3.7K）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/microsoft/torchscale&quot;&gt;Torchscale：(M)LLM 的基础架构&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;微软开源的一个 PyTorch 库，可让开发者高效地扩展 &lt;strong&gt;Transformers&lt;/strong&gt;，聚焦于提升建模的能力与通用性，同时提升训练的稳定性与效率。（star 2.4K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/zhanymkanov/fastapi-best-practices&quot;&gt;fastapi-best-practices：FastAPI 的最佳实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个 Github 项目是一篇集合了 20 多项 FastAPI 最佳实践的长文，包括项目结构、数据校验、解耦与重用依赖、遵循 REST、文档、linter 等等话题。（star 4.5K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/sumerc/yappi&quot;&gt;yappi：又一个 Python Profiler，支持多线程、asyncio 和 gevent&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;yappi 是 PyCharm 默认的性能分析器之一，它是用 C 编写的，支持多线程、asyncio 和 gevent，可以显示挂机时间与实际 CPU 时间。（star 1.2K）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/fighting41love/funNLP&quot;&gt;funNLP：几乎最全的中文 NLP 资源库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个非常丰富的资料库，包含 NLP/人工智能的大量内容。（star 55.7K）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/chrieke/prettymapp&quot;&gt;prettymapp：在 Web 应用中创建精美的地图&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个 Web 应用和 Python 包，可从 &lt;strong&gt;OpenStreetMap&lt;/strong&gt; 获取数据生成漂亮的地图作品。它基于另一个有 10K star 的项目 &lt;a href=&quot;https://github.com/marceloprates/prettymaps&quot;&gt;prettymaps&lt;/a&gt; ，主要简化了配置、降低代码复杂性、并使用 streamlit 开发了 Web 端应用。（star 1.7K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/eliben/pycparser&quot;&gt;pycparser：纯 Python 实现的完整 C99 解析器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个用 Python 写的 C 语言解析器，可轻松集成到需要解析 C 源代码的程序中。它最主要的用途是在 &lt;strong&gt;cffi&lt;/strong&gt; 库中，用于解析 C 函数和类型的声明。（star 3K）&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/StanGirard/quivr&quot;&gt;quivr：生成式 AI 打造你的第二大脑&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;利用生成式 AI 来存储和检索非结构化的信息，可以理解成支持人工智能的  Obsidian。可以处理各种形式的文件如文本、图片、代码、音频和视频等，依赖于 ChatGPT、Docker、Supabase，只支持操作系统是 Ubuntu 22+。（star 21.7K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/taojy123/KeymouseGo&quot;&gt;KeymouseGo: 类似按键精灵的鼠标键盘录制和自动化操作&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个中文项目。记录用户的鼠标键盘操作，通过触发按钮自动执行之前记录的操作，可设定执行的次数，可以理解为精简绿色版的&lt;strong&gt;按键精灵&lt;/strong&gt;。支持 Windows、Linux 和 Mac 系统。（star 4.3K）&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/CodeOptimist/ahkunwrapped&quot;&gt;ahkunwrapped：集成 AutoHotkey，用 Python 执行自动化&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;AutoHotkey&lt;/strong&gt; 是一种自动化脚本语言和工具，用于在 Windows 上创建快捷键、宏和自动化任务，例如模拟按键和鼠标操作、窗口管理、剪贴板操作、自动化表单填写等。这个项目覆盖了 AutoHotkey API，使用 Python 来桥接，扩展 AutoHotkey 的能力。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/ashishpatel26/500-AI-Machine-learning-Deep-learning-Computer-vision-NLP-Projects-with-code&quot;&gt;100+ AI/机器学习/深度学习/计算机视觉/NLP 项目与代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个仓库收录了很多学习资源，其中很多也是一些聚合类的项目，也就是说实际包含的项目与资料有上万之多。（star 13.2K）&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://github.com/adbar/trafilatura&quot;&gt;trafilatura：一个采集 Web 文本的工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个 Python 包和命令行工具，可以处理 Web 的文本信息，并转化成各种常用格式输出。包含爬虫功能、HTML 解析、网页内容萃取等等。（star 1.9K）&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://m.youtube.com/playlist?list=PLs4CJRBY5F1KwxIxbTmhN9jX4hBtE-OKJ&quot;&gt;2023 年 PyCon 澳大利亚的 84 个视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;澳大利亚今年 PyCon 上的演讲视频。目前已发布 84 个视频。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.youtube.com/playlist?list=PLnOlTVPC-yFwhpiyjsC0V_98pqRbtwNgh&quot;&gt;2023 年 Pycon 以色列的 23 个视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;以色列今年 PyCon 上的演讲视频。目前已发布 23 个视频。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.youtube.com/playlist?list=PL1PbeFStIOoOd01KhBeba-byU5E5dJ716&quot;&gt;2023 年 SciPy Talk 的 44 个视频&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;SciPy Talk 是科学计算领域的年度会议，通常涵盖数据分析、机器学习、人工智能、科学可视化等话题。目前已发布 44 个视频。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🥂讨论&amp;amp;问题&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.reddit.com/r/Python/comments/15z1amc/how_to_build_the_front_end_of_a_web_app_if_you/&quot;&gt;如果只懂 Python，如何构建 Web 程序的前端？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;独自一人开发，想要快速实现全栈的 SaaS 应用，支持用户身份验证、订阅、付款等业务功能，前端该如何选择呢？Reddit 上的这个帖子，或许能给你提供一些思路/方法。&lt;/div&gt;
&lt;div&gt;2、V2EX 上三则关于 Python 后端的热门讨论&lt;/div&gt;
&lt;div&gt;近期在 Python 节点下最热闹的三篇帖子：&lt;a href=&quot;https://www.v2ex.com/t/962899&quot;&gt;Python 后端该如何提升自己呢？&lt;/a&gt; 、&lt;a href=&quot;https://www.v2ex.com/t/965956&quot;&gt;深夜睡不着，思考为什么国内 Python Web 后端太少&lt;/a&gt; 、&lt;a href=&quot;https://www.v2ex.com/t/966460&quot;&gt;Python 做后端，相对于 Java 或者 go 来说，到底差在哪？&lt;/a&gt; 从就业的角度来看，Python 后端在国内确实偏少，不仅后端，其它领域也有一种“热度退潮”的感觉（除了 AI 相关）。Python 潮流周刊的创刊想法之一就是去欧美盗火，为国内 Python 社区注入活力。愿论坛里将来能少一些沮丧性的、要抛弃 xx 另附高枝的情绪吧。&lt;/div&gt;
&lt;h2&gt;🐱赞助&amp;amp;支持&lt;/h2&gt;
&lt;div&gt;如果你喜欢周刊，请分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有价值，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt; 或 &lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！&lt;/div&gt;
&lt;div&gt;如果你想帮助周刊办得更好，欢迎向我们投稿或提出建议：&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly/issues/new&quot;&gt;投稿/建议通道&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你是品牌方或广告主，欢迎私信我，洽谈赞助与合作事项。&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#16：优雅重要么？如何写出 Pythonic 的代码？</title>
            <link>https://pythoncat.top/posts/2023-08-19-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-08-19-weekly/</guid>
            <description>本期周刊分享了 16 篇文章，12 个开源项目，2 则视频</description>
            <pubDate>Sat, 19 Aug 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。标题取自其中两则分享，不代表全部内容都是该主题，特此声明。&lt;/div&gt;
&lt;div&gt;本周刊由 &lt;strong&gt;Python猫&lt;/strong&gt; 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img.pythoncat.top/python_cat.jpg&quot;&gt;微信&lt;/a&gt; | &lt;a href=&quot;https://pythoncat.top&quot;&gt;博客&lt;/a&gt; | &lt;a href=&quot;https://pythoncat.substack.com&quot;&gt;邮件&lt;/a&gt; | &lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;Github&lt;/a&gt; | &lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;Telegram&lt;/a&gt; | &lt;a href=&quot;https://twitter.com/chinesehuazhou&quot;&gt;Twitter&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;为了方便读者获取原始内容，我已将周刊的 Markdown 文件归档在 Github，请通过以下链接获取：&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;https://github.com/chinesehuazhou/python-weekly&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://mathspp.com/blog/pydonts/does-elegance-matter&quot;&gt;写代码时，优雅有意义吗？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者强调使用 Python 的核心特性来编写惯用的、富有变现力的、优雅的代码很重要，提出优雅不是可有可无的奢侈品。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://so1n.me/2023/08/14/python_asyncio_concunrrency_result_share/&quot;&gt;Python Asyncio实践—高并发下如何防止缓存击穿&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了如何基于&lt;code&gt;Asyncio.Future&lt;/code&gt;的特性编写一个语言级别的防缓存击穿的工具——&lt;code&gt;Share&lt;/code&gt;，并介绍它的使用和高并发下的处理方法。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://juejin.cn/post/7266663176980185144&quot;&gt;高效定时任务处理：深入学习 Python 中 APScheduler 库的奥秘&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;APScheduler 是一个强大的定时任务处理库，这篇长文详细介绍了从入门到精通的相关知识，包括创建定时任务、定时任务触发器、任务存储、并发执行、阻塞和非阻塞调度器、错误处理、立即执行任务、调度器持久化、任务监听器和移除定时任务等。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://juejin.cn/post/7266037480750071848&quot;&gt;CPython 开发实战：魔改 lambda 函数&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章尝试将 Python 的 lambda 函数改成 Javascript 风格的箭头函数。在编译 CPython 时，通过修改 &lt;code&gt;.asdl&lt;/code&gt; 文件，重新构造抽象语法树，修改语法分析文件，并利用 &lt;strong&gt;pegen&lt;/strong&gt; 重新生成语法分析器。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://codeconfessions.substack.com/p/cpython-reference-counting-internals&quot;&gt;CPython 是如何实现引用计数的？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;你是否对 CPython 的底层运行原理及其内部结构感到好奇？文章通过分析源码，介绍了 CPython 是如何实现引用计数和内存管理的，涉及引用计数的机制、关键数据结构的解释、字节码指令的执行、引用计数的局限性等。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://coderslegacy.com/python-lazy-loading-with-importlib/&quot;&gt;使用 Importlib 实现 Python 延迟加载&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;延迟加载指的是在使用时再导入模块，而不是在程序刚执行时就加载。它的好处：减少启动时间、降低内存消耗、提高性能、优化资源、运行时加载。文章介绍了&lt;code&gt;importlib&lt;/code&gt; 实现延迟加载的用法。。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://sixfeetup.com/blog/end-to-end-testing-python-playwright&quot;&gt;使用 Python 和 Playwright 进行端到端测试&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;端到端测试（end-to-end）指的是对程序的整个使用流程从头到尾作测试，可能发现单元测试与集成测试都无法发现的问题。这是一篇详细的入门教程，介绍了 &lt;strong&gt;Playwright&lt;/strong&gt; 的相关用法。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://lwn.net/Articles/939981/&quot;&gt;nogil 项目和 Faster CPython 项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 官方虽已宣布会接受 &lt;strong&gt;PEP-703&lt;/strong&gt;，但是最终版本或许要等到 5 年后的 3.17 版本。从 2021 年起，nogil 和 Faster CPython 项目持续吸引大家的关注，这篇文章梳理了它们两年来的发展情况、一些关键性问题的处理方案和重要进展、近期社区和大公司的回应等。（附：&lt;a href=&quot;https://pythoncat.top/posts/2021-11-14-GIL&quot;&gt;Python 官方第一次针对 nogil 的研讨会&lt;/a&gt;、&lt;a href=&quot;https://pythoncat.top/posts/2021-05-16-Guido&quot;&gt;Faster CPython 项目的首次亮相&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://engineering.fb.com/2023/08/15/developer-tools/immortal-objects-for-python-instagram-meta/&quot;&gt;简单介绍 Python 的永生对象&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Instagram 向 Python 贡献了 3.12 版本中的 &lt;a href=&quot;https://peps.python.org/pep-0683/&quot;&gt;PEP-683&lt;/a&gt;（永生对象，使用固定的引用计数），它可以绕过引用计数检查，这是多核 Python 并行处理的重要基础。文章介绍了 Instagram 遇到的内存使用问题、为解决问题而引入永生对象、并最终贡献到 CPython 的故事。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://pybit.es/articles/why-you-should-avoid-import-in-python/&quot;&gt;为什么要避免在 Python 中用“import *”？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 中一个文件是一个模块，拥有自己的命名空间。当使用“import *”时，这会导致“&lt;strong&gt;命名空间污染&lt;/strong&gt;”！文章指出了遵循 PEP-8 风格的正确写法，同时建议应该用&lt;code&gt;__all__&lt;/code&gt; 来定义模块中可被导出的变量名。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://prefix.dev/blog/launching_pixi&quot;&gt;让我们终结 Python 的依赖地狱&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/prefix-dev/pixi&quot;&gt;pixi&lt;/a&gt; 是最新发布的用 Rust 编写的 Python 包管理器，这篇文章出自其官方博客，主要介绍为什么要开发这个项目、它提供了哪些功能、它的基本执行过程。项目当前基于 Conda 生态，暂不支持 PyPI。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://pythonguides.com/jwt-authentication-using-django-rest-framework/&quot;&gt;使用 Django Rest Framework 实现 JWT 身份验证&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇非常详细的教程，介绍了 JWT 是什么以及它的工作原理，演示了如何用 DRF 实现 JWT 身份验证的全过程。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://johnnymetz.com/posts/slow-django-database-queries/&quot;&gt;增强 Django 程序：提升数据库查询的 7 个妙招&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;数据库查询是影响 Web 程序性能的主要因素之一，这篇文章介绍了 7 个提升性能的技巧：设置查询语句的超时时间、使用&lt;code&gt;assertNumQueries&lt;/code&gt; 测试查询数、使用&lt;code&gt;nplusone&lt;/code&gt; 捕获 N+1 查询、使用&lt;code&gt;django-zen-queries&lt;/code&gt; 捕获 N+1 查询、避免对预取对象作新的查询、使用 &lt;code&gt;defer()&lt;/code&gt; 防止获取大的未使用字段、避免在大字段上使用 &lt;code&gt;distinct()&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://martinheinz.dev/blog/103&quot;&gt;可能让你大吃一惊的奇怪的 Python “特性”&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;有时候我们会在编程语言中看到一些奇怪的现象，它们可能是一些非常冷门的“特性”，也可能会让人误以为是 bug 或者因理解错误而造成 bug。作者介绍了他的几个小发现。&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;https://blog.quastor.org/p/khan-academy-rewrote-backend&quot;&gt;可汗学院如何将 Python 后端重写成 Go？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可汗学院使用 Python 做了 10 年的主力语言，然而在 2020 年前后彻底转向了 Go 阵营。这篇文章介绍了它为什么以及如何将 Python 2 后端整体重构成 Go 服务。文中引用了可汗学院总结性的一系列博客，可作延伸阅读。&lt;/div&gt;
&lt;div&gt;16、&lt;a href=&quot;https://hirrolot.github.io/posts/why-static-languages-suffer-from-complexity.html#the-unfortunate-consequences-of-being-static&quot;&gt;为什么静态语言会面临复杂性的挑战？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一篇思考编程语言该如何设计的长文！作者指出现代编程语言存在“&lt;strong&gt;静态-动态双形性&lt;/strong&gt;”问题，提出理想的编程语言应该同时具有静态和动态的特性。文章分析了 &lt;strong&gt;Idris&lt;/strong&gt; 和 &lt;strong&gt;Zig&lt;/strong&gt; 两种语言的做法，并指出其局限性，最后提出应该重新思考编程语言。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已免费发布了 16 期，访问下方链接，即可查看全部内容：&lt;a href=&quot;https://pythoncat.top/tags/weekly&quot;&gt;https://pythoncat.top/tags/weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有价值，请表达小小心意，赞赏一下猫哥吧~~&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/prefix-dev/pixi&quot;&gt;pixi：Rust 开发的基于 Conda 的包管理器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个基于 Conda 生态的包管理器，支持所有操作系统，支持多种语言的 Conda 包，拥有类似 Cargo 的命令行界面，完全用 Rust 编写。支持按照项目来安装包，也支持全局安装，此行为类似于 &lt;strong&gt;pipx&lt;/strong&gt; 和 &lt;strong&gt;condax&lt;/strong&gt;。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/beeware/briefcase&quot;&gt;briefcase：将 Python 项目转换为独立的应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;支持打包成 Mac、Windows、Linux、Android 和 iPhone 的应用，以及使用了 PyScript 作客户端的静态 Web 站点。（star 2K）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/modelscope/facechain&quot;&gt;facechain：可生成数字分身的深度学习工具链&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;上周的热门项目，仅需三张照片即可生成个人的数字分身。底层使用了 Stable Diffusion 的文生图功能，训练时可选择多种风格的 LoRA 模型，也支持添加个性化的 prompt，实现变装效果。（star 3.2K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/modelscope/modelscope&quot;&gt;modelscope：将 Model-as-a-Service 概念变为现实&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;“模型即服务”（MaaS）汇集 AI 社区中最先进的机器学习模型，并简化在实际应用中使用 AI 模型的流程。它已有 700+ 模型，涵盖自然语言处理、计算机视觉、语音、多模态等。（star 3.6K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/veekaybee/viberary&quot;&gt;viberary：基于语义的书籍搜索引擎&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;不是根据体裁和书名等常规条件，而是根据提示语来搜索相关的书籍。基于&lt;a href=&quot;https://blog.reachsumit.com/posts/2023/03/two-tower-model/&quot;&gt;双塔语义检索模型&lt;/a&gt; ，使用 DuckDB 在本地训练数据，使用 Redis Search 模块作检索，通过 Flask API 和 Bootstrap 前端展示结果。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/polarsource/polar&quot;&gt;polar：帮助开源维护者获得更好的资助&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它为开源维护者搭建一个平台，可便捷地设置、运营、推广面向支持者的增值及订阅服务，帮助开发者从开源项目中获取收入。这个项目已获得 180 万美元的种子轮投资。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/plbrault/youre-the-os&quot;&gt;youre-the-os：一个游戏，让你扮演操作系统！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个很有意思的游戏！你需要扮演操作系统，管理进程、内存和 I/O 事件，不能让进程空闲太久，不然就 game over！项目依赖 Python 3.11 和 &lt;strong&gt;pipenv&lt;/strong&gt;，也可以上这个网站&lt;a href=&quot;https://plbrault.github.io/youre-the-os/&quot;&gt;在线体验&lt;/a&gt; 。（star 1K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/spandanb/learndb-py&quot;&gt;learndb-py：通过从头实现数据库来学习&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个项目从头实现一个关系型数据库，借鉴了 &lt;strong&gt;sqlite&lt;/strong&gt; 数据库。关键的特性：支持丰富的 sql、使用&lt;code&gt;lark&lt;/code&gt; 构建自定义词法分析与解析器、支持用户和代理方式连接、实现 BTree 作数据存储。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/sybrenjansen/mpire&quot;&gt;mpire：比标准库更快的多进程开发库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;比其它多进程库更快，且功能更多：结合了 &lt;code&gt;multiprocessing.Pool&lt;/code&gt; 使用写时复制的共享对象的优点、有丰富的状态管理功能、使用 tqdm 实现进度条、支持在仪表板查看进度，等等。（star 1.5K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/joxeankoret/diaphora&quot;&gt;diaphora：二进制文件的差异比对工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何比对一个软件在两个版本间的差异？比较二进制软件的差异时，涉及哪些匹配技术？这个项目号称是目前最强的软件差异比对工具！（star 3.1K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/beartype/beartype&quot;&gt;beartype：近实时的静态类型检查工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个近实时（NRT）的纯 Python 运行时类型检查工具，将 Rust 和 C++ 的零成本对象带入动态类型的 Python 世界。它可有选择性地将 Python 的鸭子类型转换成静态类型，同时默认保留前者的优点。项目文档中称“你可以同时像鸭子一样嘎嘎叫，以及像熊一样咆哮”！（star 2K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/AzatAI/cs_books&quot;&gt;cs_books：AzatAI 推荐的计算机科学书籍&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个仓库收录了 200 多本计算机科学类书籍，仅限教育用途！&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.youtube.com/watch?v=wf-BqAjZb8M&quot;&gt;超越 PEP-8 — 漂亮易懂代码的最佳实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个视频出自 PyCon 2015，介绍如何写出优雅的 Python 代码。在油管上已有 8200+ 点赞。演讲者 Raymond Hettinger 参与贡献了大家熟知的很多 Python 特性，比如 enumerate() 函数、生成器表达式、OrderedDict()、条件表达式、set 对象等。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.youtube.com/watch?v=spi0N_PNznE&quot;&gt;只需 5 个步骤，将“勉强能用”的代码变成 Pythonic&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;写出能用的代码不应该成为最终目标，这只是一个开始！这个视频使用了__getitem__、__len__、__enter__ 和 __exit__ 等魔术方法，将难以维护的代码重构得 Pythonic。作者自称这是对上一则分享的 8 分钟浓缩版。&lt;/div&gt;
&lt;h2&gt;🐱赞助&amp;amp;支持&lt;/h2&gt;
&lt;div&gt;如果你觉得周刊有价值，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt; 或 &lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！&lt;/div&gt;
&lt;div&gt;如果你喜欢周刊，请分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#15：如何分析异步任务的性能？</title>
            <link>https://pythoncat.top/posts/2023-08-12-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-08-12-weekly/</guid>
            <description>本期周刊分享了 14 篇文章，9 个开源项目，4 则播客</description>
            <pubDate>Sat, 12 Aug 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。标题取自其中一则分享，不代表全部内容都是该主题，特此声明。&lt;/div&gt;
&lt;div&gt;本周刊精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;&amp;gt;&amp;gt;&amp;gt; &lt;a href=&quot;https://img.pythoncat.top/python_cat.jpg&quot;&gt;微信&lt;/a&gt; | &lt;a href=&quot;https://pythoncat.top&quot;&gt;博客&lt;/a&gt; | &lt;a href=&quot;https://pythoncat.substack.com&quot;&gt;邮件&lt;/a&gt; | &lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;Github&lt;/a&gt; | &lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;Telegram&lt;/a&gt; | &lt;a href=&quot;https://twitter.com/chinesehuazhou&quot;&gt;Twitter&lt;/a&gt; &amp;lt;&amp;lt;&amp;lt;&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&quot;https://blog.balthazar-rouberol.com/how-to-profile-a-fastapi-asynchronous-request&quot;&gt;如何分析 FastAPI 异步请求的性能？&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;&lt;strong&gt;cProfile&lt;/strong&gt; 这种基于函数调用的分析工具无法有效分析异步操作的执行时间，文章介绍了 &lt;a href=&quot;https://github.com/joerick/pyinstrument&quot;&gt;pyinstrument&lt;/a&gt; 这个分析库，结合 &lt;strong&gt;FastAPI.middleware&lt;/strong&gt; 装饰器，并使用 &lt;a href=&quot;https://github.com/jlfwong/speedscope&quot;&gt;speedscope&lt;/a&gt; 来可视化 FastAPI 程序的耗时情况。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://noplacelikelocalhost.medium.com/leveraging-background-tasks-in-fastapi-enhancing-performance-and-responsiveness-6e4ad64c7d16&quot;&gt;利用 FastAPI 的后台任务：增强性能和响应能力&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;介绍了 FastAPI 的 BackgroundTasks，可以创建后台任务，用于管理长时间运行的任务，而不阻塞主进程。&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://compucademy.net/creating-histograms-with-python/&quot;&gt;使用 Python 创建直方图&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;直方图又名“柱状图”，可直观查看数据的分布趋势、离散程度和异常值等信息。文中介绍了 Matplotlib、Plotly、Seaborn、Numpy 和 Pandas 等工具绘制直方图的方法，介绍各种直方图的样式和风格、处理异常值、分析时间序列数据等。&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://mypy-lang.blogspot.com/2023/08/mypy-15-released.html&quot;&gt;Mypy 1.5 发布了&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;Mypy 是 Python 的静态类型检查工具，1.5 版本主要功能有：不再支持 Python 3.7、更灵活的 TypedDict 创建和更新、可显示错误代码的文档链接、实验性改进了泛型函数的类型推断、对 Python 3.12 的部分支持，等等。&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://jvns.ca/blog/2023/08/03/behind--hello-world/&quot;&gt;在 Linux 上运行 Python 的“Hello World”脚本时，会发生什么？&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;在 py 文件中写上一句&lt;code&gt;print(&quot;hello world&quot;)&lt;/code&gt;，然后在命令行执行这个文件，幕后都发生了什么呢？文章使用了 &lt;code&gt;readelf&lt;/code&gt; 、&lt;code&gt;strace&lt;/code&gt; 、&lt;code&gt;ldd&lt;/code&gt; 、&lt;code&gt;debugfs&lt;/code&gt; 、&lt;code&gt;/proc&lt;/code&gt; 、&lt;code&gt;ltrace&lt;/code&gt; 、&lt;code&gt;dd&lt;/code&gt; 和 &lt;code&gt;stat&lt;/code&gt; 等工具，详细解释了脚本被执行的过程。主要涉及操作系统相关的内容，而不是 CPython 解释器。（附：文章还引用了最近很火的 &lt;a href=&quot;https://cpu.land/&quot;&gt;Putting the “You” in CPU &lt;/a&gt; ，介绍计算机是如何运行程序的，强烈推荐！）&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://kenschutte.com/postscript-vs-python&quot;&gt;通过对比 Python 来学习 PostScript&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;PostScript 是电子出版和桌面出版领域的页面描述语言，广泛用于打印机、出版和图形设备。文章将一段 PostScript 程序直译成 Python 代码，可以让你快速了解这门语言的语法。&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://www.nathom.dev/blog/casual_performance_optimization_python/&quot;&gt;Python 中不那么随意的性能优化&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;作者的一段代码，用 Rust 花了 950 毫秒，而 Python 却花 70 秒！这怎么能忍！将生成器写法改成 for 循环后，只是轻微提速，使用 Numpy 和多进程做了一些优化后，终于看到了比较可观的数据。不同代码方案的对比、Python 底层工作原理、内存使用效率问题，以及语言特性的差异。&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://www.pythonmorsels.com/creating-a-context-manager/&quot;&gt;在 Python 中创建上下文管理器&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;如何用 Python 创建自己的上下文管理器？上下文管理器是可以在 &lt;code&gt;with&lt;/code&gt; 代码块中使用的对象，在进入和退出时做一些操作。文章介绍了上下文管理器的实现细节。&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://kenschutte.com/python-swap-ints&quot;&gt;一个简单的模块，可以篡改 Python 解释器的数字&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;一篇有意思的文章。导入一个模块后，可以将 8 和 9 互换，即&lt;code&gt;print(8)&lt;/code&gt; 会打印出 9。文章展示了如何用 C 编写一个简单的模块，介绍了 CPython 中整数对象池的实现，并通过修改两个整数的引用，实现一个简单的篡改数字的效果。&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://josvisser.substack.com/p/why-python-is-terrible&quot;&gt;为什么说 Python 很糟糕……&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;一篇给 Python 泼冷水的文章，主要观点是认为 Python 不适合于开发大型应用。批评的点包括动态和鸭子类型、性能问题、代码维护和重构难等问题。&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://pybit.es/articles/python-errors-should-not-pass-silently/&quot;&gt;Python 中错误处理的最佳实践&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;Python 之禅说“错误不应该悄无声息地被忽略”，强调了应该直面错误和透明处理。文章指出了一些糟糕的错误处理写法，给出了尽早检查错误、快速失败处理等编程建议。&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://www.pythongasm.com/build-gpt-powered-chatbots-around-enterprise-data-with-python&quot;&gt;使用企业数据和 Python 构建 GPT 对话机器人&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;这篇教程介绍了搭建企业中 GPT 对话机器人的完整流程，包括数据索引、查询检索、集成 LLM、使用 FastAPI 开发接口、uvicorn 作部署。&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://www.bitecode.dev/p/python-cocktail-mix-a-context-manager&quot;&gt;Python 鸡尾酒：将上下文管理器和迭代器等量混合&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;&lt;strong&gt;tenacity&lt;/strong&gt; 库提供了一种用迭代器和上下文管理器组合的写法，实现重试机制。这篇文章演示了如何用自定义的迭代器和上下文管理器，来实现同样的功能，可以让你更深入理解这两个好用的特性。&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://stackabuse.com/the-power-of-indexing-boosting-data-wrangling-efficiency-with-pandas/&quot;&gt;索引的力量：利用 Pandas 提高数据整理效率&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;Pandas 被广泛用于数据处理，文章介绍了如何高效利用索引技术，提升它整理数据的速度和效率。介绍了多种索引技术，例如基于整数的索引、布尔索引、设置新索引并重置旧索引、排序索引。&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://www.tinybird.co/blog-posts/killing-the-processpoolexecutor&quot;&gt;杀死 ProcessPoolExecutor&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;Python 不适合处理 CPU 密集型任务，文章中项目原本使用进程池来规避 GIL 问题，后使用线程、C++ 扩展和更精细调整的 GIL 控制，将内存使用量减少 50%，CPU 使用量减少约 20%，线程和进程减少约 70%，I/O 流量减少 100%。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已免费发布了 15 期，访问下方链接，即可查看全部内容：&lt;a href=&quot;https://pythoncat.top/tags/weekly&quot;&gt;https://pythoncat.top/tags/weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有价值，请表达小小心意，赞赏一下猫哥吧~~&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&quot;https://github.com/joerick/pyinstrument&quot;&gt;pyinstrument：Python 的调用堆栈分析器&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;一个轻量级、无侵入的 Python 代码性能分析库，支持分析异步任务和事件循环代码，可生成多种格式的分析报告，包括文本、HTML 和火焰图。（star 5.5K）&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://github.com/gaogaotiantian/viztracer&quot;&gt;viztracer：低开销的日志记录/调试/分析工具，可视化 Python 代码的执行&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;国人开源的日志记录/调试/分析工具，支持线程、多进程、子进程和异步，支持火焰图、远程连接、虚拟调试等，有强大的前端，可流畅渲染 GB 级堆栈信息。（star 3.5K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://github.com/jd/tenacity&quot;&gt;tenacity：Python 重试库&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;可提供简单而灵活的方式来实现可靠的重试机制，支持指定重试次数、重试间隔时间、重试的回调函数、根据不同的错误条件进行重试等功能，减少手动处理错误和异常的麻烦。（star 5.1K）&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://github.com/litestar-org/litestar&quot;&gt;litestar：轻量、灵活且可扩展的 ASGI API 框架&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;一个高性能的 ASGI API 框架，其早期版本是基于 &lt;a href=&quot;https://github.com/encode/starlette&quot;&gt;Starlette&lt;/a&gt; 开发的，命名为 &lt;strong&gt;Starlite&lt;/strong&gt;，但从 2.0 版本起已完全移除 Starlette 依赖，并改名为 litestar。核心特性：基于类的控制器、依赖注入、分层中间件、插件系统、OpenAPI 3.1、内置 Trio，等等。（star 2.5K）&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://github.com/junshutang/Make-It-3D&quot;&gt;Make-It-3D：利用单个图像创建高保真 3D 模型&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;从图片中分割物体，创建高保真的 3D 几何形状，可作 360° 旋转展示。（star 1.2K）&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://github.com/ErwannMillon/Color-diffusion&quot;&gt;Color-diffusion：对黑白图像进行着色的扩散模型&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;使用 diffusion  模型对黑白图像进行着色，使用 LAB 色彩空间实现，这是 RGB 色彩空间的 3 通道替代方案。&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://github.com/kuafuai/DevOpsGPT&quot;&gt;DevOpsGPT：AI 驱动的自动化软件开发系统&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;将 LLM 与 DevOps 工具相结合，将自然语言需求转换为可工作的软件。无需繁琐的需求文档编写与沟通，缩短开发与交付时间，加速软件部署和迭代。（star 1.2K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://github.com/Instagram/LibCST&quot;&gt;ILibCST：Python 的具体语法树解析器和序列化器库&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;具体语法树（Concrete Syntax Tree）是在词法分析和语法分析阶段后生成的一种数据结构，可用于分析代码结构，执行语义分析、重构优化和代码生成等操作。（star 1.2K）&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://github.com/HypothesisWorks/hypothesis&quot;&gt;hypothesis：功能强大、灵活且易于使用的库，用于基于属性的测试&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;基于属性的测试（Property-based Testing）是一种软件测试方法，其中测试用例的生成和验证是基于定义的属性或规约。传统的单元测试要给定具体的测试用例，而基于属性的测试则是随机生成大量的测试数据。（star 6.8K）&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&quot;https://pythonpeople.fm/&quot;&gt;Python People 播客&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;这是一档新上线一个月的播客栏目，每周访谈 Python 社区里一位有突出贡献的大佬。目前已访谈的嘉宾有 Michael Kennedy（Talk Python to Me 和 Python Bytes 的主理人）、Paul Everitt（ JetBrains 和 PyCharm 的开发者倡导者）、Brett Cannon（Python 核心开发者）、Barry Warsaw（Python 核心开发者，非常早的成员）、Bob Belderbos（Pybites 的主理人）。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://talkpython.fm/episodes/show/426/whats-new-in-pyscript-august-2023&quot;&gt;Talk Python To Me #426：PyScript 的新增功能&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;Pyscript 使 Python 能够在浏览器中运行。这期播客聊了它的最新进展。&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://stackoverflow.blog/2023/08/08/understanding-sre-ep-597/&quot;&gt;Stack Overflow Blog #597：了解 SRE&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;网站可靠性工程（Site Reliability Engineering，SRE）是什么？它和 DevOps 有什么关系？如何平衡 SRE 的原则与组织结构的关系？生成式 AI 对 SRE 会带来什么影响？&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;https://stackoverflow.blog/2023/07/25/how-the-python-team-is-adapting-the-language-for-an-ai-future-ep-593/&quot;&gt;Stack Overflow Blog #593：Python 团队如何调整语言以适应 AI 的未来&lt;/a&gt;&lt;/h3&gt;
&lt;div&gt;播客嘉宾是 Python 核心开发者和指导委员会成员 Pablo Galindo Salgado，讨论了如何平衡语言设计中的一致性和新功能、为什么收集社区对新版本的反馈很重要，以及为何他要专注于让 Python 更快。&lt;/div&gt;
&lt;h2&gt;🐱赞助&amp;amp;支持&lt;/h2&gt;
&lt;div&gt;如果你觉得周刊有价值，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt; 或 &lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！&lt;/div&gt;
&lt;div&gt;如果你喜欢周刊，请分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#14：Lpython 高性能编译器、Python 与 JavaScript 实现互通</title>
            <link>https://pythoncat.top/posts/2023-08-05-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-08-05-weekly/</guid>
            <description>本期周刊分享了 15 篇文章，12 个开源项目，1 则播客</description>
            <pubDate>Sat, 05 Aug 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，本期分享的全部是英文材料。（标题取自其中两则分享，不代表全部内容都是该主题，特此声明。）&lt;/div&gt;
&lt;div&gt;本周刊由 &lt;strong&gt;Python猫&lt;/strong&gt; 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;周刊已开通 Telegram 频道&lt;/strong&gt;，欢迎加入：&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;https://t.me/pythontrendingweekly&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://lpython.org/blog/2023/07/lpython-novel-fast-retargetable-python-compiler/&quot;&gt;LPython：新颖、高性能、适用于多平台的 Python 编译器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;最新发布的一个Python 编译器（当前为 alpha 版本），目标是打造高性能的 Python。可以将带有类型提示的 Python 代码编译为优化的机器代码，支持提前编译（AOT）与即时编译（JIT），支持与 CPython 互操作，支持多种后端，例如 LLVM、C、C++、WASM、Julia 和 x86。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://cython.readthedocs.io/en/latest/src/changes.html&quot;&gt;Cython 3.0.0 的文档&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Cython 是一门专用于提升 Python 性能的编程语言，最近从 0.29.x 版本直接升到了 3.0.0 版本，带来了大量的问题修复以及新特性，这份 changelog 文档非常丰富。（附一篇&lt;a href=&quot;https://mp.weixin.qq.com/s/CcC1QEojybyRpzUUiJxdAw&quot;&gt;详解历时五年的 Cython3.0 都发生了哪些变化&lt;/a&gt; ，总结了这个版本的几项较大的变化点。）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.marsja.se/coefficient-of-variation-in-python-with-pandas-numpy/&quot;&gt;Python 中使用 Pandas 和 NumPy 计算变异系数&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;变异系数（Coefficient of Variation，CoV）是一种统计量，用于评估数据集相对于其均值的相对变异性或离散程度。文章介绍了变异系数的公式、解释、意义和实际用途，以及如何用 Pandas 和 Numpy 来计算变异系数。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://blog.jupyter.org/generative-ai-in-jupyter-3f7174824862&quot;&gt;Jupyter 中的生成式 AI&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Jupyter Notebook 也支持 AI 功能了，目前免费提供。官博这篇教程指导了如何在聊天界面使用 Jupyter AI 完成各项任务。支持来自 AI21、Anthropic、AWS、Cohere、HuggingFace Hub 和 OpenAI 的大语言模型。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.tartley.com/posts/structured-pattern-matching-in-python/&quot;&gt;Python 中的结构化模式匹配&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 3.10 版本的模式匹配语法，你用过了么？这篇文章探究了这种语法的相关要素（基本结构、每种模式的演示），也思考了是否真必要用模式匹配语法替换&lt;code&gt;elif&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://textual.textualize.io/blog/2023/07/27/using-rich-inspect-to-interrogate-python-objects/&quot;&gt;使用 Rich 的 Inspect 查看 Python 对象属性&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Rich 是一个在终端使用富文本和美观样式的库（本期周刊的“项目&amp;amp;资源”中有介绍），这篇文章介绍了它的 inspect() 函数，可以查看 Python 对象的属性以及可用的 API。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://sethmlarson.dev/pep-440&quot;&gt;Python 包版本控制的怪癖&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个冷门话题，讨论了 Python 包的版本号。我才知道 Python 包版本命名竟有 6 个组成部分！文章大部分内容是对 &lt;a href=&quot;https://peps.python.org/pep-0440/&quot;&gt;PEP-440（版本标识和依赖规范）&lt;/a&gt; 的介绍与解读，最后也介绍到了 Wheel 包的版本命名规则。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://superfastpython.com/file-io-concurrent-patterns/&quot;&gt;文件 I/O 并发编程的模式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用并发编程来提升文件 I/O 操作的性能，具体有哪些使用手段呢？文章介绍了四种模式（单线程、线程池/进程池、批处理任务、在进程池中使用线程池），并讨论了该如何选择更合适的模式。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://mostlypython.substack.com/p/reading-code?nthPub=581&quot;&gt;如何高效地阅读 Python 代码？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;对于所有程序员来说，阅读代码都是一项必备能力。但是，如何高效地阅读与理解别人的代码呢？这篇文章介绍了一些阅读策略与技巧，同时站在阅读者的视角，也有助于我们写出更具可读性、可理解性的代码。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://www.askpython.com/python/examples/call-java-using-python&quot;&gt;如何在 Python 中用 JPype 与 Pyjnius 调用 Java 代码？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Java 和 Python 各有优点，如何能将它们结合起来呢？这篇文章介绍了如何用 &lt;strong&gt;JPype&lt;/strong&gt; 和 &lt;strong&gt;Pyjnius&lt;/strong&gt; 等方式来调用 Java，同时指出实现方案所面临的挑战和限制。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://dev.to/willp/call-javascript-code-in-python-551a&quot;&gt;如何在 Python 中调用 JavaScript 代码？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了 &lt;a href=&quot;https://github.com/Distributive-Network/PythonMonkey&quot;&gt;PythonMonkey&lt;/a&gt; 库的用法，实现在 Python 中加载与运行 JavaScript 代码，以及在 Python 中使用 WASM。（附作者的其它文章：&lt;a href=&quot;https://medium.com/@willkantorpringle/executing-rust-in-python-using-webassembly-d361eb5583da&quot;&gt;使用 WebAssembly 在 Python 中执行 Rust 代码&lt;/a&gt; 、&lt;a href=&quot;https://medium.com/@willkantorpringle/calling-c-function-from-python-using-webassembly-63a305248951&quot;&gt;使用 WebAssembly 在 Python 中调用 C 函数&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://chaoticengineer.hashnode.dev/textual-and-chatgpt&quot;&gt;使用 Textual 构建 ChatGPT TUI 应用程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;本期周刊有好几则内容与 &lt;a href=&quot;https://github.com/Textualize/textual&quot;&gt;Textual&lt;/a&gt; 相关！与图形用户界面（GUI）相比，文本用户界面（TUI）响应更快、系统要求更低和更易自动化。这篇文章使用 Textual 构建了一个 ChatGPT 对话工具。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://code.dblock.org/2023/06/16/getting-started-with-vector-dbs-in-python.html&quot;&gt;Python 中的向量数据库入门&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何在 Python 中使用当前热门的向量数据库呢？这篇文章介绍了使用 10 多种数据库来索引及搜索向量数据，包括 ClickHouse、OpenSearch、pgVector、Pinecone、Redis 等等。&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://dev.to/cwprogram/a-tour-of-cpython-compilation-cd5&quot;&gt;CPython 的编译过程是怎样的？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;CPython 是 Python 官方的解释器实现，这篇长文介绍了它的编译过程，包括语法解析、抽象语法树、字节码、pyc 解析等内容。&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;https://dev.to/mintzworld/the-new-pdbp-pdb-python-debugger-2blc&quot;&gt;介绍新开源的 Python 调试器 pdbp (Pdb+)！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者指出了 Python 内置的 &lt;strong&gt;pdb&lt;/strong&gt; 与其它调试器（如 &lt;strong&gt;ipdb、pdbpp&lt;/strong&gt;）的缺点，介绍了他开发的 pdbp 所作的修复和改进，以及简单的入门使用。这个库依赖项很少，功能强大，值得一试。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已免费发布了 14 期，访问下方链接，即可查看全部内容：&lt;a href=&quot;https://pythoncat.top/tags/weekly&quot;&gt;https://pythoncat.top/tags/weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有价值，请表达小小心意，赞赏一下猫哥吧~~&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pyflo.net/&quot;&gt;PyFlo：一个很有趣的 Python 入门教学网站&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个网站非常惊艳，推荐大家去体验下！主页是一幅学习线路图，画了不同的学习分支和内容分类，还有几个编程项目挑战，点击每个节点则跳转到对应内容的页面。（借鉴此网站的创意，开发面向中文读者的教学网站，应该会挺有趣）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://pandastutor.com/&quot;&gt;Pandas Tutor：可视化 Pandas 执行过程的网站&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;你或许已知道 &lt;a href=&quot;https://pythontutor.com/&quot;&gt;Python Tutor&lt;/a&gt;，它是一个提供了在线交互式 Python 编程环境的教学工具。这里介绍的 Pandas Tutor 也是类似的网站，它允许在浏览器中编写 Pandas 代码，并可视化数据的转换过程。 （附一篇文章，两位作者介绍了他们将 &lt;a href=&quot;https://blog.pyodide.org/posts/pandastutor/&quot;&gt;Pandas Tutor 移植到 Pyodide &lt;/a&gt; 的工作，以便大规模推广数据科学的教学）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://ploomber-sql.readthedocs.io/en/latest/index.html&quot;&gt;ploomber-sql：使用 SQL 和 Jupyter 开发端到端的应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是托管在 Read The Docs 上的一个教学课程，介绍了如何使用 SQL 和 Jupyter 作数据分析，包含操作数据库、高级查询技术、数据可视化（&lt;strong&gt;seaborn、plotly、ggplot&lt;/strong&gt;）、项目打包部署与监控等章节。它出自于开源项目 &lt;a href=&quot;https://github.com/ploomber/ploomber&quot;&gt;ploomber&lt;/a&gt; （star 3.1K），后者是一个快速构建数据管道的项目。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/bloomberg/memray&quot;&gt;memray：Python 的内存分析器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是周刊&lt;a href=&quot;https://pythoncat.top/posts/2023-07-22-weekly&quot;&gt;第 12 期&lt;/a&gt;介绍过的 &lt;strong&gt;pystack&lt;/strong&gt; 的姊妹项目，可以跟踪 Python 代码、C/C++ 扩展模块和 Python 解释器本身中的内存分配，支持本机模式与实时查看模式，可生成多种类型的报告。提供了 Pytest 插件 &lt;a href=&quot;https://github.com/bloomberg/pytest-memray&quot;&gt;pytest-memray&lt;/a&gt;，可以在运行测试套后查看内存报告。（star 11K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/1j01/textual-paint&quot;&gt;textual-paint：终端中的 MS Paint&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;MS Paint&lt;/strong&gt; 是微软公司开发的一款简单的图像编辑软件。这个项目是 MS Paint 风格的 TUI 图像编辑器，支持在终端中打开与保存图像、MS Paint 中的所有工具、调色板、画笔预览等等功能。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/Textualize/rich&quot;&gt;rich：在终端中提供富文本和美观的样式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Rich 让终端不再单调，可以绘制漂亮的表格、进度条、markdown、源代码语法高亮以及栈回溯信息等。（star 44.2K）下面这张效果图，囊括了它的主要特色：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/Salaah01/json-lineage&quot;&gt;json-lineage：支持解析大型 JSON 文件的工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是用 Rust 开发的 JSON 解析库，主要解决大文件无法加载到内存的痛点，通过将 JSON 转化成 JSONL 格式，解决内存消耗问题。测试表明，处理一个 500MB 文件，Python 标准库要用 2GB 内存，但这个库仅需 1.5MB，而且速度差异很小。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/Distributive-Network/PythonMonkey&quot;&gt;PythonMonkey：嵌入到 Python VM 中的 JavaScript 引擎&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;前文已出现过 PythonMonkey，它将 Mozilla 的 SpiderMonkey JavaScript 引擎嵌入到 Python 虚拟机中，利用Python 引擎提供 JS 主机环境。这个项目的目标包括在 Python 中调用 JavaScript 库和在 JavaScript 中调用 Python 库，如果能有效打通这两种语言的生态，前途不可估量！&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/rapidsai/cudf&quot;&gt;cudf：GPU 数据帧库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;cuDF 基于 &lt;strong&gt;Apache Arrow&lt;/strong&gt; 列式内存格式构建，是一个 GPU DataFrame 库，用于加载、连接、聚合、过滤和以其它方式操作数据。提供了类似 pandas 的 API，无需了解 CUDA 编程的细节。（star 5.8K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/segmind/distill-sd&quot;&gt;distill-sd：更小更快的 Stable Diffusion&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;对 Stable Diffusion 作“知识蒸馏”后的小型化版本，可生成与 SD 质量相当的图像，同时速度更快、空间占用更少。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/jiawen-zhu/HQTrack&quot;&gt;HQTrack：高质量追踪视频中的任何事物&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个对视频中对象作高性能跟踪和分割的框架，由视频多目标分割器（VMOS）和掩模优化器（MR）组成，可以同时跟踪多个目标物体并输出准确的物体掩模。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/kelvins/awesome-mlops&quot;&gt;awesome-mlops：很棒的 MLOps 工具精选列表&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个 awesome 系列的 MLOps 精选列表，包含各种各样的项目/工具，以及文章、书籍、活动、播客和网站等等资源。&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://talkpython.fm/episodes/show/425/memray-the-endgame-python-memory-profiler&quot;&gt;Talk Python To Me #425：终极的 Python 内存分析器 Memray&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;本期的“项目&amp;amp;资源”介绍了 Memray，这里的播客节目邀请了两位嘉宾深入聊了这个项目。&lt;/div&gt;
&lt;h2&gt;🐱赞助&amp;amp;支持&lt;/h2&gt;
&lt;div&gt;如果你觉得周刊有价值，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt; 或 &lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！&lt;/div&gt;
&lt;div&gt;如果你喜欢周刊，请分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#13：Jupyter Notebook 7 发布了，无 GIL 提案传来大好消息！</title>
            <link>https://pythoncat.top/posts/2023-07-29-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-07-29-weekly/</guid>
            <description>本期周刊分享了 15 篇文章，12 个开源项目，1 则热门话题</description>
            <pubDate>Sat, 29 Jul 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文，已在小标题注明。（标题取自其中一则分享，不代表全部内容都是该主题，特此声明。）&lt;/div&gt;
&lt;div&gt;本周刊精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;周刊已开通 Telegram 频道&lt;/strong&gt;，欢迎加入：&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;https://t.me/pythontrendingweekly&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://blog.jupyter.org/announcing-jupyter-notebook-7-8d6d66126dcf&quot;&gt;Jupyter Notebook 7 隆重发布&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Jupyter Notebook 大版本更新，亮点包括实时协作、交互式调试、目录、主题和深色模式、国际化、改进的可访问性、移动设备上的紧凑视图。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://juejin.cn/post/7258881840823615544&quot;&gt;Python 中的弱引用与基础类型支持情况探究&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 的基础类型 Int、List、Dict、Tuple、Str 不支持弱引用，而 Object、Type、Set 等类型却支持弱引用，为什么会出现这种情况呢？文章给出了自己的分析。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;http://so1n.me/2023/07/23/distributed_lock_lntroduction_and_lmplementation/&quot;&gt;分布式锁的介绍与 Python 实现&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;什么情况下要使用分布式锁？如何用 py-redis 实现分布式锁，加锁与解锁的流程是怎样的？加锁的超时时间有什么注意点，如何实现 WatchDog 给锁自动续约？&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://scofield.hashnode.dev/unlocking-the-power-of-pyscript-a-guide-to-running-python-code-in-your-html&quot;&gt;释放 PyScript 的力量：在 HTML 中运行 Python 代码&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一篇 PyScript 入门教程，介绍了安装、基础知识、配合 Flask 的使用以及高级功能。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://superfastpython.com/faster-file-io-with-concurrency/&quot;&gt;通过并发实现更快的文件 I/O&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;什么是文件 I/O，为什么它会比主内存 I/O 慢很多？文件 I/O 的速度与哪些因素有关？有哪些提升文件 I/O 性能的方法？&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://dev.to/atkumar/how-to-write-impeccably-clean-code-that-will-save-your-sanity-4np9&quot;&gt;如何编写完美干净的 Python 代码？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章介绍了一些最佳编程实践，涵盖代码结构、pre-commit、类型提示、文档字符串、lint、Pydantic、拼写检查、测试等方面。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://betterstack.com/community/guides/logging/best-python-logging-libraries/&quot;&gt;Python 日志记录：对比最流行的 6 个库&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章详细对比了当前最为流行的 6 种日志框架：&lt;strong&gt;logging、loguru、structlog、Eliot、logbook 与 picologging&lt;/strong&gt; 。最推荐的无疑是前两个，其它权当兴趣尝鲜吧。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://adamj.eu/tech/2023/07/23/python-profile-section-cprofile/&quot;&gt;使用 cProfile 分析模块级代码&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;如何使用 &lt;strong&gt;cProfile&lt;/strong&gt; 来对 Python 代码进行性能分析？文章简单介绍了它的用法，并给出了上下文管理器与装饰器两种高级用法。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://www.codium.ai/blog/mastering-functional-programming-in-python/&quot;&gt;掌握 Python 函数式编程&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章介绍了函数式编程的优点、Python 对函数式编程的支持、最佳实践以及编写 Python 程序时要避免的错误。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://realpython.com/python312-f-strings/&quot;&gt;Python 3.12 预览版：更直观和一致的 f-string&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;在 Python 3.12 之前，f-string 有什么限制？即将发布的 3.12 版本会带来哪些变化呢？新功能前瞻：嵌入表达式可以重用引号、f-string 中允许使用反斜杠、多行表达式中可写注释、任意级别的 f-string 嵌套、优化了 f-string 的错误提示……&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://dev.to/akarshan/asynchronous-python-magic-how-to-create-awaitable-constructors-with-asyncmixin-18j5&quot;&gt;使用 AsyncMixin 创建可等待的构造函数&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;介绍了如何使用名为 &lt;code&gt;AsyncMixin&lt;/code&gt; 的 mixin 在 Python 中创建异步构造函数。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://snyk.io/blog/insecure-direct-object-references-python/&quot;&gt;在 Python 中查找并修复不安全的直接对象引用&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;不安全的直接对象引用 (IDOR) 是一种安全漏洞，文章介绍了这种漏洞的危害，如何识别并修复 IDOR 漏洞。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://medium.com/@DorIndivo/overcoming-performance-bottlenecks-with-async-python-a-deep-dive-into-cpu-bound-code-b604a400255a&quot;&gt;使用异步 Python 克服性能瓶颈：深入研究 CPU 密集型代码&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;作者介绍了如何识别和优化特征存储中 CPU 密集型代码，从而提升核心模型的性能。事件循环延迟是什么，如何监控异步代码消耗的时间？&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://peps.python.org/pep-0720/&quot;&gt;PEP-720 交叉编译 Python 包&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;交叉编译是指在一台计算机上编译适用于另一种体系结构的程序。这份 PEP 试图揭示交叉编译遇到的挑战，并以此进行改进。&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;https://pep-previews--3210.org.readthedocs.build/pep-0722/&quot;&gt;PEP-722 单文件脚本的依赖关系规范&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;在项目中记录和管理第三方库，这有很多解决方案。但是，如何给单文件管理三方库依赖呢？这份 PEP 提出了一种很简单的规范格式。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已免费发布了 13 期，访问下方链接，即可查看全部内容：&lt;a href=&quot;https://pythoncat.top/tags/weekly&quot;&gt;https://pythoncat.top/tags/weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有价值，请表达小小心意，赞赏一下猫哥吧~~&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/srbhr/Resume-Matcher&quot;&gt;Resume-Matcher：比较简历与职位描述，按照打分排名&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;基于 AI 的简历匹配器，根据 JD 的关键词给简历打分。使用 Qdrant（一种高效的向量相似度搜索工具）来衡量简历与 JD 的匹配程度。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/PyHAT-stack/awesome-python-htmx&quot;&gt;awesome-python-htmx：Python 中使用 htmx 作 Web 开发的精选内容&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;PyHAT 旨在 Python 中推广 htmx+ASGI+TailwindCSS，这个项目列出了一些入门资源、教程、设计理论、周边生态等等。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/THUDM/CodeGeeX2&quot;&gt;CodeGeeX2: 更强大的多语言代码生成模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于 ChatGLM2-6B 基座语言模型，在 Python 上达到 35.9% 的 Pass@1 一次通过率，超越规模更大的 StarCoder-15B。CodeGeeX 插件支持 VS Code、 IntelliJ IDEA、PyCharm、GoLand、WebStorm、Android Studio 等IDE。（star 1K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/LinkSoul-AI/Chinese-Llama-2-7b&quot;&gt;Chinese-Llama-2-7b: 第一个能下载运行的中文 LLaMA2 模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;开源可商用的&lt;strong&gt;中文版 Llama2 模型及中英文 SFT 数据集&lt;/strong&gt;，兼容适配所有针对原版 &lt;em&gt;llama-2-chat&lt;/em&gt; 模型的优化。（star 1K）&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/soulteary/docker-llama2-chat&quot;&gt;docker-llama2-chat: LLaMA2 (official / 中文版 / INT4 / llama2.cpp)&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;中文开源项目，三步上手 LLaMA2，作者写了一系列教程博客。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/Avaiga/taipy&quot;&gt;taipy：将数据和 AI 算法转变为完整的 Web 应用&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一个全栈项目，快速将数据和 AI 构建出 Web 应用。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/lmacken/pyrasite&quot;&gt;pyrasite：将代码注入正在运行的 Python 进程&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;允许在运行中的 Python 进程里注入自定义代码，以实现动态调试、修改变量值、破解加密、分析运行时行为等功能。支持多种注入方式，包括注入到 Python 解释器、注入到指定函数、注入到特定线程等。（star 2.7K）&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/ionelmc/python-manhole&quot;&gt;python-manhole：调试运行中的 Python 程序&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;在运行中的 Python 进程里提供交互式的调试和监控功能，利用 Python 的”ptrace”机制，通过在目标进程中注入代码，可通过 SSH 或 telnet 等协议连接，实现远程交互。与 gevent 和 eventlet 兼容，有少许限制。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/RamiKrispin/vscode-python&quot;&gt;vscode-python：使用 VScode 和 Docker 设置 Python 开发环境&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一个非常完备的教程项目，指导在 Docker 上运行 Python、设置开发环境与容器扩展、测试与部署等。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/SergeyPirogov/webdriver_manager&quot;&gt;webdriver_manager：Python 的 Webdriver 管理器&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;使用 &lt;strong&gt;Selenium&lt;/strong&gt; 与 &lt;strong&gt;Playwright&lt;/strong&gt; 等框架时，要管理各种浏览器驱动。这个项目简化了浏览器驱动的管理与使用方式。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/JetBrains/lets-plot&quot;&gt;lets-plot：用于统计数据的开源绘图库&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;JetBrains&lt;/strong&gt; 开源的一个绘图库，可创建美观、交互式的统计图表和数据可视化。为 Python 和 Kotlin 开发者提供类似 &lt;strong&gt;ggplot2&lt;/strong&gt; 的绘图 API。（star 1.1K）&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/pdfarranger/pdfarranger&quot;&gt;pdfarranger：在图形界面合并或拆分 PDF 文档，支持旋转、裁剪和重排&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一个小型 python-gtk 程序，通过直观的方式编辑 PDF 文档。它的后端基于 &lt;a href=&quot;https://github.com/pikepdf/pikepdf&quot;&gt;pikepdf&lt;/a&gt; ，这是一个用于读写 PDF 文件的库。（star 2.3K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🥂讨论&amp;amp;问题&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://discuss.python.org/t/a-steering-council-notice-about-pep-703-making-the-global-interpreter-lock-optional-in-cpython/30474?s=35&quot;&gt;关于 PEP-703 的指导委员会通知（使 CPython 的 GIL 成为可选）&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;在第 11 期周刊中，我们分享过“如果 PEP-703 被采纳，Meta 将投入人力支持”，现在又有进展啦，指导委员会打算接受 PEP-703 了！这篇帖子列出几个基本原则与三个阶段的开发计划。向后兼容性是重中之重，这不会是 Python 4。&lt;/div&gt;
&lt;h2&gt;🐱赞助&amp;amp;支持&lt;/h2&gt;
&lt;div&gt;如果你觉得周刊有价值，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt; 或 &lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！&lt;/div&gt;
&lt;div&gt;如果你喜欢周刊，请分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 潮流周刊#12：Python 中如何调试死锁问题？</title>
            <link>https://pythoncat.top/posts/2023-07-22-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-07-22-weekly/</guid>
            <description>本期周刊分享了 15 篇文章，10 个开源项目，5 则音视频</description>
            <pubDate>Sat, 22 Jul 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文，已在小标题注明。（标题取自其中一则分享，不代表全部内容都是该主题，特此声明。）&lt;/div&gt;
&lt;div&gt;本周刊精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;周刊已开通 Telegram 频道&lt;/strong&gt;，欢迎加入：&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;https://t.me/pythontrendingweekly&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://martinheinz.dev/blog/101&quot;&gt;使用 PyStack 调试 Python 中的崩溃和死锁&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;介绍了一款强大的工具 &lt;strong&gt;PyStack&lt;/strong&gt;，可以解决一些难以调试的问题，如死锁、程序挂起、段错误、Python 和 C/C++ 混合应用调试等。它支持两种调试方法：附加到运行中的进程，或分析崩溃进程的核心转储文件。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://bitestreams.com/blog/fastapi_template/&quot;&gt;介绍一个 FastAPI 项目模板&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一个非常完备的 FastAPI 项目模板，带有 CI/CD、Docker、PostgreSQL、Makefile、单元/集成测试、linting及类型检查。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://davidvujic.blogspot.com/2023/07/python-fastapi-microservices-with-polylith.html&quot;&gt;Python FastAPI 微服务与 Polylith 架构&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Polylith&lt;/strong&gt; 是一种软件架构框架，核心思想是将系统分解为一个个可测试的、可重用的独立单元。作者结合 FastAPI 与 Polylith 架构，开发了一个项目模板。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://juejin.cn/post/7257321872425058359&quot;&gt;Python日志模块：实战应用与最佳实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;详细解析了 &lt;strong&gt;logging&lt;/strong&gt; 模块，从基本介绍到实际应用和最佳实践，介绍了如何高效地用它记录日志，以及如何避免常见的陷阱。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://codesolid.com/benchmarking-python-and-rust-async-web-server-performance/&quot;&gt;测量 Python 和 Rust 异步 Web 服务的性能&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章使用 &lt;strong&gt;JMeter&lt;/strong&gt; 分别测试了 Rust 的 &lt;strong&gt;Axum&lt;/strong&gt; 框架以及 Python 的 &lt;strong&gt;Blacksheep&lt;/strong&gt; 框架。猜猜最终的测试结论是什么呢？&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;http://vra.github.io/2023/07/14/dinov2-retrieval/&quot;&gt;dinov2_retrieval：一个基于 DINOv2 的图片检索应用&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Meta 发布了 &lt;strong&gt;DINOv2&lt;/strong&gt; 视觉预训练模型，能够准确地理解图片中的语义信息。这篇文章用它开发了一个 Python工具，能够检索若干张图片在测试数据集中最相似的图。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://til.simonwillison.net/python/stdlib-cli-tools&quot;&gt;隐藏在 Python 标准库中的 CLI 工具&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Python 标准库中有哪些实用的小工具，可以直接写 &lt;code&gt;python -m xxx&lt;/code&gt; 调用？这篇文章使用 &lt;strong&gt;ripgrep&lt;/strong&gt; 查找出几十个模块，并重点介绍了&lt;code&gt;http.server&lt;/code&gt; 、&lt;code&gt;base64&lt;/code&gt; 、&lt;code&gt;asyncio&lt;/code&gt; 、&lt;code&gt;tokenize&lt;/code&gt; 、&lt;code&gt;ast&lt;/code&gt; 、&lt;code&gt;json.tool&lt;/code&gt; 、&lt;code&gt;random&lt;/code&gt; 等工具。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://www.abdulmumin.com/how-to-use-tailwindcss-in-any-python-project&quot;&gt;如何在 Python 项目中使用 TailwindCSS ？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Tailwind 是近几年在前端很火的一个 CSS 框架，如何将它运用到 Python Web 项目中呢？文章主要介绍了&lt;code&gt;tailwindpie&lt;/code&gt; 这个库，并演示如何在 Flask 项目中使用它，实现自动安装及配置 TailwindCSS。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://dev.to/karishmashukla/a-practical-guide-to-metaprogramming-in-python-691&quot;&gt;Python 元编程实用指南&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;介绍 Python 中元编程的几种机制：装饰器、元类、函数及类装饰器、动态代码生成，以及常用于元编程的关键字与内置函数。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://blog.stealthrocket.tech/how-cpython-prints-stack-traces/&quot;&gt;CPython 是如何打印堆栈信息的？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一篇硬核长文，介绍了 CPython 如何表示程序的调用栈以及如何将字节码地址解析为源代码行号。文章剖析了 CPython 的内部机制，提供了 CPython 性能分析和调试的有用信息。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://switowski.com/blog/pathlib/&quot;&gt;用于路径操作的 Pathlib&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Pathlib 是 Python 中作目录相关操作的库，而且应该是最好用的一个。文章详细介绍了它的常见用法，对比了其它常用工具，并且针对一些场景作了性能分析。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://newsletter.techworld-with-milan.com/p/stack-overflow-architecture&quot;&gt;Stack Overflow、Shopify 及 Levels.fyi 的软件架构&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章分享了三家大型网站的软件架构。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://dev.to/alexomeyer/10-must-know-patterns-for-writing-clean-code-with-python-56bf&quot;&gt;10 条编写干净 Python 代码的建议&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;代码的可读性与可维护性，再怎么强调也不为过！这篇文章介绍了一些基础的原则，但却非常体现程序员的编程素养。&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://engineering.fb.com/2023/06/27/developer-tools/meta-developer-tools-open-source/&quot;&gt;Meta 开发者工具：支撑大规模协作的编程体系&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Meta 的几千名开发者使用了哪些支撑大规模协作的工具呢？文章介绍了几款开源工具（&lt;a href=&quot;https://engineering.fb.com/2022/11/15/open-source/sapling-source-control-scalable/&quot;&gt;Sapling&lt;/a&gt; 版本控制、 &lt;a href=&quot;https://engineering.fb.com/2023/04/06/open-source/buck2-open-source-large-scale-build-system/&quot;&gt;Buck2&lt;/a&gt; 构建系统、 &lt;a href=&quot;https://fbinfer.com/&quot;&gt;Infer&lt;/a&gt;/ &lt;a href=&quot;https://engineering.fb.com/2017/10/19/android/open-sourcing-racerd-fast-static-race-detection-at-scale/&quot;&gt;RacerD&lt;/a&gt;/&lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt; 测试与静态分析），另外 Meta 官博还有一篇介绍开发者工作流的文章 &lt;a href=&quot;https://developers.facebook.com/blog/post/2022/11/15/meta-developers-workflow-exploring-tools-used-to-code/&quot;&gt;Meta 开发者工作流：探索大规模编码工具&lt;/a&gt; 。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已免费发布了 12 期，访问下方链接，即可查看全部内容：&lt;a href=&quot;https://pythoncat.top/tags/weekly&quot;&gt;https://pythoncat.top/tags/weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有价值，请表达小小心意，赞赏一下猫哥吧~~&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.reddit.com/r/Python/comments/111y9o2/python_projects_with_best_practices_on_github/&quot;&gt;GitHub 上有哪些值得推荐学习的 Python 项目？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Github 上有哪些运用了最佳实践，并且有强大而良好架构的项目？这是 Reddit 上的帖子，可去看看大家推荐了什么。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/gto76/python-cheatsheet&quot;&gt;python-cheatsheet: Python 知识点速查表&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一份非常全面的 Python 知识手册，除了 Github 仓库，还有在线网站及 PDF 版本。（star 33K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/pengzhile/pandora&quot;&gt;pandora：潘多拉，一个让你呼吸顺畅的ChatGPT&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;国人开源的项目，实现了网页版 ChatGPT 的主要操作，能解决国内访问 ChatGPT 的诸多痛点。（star 18.6K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/web2py/py4web&quot;&gt;py4web：数据库驱动的 Web 开发框架&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这个框架可以快速开发由数据库驱动的 Web 应用，它基于流行的全栈框架 &lt;a href=&quot;https://github.com/web2py/web2py&quot;&gt;web2py&lt;/a&gt; ，但比后者快 10-20 倍。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.oschina.net/p/fastapi-vue-admin&quot;&gt;FastAPI-Vue-Admin：基于 FastAPI+Vue 的敏捷开发框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于 FastAPI、Vue2.x、ElementUI、MySQL 等框架精心打造的一款模块化、高性能、企业级的敏捷开发框架，实现了可插拔的组件式开发方式。国人作品（收费），有完善的中文支持。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/sunner/ChatALL&quot;&gt;ChatALL：同时与ChatGPT、Bing Chat、Bard、Alpaca、Claude、讯飞星火、文心一言等聊天&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这个项目的中文名叫“&lt;strong&gt;齐叨&lt;/strong&gt;”，可同时与多个 AI 对话，方便取得最佳答案。（star 8.2K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/jina-ai/vectordb&quot;&gt;vectordb：一个 Python 向量数据库&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;纯 Python 开发的向量数据库，支持 CURD 及强大的可扩展能力（分片与复制）。使用了  &lt;a href=&quot;https://github.com/docarray/docarray&quot;&gt;DocArray&lt;/a&gt; 充当驱动向量搜索逻辑的引擎，使用  &lt;a href=&quot;https://github.com/jina-ai/jina&quot;&gt;Jina&lt;/a&gt; 保证高效和可扩展的索引服务。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/grantjenks/python-sortedcontainers&quot;&gt;python-sortedcontainers：有序容器类型（有序列表、有序字典和有序集合）&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一个纯 Python 实现的有序容器库，提供了列表、集合与字典的有序版本，API 兼容，号称经常比 C 实现更快。用户指南中提供了几份性能对比报告，数据很可观。（star 3K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/pallets/quart&quot;&gt;quart：一个支持异步的 Python Web 框架&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这是基于 Flask 框架而作的异步版实现，支持快速将 Flask 项目改造成支持异步。（star 2K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/RayVentura/ShortGPT&quot;&gt;ShortGPT：自动生成短视频内容的 AI 框架&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一个强大的自动化内容生成框架，简化了视频创建、素材获取、字幕生成、画外音合成和编辑任务。（star 1.4K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pythonhunter.org/episodes/ep41&quot;&gt;捕蛇者说 Ep 41：和 Penguin 聊聊 CPython 优化和大厂编译器组的工作&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这期播客的嘉宾曾出现在我们周刊的第 7 期，他给 &lt;a href=&quot;https://github.com/python/cpython/issues/101632&quot;&gt;CPython 添加返回常量指令&lt;/a&gt; ，节目聊了他给 CPython 做的这项工作以及在腾讯做编译器开发的情况。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.pythonshow.com/p/07-the-robyn-python-web-framework#details&quot;&gt;The Python Show 07 - 访谈 Robyn Web 框架的作者&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Robyn&lt;/strong&gt; 是用 Rust 开发的轻量级、高性能 Python Web 框架。这期播客聊了关于 Robyn 的相关话题。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.youtube.com/playlist?list=PLt4L3V8wVnF4GJb8dekLGTNx44FNIFwdv&quot;&gt;2023 年 Python 网络大会的 80 个视频&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Python 网络大会（Python Web Conf）今年举办了第 5 届，上周发布了相关的视频材料，涵盖主题有人工智能/机器学习、大数据、CI/CD、Serverless、安全、容器等等。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://thecreatorsai.com/p/what-to-watch-about-ai-6-youtube&quot;&gt;关于 AI 内容：推荐 6 个 YouTube 频道&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;想要了解 AI？想观看关于 ChatGPT 的相关视频？想发现最新潮的 AI 工具？这里推荐了 6 个油管频道。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.xiaoyuzhoufm.com/episode/64b4f4c5d0844ea812ce31e9&quot;&gt;除你武器 013｜我也不想工作啊，只是想找个岸上一上&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是我本周听到最喜欢的一档播客！这期节目聊了就业与人生选择的相关话题。（如果你是高考毕业生，可去听第 11 期高考特辑 &lt;a href=&quot;https://www.xiaoyuzhoufm.com/episode/647c8bb653a5e5ea14dbffad&quot;&gt;成为状元 9 年后，我还在做高考的噩梦&lt;/a&gt;）&lt;/div&gt;
&lt;h2&gt;🐱赞助&amp;amp;支持&lt;/h2&gt;
&lt;div&gt;如果你觉得周刊有价值，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt; 或 &lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！&lt;/div&gt;
&lt;div&gt;如果你喜欢周刊，请分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python潮流周刊#11：如何使用 Golang 运行 Python 代码？</title>
            <link>https://pythoncat.top/posts/2023-07-15-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-07-15-weekly/</guid>
            <description>本期周刊分享了 16 篇文章，12 个开源项目，2 则播客，2 个热门话题</description>
            <pubDate>Sat, 15 Jul 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python 及通用技术内容，大部分为英文，已在小标题注明。（标题取自其中一则分享，不代表全部内容都是该主题，特此声明。）&lt;/div&gt;
&lt;div&gt;本周刊精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;周刊已开通 Telegram 频道&lt;/strong&gt;，欢迎加入：&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;https://t.me/pythontrendingweekly&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://soulteary.com/2023/05/21/run-python-code-with-golang-and-docker.html&quot;&gt;使用 Golang 和 Docker 运行 Python 代码&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何使用 Golang 来运行 Python 代码呢？关于 Python 版本和硬件，有哪些使用限制呢？这篇文章使用 Docker 解决环境依赖问题，使用开源项目 &lt;strong&gt;cpy3&lt;/strong&gt;，成功用 Golang 运行 Python 代码。它有一篇续文《&lt;a href=&quot;https://soulteary.com/2023/05/22/using-golang-and-docker-to-implement-python-computing-services.html&quot;&gt;使用 Golang 和 Docker 实现 Python 计算服务&lt;/a&gt;》，将普通的 Python 软件包封装为高性能的可通过 &lt;strong&gt;gRPC&lt;/strong&gt; 方式调用的服务。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.piglei.com/articles/the-answer-is-in-the-code-fulfill-requirements/&quot;&gt;答案在代码中：“实现需求”的双重含义&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;很多程序员容易忽略一件事：那就是阅读代码的时间会远多于写下它们的时间！这意味着&lt;strong&gt;代码的可读性&lt;/strong&gt;非常重要，因此当我们在“实现需求”时，除了要考虑用户的功能需求外，更应多加关注如何写出可读性高的代码。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.bitecode.dev/p/relieving-your-python-packaging-pain&quot;&gt;减轻 Python 包管理的痛苦&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;@NoHeartPen 投稿：在看了第一期中&lt;a href=&quot;https://www.v2ex.com/t/938669#reply88&quot;&gt;对 conda 的吐槽&lt;/a&gt; 后，开始关注这个问题，但一直没有找到比较系统的总结，看了这篇文章后终于有了大致的思路（这篇文章不仅写了「怎么做」，还写了「为什么」，让我改掉了不建虚拟环境的陋习和放弃折腾 conda）。另外，附上翻译版 &lt;a href=&quot;https://blog.csdn.net/csdnnews/article/details/131546123&quot;&gt;如何减轻 Python 打包之痛&lt;/a&gt; 。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://www.cnblogs.com/traditional/p/17536459.html&quot;&gt;CuPy：将 NumPy 数组调度到 GPU 上运行&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;NumPy 的作者 Travis Oliphant 曾说，如果当时给 NumPy 添加了 GPU 的支持，就没有后来的 Tensorflow、Torch 等深度学习框架什么事了。&lt;a href=&quot;https://github.com/cupy/cupy&quot;&gt;CuPy&lt;/a&gt; 是一个兼容 Numpy 且支持 GPU 的库（star 7K），这篇文章介绍了它的安装及数组的基础知识。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://segmentfault.com/a/1190000044006618&quot;&gt;Python 源码剖析：深度探索 Cpython 对象&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;为什么说 Python 中一切皆对象？为什么 Python 用起来比其它静态类型语言慢很多？这篇文章从 CPython 的对象构造器入手，介绍了 CPython 底层数据结构、对象创建的过程、动态性的实现方式等内容。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://juejin.cn/post/7252976055093592120&quot;&gt;使用 Flask + Flask RESTful 快速搭建 API 服务&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇长文，使用 Flask + Flask RESTful 搭建一个 API 应用，使用 &lt;strong&gt;Flask-SQLAlchemy&lt;/strong&gt; 扩展实现 ORM 操作 MySQL 数据库，基于 JWT 验证实现注册、登录以及登出接口，解决跨域问题，并使用 Docker 部署该应用。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://segmentfault.com/a/1190000043988232&quot;&gt;详解 Django 请求与响应：深入理解 Web Http 交互的核心机制&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;探讨了 Django 中的请求与响应处理，包含基础知识、生命周期、HttpRequest 和 HttpResponse 对象的详细介绍。同时，讨论了 Django 的视图和请求、响应处理，以及安全性和异步处理的考虑。最后，对比了 Django 与 Flask、FastAPI 等框架在请求响应处理上的异同。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://dev.to/derlin/when-plans-go-astray-my-unsuccessful-journey-of-migrating-a-large-django-project-to-mypy-3l23&quot;&gt;将大型 Django 项目迁移到 Mypy 的失败之旅&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;作者在给一个生产项目添加 Mypy 类型检查时遇到了诸多问题：很多库不提供 pyi 类型、TypedDict 使用受限、Optional 类型需要许多断言、混合类需要实现协议、Django 模型不支持泛型。简而言之，给历史项目加上类型检查是一件痛苦的事，最好是从一开始就考虑。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://www.python-engineer.com/posts/notion-api-python/&quot;&gt;如何在 Python 中使用 Notion API？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Notion 是一款强大的知识管理软件，这篇教程教你如何用 Python 操作 Notion 的数据库：创建集成、在数据库中创建页面、查询数据库与页面、更新页面、删除页面。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://pythonspeed.com/articles/easiest-rust-python/&quot;&gt;最简单的使用 Rust 加速 Python 的方法&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;如何将 Rust 代码打包为 Python 可使用的扩展？&lt;a href=&quot;https://www.maturin.rs/&quot;&gt;maturin&lt;/a&gt; 和 &lt;a href=&quot;https://setuptools-rust.readthedocs.io/&quot;&gt;setuptools-rust&lt;/a&gt; 是主流的两种方式。但是，在做原型设计时，打包与集成过程还是挺麻烦，这篇文章介绍了一个新的库 &lt;a href=&quot;https://pypi.org/project/rustimport/&quot;&gt;rustimport&lt;/a&gt; ，可以直接从 Python 中导入 Rust 代码！文章介绍了它的使用方法、Rust 初学者最常见的性能错误、以及使用 &lt;strong&gt;rustimport&lt;/strong&gt; 时的一些陷阱。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://jayconrod.com/posts/101/how-python-parses-white-space&quot;&gt;Python 是如何解析空格的？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Python 的换行与缩进是程序结构的基础部分。空格在 Python 的语法解析中起到什么作用，词法分析器如何处理换行和缩进？Python 的空格有哪些优点和缺点？Python 如何解析代码并生成抽象语法树？&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://pythonguides.com/remove-duplicate-values-from-a-python-dictionary/&quot;&gt;如何从 Python 字典中删除重复的值？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;介绍了 7 种从 Python 字典中删除重复值的方法：使用 for 循环、使用字典解析式、使用 setdefault() 方法、使用 values() 和 set() 方法、使用 collections.defaultdict()、使用列表解析式、使用 dict.fromkeys() 和 values()。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://realpython.com/python-profiling/&quot;&gt;如何找出 Python 代码中的性能瓶颈？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;什么时候该给项目作性能优化？性能调优前该关注哪些内容，应该使用什么工具？这篇文章介绍了&lt;code&gt;time&lt;/code&gt; 、&lt;code&gt;timeit&lt;/code&gt; 、&lt;code&gt;cProfile&lt;/code&gt; 、&lt;code&gt;Pyinstrument&lt;/code&gt; 、&lt;code&gt;perf&lt;/code&gt; 等工具以及一些性能优化的技巧。&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://samuel-vidovich.medium.com/3-cool-python-libraries-that-will-save-you-time-and-effort-27fcdc6762d5&quot;&gt;3 个很酷的 Python 库，节省你的时间和精力&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;介绍了 3 个非常好用的库：&lt;a href=&quot;https://github.com/jmespath/jmespath.py&quot;&gt;JMESPath&lt;/a&gt; 可以很方便查询 Json 中的元素（star 1.9k），&lt;a href=&quot;https://github.com/jpvanhal/inflection&quot;&gt;inflection&lt;/a&gt; 可以很方便处理字符串（比如批量将驼峰式变量名修改成蛇形命名），&lt;a href=&quot;https://github.com/more-itertools/more-itertools&quot;&gt;more-itertools&lt;/a&gt; 类似于标准库的&lt;code&gt;itertools&lt;/code&gt; 提供了很多操作可迭代对象的方法（star 3.1k）。&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;https://blog.europython.eu/kraken-technologies-how-we-organize-our-very-large-pythonmonolith/&quot;&gt;如何管理有近 3 万个文件的超大型 Python 代码仓？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;你见过接近 3 万个文件（不含测试）的 Python 单体代码仓么？全球有 400 开发者共同开发，如何避免混乱？作者介绍了分层管理代码仓的做法、使用的架构和工具（&lt;a href=&quot;https://github.com/seddonym/import-linter&quot;&gt;import-linter&lt;/a&gt;）、以及克服过的一些困难。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已免费发布了 11 期，访问下方链接，即可查看全部内容：&lt;a href=&quot;https://pythoncat.top/tags/weekly&quot;&gt;https://pythoncat.top/tags/weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如果你觉得周刊有帮助，请表达小小心意赞赏下猫哥吧~~&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/dmytrostriletskyi/threads-net&quot;&gt;threads-net：逆向工程 Threads 的 Python API&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;新上线的 Threads 依然是本周最火爆的科技话题之一。这个项目通过逆向工程获得了它的 API，可让你使用 Python 操作 Threads 的很多功能。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/ishan0102/engblogs&quot;&gt;engblogs：用 AI 为科技公司官博作摘要，并部署成网站&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这个项目用 RSS 抓取 AWS、Apple、DeepMind、Google、Meta、Stripe 等科技公司的博客，调用 gpt-3.5 生成摘要，将数据存储在 supabase 中，并在 Vercel 上托管了一个 Next.js &lt;a href=&quot;https://www.engblogs.dev/&quot;&gt;网站&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/adamghill/django-unicorn&quot;&gt;django-unicorn：Django 全栈的响应式组件框架&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;可以为 Djiango 模板添加现代响应式的组件功能，无需使用 Javascript 框架。支持表单验证、重定向、加载状态、部分更新、滚动触发、消息、Javascript 集成等等丰富的功能。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/Undertone0809/imarkdown&quot;&gt;imarkdown：轻量级的 Markdown 图片链接转换器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可以批量将图片的链接进行本地到图片服务器、图片服务器到本地、图片服务器到图片服务器的转换。（@Zeeland 投稿）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/198808xc/Pangu-Weather&quot;&gt;Pangu-Weather：盘古天气的官方实现&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;可以通过人工智能来提升天气预报的准确度啦？！Pangu-Weather 是一个快速而准确预报全球天气的 3D 高分辨率模型。这个仓库提供了伪代码、预训练模型、推理代码等资源。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/openmedlab/PULSE&quot;&gt;PULSE：中文医疗大语言模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于 4 百万个中文医学领域和通用领域的指令微调，支持医学领域的各种自然语言处理任务，包括健康教育、医师考试问题、报告解读、医疗记录结构化以及模拟诊断和治疗。基于这个大模型，已经有不少应用，比如与 X-ray 图像模型结合的应用 &lt;strong&gt;XrayPULSE&lt;/strong&gt; ：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/fredrikaverpil/creosote&quot;&gt;creosote：识别虚拟环境中未使用的依赖库&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;可扫描虚拟环境中未使用的依赖库，支持 Poetry、Pipenv、PDM、 &lt;code&gt;requirements.txt&lt;/code&gt; 文件以及 PEP-621 的 &lt;code&gt;pyproject.toml&lt;/code&gt; 文件。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/IMOSR/MediaGPT&quot;&gt;MediaGPT：中文的自媒体大语言模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个面向自媒体创作、直播和运营等领域的大语言模型，能够理解抖音运营、短视频创作、巨量千川投放、直播运营等领域的核心概念和策略，支持内容创作、平台运营、广告投放等。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/geekan/MetaGPT&quot;&gt;MetaGPT：给定一行需求，返回 PRD、设计、任务、代码&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一个元编程框架，可以为 GPT 分配不同的角色（如产品经理/架构师/项目经理/工程师），共同协作完成复杂的软件开发任务。仅需一句话需求，就能输出用户故事/竞争分析/需求/数据结构/API/文档等。（star 3.7k）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/khoj-ai/khoj&quot;&gt;khoj：数字大脑的 AI 个人助理&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;基于个人的 Markdown 笔记、PDF 文件、Github 代码仓和照片，打造支持搜索与聊天的 AI 助理，可通过浏览器、Emacs、Obsidian 和移动设备等多种界面进行交互。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/paul-gauthier/aider&quot;&gt;aider：基于命令行的 AI 编码助手&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一个命令行聊天工具，可以让 GPT 创建新项目，或修改现有 git 代码仓中的代码。它可以轻松完成 git 提交、比较和撤消更改，无需人工复制/粘贴。（star 2.3k）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://github.com/allenai/visprog&quot;&gt;visprog：可视化编程，无需训练的合成视觉推理&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一篇 CVPR 2023 最佳论文的官方实现，可以实现：基于图片内容的自然语言问答与推理、图片内对象标注、自然语言图片编辑等功能。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://talkpython.fm/episodes/show/421/python-at-netflix&quot;&gt;Talk Python To Me Podcast #421 Python at Netflix&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Python 在 Netflix 中有大量的使用场景，比如 CDN、需求预测和容灾、安全、机器学习等等。这期播客节目聊了 Netflix 在使用 Python 时的相关话题。另外，分享它官博上获得 8k 赞的一篇旧文《&lt;a href=&quot;https://netflixtechblog.com/python-at-netflix-bba45dae649e&quot;&gt;Python at Netflix&lt;/a&gt;》。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://pythonbytes.fm/episodes/show/343/so-much-pydantic&quot;&gt;Python Bytes #343 So Much Pydantic!&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这期播客聊了很多话题，其中关于 Pydantic 的有两则：V2 版本已发布、一个&lt;a href=&quot;https://github.com/Kludex/awesome-pydantic&quot;&gt;awesome-pydantic&lt;/a&gt; 清单，后者收录了很多使用 Pydantic 的开源项目。&lt;/div&gt;
&lt;h2&gt;🥂讨论&amp;amp;问题&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.zhihu.com/question/274635237&quot;&gt;Pytorch有什么节省显存的小技巧？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;知乎上的一个问题，前排有很多高赞的回答，八仙过海各显神通！&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://discuss.python.org/t/a-fast-free-threading-python/27903/99&quot;&gt;如果 PEP-703 被采纳，Meta 将投入人力支持&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Python 社区今年最受瞩目的提案当属 PEP-703 了吧（我曾&lt;a href=&quot;https://pythoncat.top/posts/2023-02-20-GIL&quot;&gt;在年初介绍过&lt;/a&gt;）！Guido 上个月在论坛中说要是能得到 Meta 等科技公司的支持就太好了。好消息来了，上周 Meta 承诺可以提供人力支持。消息在 Twitter 和 Hacker News（&lt;a href=&quot;https://news.ycombinator.com/item?id=36643670&quot;&gt;查看 HN 帖子&lt;/a&gt;）等平台上，获得了激烈的讨论。&lt;/div&gt;
&lt;h2&gt;🐱赞助&amp;amp;支持&lt;/h2&gt;
&lt;div&gt;内容创作要花费大量的时间和精力，如果你觉得有帮助，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt; 或 &lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！&lt;/div&gt;
&lt;div&gt;如果你喜欢本周刊，请转发分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;h2&gt;🐼欢迎订阅&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python潮流周刊#10：Twitter 的强敌 Threads 是用 Python 开发的！</title>
            <link>https://pythoncat.top/posts/2023-07-08-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-07-08-weekly/</guid>
            <description>本期周刊分享了 13 篇文章，12 个开源项目，2 个热门问题</description>
            <pubDate>Sat, 08 Jul 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python 及通用技术内容，大部分为英文，已在小标题注明。（标题取自其中一则分享，不代表全部内容都是该主题，特此声明。）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;周刊已开通 Telegram 频道&lt;/strong&gt;，欢迎关注：&lt;a href=&quot;https://t.me/pythontrendingweekly&quot;&gt;https://t.me/pythontrendingweekly&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.yance.wiki/gc_go_py&quot;&gt;聊一聊 Python 和 Golang 的垃圾回收&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;常见的垃圾回收算法有哪些，它们的优缺点是什么？Python 的垃圾回收机制由什么组成，如何解决内存泄漏问题？Golang 的垃圾回收机制又是怎样的，如何解决内存泄漏问题？&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://albexl.substack.com/p/a-tale-of-debugging-the-competitive&quot;&gt;像竞赛程序员一样调试&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;编程竞赛需要在限定时间内解决一系列难题，这篇文章介绍了在编程竞赛中作自动调试的方法。它的方法除了可以提升成绩，对于现实的软件开发也有所启示。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://realpython.com/python312-perf-profiler/&quot;&gt;Python 3.12 预览版：支持 Linux 性能分析器&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Python 3.12 最终版将在今年 10 月发布，其中最大的变化之一是支持 Linux &lt;code&gt;perf&lt;/code&gt; 分析器。这篇文章介绍了什么是 Linux perf 分析器、perf 能给 Python 带来什么好处、如何在 Python 3.12 中使用 perf、如何分析性能数据、性能数据可视化……&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://lukasz.langa.pl/40b601fc-2b24-4629-91d9-3b32c58365c6/&quot;&gt;CPython 招聘一名全职工程师&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Łukasz Langa 是 PSF 的首个全职开发者（由 Meta 赞助），近日发文表示要新招聘一名“副手”工程师（由彭博社赞助）！两周前，PSF 官网刚公布了&lt;a href=&quot;https://pyfound.blogspot.com/2023/06/announcing-our-new-security-developer.html&quot;&gt;首个全职的安全开发工程师&lt;/a&gt; （由 OpenSSF 赞助），现在又有了新的赞助，真的要感谢慷慨的赞助者们！&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://lukasz.langa.pl/61df599c-d9d8-4938-868b-36b67fdb4448/&quot;&gt;PEP 563 和 PEP 649&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;PEP-563 注解的延迟求值，PEP-649 使用描述符作注解的延迟求值。这篇 2021 年的文章出自 PEP-563 的作者 Łukasz Langa，介绍和对比了这两个 PEP。它们都是 Accepted 状态，然而原计划在 3.10 发布的 PEP-563 已被&lt;a href=&quot;https://docs.python.org/zh-cn/3/whatsnew/3.11.html#pep-563-may-not-be-the-future&quot;&gt;宣告无限期搁置&lt;/a&gt; ，所以它似乎需要更多的关注？（@Plutonium 投稿）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://ritwikmath.hashnode.dev/python-design-patterns-cookbook-recipes-for-clean-and-reusable-code-observer&quot;&gt;Python 设计模式：简洁及可重用代码（观察者）&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;在构建复杂软件时通常会使用设计模式。文章介绍了观察者设计模式、其使用场景与 Python 代码示例，另外与事件驱动架构（EDA）作了几项对比。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://jamesturk.net/posts/you-dont-need-all/&quot;&gt;你并不需要写__all__&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章介绍了 Python 中三种导入模块的方式和__all__的用法，重点介绍了一种替代__all__的方法，即在 __init__.py 文件中直接导入所需的名称。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://blog.miguelgrinberg.com/post/building-a-toy-programming-language-in-python&quot;&gt;用 Python 实现一门简易的编程语言&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;如何用 Python 来实现一门编程语言呢？这是一个系列教程，第一篇中实现了一个非常基础的编程语言，可以执行 print 语句，第二篇则拓展成支持变量和数学表达式。涉及词法分析、语法分析、代码生成及执行等知识。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://www.pythonmorsels.com/using-counter/&quot;&gt;使用 Python 的 collections.Counter 计算出现次数&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Counter 是 Python 中最好用的数据结构之一。这篇文章介绍了一些很有用的操作：获取出现次数最多的 N 个内容、添加内容到 Counter、移除内容、删除负计数内容、Counter 作算术运算、Counter 传入生成器表达式。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://coderslegacy.com/python-code-with-numba-vectorize/&quot;&gt;使用 Numba Vectorize 加速 Python 代码&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Numba 是用于提升 Python 性能的常用手段，这篇文章介绍了它的重要功能 Vectorize（矢量化），包括它的内部原理，了解它如何充分利用单指令多数据（SIMD）操作的强大功能。文中展示了 5 个使用场景的代码示例。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://emmmme.com/greatwork&quot;&gt;Paul Graham：如何做出伟大的工作？&lt;/a&gt; (中译)&lt;/div&gt;
&lt;div&gt;Paul Graham 是《黑客与画家》的作者，最近发布了文章《&lt;a href=&quot;http://paulgraham.com/greatwork.html&quot;&gt;How to Do Great Work ?&lt;/a&gt;》。一句话概括要点：做出伟大的工作需要好奇心、努力和适合自己的工作类型。文章较长，关键的几个问题：什么是做伟大工作的关键？如何找到适合自己的工作类型？如何保持好奇心？什么是伟大工作的标准？为什么要努力做伟大工作？&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://emmmme.com/workhard&quot;&gt;Paul Graham：如何努力工作？&lt;/a&gt; (中译)&lt;/div&gt;
&lt;div&gt;翻译自 Paul Graham 写于 2021 年的《&lt;a href=&quot;http://paulgraham.com/hwh.html&quot;&gt;How to Work Hard ?&lt;/a&gt;》，可与上一则内容关联阅读。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://www.pythonmorsels.com/django-june-2023/&quot;&gt;Django 2023 年 6 月：技巧和讨论&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这是一篇关于 Django 的聚合类月刊，分享了一些学习 Django 的技巧、资源、文章，等等。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已免费发布了 10 期，访问下方链接，即可查看全部内容：&lt;a href=&quot;https://pythoncat.top/tags/weekly&quot;&gt;https://pythoncat.top/tags/weekly&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/facebookincubator/cinder&quot;&gt;cinder：Meta 内部以性能为导向的 CPython 版本&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;本周重大新闻：Meta 推出了 Twitter 的竞品 Threads，仅两天的注册量就已突破三千万。它的后端使用了 Cinder，这是基于 Python 3.10 构建的高性能版本，包含许多性能优化，包括字节码内联缓存、协程的预先求值、每个方法一次的 JIT，以及一种实验性的字节码编译器。（star 2.6K）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/sdan/vlite&quot;&gt;vlite：用 NumPy 制作的简易矢量数据库&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;用不到 200 行代码编写的快速、轻量级和简易的矢量数据库。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/0xpayne/gpt-migrate&quot;&gt;gpt-migrate：将代码仓从一种框架或语言迁移成其它&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;使用 GPT 将少量代码从一种编程语言转换成其它语言，这已非难事。但是，整个代码仓级别的语言/框架迁移，听起来就不是一件容易的事！这个项目需要使用 GPT-4，目前在 Python 和 Javascript 这种“简单”的语言上有不错的效果。（star 5.4K）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/lancetnik/FastDepends&quot;&gt;FastDepends：从 FastAPI 中提取的依赖注入框架，异步和同步模式都支持&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这是将 FastAPI 移除所有 HTTP 逻辑后改造成的依赖注入框架。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/zwq2018/Data-Copilot&quot;&gt;Data-Copilot：通过自主工作流程桥接数十亿数据和人类&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个基于 LLM 的系统，连接中国金融市场，目前可以访问中国的股票、基金、经济及金融数据、实时新闻。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/readthedocs-examples/awesome-read-the-docs&quot;&gt;awesome-read-the-docs：精选的项目文档列表&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;&lt;code&gt;Read the Docs&lt;/code&gt; 是一个用于构建和发布文档的开源平台（你肯定见过它家的 Sphinx 或 MkDocs 生成的文档），这个仓库收录了一些开源项目的文档，可以学习它们是如何构建出酷炫效果的。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/Wangt-CN/DisCo&quot;&gt;DisCo：通过指示生成现实世界的人类舞蹈&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这是一个通用的人类舞蹈生成工具包，可以根据参考图片和姿势，生成人类舞蹈图片和视频。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://theses.gla.ac.uk/2975/1/2011shannonphd.pdf&quot;&gt;Mark Shannon 博士论文：为动态语言构建高性能虚拟机&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Mark Shannon 由于“&lt;a href=&quot;https://pythoncat.top/posts/2021-05-16-Guido&quot;&gt;香农计划&lt;/a&gt;”而被很多人所知。这里分享的是他 2011 年在格拉斯哥大学的博士论文（可下载的 PDF），描述了一种用于构建动态语言虚拟机的方法，并解释了如何通过围绕一个抽象机器来构建虚拟机工具包的设计。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/guofei9987/blind_watermark&quot;&gt;blind_watermark：图片加盲水印，提取水印无须原图&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;盲水印（Blind Watermark）是一种数字水印技术，可以在不需要原图或文本的情况下，将水印嵌入到数据中。这个项目是基于频域的数字盲水印，在多种攻击方式下仍能有效提取。（star 3.6K）&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/OpenBMB/VisCPM&quot;&gt;VisCPM：基于 CPM 基础模型的中英双语多模态大模型系列&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个开源的多模态大模型系列，支持中英双语的多模态对话能力（&lt;code&gt;VisCPM-Chat&lt;/code&gt;模型）和文到图生成能力（&lt;code&gt;VisCPM-Paint&lt;/code&gt;模型）。基于百亿参数量语言大模型 CPM-Bee（10B）训练（&lt;a href=&quot;https://pythoncat.top/posts/2023-06-17-weekly7&quot;&gt;周刊第 7 期&lt;/a&gt;曾介绍过），融合视觉编码器（Q-Former）和视觉解码器（Diffusion-UNet）以支持视觉信号的输入和输出。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/escobar-west/polars-cookbook&quot;&gt;polars-cookbook：Python polars 库的教程&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;polars 是用 Rust 写成的 Python 库，用于进行数据分析。这个仓库包含有 9 个章节的使用教程。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://www.evidentlyai.com/ml-system-design&quot;&gt;ML 系统设计：200 个研究案例&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;像 Netflix、Airbnb 和 Doordash 这样的公司如何运用机器学习来改善其产品和流程？这个网站整理了 64 家公司的 200 个案例，可以了解到机器学习的现实用例，学习如何设计机器学习系统。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🥂讨论&amp;amp;问题&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://news.ycombinator.com/item?id=36581241&quot;&gt;Ask HN：关于技术史的好书？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Hacker News 上的问题，有哪些关于技术历史的好书推荐？&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://news.ycombinator.com/item?id=36560950&quot;&gt;Ask HN：最有价值的计算机科学书籍？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;也是 HN 上的问题，有哪些关于编程语言、符号逻辑、算法、操作系统等 CS 书籍推荐？&lt;/div&gt;
&lt;h2&gt;🐼关于周刊&lt;/h2&gt;
&lt;div&gt;Python 潮流周刊，由豌豆花下猫主理，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;内容创作要花费大量的时间和精力，如果你觉得有帮助，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt; 或 &lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！如果你喜欢本周刊，请转发分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python潮流周刊#9：如何在本地部署开源大语言模型？</title>
            <link>https://pythoncat.top/posts/2023-07-01-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-07-01-weekly/</guid>
            <description>本期周刊分享了 15 篇文章，10 个开源项目</description>
            <pubDate>Sat, 01 Jul 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python 及通用技术内容，部分为英文，已在小标题注明。（标题取自其中一则分享，不代表全部内容都是该主题，特此声明。）&lt;/div&gt;
&lt;div&gt;首发于我的博客：&lt;a href=&quot;https://pythoncat.top/posts/2023-07-01-weekly&quot;&gt;https://pythoncat.top/posts/2023-07-01-weekly&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;周刊的投稿通道已开放&lt;/strong&gt;，请在 Github 项目中提交 issue：&lt;a href=&quot;https://github.com/chinesehuazhou/python-weekly&quot;&gt;https://github.com/chinesehuazhou/python-weekly&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ai.plainenglish.io/%EF%B8%8F-langchain-streamlit-llama-bringing-conversational-ai-to-your-local-machine-a1736252b172&quot;&gt;本地部署开源大模型的完整教程：LangChain + Streamlit+ Llama&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;一篇步骤清晰的教程，它使用 LangChain 及 Facebook 开源的 LLaMA 大语言模型搭建了一个基于文档的问答助手，另外使用 Streamlit 构建出一个美观的用户界面。（附一篇中文的&lt;a href=&quot;https://segmentfault.com/a/1190000043935266&quot;&gt;翻译文&lt;/a&gt; ）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://so1n.me/2023/05/29/python_asyncio_lib_overhead/&quot;&gt;Python Asyncio 协程对象开销成本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;一个 Python Asyncio 协程会占用有多少内存呢？文章的测试结论是约 2Kb。另外，文中还测试了以下的问题：每秒可创建多少个裸协程？每秒可处理多少个协程？使用&lt;code&gt;uvloop&lt;/code&gt; 后，创建及处理协程任务，能有多少提升？&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://superfastpython.com/asyncio-runner/&quot;&gt;如何使用 asyncio.Runner 执行多个协程&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;asyncio.Runner 是 Python 3.11 中新增的功能，支持在同一事件循环中执行多个协程。文章主要内容：如何使用 asyncio.run() 运行多个协程，如何使用包装方法运行多个协程，以及如何使用 asyncio.Runner 类在同一个事件循环中以自适应甚至有条件的方式执行协程。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://hakibenita.com/django-concurrency&quot;&gt;不使用锁的并发实现&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;在并发编程中，通常需要使用锁，但是不应该滥用锁。这篇文章探讨了如何尽量不依赖锁来实现并发，演示的例子是生成短链接，主要的思想是“请求宽恕”而不是“提前检查”、使用 PostgreSQL 数据库提供的功能。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/639119164&quot;&gt;贡献 CPython 日记 (3) CPython 是如何运行的&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;文章介绍了 CPython 是如何把 Python 代码跑起来的，主要过程：词法分析、语法分析、编译到字节码、执行字节码。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://coderslegacy.com/python-jit-compilers/&quot;&gt;Python JIT 编译器 - 即时编译&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;文章探讨了 JIT 编译的概念及其优点，并深入分析了主流的 Python JIT 编译器的优缺点（如 PyPy、Numba 和 Cython），介绍了在 Python 中使用 JIT 编译器的最佳实践和准则。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bitecode.dev/p/whats-the-deal-with-cpython-pypy&quot;&gt;CPython、Pypy、MicroPython、Jython……都是些什么？&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;当我们说 Python 时，通常指的是官方实现的 CPython，但还有很多的“Python”，比如 Pypy、Jython、MicroPython、Brython、RustPython 等等，还有很多像是新“Python”的东西，比如 Nuitka、WinPython、Psyco、Pyjion 等等。文章解释了相关的概念和工具。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://coderslegacy.com/python-apscheduler-asyncioscheduler/&quot;&gt;Python APScheduler：感受 AsyncIOScheduler 的强大&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;APScheduler 是一个调度和自动化任务工具，它的 AsyncIOScheduler 支持调度异步函数和协程，文章介绍了它的功能、优点以及如何优化异步任务调度需求。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://sourcery.ai/blog/chatgpt-maintainable-code/&quot;&gt;在生成代码时避免产生技术债务&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;GPT 和其它大语言模型可以快速生成大量代码，但这也可能导致很多的混乱代码。文章探讨了如何改进这些工具生成的代码，并将其融入到项目中的几种方法，包括采用专家角色、提供示例、遵循最佳实践、遵循标准和明确指南以及代码放置的恰当位置等。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://pythonspeed.com/articles/numpy-is-slow/&quot;&gt;当 NumPy 太慢时&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;在不考虑并行处理的情况下，如何提升 Numpy 性能？NumPy 有三个固有瓶颈（急切执行、通用编译代码和向量化导致的高内存使用率）。针对这些瓶颈，文章介绍四种解决方案：手动优化代码、使用 JAX 作即时编译、使用 Numba 作即时编译，以及使用提前编译。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://coderslegacy.com/python-numba-tutorial/&quot;&gt;Numba 教程：使用 JIT 编译加速 Python 代码&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;Numba 是一个专用的即时编译器，通过将 Python 代码编译为高效的机器代码来消除解释执行的开销，从而提升性能。文章介绍了 Numba 的功能、内部原理、主要用法和常见问题。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.fidelramos.net/software/python-code-quality&quot;&gt;自动化提升 Python 代码质量&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;如何使用较少的时间和精力来提升代码的质量？文章介绍了一些提升代码质量的工具（flake8、Black、isort、mypy、bandit等），以及使用 IDE、CI 和 pre-commit 等方式自动化调用这些工具。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cognibits.hashnode.dev/enhancing-data-analysis-with-pandasai&quot;&gt;使用 PandasAI 增强数据分析&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;PandasAI 是最近火爆的库，为 Pandas 集成了 AI 对话功能，可简化数据操作。文章介绍了 PandasAI 作复杂查询与图表可视化的方法，以及介绍了它提供的十几个方便好用的函数。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.codium.ai/blog/best-practices-for-writing-unit-tests/&quot;&gt; 写单元测试的最佳实践&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;单元测试的好处无须赘述，但是写单测却是开发者最讨厌的事情之一。文章罗列了 10 条写单元测试的最佳实践，介绍了手工写单元测试的步骤，最后介绍了使用 Codium.AI 自动化编写测试的方法。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://netflixtechblog.com/migrating-netflix-to-graphql-safely-8e1e4d4f1e72&quot;&gt;Netflix 如何安全地迁移到 GraphQL&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;Netflix 官方的一篇博客，介绍了在将手机 APP 安全地从 Falcor 迁移到 GraphQL 的过程中，所采用的三种测试策略：AB 测试、Replay 测试和 Sticky Canaries。AB 测试用于评估新功能对客户的影响，Replay 测试用于验证迁移的正确性，Sticky Canaries 用于验证性能和业务指标。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已免费发布了 9 期，访问下方链接，即可查看全部内容：&lt;a href=&quot;https://pythoncat.top/tags/weekly&quot;&gt;https://pythoncat.top/tags/weekly&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Kanaries/pygwalker&quot;&gt;PyGWalker：将 pandas 数据转换为 Tableau 样式的可视化界面&lt;/a&gt; (中英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;一个在 Jupyter Notebook 环境中运行的可视化探索式分析工具，仅一条命令即可生成一个可交互的图形界面，以类似 Tableau/PowerBI 的方式，通过拖拽字段进行数据分析。（star 6.5K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Suzhou-Tongyuan/jnumpy&quot;&gt;jnumpy：快速用 Julia 编写 Python C 扩展&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;用 Julia 为 Python 写高性能的 C 扩展，提速约 200x。（@xgdgsc 投稿）&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jupyterlab/jupyter-ai&quot;&gt;jupyter-ai：JupyterLab 的生成式 AI 扩展&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;JupyterLab 官方提供的生成式 AI 扩展，主要提供了：&lt;code&gt;%%ai&lt;/code&gt; 指令、原生的聊天 UI 页面、支持大量平台的大语言模型（AI21、Anthropic、Cohere、Hugging Face、OpenAI、SageMaker 等）。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Undertone0809/broadcast-service&quot;&gt;broadcast-service: 一个强大的 Python 发布订阅者框架&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;一个发布订阅者框架，支持同步异步调度、定时任务、主题管理、发布订阅者回调等功能。（@Zeeland 投稿）&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Undertone0809/cushy-storage&quot;&gt;cushy-storage: 一个基于磁盘缓存的 ORM 框架&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;一个基于磁盘缓存的 ORM 框架，可对基本数据类型及自定义的数据通过 ORM 进行增删改查，支持多种序列化操作和数据压缩方式。（@Zeeland 投稿）&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Giskard-AI/giskard&quot;&gt;giskard：专用于 ML 模型的测试框架&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;如何测试机器学习模型、要涵盖哪些问题、如何实施测试？这个框架可扫描数十种漏洞（性能偏差、数据泄漏、不鲁棒性、虚假关联、过度自信、信心不足、不道德问题等），并基于结果生成特定领域的测试套件。（star 1K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/XingangPan/DragGAN&quot;&gt;DragGAN：基于点的交互式图像编辑&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;本周最火项目，可在图像上通过拖动点的方式，生成想要的新图像，非常惊艳！（star 28K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tomerfiliba/plumbum&quot;&gt;plumbum: 永远不要再写 shell 脚本&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;除了类似 shell 的语法和方便的快捷方式外，这个库还提供了本地和远程命令执行（通过 SSH）、本地和远程文件系统路径、简单的目录和环境操作、以及一个可编程的 CLI 工具包。（star 2.6K）&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/threestudio-project/threestudio&quot;&gt;threestudio：用于生成 3D 内容的统一框架&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;支持用文本提示、单个图像和少量镜头图像创建 3D 内容。支持多种模型，如 ProlificDreamer、DreamFusion、Magic3D、Score Jacobian Chaining，等等。（star 1.8K）&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/danielgatis/rembg&quot;&gt;rembg：一个删除图像背景的工具&lt;/a&gt; (英)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;支持删除图像的背景，支持多种使用方式（cli、库、docker）和多种强大的功能。（star 10.5K）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐼关于周刊&lt;/h2&gt;
&lt;div&gt;Python 潮流周刊，由豌豆花下猫主理，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;内容创作要花费大量的时间和精力，如果你觉得有帮助，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt;、&lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！如果你喜欢本周刊，请转发分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python潮流周刊#8：Python 3.13 计划将解释器提速 50%！</title>
            <link>https://pythoncat.top/posts/2023-06-24-weekly/</link>
            <guid>https://pythoncat.top/posts/2023-06-24-weekly/</guid>
            <description>Python 3.13 将引入重大更新，最值得期待的 Python 版本之一</description>
            <pubDate>Sat, 24 Jun 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里每周分享优质的 Python 及通用技术内容，部分为英文，已在小标题注明。（标题取自其中一则分享，不代表全部内容都是该主题，特此声明。）&lt;/div&gt;
&lt;div&gt;首发于我的博客：&lt;strong&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-06-24-weekly&quot;&gt;https://pythoncat.top/posts/2023-06-24-weekly&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/faster-cpython/ideas/blob/main/3.13/README.md&quot;&gt;Python 3.13 版本的计划&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Faster CPython 项目（即香农计划）有了关于 3.13 版本的最新计划，这次的性能目标是减少解释器 50% 的耗时。涵盖三项主要工作：第 2 层的优化器、启用子解释器（PEP-554）、内存管理。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://superfastpython.com/why-numpy-parallelism/&quot;&gt;为什么 Numpy 并行性很重要？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Numpy 是作科学计算和数据分析的最重要的库之一，并行性是提升其性能的重要手段。文章介绍了 5 种可以实现 Numpy 并行性的场景和方法：加载/保存 Numpy 数组数据、高效地计算数学函数、高效地初始化数组、并行执行数组的元素级数学运算、在进程间高效共享 Numpy 数组数据。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://ohadravid.github.io/posts/2023-03-rusty-python/&quot;&gt;用少于 100 行的 Rust 使 Python 变快 100 倍&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章针对一个有性能问题的 Python 库，使用 Rust 重写并作了三轮优化后，提升了性能 100 倍。文中使用了 py-spy 库绘制火焰图，分析出了代码的瓶颈点，并以此作为优化的依据，可以看到前后火焰图的差别很大。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;4、 &lt;a href=&quot;https://www.jelmer.uk/port-py-to-rust.html&quot;&gt;将 Python 项目移植到 Rust&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章指出“一步到位的移植”方式存在一些问题，从而提出“迭代式移植”的方法，并给出了一个代码示例。&lt;/div&gt;
&lt;div&gt;5、 &lt;a href=&quot;https://benhoyt.com/writings/python-api-design/&quot;&gt;设计 Pythonic 的库 API&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;如何设计出一个 Pythonic 的 API？在设计上有什么方法和基本原则呢？文章从代码结构、变量命名、错误处理、版本控制、类型注解等方面，给出了非常详细的介绍。文章较长，最后总结出 18 条 takeaways。&lt;/div&gt;
&lt;div&gt;6、 &lt;a href=&quot;https://bernsteinbear.com/blog/typed-python/&quot;&gt;编译类型化的 Python&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Python 已支持类型提示，那能否编译 Python 代码为本地代码以提升性能呢？虽然类型提示可以提供一些性能优化，但由于 Python 的动态特性和灵活性，使得静态分析和编译非常困难。因此目前还没有一种方法可以将 Python 代码编译成本地代码以提高性能。&lt;/div&gt;
&lt;div&gt;7、 &lt;a href=&quot;https://www.revsys.com/tidbits/pytest-fixtures-are-magic/&quot;&gt;pytest 的夹具很神奇！&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;夹具（fixture）是在测试前设置和准备必要数据的一种机制，可以将测试数据和测试代码分离。文章介绍了 pytest 中夹具的基本用法，以及与 Django 项目的结合使用。&lt;/div&gt;
&lt;div&gt;8、 &lt;a href=&quot;https://just-taking-a-ride.com/inside_python_dict/chapter1.html&quot;&gt;探析 Python 字典的实现原理&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这是一个系列文章，支持用可视化的调试方式探析 Python字典的实现原理。这篇文章介绍了如何通过哈希表实现字典，以及如何解决哈希冲突。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;9、 &lt;a href=&quot;https://djangocentral.com/flask-vs-django-selecting-the-perfect-python-web-framework/&quot;&gt;Flask vs Django：选择完美的 Python Web 框架&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Python 最主流的两个 Web 框架是 Flask 和 Django，文章深入比较了它们的主要功能、优势与缺点、流行的插件和使用场景等，让读者更方便做出自己的选择。&lt;/div&gt;
&lt;div&gt;10、 &lt;a href=&quot;https://www.bitecode.dev/p/why-not-tell-people-to-simply-use&quot;&gt;为什么不告诉人们“简单地”使用 pyenv、poetry、anaconda&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章的要点是：介绍一个基本的 Python 打包流程，尽可能减少依赖和要求，并解决大多数用户的打包问题。文中列出了一些常见的打包问题，并提供了一些解决方案，同时指出了一些常见的打包工具（如 homebrew、pyenv、anaconda、poetry）的缺点。&lt;/div&gt;
&lt;div&gt;11、 &lt;a href=&quot;https://jeff.glass/post/pyscript-asyncio/&quot;&gt;PyScript 中的 Asyncio&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章介绍了在 PyScript/Pyodide 中使用 &lt;code&gt;async/await/asyncio&lt;/code&gt; 来编写并发代码，还介绍了 Pyodide.Webloop 的实现，该实现允许 async/await 与浏览器事件循环一起使用。&lt;/div&gt;
&lt;div&gt;12、 &lt;a href=&quot;https://glyph.twistedmatrix.com/2014/02/unyielding.html&quot;&gt;线程的问题及其解决方案&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-06-17-weekly7&quot;&gt;上期周刊&lt;/a&gt;第一则分享中的三篇文章偏向于支持隐式的 async，有读者建议再呈现一些支持显式 async 的观点。这篇文章的要点是：线程会使本地推理变得困难，而本地推理是软件开发中最重要的事情之一。因此，应该避免使用线程，而使用异步编程模型，如回调、promise、协程等。同时，文章还提到了使用隐式协程的风险，因为它们可能会导致与线程相同的问题。（@Plutonium 投稿）&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、 &lt;a href=&quot;https://github.com/zhiyiYo/PyQt-Fluent-Widgets/blob/master/docs/README_zh.md&quot;&gt;PyQt-Fluent-Widgets：基于 PyQt5 的 Fluent Design 风格组件库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;目前开源且美观实用的 PyQt/PySide 组件库很少，所以作者照着 WinUI3 的设计稿写了这个 Fluent Design 风格的组件库，支持亮暗主题无缝切换和自定义主题色，支持 PyQt5/PyQt6/PySide2/PySide6 ，搭配 QtDesigner 可以快速设计出美观的界面。（来自@shokokawaii）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;2、 &lt;a href=&quot;https://github.com/pycob/pyvibe&quot;&gt;pyvibe：使用 Python 生成样式化的 HTML 页面&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;PyVibe是一个用于创建网页的 Python 库，让 Python 开发者快速构建前端页面，简化 UI 开发。PyVibe 返回一个 HTML 字符串，可用于静态页面、Flask 函数、Pyodide 动态客户端呈现。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;3、 &lt;a href=&quot;https://github.com/pynecone-io/pynecone&quot;&gt;pynecone：纯 Python 的 Web 框架&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Pynecone 发布于 2022 年 12 月，已获得 9K 星星，可谓十分火爆。它是一个用于构建和部署 Web 程序的全栈框架，提供了 50+ 内置组件，支持创建复杂的布局和使用 CSS 的全部功能来设置样式。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;4、 &lt;a href=&quot;https://github.com/norvig/pytudes&quot;&gt;pytudes：短小精悍的 Python 编程练习内容&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这个项目包含了一些短小却很有挑战性的项目代码，既有“Advent of Code”历年的年度编程挑战活动的题目，也有“The Riddler”的系列数学谜题，还有文字谜题、概率问题等，甚至有使用 Python 解任何的数独题、实现一个 lisp 解释器，等等。&lt;/div&gt;
&lt;div&gt;5、 &lt;a href=&quot;https://github.com/xinyu1205/recognize-anything&quot;&gt;recognize-anything：Recognize Anything 模型和 Tag2Text 模型&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Recognize Anything Model 是一种图像标记模型，可以高精度地识别任何常见类别；Tag2Text 是一种以标签为指导的视觉语言模型，可以支持字幕、检索和标签。这个项目是这两个模型的代码实现。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;6、 &lt;a href=&quot;https://github.com/alejandro-ao/ask-multiple-pdfs&quot;&gt;ask-multiple-pdfs：支持与多个 PDF 聊天的 Langchain 程序&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;支持使用自然语言同时与多个 PDF 文件进行对话。项目使用了 streamlit，可在浏览器中显示用户界面。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;7、 &lt;a href=&quot;https://github.com/zjunlp/DeepKE&quot;&gt;DeepKE：用于知识图谱提取和及构建的开放工具包&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;DeepKE 是用于知识图谱构建的知识提取工具包，支持 cnSchema、低资源、文档级和多模态场景的实体、关系和属性提取。三个主要功能：命名实体识别、关系提取、属性提取。项目提供了详细的文档、教程和在线演示。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;8、 &lt;a href=&quot;https://github.com/wmariuss/awesome-devops&quot;&gt;awesome-DevOps：精选的 DevOps 平台、工具、实践和资源的列表&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一个“awesome”系列仓库，收录了关于 DevOps 的方方面面的内容，包含各种平台、自动化、CI/CD、代码管理、网络服务器、数据库、监控工具、网关、混沌工程，等等。&lt;/div&gt;
&lt;h2&gt;🥂讨论&amp;amp;问题&lt;/h2&gt;
&lt;div&gt;1、 &lt;a href=&quot;https://news.ycombinator.com/item?id=36339777&quot;&gt;Hacker News：Our Plan for Python 3.13&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一则热门讨论，话题关于 Python 3.13 版本的开发计划。不出意外，大部分的留言都围绕着 GIL，赞成与反对声皆有。&lt;/div&gt;
&lt;div&gt;2、 &lt;a href=&quot;https://news.ycombinator.com/item?id=36370684&quot;&gt;在你最喜欢的编程语言中，有哪些很优雅的代码库？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这也是一则 HN 上的帖子，既引起了关于编程语言本身的讨论，也涉及不同编程语言生态中的一些优秀的项目。有趣的是，有三则关于 Python 的留言都推荐了我们在上文中分享的&lt;code&gt;pytudes&lt;/code&gt; 项目！&lt;/div&gt;
&lt;h2&gt;🐼关于周刊&lt;/h2&gt;
&lt;div&gt;Python 潮流周刊，由豌豆花下猫主理，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;内容创作要花费大量的时间和精力，如果你觉得有帮助，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt;、&lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！如果你喜欢本周刊，请转发分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python潮流周刊#7：我讨厌用 asyncio</title>
            <link>https://pythoncat.top/posts/2023-06-17-weekly7/</link>
            <guid>https://pythoncat.top/posts/2023-06-17-weekly7/</guid>
            <description>本期周刊提及了22篇文章/教程，13个开源项目/资源，3则音视频</description>
            <pubDate>Sat, 17 Jun 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里记录每周值得分享的 Python 及通用技术内容，部分为英文，已在小标题注明。（标题取自其中一则分享，不代表全部内容都是该主题，特此声明。）&lt;/div&gt;
&lt;div&gt;首发于我的博客：&lt;a href=&quot;https://pythoncat.top/posts/2023-06-17-weekly7&quot;&gt;https://pythoncat.top/posts/2023-06-17-weekly7&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://charlesleifer.com/blog/asyncio&quot;&gt;AsyncIO&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章的作者讨厌 asyncio 库，认为使用 &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; 的设计十分糟糕，它与大多数库不兼容，也不满足“Python之禅”的一些标准。作者的推荐方案是 gevent，提及了它的几点好处。另外，作者还推荐了两篇相关的文章：Flask 作者 Armin Ronacher 的《&lt;a href=&quot;https://lucumr.pocoo.org/2016/10/30/i-dont-understand-asyncio&quot;&gt;I don’t understand Python’s Asyncio&lt;/a&gt;》，SQLAlchemy 作者 Mike Bayer 的《&lt;a href=&quot;https://techspot.zzzeek.org/2015/02/15/asynchronous-python-and-databases/&quot;&gt;Asynchronous Python and Databases&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://eng.lyft.com/what-the-heck-is-gevent-4e87db98a8&quot;&gt;gevent 到底是什么？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;gevent 是一个基于协程的协作式多任务 Python 框架，使用猴子补丁来协调所有代码。这篇文章是一个系列的第一篇，介绍了 gevent 的基本实现原理，第二篇是《&lt;a href=&quot;https://eng.lyft.com/gevent-part-2-correctness-22e3b7998382&quot;&gt;Gevent Correctness&lt;/a&gt;》，第三篇是《&lt;a href=&quot;https://eng.lyft.com/gevent-part-3-performance-e64303fa102b&quot;&gt;Gevent Performance&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.kdnuggets.com/2023/06/getting-started-reactpy.html&quot;&gt;ReactPy 的入门教程&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;上期周刊推荐过的 ReactPy 最近很火，它支持用 Python 写 React 风格的前端应用。这里是一篇简单的入门教程。另外，建议感兴趣的同学去看&lt;a href=&quot;https://reactpy.dev/docs/guides/getting-started/index.html&quot;&gt;官方文档&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://qin.news/python-circular-dependency-and-global-contexts&quot;&gt;Python 业务框架循环依赖和全局上下文的一些思考&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如何简单而优雅地解决 Python 的循环依赖问题呢？作者考察了主流 API 框架（Django、Flask、FastAPI）的上下文管理方案，然后介绍了自己框架采用的方案：借鉴了 Ray 社区中对象所有权的概念，在一个协程上实现一个简易的所有权字典。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://amakelov.github.io/blog/deps&quot;&gt;Python 函数调用的实际依赖关系跟踪&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;跟踪 Python 函数调用时访问的代码和数据是一种很有用的操作，比如绘制依赖图、调试和分析性能、缓存失效。这篇文章考察了一种可能的实现方式，包含了一个少于 100 行代码的最小可行实现。作者是 MIT 的计算机科学博士。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://juejin.cn/post/7244033665209073725&quot;&gt;Python 3.x从基础到实战 - typing类型提示&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一篇入门教程，通过简短的示例，介绍了 Python Typing 模块的基础用法和进阶用法。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://www.pythonpapers.com/p/an-intro-to-wxpython&quot;&gt;wxPython 入门教程&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;wxPython 是跨平台的图形用户界面框架，基于 wxWidgets 库开发，在 1998 年发布。它最新发展到了 4.x 版本，这篇文章基于最新的特性作了详细的入门介绍。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://juejin.cn/post/7241943960083546171&quot;&gt;Python 装饰器的用法指导&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一篇很认真的文章，介绍了装饰器的基本概念和进阶用法。在示例部分介绍了 Django 的几个很常用的装饰器（&lt;code&gt;@login_required&lt;/code&gt;、&lt;code&gt;@permission_required&lt;/code&gt;、&lt;code&gt;@csrf_exempt&lt;/code&gt;、&lt;code&gt;@cache_page&lt;/code&gt;）。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://superfastpython.com/numpy-share-array-processes&quot;&gt;在进程间共享 Numpy 数组的 7 种方式&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;多进程编程时最麻烦的事情之一就是共享数据，这篇文章介绍了 7 种共享 Numpy 数组的方式：传递参数、使用全局变量、使用队列 Queue、使用管道 Pipe、使用基于 ctypes 的 RawArray、使用 Python 3.8 的 SharedMemory、使用多进程的管理器。这是一篇系统性的长文，里面还引用了作者的一些相关文章，十分推荐阅读。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://www.timescale.com/blog/tools-for-working-with-time-series-analysis-in-python&quot;&gt;在 Python 中作时间序列分析的工具&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;时间序列数据（&lt;strong&gt;Time-Series Data&lt;/strong&gt;）是指在不同时间点上收集的数据，这篇文章介绍了在 Python 中分析时间序列数据的工具，包括常用的 NumPy、pandas 和 Matplotlib，以及 Tsfresh、Sktime、AutoTS、Prophet、Timescale 等。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://neuronize.dev/learn-handling-missing-data-in-10-minutes&quot;&gt;如何快速处理缺失的数据&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;在数据分析和机器学习领域，需要尽量确保数据集的完整性和准确性，因此处理缺失值是必不可少的环节。文章先介绍了数据缺失的原因和模式（完全随机丢失 、随机丢失和不随机丢失），然后介绍了处理缺失值的常用方法：删除、填充、插补。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://coderslegacy.com/cython-vs-cpython-comparing-speed&quot;&gt;Cython 与 CPython：对比性能差异&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这篇文章用 10 个不同的基准作性能比较，涵盖了多种场景及边缘情况，包括斐波那契数列、斐波那契数列（迭代）、矩阵乘法、质数生成、字符串拼接、计算均值、计算均值（未优化）、算术运算、文件操作、线性搜索、冒泡排序。猜猜最后的结论是什么呢？&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://www.vidavolta.io/streaming-with-fastapi&quot;&gt;使用 FastAPI 进行流式处理&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;服务器推送事件 （&lt;strong&gt;Server-Sent Events&lt;/strong&gt;） 是一种基于 HTTP 的单向通信协议，允许服务器向客户端实时推送数据。这篇文章解释了如何使用 FastAPI 实现流式处理 JSON 事件。文章出自“&lt;em&gt;FastAPI Pro 系列&lt;/em&gt;”，另外两篇文章关于&lt;a href=&quot;https://www.vidavolta.io/dynamically-configure-python-apps-fastapi&quot;&gt;如何使用动态配置&lt;/a&gt;、&lt;a href=&quot;https://www.vidavolta.io/fastapi-api-keys&quot;&gt;如何加密保护 API&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;https://techwasti.com/fastapi-interview-questions-on-middleware&quot;&gt;20 道关于 FastAPI 中间件的面试题&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;中间件（&lt;strong&gt;middleware&lt;/strong&gt;）是 FastAPI 中的一种机制，允许在 HTTP 请求和响应到达路由处理程序之前拦截和修改它们。文章包含 20 个与中间件、身份验证和授权相关的面试题。&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;https://github.com/python/cpython/issues/101632&quot;&gt;CPython 添加返回常量指令&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;上期周刊引发了“国内 Python 贡献者数量”的话题，@yihong0618 在推特上留言分享了 @penguin-wwy 给 CPython 提交的这个贡献。该作者发现 LOAD_CONST + RETURN_VALUE 高频出现在 pystats 文档中，因此提交了一个新的 &lt;strong&gt;RETURN_CONST&lt;/strong&gt; 指令，此项贡献在 Python 3.12 基准测试中获得约 10% 的性能提升。&lt;/div&gt;
&lt;div&gt;🎁&lt;strong&gt;Python潮流周刊&lt;/strong&gt;🎁已免费发布了 7 期，扫描下方二维码，即可查看全部内容：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/kislyuk/argcomplete&quot;&gt;argcomplete：命令行自动补全库&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;在使用 Python 命令或者命令行工具时，一个痛点是没有补全。使用 argcomplete 后，按 tab 键就可以自动补全。它需要与 argparse 模块一起使用，目前支持 bash 和 zsh 两种 shell。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/AndrewZhe/lawyer-llama&quot;&gt;Lawyer LLaMA：中文法律 LLaMA&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个系统性学习了中国的法律知识体系的大语言模型，能够正确理解民法、刑法、行政法、诉讼法等常见领域的法律概念，可进行基础的法律咨询，涵盖婚姻、借贷、海商、刑事等。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/OpenBMB/CPM-Bee&quot;&gt;CPM-Bee：百亿参数的中英文双语基座大模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个完全开源、允许商用的百亿参数中英文基座模型，采用 Transformer 自回归架构，在超万亿（trillion）高质量语料上进行预训练。在中文的 Zero-CLUE 评测基准上，它大幅超越其他模型，位列中文大模型第一。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/TigerResearch/TigerBot&quot;&gt;TigerBot：多语言多任务 LLM&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;也是国内团队开源的大语言模型，根据 OpenAI InstructGPT 论文在公开 NLP 数据集上的自动评测，TigerBot-7B 达到 OpenAI 同样大小模型的综合表现的 96%。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/xbzstudio/BingAI-Client&quot;&gt;BingAI-Client：突破限制的 New Bing&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;New Bing 集成了 ChatGPT，但是在国内使用的门槛有点高！这个项目的客户端基于 Angular，服务端基于 FastAPI 和 &lt;a href=&quot;https://github.com/acheong08/EdgeGPT&quot;&gt;EdgeGPT&lt;/a&gt;。在本地部署好后，运行服务端程序即可开始使用客户端。（另外推荐一个项目 &lt;a href=&quot;https://github.com/adams549659584/go-proxy-bingai&quot;&gt;go-proxy-bingai&lt;/a&gt;，是用 Vue3 和 Go 搭建的 New Bing 演示站点，国内可用，无需登录即可畅聊）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/TabbyML/tabby&quot;&gt;tabby：可自托管的 AI 编码助手&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这是 GitHub Copilot 的开源/本地替代品，无需 DBMS 或云服务，拥有 Web UI，支持消费级的 GPU。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/ahui2016/pyboke&quot;&gt;pyboke：极简博客生成器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个功能极简、代码极简、自带四种主题、支持生成 RSS 的静态博客生成器。项目基于 Python 3.10，主要使用的库有 arrow、click、jinja2、mistune 等。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/AntonOsika/gpt-engineer&quot;&gt;gpt-engineer&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这是一个基于 ChatGPT4 的 AI 工程师，你只用告诉它需求，然后它会问几个问题，接着生成整个项目代码。提供出来的演示视频非常惊艳！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/facebookresearch/audiocraft&quot;&gt;audiocraft：音频处理和生成库&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这是 FaceBook 开源的一个 PyTorch 库，有最先进的 EnCodec 音频压缩器/分词器，内含文本到音乐模型 MusicGen，使用了 10K 高质量音乐曲目的内部数据集，以及 ShutterStock 和Pond5 的音乐数据。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://www.pythonguis.com&quot;&gt;PythonGUI 教程网站&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;Python 中有很多开发 GUI 的库，除了前文提到的 wxPython，还有 Tkinter、PyQt、PySide、Kivy 等等。这个网站上提供了很多 GUI 相关的学习资料。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://hai-shi.gitbook.io/cpython-internals&quot;&gt;CPython 实现原理&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一本用 GitBook 制作的在线电子书，翻译自微软独立研究员 Anthony Shaw 的《CPython Internals》。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pybit.es/articles/importance-of-refactoring&quot;&gt;pybites：&lt;/a&gt;&lt;a href=&quot;https://pybit.es/articles/importance-of-refactoring&quot;&gt;定期重构的重要性&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这期播客聊了关于重构的相关话题。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://b23.tv/cw3Ai8V&quot;&gt;三个看似一样的列表，占用内存空间竟然不一样多？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;有三个看起来完全一样的列表：[0]*3、[0,0,0]、[0 for _ in range(3)]，但是使用 sys.getsizeof() 计算的内存却完全不同。这是为什么呢？这期 B 站视频通过分析字节码和 CPython 解释器源码，非常硬核地分析出了根本原因，值得一看！&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://b23.tv/2XeGXwI&quot;&gt;asyncio的理解与入门，搞不明白协程？看这个视频就够了&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这里呼应一下本期标题及第一则内容。asyncio 依然是最主流的异步编程库，近几年也在逐渐发展成熟，很有必要深入学习。这是一则 B 站视频，适合用于入门与加深理解。&lt;/div&gt;
&lt;h2&gt;🐱福利活动&lt;/h2&gt;
&lt;div&gt;不定期的福利活动，本期赠书 &lt;strong&gt;5&lt;/strong&gt; 本《Excel 应用大全》，开奖时间 &lt;strong&gt;6 月 22 日&lt;/strong&gt;（端午节）。请给 &lt;strong&gt;Python猫&lt;/strong&gt;公众号发送数字“&lt;strong&gt;8007&lt;/strong&gt;”，获取抽奖资格。&lt;/div&gt;
&lt;div&gt;这本书由 Excel Home 团队策划，由多位微软 MVP 通力打造，全面系统地介绍了 Excel 365 &amp;amp; Excel 2021 的技术特点和应用方法，配合大量典型实用的案例，既可以作为初学者的入门指南，也可作为中高级用户的参考手册。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐼关于周刊&lt;/h2&gt;
&lt;div&gt;Python 潮流周刊，由豌豆花下猫主理，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;内容创作要花费大量的时间和精力，如果你觉得有帮助，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt;、&lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！如果你喜欢本周刊，请转发分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python潮流周刊#6：Python 3.12 有我贡献的代码！</title>
            <link>https://pythoncat.top/posts/2023-06-10-weekly6/</link>
            <guid>https://pythoncat.top/posts/2023-06-10-weekly6/</guid>
            <description>国内 Python 贡献者很少，但并不是没有！本期周刊就提到了两位</description>
            <pubDate>Sat, 10 Jun 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里记录每周值得分享的 Python 及通用技术内容，部分为英文，已在小标题注明。（标题取自其中一则分享，不代表全部内容都是该主题，特此声明。）&lt;/div&gt;
&lt;h2&gt;🦄文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://zhuanlan.zhihu.com/p/634654153&quot;&gt;CPython 贡献日记：Python 3.12 有什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章出自群友@孙孟越，介绍了 Python 3.12 中他深度参与的几个大更新，比如 PEP-701 定型 f-字符串的句法、PEP-688 给 Python Buffer Protocol 暴露 Python 接口、PEP-695 类型参数语法，等等。另外，他在前一篇《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/623602662&quot;&gt;CPython 贡献日记&lt;/a&gt;》中介绍了给开源社区做贡献的相关知识，比如提 PR 的小技巧、提/解决 Issue 的小技巧，等等。（你也想给 Python 贡献代码么？请参考：&lt;a href=&quot;https://devguide.python.org/&quot;&gt;Python Developer’s Guide&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://topbook.cc/overview?selectedArticle=1975&quot;&gt;有哪些值得关注的 AI 工具？我们整理了这 67 个&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了目前流行的 67 个工具，包括大语言模型、搜索引擎、办公、内容生成、精神需求、提示词学习等方向，它还梳理了下面这张思维导图：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://juejin.cn/post/7240248679515963451&quot;&gt;我买了本豆瓣 9.6 分的 Python 书，发现里面每 5 页一个错误？！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章从一本 Python 入门书籍中找出了 30 个有代表性的错误，并给出了“离谱程度”评分。作者批判性阅读了那本书，同理，读者们也应该批判性阅读这篇文章，因为它说得也并不都对。（@TheFry 投稿）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://borretti.me/article/sketch-post-orm&quot;&gt;Sketch of a Post-ORM&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;通常我们使用纯 SQL 或者 ORM 框架来操作数据库，作者比较了这两种方案，指出了它们的诸多缺陷，然后提出了一种新的技术设想。作者从 8 个方面介绍了自己的思路，包括迁移优先、声明式迁移、跨语言移植、更好的 SQL，等等。作者还演示了一个工作流以及 Python 代码示例。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://martinheinz.dev/blog/98&quot;&gt;Python 中运行 Shell 命令的正确做法&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;作者先介绍了 Python 与操作系统交互的一些常用库，比如 pathlib、tempfile、shutil、os、subprocess 等等，最后再介绍了他最为推荐的 &lt;a href=&quot;https://github.com/amoffat/sh&quot;&gt;sh&lt;/a&gt; 库的相关用法。这个库的方法对熟悉 shell 命令的同学非常友好。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://www.vidavolta.io/how-to-upgrade-your-flask-application-using-async/&quot;&gt;如何使用 async 升级 Flask 程序&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章使用 Locust 作负载测试，简单演示了将同步的 Flask 程序修改为异步后，性能数据上的变化。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://snarky.ca/proposing-a-struct-syntax/&quot;&gt;提议给 Python 添加一个结构语法&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;核心开发者 Brett Cannon 的博客介绍了他的思考，提议增加一个&lt;code&gt;struct&lt;/code&gt; 关键字，用于更方便地创建数据类，类似于 C、Rust 与 Go 的结构语法。文中介绍了他的目标以及这个关键字的实现原理，目前在收集意见阶段，未来不排除会提成一个 PEP。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://juejin.cn/post/7240380161555234876&quot;&gt;类属性和实例属性是怎样的关系？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;出自《从 1 到 ∞ 精通 Python》系列，已包含 17 篇文章。作者参考了《Python 源码剖析》的分析方法及结论，深度探析了 Python 解释器源码，讲解 Python 重要特性的实现原理。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://dev.to/lambdatest/39-top-python-frameworks-to-look-for-in-2023-3hdb&quot;&gt;2023 年 39 个顶级 Python 框架&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;文章梳理介绍了 39 个用于开发及测试的 Python 框架，内容很长，介绍的范围很全面。&lt;/div&gt;
&lt;div&gt;10、内容删除&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://www.pythonguis.com/tutorials/getting-started-kivy/&quot;&gt;使用 Kivy 库进行 GUI 开发&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;这是一篇入门教程。Kivy 是一个用于开发图形用户界面的库，支持桌面的跨平台开发，也支持为移动设备创建多点触控的程序。&lt;/div&gt;
&lt;div&gt;12、&lt;a href=&quot;https://pythonspeed.com/articles/speeding-up-numba/&quot;&gt;了解 CPU 有助于提升 Numba 和 NumPy 代码的速度&lt;/a&gt;  (英)&lt;/div&gt;
&lt;div&gt;当需要加快 NumPy 速度或减少其运行内存时，通常使用即时编译器 Numba。文章针对现代 CPU 的特点来优化 代码，将一个去除图像中的噪点程序的耗时从 48 ms 降到了 2 ms。&lt;/div&gt;
&lt;div&gt;13、&lt;a href=&quot;https://www.reversinglabs.com/blog/when-python-bytecode-bites-back-who-checks-the-contents-of-compiled-python-files&quot;&gt;当字节码咬人时：谁检查 Python 文件编译后的内容？&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;ReversingLabs 研究团队发现了一种针对 PyPI 的新型攻击，它使用编译后的 Python 代码来规避检测——可能是第一个利用 PYC 文件直接执行的攻击。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;14、&lt;a href=&quot;http://arthurchiao.art/blog/gpt-as-a-finite-state-markov-chain-zh/&quot;&gt;GPT 是如何工作的：200 行 Python 代码实现一个极简 GPT&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一篇译文，原文作者是 OpenAI 的创始成员 Andrej Karpathy。文章使用 PyTorch 实现了一个极简 GPT，让读者对其内部工作机制有个直观理解。&lt;/div&gt;
&lt;div&gt;15、&lt;a href=&quot;http://arthurchiao.art/blog/transformers-from-scratch-zh/&quot;&gt;600 行 Python 代码实现两个 Transformer（文本分类+文本生成）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这也是一篇译文，原文作者是阿姆斯特丹自由大学的助理教授。原文最早写于 2019 年，那时大语言模型还没有如今火爆。在文章末尾，作者希望 transformer  扩展到其它领域，因为它有很强的通用性。&lt;/div&gt;
&lt;h2&gt;🐿️项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/neodb-social/neodb&quot;&gt;neodb：标记你喜欢的东西&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;NeoDB 是一个用 Django 写的开源项目，也是一个联邦宇宙书影音游戏标注平台，可简单理解成 Web3 的开源的无审查的豆瓣，但支持标记的内容比豆瓣多得多。（这个库是在@laike9m 的博客看到的。以及非常感谢他在 Twitter 上推荐了本周刊！！）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://blog.jupyter.org/jupyterlab-4-0-is-here-388d05e03442&quot;&gt;JupyterLab 4.0 已发布&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;JupyterLab 4.0 主要的新功能有：性能更快、升级的文本编辑器、新的扩展管理器、UI 改进，等等。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/bloomberg/pystack&quot;&gt;pystack&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;pstack 是 Linux 系统上常用的命令行工具，用于显示一个进程的函数调用栈，可诊断进程卡死、死锁等问题，以及分析进程的性能瓶颈。pystack 是用 Python 写成的类 pstack 库。值得一提的是，它竟然还可以显示线程是否持有、是否在等待或正在释放 GIL。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://gpython.aibang.run/&quot;&gt;GPYTHON：你的专属 Python 学习助手&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个基于 ChatGPT 的 Python 在线学习平台，内置了 AI 助手以及在线代码运行模块，允许你随时修改示例代码，一键运行，一键查错。（@Stanaaa 投稿）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://huggingface.co/moka-ai/m3e-base&quot;&gt;M3E 模型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;M3E 是一个中文开源的 Embedding 模型，使用千万级 (2200w+) 的中文句对数据集进行训练，在文本分类和文本检索的任务上都超越了 openai-ada-002 模型。（@王宇昕投稿）&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/reactive-python/reactpy&quot;&gt;reactpy：Python 的 React&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;ReactPy 是一个库，用于在 Python 中构建用户界面，且不使用 Javascript。它的接口类似于 ReactJS 中的组件，可供没有 Web 开发经验的人使用。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/mouday/domain-admin&quot;&gt;domain-admin: 域名 SSL 证书监测平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;基于 Python + Vue3.js 技术栈实现的域名和 SSL 证书监测平台，核心功能：到期自动邮件提醒。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://github.com/NaiboWang/EasySpider&quot;&gt;EasySpider：一个可视化爬虫软件&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个可视化爬虫软件，只需在网页上选择想爬的内容，并根据提示框操作即可完成爬虫设计和执行。也支持以命令行方式执行，可以方便地嵌入到其他系统中。这个项目源于原作者的浙江大学硕士论文，已获得国家发明专利，相关资料可在仓库查看。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/camenduru/text-to-video-synthesis-colab&quot;&gt;text-to-video-synthesis-colab：文本生成视频的模型&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;一个开源的文本生成视频模型，整体模型参数约 17 亿，使用英文输入。放出来的演示视频非常惊艳。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://github.com/opengeos/segment-geospatial&quot;&gt;segment-geospatial：使用 SAM 分割地理空间数据&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;SAM 即“分割任意物体模型”（Segment Anything Model），是计算机视觉领域中非常有用和先进的模型，用于需要精确识别和分割任意物体的应用场景。这个项目使用它来分割地理空间数据。&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://github.com/andy-landy/traceback_with_variables&quot;&gt;traceback_with_variables：Python 回溯（错误消息）打印变量&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;该项目可以在 Python 的回溯信息中添加变量。通过记录日志或打印彩色的变量上下文信息，方便调试异常的原因，并显示堆栈跟踪中每个帧的变量值。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;🐢播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.bilibili.com/video/BV1XX4y1y7s4&quot;&gt;当你用Python3.12的时候，或许就跑了我写的代码呢！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;视频来自 B 站@码农高天，他从 3 月份起，有 20 几个 pr 已合入 Python 3.12。这期视频详细介绍了他做出的几个贡献，主要有完善 pdb 文档、修复了几个 bug、引入 convenience variable 特性，等等。（作者在第一次 pr 被合入后，录了一期《&lt;a href=&quot;https://b23.tv/7zZFshm&quot;&gt;我给Python修了个bug！从今天起，也算是Python开发者了？&lt;/a&gt;》）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.youtube.com/playlist?list=PL2Uw4_HvXqvY2zhJ9AMUa_Z6dtMGF3gtb&quot;&gt;PyCon US 2023 - YouTube&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;今年 PyCon US 活动的视频已经可以看了，共用 142 个视频！PyCon 是全球性的最大的 Python 开发者会议之一，由 PSF 主办，通常在 PyCon 活动期间会举行“Python 语言峰会”，今年的峰会议题详见《&lt;a href=&quot;https://pythoncat.top/posts/2023-05-31-weekly4&quot;&gt;Python潮流周刊#4：Python 2023 语言峰会&lt;/a&gt;》。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.youtube.com/@PyCascades/videos&quot;&gt;PyCascades - 2023 视频&lt;/a&gt; (英)&lt;/div&gt;
&lt;div&gt;2023 年 PyCascades 活动上的视频在上个月发布了，有 20 几个视频。PyCascades 是一个专注于 Python 编程语言的会议，通常在北美地区举行，每年一次。它类似于 PyCon，但是由独立的组织者和志愿者自发组织，规模更小。&lt;/div&gt;
&lt;h2&gt;🐱赞助&amp;amp;支持&lt;/h2&gt;
&lt;div&gt;内容创作要花费大量的时间和精力，如果你觉得有帮助，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt;、&lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！如果你喜欢本周刊，请转发分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;div&gt;诚邀赞助者，帮助本周刊免费且可持续发布，欢迎通过私信联系。&lt;/div&gt;
&lt;h2&gt;🐼关于周刊&lt;/h2&gt;
&lt;div&gt;Python 潮流周刊，由豌豆花下猫主理，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python潮流周刊#5：并发一百万个任务要用多少内存？</title>
            <link>https://pythoncat.top/posts/2023-06-03-weekly5/</link>
            <guid>https://pythoncat.top/posts/2023-06-03-weekly5/</guid>
            <description>精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容</description>
            <pubDate>Sat, 03 Jun 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里记录每周值得分享的 Python 及通用技术内容，部分为英文，已在小标题注明。（标题取自其中一则分享，不代表全部内容都是该主题，特此声明。）&lt;/div&gt;
&lt;h2&gt;文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pkolaczk.github.io/memory-consumption-of-async/&quot;&gt;并发一百万个任务要用多少内存？&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;文中测试了主流的编程语言（Rust、Go、Java、C#、Python、Node.js 和 Elixir），依次运行 1 个、1 万、10 万和 100 万个任务，统计了这些语言所消耗的内存。随着任务量增加，它们的排名出现了较大变化，让我感觉挺意外的。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://towardsdatascience.com/use-these-methods-to-make-your-python-concurrent-tasks-perform-better-b693b7a633e1&quot;&gt;使用这些方法让你的 Python 并发任务执行得更好&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;使用 asyncio 有什么最佳实践呢？这篇文章介绍了 asyncio.gather、asyncio.as_completed 和 asyncio.wait API，还介绍了 Python 3.11 中引入的新 asyncio.TaskGroup 特性。（附一篇&lt;a href=&quot;https://juejin.cn/post/7237424021768011834&quot;&gt;不完整的译文&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;3、原推荐文章为拼凑且非原创，已删&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://programmingeeksclub.com/ultimate-python-multithreading-guide&quot;&gt;Python 多线程编程的终极指南&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;也是一篇长文，介绍了 Python 多线程编程的方方面面，真的是一份终极指南。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.bmpi.dev/dev/deep-in-program-language/how-to-implement-concurrency/concurrency-model/&quot;&gt;编程语言是如何实现并发的之并发模型篇&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;依然是长文，介绍了常见的并发模型及不同编程语言是如何实现的。它的姊妹篇是《&lt;a href=&quot;https://www.bmpi.dev/dev/deep-in-program-language/how-to-implement-concurrency/os-scheduling/&quot;&gt;编程语言是如何实现并发的之操作系统篇&lt;/a&gt;》，都是图文并茂，资料翔实。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://segmentfault.com/a/1190000043833549&quot;&gt;鹅厂程序员的 9 个生存法则&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者分享了自己工作多年对代码设计、架构设计和工作思维的经验，比如 DRY 原则、SOLID 原则、高可用设计、如何想尽一切办法“偷懒”，等等。（文中提到了面向对象编程的原则，这里顺便推荐另一位鹅厂程序员的《&lt;a href=&quot;https://github.com/piglei/one-python-craftsman&quot;&gt;Python工匠&lt;/a&gt;》系列的第 12-14 章）&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://juejin.cn/post/7238274120881422392&quot;&gt;一览 Python 3.12！PEP 701 —— f-string 语法规范化&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;f-string 是 Python 最好用的特性之一，但它也有诸多限制。即将发布的 3.12 会对 f-string 作语法规范化，详情可查看 &lt;a href=&quot;https://peps.python.org/pep-0701/&quot;&gt;PEP-701&lt;/a&gt; 。这里分享的文章带大家直观地感受了这个改动在代码的词法解析（lexing）层面的不同。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://blog.jetbrains.com/pycharm/2023/05/five-things-to-love-about-the-new-ui/&quot;&gt;PyCharm：新用户界面的五大亮点&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;大家都用上 PyCharm 新的 UI 了么？这份官方教程介绍了新 UI 的使用方法及亮点。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://discuss.python.org/t/pep-594-has-been-implemented-python-3-13-removes-20-stdlib-modules/27124&quot;&gt;PEP-594 已被实现：Python 3.13 将移除 20 个标准库&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;Python 3.12 正式版本还要几个月才发布，这边 3.13 已经迫不及待地移除了 20 个标准库。值得一提的是，2to3 项目及 lib2to3 模块也将会被移除。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://innovation.alteryx.com/introducing-grasshopper-an-open-source-python-library-for-load-testing/&quot;&gt;Grasshopper：一个用于负载测试的开源 Python 库&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;Locust 是 Python 最主流的分布式负载测试库，而文章介绍的 &lt;a href=&quot;https://github.com/alteryx/locust-grasshopper&quot;&gt;Grasshopper&lt;/a&gt; 是新开源的基于 Locust 与 Pytest 的更全面的性能测试库。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://hackthedeveloper.com/python-decorator/&quot;&gt;Python 装饰器：用包装巫术增强你的代码&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;Python 装饰器是增强代码行为和灵活性的强大工具，文章内容从基础到高阶，是不错的学习材料。&lt;/div&gt;
&lt;div&gt;12、三个练手项目的实战教程：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://swiftuser.hashnode.dev/how-to-telegram-bot-with-python&quot;&gt;用 Python 开发 Telegram 机器人&lt;/a&gt; （英文）：开发 tg 机器人，教程使用 Tornado 作后端，项目部署在 Render 平台上&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://implement-dns.wizardzines.com/index.html&quot;&gt;花一周末用 Python 实现 DNS&lt;/a&gt; （英文）：教程指导实现一个 DNS 解析器，总代码仅约 200 行，但作者给出了很多学习材料和代码讲解，你能学到的绝对够多。另外，教程最后还有 7 个练习题，可以进一步开发 DNS 解析器的功能。（Julia Evans 是一个宝藏作者，&lt;a href=&quot;https://jvns.ca/&quot;&gt;博客&lt;/a&gt;、&lt;a href=&quot;https://wizardzines.com&quot;&gt;网站&lt;/a&gt; 、&lt;a href=&quot;https://github.com/jvns/pandas-cookbook&quot;&gt;pandas-cookbook&lt;/a&gt; ，等等，强烈推荐！！！）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.leshenko.net/p/ugit/&quot;&gt;用 Python 构建你自己的 Git&lt;/a&gt; （英文）：这个项目我要给它满分！教程网站设计得独特而酷炫，从最小可行项目起步，逐渐添加代码，手把手教你实现 Git 的各种功能。每章都使用 Git 的差异比对方式，明确告诉你增删了哪些代码，良心满满，全网估计找不着第二家！&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/Textualize/frogmouth&quot;&gt;frogmouth：一个在终端中浏览 Markdown 的工具&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;frogmouth 可以打开本地或 URL 中的 md 文件，具有类似浏览器的导航条、历史记录、书签和目录。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/dibrale/samist&quot;&gt;使用 Meta AI 的 SAM 进行图像分割的 Python GUI&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;一个 Python 桌面程序，为 Meta 公司的 AI 模型 SAM 提供了图形界面，可以提取照片里面的物体。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/EniasCailliau/GirlfriendGPT&quot;&gt;GirlfriendGPT：你的人工智能伴侣&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;你有对象了么？这个入门项目使用 ChatGPT 构建一个 AI 伴侣， 拥有个性化的人格、声音以及自拍照！&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://www.slideshare.net/Manjusaka1/python-pptx-258083055&quot;&gt;Python 进化之路.pptx&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一份技术分享的 PPT 材料，介绍了 Python 3.7-3.11 在性能、类型体验及开发者体验方面的优化。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/lucidrains/soundstorm-pytorch&quot;&gt;soundstorm-pytorch：在 Pytorch 中实现 SoundStorm &lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;SoundStorm 是 Google Deepmind 新提出的一个高效的、非自回归的音频并行生成模型。soundstorm-pytorch 使用 Pytorch 实现了这个模型。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/quora/asynq&quot;&gt;asynq：Python 的异步编程库&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;asynq 是 Quora 开发的异步编程库，专注于对外部服务的批处理请求。对于 memcache、redis 等存储服务，它发起一次请求批量获取多个 key，比发出多次请求每次获取一个 key 要快得多。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://github.com/Lancetnik/Propan&quot;&gt;Propan：功能强大且易用的 Python 异步 Web 框架&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;一个基于 pydantic、fastapi 和 pytest 的异步框架，简化了 MQ 的代码集成，并提供了一个有用的开发工具包。其特点是基于消息架构（Messaging Architecture）设计，所以它还是个声明式的 MQ 框架。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://vra.github.io/2023/05/27/talkgpt4all-2-0/&quot;&gt;talkGPT4All：基于 GPT4All 的一个语音聊天程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它利用 OpenAI 的 Whisper 模型将用户输入的语音转换为文本，再调用 GPT4All 的语言模型得到回答文本，最后利用文本转语音（TTS）的程序将回答文本朗读出来。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://github.com/lightly-ai/lightly&quot;&gt;lightly：一个用于图像自监督学习的 Python 库&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;这是一个用于自我监督学习的计算机视觉框架，以类似 PyTorch 的风格编写，支持使用 PyTorch Lightning 进行分布式训练。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.xiaoyuzhoufm.com/episode/647456af6752b5f9de6bd99c&quot;&gt;硬地骇客：独立开发赚钱难？你需要正确的build策略&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;探讨了在海外独立开发者中最常用的 &lt;strong&gt;build in public&lt;/strong&gt; 策略。我对这期节目很有共鸣，打算针对本周刊的一些数据、周刊的创作流程、个人知识输入及创作体系等话题，不久会做一些分享。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.xiaoyuzhoufm.com/episode/646af4a66752b5f9dec561c6&quot;&gt;代码之外：离开微软、人生在于体验？阅读的意义、主动和被动的人生&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一档新上线的程序员闲聊播客节目，主题很随性，但常常有能打动人的片段。这里分享的是第一期，它目前已更新到第三期，第三期请的嘉宾是 Vue 的作者尤雨溪！&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://changelog.com/podcast/526&quot;&gt;Changelog #526：与你的朋友一起 Git&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;这期播客聊了一些 Git 工具，如 Git-Heat-Map、Git-Sim、git-bug、GitUI，等等。因为有两个工具是用 Python 编写的，因此也聊了一些 Python 安装依赖包的话题。Brett Cannon 针对主播们的错误用法，写了一篇&lt;a href=&quot;https://snarky.ca/in-response-to-the-changelog-526/&quot;&gt;回应博客&lt;/a&gt; ，主要介绍了 pipx、.pyz 文件以及系统包管理器的正确使用。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://talkpython.fm/episodes/show/418/how-to-keep-a-secret-in-python-apps&quot;&gt;#418：如何在 Python 程序中加密保存&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;“Talk Python To Me”的这期播客探讨如何处理程序要用到的敏感信息，同时也聊到了日常个人密码的保存方案。我正巧本周还看到一篇《&lt;a href=&quot;https://xuanwo.io/reports/2023-21/&quot;&gt;2023-21: 我的 1Password 密钥管理实践&lt;/a&gt;》，它系统介绍了密码管理、SSH/Shell 集成和 CI/CD 应用等内容。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.deeplearning.ai/short-courses/?continueFlag=40c2724537472cbb3553ce1582e0db80&quot;&gt;吴恩达三门新的生成式 AI 课程&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;使用 OpenAI 的 ChatGPT API 构建系统、LangChain 用于开发 LLM 应用、Diffusion模型是如何工作的。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://twitter.com/python_spaces/status/1663976856578822144&quot;&gt;MIT 的三门 Python 相关课程&lt;/a&gt; （英文）&lt;/div&gt;
&lt;div&gt;麻省理工学院的免费课程：Python 计算机科学和编程简介、经典机器学习、深度学习。&lt;/div&gt;
&lt;h2&gt;赞助&amp;amp;支持&lt;/h2&gt;
&lt;div&gt;内容创作要花费大量的时间和精力，如果你觉得有帮助，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt;、&lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！如果你喜欢本周刊，请转发分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;div&gt;另诚邀赞助者，欢迎通过私信联系。&lt;/div&gt;
&lt;h2&gt;关于周刊&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python潮流周刊#4：Python 2023 语言峰会</title>
            <link>https://pythoncat.top/posts/2023-05-31-weekly4/</link>
            <guid>https://pythoncat.top/posts/2023-05-31-weekly4/</guid>
            <description>精心筛选国内外的 200+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容</description>
            <pubDate>Wed, 31 May 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里记录每周值得分享的 Python 及通用技术内容，本期是特别加更版，聚焦于 Python 官方 2023 年语言峰会的系列博客。&lt;/div&gt;
&lt;div&gt;每年在 PyCon US 开始之前，Python 核心开发者、维护者和特邀嘉宾都会聚在一起参加 Python 语言峰会：这是一个为期一天的会谈活动，讨论 Python 的未来方向。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;今年的活动刚结束一个月，PSF 在本周一发布了多篇博客，回顾了峰会上的一些演讲内容。本期周刊将这些文章进一步作了摘要，分享给大家：&lt;/div&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-three.html&quot;&gt;Three Talks on the C API&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是关于 C API 的三场演讲。首先，Mark Shannon 和 Guido van Rossum 提及当前 C API 对第三方扩展的支持不够，经常在升级版本时破坏它们的功能。会上的结论是收集 C API 的问题清单，再制定解决方案。&lt;/div&gt;
&lt;div&gt;另一场演讲是关于 HPy，它是一个用于编写 Python 扩展模块的新的 API，旨在解决 CPython C API 的一些限制和问题。它的好处是编写的扩展模块可以在不同的 Python 实现中运行，例如 CPython 和 PyPy。但是，演讲者想要官方将它作为推荐方案的想法没有得到支持，一方面的原因是它还不够完善，更重要的原因则是 Guido 评论的自上而下的方法行不通。HPy 似乎是挺不错的克服 C API 问题的方案，但它要取代 C API 的地位，还为时尚早。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-making.html&quot;&gt;Making the Global Interpreter Lock Optional&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;我们曾多次介绍过 nogil 项目，比如在周刊第二期就分享了一篇文章。在本次峰会上，nogil 的作者 Sam Gross 介绍了过去一年的进展，给出了 nogil 在性能上取得的令人满意的数据，还提出了更明确的路线图。大家最担心的依然是它提出编译成两个发行版、以及导致的调试困难等问题。（我们曾在 2 月份的&lt;a href=&quot;https://mp.weixin.qq.com/s/HHSjv0ZlAjq0ZvLHMI-W9g&quot;&gt;一篇文章&lt;/a&gt; 中讨论过）&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-towards.html&quot;&gt;Towards Native Profiling for Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Joannah Nanjekye 的演讲介绍了 Scalene，这是一个基于采样的 Python 分析器，可以在报告中区分机器代码和 Python 代码。使用 C、C++ 或 Rust 编写的 Python 扩展会被编译为机器代码，因此很难用采样的方式分析。Scalene 解决了一些技术难题，是最受欢迎的 Python 分析工具之一。演讲者试探性提出将 Scalene 的成果集成到标准库 &lt;code&gt;cProfile&lt;/code&gt; 中，但没有得到响应。最后，这个库还被拿来跟 Python 3.12 中引入的 &lt;code&gt;perf&lt;/code&gt; 分析器作比对。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-what-is.html&quot;&gt;What is the stdlib for?&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Brett Cannon 提出的问题实际是：标准库应该扮演什么样的角色？Python 在发展初期自诩“自带电池”，包含了很多标准库，但随着第三方库越来越丰富以及 PyPI 使得安装库非常便利，很多标准库就不再有价值了。与会者的共识是：标准库应该专注于帮助用户编写更好的 Python 代码。这意味正在进行的标准库“瘦身计划”不会停，同时，未来的新标准库会更加规范引入。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-pattern.html&quot;&gt;Pattern Matching, __match__, and View Patterns&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;模式匹配语法是 3.10 版本的重大特性，但是 Sullivan 认为它的能力相当有限，因此提出了模式匹配的后续发展方向。与会者们普遍认同要增强模式匹配语法，然而，是否要引入一个新的魔术方法 __match__，或者采用别的方案，暂无定论。文中附有很多代码示例以及关于模式匹配的参考资料，对此话题感兴趣的同学可以去了解下。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-python.html&quot;&gt;Python on Mobile: State of the Union&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Russell Keith-Magee 介绍了 BeeWare，它的目标是在 Android 和 iOS 等移动平台上轻松运行 Python。项目已得到 Anaconda 的投资支持，演讲者的诉求是希望得到 CPython 的“Tier-3”支持。会上讨论了 CI 测试套对移动平台的支持、sys.platform 在移动平台应该得到什么值、以及如何在移动平台发布 CPython 二进制文件，等等。手机上的 Python，这值得期待！&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023-burnout.html&quot;&gt;Burnout is Real&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Guido 在峰会上聊了开源倦怠、解决倦怠的策略、以及如何避免倦怠等话题。很多时候，开源贡献者都是在用爱发电，然而大型开源项目还常常有复杂的场景、琐碎的讨论、多样的人际协作、时常冲突的观点或想法等，这些都容易让人疲倦、消磨人的热情。（PS.如果你关注技术新闻的话，会看到 Rust 社区最近闹得沸沸扬扬的核心开发者内讧事件。开源社区的发展也是一大难题，庆幸的是这届峰会反映出 Python 社区是在健康发展中）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://pyfound.blogspot.com/2023/05/the-python-language-summit-2023.html&quot;&gt;Lightning Talks&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了三场简短的闪电演讲，主题有：让我们支持 LLVM-BOLT 作为官方功能、在 Python 中实现延迟导入的机制、让模块支持调用（已提出 PEP-713）。&lt;/div&gt;
&lt;div&gt;以上就是今年峰会上讨论的重大议题，可以说都是非常有意义的话题。&lt;/div&gt;
&lt;div&gt;有不少内容其实已经有了最新进展（毕竟活动已结束一个月），还有一些可能仍需较长时间才能尘埃落定（比如 nogil 和手机上的 Python）。&lt;/div&gt;
&lt;div&gt;这里再补充两篇文章，有关于 Fast CPython 项目的进展：《&lt;a href=&quot;https://lwn.net/Articles/930705&quot;&gt;Faster CPython at PyCon, part one&lt;/a&gt;》、《&lt;a href=&quot;https://lwn.net/Articles/931197/&quot;&gt;Faster CPython at PyCon, part two&lt;/a&gt;》，Python 3.11 已经让大家看到了非常多的性能提升，未来版本更值得期待。&lt;/div&gt;
&lt;h2&gt;赞助&amp;amp;支持&lt;/h2&gt;
&lt;div&gt;内容创作要花费大量的时间和精力，如果你觉得有帮助，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt;、&lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！如果你喜欢本周刊，请转发分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;div&gt;另诚邀赞助者，欢迎通过私信联系。&lt;/div&gt;
&lt;h2&gt;关于周刊&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python潮流周刊#3：PyPI 的安全问题</title>
            <link>https://pythoncat.top/posts/2023-05-27-weekly3/</link>
            <guid>https://pythoncat.top/posts/2023-05-27-weekly3/</guid>
            <description>精心筛选国内外的 200+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容</description>
            <pubDate>Sat, 27 May 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你好，我是猫哥。这里记录每周值得分享的 Python 及通用技术内容，部分为英文，已在小标题注明。（标题取自其中一则分享，不代表全部内容都是该主题，特此声明。）&lt;/div&gt;
&lt;h2&gt;文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://segmentfault.com/a/1190000043822529&quot;&gt;掌握Python面向对象编程的关键：类与对象&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍类和对象概念，通过示例展示 Python 中的类和对象如何工作，包括定义、实例化和继承等。文章出自《Python全景系列》，目前已更新七篇。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://juejin.cn/post/7232977661207085117&quot;&gt;umongo + motor: 构建高效 MongoDB 应用的最佳组合&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍如何在 Tornado 中集成 umongo 和 motor，实现用异步非阻塞的方式与 MongoDB 进行交互。文章出自《tornado 并发编程系列》，目前已更新六篇。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://juejin.cn/post/7234821431804002365&quot;&gt;徒手使用 LangChain 搭建一个 ChatGPT PDF 知识库&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;演示了如何使用 langchain 和 ChatGPT 搭建一个本地的 PDF 知识库，文中使用了 pdfplumber 处理 PDF 文件、使用 streamlit 绘制 UI 界面。知识库搭建和使用流程图如下：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://laike9m.com/blog/python-zhen-de-shi-kao-yi-ge-switch-lai-zhi-xing-zi-jie-ma-de-ma,138&quot;&gt;Python 真的是靠一个 switch 来执行字节码的吗？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个流行的观点说：CPython 有一个大&lt;strong&gt;switch&lt;/strong&gt;，会根据不同的 opcode 跳到相应的 case 分支去执行字节码。文章提出了质疑，最后的结论是：只要 Python 启用了 computed goto （比如在 Mac 和 Linux 上），字节码的执行就不依赖 switch。而这个功能在 Python 3.2 中就已是默认开启的。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.bmpi.dev/dev/renaissance-sqlite&quot;&gt;SQLite 的文艺复兴&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章的开头把我震惊了：“SQLite 源码有 15 多万行，但测试代码和脚本竟有九千多万行”！文章介绍了 SQLite 的架构，以及多个基于它的开源项目，如 Litefs、sql.js、absurd-sql、postlite、sqlite3vfshttp 等等，回答了为什么 SQLite 能在如此多领域有创新的项目出现？&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://soulteary.com/2023/04/05/eighty-lines-of-code-to-implement-the-open-source-midjourney-and-stable-diffusion-spell-drawing-tool.html#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2&quot;&gt;八十行代码实现开源的 Midjourney、Stable Diffusion “咒语”作图工具&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;通过 Docker 和 80 行左右的 Python 代码，实现一款类似 Midjourney 官方图片解析功能 Describe 的 Prompt 工具。提供了两个版本的工具，分别支持 CPU 和 GPU 推理使用。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://kobzol.github.io/rust/python/2023/05/20/writing-python-like-its-rust.html&quot;&gt;像写 Rust 一样写 Python&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;分享了从 Rust 中学到的一些编程习惯：使用类型提示、使用数据类代替元组或字典、使用代数数据类型、使用“newtype”、使用构造函数、使用互斥锁等。总体而言，它们并不是那些“个人喜好式”的编程风格，而是切实能提升代码健壮性和可维护性的编程经验。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://www.patricksoftwareblog.com/flask_tips.html&quot;&gt;一系列的 Flask 小贴士&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;这个《Flask Tips》栏目已分享了 58 个使用 Flask 的小知识，另外其作者在最新的博文《&lt;a href=&quot;https://www.patricksoftwareblog.com/my_favorite_python_packages_for_flask.html&quot;&gt;我开发 Flask 程序时最喜欢用的库&lt;/a&gt;》中，介绍了 APIFairy、Frozen-Flask、Flask-SQLAlchemy 等 10 个常用的库。&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://steve.dignam.xyz/2023/05/20/many-problems-with-celery/&quot;&gt;Celery 的诸多问题&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;Celery 是一个分布式任务队列库，用于实现异步处理和定时任务等功能。但它有很多“问题”，这篇文章一口气列出了 15 个，是一份避坑指南。不过，并非所有问题都有解决方案，比如说它 API 接口不够 Pythonic、没有类型检查等，这些就只能“Live with it”了……&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://last9.io/blog/using-golang-package-in-python-using-gopy/&quot;&gt;Python 借助 Gopy 库实现调用 Go 包&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;作者遇到一个静态验证 PromQL 查询的需求，但没有可用的 Python 库。文章介绍了使用  Gopy 将 Go 代码编译成 wheel 文件的方法，另外也提醒几个注意事项，比如对错误的处理、操作系统的兼容性问题、调试和测试的问题。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;11、&lt;a href=&quot;https://pythonspeed.com/articles/best-file-format-for-pandas/&quot;&gt;最适用于 Pandas 的文件格式&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;使用 Pandas 前需要加载数据，它支持非常多种数据格式，但哪种才最合适呢？文中给出了三个衡量标准（类型支持、磁盘格式、读写速率），并测试了三种数据文件（CSV、JSON 和 Parquet），你猜最后的结论是什么呢？&lt;/div&gt;
&lt;div&gt;12、关于 PyPI 的一系列新闻/文章（英文）&lt;/div&gt;
&lt;div&gt;PyPI 在 3 月上线了官方博客，5 月初刚宣布获得了 AWS 的 14.4 万美元赞助，用于开设一个新的安全工程师职位。巧的是本周密集出现了几件与安全相关的事情。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;5.21，PyPI 在连续一周受到恶意软件的侵扰后，&lt;a href=&quot;https://status.python.org/incidents/qy2t9mjjcc7g&quot;&gt;临时暂停&lt;/a&gt;了新用户的注册及新项目的上传。（这有&lt;a href=&quot;https://programmingeeksclub.com/pypi-security-threats-implications-python-community&quot;&gt;一篇文章&lt;/a&gt;，提到一则有相关性的新闻，这些恶意软件可能是趁 ChatGPT 的热点，通过窃取剪贴板内容从而劫持加密货币交易）&lt;/li&gt;
&lt;li&gt;5.23，PyPI &lt;a href=&quot;https://blog.pypi.org/posts/2023-05-23-removing-pgp/&quot;&gt;宣布移除 PGP 签名&lt;/a&gt;，因为近三年上传的签名仅有 36% 为有效的，移除这项功能有利于降低维护成本。（这有&lt;a href=&quot;https://blog.yossarian.net/2023/05/21/PGP-signatures-on-PyPI-worse-than-useless&quot;&gt;一篇文章&lt;/a&gt;，使用大量数据和统计图分析了 PyPI 上糟糕的 PGP 情况）&lt;/li&gt;
&lt;li&gt;5.24，PyPI 发了&lt;a href=&quot;https://blog.pypi.org/posts/2023-05-24-pypi-was-subpoenaed&quot;&gt;一篇博客&lt;/a&gt;，披露 PSF 收到了美国司法部的三张要求提供 PyPI 用户数据的传票，在律师的建议下，他们提供了司法部索要的数据，并公开了传票的相关细节。&lt;/li&gt;
&lt;li&gt;5.25，PyPI 发布《&lt;a href=&quot;https://blog.pypi.org/posts/2023-05-25-securing-pypi-with-2fa&quot;&gt;通过双因素身份验证保护 PyPI 帐户&lt;/a&gt;》，宣布在 2023 年底前，PyPI 上的帐户都必须启用双重验证（2FA），以此提升账户的安全性。&lt;/li&gt;
&lt;li&gt;5.26，PyPI 发布《&lt;a href=&quot;https://blog.pypi.org/posts/2023-05-26-reducing-stored-ip-data&quot;&gt;减少 PyPI 中存储的 IP 数据&lt;/a&gt;》，介绍了团队出于不存储用户 IP 的目的而做的一些事情，试图既要保护用户的隐私，又能更好地运维管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/Syan-Lin/CyberWaifu&quot;&gt;CyberWaifu：使用 LLM 和 TTS 实现的聊天机器人&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用 LangChain 作为 LLM 主体框架，使用 go-cqhttp 进行 QQ 机器人部署，TTS 支持 vits、edge-tts，语言模型支持ChatGPT 和 Claude。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/c121914yu/FastGPT&quot;&gt;FastGPT：基于 openai 搭建的知识库平台&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;技术栈: NextJs + TS + ChakraUI + Mongo + Postgres，支持私有化部署，可以在线体验。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/pyrustic/jesth&quot;&gt;jesth：更具可读性的数据序列化格式&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;文档将这种新格式与 TOML、YAML 和 JSON 分别做了对比，并详细展示了在 Python 中的使用方法。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/Textualize/trogon&quot;&gt;trogon：为 CLI 程序生成友好的用户界面&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;命令行程序本就是无界面的，但是这对于用户来说不够友好。这个项目可以生成美观的界面，用于编辑和运行命令。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/ipyflow/ipyflow&quot;&gt;ipyflow：用于 Jupyter 笔记本的响应式 Python 内核&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;可在交互式会话期间，跟踪符号和单元格之间的数据流关系，支持的功能：显示执行建议、支持响应式执行、语法拓展、集成了 ipywidgets，等等。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://github.com/widgetti/solara&quot;&gt;solara：一个纯 python、React-风格的框架&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;solara 可使用 Reacton（纯 Python 实现的 React）创建基于 ipywidget 的程序。可用在 Jupyter Notebook，也可以作为独立的 Web 程序在 FastAPI 等框架中使用。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://pythoninsider.blogspot.com/2023/05/python-3120-beta-1-released.html&quot;&gt;Python 3.12 的 beta 1 版本已发布&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;3.12 的最终版本计划在 10 月 2 日发布，目前发布了 beta 1 版本，意味着不会再加入新功能。总体而言，这个版本更为精简了（删除了很多函数、类和方法），性能方面也有很多优化。值得一提的是，这个版本虽然引入了 PEP-684（每个子解释器的独立 GIL），但需要等 3.13 版本实现 PEP-554（标准库中的多解释器）后，才真正的可用。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://programming-idioms.org/cheatsheet/Python/Rust&quot;&gt;对比 Python 与 Rust 的编程习惯用法&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;这是一个有意思的网站，可比较不同编程语言在 300 多项习惯用法上的区别，提升学习效率。我们这里比较了 Python 和 Rust，在网站首页可选的语言有 30 种。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.edx.org/course/cs50s-introduction-to-programming-with-python&quot;&gt;哈佛大学的 Python 编程入门课程&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;哈佛大学计算机科学专业的入门课程，向初学者介绍计算机科学和编程基础，以及如何使用 Python 进行编程。目前已有 50 万人参与学习。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://pybit.es/articles/django-plugin-recommendations-by-antonio-mele-top-10-picks-for-web-development/&quot;&gt;推荐 10 个最好用的 Django 插件&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;这期视频中，《Django by Example》书籍的作者推荐了 10 个 Django 插件，例如 Django Debug Toolbar、Django REST Framework、Django Channels，等等。&lt;/div&gt;
&lt;h2&gt;问题&amp;amp;讨论&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://tech.slashdot.org/story/23/05/23/1940217/28-years-later-windows-finally-supports-rar-files&quot;&gt;Windows 要支持 tar、7-zip、rar、gz 等格式啦？&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;来自一则匿名爆料，Windows 要利用开源项目 libarchive 实现对 rar 等格式的支持了。这会是真的么？&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.reddit.com/r/Python/comments/13nfyir/best_language_for_building_apis_tsjs_vs_py/&quot;&gt;构建 API 的最佳语言——TS/JS vs. Python&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;从可维护性、优雅性、灵活性和开发速度的角度来看，这两种语言的 API 开发体验哪种更好？&lt;/div&gt;
&lt;h2&gt;赞助&amp;amp;支持&lt;/h2&gt;
&lt;div&gt;内容创作要花费大量的时间和精力，如果你觉得有帮助，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt;、&lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！如果你喜欢本周刊，请转发分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;div&gt;另诚邀赞助者，欢迎通过私信联系。&lt;/div&gt;
&lt;h2&gt;关于周刊&lt;/h2&gt;
&lt;div&gt;Python 潮流周刊，精心筛选国内外的 200+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。&lt;/div&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python潮流周刊#2：Rust 让 Python 再次伟大</title>
            <link>https://pythoncat.top/posts/2023-05-20-weekly2/</link>
            <guid>https://pythoncat.top/posts/2023-05-20-weekly2/</guid>
            <description>精心筛选国内外的 200+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容</description>
            <pubDate>Sat, 20 May 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;这里记录每周值得分享的 Python 及通用技术内容，部分为英文，已在小标题注明。（本期标题取自其中一则分享，不代表全部内容都是该主题，特此声明。）&lt;/div&gt;
&lt;h2&gt;文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;http://coolshell.cn/articles/11265.html&quot;&gt;Python修饰器的函数式编程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了装饰器的实现原理、带参装饰器、多装饰器、类装饰器和几个典型的示例。文章发布于 2014 年，代码用的还是 Python 2。之所以分享这篇文章，因为它是&lt;a href=&quot;https://coolshell.cn/haoel&quot;&gt;左耳朵耗子&lt;/a&gt;唯一以 Python 为话题的文章，而且写得详细到位。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.cnblogs.com/traditional/p/17403428.html&quot;&gt;asyncio 的一些高级用法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;出自我们的老朋友@&lt;strong&gt;古明地觉&lt;/strong&gt; 的新系列《asyncio 系列》，半个月内已连载 14 篇。真想问问他是如何做到如此高产又高质量的？！文章回答了：如何设计既能接收协程又能接收普通 Python 函数的 API，如何强制事件循环的迭代，如何在不传递参数的情况下在任务之间传递状态……&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://segmentfault.com/a/1190000043790186&quot;&gt;Nginx+uWSGI 部署 Django 以及负载均衡操作&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;介绍了 uWSGI 和 Nginx 的配置，实现对 Django 服务的反向代理及负载均衡。该文出自仍在连载的《Django 系列》，目前该系列包含 44 篇文章，能作为系统学习 Django 的参考材料。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;http://vra.github.io/2023/05/17/rye-intro/&quot;&gt;Rye:一个实验性质的Python包管理系统&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 目前的包管理工具多得让人眼花缭乱，而 Conda 和操作系统的包管理器也存在诸多问题（本周刊第一期就有两则相关内容）。Flask 作者 Armin Ronacher 用 Rust 开发的 rye，借鉴了 Rust 包管理的经验，试图提供一个标准化的解决方案。这篇文章介绍了 rye 的安装及使用。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://juejin.cn/post/7232571353123487802&quot;&gt;PyInstaller：将你的Python代码打包成独立应用程序&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PyInstaller 可将 Python 程序打包为一个可执行文件，支持多个平台如 Windows、Mac 和 Linux。这是一篇简单清晰的使用教程，除了基础介绍外，难得的是它还介绍了两种打包方式的优缺点，以及打包后常见的 5 个问题。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://martinheinz.dev/blog/97&quot;&gt;如何在 Python 中实现真正的多线程&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;Python 3.12 即将推出“Per-Interpreter GIL（PEP-684）”特性，它允许 Python 实现真正的并行处理。代码虽然已在 alpha 版本中，但目前只能通过 C-API 使用。文章使用 CPython 的&lt;code&gt;test&lt;/code&gt; 模块演示了子解释器的示例。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://www.backblaze.com/blog/python-gil-vs-nogil-boost-i-o-performance-10x-with-one-line-change/&quot;&gt;GIL vs. nogil: 改动一行代码，提升十倍 I/O 性能&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://pythoncat.top/posts/2021-11-14-GIL&quot;&gt;nogil 项目&lt;/a&gt;是另一个试图实现真正多线程的方案，这篇文章测试发现 CPython 3.9-nogil 在单文件和多文件的情况下，比未修改的 CPython 3.9 分别快 2.5 倍和 10 倍。nogil 项目最新的进展是形成了正式的 PEP-703，相关介绍&lt;a href=&quot;https://pythoncat.top/posts/2023-02-20-GIL&quot;&gt;在此&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://blog.jetbrains.com/pycharm/2023/05/create-passphrase-generator-in-pycharm/&quot;&gt;如何在 PyCharm 中创建一个密码生成器？&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;PyCharm 官方推出的文章教程，指导在 PyCharm 中创建项目、导入包、使用 Typer 库创建 CLI 应用、运行和调试代码、创建和编辑运行配置，适合于新人学习练手。另外，&lt;a href=&quot;https://blog.jetbrains.com/pycharm/2023/05/pycharm-2023-1-2-is-out&quot;&gt;PyCharm 2023.1.2&lt;/a&gt; 版本刚刚发布，可以去尝鲜！&lt;/div&gt;
&lt;div&gt;9、&lt;a href=&quot;https://coderslegacy.com/python-metaclass-tutorial/&quot;&gt;Python 元类教程（带示例）&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;在 Python 中，一切都是对象，包括&lt;strong&gt;类&lt;/strong&gt;。元类是 Python 的一项强大功能，允许你在运行时动态地创建类（实际是创建一个&lt;code&gt;type&lt;/code&gt; 类型的对象）。文章探讨元类的基础知识，以及更高级的功能和示例。&lt;/div&gt;
&lt;div&gt;10、&lt;a href=&quot;https://www.warp.dev/blog/what-happens-when-you-open-a-terminal-and-enter-ls&quot;&gt;当在终端输入“ls”后会发生什么？&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;有一道很常见的面试题：“当在浏览器输入 google.com 后会发生什么？”由于见得多了，每个人都能回答个一二，但是，经常跟终端打交道的我们，能否回答这个问题呢：当在终端输入命令后会发生什么？文章主要介绍了终端的历史、启动过程、命令的解析和执行过程。&lt;/div&gt;
&lt;h2&gt;项目&amp;amp;资源&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/marticliment/WingetUI&quot;&gt;WingetUI：更好用的包管理器 UI&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;该项目的目标是为 Win 10-11 中最常见的 CLI 包管理器（如 Winget、Scoop 和 Chocolatey）创建一个直观的 GUI。已支持软件包的安装、更新和卸载、排队安装、消息通知、黑暗模式、导入/导出等功能。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/gventuri/pandas-ai&quot;&gt;pandas-ai：支持 AI 功能的 Pandas&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;Pandas 无疑是目前最流行的数据分析和处理工具，当它结合了生成式 AI 的能力后，会不会更好用呢？答案似乎是的！pandasai 项目支持用文字的方式操作 Pandas 的数据对象，可简化很多 Pandas 库的操作。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/Undertone0809/promptulate&quot;&gt;promptulate：一个强大的 LLM Prompt Layer 框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个专为 Prompt Engineer 设计的 LLM Prompt Layer 框架，支持连续对话、角色预设、对话存储、工具扩展等功能，可以无需代理直接访问，开箱即用。 通过 promptulate，你可以轻松构建起属于自己的 GPT 应用程序。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/micropython/micropython/releases/tag/v1.20.0&quot;&gt;MicroPython：面向微控制器和嵌入式系统的 Python&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;MicroPython 新发布了 1.20 版本，引入了一个新的轻量级包管理器，减小了代码大小，并增加了对许多新板的支持。另外，LWN 的&lt;a href=&quot;https://lwn.net/Articles/931051&quot;&gt;这篇文章&lt;/a&gt;对此版本做了介绍，文章还提到 Anaconda 有可能在 Q2 将 PyScript 的运行时从 Pyodide 替换为 MicroPython。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://github.com/csunny/DB-GPT&quot;&gt;DB-GPT：以数据库为基础的 GPT 实验项目&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用本地化的 GPT 大模型与你的数据和环境交互，无数据泄露风险，100% 私密，100% 安全。基于 FastChat 构建大模型运行环境，并提供 vicuna 作为基础的大语言模型，通过 LangChain 提供私域知识库问答能力，支持插件模式，在设计上原生支持 Auto-GPT 插件。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pythonhunter.org/episodes/ep40&quot;&gt;Ep 40. Rust 和 PyO3：让 Python 再次伟大&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;断更许久的《捕蛇者说》播客回归了！本期的嘉宾是 PyO3 项目的维护者，他的另一个身份是 wechatpy 的作者。Rust 和 PyO3 项目能放大 Python 的优势，并能改造 Python 的应用生态。我们曾推荐过性能最快的代码分析工具 &lt;a href=&quot;https://pythoncat.top/posts/2023-04-09-ruff&quot;&gt;Ruff&lt;/a&gt;，另外 Flask 作者新开发的包管理工具 &lt;a href=&quot;https://github.com/mitsuhiko/rye&quot;&gt;rye&lt;/a&gt;，它们都是 Rust 与 Python 结合的产物。（题外话：看到了捕蛇者说的三位主播发推/发博缅怀左耳朵耗子，想不到他对 Python 圈子有这么多渊源。R.I.P）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://talkpython.fm/episodes/show/415/future-of-pydantic-and-fastapi&quot;&gt;Talk Python to Me #415: Future of Pydantic and FastAPI&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;Pydantic 2.0 使用 Rust 重写了核心及顶层的代码，将对构建在其之上的库产生积极的影响，比如 FastAPI。播客邀请了 Pydantic 的 Samuel Colvin 以及 FastAPI 的 Sebastián Ramírez 一起采访，话题度很新！&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.thoughtworks.com/insights/podcasts/technology-podcasts/fluent-python-revisited&quot;&gt;再访《流畅的 Python》作者 Luciano Ramalho&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;我在上个月推荐过新上市的《流畅的 Python》中文第二版（&lt;a href=&quot;https://pythoncat.top/posts/2023-04-28-fluent&quot;&gt;链接&lt;/a&gt;），这里补充两则相关材料。这期播客来自 thoughtworks，是在《Fluent Python》英文第二版上市前的访谈，介绍了关于 Python 发展、不同语言的对比、新书的变化等。另外，他们还在 2020 年新书写作期间录了&lt;a href=&quot;https://www.thoughtworks.com/insights/podcasts/technology-podcasts/future-python&quot;&gt;一期“The future of Python”&lt;/a&gt;，两期播客都有完整的文字稿。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://youtu.be/nH4qjmP2KEE&quot;&gt;最常用的七种分布式系统模式&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;一则简短的科普视频，介绍了七种分布式系统模式：Ambassador、Circuit Breaker、CQRS、Event Sourcing、Leader Election、Publisher/Subscriber、Sharding。视频中的动画和图例都非常直观和舒适，让人赏心悦目。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;问题&amp;amp;讨论&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.v2ex.com/t/940584&quot;&gt;作为程序员，有什么提升生活/工作体验的 App、硬件、服务？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;V2ex 上的一个帖子，大家对这样的话题似乎很有发言欲。我在此最想推荐的 APP 是 Feedly 和 Substack，用于阅读 RSS 和 Newsletter。Feedly 对本周刊的素材采集帮助极大！（心愿：依靠读者的打赏，让我用上 Feedly Pro+ 的 AI 功能！）&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/mitsuhiko/rye/discussions/6&quot;&gt;rye 应该存在么？&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;前文已提到过 rye，那么，mitsuhiko 是出于什么考虑而开发了它呢？它想解决什么样的问题，想打造出一款什么样的工具呢？Python 官方对包管理会有什么发展支持呢？Github 上的这个问题引起了广泛的讨论。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.v2ex.com/t/940195&quot;&gt;你是怎样开始程序员职业生涯的？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;V2ex 上的帖子，楼主分享了自己从读书到就业前几年的故事，评论区有不少人分享了自己的经历。你是如何开始自己的程序员之路的呢？&lt;/div&gt;
&lt;h2&gt;赞助&amp;amp;支持&lt;/h2&gt;
&lt;div&gt;内容创作要花费大量的时间和精力，如果你觉得有帮助，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt;、&lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！如果你喜欢本周刊，请转发分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;div&gt;另诚邀广告主，欢迎通过私信联系。&lt;/div&gt;
&lt;h2&gt;关于周刊&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python潮流周刊#1：如何系统地自学Python？</title>
            <link>https://pythoncat.top/posts/2023-05-13-weekly1/</link>
            <guid>https://pythoncat.top/posts/2023-05-13-weekly1/</guid>
            <description>精心筛选国内外的 200+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容</description>
            <pubDate>Sat, 13 May 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;这里记录每周值得分享的 Python 及通用技术内容，部分内容为英文，已在小标题注明。（本期标题取自其中一则分享，不代表全部内容都是该主题，特此声明。）&lt;/div&gt;
&lt;h2&gt;文章&amp;amp;教程&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://pythoncat.top/posts/2023-05-08-error&quot;&gt;编程语言的错误处理模式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章讨论了编程中处理错误的四种常见方法：返回错误代码（C、Go）、异常（Java、C＃、Python、C++）、回调函数（JavaScript）和 Result 对象（Haskell、Rust、Kotlin）。对每种方法进行了分析，介绍了它们的优缺点以及使用时需要注意的地方。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/Chang-LeHung/dive-into-cpython/blob/master/obsy/03decriptor.md&quot;&gt;深入理解 Python 虚拟机：描述器实现原理与源码分析&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了描述器的实现原理，分析了 CPython 源码中描述器相关的字节码指令，并使用 Python 代码解释了描述器的执行逻辑。文章出自 Github 上的《深入理解 Python 虚拟机系列》，该系列已含 20+ 文章。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://v3u.cn/a_id_310&quot;&gt;人工智能 AI 孙燕姿模型应用实践&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;最近 AI 孙燕姿太火了！文章基于 Python3.10 和开源库 so-vits-svc（高表现力的语音合成模型）、Spleeter（人声和伴奏分离）和 FFMPEG（声音与伴奏合并），手把手演示了让 AI 孙燕姿演唱歌曲。（PS.由于担心侵权风险，so-vits-svc 项目已经归档了）&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://juejin.cn/post/7229485914219642941&quot;&gt;用 C 语言写一个 Python 包&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;文章介绍了 Python 的 C 语言 API 相关特性，最后实现了一个模仿官方 &lt;code&gt;datetime&lt;/code&gt; 的 C 扩展模块。文章出自《Python 之 C 语言 API 系列教程》的第一篇，该系列目前已更新两篇。&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://www.cnblogs.com/shanxihualu/p/17391082.html&quot;&gt;Python 工具箱系列文章&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这是一个系列文章，目前包含 31 篇文章，最近介绍的几个工具是数据库相关的：Neo4j（一个 NoSQL 图数据库，使用 Py2neo 操作）、PostgreSQL（一个关系型数据库，使用 Psycopg2 操作）、MongoDB、Access、ClickHouse、Redis 等。&lt;/div&gt;
&lt;div&gt;6、&lt;a href=&quot;https://peps.python.org/pep-0713&quot;&gt;PEP-713：可调用的模块&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;Łukasz Langa 发起的新提案，提议支持在模块的全局命名空间中定义一个__call__对象以使模块可直接调用，__call__对象可以是一个标准函数或任意可调用对象。提案目前是草稿状态，未采纳。&lt;/div&gt;
&lt;div&gt;7、&lt;a href=&quot;https://pythonspeed.com/articles/externally-managed-environment-pep-668&quot;&gt;“Externally managed environments”：当 PEP-668 影响了 pip&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;在较新 Linux 系统上使用 pip install 时可能遇到“externally managed environment”错误。原因：Linux 发行版已预装某些 Python 包，pip install 可能导致系统包冲突。解决方法：开发时用虚拟环境；Docker 里不用系统 Python；需最新工具时用 pipx。Python 包管理较为痛苦，短时间内难以改善。&lt;/div&gt;
&lt;div&gt;8、&lt;a href=&quot;https://blog.zech.codes/bevy-v2&quot;&gt;Bevy v2.0：Python 的依赖注入框架&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;Bevy v2.0 是一个强大的依赖注入框架，可以帮助简化 Python 应用程序的管理。文章介绍了三种解决依赖关系的方法：全局变量、参数传递和依赖注入。Bevy v2.0 使用的方法包括参数注入、属性注入、仓库和依赖构造函数等。&lt;/div&gt;
&lt;h2&gt;项目&amp;amp;代码&lt;/h2&gt;
&lt;div&gt;最近几个月，乘着人工智能的东风，Github 上天天都被 AI 相关的项目屠榜，相信读者们已经从各种渠道看到过那些知名的以 Python 为主的开源项目了。因此，为了不撞车，本周刊主要收录一些小而美的项目。本期以中文开发者的项目为主。&lt;/div&gt;
&lt;div&gt;1、&lt;a href=&quot;https://github.com/zixiiu/Digital_Life_Server&quot;&gt;「数字生命」的服务端&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个“有生命的”语音助手 Python 项目，支持与前端通信、语音识别、chatGPT 接入和语音合成。前端部分可渲染人物动画、录音和播放声音。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/RVC-Project/Retrieval-based-Voice-Conversion-WebUI&quot;&gt;一个基于VITS的简单易用的语音转换（变声器）框架&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;具有以下特点：使用 top1 检索替换输入源特征为训练集特征来杜绝音色泄漏；即便在相对较差的显卡上也能快速训练；使用少量数据进行训练也能得到较好结果（推荐至少收集 10 分钟低底噪语音数据）；可以通过模型融合来改变音色（借助 ckpt 处理选项卡中的 ckpt-merge）；简单易用的网页界面；可调用 UVR5 模型来快速分离人声和伴奏。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://github.com/bookfere/Ebook-Translator-Calibre-Plugin&quot;&gt;电子书翻译器（Calibre 插件）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个可以将电子书翻译成指定语言（原文译文对照）的 Calibre 插件。支持多种翻译引擎，包括 Google 翻译、ChatGPT 以及 DeepL。支持所有 Calibre 所支持的电子书格式（输入格式 48 种，输出格式 20 种）。支持批量翻译、支持缓存续译、提供大量自定义设置。&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://github.com/pikasTech/PikaPython/blob/master/README_zh.md&quot;&gt;跨平台的超轻量级嵌入式 Python 引擎&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个完全重写的超轻量级 Python 引擎，零依赖，零配置，可以在 Flash ≤ 64KB，RAM≤ 4KB 的平台下运行，极易部署和扩展，具有大量的中文文档和视频资料。&lt;/div&gt;
&lt;h2&gt;播客&amp;amp;视频&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.xiaoyuzhoufm.com/episode/6446499294d78eb3f74a01d8&quot;&gt;硬地骇客：大厂程序员构建 “小生意”，更加从容应对裁员潮&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;“每一位 hacker，每一位开发者，每一位程序员，都值得拥有一个属于自己的小生意”。这档播客已发布了几期关于独立开发者的话题，对作为程序员的我们，在技术、产品、创业等方面会有所启发。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://talkpython.fm/episodes/show/414/a-stroll-down-startup-lane&quot;&gt;Talk Python To Me #414：漫步创业之路&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;在 4 月的 PyCon 上，有一个专门展示新型 Python 创业公司的展台，叫做 Startup Row。在这期节目中，主播与这些公司的创始人分别聊了 5-10 分钟，这期节目同时包含了播客和视频。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://pythonbytes.fm/episodes/show/335/should-you-get-your-mojo-on&quot;&gt;PythonBytes #335：应该开始用 mojo 了么？&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;Mojo 是 LLVM 及 Swift 之父新开发的 AI 编程语言，号称比 Python 快 35000 倍。Mojo 已支持 Python 的许多核心特性，包括 async/await、错误处理、可变参数等等，但是它仍然处于早期阶段，缺少许多功能，比如还不支持类！&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://www.bilibili.com/video/BV14M4y147yH&quot;&gt;ChatGPT提示工程师｜AI大神吴恩达教你写提示词&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;鼎鼎大名的吴恩达联合 OpenAI，推出了一个面向开发者的 ChatGPT 提示词课程。这是 B 站上的链接，配有双语字幕。&lt;/div&gt;
&lt;h2&gt;问题&amp;amp;讨论&lt;/h2&gt;
&lt;div&gt;1、&lt;a href=&quot;https://www.zhihu.com/question/29138020&quot;&gt;如何系统地自学Python？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;知乎上的一个热门问题，已有 7.4 万人关注和 1200+ 回答。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://www.v2ex.com/t/938669#reply88&quot;&gt;[吐槽] conda 真是太难用了！ 如何优雅地管理 Python 环境？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;v2ex 上的一个帖子，吐槽使用 Conda 遇到了各种问题，包括安装后找不到命令、安装依赖卡住不动、影响系统更新等等。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://discuss.python.org/t/allow-comprehension-syntax-in-loop-header-of-for-loop/25864&quot;&gt;允许在 for 循环的循环头中使用推导式语法&lt;/a&gt;（英文）&lt;/div&gt;
&lt;div&gt;这个帖子提出了一个想法：让 Python 的 for 循环支持推导式语法“for i in x if i % 2 == 0:”。&lt;/div&gt;
&lt;h2&gt;赞助&amp;amp;支持&lt;/h2&gt;
&lt;div&gt;内容创作要花费大量的时间和精力，如果你觉得有帮助，请随意&lt;a href=&quot;https://img.pythoncat.top/wechat_code.png&quot;&gt;赞赏&lt;/a&gt;、&lt;a href=&quot;https://www.buymeacoffee.com/pythoncat&quot;&gt;买杯咖啡&lt;/a&gt; 进行支持！如果你喜欢本周刊，请转发分享给其他需要的同学，让更多人可以从中受益～&lt;/div&gt;
&lt;div&gt;另诚邀广告主，欢迎通过私信联系。&lt;/div&gt;
&lt;h2&gt;关于周刊&lt;/h2&gt;
&lt;div&gt;本周刊已持续连载一年，更新内容接近 11 万字。希望周刊能成为你高质量的信息筛选器，成为你开阔视野的一扇明窗。目前已开通付费专栏，欢迎你来订阅：&lt;a href=&quot;https://xiaobot.net/p/python_weekly&quot;&gt;https://xiaobot.net/p/python_weekly&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>对比编程语言的四种错误处理方法，哪种才是最优方案？</title>
            <link>https://pythoncat.top/posts/2023-05-08-error/</link>
            <guid>https://pythoncat.top/posts/2023-05-08-error/</guid>
            <description>文章讨论了编程中处理错误的四种常见方法：返回错误代码、异常、回调函数和 Result 对象。对每种方法进行了分析，介绍了它们的优缺点以及使用时需要注意的地方。特别是对于异常和回调，文章讨论了它们可能存在的问题，如代码可读性和回调地狱等，并提出了一些解决方案。文章总结了 Result 对象的优势，将错误信息和其他相关信息捆绑在一起，提供了一种更为灵活的错误处理方式。</description>
            <pubDate>Mon, 08 May 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;作者：&lt;a href=&quot;https://twitter.com/andreabergia&quot;&gt;Andrea Bergia&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;译者：豌豆花下猫@Python猫&lt;/div&gt;
&lt;div&gt;英文：&lt;a href=&quot;https://andreabergia.com/blog/2023/05/error-handling-patterns&quot;&gt;Error handling patterns&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;转载请保留作者及&lt;a href=&quot;https://pythoncat.top&quot;&gt;译者信息&lt;/a&gt;！&lt;/div&gt;
&lt;div&gt;错误处理是编程的一个基本要素。除非你写的是“hello world”，否则就必须处理代码中的错误。在本文中，我将讨论各种编程语言在处理错误时使用的最常见的四种方法，并分析它们的优缺点。&lt;/div&gt;
&lt;div&gt;关注不同设计方案的语法、代码可读性、演变过程、运行效率，将有助于我们写出更为优雅和健壮的代码。&lt;/div&gt;
&lt;h2&gt;返回错误代码&lt;/h2&gt;
&lt;div&gt;这是最古老的策略之一——如果一个函数可能会出错，它可以简单地返回一个错误代码——通常是负数或者&lt;code&gt;null&lt;/code&gt;。例如，C 语言中经常使用：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;FILE* fp = fopen(&quot;file.txt&quot; , &quot;w&quot;);
if (!fp) {
  // 发生了错误
}&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这种方法非常简单，既易于实现，也易于理解。它的执行效率也非常高，因为它只需要进行标准的函数调用，并返回一个值，不需要有运行时支持或分配内存。但是，它也有一些缺点：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;用户很容易忘记处理函数的错误。例如，在 C 中，printf 可能会出错，但我几乎没有见过程序检查它的返回值！&lt;/li&gt;
&lt;li&gt;如果代码必须处理多个不同的错误（打开文件，写入文件，从另一个文件读取等），那么传递错误到调用堆栈会很麻烦。&lt;/li&gt;
&lt;li&gt;除非你的编程语言支持多个返回值，否则如果必须返回一个有效值或一个错误，就很麻烦。这导致 C 和 C++ 中的许多函数必须通过指针来传递存储了“成功”返回值的地址空间，再由函数填充，类似于：&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;my_struct *success_result;
int error_code = my_function(&amp;amp;success_result);
if (!error_code) {
  // can use success_result
}&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;众所周知，Go 选择了这种方法来处理错误，而且，由于它允许一个函数返回多个值，因此这种模式变得更加人性化，并且非常常见：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;user&lt;span&gt;,&lt;/span&gt; err &lt;span&gt;=&lt;/span&gt; &lt;span&gt;FindUser&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;username&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; err &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; err
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Go 采用的方式简单而有效，会将错误传递到调用方。但是，我觉得它会造成很多重复，而且影响到了实际的业务逻辑。不过，我写的 Go 还不够多，不知道这种印象以后会不会改观！😅&lt;/div&gt;
&lt;h2&gt;异常&lt;/h2&gt;
&lt;div&gt;异常可能是最常用的错误处理模式。&lt;code&gt;try/catch/finally&lt;/code&gt; 方法相当有效，而且使用简单。异常在上世纪 90 年代到 2000 年间非常流行，被许多语言所采用（例如 Java、C＃ 和 Python）。&lt;/div&gt;
&lt;div&gt;与错误处理相比，异常具有以下优点：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;它们自然地区分了“快乐路径”和错误处理路径&lt;/li&gt;
&lt;li&gt;它们会自动从调用堆栈中冒泡出来&lt;/li&gt;
&lt;li&gt;你不会忘记处理错误！&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;然而，它们也有一些缺点：需要一些特定的运行时支持，通常会带来相当大的性能开销。&lt;/div&gt;
&lt;div&gt;此外，更重要的是，它们具有“深远”的影响——某些代码可能会抛出异常，但被调用堆栈中非常远的异常处理程序捕获，这会影响代码的可读性。&lt;/div&gt;
&lt;div&gt;此外，仅凭查看函数的签名，无法确定它是否会抛出异常。&lt;/div&gt;
&lt;div&gt;C++ 试图通过&lt;code&gt;throws&lt;/code&gt; 关键字来解决这个问题，但它很少被使用，因此在 C++ 17 中已被&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/exceptspec&quot;&gt;弃用&lt;/a&gt; ，并在 C++ 20 中被删除。此后，它一直试图引入&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/noexceptspec&quot;&gt;noexcept&lt;/a&gt; 关键字，但我较少写现代 C++，不知道它的流行程度。&lt;/div&gt;
&lt;div&gt;（译者注：throws 关键字很少使用，因为使用过于繁琐，需要在函数签名中指定抛出的异常类型，并且这种方法不能处理运行时发生的异常，有因为“未知异常”而导致程序退出的风险）&lt;/div&gt;
&lt;div&gt;Java 曾试图使用&lt;a href=&quot;https%EF%BC%9A//www.baeldung.com/java-checked-unchecked-exceptions&quot;&gt;“受检的异常（checked exceptions）”&lt;/a&gt;，即你必须将异常声明为函数签名的一部分——但是这种方法被认为是失败的，因此像 Spring 这种现代框架只使用“运行时异常”，而有些 JVM 语言（如 Kotlin）则完全&lt;a href=&quot;https://kotlinlang.org/docs/exceptions.html#the-nothing-type&quot;&gt;抛弃了这个概念&lt;/a&gt;。这造成的结果是，你根本无法确定一个函数是否会抛出什么异常，最终只得到了一片混乱。&lt;/div&gt;
&lt;div&gt;（译者注：Spring 不使用“受检的异常”，因为这需要在函数签名及调用函数中显式处理，会使得代码过于冗长而且造成不必要的耦合。使用“运行时异常”，代码间的依赖性降低了，也便于重构，但也造成了“异常源头”的混乱）&lt;/div&gt;
&lt;h2&gt;回调函数&lt;/h2&gt;
&lt;div&gt;另一种方法是在 JavaScript 领域非常常见的方法——使用&lt;a href=&quot;https://kotlinlang.org/docs/exceptions.html#the-nothing-type&quot;&gt;回调&lt;/a&gt;，回调函数会在一个函数成功或失败时调用。这通常会与异步编程结合使用，其中 I/O 操作在后台进行，不会阻塞执行流。&lt;/div&gt;
&lt;div&gt;例如，Node.JS 的 I/O 函数通常加上一个回调函数，后者使用两个参数（error，result），例如：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fs &lt;span&gt;=&lt;/span&gt; &lt;span&gt;require&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;fs&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
fs&lt;span&gt;.&lt;/span&gt;&lt;span&gt;readFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;some_file.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;err&lt;span&gt;,&lt;/span&gt; result&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;err&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    console&lt;span&gt;.&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;err&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;

  console&lt;span&gt;.&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;result&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;但是，这种方法经常会导致所谓的&lt;a href=&quot;http://callbackhell.com/&quot;&gt;“回调地狱”&lt;/a&gt;问题，因为一个回调可能需要调用其它的异步 I/O，这可能又需要更多的回调，最终导致混乱且难以跟踪的代码。&lt;/div&gt;
&lt;div&gt;现代的 JavaScript 版本试图通过引入&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/GlobalObjects/Promise&quot;&gt;promise&lt;/a&gt; 来提升代码的可读性：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;fetch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;https://example.com/profile&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
      &lt;span&gt;method&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;POST&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;// or &apos;PUT&apos;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;.&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;response&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt; response&lt;span&gt;.&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;.&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;data&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt; data&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;some_key&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;.&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;error&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt; console&lt;span&gt;.&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Error:&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; error&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;promise 模式并不是最终方案，JavaScript 最后采用了由 C＃推广开的 async/await 模式，它使异步 I/O 看起来非常像带有经典异常的同步代码：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; &lt;span&gt;fetchData&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  &lt;span&gt;try&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt; response &lt;span&gt;=&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; &lt;span&gt;fetch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;my-url&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;response&lt;span&gt;.&lt;/span&gt;ok&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Network response was not OK&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; response&lt;span&gt;.&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;some_property&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;error&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    console&lt;span&gt;.&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;There has been a problem with your fetch operation:&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; error&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;使用回调进行错误处理是一种值得了解的重要模式，不仅仅在 JavaScript 中如此，人们在 C 语言中也使用了很多年。但是，它现在已经不太常见了，你很可能会用的是某种形式的async/await。&lt;/div&gt;
&lt;h2&gt;函数式语言的 Result&lt;/h2&gt;
&lt;div&gt;我最后想要讨论的一种模式起源于函数式语言，比如 &lt;a href=&quot;https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Either.html&quot;&gt;Haskell&lt;/a&gt;，但是由于 &lt;a href=&quot;https://andreabergia.com/blog/2022/11/languages-opinion-part-two-rust/&quot;&gt;Rust&lt;/a&gt; 的流行，它已经变得非常主流了。&lt;/div&gt;
&lt;div&gt;它的创意是提供一个&lt;code&gt;Result&lt;/code&gt;类型，例如：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; &lt;span&gt;Result&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  &lt;span&gt;Ok&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
  &lt;span&gt;Err&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这是一个具有两种结果的类型，一种表示成功，另一种表示失败。返回结果的函数要么返回一个&lt;code&gt;Ok&lt;/code&gt; 对象（可能包含有一些数据），要么返回一个&lt;code&gt;Err&lt;/code&gt; 对象（包含一些错误详情）。函数的调用者通常会使用模式匹配来处理这两种情况。&lt;/div&gt;
&lt;div&gt;为了在调用堆栈中抛出错误，通常会编写如下的代码：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;match&lt;/span&gt; &lt;span&gt;my_fallible_function&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  &lt;span&gt;Err&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Err&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;e&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
  &lt;span&gt;Ok&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;some_data&lt;span&gt;)&lt;/span&gt; &lt;span&gt;=&amp;gt;&lt;/span&gt; some_data&lt;span&gt;,&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;由于这种模式非常常见，Rust 专门引入了一个操作符（即问号 &lt;code&gt;?&lt;/code&gt;） 来简化上面的代码：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;my_fallible_function&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;   &lt;span&gt;// 注意有个&quot;?&quot;号&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这种方法的优点是它使错误处理既明显又类型安全，因为编译器会确保处理每个可能的结果。&lt;/div&gt;
&lt;div&gt;在支持这种模式的编程语言中，Result 通常是一个 &lt;a href=&quot;https://en.wikipedia.org/wiki/Monad(functionalprogramming)&quot;&gt;monad&lt;/a&gt;，它允许将可能失败的函数组合起来，而无需使用 try/catch 块或嵌套的 if 语句。&lt;/div&gt;
&lt;div&gt;（译者注：函数式编程认为函数的输入和输出应该是纯粹的，不应该有任何副作用或状态变化。monad 是一个函数式编程的概念，它通过隔离副作用和状态来提高代码的可读性和可维护性，并允许组合多个操作来构建更复杂的操作）&lt;/div&gt;
&lt;div&gt;根据你使用的编程语言和项目，你可能主要或仅仅使用其中一种错误处理的模式。&lt;/div&gt;
&lt;div&gt;不过，我最喜欢的还是 Result 模式。当然，不仅是函数式语言采用了它，例如，在我的雇主 &lt;a href=&quot;https://lastminute.com/&quot;&gt;lastminute.com&lt;/a&gt; 中，我们在 Kotlin 中使用了 &lt;a href=&quot;https://arrow-kt.io/&quot;&gt;Arrow&lt;/a&gt; 库，它包含一个受 Haskell 强烈影响的类型&lt;code&gt;Either&lt;/code&gt;。我有计划写一篇关于它的文章，最后感谢你阅读这篇文章，敬请保持关注😊。&lt;/div&gt;
&lt;div&gt;译注：还有一篇《&lt;a href=&quot;https://www.amazingcto.com/best-way-to-handle-errors-for-a-programming-language/&quot;&gt;Musings about error handling mechanisms in programming languages&lt;/a&gt;》文章，同样分析了不同编程语言在错误处理时的方案。它还介绍了 Zig 编程语言的做法、Go 语言的 defer 关键字等内容，可以丰富大家对这个话题的理解，推荐一读。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>《流畅的Python》第二版上市了，值得入手么？</title>
            <link>https://pythoncat.top/posts/2023-04-28-fluent/</link>
            <guid>https://pythoncat.top/posts/2023-04-28-fluent/</guid>
            <description>这本属于是必推好书！本文详细梳理了第二版新增的内容，可以作为购买参考</description>
            <pubDate>Fri, 28 Apr 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;《Fluent Python》第一版在 2015 年出版，简体中文版《流畅的Python》在 2017 年出版。从那时起，它就成为了所有 Python 程序员的必读之书。如果一份面向中高级 Python 开发者的书单里不包含这本书，那这份书单肯定不合格！&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;《Fluent Python》第二版在 2022 年出版，最近，简体中文版《流畅的Python》也隆重上市了！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;在收到出版社的赠书后，我发了一条朋友圈，收到了很多点赞，以及咨询最多的两个问题：&lt;strong&gt;新书相比于旧版，有什么区别？我是新手，这本书适合我么？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;本文将给大家解答这两个问题，另外在文末有赠书福利（&lt;strong&gt;送 10 本书&lt;/strong&gt;），请不要错过哦~&lt;/div&gt;
&lt;h2&gt;这本书适合哪些读者？&lt;/h2&gt;
&lt;div&gt;如果你是零基础的 Python 新手，那么这本书不适合你，因为这本书“&lt;strong&gt;深入剖析 Python 语言核心特性及底层逻辑&lt;/strong&gt;”，你可能会感觉它深奥超纲。&lt;/div&gt;
&lt;div&gt;如果你是零基础的初学者，那么我推荐你阅读《Python编程：从入门到实践》、《看漫画学Python》这样的入门书籍。但是，在划走之前，请你一定要收藏本文，因为 Python 入门简单，相信你很快就会需要一本指导进阶的书籍了。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;除了以上的读者群体外，《流畅的Python》适合于所有 Python 开发者/爱好者，特别地，如果你怀有以下的想法，那么这本书绝对是不二之选：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;想要更加熟练地掌握 Python&lt;/li&gt;
&lt;li&gt;想要了解实用的编程技巧&lt;/li&gt;
&lt;li&gt;想写出地道、优雅、高效的 Python 代码&lt;/li&gt;
&lt;li&gt;想要掌握 Python 最新的语言特性&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;我在两年前写过一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/A4_DD2fvceNk1apn9MQcXA&quot;&gt;如果只推荐一本 Python 书，我要 Pick 它！&lt;/a&gt;》，强烈推荐了第一版书籍，你可以从该文看到第一版主要内容的思维导图，以及我的推荐介绍。&lt;/div&gt;
&lt;div&gt;如果你没听说过《流畅的Python》，或者没读过第一版的书，我建议你先读一下那篇文章。&lt;/div&gt;
&lt;div&gt;在本文中，我主要面向已经了解过这本书的读者，回答大家最为关切的两个疑问：&lt;strong&gt;已经读过第一版了，是否还有必要读第二版呢？已经拥有了第一版书籍（不管实体书还是电子书），是否值得再买入第二版呢？&lt;/strong&gt;&lt;/div&gt;
&lt;h2&gt;这本书新增了什么内容？&lt;/h2&gt;
&lt;div&gt;《流畅的Python》作者 Luciano Ramalho 是 Python 软件基金会成员，他深度参与了各类社区活动，熟知大量语言特性的设计过程和差异，他的书具有&lt;strong&gt;内容全面而新潮&lt;/strong&gt;的特点。在第一版写作完成时，Python 3.5 版本还没发布，但是书中已包含了大量 3.5 版本的内容。&lt;/div&gt;
&lt;div&gt;第一版英文书籍发布于 2015 年，那时社区中仍有较多 Python 2 用户因循守旧，因此作者的附加意图之一就是展现 Python 3 的魅力，引导老用户们进行迁移。&lt;/div&gt;
&lt;div&gt;在随后 7、8 年时间里，Python 社区中发生了很多重大事件：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;2015 年，PEP-484 被引入到 Python 3.5 版本，类型提示开始迅猛发展&lt;/li&gt;
&lt;li&gt;2015 年以来，asyncio 引入了很多新特性，异步编程越来越好用&lt;/li&gt;
&lt;li&gt;2015 年 TensorFlow 发布，2016 年 PyTorch 发布，2017 年 AlphaGo 击败人类世界围棋冠军。2022 年 ChatGPT 发布，各种 AI 模型和应用变得数不胜数&lt;/li&gt;
&lt;li&gt;2018 年，Python 之父 Guido van Rossum 卸任“独裁者”，社区开始“指导委员会”治理模式&lt;/li&gt;
&lt;li&gt;2020 年，Python 2 彻底停止维护&lt;/li&gt;
&lt;li&gt;2023 年，PEP-684 被采纳，&lt;a href=&quot;https://mp.weixin.qq.com/s/HHSjv0ZlAjq0ZvLHMI-W9g&quot;&gt;PEP-703 也有希望被采纳&lt;/a&gt;，GIL 将迎来重大变革……&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;第二版书籍从 2020 年初开始写作，他这次已不用特意考虑 Python 2 用户了，重点是让读者熟悉 Python 新的功能特性。&lt;/div&gt;
&lt;div&gt;英文第二版的上市时间比 Python 3.10.0 的发布时间早了好几个月，但是，书中的示例已基于 3.10 测试过，不仅有大量 3.10 版本的内容，还涉及一些 3.11 版本的变化。&lt;/div&gt;
&lt;div&gt;为了凸显出两个版本的差异，这本书每一章的第一节都会介绍“本章新增内容”。得益于作者梳理出的线索，我整理出了一份新增特性的清单（仅为简化版，详细内容请以书本为准）：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;3.5 版本：原生协程、矩阵乘法运算&lt;/li&gt;
&lt;li&gt;3.6 版本：f-string 语法、collections.abc.Collection 抽象基类、异步生成器&lt;/li&gt;
&lt;li&gt;3.7 版本：dict 插入有序、@dataclass 装饰器、contextlib 模块新增的几个函数、http.server 的多线程服务器&lt;/li&gt;
&lt;li&gt;3.8 版本：仅限位置参数、异步的 REPL、@functools.cached_property、海象运算符（:=）&lt;/li&gt;
&lt;li&gt;3.9 版本：&lt;code&gt;|&lt;/code&gt; 和 &lt;code&gt;|=&lt;/code&gt; 运算符、缓存装饰器 functools.cache、泛化类型提示&lt;/li&gt;
&lt;li&gt;3.10 版本：模式匹配语法（match-case）、zip() 函数的新功能、带括号的上下文管理器&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;以上罗列的内容都是各个版本的新特性，表明了这本书紧跟着语言的发展趋势。&lt;/div&gt;
&lt;div&gt;除此之外，书中还增加了大量的内容或修改，比如：新增了很多图表、说明框、示例代码和延伸阅读材料；介绍 dict 与 OrderDict 之间的差异、介绍字典的视图对象、super() 函数是如何支持协作多重继承的、如何避免使用继承、使用 HTTPX 库、新增 FastAPI Web 服务示例、使用元类时的注意事项……&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;以上提到的新内容和修改点，主要都分散在第一版原有的内容里。另外，对于一些重点话题，作者在第二版里增加了大量的篇幅，比如新增两章内容重点介绍类型提示（《第8章 函数中的类型提示》、《第15章 类型提示进阶》）、增加大量并发编程内容（新增一章《第19章 Python并发模型》、新增 asyncio 异步编程内容）……&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;在翻阅新书的时候，我还注意到了几个值得一提的章节（都是第一版没有的内容）：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;第 13 章对四种类型的划分讨论（鸭子类型、大鹅类型、静态鸭子类型、静态类型），不再是常规的类型分类角度（即动态类型、静态类型、强类型、弱类型），而是将类型提示以及抽象基类整合进来，作者画的图例让我感觉耳目一新&lt;/li&gt;
&lt;li&gt;第 2.6 节不仅介绍了最新的模式匹配（match-case）语法，还用它重构了一个解释器 lis.py 代码。然后到了第 18.3 节，作者又进一步分析 lis.py 的整体机制，试图让我们感受到“地道的 Python 代码体现的编程美感”，通过介绍 Scheme 句法，让 Python 开发者感受“简单的语言设计哲学如何让 Scheme 成为大师级作品”&lt;/li&gt;
&lt;li&gt;第 21.9.1 节使用 FastAPI 框架实现 Web 服务，舍弃了第一版中用到的 aiohttp，这为近几年已十分流行的 FastAPI 又助力推了一把&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;《流畅的 Python》的内容十分庞博，信息密度极高，作者是个&lt;strong&gt;绝对的细节控和整理大师&lt;/strong&gt;。在主体的文本外，那些密集的提示框、注释、延伸阅读和杂谈，在知识广度和深度上让人叹为观止。&lt;/div&gt;
&lt;div&gt;第二版除了新增大量内容外，还调整了很多原有章节的次序，图灵教育整理了全书的思维导图如下：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;总体而言，第二版的变化之大超出了我的预期，值得我们暂时忘记第一版，然后把它当做一本全新的书仔细研读。购入实体书也很有必要，因为很多章节彼此关联，实体书比较便于查找目标章节，也便于阅读完整的上下文信息。&lt;/div&gt;
&lt;div&gt;本文首发于 Python猫 &lt;a href=&quot;https://pythoncat.top/posts/2023-04-28-fluent&quot;&gt;《流畅的Python》第二版怎么样？&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;其它的变化&lt;/h2&gt;
&lt;div&gt;在解答完大家最为关切的问题后，我还想补充几点。&lt;/div&gt;
&lt;div&gt;首先是关于印刷，第二版分成了上下两册，用纸也更为讲究，比第一版轻薄许多，对比沉甸甸的第一版，我个人感觉新版的阅读体验提升了不少。&lt;/div&gt;
&lt;div&gt;其次是关于翻译，第二版修改了旧版翻译不到位或不准确的很多内容。比如，第一版将“Goose typing”翻译成“白鹅类型”，第二版修改成了“大鹅类型”；第一版将“Boolean Value of a Custom Type”错误译成了“自定义的布尔值”，第二版修正为“自定义类型的布尔值”；第一版将“When a List Is Not the Answer”译成“当列表不是首选时”，第二版修改成“当列表不适用时”……&lt;/div&gt;
&lt;div&gt;“goose”是“鹅”，为了跟“鸭子类型”对照，最好翻译成两个字，但鹅不一定是白色，却普遍体型大于鸭子，因此我觉得改成“大鹅类型”是贴切的。另外两个例子出自前两章的小标题，比较显眼易见，书中还有不少翻译调整之处，就不一一列举了。&lt;/div&gt;
&lt;div&gt;最后很值得关注的是，作者在创作第二版时，为新书搭建了一个&lt;a href=&quot;https://www.fluentpython.com&quot;&gt;网站&lt;/a&gt;，里面已收录了多篇没有写到书中的文章，可以作为辅助材料。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;网站文章目前包括：经典的协程（高能预警：这篇特别长，是对书中第 17.13 章的强力补充）、使用 &lt;code&gt;bisect&lt;/code&gt; 处理有序序列、 集合与字典的内部实现、对象的弱引用，等等。&lt;/div&gt;
&lt;h2&gt;福利环节&lt;/h2&gt;
&lt;div&gt;本次赠书共 &lt;strong&gt;10&lt;/strong&gt; 本，有效期至 5 月 2 日 12 点。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;抽奖送书（5本）&lt;/strong&gt;：给公众号【&lt;strong&gt;Python猫&lt;/strong&gt;】发送数字“&lt;strong&gt;0428&lt;/strong&gt;”，获取抽奖二维码后参与。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;评论送书（5本）&lt;/strong&gt;：有两种评论方式，任选其一即可。方式1，从公众号里加猫哥为好友后，在朋友圈评论“你想获得赠书的理由”；方式2，将本文转发到你的社交圈之一（朋友圈或技术群或头条号或微博或其它交流平台），写上你对本书的评论/推荐语，然后发截图给我。&lt;/div&gt;
&lt;div&gt;抽奖送书，各凭运气；评论送书，我会择优录用，奖品不叠加。若有弃奖，则奖品在微信读者群内抽奖送出。最后，感谢图灵出版社对本次活动的赞助。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>性能最快的代码分析工具，Ruff 正在席卷 Python 圈！</title>
            <link>https://pythoncat.top/posts/2023-04-09-ruff/</link>
            <guid>https://pythoncat.top/posts/2023-04-09-ruff/</guid>
            <description>Ruff 为什么能吸引大量的开源项目使用？相比于其它代码分析工具，它有哪些突出之处，是否还有一些局限性？现在是否值得将项目在用的工具都替换成它呢？</description>
            <pubDate>Sun, 09 Apr 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;几天前，Python 开源社区又出了一个不小的新闻：HTTPX 和 Starlette 在同一天将在用的代码分析工具（flake8、autoflake 和 isort）统一替换成了 Ruff。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/encode/httpx&quot;&gt;HTTPX&lt;/a&gt; 是一个支持异步的 HTTP 客户端，&lt;a href=&quot;https://github.com/encode/starlette&quot;&gt;Starlette&lt;/a&gt; 是一个轻量级的 ASGI 框架，它们都是 Python 社区里的明星项目，目前加起来有近 20K star。它们都选择了使用 Ruff，再次扩大了 Ruff 的应用版图。&lt;/div&gt;
&lt;div&gt;Ruff 是个诞生仅仅 8 个月的新兴项目，但已呈现出一种席卷 Python 社区的趋势！很多知名的开源项目已采纳 Ruff，比如 Transformers、Pandas、FastAPI、Airflow、SciPy、Bokeh、Jupyter、LangChain、PaddlePaddle、Sphinx、Pydantic、LlamaIndex……&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/charliermarsh/ruff&quot;&gt;Ruff&lt;/a&gt; 是什么？为什么它能吸引大量的开源项目使用？相比于其它代码分析工具，它有哪些突出之处，是否还有一些局限性？现在是否值得将项目在用的工具都替换成它呢？&lt;/div&gt;
&lt;div&gt;带着这些问题，本文将带你全方位了解这个火爆的项目。&lt;/div&gt;
&lt;h2&gt;Ruff 加速 Rust 与 Python 的融合&lt;/h2&gt;
&lt;div&gt;Ruff 诞生于 2022 年 8 月，它是一个用 Rust 语言编写的高性能的 Python 静态代码分析工具，比其它分析工具快几个数量级（10-100 倍），而且功能也很全面。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;代码分析工具&lt;/code&gt; 即 Linter，用于检查代码中的语法错误、编码规范问题、潜在的逻辑问题和代码质量问题等，可以提供实时反馈和自动修复建议。&lt;/div&gt;
&lt;div&gt;在 Ruff 出现之前，社区里的代码分析工具呈现出百花齐放之势，比如有 Pylint、Flake8、Autoflake、Pyflakes、Pycodestyle 等等，它们的共同点是都使用 Python 编写而成。&lt;/div&gt;
&lt;div&gt;Ruff 异军突起，在性能方面立于不败之地，主要得益于 Rust 天然的速度优势。Ruff 的出现，就像基于大语言模型的 ChatGPT 横空出世，所有竞争对手瞬间就黯淡失色了。&lt;/div&gt;
&lt;div&gt;两个月前，我翻译了一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/_qcUu-PzjUtmX0uktZbNQw&quot;&gt;Python 2023 年的 3 个趋势&lt;/a&gt;》，它预测的第一个趋势就是 Rust 将加快融入到 Python 相关的项目和工具中，举出的例子就有 Ruff。&lt;/div&gt;
&lt;div&gt;我现在可以补充一个观察了：&lt;strong&gt;用 Rust 开发的新工具将淘汰用其它语言开发的工具，而且新工具的普及速度可能比你的预想快得多！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;Ruff 项目的成功，将刺激出更多 Python+Rust 的项目。它的作者 &lt;a href=&quot;https://github.com/charliermarsh/&quot;&gt;Charlie Marsh&lt;/a&gt; 立志于给 Python 构建高性能的开发工具，巧合的是我曾翻译过他写的《&lt;a href=&quot;https://mp.weixin.qq.com/s/4lehHrznHL5Yt52Mmbi17Q&quot;&gt;Using Mypy in production at Spring&lt;/a&gt;》，这篇文章恰好发布于 Ruff 诞生的 2022 年 8 月！&lt;/div&gt;
&lt;div&gt;因此，我有理由推测：在 Ruff 项目成熟后，他将用 Rust 开发高性能的 Python 类型检查工具，到时候，目前流行的 Mypy、Pytype、Pyright 和 Pyre 等工具将迎来一大劲敌。（题外话：Python 社区纷乱繁多的虚拟环境管理工具和依赖包管理工具，也有望迎来变革了吧！）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这里还必须介绍两个 Rust 项目，因为 Ruff 的成功离不开它们：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/RustPython/RustPython&quot;&gt;RustPython&lt;/a&gt; ：用 Rust 写成的 Python 解释器。Ruff 利用了它高性能的 AST 解析器，以此实现了自己的 AST 遍历、访问器抽象和代码质量检测逻辑&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/PyO3/maturin&quot;&gt;Maturin&lt;/a&gt; ：用 Rust 写成的打包工具，可以将 Rust 项目打包成 Python 可用的包，从而可以被我们“pip install”后使用，且不需要配置 Rust 环境&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Ruff 的优点与局限性&lt;/h2&gt;
&lt;div&gt;介绍完最关键的特性后（速度极快、支持 pip），我们接下来看看 Ruff 的其它方面。&lt;/div&gt;
&lt;div&gt;总体而言，它具有这些特点：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;支持 &lt;code&gt;pyproject.toml&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;兼容 Python 3.11&lt;/li&gt;
&lt;li&gt;超过 &lt;a href=&quot;https://beta.ruff.rs/docs/rules/&quot;&gt;500 条内置规则&lt;/a&gt;，与 Flake8 内置的规则集近乎对等&lt;/li&gt;
&lt;li&gt;重新实现了数十个 Flake8 插件，如 flake8-bugbear、flake8-comprehensions 等&lt;/li&gt;
&lt;li&gt;支持自动修复，可自动纠正错误（例如，删除未使用的导入）&lt;/li&gt;
&lt;li&gt;内置缓存，可避免重复分析未更改的文件&lt;/li&gt;
&lt;li&gt;支持 VS Code、Pycharm、Neovim、Sublime Text、Emacs 等编辑器&lt;/li&gt;
&lt;li&gt;对 monorepo 友好，具有分层和级联配置&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;首先最值得介绍的是它支持的规则。Ruff 借鉴了流行的工具如 Flake8、autoflake、isort、pyupgrade、yesqa 等等，然后用 Rust 重新实现了超过 500 条规则。它本身不支持插件，但是吸收了数十个常用的 Flake8 插件的设计，使得已囊括的规则范围比其它任何工具都大。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Ruff 的作者还非常熟悉其它语言的分析工具，比如 Rust 的 Clippy 和 JavaScript 的 ESLint，并从这些项目上得到了设计上的启发。&lt;/div&gt;
&lt;div&gt;Ruff 站在了多个工具/插件的肩膀上，重新实现了它们验证过的规则，也借鉴了它们的 API 和实现细节，这使得它扮演了一种“集大成”的角色，很方便使用者们作工具的顺滑迁移。&lt;/div&gt;
&lt;div&gt;Ruff 第二个值得介绍的特点是，它没有局限于 Linter 的定位，而是借鉴 Rome、Prettier 和 Black 这些代码格式化工具（Formatter），也实现了代码格式化的功能。借鉴了 Autoflake、ESLint、Fixit 等工具，实现了代码自动纠错的功能。另外，它还借鉴了使用很广泛的 isort，支持对 import 作快速排序。&lt;/div&gt;
&lt;div&gt;这些表明作者的目标并不只是开发一款优秀的代码分析工具，而是在静态代码分析的核心功能外，要创造出更多的可能性。此举是开发者的福音啊，以后一个工具就能满足多种诉求，再也不必纠结于不同工具的选型、协作与维护了！&lt;/div&gt;
&lt;div&gt;Ruff 还有其它的优点，例如支持 &lt;code&gt;pyproject.toml&lt;/code&gt; 、支持 Python 3.11、支持只分析变更的文件，等等。另外，它也有着一些局限性：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;支持的 lint 规则还有不够&lt;/li&gt;
&lt;li&gt;不支持使用插件，扩展性不强&lt;/li&gt;
&lt;li&gt;用 Rust 开发的，因此不便于在出错时 debug，也不便于 Python 开发者给它贡献代码&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;关于第一点，毕竟 Ruff 只是 8 个月大的新生项目，支持更多的规则，只是时间问题。至于插件带来的扩展性和编程语言的开发者生态，原因也是 Rust，属于“有得必有失”了。&lt;/div&gt;
&lt;h2&gt;Ruff 的使用&lt;/h2&gt;
&lt;div&gt;介绍完 Ruff 的整体情况后，我们接着看看该如何使用它吧。&lt;/div&gt;
&lt;div&gt;首先是安装，可以用 Conda 和其它包管理工具，也可以直接用 pip：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;pip install ruff&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;可以通过以下命令运行：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;ruff check &lt;span&gt;.&lt;/span&gt;                        &lt;span&gt;# 分析当前及子目录内的所有文件&lt;/span&gt;
ruff check path&lt;span&gt;/&lt;/span&gt;to&lt;span&gt;/&lt;/span&gt;code&lt;span&gt;/&lt;/span&gt;            &lt;span&gt;# 分析指定目录及子目录内的所有文件&lt;/span&gt;
ruff check path&lt;span&gt;/&lt;/span&gt;to&lt;span&gt;/&lt;/span&gt;code&lt;span&gt;/&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;py        &lt;span&gt;# 分析指定目录内的所有py文件&lt;/span&gt;
ruff check path&lt;span&gt;/&lt;/span&gt;to&lt;span&gt;/&lt;/span&gt;code&lt;span&gt;/&lt;/span&gt;to&lt;span&gt;/&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;py  &lt;span&gt;# 分析 file.py&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;可以用作预提交的钩子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;-&lt;/span&gt; repo&lt;span&gt;:&lt;/span&gt; https&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;github&lt;span&gt;.&lt;/span&gt;com&lt;span&gt;/&lt;/span&gt;charliermarsh&lt;span&gt;/&lt;/span&gt;ruff&lt;span&gt;-&lt;/span&gt;pre&lt;span&gt;-&lt;/span&gt;commit
  &lt;span&gt;# Ruff version.&lt;/span&gt;
  rev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;v0.0.261&apos;&lt;/span&gt;
  hooks&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; ruff&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;可以通过 &lt;code&gt;pyproject.toml&lt;/code&gt; ，&lt;code&gt;ruff.toml&lt;/code&gt; 或 &lt;code&gt;.ruff.toml&lt;/code&gt; 文件进行配置，默认配置已能满足基本使用，详细配置可以参见文档的 &lt;a href=&quot;https://beta.ruff.rs/docs/configuration/&quot;&gt;Configuration&lt;/a&gt; 。&lt;/div&gt;
&lt;div&gt;Ruff 提供了官方的 VS Code 插件，可以快速上手：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Ruff 官方没有提供 Pycharm 的插件，社区中有人发布了一个 Ruff 插件。&lt;/div&gt;
&lt;div&gt;另外，它还提供了&lt;a href=&quot;https://github.com/charliermarsh/ruff-lsp&quot;&gt;&lt;code&gt;ruff-lsp&lt;/code&gt;&lt;/a&gt; ，可以被集成到任何支持 Language Server Protocol 的编辑器中，例如 Neovim、Sublime Text、Emacs 等等。&lt;/div&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;div&gt;本文从 HTTPX 和 Starlette 采纳 Ruff 的新闻开始，向读者介绍了这个仅诞生 8 个月却俘获了一大批知名开源项目。它最突出的特点是使用 Rust 开发，因此在性能方面远远超越同类工具，此外，它借鉴了众多工具和插件的设计，不仅静态代码分析的规则全面，而且还具备代码格式化、代码自动纠错和 import 排序等非其它 linter 所拥有的功能。&lt;/div&gt;
&lt;div&gt;Ruff 的成功为 Python 社区提供了一个鲜活的榜样，可以预见，我们将迎来一波用 Rust 开发的高性能工具。Ruff 的成功，与最近火爆的 ChatGPT 一样，它们传递出了一个“&lt;strong&gt;这事儿能成&lt;/strong&gt;”的信号，从而会引爆一场使用新技术的变革！（非常巧合的是：Rust 1.0 在 2015 年 5 月发布，而 OpenAI 在 2015 年 12 月成立。）&lt;/div&gt;
&lt;div&gt;总体而言，Ruff 非常强大，凭实力而风靡 Python 社区，绝对推荐使用！它的&lt;a href=&quot;https://beta.ruff.rs/docs/&quot;&gt;使用文档&lt;/a&gt;很友好，如果你想了解更多细节，可以去翻查。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Why don&apos;t Python, Go and Rust have a ternary conditional operator?</title>
            <link>https://pythoncat.top/posts/2023-04-04-condition-en/</link>
            <guid>https://pythoncat.top/posts/2023-04-04-condition-en/</guid>
            <description>understanding the rationale, history and philosophy behind language design can enhance our programming skills and lead to clearer and more creative thinking</description>
            <pubDate>Tue, 04 Apr 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;Hello readers! This article is written by a Chinese author named &lt;a href=&quot;https://pythoncat.top/about&quot;&gt;豌豆花下猫&lt;/a&gt;, who is writing his first English article with the super help of ChatGPT. I hope that this article will provide valuable insights for developers interested in language design.（另致中文读者：这篇英文是在 ChatGPT 辅助下翻译而成的，为了保证阅读体验，我建议你&lt;a href=&quot;https://pythoncat.top/posts/2023-04-03-condition&quot;&gt;阅读原版&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;The ternary operator is a common syntax shortcut used in many programming languages to simplify conditional logic by allowing developers to execute different blocks of code based on specific conditions. However, Python, as well as two emerging popular languages, Go and Rust, do not have a ternary conditional operator.&lt;/div&gt;
&lt;div&gt;In this article, we will analyze the process of Python designing its conditional expression syntax and explain why it adopted its current unique implementation. We will also examine why other languages have abandoned ternary traditional operator.&lt;/div&gt;
&lt;div&gt;It is worth noting that, like most articles in the ”&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;Python Whydo&lt;/a&gt;” series, this article focuses on a seemingly small syntax point. However, understanding the rationale, history and philosophy behind language design can enhance our programming skills and lead to clearer and more creative thinking.&lt;/div&gt;
&lt;h2&gt;What is the ternary operator?&lt;/h2&gt;
&lt;div&gt;Ternary operator commonly represented as “?:”, is a syntax shortcut that simplify conditional logic by allowing developers to execute different blocks of code based on specific conditions. The syntax takes the form of &lt;code&gt;condition ? expression1 : expression2&lt;/code&gt;, where &lt;code&gt;expression1&lt;/code&gt; is taken if &lt;code&gt;condition&lt;/code&gt; is true, and &lt;code&gt;expression2&lt;/code&gt; is taken if &lt;code&gt;condition&lt;/code&gt; is false.&lt;/div&gt;
&lt;div&gt;The simplified syntax form of &lt;code&gt;a ? b : c&lt;/code&gt; can be read as “if the condition &lt;code&gt;a&lt;/code&gt; is true, then &lt;code&gt;b&lt;/code&gt; is returned; otherwise, &lt;code&gt;c&lt;/code&gt; is returned.”&lt;/div&gt;
&lt;div&gt;Ternary operator serves as a shorthand for the common if-else structure, and is frequently used to perform conditional checks and value assignments in a single statement.&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;// use if-else 
if (a &amp;gt; b) {
    result = x;
} else {
    result = y;
}

// use the ternary operator
result = a &amp;gt; b ? x : y;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;There are many programming languages that have adopted this syntax, including C, C#, C++, Java, JavaScript, PHP, Perl, Ruby, Swift, and many others. Undoubtedly, it is the mainstream design solution in the programming language community and remains so to this day.&lt;/div&gt;
&lt;div&gt;This syntax is highly concise and efficient and has strong code readability (if you are not encountering it for the first time), making it a favorite of many developers.&lt;/div&gt;
&lt;div&gt;However, it is not without its drawbacks. Python is the most famous challenger to this syntax design, and in the following section, we will explore why Python has taken a different approach.&lt;/div&gt;
&lt;h2&gt;Vote from the Python community&lt;/h2&gt;
&lt;div&gt;Python was first released in 1991, but for the next 15 years, apart from the if-else syntax, it did not support ternary operator or any other conditional expression. Even after the introduction of conditional expression in 2006, there was a long and winding debate within the community, making it a highly challenging syntax to design.&lt;/div&gt;
&lt;div&gt;In February 2003,  &lt;a href=&quot;https://peps.python.org/pep-0308&quot;&gt;PEP 308 - Conditional Expressions&lt;/a&gt; was proposed in response to frequent requests for the addition of if-then-else (ternary) expressions. The goal was to choose a solution that would be widely supported by the community.&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Soon, several proposals emerged within the community, with only a few people preferring to do nothing.&lt;/div&gt;
&lt;div&gt;One proposal was to use punctuation to construct ternary operator, which is the same as the syntax introduced earlier:&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;condition&amp;gt; ? &amp;lt;expression1&amp;gt; : &amp;lt;expression2&amp;gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;This proposal received significant support, and Eric Raymond even implemented this. However, Guido gave two reasons for his opposition: the colon already has many uses in Python (even though it would actually not be ambiguous, because the question mark requires a matching colon); for people not used to C-derived language, it is hard to understand.&lt;/div&gt;
&lt;div&gt;Another proposal suggested using a combination of existing and new keywords by introducing a new ‘then’ keyword in conjunction with the existing ‘else’ keyword:&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;condition&amp;gt; then &amp;lt;expression1&amp;gt; else &amp;lt;expression2&amp;gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;This proposal offers several benefits, such as readability, no need for parentheses, no impact on the meaning of existing keywords, lower risk of confusion with statement syntax, and avoidance of additional burden on the colon operator. However, a drawback is that it entails implementation costs associated with introducing a new keyword.&lt;/div&gt;
&lt;div&gt;There were other proposals that were similar to the previous one in concept, but did not receive as much support as the first two proposals.&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;(if &amp;lt;condition&amp;gt;: &amp;lt;expression1&amp;gt; else: &amp;lt;expression2&amp;gt;)
&amp;lt;condition&amp;gt; and &amp;lt;expression1&amp;gt; else &amp;lt;expression2&amp;gt;
&amp;lt;expression1&amp;gt; if &amp;lt;condition&amp;gt; else &amp;lt;expression2&amp;gt;
cond(&amp;lt;condition&amp;gt;, &amp;lt;expression1&amp;gt;, &amp;lt;expression2&amp;gt;)&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;It’s worth mentioning &lt;code&gt;(if &amp;lt;condition&amp;gt;: &amp;lt;expression1&amp;gt; else: &amp;lt;expression2&amp;gt;)&lt;/code&gt;, which is a flattened version of the conventional if-else syntax that is easy to understand. However, the downside is that it requires parentheses, which can be confused with generator expressions, and requires special treatment of the colon by the interpreter.&lt;/div&gt;
&lt;div&gt;Another noteworthy proposal is &lt;code&gt;&amp;lt;expression1&amp;gt; if &amp;lt;condition&amp;gt; else &amp;lt;expression2&amp;gt;&lt;/code&gt;, which was the recommended solution in the earliest version of PEP-308. However, some people find the style of not placing the condition first uncomfortable, and when “expression1” is long, it is easy to overlook its condition.&lt;/div&gt;
&lt;div&gt;Here are all the design proposals that were voted on at the time:&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Overall, developers wanted to introduce some form of if-then-else expression, but no proposal gained an absolute advantage in the vote. The main points of disagreement were whether to use punctuation, whether to reuse keywords, whether to reuse parentheses, whether to introduce new keywords, and whether to introduce new syntax.&lt;/div&gt;
&lt;div&gt;Due to the scattered votes, the PEP was rejected at the time. The PEP stated, “a Python design principle has been to prefer the status quo whenever there are doubts about which path to take.”&lt;/div&gt;
&lt;h2&gt;The problem of using and-or for conditional selection&lt;/h2&gt;
&lt;div&gt;The above voting event occurred in March 2004, but the discussion on the related topic did not die down after the PEP was rejected, as people were always looking for a concise way to replace “if-else”.&lt;/div&gt;
&lt;div&gt;In September 2005, someone in the mailing list proposed &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056510.html&quot;&gt;changing the logic of the “and” and “or” operators in Py3.0&lt;/a&gt;, suggesting that “and” and “or” operators be simplified to always return a boolean value instead of returning the last evaluated argument.&lt;/div&gt;
&lt;div&gt;The reason for this proposal was that he used the &lt;code&gt;&amp;lt;condition&amp;gt; and &amp;lt;expression1&amp;gt; or &amp;lt;expression2&amp;gt;&lt;/code&gt; syntax to implement conditional selection. However, this syntax behaves differently in Python than in some other languages, and if used improperly, it can result in bugs!&lt;/div&gt;
&lt;div&gt;Take a look at the following two examples. What do you think their results will be?&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;a = True and True or &quot;Python cat&quot;

b = True and False or &quot;Python cat&quot;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;For &lt;code&gt;&amp;lt;condition&amp;gt; and &amp;lt;expression1&amp;gt; or &amp;lt;expression2&amp;gt;&lt;/code&gt;, if the condition is false, expression2 is evaluated and returned directly. If the condition is true, expression1 is evaluated first. If it is also true, expression2 will not be evaluated further. If expression1 is false, expression2 will be evaluated.&lt;/div&gt;
&lt;div&gt;Therefore, the variable a in the above example will be “True”, while b will be “Python cat”.&lt;/div&gt;
&lt;div&gt;In the previous article ”&lt;a href=&quot;https://mp.weixin.qq.com/s/g6jZX0IdH9xpM7BMV3-ToQ&quot;&gt;Why Python Supports Arbitrary Truth Value Testing?&lt;/a&gt;”, we discussed the special nature of truth value testing in Python. When applied to the above structure, more subtle issues may arise. For example, the author of the email encountered a complex number “0+4i” as “expression1”, which is evaluated as false, leading to the unexpected return of “expression2” instead of “expression1”!&lt;/div&gt;
&lt;div&gt;Before a better solution was found, “and-or” was a common conditional selection syntax, which was also mentioned in PEP-308. It was also considered ugly and require much more effort to understand.&lt;/div&gt;
&lt;div&gt;This email once again sparked a discussion in the community about conditional selection syntax, with many experts joining the conversation.&lt;/div&gt;
&lt;div&gt;From my current perspective, developers were not satisfied with the status quo of “if-else”, but the popular “and-or” syntax at the time was not good enough. Therefore, people hoped that Python could design a new standardized syntax to solve this pain point.&lt;/div&gt;
&lt;h2&gt;Unusual conditional expression&lt;/h2&gt;
&lt;div&gt;After 10 days of email discussion, Guido van Rossum ultimately decided to add a conditional expression with the syntax &lt;code&gt;X if C else Y&lt;/code&gt;. As a result, PEP-308 was reopened and updated, and it was soon implemented in the &lt;a href=&quot;https://docs.python.org/3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator&quot;&gt;2.5 version&lt;/a&gt; the following year.&lt;/div&gt;
&lt;div&gt;As mentioned earlier, this solution made some people uncomfortable because it did not put conditional logic at the forefront.&lt;/div&gt;
&lt;div&gt;So why did it end up being the winner? Is it the optimal design?&lt;/div&gt;
&lt;div&gt;Undeniably, the decisive factor was Guido. Since the community did not form a majority opinion when voting a year and a half ago, he exercised his BDFL (Benevolent Dictator For Life) decision-making power to decide on what he believed to be the best solution.&lt;/div&gt;
&lt;div&gt;&lt;code&gt;X if C else Y&lt;/code&gt; is very easy to understand and highly readable. It continues the style of “explicit is better than implicit” by using the intuitive and conversational “if-else” instead of introducing potentially confusing punctuation, just like how Python chooses the words “and” and “or” instead of the symbols ”&amp;amp;&amp;amp;” and ”||“.&lt;/div&gt;
&lt;div&gt;Although the adjusted syntax order may require some adjustment, it has many advantages. First, it only needs to reuse the two keywords “if-else” without introducing other syntax elements like “then” and “when”, or the cumbersome &lt;code&gt;(if &amp;lt;condition&amp;gt;: &amp;lt;expression1&amp;gt; else: &amp;lt;expression2&amp;gt;)&lt;/code&gt;.&lt;/div&gt;
&lt;div&gt;Secondly, in order to verify the effectiveness of &lt;code&gt;X if C else Y&lt;/code&gt;, Guido examined all the “and-or” combinations in the standard library and found that those written as &lt;code&gt;C and X or Y&lt;/code&gt; could be replaced by &lt;code&gt;X if C else Y&lt;/code&gt;. The situation in the standard library proved that this new syntax is feasible.&lt;/div&gt;
&lt;div&gt;Looking back at this history, we can trace a clue: Python did not design the ternary operator “?:” mainly because it did not fit the clear and intuitive design style of Python. The main intention behind using the &lt;code&gt;X if C else Y&lt;/code&gt; design was actually to eliminate the pitfalls of the “and-or” syntax. This design is concise and easy to read.&lt;/div&gt;
&lt;div&gt;Overall, Python designers highly value readability and maintainability. The decision to create a conditional expression syntax instead of adopting the ternary operator was the result of open discussion, careful evaluation, and trade-offs.&lt;/div&gt;
&lt;h2&gt;Why don’t Go and Rust have the ternary operator?&lt;/h2&gt;
&lt;div&gt;After examining the design reasons for Python, let’s now look at two other most popular languages.&lt;/div&gt;
&lt;div&gt;First is the Go language, which has a specific question in its &lt;a href=&quot;https://go.dev/doc/faq#Does_Go_have_a_ternary_form&quot;&gt;FAQ&lt;/a&gt;: “Why does Go not have the &lt;code&gt;?:&lt;/code&gt; operator?“.&lt;/div&gt;
&lt;div&gt;Go language does not support the &lt;code&gt;?:&lt;/code&gt; operator and instead recommends using the native “if-else” syntax. The explanation in the documentation is brief, with only one sentence:&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;The reason &lt;code&gt;?:&lt;/code&gt; is absent from Go is that the language’s designers had seen the operation used too often to create overly complex expressions. The &lt;code&gt;if-else&lt;/code&gt; form, although longer, is unquestionably clearer. A language needs only one conditional control flow construct.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;Moving on to the Rust language, there doesn’t seem to be any explanation in its &lt;a href=&quot;https://doc.rust-lang.org/stable/reference/introduction.html&quot;&gt;official documentation&lt;/a&gt; about the lack of support for the ternary operator. However, after doing some research, I found a fascinating story: in June 2011, Rust once introduced the ternary operator (&lt;a href=&quot;https://github.com/rust-lang/rust/commit/05c0216654999e3d33373914b10aebf9dd7d4907&quot;&gt;#565&lt;/a&gt;), but six months later, the designers realized that this feature was redundant and removed it (&lt;a href=&quot;https://github.com/rust-lang/rust/issues/1698&quot;&gt;#1698&lt;/a&gt;, &lt;a href=&quot;https://github.com/rust-lang/rust/issues/4632&quot;&gt;#4632&lt;/a&gt;)!&lt;/div&gt;
&lt;div&gt;Why was the ternary operator redundant in Rust? Because its &lt;code&gt;if&lt;/code&gt; syntax is not a “statement” like in other languages, but an “expression”, which means that you can directly assign the &lt;code&gt;if&lt;/code&gt; expression to a variable:&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;// Gets 5 if the condition is true, otherwise 6&lt;/span&gt;
&lt;span&gt;let&lt;/span&gt; number &lt;span&gt;=&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; condition &lt;span&gt;{&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt; &lt;span&gt;6&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;This syntax is simple enough - it’s just taking the familiar “if-else” and using it directly for assignment. It’s so convenient that replacing it with the ternary operator would feel like unnecessary complication.&lt;/div&gt;
&lt;div&gt;Additionally, Rust uses curly braces to delimit code blocks, so the curly braces in the above example can contain multiple expressions and support line breaks, as shown in this example:&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x &lt;span&gt;=&lt;/span&gt; &lt;span&gt;42&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;let&lt;/span&gt; result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; x &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;50&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;println!&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;x is greater than 50&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    x &lt;span&gt;*&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;// This is an expression that will assign its returned value to the variable &apos;result&apos;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;println!&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;x is less than or equal to 50&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    x &lt;span&gt;/&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;This usage is impossible in Python. The key difference is that in Rust, if is an expression rather than a statement.&lt;/div&gt;
&lt;div&gt;The difference between these two concepts is:&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;An expression is an &lt;strong&gt;evaluatable code snippet&lt;/strong&gt; composed of variables, constants, operators, etc., whose evaluation result can be used in other expressions or statements.&lt;/li&gt;
&lt;li&gt;A statement is typically a &lt;strong&gt;single or group of instructions&lt;/strong&gt; that perform a task, such as assignment statements, conditional statements, loop statements, etc. It has no return value (or is empty) and cannot be used for assignment operations.&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;In addition to Rust, there are also other programming languages in which &lt;code&gt;if&lt;/code&gt; is an expression instead of a statement, such as Kotlin, Scala, F#, and Swift. They theoretically do not need to use the ternary operator. (As an aside, Swift is an exception, and it also has a ternary operator. Kotlin has the “?: ” operator, note that the two symbols are connected together. &lt;code&gt;val result = a ?: b&lt;/code&gt; means: if &lt;code&gt;a&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, assign it to &lt;code&gt;result&lt;/code&gt;; otherwise, assign &lt;code&gt;b&lt;/code&gt; to &lt;code&gt;result&lt;/code&gt;.)&lt;/div&gt;
&lt;div&gt;Due to this language design difference, Rust and Python/Go have naturally different starting points when facing the question of whether to support the ternary operator. Knowing this difference will give us a clearer understanding of programming languages.&lt;/div&gt;
&lt;div&gt;Returning to the question of this article: Why do some programming languages not adopt the mainstream syntax of the ternary operator?&lt;/div&gt;
&lt;div&gt;Undeniably, the “?: ” syntax is indeed a concise and useful design. However, the potential drawbacks of using punctuation are that they are too abstract, and their readability is not as strong as “if-else”. Additionally, different language design styles and usage habits can lead to different choices.&lt;/div&gt;
&lt;div&gt;After some twists and turns, Python ultimately designed a unique conditional expression. The Go language explicitly states that it does not support the ternary operator. Rust designed it initially but later abandoned it, mainly due to the language foundation of the if expression.&lt;/div&gt;
&lt;div&gt;After examining these three popular languages, I believe you have found a satisfying answer.&lt;/div&gt;
&lt;h2&gt;Author’s Note&lt;/h2&gt;
&lt;div&gt;This article is based on a &lt;a href=&quot;https://pythoncat.top/posts/2023-04-03-condition&quot;&gt;Chinese translation&lt;/a&gt; and may contain inaccuracies or errors in expression. The author welcomes any feedback or corrections from readers.&lt;/div&gt;
&lt;div&gt;Finally, this article is part of the ”&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;Python whydo&lt;/a&gt;” series and all articles have been archived on GitHub. Feel free to star and raise any issues.&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>为什么 Python、Go 和 Rust 都不支持三元运算符？</title>
            <link>https://pythoncat.top/posts/2023-04-03-condition/</link>
            <guid>https://pythoncat.top/posts/2023-04-03-condition/</guid>
            <description>Python 在经过一番波折后，最后设计出了与众不同的条件表达式。Go 语言明确表示不支持三元运算符。Rust 先设计后舍去，主要的原因在于 if 表达式的语言基础</description>
            <pubDate>Mon, 03 Apr 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在编程时，我们经常要作条件判断，并根据条件的结果选择执行不同的语句块。在许多编程语言中，最常见的写法是三元运算符，但是，Python 并不支持三元运算符，无独有偶，两个最热门的新兴语言 Go 和 Rust 也不支持！&lt;/div&gt;
&lt;div&gt;为什么 Python 不支持三元运算符呢？本文将主要分析 Python 在设计&lt;strong&gt;条件选择语法&lt;/strong&gt;时的过程，科普为什么它会采用现今的与众不同的实现方案，同时，我们也将考察为什么其它语言也要抛弃传统的三元运算符。&lt;/div&gt;
&lt;div&gt;在开篇之前，我再声明一下：就像“&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;Python为什么&lt;/a&gt;”系列的大部分文章一样，本文关注的仅是一个很小的语法点，但它并不是“茴香豆有几种写法”那种毫无意义的话题。因为，&lt;strong&gt;细微之处见真功夫，深入研究语言设计背后的原因、历史和哲学，可以让我们在编程时有更加清晰和自由的思维。&lt;/strong&gt;&lt;/div&gt;
&lt;h2&gt;什么是三元运算符？&lt;/h2&gt;
&lt;div&gt;三元运算符通常指的是“?:”，其语法形式为：&lt;code&gt;condition ? expression1 : expression2&lt;/code&gt;，如果 condition 为真，则取 expression1，若不为真，则取 expression2。&lt;/div&gt;
&lt;div&gt;语法简化形式“a ? b : c”，可以读成“如果 a 条件成立，则为 b，否则为 c”。&lt;/div&gt;
&lt;div&gt;三元运算符是对普通一重 if-else 结构的简化，常用于在一条语句中同时实现条件判断和取值操作。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;// 常规 if-else 
if (a &amp;gt; b) {
    result = x;
} else {
    result = y;
}

// 简化后的写法
result = a &amp;gt; b ? x : y;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;采用了这种语法设计的编程语言有很多，比如 C、C#、C++、Java、JavaScript、PHP、Perl、Ruby、Swift 等等。毫无争议，它就是编程语言界的主流设计方案（至今仍是）。&lt;/div&gt;
&lt;div&gt;这种语法非常简洁高效，代码的可读性也很强（如果你不是第一次接触的话），深得很多人的喜欢。&lt;/div&gt;
&lt;div&gt;但是，它并非毫无缺点。Python 是这种语法设计的最著名的挑战者，接下来，我们将看看为什么 Python 要另辟蹊径。&lt;/div&gt;
&lt;h2&gt;Python 社区的投票&lt;/h2&gt;
&lt;div&gt;Python 发布于 1991 年，但在接下来的 15 年里，除了 if-else 语法外，它并不支持三元运算符和其它条件表达式。而且，在 2006 年引入条件表达式前，社区对此进行了漫长而曲折的争论，可以说这是一个设计得很艰难的语法了。&lt;/div&gt;
&lt;div&gt;最初，由于时常有人请求添加 if-then-else（三元）表达式，因此在 2003 年 2 月，&lt;a href=&quot;https://peps.python.org/pep-0308&quot;&gt;PEP 308 – Conditional Expressions&lt;/a&gt; 被提了出来，目的是让社区选出一个让多数人支持的方案。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;很快，除了少部分人希望啥也不做外，社区里出现了好几种方案：&lt;/div&gt;
&lt;div&gt;（1）使用标点符号构建的三元运算符&lt;/div&gt;
&lt;div&gt;即常规的三元运算符，跟前文介绍的语法一样：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;condition&amp;gt; ? &amp;lt;expression1&amp;gt; : &amp;lt;expression2&amp;gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这个方案的呼声挺高，有开发者甚至已提交了实现代码。但是，Guido 给出了两个反对的理由：冒号在 Python 中已经有许多用途（即使它实际上不会产生歧义，因为问号需要匹配冒号）；对于不习惯 C 衍生语言的人来说，理解起来很困难。&lt;/div&gt;
&lt;div&gt;（2）使用现有和新的关键字构建&lt;/div&gt;
&lt;div&gt;引入新的“then”关键字，结合现有的“else”关键字：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;condition&amp;gt; then &amp;lt;expression1&amp;gt; else &amp;lt;expression2&amp;gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;它的优点是简单明了、不需要括号、不改变现有关键字的语义，不大可能与语句混淆，而且不需要重载冒号。缺点是引入新关键字的实现成本较高。&lt;/div&gt;
&lt;div&gt;（3）其它思路&lt;/div&gt;
&lt;div&gt;跟上一种方案的思路相似，但没有上述两类方案的支持度高。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;(if &amp;lt;condition&amp;gt;: &amp;lt;expression1&amp;gt; else: &amp;lt;expression2&amp;gt;)
&amp;lt;condition&amp;gt; and &amp;lt;expression1&amp;gt; else &amp;lt;expression2&amp;gt;
&amp;lt;expression1&amp;gt; if &amp;lt;condition&amp;gt; else &amp;lt;expression2&amp;gt;
cond(&amp;lt;condition&amp;gt;, &amp;lt;expression1&amp;gt;, &amp;lt;expression2&amp;gt;)&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;值得一提的是&lt;code&gt;(if &amp;lt;condition&amp;gt;: &amp;lt;expression1&amp;gt; else: &amp;lt;expression2&amp;gt;)&lt;/code&gt; ，它是常规 if-else 语法的扁平化，容易理解，但缺点是需要使用圆括号，容易跟生成器表达式混淆，而且需要解释器对冒号做特殊化处理。&lt;/div&gt;
&lt;div&gt;另外值得一提的是&lt;code&gt;&amp;lt;expression1&amp;gt; if &amp;lt;condition&amp;gt; else &amp;lt;expression2&amp;gt;&lt;/code&gt;，它是 PEP-308 最早版本的推荐方案，但是这种不将条件放在首位的风格让一些人感觉不舒服，而且，当“expression1”很长的时候，很容易就忽略掉它的条件。&lt;/div&gt;
&lt;div&gt;当时参与投票的全部设计方案：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;总体上，开发者们希望引入某种形式的 if-then-else 表达式，但投票后却没有哪种方案能取得绝对的优势。概括起来，分歧的问题主要有：是否用标点符号、是否复用关键字、是否复用圆括号、是否引入新关键字、是否引入新语法……&lt;/div&gt;
&lt;div&gt;由于得票太分散，因此，这个 PEP 在当时被拒绝了。PEP 中写道：“&lt;strong&gt;Python 的一个设计原则是在不确定采取哪条路线时，则保持现状。&lt;/strong&gt;”&lt;/div&gt;
&lt;h2&gt;and-or 用于条件选择的问题&lt;/h2&gt;
&lt;div&gt;以上的投票事件发生在 2004 年 3 月，但是，在 PEP 被拒绝后，相关话题的讨论并未平息，因为大家总想找一种简洁的方式来替换“if-else“。&lt;/div&gt;
&lt;div&gt;时间到了 2005 年 9 月，邮件组中有人提议&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056510.html&quot;&gt;在  Py3.0 中变更”and”与”or”操作符的逻辑&lt;/a&gt;，提议将”and” 和 “or” 运算符简化成始终返回布尔值，而不是返回最后一个被求值的参数。&lt;/div&gt;
&lt;div&gt;之所以发起这个提议，原因是他使用了&lt;code&gt;&amp;lt;condition&amp;gt; and &amp;lt;expression1&amp;gt; or &amp;lt;expression2&amp;gt;&lt;/code&gt;的方式来实现条件判断与选择。但是这种写法在 Python 中的行为跟有些语言并不一样，使用不严谨的话，可能会酿成 Bug！&lt;/div&gt;
&lt;div&gt;看看下面的两个例子，你觉得它们会得到什么结果呢？&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;a = True and True or &quot;Python猫&quot;

b = True and False or &quot;Python猫&quot;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;对于&lt;code&gt;&amp;lt;condition&amp;gt; and &amp;lt;expression1&amp;gt; or &amp;lt;expression2&amp;gt;&lt;/code&gt; ，若 condition 为假，则会直接对 expression2 求值并返回结果；若 condition 为真，则先对 expression1 求值，若也为真，则不会继续对 expression2 求值，若 expression1 不为真，则对 expression2 求值。&lt;/div&gt;
&lt;div&gt;因此，上述例子得到的 a 是“True”，而 b 会得到“Python猫”。&lt;/div&gt;
&lt;div&gt;本系列的《&lt;a href=&quot;https://mp.weixin.qq.com/s/g6jZX0IdH9xpM7BMV3-ToQ&quot;&gt;Python 为什么能支持任意的真值判断？&lt;/a&gt; 》介绍过 Python 在真值判断的特殊之处，运用到以上结构中，将出现更不易察觉的问题。比如，该邮件的作者就是遇到了“expression1”为复数“0+4i”，这个数的真值判断为 False，因此导致最后返回的不是预期的“expression1”，而是“expression2”！&lt;/div&gt;
&lt;div&gt;在没有更好的方案前，“and-or”是比较常见的条件选择写法，PEP-308 也提及了它，也指出了当“expression1”为假的情况，还认为这种方案是丑陋和令人费解的。&lt;/div&gt;
&lt;div&gt;这封邮件再次引发了社区对条件选择语法的讨论，大佬们纷纷登场。&lt;/div&gt;
&lt;div&gt;以我现在的视角分析，其实就是开发者们不满足于“if-else”的现状，但是当时流行的“and-or”写法并不够好，因此，大家期望 Python 设计出新的规范性语法，来解决这个痛点。&lt;/div&gt;
&lt;h2&gt;与众不同的条件表达式&lt;/h2&gt;
&lt;div&gt;在经过 10 天的邮件讨论后，Guido van Rossum 最终决定添加一个&lt;strong&gt;条件表达式&lt;/strong&gt;，语法形式为&lt;code&gt;X if C else Y&lt;/code&gt; 。因此，PEP-308 被重开和更新，并很快就在次年的 &lt;a href=&quot;https://docs.python.org/3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator&quot;&gt;2.5 版本&lt;/a&gt;中实现了。&lt;/div&gt;
&lt;div&gt;前文已提到过这个让一些人感觉不舒服的方案了，因为它没有将条件判断逻辑放在最前面。&lt;/div&gt;
&lt;div&gt;那么，为什么最后的胜者会是它呢？这是不是最优的设计呢？&lt;/div&gt;
&lt;div&gt;不可否认，起到决定性作用的原因是 Guido。由于社区在一年半前投票时没有形成多数意见，因此他行使 BDFL （终身仁慈独裁者）的决策权力，裁定出一个他认为是最佳的方案。&lt;/div&gt;
&lt;div&gt;&lt;code&gt;X if C else Y&lt;/code&gt; 非常易于理解，可读性高。它延续了“&lt;strong&gt;明确优于隐式&lt;/strong&gt;”的风格，使用了直观口语化的“if-else”，而不是引入可能引起混淆的标点符号，就像 Python 选择“and”和“or”两个单词，而不是“&amp;amp;&amp;amp;”和“||”两个符号，它们有着异曲同工之妙。&lt;/div&gt;
&lt;div&gt;虽然调整后的语法顺序让人不太习惯，但其实这样的实现却大有好处。首先，它只需复用“if-else”两个关键字，而不需要引入“then”、“when”和其它语法要素，也不像&lt;code&gt;(if &amp;lt;condition&amp;gt;: &amp;lt;expression1&amp;gt; else: &amp;lt;expression2&amp;gt;)&lt;/code&gt; 那样的繁琐。&lt;/div&gt;
&lt;div&gt;其次，为了验证&lt;code&gt;X if C else Y&lt;/code&gt; 的有效性，Guido 排查了标准库中所有“and-or”组合的写法，发现那些&lt;code&gt;C and X or Y&lt;/code&gt; 写法都可以被&lt;code&gt;X if C else Y&lt;/code&gt; 替换掉。&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056803.html&quot;&gt;标准库的情况&lt;/a&gt;，证明了这新的语法是可行的。&lt;/div&gt;
&lt;div&gt;回顾这段历史，我们可以梳理出一条线索：&lt;strong&gt;Python 没有设计三元运算符“?:”，主要是因为它不符合 Python 明确直观的设计风格。最后采用&lt;code&gt;X if C else Y&lt;/code&gt; 这种设计，主要的意图其实是消除“and-or”写法的隐患，这种设计简明易读，非常好用。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;总体而言，&lt;strong&gt;Python 设计者非常看重可读性与可维护性，不采用三元运算符而创造条件表达式语法，这是一个经过了开放讨论、谨慎评估与权衡取舍的结果。&lt;/strong&gt;&lt;/div&gt;
&lt;h2&gt;Go、Rust 为什么不支持三元运算符？&lt;/h2&gt;
&lt;div&gt;考察完 Python 的设计原因后，我们再来考察“反派阵营”中两门最热门的语言。&lt;/div&gt;
&lt;div&gt;首先是 Go 语言，官网的 &lt;a href=&quot;https://go.dev/doc/faq#Does_Go_have_a_ternary_form&quot;&gt;FAQ&lt;/a&gt; 专门列出了一个问题：“Why does Go not have the &lt;code&gt;?:&lt;/code&gt; operator?”。&lt;/div&gt;
&lt;div&gt;Go 语言不支持“?:”运算符，而是推荐使用原生的“if-else”写法。文档的解释很简短，只有一段话：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Go 语言没有 ?: 运算符，因为语言的设计者们经常看到它被用来创建难以理解的复杂表达式。虽然 if-else 形式比较长，但是它无疑更清晰易懂。&lt;strong&gt;一个语言只需要一个条件控制流结构&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;接着是 Rust 语言，它的&lt;a href=&quot;https://doc.rust-lang.org/stable/reference/introduction.html&quot;&gt;官方文档&lt;/a&gt;中似乎没有任何关于不支持三元运算符的解释。但在查阅资料后，我发现它也有一段特殊的故事，非常有意思：在 2011 年 6 月时，Rust 曾经引入过三元运算符（&lt;a href=&quot;https://github.com/rust-lang/rust/commit/05c0216654999e3d33373914b10aebf9dd7d4907&quot;&gt;#565&lt;/a&gt;），然而半年后，设计者意识到这个特性是多余的，因此又把它移除了（&lt;a href=&quot;https://github.com/rust-lang/rust/issues/1698&quot;&gt;#1698&lt;/a&gt;、&lt;a href=&quot;https://github.com/rust-lang/rust/issues/4632&quot;&gt;#4632&lt;/a&gt;）!&lt;/div&gt;
&lt;div&gt;为什么三元运算符在 Rust 是多余的呢？因为它的 if 语法并不像其它语言是“语句（&lt;strong&gt;statement&lt;/strong&gt;）”，而是一个“表达式（&lt;strong&gt;expression&lt;/strong&gt;）”，这意味着你可以直接将 if 表达式赋值给变量：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;// 若条件为真，得到 5，否则 6&lt;/span&gt;
&lt;span&gt;let&lt;/span&gt; number &lt;span&gt;=&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; condition &lt;span&gt;{&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt; &lt;span&gt;6&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这种语法形式足够简单明了，不就是将大家都熟悉的“if-else”直接用于赋值么，太方便了，替换成三元运算符的话，确实有点画蛇添足之感。&lt;/div&gt;
&lt;div&gt;另外，Rust 使用花括号划分代码块，因此上例的花括号内可以包含多条表达式，也支持换行，例如这个例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x &lt;span&gt;=&lt;/span&gt; &lt;span&gt;42&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;let&lt;/span&gt; result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; x &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;50&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;println!&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;x is greater than 50&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    x &lt;span&gt;*&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;// 这是一个表达式，将返回的值赋给 result&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;println!&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;x is less than or equal to 50&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    x &lt;span&gt;/&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;// 也是一个表达式，将返回的值赋给 result&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这种用法，Python 是不可能做到的。最关键的区别在于，Rust 的 if 是表达式而不是语句。&lt;/div&gt;
&lt;div&gt;这两个概念的区别是：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;表达式（expression）通常指的是由变量、常量、运算符等组成的一个&lt;strong&gt;可求值的代码片段&lt;/strong&gt;，它的求值结果可以用到其它表达式或语句中。&lt;/li&gt;
&lt;li&gt;语句（statement）通常指的是完成某个任务的&lt;strong&gt;单个指令或一组指令&lt;/strong&gt;，例如赋值语句、条件语句、循环语句等，它没有返回值（或者为空），不能用于赋值操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;除了 Rust 外，还有一些编程语言中的 if 是表达式而不是语句，例如 Kotlin、Scala、F#、Swift，它们在理论上也不需要使用三元运算符。（题外话：Swift 是个例外，它也有三元运算符。Kotlin 有“?:”运算符，注意两个符号是连在一起的，&lt;code&gt;val result = a ?: b&lt;/code&gt; 表示：如果 &lt;code&gt;a&lt;/code&gt; 不为 &lt;code&gt;null&lt;/code&gt;，则赋值给 &lt;code&gt;result&lt;/code&gt; ；否则将 &lt;code&gt;b&lt;/code&gt; 赋给 &lt;code&gt;result&lt;/code&gt;）&lt;/div&gt;
&lt;div&gt;由于有这种语言设计层面的区别，因此在面对“是否要支持三元运算符”这个问题时，Rust 和 Python/Go 的思考角度有着天然不同的起点。知道了这种区别后，我们对编程语言会有更明晰地认知。&lt;/div&gt;
&lt;div&gt;回到本文的问题：为什么有些编程语言不采用主流的三元运算符语法呢？&lt;/div&gt;
&lt;div&gt;不可否认，“?:”确实是一种简洁好用的设计，然而，标点符号的负面影响是过于抽象，可读性并不及“if-else”那样强。另外，不同语言的设计风格与使用习惯，也会导致不同的选择。&lt;/div&gt;
&lt;div&gt;Python 在经过一番波折后，最后设计出了与众不同的条件表达式。Go 语言明确表示不支持三元运算符。Rust 先设计后舍去，主要的原因在于 if 表达式的语言基础。&lt;/div&gt;
&lt;div&gt;考察完这三个热门语言后，我相信你已收获了一个满意的答案。如果是这样，请点赞支持一下本文吧！&lt;/div&gt;
&lt;div&gt;最后，本文出自“&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;Python为什么&lt;/a&gt;”系列，全部文章已归档在 Github 上，欢迎 star 和提 issue。&lt;/div&gt;
&lt;div&gt;PS.在强力的 ChatGPT 辅助下，我将本文翻译成了英文，欢迎阅读指正—&amp;gt;&lt;a href=&quot;https://pythoncat.top/posts/2023-04-04-condition-en&quot;&gt;Why don’t Python, Go and Rust have a ternary conditional operator?&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>ChatGPT 开源了第一款插件，都来学习一下源码吧！</title>
            <link>https://pythoncat.top/posts/2023-03-29-plugin/</link>
            <guid>https://pythoncat.top/posts/2023-03-29-plugin/</guid>
            <description>ChatGPT 推出了插件系统，未来不可估量！本文走读知识库插件源码，提前熟悉如何开发一款插件</description>
            <pubDate>Wed, 29 Mar 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;3 月 23 日，OpenAI 又投出了一枚重磅炸弹：&lt;strong&gt;为 ChatGPT 推出插件系统！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;此举意味着 ChatGPT 将迎来“APP Store”时刻，也就是围绕它的能力，形成一个开发者生态，打造出基于 AI 的“操作系统”！&lt;/div&gt;
&lt;div&gt;插件系统将为 ChatGPT 带来质的飞跃，因为借助于插件服务，它可以获取实时的互联网信息、调用第三方应用（预定酒店航班、点外卖、购物、查询股票价格等等）。&lt;/div&gt;
&lt;div&gt;ChatGPT 是一个无比聪明的大脑，而插件会成为它的眼睛、耳朵、手脚、甚至于翅膀，能力惊人，未来不敢想象！&lt;/div&gt;
&lt;div&gt;官方目前提供了两个插件：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;一个网页浏览器。利用新必应浏览器的 API，实时搜索互联网内容，并给出答案和链接&lt;/li&gt;
&lt;li&gt;一个代码解释器。利用 Python 解释器，可以解决数学问题、做数据分析与可视化、编辑图片、剪辑视频等等，还支持下载处理后的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;另外，OpenAI 还开源了一个知识库检索插件 &lt;a href=&quot;https://github.com/openai/chatgpt-retrieval-plugin&quot;&gt;chatgpt-retrieval-plugin&lt;/a&gt; ，这个插件通过自然语言从各种数据源（如文件、笔记、邮件和公共文档）检索信息。有了开源代码后，开发者可以部署自己的插件版本。&lt;/div&gt;
&lt;div&gt;想象一下，假如我提供了一个“Python 知识库插件”，以所有官方文档作为数据源，那以后有任何 Python 使用上的问题，我就只需询问 ChatGPT，然后它调用插件并解析数据，最后返回给我准确的答案。这将节省大量的时间！&lt;/div&gt;
&lt;div&gt;不仅如此，你还可以用书籍作为数据源，打造出“西游记知识库”、“红楼梦知识库”、“百科全书知识库”、“个人图书馆知识库”，等等；以专业领域的论文与学术期刊为数据源，创造出一个专家助手，从此写论文查资料将无比轻松；以苏格拉底、乔布斯、马斯克等名人的资料为数据源，创造出人格化的个人顾问……&lt;/div&gt;
&lt;div&gt;作为第一个开源的 ChatGPT 插件，chatgpt-retrieval-plugin 项目一经发布，就登上 Github 趋势榜第一，发布仅一周就获得 11K stars。&lt;/div&gt;
&lt;div&gt;这个项目完全是用 Python 写的，不管是出于学习编程的目的，还是为了将来开发别的插件作借鉴，这都值得我们花时间好好研究一下。&lt;/div&gt;
&lt;div&gt;接下来，我将分享自己在阅读项目文档和源码时，收获到的一些信息。&lt;/div&gt;
&lt;div&gt;首先，该项目含 Python 代码约 3 K，规模不算大。项目结构也很清晰，目录如下：&lt;/div&gt;









































&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;目录&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;datastore&lt;/code&gt;&lt;/td&gt;&lt;td&gt;包含使用各种向量数据库提供程序存储和查询文档嵌入的核心逻辑&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;examples&lt;/code&gt;&lt;/td&gt;&lt;td&gt;包括配置示例、身份验证方法和面向程序提供方的示例&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;models&lt;/code&gt;&lt;/td&gt;&lt;td&gt;包含插件使用的数据模型，例如文档和元数据模型&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;scripts&lt;/code&gt;&lt;/td&gt;&lt;td&gt;存放实用的脚本，用于处理和上传来自不同数据源的文件&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;server&lt;/code&gt;&lt;/td&gt;&lt;td&gt;存放主要的 FastAPI 服务端实现&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;services&lt;/code&gt;&lt;/td&gt;&lt;td&gt;包含用于任务（如分块、元数据提取和 PII 检测）的实用服务&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;tests&lt;/code&gt;&lt;/td&gt;&lt;td&gt;包括各种向量数据库提供程序的集成测试&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;.well-known&lt;/code&gt;&lt;/td&gt;&lt;td&gt;存储插件清单文件和 OpenAPI 格式，定义插件配置和 API 规范等信息&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;div&gt;除去示例、测试、配置文件等内容外，最主要的三个目录如下：&lt;/div&gt;
&lt;h2&gt;datastore 数据存储&lt;/h2&gt;
&lt;div&gt;数据源的文本数据会被映射到低维度向量空间，然后存储到向量数据库中。官方已提供 Pinecone、Weaviate、Zilliz、Milvus、Qdrant、Redis 这几种数据存储方案的示例。另外，有几个 pull requests 想要加入 PostgreSQL 的支持，大概率将来会合入。&lt;/div&gt;
&lt;div&gt;这里使用了&lt;code&gt;抽象工厂设计模式&lt;/code&gt; ，DataStore 是一个抽象类，每种数据存储库是具体的实现类，需要实现三个抽象方法：&lt;/div&gt;
&lt;div&gt;（1）&lt;code&gt;_upsert(chunks: Dict[str, List[DocumentChunk]]) -&amp;gt; List[str]&lt;/code&gt; 方法，接收一个字典参数，包含有 DocumentChunk 对象列表，将它们插入到数据库中。返回值为文档 ID 的列表。&lt;/div&gt;
&lt;div&gt;（2）&lt;code&gt;_query(queries: List[QueryWithEmbedding]) -&amp;gt; List[QueryResult]&lt;/code&gt; 方法，接收一个列表参数，包含被 embedding 的查询文本。返回一个包含匹配文档块和分数的查询结果列表。&lt;/div&gt;
&lt;div&gt;（3）&lt;code&gt;delete(ids: Optional[List[str]] = None, filter: Optional[DocumentMetadataFilter] = None, delete_all: Optional[bool] = None, ) -&amp;gt; bool&lt;/code&gt;  方法，根据 id 和其它过滤条件删除，或者全部删除。返回操作是否成功。&lt;/div&gt;
&lt;div&gt;值得注意的是，该目录下的&lt;code&gt;factory.py&lt;/code&gt; 模块使用了 Python 3.10 新引入的 match-case 语法，紧跟着 Python 社区的新潮流呢~&lt;/div&gt;
&lt;h2&gt;server 服务端接口&lt;/h2&gt;
&lt;div&gt;这个目录只有一个&lt;code&gt;main.py&lt;/code&gt; 文件，是整个项目的启动入口。它使用了目前主流的 FastAPI 框架，提供了增删改查的几个 API，另外使用 uvicorn 模块来启动服务。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/upsert-file&lt;/code&gt; 接口，用于上传单个文件，将其转换为 Document 对象，再进行新增或更新&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/upsert&lt;/code&gt; 接口，上传一系列的文档对象，用于新增或更新&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/query&lt;/code&gt; 接口，传入一系列的文本条件，转成 QueryWithEmbedding 对象后，再从向量数据库查询&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/delete&lt;/code&gt; 接口，根据条件删除或者全部删除数据库中的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;在这几个接口中，增改删功能主要是给开发者/维护者使用的，ChatGPT 只需调用插件的查询接口。因此，代码中还创建了一个“/sub”子应用，只包含&lt;code&gt;/query&lt;/code&gt; 接口，提供给 ChatGPT 调用。&lt;/div&gt;
&lt;div&gt;另外，它使用 FastAPI 的 mount 方法挂载了一个“/.well-known”静态文件目录，暴露了关于本插件的基本信息，例如名称、描述、作者、logo、邮箱、提供给 OpenAPI 的接口文档等等。&lt;/div&gt;
&lt;h2&gt;services 任务处理方法&lt;/h2&gt;
&lt;div&gt;这个目录下是一些通用的函数，比如下面这些：&lt;/div&gt;
&lt;div&gt;（1）chunks.py 文件包含了将字符串和 Document 对象分割成小块、以及为每个块获取嵌入向量的函数。&lt;/div&gt;
&lt;div&gt;（2）file.py 文件提供了从上传的文件中提取文本内容及元数据的函数。目前支持解析的文件类型包括 PDF、纯文本、Markdown、Word、CSV 和 PPTX。&lt;/div&gt;
&lt;div&gt;（3）openai.py 文件包含两个函数：get_embeddings 函数使用 OpenAI 的 &lt;code&gt;text-embedding-ada-002&lt;/code&gt; 模型对给定的文本进行嵌入。get_chat_completion 函数使用 OpenAI 的 ChatCompletion API 生成对话。&lt;/div&gt;
&lt;div&gt;整个而言，这个插件的几个接口功能很清晰，代码逻辑也不算复杂。核心的文本嵌入操作是借助于 openai 的 Embedding 接口，文本分块信息的存储及查询操作，则是依赖于各家向量数据库的功能。&lt;/div&gt;
&lt;div&gt;YouTube 上有博主手画了一张示意图，字体虽潦草，但大家可以意会一下：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;他&lt;a href=&quot;https://www.youtube.com/watch?v=hpePPqKxNq8&quot;&gt;这个视频&lt;/a&gt; 值得推荐一看，因为 up 主不仅简明地介绍了插件的工作原理，还手把手演示如何部署到 Digital Ocean、如何修改配置、如何调试，而且他有 ChatGPT 的插件权限，可以将自己部署的插件接入 ChatGPT，现场演示了知识库插件的使用！&lt;/div&gt;
&lt;div&gt;目前，关于 ChatGPT 插件的介绍、开发及配置等资料还比较少，毕竟是新推出的。但是，申请 waitlist 的个人和组织已经数不胜数了，一旦开放使用，各式各样的插件一定会像 Python 社区丰富的开源库一样，也将极大扩展 ChatGPT 的生态。&lt;/div&gt;
&lt;div&gt;最后，插件 &lt;a href=&quot;https://github.com/openai/chatgpt-retrieval-plugin&quot;&gt;chatgpt-retrieval-plugin&lt;/a&gt; 的官方文档是最为详细的一手资料，推荐大家研究一番。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>100 天</title>
            <link>https://pythoncat.top/posts/2023-03-09-100-days/</link>
            <guid>https://pythoncat.top/posts/2023-03-09-100-days/</guid>
            <description>为人父母是一种很新奇的体验！我和豌豆结婚六年才决定生娃，因为有诸多担忧与顾虑。现在小孩百天了，我们收获的是满满的爱和责任</description>
            <pubDate>Thu, 09 Mar 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;几天前，在傍晚约莫 7 点时分，我们坐上了顺风车，一家人从泰州返程回苏州。&lt;/div&gt;
&lt;div&gt;启程还没多久，我怀抱中的小羽儿突然从安静好奇地探视夜景，变为挣扎和哄不住的啼哭。我感受到了车内烘热的气温，伸手在他额头上摸出了汗迹。&lt;/div&gt;
&lt;div&gt;汽车行驶在热闹的大街上，车辆、红绿灯、高楼和墙饰、广告牌、路标和路灯、景观树木、变速和颠簸，以及车里那大声而俗气的音乐，也许是这些信息令他感到不安了。&lt;/div&gt;
&lt;div&gt;当豌豆把他抱去喂了一侧边母乳后，我们的车终于驶到了较平缓的路段，车里已关了壁灯，减少了光源。&lt;/div&gt;
&lt;div&gt;我把小羽儿平抱在大腿上。他没有哭，没有笑，没有睡觉，没有发出声音，有好一会儿时间里，只是睁大了双眼直直向上看着我的脸。&lt;/div&gt;
&lt;div&gt;我时而看向他，时而转头看车外，每次转头，发现他都是一样的姿势和神态。&lt;/div&gt;
&lt;div&gt;过了一会，豌豆头抵着我的头，一起看他。&lt;/div&gt;
&lt;div&gt;我们笑了。&lt;/div&gt;
&lt;div&gt;他也笑了！&lt;/div&gt;
&lt;div&gt;婴儿水灵灵的大眼睛是那样纯净，也不知道在那昏暗的光亮频闪的环境里，他辨别出我们的笑脸时，留下的是什么样的印象。&lt;/div&gt;
&lt;div&gt;他似乎是成长到了一个容易发笑的阶段，浅浅的笑、吐出了点舌尖的笑、灿烂出了声兼手脚挥舞的笑，已经掌握了人类的初级表情语言。&lt;/div&gt;
&lt;div&gt;小羽儿刚满 100 天龄，他在快速地适应和学习。这是他第一次出远门，去程的时候正是中午，他基本是在睡觉，而回程的这一路，则一直不肯入睡。白天与黑夜的作息规律，似乎需要克服更大的生理惯性才能适应呢。&lt;/div&gt;
&lt;div&gt;那天白天，小羽儿第一次剪了头发，成了光头。理发师已经从业多年了，她夸赞说，小羽儿长得真好，完全不像其他 100 天的娃。小羽儿个子高，脑袋大。理发期间几乎不挣扎，更是没有哭，这在她的理发经验里，属于是罕见的了。&lt;/div&gt;
&lt;div&gt;小羽儿很容易亲近人，不怕生怯懦。在前一天以他为主角的人声嘈杂的晚宴上，他被轮流着抱来抱去，谁也不抗拒，谁也不敷衍，安静观察着、聆听着、闻嗅着、感触着、记忆着、等待着，竟然有绝大部分时间是在陌生人的手上！&lt;/div&gt;
&lt;div&gt;宾客们都对他很满意，小小年纪的他从一众长辈那里挣下了第一个好印象，第一次在社交场上表现出了过人之处。&lt;/div&gt;
&lt;div&gt;在这一项上，他很不像作为父母的我们。&lt;/div&gt;
&lt;div&gt;或许这只是一种年幼时的单纯表现，并不是一种会长久持有的秉性，但是，这样的时刻值得用文字仔细记录下来，我希望这能印刻成他生命图腾的基调之一，助他演生出偏于积极外向型的人格。&lt;/div&gt;
&lt;div&gt;那天白天，他的表姐来了。小羽儿如今还不是可以互动做游戏的年纪，眼神停留在她红红的羽绒服上看着，又看着。&lt;/div&gt;
&lt;div&gt;等到他乏了趴在我身上睡觉时，她在请教着自己姑姑做作业。等到午饭过后，他躺在床上睡觉，她在一旁拢着手机刷起了小视频。&lt;/div&gt;
&lt;div&gt;有一个姐姐在身边，融洽的气氛让人心安。&lt;/div&gt;
&lt;div&gt;她非常活泼，好奇地问着桌上这个是什么，那个是什么，问着小小台钟上的时针分针秒针是怎么看的。&lt;/div&gt;
&lt;div&gt;她已学了 100 以内的数字计算，但对 6+7-4 这样的连续计算还是感觉吃力，也会混淆百数表的空间位置与卷面题目顺序的关系，在找规律做推理的时候不完全熟练。&lt;/div&gt;
&lt;div&gt;一边听着她们的对话，一边感受着小羽儿轻微的呼吸，我不禁又想起了亲子教育与引导成长的话题。&lt;/div&gt;
&lt;div&gt;多年前，我看到过一个教育理念，它深深印在了我的认知里，每到这种时刻，总是第一个冒出来。&lt;/div&gt;
&lt;div&gt;它的核心观点是不要顺口而出夸赞小孩“很聪明”“很有天赋”“天生xxx”，家长应该关注那些后天习得的能力，比如某种好的习惯、做事与解决问题的思维方法、情绪调节的能力、不怕犯错的积极心态、以及吸取经验完善自己的能力，等等。&lt;/div&gt;
&lt;div&gt;在这样的理念下，没有一个小孩是“笨蛋”，也没有一个小孩是“聪明鬼”，只有“笨家长”和“聪明家长”。&lt;/div&gt;
&lt;div&gt;遗传基因确实对一个人的未来有着重大影响，但是，成年前的家庭教育环境与方式，影响更大。&lt;/div&gt;
&lt;div&gt;上个月的某天，刚好是我和豌豆结婚七周年纪念日。我们在婚后几年里一直刻意避孕和屏蔽长辈们的生育建议，豌豆有她的诸多担忧因素，我也有我的顾虑，其中最大的顾虑就是家庭教育。&lt;/div&gt;
&lt;div&gt;我曾有很强的优生优育想法。&lt;/div&gt;
&lt;div&gt;这种想法有一个很早的起源：我老家那边有一种多生超生的传统，基于自身的经验和观察到的不好例子，所以我在上大学前就产生了对早生、多生、留守、散养方式的排斥。&lt;/div&gt;
&lt;div&gt;另一方面，我意识到自己没有从上一代那里得到某些东西，所以当考虑养育下一代的时候，我就希望他不要再感受到同样的匮乏、窘迫和缺憾。同时，意识到了自身的不足，我恐怕也难以通过言传身教、以身作则的方式，教给小孩某些东西。&lt;/div&gt;
&lt;div&gt;我们慎重考虑了很久，才决定生小孩。&lt;/div&gt;
&lt;div&gt;豌豆放下了她的一些担忧，我也消解了自己的几个顾虑。&lt;/div&gt;
&lt;div&gt;我们想通了一点，小孩成长的环境并不是一座标准化的温室大棚，不能像控制光照时长、温度湿度和营养数值一样精确调控那些关键的变量，不能将天灾、风雨、杂草和蜂虫都阻挡在外，但是，我们也并不希求那娇弱的花朵，我们希望 TA 自然生长，面对挑战时能坚强自立，面对困境时则迸发生机。&lt;/div&gt;
&lt;div&gt;经过了半年备孕和十月怀胎，我们迎来了一个小天使，已陪他探险这个世界超过 100 天。&lt;/div&gt;
&lt;div&gt;如今，他健康茁壮，常露笑脸。&lt;/div&gt;
&lt;div&gt;每当回看过去的时候，我总是觉得时间过得真快。曾经遇到的某些烦恼的小问题，并没有对未来产生什么影响。时间可以抚平波折，沥选沉沙，仔细看，那是一些会发光的颗粒。&lt;/div&gt;
&lt;div&gt;小羽儿剪了光头，才过几天，那些柔柔软软的毛发又很快长高了。几天前剪短了指甲，现在也很快变长变尖了。&lt;/div&gt;
&lt;div&gt;时间在他身上，似乎流速更快些。&lt;/div&gt;
&lt;div&gt;有些时候，我希望他能快一点长大。有些时候，我又希望他能慢一点长大。&lt;/div&gt;
&lt;div&gt;千羽，快一点长大吧，那我就能听懂你的诉求，能教你知识，能一起去探索世界中的美好，一同去品味人生中的酸甜苦乐。&lt;/div&gt;
&lt;div&gt;千羽，慢一点长大吧，那我就能借着拍嗝哄睡而长时间把你抱在身上，头贴着头给你哼些随性的小曲，不用怕被某种无形的力量割分出距离。&lt;/div&gt;
&lt;div&gt;时间的节奏不服务于人的意愿。&lt;/div&gt;
&lt;div&gt;我知道没必要着急，没必要贪恋。&lt;/div&gt;
&lt;div&gt;现在要做的是，爱眼前的人，活好每一个真实的白天与黑夜，为将来提前做些准备，同时再捕捉住零碎的思绪，添附到这一个又一个文字上。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>这一次，Python 真的有望告别 GIL 锁了？</title>
            <link>https://pythoncat.top/posts/2023-02-20-GIL/</link>
            <guid>https://pythoncat.top/posts/2023-02-20-GIL/</guid>
            <description>GIL 迎来一次强有力的挑战！本文分析了最新出炉的 PEP-703，以及 3.12 版本将会出现的一些变化点</description>
            <pubDate>Mon, 20 Feb 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 中有一把著名的锁——全局解释器锁（Global Interpreter Lock，简写 GIL），它的作用是防止多个本地线程同时执行 Python 字节码，这会导致 Python 无法实现真正的多线程执行。（注：本文中 Python 解释器特指 CPython）&lt;/div&gt;
&lt;div&gt;这把锁在 Python 的早期发展中具有积极的作用（单核 CPU 时代），然而，它阻碍了 Python 在多核 CPU 上的并行编程，引起了开发者们与日俱增的诟病。&lt;/div&gt;
&lt;div&gt;GIL 影响的主要是 CPU 密集型任务，比如科学计算与数值计算任务。&lt;/div&gt;
&lt;div&gt;在最近发布的 &lt;a href=&quot;https://peps.python.org/pep-0703/&quot;&gt;PEP-703&lt;/a&gt; 中，它概括了 GIL 对科学计算（主要是 AI/ML）造成的四类问题：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;GIL 导致许多并行化操作难以表达（影响强化学习、DeepMind、医学治疗及生物研究等领域）&lt;/li&gt;
&lt;li&gt;GIL 影响了 Python 库的可用性（例如 PyTorch、scikit-learn、NumPy）&lt;/li&gt;
&lt;li&gt;GIL 导致无法充分利用 GPU 资源（例如计算机视觉任务）&lt;/li&gt;
&lt;li&gt;GIL 导致难以部署 Python AI 模型（例如基于神经网络的 AI 模型）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;社区中想要移除 GIL 的呼声以及尝试，此起彼伏，绵绵不绝，但这个话题一直悬而未决。&lt;/div&gt;
&lt;div&gt;抱怨、质疑、不满、不甘、期盼等这些诸多的情绪，不是那么容易平息的。然而，从一个积重已久的庞大的项目中移除一个根基性的设计，又谈何容易？&lt;/div&gt;
&lt;div&gt;2023 新年刚过，这个话题又一次热了起来，又一轮对 GIL 的挑战开始了。&lt;/div&gt;
&lt;div&gt;这一次，事情似乎有了新的转机，这次也许能成功了呢？&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;PEP-703 在今年 1 月 9 日新鲜出炉，虽然它目前仍是“草案”状态未被采纳，但是这份 PEP 的意义十分重大！&lt;/div&gt;
&lt;div&gt;（注：每个 Python 学习者都应该基本了解 PEP，建议阅读《&lt;a href=&quot;https://mp.weixin.qq.com/s/oRoBxZ2-IyuPOf_MWyKZyw&quot;&gt;学习Python，怎能不懂点PEP呢？ &lt;/a&gt;》）&lt;/div&gt;
&lt;div&gt;这个 PEP 的作者是 Sam Gross，他是 nogil 项目的作者。Python猫的老读者应该有印象，我们在 2021 年曾翻译过他与 Python 核心开发者们的一次&lt;a href=&quot;https://mp.weixin.qq.com/s/SvUyyUGLZFbqEyERWWJIYQ&quot;&gt;研讨会的纪要&lt;/a&gt;，这份纪要里概括了 nogil 的主要设计思路，同时回答了核心开发者们最为关注的约 20 个问题。&lt;/div&gt;
&lt;div&gt;经过一年多时间的沉淀，nogil 项目现在终于形成了正式的 PEP，这意味着它被采纳进 Python 主分支的可能性变大了一些啦！&lt;/div&gt;
&lt;div&gt;PEP 的标题是《使 CPython 的 GIL 成为可选项》（Making the Global Interpreter Lock Optional in CPython），内容详实，正文超过 1 万字，这个体量的 PEP 绝对够得上排在所有 PEP 的前十了。&lt;/div&gt;
&lt;div&gt;简单而言，这份提案提议给 CPython 增加一个构建时配置项&lt;code&gt;--disable-gil&lt;/code&gt; ，作用是构建出一个线程安全的无 GIL 的解释器。&lt;/div&gt;
&lt;div&gt;为了实现无 GIL 的解释器，Python 底层的部分设计必须作出变更，内容可以概括成四类：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;引用计数&lt;/li&gt;
&lt;li&gt;内存管理&lt;/li&gt;
&lt;li&gt;容器线程安全&lt;/li&gt;
&lt;li&gt;锁和原子 API&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;如果这份 PEP 被采纳实现的话，它会带来一个不容忽视的问题：Python 将发布两个不同版本的解释器，而第三方库也要相应地开发/维护/发布两个版本的软件包。&lt;/div&gt;
&lt;div&gt;PEP-703 的作者也考虑到了这个问题，他提出的解决方案是与 Anaconda 一起发布无 GIL 的 Python，同时在 conda 里集中发布管理那些兼容了新 Python 的库。&lt;/div&gt;
&lt;div&gt;考虑到 Anaconda 在科学计算与数值计算领域的强大影响力，此举既能较好地发挥 nogil Python 的用处，又能减少用户及三方库开发者面对两种发行版时的割裂感。&lt;/div&gt;
&lt;div&gt;值得注意的是，nogil 的 Python 还有一个更大的问题，那就是会影响单线程程序的性能。&lt;/div&gt;
&lt;div&gt;基于 Python 3.11 版本，实现了有偏见的引用计数及永生对象后，Python 单线程性能会变慢 10%。&lt;/div&gt;
&lt;div&gt;尽管这个数值在最新的 nogil 原型版本上可以降低到 5%，但是，另外至少还有两项难以规避的性能下降点：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;2% - 全局的自由列表（主要是元组和浮点数自由列表）&lt;/li&gt;
&lt;li&gt;1.5% - 集合中每个对象的互斥锁（字典、列表、队列）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;单线程的代码才是最广泛的使用场景，可以说这会影响到每一个 Python 用户。任何试图移除 GIL 的项目都不可避免要面临这项挑战。&lt;/div&gt;
&lt;div&gt;尽管存在着以上的两大问题，但 PEP-703 还是很有可取之处的。&lt;/div&gt;
&lt;div&gt;比如，相比于 2015 年提出的著名的 Gilectomy 项目（由 GIL ectomy 两个单词组合而成，ectomy 是一个医学上的术语“切除术”），nogil 在单线程的性能上要快得多，同时可扩展性也更好。&lt;/div&gt;
&lt;div&gt;比如，相比于 2021 年火热的“香农计划”的作者 Eric Snow 提出的 PEP-684 方案（给每个子解释器创建 GIL），后者一方面需要实现作为前提的多个 PEP（如 PEP-554、PEP-683），另一方面需要用户处理多子解释器间共享变量的麻烦。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;在香农计划的《&lt;a href=&quot;https://mp.weixin.qq.com/s/GWByw61O56gJ7qUisAGQNw&quot;&gt;Python 3.12 目标&lt;/a&gt;》中，PEP-554 与 PEP-684 已经囊括在内了，版本目标是充分利用 Python 的子解释器，让子解释器使用各自的 GIL，从而实现多线程的并行。&lt;/div&gt;
&lt;div&gt;好消息是，3.12 的计划跟本文的主角  PEP-703 并不冲突。事实上，它们的很多设计细节是一致的，也就是说，这两套对于 GIL 的改造方案是可以共存的，它们相互促进，事半功倍！&lt;/div&gt;
&lt;div&gt;香农计划有 Python 之父 Guido van Rossum 站台，还有财大气粗的微软支持着一支豪华的团队投入开发（含 Guido 和 Eric Snow），因此，多解释器多 GIL 的方案很可能会更快落地。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;而 PEP-703 有 PSF 首位全职开发者 Łukasz Langa 的倾力支持，社区的反响也不错，我觉得它今后落地的希望也挺大！&lt;/div&gt;
&lt;div&gt;无论如何，这次香农计划和 PEP-703 掀起的对 GIL 的挑战，比以往所有的尝试都更猛烈，更有成功的可能，让人不由得心生欢欣之喜~~&lt;/div&gt;
&lt;div&gt;但愿它们实现的一天不会太远吧。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 发展趋势：与 Rust 深度融合、更易于编写 Web 应用</title>
            <link>https://pythoncat.top/posts/2023-02-12-trends/</link>
            <guid>https://pythoncat.top/posts/2023-02-12-trends/</guid>
            <description>Rust 现在太火了，我也想学啊！用 Python 写 Web 项目，对于不会前端的我而言，也是一直想要掌握的技能呢</description>
            <pubDate>Sun, 12 Feb 2023 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;大家好，我是猫哥，好久不见！2022 年末的时候，我不可避免地阳了，借着身体不舒服就停更了，接踵而至的是元旦和春节假期，又给自己放了假，连年终总结也鸽了，一懈怠就到了 2 月中旬……&lt;/div&gt;
&lt;div&gt;现在是我家娃出生的第三个月，全家人大部分的时间和精力都在他身上，结果是幸福与疲累共存。新生儿是那么的可爱，又是那么的“吵闹”，影响着我们的情绪和生活节奏。这三个月的基调跟过去的日子完全不同，它是新一年的开始，是未来日子的底色，引导着我们的生活重心偏移。&lt;/div&gt;
&lt;div&gt;在过去的两年时间里，我工作上的任务与 Python 基本无关了，转向了 Java 的阵营。然而，在业余时间里，我对 Python 的热情一直不灭（尽管有退减），直到近期，懒怠的念头变多了。&lt;/div&gt;
&lt;div&gt;身心状态与家庭节奏是这段时间停更的主要原因吧。&lt;/div&gt;
&lt;div&gt;今年的这第一篇文章，就当作给大家问声好，给自己打个气吧。唯愿 2023 年，家庭、工作与兴趣都能顺顺利利，不留遗憾，相信前方有美好的未来！&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;最近的 Pycoder‘s Weekly 中有一篇《&lt;a href=&quot;https://blog.jerrycodes.com/python-trends-in-2023/&quot;&gt;Three Python trends in 2023&lt;/a&gt;》，它介绍了当下较为热门的三个话题。我简略翻译/摘录出来，分享给大家。&lt;/div&gt;
&lt;h2&gt;趋势一：Python🤝Rust&lt;/h2&gt;
&lt;div&gt;Rust 对 Python 技术生态的影响越来越大了。关键的赋能者是  &lt;a href=&quot;https://github.com/PyO3/pyo3&quot;&gt;PyO3&lt;/a&gt;，它为 Python 提供了 Rust 绑定。有了 PyO3 后，Python 可以轻松调用 Rust 代码，同时 Rust 也能执行 Python 代码。&lt;/div&gt;
&lt;div&gt;另外，下面的工具在进一步加深这两门语言的友谊：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/pydantic/pydantic-core&quot;&gt;pydantic-core&lt;/a&gt;：pydantic v2 的校验核心。pydantic 的作者 Samuel Colvin 将&lt;a href=&quot;https://twitter.com/samuel_colvin/status/1615044553425424384&quot;&gt;在 Pycon 2023 上发表相关演讲&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/charliermarsh/ruff&quot;&gt;ruff&lt;/a&gt;：速度极快的 linter。它拥有几乎与 Flake8 相同的功能，包括一些流行的插件。此外，它具有与 autoflake、isort、pydocstyle 和 pyupgrade 等工具相同的功能。因此，它基本上是检测 Python 代码的瑞士军刀。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/pola-rs/polars&quot;&gt;polars&lt;/a&gt;：更快的 DataFrames，是超级广泛使用的 pandas 的性能竞争对手。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/sansyrox/robyn&quot;&gt;Robyn&lt;/a&gt;：带 Rust 运行时的异步 Python web 框架。这有一篇博客关于《&lt;a href=&quot;https://sansyrox.medium.com/robyns-plans-for-2023-7eda52011563&quot;&gt;Robyn 的 2023 年路线图&lt;/a&gt;》。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;Rust 目前的热度极高，未来它将融入到更多 Python 相关的项目和工具中。Python + Rust 的组合在未来的就业市场上，也可能有很高的需求。&lt;/div&gt;
&lt;h2&gt;趋势二：Web 应用&lt;/h2&gt;
&lt;div&gt;从历史上看，用户界面并不是 Python 的强项。然而，最近机器学习和数据应用的兴起，催生了一批”使用纯 Python 的 Web UI”框架，例如 &lt;a href=&quot;https://github.com/streamlit/streamlit&quot;&gt;Streamlit&lt;/a&gt;、&lt;a href=&quot;https://github.com/zauberzeug/nicegui&quot;&gt;NiceGUI&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/pynecone-io/pynecone&quot;&gt;Pynecone&lt;/a&gt;。这样的框架为 Pythonistas 提供了构建 Web 应用的快捷方式，不再需要学习 JavaScript+HTML+CSS 技术栈。&lt;/div&gt;
&lt;div&gt;另一条线路是浏览器中的 Python。通过 &lt;a href=&quot;https://pyodide.org/en/stable/&quot;&gt;Pyodide&lt;/a&gt;、&lt;a href=&quot;https://pyscript.net/&quot;&gt;PyScript&lt;/a&gt;和相关工具，这已经实现了。它的基础推动者是与所有主流浏览器兼容的 WASM (WebAssembly)。在写本文时， CPython 源码库中已经有了对 CPython 的 WASM 构建的实验性支持。如果你想深入了解，可以查看 &lt;a href=&quot;https://youtu.be/oa2LllRZUlU&quot;&gt;Python 3.11 in the Web Browser&lt;/a&gt;，这是 Cristian Heimes 在 PyConDE 2022 上的演讲。&lt;/div&gt;
&lt;div&gt;WASM 的故事还处于早期阶段，但它有着巨大的潜力，将使 Python 更容易访问并支持新的使用场景。我希望在不久的将来这个领域会有大量的创新。&lt;/div&gt;
&lt;h2&gt;趋势三：类型安全&lt;/h2&gt;
&lt;div&gt;CPython 对类型的支持在不断发展。例如，Python 3.10 发布了 4 个与类型相关的 PEP, 3.11 发布了 5 个。此外，PyCon 还有专门的 Typing Summit。与此同时，与类型相关的工具已经成熟化和多样化。例如，现在有一大把静态类型检查器可供选择（例如 mypy、Pyright、pytype 和 Pyre）。此外，一些包（例如 pydantic）可以在运行时巧妙地利用类型信息。（延伸阅读：&lt;a href=&quot;https://mp.weixin.qq.com/s/l8FyTp_oxdBEcg95fgWrDA&quot;&gt;介绍几款 Python 类型检查工具&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;&lt;code&gt;*args, **kwargs&lt;/code&gt; 的时代即将结束，它们将被带有类型注释的签名所取代。类型极大地提高了代码可读性。当可读性与便利的 IDE 相结合，阅读庞大的 Python 代码库将变得相对容易。另一方面，在习惯了类型信息带来的超能力之后，无类型的代码库会更让人感到难受。&lt;/div&gt;
&lt;div&gt;无论现今和未来的趋势如何，Python 比以往任何时候都更受欢迎。在写本文时（2023 年 2 月），PyPI 中有 431k 个项目和 665k 个用户。在“how often language tutorials are searched in Google”中，Python 以 27.93% 的份额领先（&lt;a href=&quot;https://pypl.github.io/PYPL.html&quot;&gt;来源&lt;/a&gt;）。Reddit 上的 r/Python 话题有 1.1 万订阅，r/learnpython 有 68 万订阅。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 为什么如此设计？</title>
            <link>https://pythoncat.top/posts/2022-12-18-design/</link>
            <guid>https://pythoncat.top/posts/2022-12-18-design/</guid>
            <description>两年半以来，Python为什么系列是我主要的创作方向，这些文章由我强烈的问题意识驱动，自认为有好几篇在整个 Python 社区中都属于上乘之作。现整理在 Github 上，欢迎给我提新的话题</description>
            <pubDate>Sun, 18 Dec 2022 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;大概两年半前，我萌生了要创作一个新的系列文章的想法，也就是“&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;Python为什么&lt;/a&gt;”，试图对 Python 的语法及特性提出“为什么”式的问题，以此加深对它的理解，探寻使用技巧、发展演变、设计哲学等话题。&lt;/div&gt;
&lt;div&gt;一直以来，我都是一个有着较强问题意识的充满着好奇心的人，擅长于识别出相似东西的差异，并从差异性上发现事物的独特意义。&lt;/div&gt;
&lt;div&gt;于是，当将 Python 与其它编程语言作比较时，加上阅读及&lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;翻译了一些 PEP&lt;/a&gt; 从而积攒了一些素材后，我就得到了很多的小发现。当确认了国内外的技术社区里缺少这方面的文章后，我就更确信了这件事的独特价值。&lt;/div&gt;
&lt;div&gt;我当时有个天真的想法，觉得可以按照“十万个为什么”的方式，写出源源不断的文章……&lt;/div&gt;
&lt;div&gt;刚开始的 2020 年下半年，我创作力旺盛，写了约 20 篇“Python为什么”系列文章！然而，到了 2021 年，仅有 2 篇！再到 2022 年，也是仅仅 2 篇！！……&lt;/div&gt;
&lt;div&gt;时间都去哪儿了？怎么我才稍稍微偷了个懒儿，它就不见了呢？本来计划有不少想写的话题的，怎么拖着拖着就忘了该怎么写了呢……&lt;/div&gt;
&lt;div&gt;最近眼看到了年末，我越想越是有些不甘，于是，花了几天时间，好好梳理了下“Python为什么”系列文章，优化了 Github 的介绍内容，准备认真把这个系列重拾起来！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;我把之前调查问卷里遗留的问题，以及其它计划要写的话题放在 &lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/issues&quot;&gt;Issues&lt;/a&gt; 跟踪，欢迎大家来提问题/给建议/指导写作/监督催更……&lt;/div&gt;
&lt;div&gt;下面放出的是目前系列文章的介绍，恳请喜欢本系列的同学给颗 star 鼓励一下！（内容会不断更新/增长，请以 Github 主页为准。）&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你在手机微信端阅读，由于链接跳转麻烦，建议你通过这个&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUyOTk2MTcwNg==&amp;amp;action=getalbum&amp;amp;album_id=1338406397180084225&amp;amp;scene=126#wechat_redirect&quot;&gt;合集的链接&lt;/a&gt;进行阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;文章列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/0-design-and-history-FAQ.md&quot;&gt;Python 设计和历史的常见问题&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Python 官方提供了约 30 个常见问题的 FAQ，你可以从中快速得到“权威”的解释&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/1-why-design-len()-and-not-x.len().md&quot;&gt;Python 为什么用 len() 函数，不用 x.len() 风格？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;介绍了《流畅的Python》及 Guido 的解释&lt;/li&gt;
&lt;li&gt;我本人认为这体现了 Python 对世界本质的洞察&lt;/li&gt;
&lt;li&gt;文章顺便回答了：&lt;strong&gt;为什么 Python 的索引从 0 开始计数？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/2-why-use-indentation-to-divide-code-block.md&quot;&gt;Python 为什么使用缩进来划分代码块？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;这是个经典的问题，总会被提起，我总结了 8 个原因&lt;/li&gt;
&lt;li&gt;有不少人对上述 8 个原因并不买账，因此我补充了一个回复：Python 的缩进绝不是反人类的设计！&lt;/li&gt;
&lt;li&gt;Guido 在一次采访中说：严格要求代码缩进确实有点夸张，改用花括号，也不是不可以&lt;/li&gt;
&lt;li&gt;Python 的缩进起源于 ABC，而 ABC 的缩进起源于 60-70 年代的编程畅想&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/3-why-not-use-semicolons-as-terminators.md&quot;&gt;Python 为什么不用分号作语句终止符？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;分号一般有分隔符与终止符两种作用，但 Python 只用分号作为分隔符，却不用它作为终止符， 而是改用换行作为终止符。本文精炼总结了 5 个原因&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/4-why-doesn&apos;t-Python-have-main-function.md&quot;&gt;Python 为什么没有 main 函数？为什么我不推荐写 main 函数？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;main 函数作为某些编程语言的执行入口是强制必要的，然而 Python 这门脚本语言有着自己更为灵活的执行方式&lt;/li&gt;
&lt;li&gt;在我的编程习惯中，我反感那些不假思索的&lt;code&gt;if __name__ == &apos;__main__&apos;&lt;/code&gt; 写法，文中给出了我的编程建议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/5-why-recommend-snake-case.md&quot;&gt;Python 为什么推荐蛇形命名法？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;编程语言中有好几种变量命名风格，最为流行的两种分别是驼峰命名法和蛇形命名法。本文从编程语言的历史发展过程和语言内部的使用习惯角度，解释了为什么 Python 更偏好于蛇形命名法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/6-why-doesn&apos;t-Python-support-i++-increment-syntax.md&quot;&gt;Python 为什么不支持 i++ 自增语法，不提供 ++ 操作符？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;有过 C/C++/Java 等语言的编程经验的开发者会疑惑，为什么 Python 中没有 i++ 这样的语法&lt;/li&gt;
&lt;li&gt;这个问题反映出 Python 中的数字对象跟其它语言中的数字有着根本性的差异；另外，Python   的可迭代对象特性，也深刻影响着语言的诸多设计方面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/7-why-can-Python-use-&apos;a,b=b,a&apos;-to-directly-swap-variable-values.md&quot;&gt;Python 为什么只需一条语句“a,b=b,a”，就能直接交换两个变量？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;很多人以为“a,b=b,a”（交换变量操作）跟“a,b=1,2”（多变量赋值）一样，都是基于元组解包的特性，然而 CPython 的实现并非如此&lt;/li&gt;
&lt;li&gt;CPython 使用专门的优化指令（即 ROT_TWO、ROT_THREE 和 ROT_FOUR）实现栈顶元素的快捷交换&lt;/li&gt;
&lt;li&gt;当同时交换的元素数量大于 4 个时，解释器才会跟“a,b=1,2”（多变量赋值）一样，基于解包实现变量赋值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/8-why-use-%23-as-a-notation-for-comments.md&quot;&gt;Python 为什么用 # 号作注释符？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;注释符是编程语言中最基础的要素之一，Python 属于“# 号注释符阵营”，原因或许是它遵循着 Shell 等脚本语言的传统&lt;/li&gt;
&lt;li&gt;Python 中不存在“块注释符”，Guido 曾建议使用多行字符串（multi-line strings）来达到块注释的效果，但这种方案在语义上有点怪异&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/9-why-does-Python-have-pass-statement.md&quot;&gt;Python 为什么要有 pass 语句？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;pass 是 Python 独有的一种空操作，其它语言并没有这样的设计&lt;/li&gt;
&lt;li&gt;pass 可以作为一种空间占位符，辅助程序员快速编程，然而这点小用途并非至关重要的&lt;/li&gt;
&lt;li&gt;由于 Python 不使用花括号之类的手段来划分代码块，因此在定义空函数时，pass 就成了一种补齐语法逻辑的方案&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/10-why-does-Python-have-a-weird-&apos;...&apos;-object.md&quot;&gt;Python 为什么会有个奇怪的“…”对象？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;… 是 Python3 在 PEP-3100 中引入的一个内置常量，与 Ellipsis 表示同一个对象&lt;/li&gt;
&lt;li&gt;官方说它们是单例的，然而这有违事实。要么是文档错了，要么这是一个 Bug ？&lt;/li&gt;
&lt;li&gt;… 有什么用处，能够解决什么问题？文中介绍了 4 个用途：扩展切片语法、表达“未完成的代码”语义、Type Hint 用法、表示无限循环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/11-why-does-Python-support-arbitrary-truth-value-testing.md&quot;&gt;Python 为什么能支持任意的真值判断？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;这也是 Python 与众不同的一个特性，它将其它语言中仅限于布尔类型的操作（if 或 while 或布尔操作 and、or、not），扩展到了任意对象，带来了极大的灵活性&lt;/li&gt;
&lt;li&gt;真值判断的结果取决于__bool__() 和 __len__() 这两个魔术方法的返回值&lt;/li&gt;
&lt;li&gt;Python 甚至可以对数字对象作真值判断（表示 0 的数为 False，其它数为 True）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/12-why-do-Python-functions-default-to-return-None.md&quot;&gt;Python 函数为什么会默认返回 None？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Python 隐性地为没有带 return 的函数添加一个 return 操作，即默认返回 None 值，这是由解释器强行注入的逻辑。这意味着：Python 中不存在无返回值的函数&lt;/li&gt;
&lt;li&gt;为什么 Python 要强制令所有函数都有一个返回值呢？为什么它不支持无返回值的空函数呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/13-why-doesn&apos;t-Python-have-the-void-keyword.md&quot;&gt;Python 为什么没有 void 关键字？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;void 通常指的是一种类型（type），但是它没有具体的值（value）。文中介绍了其它语言需要使用 void 关键字实现的两种功能&lt;/li&gt;
&lt;li&gt;Python 舍弃了表示“没有值的类型”的 void，统一使用表示“仅有一个值的类型” None，配合前一篇“所有函数必然有返回值”的设计，实现了简单好用的效果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/14-why-is-Python-strongly-typed.md&quot;&gt;Python 为什么是强类型语言，不是弱类型语言？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;动静类型与强弱类型是两组不同维度的概念，不应混为一谈。在编程语言发展的早期，当强弱类型的概念还未提出时，一些大佬使用动静类型来笼统地描述语言的特性，这是历史原因&lt;/li&gt;
&lt;li&gt;如今主流观点以“隐式类型转换”来划分强弱类型，Python 毫无疑问是强类型语言。文中针对几个易混淆的问题，详细解释了为什么 Python 中不存在“隐式类型转换”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/15-why-does-Guido-dislike-lambda-anonymous-functions.md&quot;&gt;Python 之父为什么嫌弃 lambda 匿名函数？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;lambda 语法借鉴自 lisp 语言，却遭到 Python 之父的嫌弃，然而它竟从他的屠刀下幸存，这段故事充满戏剧性&lt;/li&gt;
&lt;li&gt;Python 的 lambda 只支持单行表达式，功能不完备。曾有人提议增强 lambda 语法，Python 之父认为那不是好的设计，因而否决了&lt;/li&gt;
&lt;li&gt;Guido 提出要一次性移除 reduce()、map()、filter() 以及 lambda，但最后他妥协了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/16-why-doesn&apos;t-Python-support-the-switch-statement.md&quot;&gt;Python 为什么不支持 switch 语句？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;大多数语言都提供了 switch 语句或者极其相似的东西，但在 Python 之父的裁决下，Python 不提供 switch 语句&lt;/li&gt;
&lt;li&gt;文章介绍了试图引入 switch 语句的 PEP-275 与 PEP-3103，总结了这两个提案的要点以及被否决的原因&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/17-why-is-%5B%5D-faster-than-list().md&quot;&gt;Python 疑难问题：[] 与 list() 哪个快？为什么快？快多少呢？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;两种创建列表的 [] 与 list() 写法，哪一个更快呢，为什么它会更快呢？&lt;/li&gt;
&lt;li&gt;文章通过字节码与执行过程的分析，解释了两者执行速度的差异&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/18-why-aren&apos;t-Python-built-in-functions-a-panacea.md&quot;&gt;为什么说 Python 内置函数并不是万能的？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;内置函数的名称并不是关键字，而内置作用域位于名称查找的最低优先级，因此在调用时，某些内置函数/类型的执行速度就明显慢于它们对应的字面量表示法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/19-why-is-inheriting-Python-built-in-types-a-problem.md&quot;&gt;为什么继承 Python 内置类型会出问题？！&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;由《流畅的Python》中的例子，引出 Python 在内置类型子类化时不合常理的话题&lt;/li&gt;
&lt;li&gt;分析魔术方法的底层实现逻辑及调用关系，解释内置类型存在的问题&lt;/li&gt;
&lt;li&gt;介绍了内置类型子类化的最佳实践&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/20-why-can-Python&apos;s-f-string-concatenate-strings-and-numbers.md&quot;&gt;为什么 Python 的 f-string 可以拼接字符串与数字？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Python 是强类型语言，在不经过强制类型转换的情况下，字符串无法拼接数字&lt;/li&gt;
&lt;li&gt;介绍了 PEP-498 实现 f-string 的原理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/21-why-don&apos;t-Python-slices-index-out-of-bounds.md&quot;&gt;Python 的切片为什么不会索引越界？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;切片是不少编程语言的特性，Python 的切片不仅功能完善，而且在使用上更为灵活&lt;/li&gt;
&lt;li&gt;索引越界是一个常见的问题，Python 切片使用了几条规则，屏蔽了可能导致出错的情况&lt;/li&gt;
&lt;li&gt;文章介绍了 Python 的解决方案，但是也留下了一个疑问：为什么 Python 的切片语法要允许索引超出边界呢，为什么不设计成抛出索引错误？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/22-why-doesn&apos;t-range()-generate-an-iterator.md&quot;&gt;为什么 range() 生成的不是迭代器？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;有很多内置方法可以生成迭代器，然而似乎只有 range() 生成的是可迭代对象，这个 range() 显得非常独特。文中给出了我对此的猜想&lt;/li&gt;
&lt;li&gt;我还注意到 range 是一种不可变序列，然而它跟字符串这种不可变序列相比，也有着独特的表现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/23-why-does-Python-keep-explicit-self.md&quot;&gt;Python 为什么要保留显式的 self ？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;这也是一个常见问题。这里给出了官方文档的解释，另外附了 Guido 的一篇博客全文&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/24-why-doesn&apos;t-Python-design-a-do-while-loop.md&quot;&gt;Python 为什么不设计 do-while 循环结构？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;在 C/C++、C#、PHP、Java、JavaScript 等语言中，do-while 是一种基本结构。Python 为什么不沿袭它们的传统呢？有什么特殊的考虑？&lt;/li&gt;
&lt;li&gt;文章列举了其它语言中 do-while 语法的主要使用场景，解释了为什么 Python 可以不用这种结构&lt;/li&gt;
&lt;li&gt;介绍了 PEP-315 试图引入 do-while 结构的尝试，以及 Guido 的反对意见&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn/blob/master/StandardsTrack/3105--%E6%94%B9%20print%20%E4%B8%BA%E5%87%BD%E6%95%B0.md&quot;&gt;为什么 Python 3 把 print 改为函数？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Python3 与 Python2 最显眼的一个区别就是：print 语句变成了 print() 函数&lt;/li&gt;
&lt;li&gt;PEP-3105 Make print a function 是对这个问题最好的回答&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/25-why-is-it-the-most-magical-magic-method-in-Python.md&quot;&gt;为什么说 Python 最会变魔术的魔术方法是它？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;__missing__() 是仅在内置类型的子类上才存在的魔术方法，似乎是唯一的特例&lt;/li&gt;
&lt;li&gt;__missing__() 极为特殊，Python 解释器为它开了后门，实现了最为罕见的“魔术方法间调用”逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/26-why-does-Python-use-elif-instead-of-else-if.md&quot;&gt;Python 为什么用”elif“，而不是“else if”？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;elif 写法相比于“else if”更为简洁，这种写法并非 Python 首创。Guido 发推特解释了这种写法的来源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;当在两年半前写下第一篇“Python为什么”系列的时候，我无法想象自己会在 2023 年到来之际写下这一篇宣告重新起航的小结，更无法想象是在下一个两年半，或者五年半或者更久，再次写下一篇新的总结。谁说得准呢！&lt;/div&gt;
&lt;div&gt;但是，不忘初心，珍惜当下的决心，树立砥砺前行的恒心，我可以的！&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 缩进语法的起源：上世纪 60-70 年代的大胆创意</title>
            <link>https://pythoncat.top/posts/2022-12-13-indentation/</link>
            <guid>https://pythoncat.top/posts/2022-12-13-indentation/</guid>
            <description>Guido van Rossum 在推特上转发的一篇文章引起了我的兴趣，本文追溯历史，探寻 Python 缩进语法的古老起源</description>
            <pubDate>Tue, 13 Dec 2022 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;上个月，Python 之父 Guido van Rossum 在推特上转发了一篇文章《&lt;a href=&quot;https://inference-review.com/article/the-origins-of-python&quot;&gt;The Origins of Python&lt;/a&gt;》，引起了我的强烈兴趣。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;众所周知，Guido 在 1989 年圣诞节期间开始创造 Python，当时他就职于荷兰数学和计算机科学研究学会（简称 CWI），曾参与设计与实现了一门用于教学的 ABC 语言。这段工作经历以及 ABC 语言的某些设计思想对 Python 有着重要的影响。&lt;/div&gt;
&lt;div&gt;文章标题是“Python 的起源”，文章作者 Lambert Meertens 是 Guido 在 CWI 时的导师，以同事亲历者的视角，讲述 Python 从无到有的起源过程。这样的文章我还未曾读过，因此饶有兴趣。&lt;/div&gt;
&lt;div&gt;文章内容跟 Python 直接相关的部分并不多，作者花了较大篇幅介绍 ABC 项目的演变，讨论了编程语言的设计（特别强调的是简洁性 &lt;strong&gt;Simplicity&lt;/strong&gt;）。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;最引起我兴趣的内容是：缩进语法的设计！&lt;/strong&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;More striking is the use of indentation. Although it was common in programs written in ALGOL 60 or its descendants, such as Pascal, to use indentation as a typographical layout feature for clarifying the grouping of commands, this was an entirely optional presentation choice, made purely for the benefit of the human reader. In an article by P. J. Plauger entitled “&lt;strong&gt;Signal and Noise in Programming Languages&lt;/strong&gt;,”&lt;a href=&quot;https://inference-review.com/article/the-origins-of-python#endnote-16&quot;&gt;16&lt;/a&gt; we found the (then) radical idea to “&lt;strong&gt;have the compiler read the same signal as we human beings, and let the indenting control grouping&lt;/strong&gt;,” a suggestion we followed with enthusiasm. Indentation to indicate that a suite of commands belong together subsequently became mandatory in B0 programs, a design choice that has been maintained throughout all iterations.&lt;a href=&quot;https://inference-review.com/article/the-origins-of-python#endnote-17&quot;&gt;17&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;——节选自《The Origins of Python》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;简单概括：当时在设计新的编程语言时，他们受到了一篇文章的强烈影响，决定仅采用缩进语法来控制代码块的分组。核心思想是“have the compiler read the same signal as we human beings”，为了代码简洁性及理解一致性，舍弃了其它的代码分组方案。&lt;/div&gt;
&lt;div&gt;我极为推崇 Python 的强制缩进语法，曾写过一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/byhJnKoKSDnhUNUE9WWopw&quot;&gt;Python为什么使用缩进来划分代码块？&lt;/a&gt;》介绍了这种设计的 8 个原因，但是，该文收到了大量的反对声，因此，我又补写了一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/pi1x6lT88dMmfUUqcVet-A&quot;&gt;Python 的缩进是不是反人类的设计？&lt;/a&gt;》。&lt;/div&gt;
&lt;div&gt;我知道自己的两篇文章不足以说服那些讨厌 Python 缩进的人，但是，如果有更多资料介绍这项设计的原因及思想来源的话，或许就能稍微地改观某些人的看法，同时也提供给那些喜欢这项设计的人一些信心~&lt;/div&gt;
&lt;div&gt;作为 ABC 语言的继承者，Python 的缩进语法应该主要来源于它。因此，我决定沿着前文的线索，继续挖掘它们设计缩进语法的起源。&lt;/div&gt;
&lt;div&gt;上文提到的文章标题为《&lt;a href=&quot;https://dl.acm.org/doi/10.1145/800181.810322&quot;&gt;编程语言中的信号与噪声&lt;/a&gt;》（Signal and Noise in Programming Languages），发表于 1975 年的 ACM 年会论文集，作者 P.J. Plauger 是全球知名的计算机科学家、C/ C++技术专家以及 The Standard C Library、Standard C : A Reference 和 The Standard Template Library 等图书的作者。&lt;/div&gt;
&lt;div&gt;该篇文章想要区分编程语言的哪些语法是对读者有用的信号、哪些仅是无用的噪声。文中提到了一个编程理论：“&lt;strong&gt;常说的东西应该言简意赅（things which get said a lot should be concise）&lt;/strong&gt;”。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;由于代码经常要分组分块，因此，“信号与噪声”一文将&lt;code&gt;begin...end&lt;/code&gt; 及&lt;code&gt;do...end&lt;/code&gt; 这两种当时常见的代码分组语法批评为糟糕的设计。它不反对花括号“{…}”的语法设计，但是提出了一种更为激进的设计，也就是仅用缩进来控制代码分组（let the indenting control grouping）。&lt;/div&gt;
&lt;div&gt;按我的理解，P.J. Plauger 建议我们移除编程语言中的噪声。人们在阅读代码时，可以直观地根据代码的缩进层级将它们分组，因此缩进本身就是一种有意义的信号，如果激进地让机器也做到“所见即所得”的话，那甚至连“{…}”这种足够言简意赅的设计也不需要了。&lt;/div&gt;
&lt;div&gt;P.J. Plauger 是个擅于总结编程风格/原则的人，他曾合作编写过一本《The Elements of Programming Style》（译本：编程格调），全书介绍了 70 多条最佳实践和编程规则。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;只不过，相比于他提出的那些经典的编程规则，“使用缩进来分组代码块”不仅在 40 多年前是一条激进而少人接受的风格，它直到今天依然令某些人无法认同。&lt;/div&gt;
&lt;div&gt;CWI 的团队当初在设计 ABC 语言时，激进地采用了缩进作分组的设计。通过溯源那篇“古老的”文章，我们知道了这种设计不是他们突然蹦出的，而是有着某种设计思想的指导，同时这也意味着，Python 的缩进设计除了有“终身仁慈独裁者（BDFL）”的个人偏好外，还隐含了这一层思想脉络的渊源。&lt;/div&gt;
&lt;div&gt;另外，《The Origins of Python》中还提供了两个比《编程语言中的信号与噪声》更早的起源：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;1965 年的 ISWIM 编程语言（“&lt;strong&gt;I&lt;/strong&gt;f you &lt;strong&gt;S&lt;/strong&gt;ee &lt;strong&gt;W&lt;/strong&gt;hat &lt;strong&gt;I&lt;/strong&gt; &lt;strong&gt;M&lt;/strong&gt;ean”的首字母缩写）。它可能是有据可考最早使用缩进分组代码块的语言（尽管它没有实现），其设计者在《&lt;a href=&quot;https://web.archive.org/web/20220323111045/https://www.cs.cmu.edu/~crary/819-f09/Landin66.pdf&quot;&gt;The Next 700 Programming Languages&lt;/a&gt;》中称之为“&lt;a href=&quot;https://en.wikipedia.org/wiki/Off-side_rule&quot;&gt;Off-side rule&lt;/a&gt;”（越位规则）&lt;/li&gt;
&lt;li&gt;1974 年唐纳德·克努特（Donald Knuth，著名计算机科学家、图灵奖获得者，经典巨著《计算机程序设计艺术》的作者）发表在 ACM 通讯的文章《 &lt;a href=&quot;https://doi.org/10.1145/356635.356640&quot;&gt;Structured Programming with Go To Statements&lt;/a&gt;》，他在畅想未来的编程语言时说：We will perhaps eventually be writing only small modules which are identified by name as they are used to build larger ones, so that devices like indentation, rather than delimiters, might become feasible for expressing local structure in the source language。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;值得注意的是，唐纳德提供的参考材料正是 1965 年 ISWIM 之父的文章《&lt;a href=&quot;https://web.archive.org/web/20220323111045/https://www.cs.cmu.edu/~crary/819-f09/Landin66.pdf&quot;&gt;The Next 700 Programming Languages&lt;/a&gt;》，里面收录了多位大佬对于缩进的讨论观点。&lt;/div&gt;
&lt;div&gt;受限于当时的计算机硬件及编辑器工具，以及考虑到印刷对代码排版的现实性影响，纯缩进分组的代码确实可能会带来一些麻烦。因此，这些编程界的先驱们仅仅是在大胆畅想未来的编程语言的语法，当时并没有编程语言作出了实现。&lt;/div&gt;
&lt;div&gt;从 1965 年的 ISWIM，到 1974 年唐纳德的畅想，再到 1975 年 P.J. Plauger 激进的想法，再到 1980 年代 ABC 及 Python 的落地实现。20 多年的时间，说长确实是挺长了。&lt;/div&gt;
&lt;div&gt;如今 2022 年即将过去，Python 已经度过了它的“而立之年”， 受这种设计思想影响的编程语言也遍地开花：据维基百科统计，有近 30 门语言使用“Off-side rule”。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;尽管某些语言（如 Scala、Nemerle、Haskell）只是可选性或部分性支持，但这份列表意味着在花括号占据统治地位的时代，缩进的星星之火依然迸发着顽强的生命力。畅想未来，我相信这份列表会加进更多语言，但愿那时可以打破 Python 一枝独秀的局面。&lt;/div&gt;
&lt;div&gt;现在作一下总结吧。本文最先关注的是 Python 之父年轻时的导师的文章“Python 的起源”，但是我发现最吸引人的还是老生常谈的缩进话题，于是文章主题转向了“Python 的缩进语法的起源”。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;不可否认，Python 的缩进语法属于是较为大胆的编程风格，但换个角度，你也可以认为它很前卫，因为它本就起源于计算机科学家们在畅想未来的编程语言时的一种创意。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;缩进语法简洁、紧凑、清晰，它是营造出 Python 之美的最大功臣之一。人生苦短，我用 Python！&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>谷歌、微软、Meta？谁才是 Python 最大的金主？</title>
            <link>https://pythoncat.top/posts/2022-11-21-sponsors/</link>
            <guid>https://pythoncat.top/posts/2022-11-21-sponsors/</guid>
            <description>维护 Python 这个大规模的开源项目每年花约 200 万美元，得益于谷歌、微软、Meta 这样的公司赞助，PSF 现在过得还可以。本文扒一扒这几个大金主</description>
            <pubDate>Mon, 21 Nov 2022 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你知道维护 Python 这个大规模的开源项目，每年需要多少资金吗？&lt;/div&gt;
&lt;div&gt;答案是：&lt;strong&gt;约 200 万美元！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.python.org/psf/&quot;&gt;PSF&lt;/a&gt;（Python 软件基金会）在 2022 年 6 月发布了 2021 的&lt;a href=&quot;https://s3.dualstack.us-east-2.amazonaws.com/pythondotorg-assets/media/files/PSF_Annual_report_2021_final.pdf&quot;&gt;年度报告&lt;/a&gt;，其中披露了以下这份支出明细（单位：千美元）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;总支出金额 196 万美元，基本与 2020 年持平，不知道这个数额有没有超出你的预期呢？&lt;/div&gt;
&lt;div&gt;另外，在收入方面，2021 年总收入为 271 万，因此年度净结余为 75 万。（PS.加上之前的资产，目前基金会还有 506 万~）&lt;/div&gt;
&lt;div&gt;PSF 是一个独立的非营利性机构， 致力于促进 Python 语言的发展与推广、促进 Python 国际化多元化社区的繁荣。虽然不以营利为目标，但不可否认的是，它也有着一笔不菲的金钱诉求：有更多的收入，才能实现更大的目标，才能发挥出基金会的更大价值。&lt;/div&gt;
&lt;div&gt;比如，尽管 PSF 在 2001 年就成立了，但是，直到 20 年后，它才拥有了第一位全职的开发者！也就是说，长久以来，基金会的其他成员及核心开发者们都只是兼职或志愿者！&lt;/div&gt;
&lt;div&gt;将来若有更多收入的话，PSF 很有可能会再次扩员全职的开发者，必然能创造出更多的可能性！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;既然 PSF 开销不小，诉求也大，那么，它目前的资金是怎么来的呢？&lt;/div&gt;
&lt;div&gt;PSF 主要的资金来源是&lt;a href=&quot;https://www.python.org/psf/sponsors/&quot;&gt;大大小小的金主&lt;/a&gt;所赞助，比如，JetBrains（Pycharm 出自这家公司）恰巧正在为 PSF 举行年终筹款。通过以下链接可以 7 折购买 Pycharm Pro，全部销售额将捐献给 Python。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;JetBrains 活动（2022.11.22结束）：&lt;a href=&quot;https://blog.jetbrains.com/zh-hans/pycharm/2022/11/jetbrains-pycharm-python/&quot;&gt;https://blog.jetbrains.com/zh-hans/pycharm/2022/11/jetbrains-pycharm-python/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;PSF 将赞助者们&lt;a href=&quot;https://www.python.org/psf/sponsors/&quot;&gt;分成了七类&lt;/a&gt;：远景的（Visionary）、持续的（Sustainability）、保持的（Maintaining）、贡献的（Contributing）、支持的（Supporting）、伙伴的（Partner）、联合的（Associate）。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;标题中的谷歌、微软、Meta 都是 PSF 最高级别的远景赞助者。但是，谁才是 Python 最大的金主呢？&lt;/div&gt;
&lt;div&gt;下面，我将根据相关新闻资讯，梳理大家比较感兴趣的这三家公司对 PSF 的赞助。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;谷歌从 2010 年起成为 PSF 的赞助者，在 2021 年 2 月成为&lt;a href=&quot;https://cloud.google.com/blog/products/open-source/supporting-the-python-ecosystem&quot;&gt;首个远景赞助者&lt;/a&gt;（赞助 35 万美元，以及其它资源）。资金主要用于提升 Python 生态的供应链安全，资源主要为 Google Cloud 的产品：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;开发用于检测 PyPI 恶意软件的产品&lt;/li&gt;
&lt;li&gt;改善 Python 的基础设施工具与服务&lt;/li&gt;
&lt;li&gt;2021 年资助 CPython 一名常驻开发者（Developer-in-Residence），他全职分析 CPython 项目的维护优先级，帮助解决积压的工作&lt;/li&gt;
&lt;li&gt;赞助谷歌云基础设施，比如用于 Pypi 的云存储，谷歌云公开数据集（Google Cloud Public Datasets）支持 Pypi 的下载统计、项目元数据查询分析&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;除此之外，谷歌还参与赞助了 Python 的各类活动，比如，2022 年 10 月为期 5 天的核心开发者 &lt;a href=&quot;https://pythoninsider.blogspot.com/2022/10/python-core-development-sprint-2022-311.html&quot;&gt;sprint 活动&lt;/a&gt; 。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;（2022年核心开发者 Sprint 活动合影）&lt;/div&gt;
&lt;div&gt;微软从 2006 年起成为 PSF 的赞助者，在 2021 年 4 月成为&lt;a href=&quot;https://devblogs.microsoft.com/python/supporting-the-python-community/&quot;&gt;远景赞助者&lt;/a&gt;（赞助 15 万美元，以及其它资源）。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;资助打包工作组，助力改善 PyPI 和打包生态&lt;/li&gt;
&lt;li&gt;包括 Guido van Rossum 在内的 6 人团队，兼职为 Faster CPython 项目作贡献&lt;/li&gt;
&lt;li&gt;雇用了 Python 生态系统中关键开源项目的几个核心贡献者和维护者&lt;/li&gt;
&lt;li&gt;通过 VS Code 相关插件、pyright、Azure 相关服务等，为 Python 社区作贡献&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;其中比较瞩目的是包括 Python 之父在内的豪华开发团队，可以通过微软发布的&lt;a href=&quot;https://devblogs.microsoft.com/python/python-311-faster-cpython-team/&quot;&gt;《A Team at Microsoft is Helping Make Python Faster》&lt;/a&gt; 了解这支团队以及正在做的事。（正在开发 3.12，可查阅《&lt;a href=&quot;https://mp.weixin.qq.com/s/GWByw61O56gJ7qUisAGQNw&quot;&gt;Python 3.12 Goals&lt;/a&gt;》）&lt;/div&gt;
&lt;div&gt;除此之外，微软也是各类活动的主要赞助方之一，比如 2022 年 10 月的一场 &lt;a href=&quot;https://devblogs.microsoft.com/python/python-hacktoberfest-2022/&quot;&gt;Hacktoberfest&lt;/a&gt; ，比如 2019 年的核心开发者 &lt;a href=&quot;https://pyfound.blogspot.com/2019/10/cpython-core-developer-sprint-2019.html&quot;&gt;sprint 活动&lt;/a&gt; 。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;（2019年核心开发者 Sprint 活动合影）&lt;/div&gt;
&lt;div&gt;Meta（即 Facebook）在 2022 年 3 月成为&lt;a href=&quot;https://pyfound.blogspot.com/2022/03/meta-deepens-its-investment-in-python.html&quot;&gt;远景赞助者&lt;/a&gt;（赞助 30 万美元）。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;资助 2022 年的 Developer-in-Residence&lt;/li&gt;
&lt;li&gt;通过 Cinder 解释器给上游贡献，提升 CPython 解释器性能&lt;/li&gt;
&lt;li&gt;维护和支撑 PyPI，管理 Python 知识产权，提供托管 Python 发行版的基础设施&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;同样地，Meta 也是 Python 各类活动的主要赞助方之一，比如，2016 年 9 月的第一期核心开发者&lt;a href=&quot;https://blog.python.org/2016/09/python-core-development-sprint-2016-36.html&quot;&gt;sprint 活动&lt;/a&gt;，这为之后每年的惯例活动开了一个好头！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;（2016年核心开发者 Sprint 活动合影）&lt;/div&gt;
&lt;div&gt;另外，值得一提的是，在 2019 年 12 月，陈和扎克伯格基金会（Chan Zuckerberg Initiative）连同 Mozilla 一起给 PSF &lt;a href=&quot;https://pyfound.blogspot.com/2019/12/moss-czi-support-pip.html&quot;&gt;赞助了 40.7 万美元&lt;/a&gt;，而扎克伯格正是 Meta 的掌舵人。&lt;/div&gt;
&lt;div&gt;这几家科技巨头对 Python 的赞助有一个明显的共同点，即有不少资金用于 Python 基础设施的维护。这里只给大家分享几个关键的数据（出自&lt;a href=&quot;https://s3.dualstack.us-east-2.amazonaws.com/pythondotorg-assets/media/files/PSF_Annual_report_2021_final.pdf&quot;&gt;年度报告&lt;/a&gt;，统计维度：2021 年）：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;1100 亿次 Python 发行版下载量&lt;/li&gt;
&lt;li&gt;1265 亿次 PyPI 软件包下载量（36.9 万个软件包）&lt;/li&gt;
&lt;li&gt;以上这么多下载量需要 324 PB 数据传输，或 82.2 Gbps 带宽，并且是 24x7x365&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;如此大数量级的服务，其实现的困难程度可想而知，而这仅是冰山一角。&lt;/div&gt;
&lt;div&gt;回到前文的话题：谁才是 Python 最大的金主呢？&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;如果你只看它们成为远景赞助者时单次的资金量的话，容易得出一个答案，但是，这没有意义！&lt;/div&gt;
&lt;div&gt;因为，每个赞助方对 Python 的赞助都是全方位的长期持续性的（比如谷歌的云服务、微软的人力投入、对 CPython 及开源生态的贡献、每年各式各样的活动、宣传与推广），很多内容根本无法直接通过金钱来衡量！&lt;/div&gt;
&lt;div&gt;另外，需要说明的是，本文为了话题性及便利性，主要介绍了三家巨头企业成为 PSF 远景赞助者的相关信息，并不代表其它赞助者的贡献不值一提。&lt;/div&gt;
&lt;div&gt;所有赞助者、志愿者、开发者都有一个共同的愿景：那就是希望 Python 语言、Python 生态、Python 社区变得越来越好！&lt;/div&gt;
&lt;div&gt;大家一起自豪地做着一些力所能及的贡献，这才是十分值得称道的事，你觉得呢？&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python冷知识：如何找出新版本增加或删除了哪些标准库？</title>
            <link>https://pythoncat.top/posts/2022-11-19-stdlib/</link>
            <guid>https://pythoncat.top/posts/2022-11-19-stdlib/</guid>
            <description>本文介绍 3.10 版本引入的一个很小的改动，在内置电池瘦身计划的背景下，这个冷知识可谓来得很及时</description>
            <pubDate>Sat, 19 Nov 2022 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;“内置电池”是 Python 最为显著的特性之一，它提供了 200 多个开箱即用的标准库。但是，历经了 30 多年的发展，很多标准库已经成为了不得不舍弃的历史包袱，因为它们正在“漏电”！&lt;/div&gt;
&lt;div&gt;好消息是，Python 正在进行一场“瘦身手术”，详情可查阅：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.python.org/3.12/whatsnew/3.12.html&quot;&gt;Python 3.12 正在移除大量的模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/2_U4wgwjMOdLnC5DAQ7tbQ&quot;&gt;终于，Python 标准库要做“瘦身手术”了！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/XzCqoCvcpFJt4A-E4WMqaA&quot;&gt;聊聊 Python 的内置电池&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;那么，我们会有这样一个话题：当 Python 发布了一个新版本的时候，如何找出它比上一个版本（或者更早版本）增加或删除了哪些标准库呢？&lt;/div&gt;
&lt;div&gt;比如，当 Python 发布 3.11.1 版本时，如何找出它相比于上一个版本（即 3.11.0），增删了哪些标准库呢？&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;也许你马上就想到了一个办法：查看官方的版本变更文档啊~&lt;/div&gt;
&lt;div&gt;没错，官方文档里肯定包含了我们所需的变更信息，但是，每个版本的《&lt;a href=&quot;https://docs.python.org/3/whatsnew/3.11.html&quot;&gt;What’s New&lt;/a&gt;》里信息太多了，这种没有特定目标的搜索，只会费时费力。&lt;/div&gt;
&lt;div&gt;假如要跨多个版本进行比较的话，比如 3.12 与 3.10 间的差异、或者未来的 3.x 跟现在的 3.11 比较，这个方法就更不好用了吧！&lt;/div&gt;
&lt;div&gt;在 3.10 版本之前，想要获知标准库的变化情况，确实不太方便。但是，自 3.10 起，Python 提供了一个非常便捷的方法：&lt;code&gt;sys.stdlib_module_names&lt;/code&gt;！&lt;/div&gt;
&lt;div&gt;官方文档的描述：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;来源：&lt;a href=&quot;https://docs.python.org/zh-cn/3/library/sys.html?#sys.stdlib_module_names&quot;&gt;https://docs.python.org/zh-cn/3/library/sys.html?#sys.stdlib_module_names&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;简单查看下它的内容：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;如上可见，&lt;code&gt;sys.stdlib_module_names&lt;/code&gt; 返回的是一个 frozenset 类型的对象，其元素是所有标准库的名称。&lt;/div&gt;
&lt;div&gt;有了详细的标准库清单后，我们就可以通过以下的步骤，比较出不同 Python 版本间的差异啦：&lt;/div&gt;
&lt;div&gt;（1）获取旧版本的标准库（比如 3.10.0），序列化后存储到文件/数据库中&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import sys
&amp;gt;&amp;gt;&amp;gt; import pickle
&amp;gt;&amp;gt;&amp;gt; with open(&quot;libs&quot;, &quot;wb&quot;) as f:
...     pickle.dump(sys.stdlib_module_names, f)
...&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;（2）获取新版本的标准库（比如 3.11.0），与旧版本的标准库进行比较&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import sys
&amp;gt;&amp;gt;&amp;gt; import pickle
&amp;gt;&amp;gt;&amp;gt; with open(&quot;libs&quot;, &quot;rb&quot;) as f:
...     old_libs = pickle.load(f)
...
&amp;gt;&amp;gt;&amp;gt; sys.stdlib_module_names - old_libs
frozenset({&apos;_typing&apos;, &apos;_scproxy&apos;, &apos;_tokenize&apos;, &apos;tomllib&apos;})
&amp;gt;&amp;gt;&amp;gt; old_libs - sys.stdlib_module_names
frozenset({&apos;binhex&apos;})&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;从以上示例中，我们可得知，3.11 相比 3.10 增加了&lt;code&gt;_typing&lt;/code&gt; 、&lt;code&gt;_scproxy&lt;/code&gt;、&lt;code&gt;_tokenize&lt;/code&gt; 以及 &lt;code&gt;tomllib&lt;/code&gt;，同时它也减少了一个&lt;code&gt;binhex&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;简简单单几行代码，这种方法比翻阅繁杂的文档要便捷且准确得多了。&lt;/div&gt;
&lt;div&gt;值得注意的是，&lt;code&gt;sys.stdlib_module_names&lt;/code&gt; 是 3.10 版本的新特性，在它之前，有一个相似的&lt;code&gt;sys.builtin_module_names&lt;/code&gt; ，但它返回的只是被解释器使用到的内置模块：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;那么，除了上文提到的获知 Python 标准库删减情况的用途之外，这个新特性还有什么用处呢？换句话说，&lt;strong&gt;Python 官方为什么突然新增了&lt;code&gt;sys.stdlib_module_names&lt;/code&gt; 这项功能呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;其实，社区中有一个三方库&lt;code&gt;stdlib-list&lt;/code&gt; ，可用于获取部分 Python 版本（2.6-2.7；3.2-3.9）的标准库清单。这个库的作者在文档中提到了&lt;a href=&quot;https://github.com/jackmaney/python-stdlib-list&quot;&gt;他的诉求&lt;/a&gt;，也提到其它开发者有着同样的&lt;a href=&quot;https://stackoverflow.com/questions/6463918/how-to-get-a-list-of-all-the-python-standard-library-modules&quot;&gt;诉求&lt;/a&gt;：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;开发了 &lt;code&gt;sys.stdlib_module_names&lt;/code&gt; 这项功能的核心开发者 Victor Stinner 也总结了几个使用场景：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当计算项目的依赖关系时，忽略标准库中的模块：&lt;a href=&quot;https://github.com/jackmaney/pypt/issues/3&quot;&gt;https://github.com/jackmaney/pypt/issues/3&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当监测第三方代码的执行时，忽略标准库，使用监测工具的&lt;code&gt;--ignore-module&lt;/code&gt;选项：&lt;a href=&quot;https://stackoverflow.com/questions/6463918/how-can-i-get-a-list-of-all-the-python-standard-library-modules&quot;&gt;https://stackoverflow.com/questions/6463918/how-can-i-get-a-list-of-all-the-python-standard-library-modules&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在格式化 Python 代码文件时，对 import 的标准库模块进行分组。isort 库包含了标准库的列表，它依据 Python 在线文档生成了每个版本的标准库清单：&lt;a href=&quot;https://github.com/PyCQA/isort/tree/develop/isort/stdlibs&quot;&gt;https://github.com/PyCQA/isort/tree/develop/isort/stdlibs&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;从这些使用场景来看，&lt;code&gt;sys.stdlib_module_names&lt;/code&gt; 的作用还真是不小。另外，在写作本文的时候，我从 CPython 的 &lt;a href=&quot;https://github.com/python/cpython/issues/87121&quot;&gt;Issue #87121&lt;/a&gt; 中发现，著名的机器学习库&lt;code&gt;pytorch&lt;/code&gt; 也需要这项功能。&lt;/div&gt;
&lt;div&gt;&lt;code&gt;pytorch&lt;/code&gt; 曾经硬编码了每个 Python 版本的标准库列表，代码冗长，现在已经适配成&lt;a href=&quot;https://github.com/pytorch/pytorch/pull/81520/files&quot;&gt;使用新的方法&lt;/a&gt; ，大大方便了后续的维护：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;11 月 15 日时，Python 3.12 alpha 2 版本发布了，这个版本开始移除大量过时的废弃的内容（标注库、标准库的子模块、类和函数等）。&lt;/div&gt;
&lt;div&gt;感兴趣的同学，可以用本文介绍的“冷知识”，去看看到底出现了哪些变化啦~&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>万万没想到，除了香农计划，Python3.11还有这么多性能提升！</title>
            <link>https://pythoncat.top/posts/2022-11-12-speedup/</link>
            <guid>https://pythoncat.top/posts/2022-11-12-speedup/</guid>
            <description>Python 3.11 版本带来了较大的性能提升，但是，它具体在哪些方面上得到了优化呢？除了著名的“香农计划”外，它还包含哪些与性能相关的优化呢？</description>
            <pubDate>Sat, 12 Nov 2022 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;众所周知，Python 3.11 版本带来了较大的性能提升，但是，它具体在哪些方面上得到了优化呢？除了著名的“香农计划”外，它还包含哪些与性能相关的优化呢？本文将带你一探究竟！&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：Beshr Kayali&lt;/p&gt;
&lt;p&gt;译者：豌豆花下猫@Python猫&lt;/p&gt;
&lt;p&gt;英文：&lt;a href=&quot;https://log.beshr.com/python-311-speedup-part-1&quot;&gt;https://log.beshr.com/python-311-speedup-part-1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载请保留作者及&lt;a href=&quot;https://mp.weixin.qq.com/s/AbpE-QJ64Q4iShMyXAygaQ&quot;&gt;译者信息&lt;/a&gt;！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;Python 3.11 在&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247497576&amp;amp;idx=1&amp;amp;sn=e2cbeb88a25b810315ad87c6719000d9&amp;amp;chksm=fa5bb0edcd2c39fb205cf01c2b3128807b47207a14b3812e89708b6981685aaa49c0f855bad7&amp;amp;scene=21#wechat_redirect&quot;&gt;几天前发布了&lt;/a&gt;，它照例带来了很多新特性，例如异常组、细粒度的错误位置与堆栈回溯、标准库对 TOML 的解析支持，当然，还有备受大家期待的由 faster CPython 项目带来的速度提升。&lt;/div&gt;
&lt;div&gt;根据 pyperformance 的基准测试，CPython 3.11 比 CPython 3.10 平均快 25%。这项改进的原因之一是 Guido 命名的“&lt;a href=&quot;https://mp.weixin.qq.com/s/DWVVoh2oj1GQ20WlTYo3cg&quot;&gt;香农计划&lt;/a&gt;”（即 faster CPython）。对于 3.11 版本，这个计划在两个主要方向进行了大量优化：启动时和运行时。&lt;/div&gt;
&lt;div&gt;除此之外，Python 3.11 还包含有其它的优化，这些优化不属于香农计划。&lt;/div&gt;
&lt;div&gt;在本文中，我将详细介绍 3.11.0 稳定版中常规优化的细节（即非 faster CPython 项目的改进）。&lt;/div&gt;
&lt;div&gt;（译注：作者表示将另写一篇文章介绍 faster CPython 的改进细节，届时，我也将继续翻译，敬请期待！）&lt;/div&gt;
&lt;h2&gt;目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;优化了一些 printf 风格 % 的格式化代码&lt;/li&gt;
&lt;li&gt;优化了 Python 大整数的除法&lt;/li&gt;
&lt;li&gt;优化了数字 PyLongs 求和&lt;/li&gt;
&lt;li&gt;精简列表的扩容操作，提升了 list.append 性能&lt;/li&gt;
&lt;li&gt;减少了全 unicode 键的字典的内存占用&lt;/li&gt;
&lt;li&gt;提升了使用asyncio.DatagramProtocol 传输大文件的速度&lt;/li&gt;
&lt;li&gt;对于 math 库：优化了 comb(n, k) 与 perm(n, k=None)&lt;/li&gt;
&lt;li&gt;对于 statistics 库：优化了 mean(data)、variance(data, xbar=None) 与 stdev(data, xbar=None)&lt;/li&gt;
&lt;li&gt;纯 ASCII 字符串的 unicodedata.normalize()，提升到常数时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;优化了一些 printf 风格 % 的格式化代码&lt;/h2&gt;
&lt;div&gt;使用格式化的字符串字面量（&lt;a href=&quot;https://peps.python.org/pep-0498/&quot;&gt;formatted string literals&lt;/a&gt;）是最快的格式化字符串的方法。&lt;/div&gt;
&lt;div&gt;Python 3.10 中的一个简单基准测试：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s \
  &lt;span&gt;&apos;k = &quot;foo&quot;; v = &quot;bar&quot;&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;&quot;%s = %r&quot; % (k, v)&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;187&lt;/span&gt; ns &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; ns&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;但是使用 f-string 似乎要快 42%：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s \
  &lt;span&gt;&apos;k = &quot;foo&quot;; v = &quot;bar&quot;&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;f&quot;{k!s} = {v!r}&quot;&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;131&lt;/span&gt; ns &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;9&lt;/span&gt; ns&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;优化性能的手段是将简单的 C 风格的格式化方法转换为 f-string 方法。在 3.11.0 中，只转换了 %s、%r 和 %a 三种，但是目前有一个待合入的 &lt;a href=&quot;https://github.com/python/cpython/pull/26160&quot;&gt;pull request&lt;/a&gt;，将会支持：%d、%i、%u、%o、%x、%X、%f、 %e、%g、%F、%E、%G。&lt;/div&gt;
&lt;div&gt;例如，下面是 Python 3.11 中相同基准测试的结果：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s \
  &lt;span&gt;&apos;k = &quot;foo&quot;; v = &quot;bar&quot;&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;&quot;%s = %r&quot; % (k, v)&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;100&lt;/span&gt; ns &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; ns&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;大约快了 87%！当然，3.11 中其它的优化对此也有影响，比如更快的解释器启动时间。&lt;/div&gt;
&lt;h2&gt;优化了 Python 大整数的除法&lt;/h2&gt;
&lt;div&gt;在 Python 3.10 中：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s &lt;span&gt;&apos;x=10**1000&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;x//10&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;1.18&lt;/span&gt; us &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;0.02&lt;/span&gt; us&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在 Python 3.11 中：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s &lt;span&gt;&apos;x=10**1000&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;x//10&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;995&lt;/span&gt; ns &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;15&lt;/span&gt; ns&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;大约快了18%。&lt;/div&gt;
&lt;div&gt;这项优化源自 Mark Dickinson 的一个发现，即编译器总会生成 128:64 的除法指令，尽管处理的是 30 位的数值。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;即使在 x64 上，Python 的除法也有些残缺。假设是 30 位数字，则多精度除法所需的基本结构是 64 位除以 32 位的无符号整数除法，产生一个 32 位的商（理想情况下还会产生一个 32 位余数）。有一个 x86/x64 指令可以做到这一点，也就是 DIVL。但是如果不使用内联汇编，当前版本的 GCC 和 Clang 显然做不到从 longobject.c 中发出该指令——它们只会在 x64 上使用 DIVQ（128 位除以 64 位的除法，尽管被除数的前 64 位被设为零），而在 x86 上则使用固有的 __udivti3 或 __udivti4。&lt;/p&gt;
&lt;p&gt;——Mark Dickinson（全文）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;优化了数字 PyLongs 求和&lt;/h2&gt;
&lt;div&gt;这里有一个 &lt;a href=&quot;https://github.com/python/cpython/issues/68264&quot;&gt;issue&lt;/a&gt;，它发现 Python 2.7 中 sum 的速度比 Python 3 快得多。不幸的是，在某些条件下，3.11.0 似乎仍然如此。&lt;/div&gt;
&lt;div&gt;Python 2.7：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s &lt;span&gt;&apos;d = [0] * 10000&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;sum(d)&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;37.4&lt;/span&gt; us &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;1.1&lt;/span&gt; us&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 3.10：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s &lt;span&gt;&apos;d = [0] * 10000&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;sum(d)&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;52.7&lt;/span&gt; us &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;1.3&lt;/span&gt; us&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 3.11：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s &lt;span&gt;&apos;d = [0] * 10000&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;sum(d)&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;39.0&lt;/span&gt; us &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;1.0&lt;/span&gt; us&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Python3.10 和 3.11 之间的区别在于，通过在 sum 函数的快速加法分支中内联对单个数字 PyLongs 的解包，可以提升在单个数字 PyLongs 上调用 sum 的性能。这样做可以避免在解包时&lt;a href=&quot;https://github.com/scoder/cpython/blob/125cdcf504a5d937b575cda3552b233dd44ba127/Python/bltinmodule.c#L2485-L2490&quot;&gt;调用&lt;/a&gt; &lt;a href=&quot;https://github.com/python/cpython/blob/de6981680bcf6496e5996a853b2eaa700ed59b2c/Objects/longobject.c#L489&quot;&gt;PyLong_AsLongAndOverflow&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;值得注意的是，&lt;a href=&quot;https://github.com/python/cpython/issues/68264#issuecomment-1285351158&quot;&gt;在某些情况下&lt;/a&gt;，Python 3.11 在整数求和时仍然明显慢于 Python 2.7。我们希望在 Python 中通过&lt;a href=&quot;https://github.com/faster-cpython/ideas/discussions/147&quot;&gt;实现更高效的整数&lt;/a&gt;，获得更多的改进。&lt;/div&gt;
&lt;h2&gt;精简列表的扩容操作，提升了 list.append 性能&lt;/h2&gt;
&lt;div&gt;在 Python 3.11 中，list.append 有了显著的性能提升（大约快 54%）。&lt;/div&gt;
&lt;div&gt;Python 3.10 的列表 append：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s \
  &lt;span&gt;&apos;x = list(map(float, range(10_000)))&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;[x.append(i) for i in range(10_000)]&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;605&lt;/span&gt; us &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;20&lt;/span&gt; us&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 3.11 的列表 append：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s \
  &lt;span&gt;&apos;x = list(map(float, range(10_000)))&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;[x.append(i) for i in range(10_000)]&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;392&lt;/span&gt; us &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;14&lt;/span&gt; us&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;对于简单的列表推导式，也有一些小的改进：&lt;/div&gt;
&lt;div&gt;Python 3.10：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s \
  &lt;span&gt;&apos;&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;[x for x in list(map(float, range(10_000)))]&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;553&lt;/span&gt; us &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;19&lt;/span&gt; us&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 3.11：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s \
  &lt;span&gt;&apos;&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;[x for x in list(map(float, range(10_000)))]&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;516&lt;/span&gt; us &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;16&lt;/span&gt; us&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;译注：记得在 3.9 版本的时候，Python 优化了&lt;a href=&quot;https://mp.weixin.qq.com/s/bjQjVmf7dP5fOqCS1cObqQ&quot;&gt;调用 list()、dict() 和 range() 等内置类型的速度&lt;/a&gt;，在不起眼处，竟还能持续优化！&lt;/div&gt;
&lt;h2&gt;减少了全 unicode 键的字典的内存占用&lt;/h2&gt;
&lt;div&gt;这项优化令 Python 在使用全为 Unicode 键的字典时，缓存的效率更高。这是因为使用的内存减少了，那些 Unicode 键的哈希会被丢弃，因为那些 Unicode 对象已经有哈希了。&lt;/div&gt;
&lt;div&gt;例如，在 64 位平台上，Python 3.10 运行结果：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;&lt;span&gt;dict&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;foo&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;bar&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; bar&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;foo&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;232&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在 Python 3.11 中：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;&lt;span&gt;dict&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;foo&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;bar&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; bar&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;foo&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;184&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;（译注：插个题外话，Python 的 getsizeof 是一种“浅计算”，这篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/EPU9TjEqm_GxnVZRwxq5Vw&quot;&gt;Python在计算内存时应该注意的问题？&lt;/a&gt;》区分了“深浅计算”，可以让你对 Python 计算内存有更深的理解。）&lt;/div&gt;
&lt;h2&gt;提升了使用asyncio.DatagramProtocol 传输大文件的速度&lt;/h2&gt;
&lt;div&gt;&lt;code&gt;asyncio.DatagramProtocol&lt;/code&gt; 提供了一个用于实现数据报（UDP）协议的基类。有了这个优化，使用asyncio UDP 传输大文件（比如 60 MiB）将比 Python 3.10 快 100 多倍。&lt;/div&gt;
&lt;div&gt;这是通过计算一次缓冲区的大小并将其存储在一个属性中来实现的。这使得通过 UDP 传输大文件时，&lt;code&gt;asyncio.DatagramProtocol&lt;/code&gt; 有着数量级的提速。&lt;/div&gt;
&lt;div&gt;PR msoxzw 的作者提供了以下的 &lt;a href=&quot;https://gist.github.com/msoxzw/8ae5c488edbc2985d41563c4d9c9cc04&quot;&gt;测试脚本&lt;/a&gt;。&lt;/div&gt;
&lt;h2&gt;对于 math 库：优化了 comb(n, k) 与 perm(n, k=None)&lt;/h2&gt;
&lt;div&gt;Python 3.8 在&lt;code&gt;math&lt;/code&gt; 标准库中增加了 comb(n, k) 和 perm(n, k=None) 函数。两者都用于计算从 n 个无重复的元素中选择 k 个元素的方法数，&lt;code&gt;comb&lt;/code&gt; 返回无序计算的结果，而&lt;code&gt;perm&lt;/code&gt; 返回有序计算的结果。（译注：即一个求组合数，一个求排列数）&lt;/div&gt;
&lt;div&gt;3.11 的优化由多个较小的改进组成，比如使用分治算法来实现 Karatsuba 大数乘法，以及尽可能用 C 语言&lt;code&gt;unsigned long long&lt;/code&gt; 类型而不是 Python 整数进行&lt;code&gt;comb&lt;/code&gt;计算(&lt;a href=&quot;https://github.com/python/cpython/pull/29090#issue-1031333783&quot;&gt;*&lt;/a&gt;)。&lt;/div&gt;
&lt;div&gt;另外一项改进是针对较小的 k 值（0 &amp;lt;= k &amp;lt;= n &amp;lt;= 67）：&lt;/div&gt;
&lt;div&gt;（译注：以下两段费解，暂跳过）&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;对于 &lt;code&gt;0 &amp;lt;= k &amp;lt;= n &amp;lt;= 67&lt;/code&gt;, &lt;code&gt;comb(n, k)&lt;/code&gt; always fits into a &lt;code&gt;uint64_t&lt;/code&gt;. We compute it as &lt;code&gt;comb_odd_part &amp;lt;&amp;lt; shift&lt;/code&gt; where &lt;code&gt;2 ** shift&lt;/code&gt; is the largest power of two dividing &lt;code&gt;comb(n, k)&lt;/code&gt; and &lt;code&gt;comb_odd_part&lt;/code&gt; is &lt;code&gt;comb(n, k) &amp;gt;&amp;gt; shift&lt;/code&gt;. &lt;code&gt;comb_odd_part&lt;/code&gt; can be calculated efficiently via arithmetic modulo &lt;code&gt;2 ** 64&lt;/code&gt;, using three lookups and two &lt;code&gt;uint64_t&lt;/code&gt; multiplications, while the necessary shift can be computed via Kummer’s theorem: it’s the number of carries when adding &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;n - k&lt;/code&gt; in binary, which in turn is the number of set bits of &lt;code&gt;n ^ k ^ (n - k)&lt;/code&gt;. &lt;a href=&quot;https://github.com/mdickinson/cpython/blob/03dccc557adf39db0150410e7c448ff3164e7022/Modules/mathmodule.c#L3583&quot;&gt;*&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;One more improvement is that the previous popcount-based code for computing the largest power of two dividing &lt;code&gt;math.comb(n, k)&lt;/code&gt; (for small n) got replaced with a more direct method based on counting trailing zeros of the factorials involved. (&lt;a href=&quot;https://github.com/python/cpython/pull/30313#issue-1091542983&quot;&gt;*&lt;/a&gt;).&lt;/div&gt;
&lt;div&gt;Python 3.10：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s \
  &lt;span&gt;&apos;import math&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;math.comb(100, 55)&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;3.72&lt;/span&gt; us &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;0.07&lt;/span&gt; us

&lt;span&gt;# ---&lt;/span&gt;

$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s \
  &lt;span&gt;&apos;import math&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;math.comb(10000, 5500)&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;11.9&lt;/span&gt; ms &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;0.1&lt;/span&gt; ms&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 3.11：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s \
  &lt;span&gt;&apos;import math&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;math.comb(100, 55)&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;476&lt;/span&gt; ns &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;20&lt;/span&gt; ns

&lt;span&gt;# ---&lt;/span&gt;

$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s \
  &lt;span&gt;&apos;import math&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;math.comb(10000, 5500)&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;2.28&lt;/span&gt; ms &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;0.10&lt;/span&gt; ms&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;对于 statistics 库：优化了 mean(data)、variance(data, xbar=None) 与 stdev(data, xbar=None)&lt;/h2&gt;
&lt;div&gt;3.11 优化了&lt;code&gt;statistics&lt;/code&gt;模块中的 &lt;code&gt;mean&lt;/code&gt;、&lt;code&gt;variance&lt;/code&gt;与&lt;code&gt;stdev&lt;/code&gt; 函数。如果入参是一个迭代器，则会直接用于计算，而不是先将其转换为列表。这种&lt;a href=&quot;https://github.com/rhettinger/cpython/blob/208abcd8f1726646f8d86306616b0db802d8064c/Lib/statistics.py#L205&quot;&gt;计算方法&lt;/a&gt; 的速度比之前的快了一倍。&lt;a href=&quot;https://docs.python.org/3/whatsnew/changelog.html&quot;&gt;*&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 3.10：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# Mean&lt;/span&gt;
$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s \
  &lt;span&gt;&apos;import statistics&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;statistics.mean(range(1_000))&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;255&lt;/span&gt; us &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;11&lt;/span&gt; us

&lt;span&gt;# Variance&lt;/span&gt;
$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s \
  &lt;span&gt;&apos;import statistics&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;statistics.variance((x * 0.1 for x in range(0, 10)))&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;77.0&lt;/span&gt; us &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;2.9&lt;/span&gt; us

&lt;span&gt;# Sample standard deviation (stdev)&lt;/span&gt;
$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s \
  &lt;span&gt;&apos;import statistics&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;statistics.stdev((x * 0.1 for x in range(0, 10)))&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;78.0&lt;/span&gt; us &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;2.2&lt;/span&gt; us&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 3.11：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# Mean&lt;/span&gt;
$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s \
  &lt;span&gt;&apos;import statistics&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;statistics.mean(range(1_000))&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;193&lt;/span&gt; us &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;7&lt;/span&gt; us

&lt;span&gt;# Variance&lt;/span&gt;
$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s \
  &lt;span&gt;&apos;import statistics&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;statistics.variance((x * 0.1 for x in range(0, 10)))&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;56.1&lt;/span&gt; us &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;2.3&lt;/span&gt; us

&lt;span&gt;# Sample standard deviation (stdev)&lt;/span&gt;
$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s \
  &lt;span&gt;&apos;import statistics&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;statistics.stdev((x * 0.1 for x in range(0, 10)))&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;59.4&lt;/span&gt; us &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;2.6&lt;/span&gt; us&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;纯 ASCII 字符串的 unicodedata.normalize()，提升到常数时间&lt;/h2&gt;
&lt;div&gt;对于 unicodedata.normalize() 方法，如果提供的入参是纯 ASCII 字符串，则通过 &lt;a href=&quot;https://www.unicode.org/reports/tr15/#Detecting_Normalization_Forms&quot;&gt;unicode 快速检查算法&lt;/a&gt; 迅速返回结果。这项检查使用的是&lt;code&gt;PyUnicode_IS_ASCII&lt;/code&gt; 实现。&lt;/div&gt;
&lt;div&gt;Python 3.10：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s \
  &lt;span&gt;&apos;import unicodedata&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;unicodedata.normalize(&quot;NFC&quot;, &quot;python&quot;)&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;83.3&lt;/span&gt; ns &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;4.3&lt;/span&gt; ns&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 3.11：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;$ python &lt;span&gt;-&lt;/span&gt;m pyperf timeit &lt;span&gt;-&lt;/span&gt;s \
  &lt;span&gt;&apos;import unicodedata&apos;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;&apos;unicodedata.normalize(&quot;NFC&quot;, &quot;python&quot;)&apos;&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
Mean &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; std dev&lt;span&gt;:&lt;/span&gt; &lt;span&gt;34.2&lt;/span&gt; ns &lt;span&gt;+&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;1.2&lt;/span&gt; ns&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;最后的话：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;我写这篇文章是为了加深自己对 Python 3.11 最新成果的认识。如果内容有错，请通过&lt;a href=&quot;mailto:me@beshr.com&quot;&gt;email&lt;/a&gt; 或者 &lt;a href=&quot;https://twitter.com/beshr&quot;&gt;Twitter&lt;/a&gt;告诉我。（译注：本翻译是出于促进自己学习及加强理解的目的，若有错漏，欢迎指正！）&lt;/li&gt;
&lt;li&gt;附 HackerNews 上的&lt;a href=&quot;https://news.ycombinator.com/item?id=33382022&quot;&gt;评论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在下一篇文章中，我将分析 faster CPython 项目带来的优化点。敬请期待！&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>如何免安装使用 Python？推荐 17 个在线的 Python 解释器！</title>
            <link>https://pythoncat.top/posts/2022-11-02-REPL/</link>
            <guid>https://pythoncat.top/posts/2022-11-02-REPL/</guid>
            <description>介绍一些可从浏览器中直接访问的 REPL，Tutor、PythonAnywhere、Replit、Brython等等</description>
            <pubDate>Wed, 02 Nov 2022 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;安装 Python 很容易，但或许你正在用智能手机/平板电脑，在用不允许安装软件的电脑，或者因为其它原因无法安装 Python。那么，如何通过免安装的方式使用 Python 呢？&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://inventwithpython.com/blog/author/al-sweigart.html&quot;&gt;Al Sweigart&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：豌豆花下猫@Python猫&lt;/p&gt;
&lt;p&gt;英文：&lt;a href=&quot;https://inventwithpython.com/blog/2022/10/30/17-online-python-ides-and-interactive-shellsrepls&quot;&gt;https://inventwithpython.com/blog/2022/10/30/17-online-python-ides-and-interactive-shellsrepls&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载请保留作者及译者信息！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;本文将介绍 17 个免费的 Python 解释器和交互式 Shell（也称为 REPL），你可以从 Web 浏览器中直接访问。（译注：国内访问部分网站不稳定，可以多试试，或者借助其它辅助上网的工具）&lt;/div&gt;
&lt;div&gt;基于浏览器的 Python 解释器有一些缺点：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;不能使用 open() 函数读写文件，不能建立网络连接。&lt;/li&gt;
&lt;li&gt;不允许运行长时间的或者耗费大量内存的程序。&lt;/li&gt;
&lt;li&gt;无法安装第三方模块，如 NumPy、Pandas、Requests、PyAutoGUI 或 Pygame（尽管有些会预装这些模块）。&lt;/li&gt;
&lt;li&gt;有些 Python 特性可能被禁用了；在使用时需要个别注意。&lt;/li&gt;
&lt;li&gt;有些服务需要你注册一个免费帐户；如果你不想处理垃圾邮件，可以用 &lt;a href=&quot;https://10minutemail.com/&quot;&gt;10 Minute Email&lt;/a&gt; 创建一次性的邮件帐户。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;尽管有以上缺点，但是用它们来练习编写 Python 代码是足够的。&lt;/div&gt;
&lt;div&gt;下面就是 Python 在线服务网站的列表。这不是一篇匆忙整理的标题党文章；我仔细检查了每一个网站，并按照个人的喜好顺序罗列出来。&lt;/div&gt;
&lt;div&gt;注：本文不包含 Pypy、Jython、Nutika、IronPython 等知名的 Python 解释器，因为它们都不是在线服务。想了解这些解释器，可查看：&lt;a href=&quot;https://mp.weixin.qq.com/s/y7noTM1F4SNAjwyjwPY5bA&quot;&gt;11 个最佳的 Python 编译器和解释器&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;1、Python Tutor&lt;/h2&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://pythontutor.com&quot;&gt;https://pythontutor.com&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;我最喜欢的基于浏览器的 Python 文件编辑器就是 Python Tutor（Python 导师）。Python Tutor 内置了一个调试器，允许每次执行一行，并查看程序的单步执行情况。不仅如此，它还记录了程序在每一步的状态，因此你也可以后退。这是大多数调试器没有的特性。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Python Tutor 网站还支持 Java 8、Javascript ES6 和 C/C++（使用 GCC 9.3 编译器）。主要的缺点是，程序在运行时会有所限制（因为在结果返回到你的浏览器之前，程序是在它们的服务器上运行的），但是在大多数的练习例子中，你不会遇到什么问题。&lt;/div&gt;
&lt;h2&gt;2、Python Anywhere&lt;/h2&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.pythonanywhere.com&quot;&gt;https://www.pythonanywhere.com&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PythonAnywhere 是最流行的基于浏览器的解释器之一。你必须先注册，是免费的。你可以存储 Python 脚本，或者无需登录而只使用它们的 IPython 交互式 Shell。（译注：毕竟是 Anaconda 出品，能秒杀大部分竞品）&lt;/div&gt;
&lt;div&gt;这个服务允许你从一个虚拟硬盘中读写文件，它已经安装了许多流行的 Python 第三方模块。&lt;/div&gt;
&lt;div&gt;它支持几个不同的 Python 版本，另外，它还被用于 &lt;a href=&quot;https://www.python.org/shell/&quot;&gt;www.python.org&lt;/a&gt; 网站上的交互式 Shell。&lt;/div&gt;
&lt;h2&gt;3、Replit&lt;/h2&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://replit.com&quot;&gt;https://replit.com&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Replit 需要注册一个帐户才能使用。用户界面有点复杂，因为它们有好几块功能，包括导航网站的帮助系统。该站点还有用于 C、C++、Java、Javascript 和其他几种语言的在线编译器。&lt;/div&gt;
&lt;div&gt;Replit 还有一个 APP，可以在智能手机和平板电脑上使用。&lt;/div&gt;
&lt;h2&gt;4、Brython&lt;/h2&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://brython.info/tests/console.html?lang=en&quot;&gt;https://brython.info/tests/console.html?lang=en&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Brython 可以让 Web 浏览器像运行 JavaScript 一样运行 Python。一般在 Web 页面上用 JavaScript 做的事情，都可以用 Brython 来做。这意味着你在运行程序时没有内存或 runtime 的限制，因为它们是在你自己的计算机上运行。缺点是浏览器在加载网页时，必须先下载 6 M 的 Brython 代码。&lt;/div&gt;
&lt;div&gt;你可以提前下载 Brython 到电脑上，并离线运行。首先，从 GitHub 上的 Brython 发布页面下载最新的版本（例如目前的 Brython-3.11.0.zip）。在解压后的目录中，创建一个名为 console.html 的文本文件（或任意以 .html 为后缀的名称），并写入以下内容：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;!doctype html&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;html&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;head&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;script &lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;text/javascript&quot;&lt;/span&gt; src&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;brython.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;script&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;script &lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;text/javascript&quot;&lt;/span&gt; src&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;brython_stdlib.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;script&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;style&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;codearea &lt;span&gt;{&lt;/span&gt;
        background&lt;span&gt;-&lt;/span&gt;color&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#000;&lt;/span&gt;
        color&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#fff;&lt;/span&gt;
        font&lt;span&gt;-&lt;/span&gt;family&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&apos;Oxygen Mono&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; Consolas&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;Liberation Mono&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;DejaVu Sans Mono&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; monospace&lt;span&gt;;&lt;/span&gt;
        font&lt;span&gt;-&lt;/span&gt;size&lt;span&gt;:&lt;/span&gt;14px&lt;span&gt;;&lt;/span&gt;
        overflow&lt;span&gt;:&lt;/span&gt;auto
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;style&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;head&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;body onload&lt;span&gt;=&lt;/span&gt;brython&lt;span&gt;(&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&quot;debug&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;!&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; remove the &lt;span&gt;1&lt;/span&gt; to leave debug mode &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;noscript&lt;span&gt;&amp;gt;&lt;/span&gt;Please enable Javascript to view this page correctly&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;noscript&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;textarea &lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;code&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;codearea&quot;&lt;/span&gt; rows&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;20&quot;&lt;/span&gt; cols&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;100&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;textarea&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;script &lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;text/python3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;from&lt;/span&gt; interpreter &lt;span&gt;import&lt;/span&gt; Interpreter

        &lt;span&gt;# Start an interactive interpreter in textarea with id &quot;code&quot;&lt;/span&gt;
        Interpreter&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;code&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;script&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;body&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;html&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;当在计算机上打开这个 .html 文件时，你将得到一个可运行的 Python 交互式 Shell。&lt;/div&gt;
&lt;h2&gt;5、Google Colab&lt;/h2&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://colab.research.google.com&quot;&gt;https://colab.research.google.com&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;使用 Google 或 GMail 帐户，你可以访问这个 Jupyter Notebook 风格的 REPL，它提供了大量的内存和 CPU 资源。&lt;/div&gt;
&lt;h2&gt;6、Trinket&lt;/h2&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://trinket.io&quot;&gt;https://trinket.io&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Trinket 是一个以教育为主的网站。你需要注册一个免费的帐户才能使用它，他们的交互式 Shell 还支持Turtle、Matplotlib 和其他模块，而许多在线 REPL 都不支持这些模块。&lt;/div&gt;
&lt;h2&gt;7、Python Fiddle&lt;/h2&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://pythonfiddle.com&quot;&gt;http://pythonfiddle.com&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python Fiddle 是一个简单的编辑器，允许你创建和运行 Python 脚本。它的用户界面太过丑陋了。。。（译注：不忍直视的页面！网站竟然支持两种语言，English与中文，我不经怀疑开发者的身份是……）&lt;/div&gt;
&lt;h2&gt;8、Programiz&lt;/h2&gt;
&lt;div&gt;&lt;a href=&quot;https://www.programiz.com/python-programming/online-compiler&quot;&gt;https://www.programiz.com/python-programming/online-compiler&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Programiz 有一个简单的文件编辑器。它不能写文件，运行资源也有限。该网站还有用于 C、C++、Java、C#、Javascript 的编译器，以及一个用于 SQL 数据库和 HTML/CSS 的沙箱。&lt;/div&gt;
&lt;h2&gt;9、Ideone&lt;/h2&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://ideone.com&quot;&gt;https://ideone.com&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Ideaone 有一个丰富的编辑器，支持包括 Python 在内的多种编程语言（甚至有 Pascal、Fortran、Prolog 和 Cobol 等较老的语言，以及 Brainfuck 和 Intercal 等深奥的编程语言）。&lt;/div&gt;
&lt;div&gt;它只有一个支持编写和运行程序的编辑器（有 5 秒的运行时长限制），但没有交互式 Shell。相比于用它写 Python，如果你想练习不太流行的语言，Ideaone 会是个不错的选择。&lt;/div&gt;
&lt;h2&gt;10、SymPy Live Shell&lt;/h2&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://live.sympy.org&quot;&gt;https://live.sympy.org&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个 Jupyter Notebook 风格的 REPL，带有一个很小的用户界面，非常适合简略的代码。它完全在浏览器中使用 &lt;a href=&quot;https://jupyterlite.readthedocs.io/en/latest/&quot;&gt;JupyterLite&lt;/a&gt; 运行 JupyterLab，而不是在服务器上运行。&lt;/div&gt;
&lt;h2&gt;11、OnlineGDB&lt;/h2&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.onlinegdb.com/online_python_interpreter&quot;&gt;https://www.onlinegdb.com/online_python_interpreter&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个不错的编辑器，有一个很好的用户界面，不会让人不知所措。运行时和内存似乎也相当多。我推荐这个。&lt;/div&gt;
&lt;h2&gt;12、W3Schools Python Shell&lt;/h2&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.w3schools.com/python/python_compiler.asp&quot;&gt;https://www.w3schools.com/python/python_compiler.asp&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;W3Schools 有一个简单的 Python 编辑器，支持基本的语法高亮。它有大约 10 秒的运行时间限制，但是如果你的程序超出时间，它不会报错。如果是简单的例子，用起来很好。&lt;/div&gt;
&lt;h2&gt;13、Python原理在线解释器&lt;/h2&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://pythonprinciples.com/online-python-interpreter&quot;&gt;https://pythonprinciples.com/online-python-interpreter&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个简单的文件编辑器，只能运行一些较为简单的代码。&lt;/div&gt;
&lt;h2&gt;14、Online Python 测试版&lt;/h2&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.online-python.com&quot;&gt;https://www.online-python.com&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个简单明了的 Python 编辑器，只能运行一些较为简单的代码。&lt;/div&gt;
&lt;h2&gt;15、TutorialsPoint&lt;/h2&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.tutorialspoint.com/execute_python_online.php&quot;&gt;https://www.tutorialspoint.com/execute_python_online.php&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一个简单易懂的编辑器，有较多运行资源。&lt;/div&gt;
&lt;h2&gt;16、RexTester&lt;/h2&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://rextester.com/l/python3_online_compiler&quot;&gt;https://rextester.com/l/python3_online_compiler&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这像一个业余项目，仅有极简的编辑器，有 5 秒的运行时间限制。它有其他语言的编译器，但网站难于浏览。&lt;/div&gt;
&lt;h2&gt;17、Portable Python&lt;/h2&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://portablepython.com&quot;&gt;https://portablepython.com&lt;/a&gt; （不推荐）&lt;/div&gt;
&lt;div&gt;这不是一个基于浏览器的 REPL，而是一个 .exe 文件，可以在 Windows 上运行 Python，而无需安装任何东西。然而，该网站自 2013 年（以及 Python 3.2）以来就没有更新过，下载页面也不使用 HTTPS。由于可能有恶意软件，我不建议使用它。&lt;/div&gt;
&lt;h2&gt;18、在线版 VS Code&lt;/h2&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://vscode.dev&quot;&gt;https://vscode.dev&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Visual Studio Code 是一个 Electron app，这意味着它可以作为一个普通的桌面应用程序，也可以基于浏览器来运行。浏览器版本有点受限，相比于其它在线解释器，使用这个在线 IDE 需要更陡的学习曲线。&lt;/div&gt;
&lt;div&gt;不过，如果你愿意深入了解它，或者已经使用过 Visual Studio Code，那么可以试试这个基于浏览器的版本。&lt;/div&gt;
&lt;div&gt;注：文中图片为译者所加。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 3.12 目标：还可以更快！</title>
            <link>https://pythoncat.top/posts/2022-10-06-goals/</link>
            <guid>https://pythoncat.top/posts/2022-10-06-goals/</guid>
            <description>开发中的 3.12 版本在 Faster CPython 项目上有很多动作，值得一睹为快！</description>
            <pubDate>Thu, 06 Oct 2022 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;按照发布计划，Python 3.11.0 将于 2022 年 10 月 24 日发布。&lt;/div&gt;
&lt;div&gt;据测试，3.11 相比于 3.10，将会有 10-60% 的性能提升，这个成果主要归功于“Faster CPython”项目，即“香农计划”。&lt;/div&gt;
&lt;div&gt;关于“香农计划”的详情，可查看 Python 之父的&lt;a href=&quot;https://mp.weixin.qq.com/s/DWVVoh2oj1GQ20WlTYo3cg&quot;&gt;主题分享&lt;/a&gt;，以及他的一则&lt;a href=&quot;https://mp.weixin.qq.com/s/YGgW1Pb79RWzs9X_etx1Rw&quot;&gt;播客访谈&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;3.11 版本为 Python 的提速开了一个激动人心的好头。接下来，3.12 还会有更多动作。&lt;/div&gt;
&lt;div&gt;以下文章翻译自“香农计划”的《Python 3.12 Goals》，大家先一睹为快吧！&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：Mark Shannon&lt;/p&gt;
&lt;p&gt;译者：豌豆花下猫@Python猫&lt;/p&gt;
&lt;p&gt;英文：&lt;a href=&quot;https://github.com/faster-cpython/ideas/wiki/Python-3.12-Goals&quot;&gt;https://github.com/faster-cpython/ideas/wiki/Python-3.12-Goals&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;&lt;em&gt;本文内容可能会改动，以实际版本为准！&lt;/em&gt;&lt;/div&gt;
&lt;div&gt;本文是 Faster CPython 计划在 3.12 中实现的主要内容的概要。&lt;/div&gt;
&lt;h2&gt;跟踪优化器&lt;/h2&gt;
&lt;div&gt;Python 3.11 提升速度的主要方法是用更快的与上下文相关的操作码（自适应的专门化操作码）替换个别的操作码，下一个大的改进方法是优化多个操作码的运行。&lt;/div&gt;
&lt;div&gt;为此，现有的许多高级操作码将被替换成低级操作码，例如，用于检查版本号和引用计数的操作码。这些更简单的操作码更容易进行优化，例如，可以删除冗余的引用计数操作。&lt;/div&gt;
&lt;div&gt;这些更底层的操作码还能让我们得到一组适合用于生成机器代码的指令（在 CPython 和第三方 JIT 项目中都适用）。&lt;/div&gt;
&lt;div&gt;为了做到这点，解释器循环（interpreter loop）将基于声明性的描述而生成。&lt;/div&gt;
&lt;div&gt;这可减少一部分为了保持解释器循环与某些相关函数同步而产生的 bug（mark_stacks、stack_effect 等函数），同时也让我们可以对解释器循环作较大的更改试验。&lt;/div&gt;
&lt;h2&gt;多线程并行&lt;/h2&gt;
&lt;div&gt;Python 当前每个进程有一个全局解释器锁（GIL），阻碍了多线程的并行。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;PEP-684：&lt;a href=&quot;https://peps.python.org/pep-0684&quot;&gt;https://peps.python.org/pep-0684&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PEP-554：&lt;a href=&quot;https://peps.python.org/pep-0554&quot;&gt;https://peps.python.org/pep-0554&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://peps.python.org/pep-0684/&quot;&gt;PEP-684&lt;/a&gt; 提出了一个方案，即保证所有的全局状态都是线程安全的，并移动到每个子解释器的全局解释器锁中使用。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://peps.python.org/pep-0554/&quot;&gt;PEP-554&lt;/a&gt; 提出了让 Python 创建子解释器的方案（目前只是一个 C API 特性），从而实现真正的多线程并行。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Python猫注：PEP-554 早在 2017 年就提出了，目标是落地在 Python 3.8-3.9 版本，然而事与愿违。早在 2019 年的时候，我还翻译了一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/8KvQemz0SWq2hw-2aBPv2Q&quot;&gt;Has the Python GIL been slain?&lt;/a&gt;》。屠刀已挥出，让它再飞一会~~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;更多专门化&lt;/h2&gt;
&lt;div&gt;我们&lt;a href=&quot;https://github.com/faster-cpython/ideas/issues/74&quot;&gt;分析了哪些字节码将从专门化中获益最多&lt;/a&gt;，计划在 3.12 完成其余的高收益的改进。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/faster-cpython/ideas/issues/74&quot;&gt;https://github.com/faster-cpython/ideas/issues/74&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;较小的对象结构&lt;/h2&gt;
&lt;div&gt;有许多可以&lt;a href=&quot;https://github.com/faster-cpython/ideas/discussions/125&quot;&gt;减少 Python 对象结构大小的机会&lt;/a&gt;。由于它们被频繁使用，这不仅有利于总体的内存使用，还有利于缓存的一致性。我们计划在 3.12 中实现最有希望的一些想法。&lt;/div&gt;
&lt;div&gt;这里有一些向后兼容性与性能之间的权衡问题，可能需要提出一个 PEP 来建立共识。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;减少内存管理的开销&lt;/h2&gt;
&lt;div&gt;我们不仅会减小对象的大小，还会使它们的 layout 更加规则。&lt;/div&gt;
&lt;div&gt;这不仅能优化内存的分配及释放，还能在 GC 和重新分配期间加快遍历对象的速度。&lt;/div&gt;
&lt;h2&gt;API 稳定性&lt;/h2&gt;
&lt;div&gt;除了前述项目外，开发团队还将提升 CPython 代码库的整体质量：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;通过减少不同编译阶段的耦合，使编译器更易于维护与测试。&lt;/li&gt;
&lt;li&gt;积极地在 C 语言级别监控和改进 CPython 测试套的代码覆盖率。&lt;/li&gt;
&lt;li&gt;改进 Python 性能基准测试套，加入更具代表性的现实世界的负载测试。&lt;/li&gt;
&lt;li&gt;协助处理 CPython 问题和 PR，特别是与性能有关的问题。&lt;/li&gt;
&lt;li&gt;增加用于标准基准测试的机器，增加 macOS 和 Windows 的测试结果。&lt;/li&gt;
&lt;li&gt;继续跟主要的深度使用 Python 内核的项目合作，帮助它们适配 CPython 解释器的更改。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;注：文中图片为译者所加。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>继GitHub的Copilot收费后，亚马逊推出了 CodeWhisperer，感觉不错哟！</title>
            <link>https://pythoncat.top/posts/2022-09-17-codewhisperer/</link>
            <guid>https://pythoncat.top/posts/2022-09-17-codewhisperer/</guid>
            <description>在 Copilot 宣布收费的几天后，Amazon 就推出了一款竞品 CodeWhisperer，这是程序员和编程学习者们的福音啊</description>
            <pubDate>Sat, 17 Sep 2022 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;Copilot 是 Github 推出的一款人工智能编程助手，推出仅一年就受到大量开发者的追捧（据官方统计有 120 万用户）。然而，自 2022 年 6 月起，它改为了付费订阅模式（每月 10 美元或每年 100 美元）。&lt;/div&gt;
&lt;div&gt;我们暂且不讨论训练代码可能涉及的版权及授权许可问题，可以肯定的是，利用机器学习训练出智能编程 AI 模型，这会是未来的大势所趋！&lt;/div&gt;
&lt;div&gt;巧合的是，仅在 Copilot 宣布收费的几天后，Amazon 就推出了一款竞品 CodeWhisperer！相信在不久的将来，类似的产品会如雨后春笋般涌现，到那时，程序员和编程学习者们就更加有福了！&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：Brian Tarbox&lt;/p&gt;
&lt;p&gt;译者：豌豆花下猫@Python猫&lt;/p&gt;
&lt;p&gt;英文：&lt;a href=&quot;https://blog.symops.com/2022/08/31/amazon-codewhisperer&quot;&gt;https://blog.symops.com/2022/08/31/amazon-codewhisperer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载请保留作者&amp;amp;译者&amp;amp;来源信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;代码补全最早出现在 1985 年的一个&lt;a href=&quot;https://www.templetons.com/brad/alice.html&quot;&gt;名为 Alice 的 Pascal 编辑器&lt;/a&gt;上。它支持自动缩进、自动补全 BEGIN/END 控制结构，甚至支持语法着色。&lt;/div&gt;
&lt;div&gt;争议也随之而来：在 Alice 的早期，人们担心代码补全&lt;a href=&quot;https://www.reddit.com/r/learnprogramming/comments/99njwv/is_the_use_of_ides_good_or_bad_for_absolute/&quot;&gt;使得编写软件过于简单&lt;/a&gt;。但它实际上只是一个语法助手。&lt;/div&gt;
&lt;div&gt;代码补全可以帮你写出语法正确的、可编译的代码，但它不能帮你写出语义正确的代码，甚至不能写出任何有用的代码。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;GitHub 的 &lt;a href=&quot;https://github.com/features/copilot&quot;&gt;CoPilot&lt;/a&gt; 和 Amazon 的 &lt;a href=&quot;https://aws.amazon.com/codewhisperer/&quot;&gt;CodeWhisperer&lt;/a&gt; 改变了这一点，它们除了提供语法辅助，还能生成语义上正确的代码。它们不仅能提供 if 语句的大纲，还能创建出完整的代码样例。&lt;/div&gt;
&lt;div&gt;但在 2022 年，一个代码辅助工具到底能好到什么程度呢？&lt;/div&gt;
&lt;div&gt;本文将重点介绍 CodeWhisperer，尝试回答这个问题。&lt;/div&gt;
&lt;h2&gt;试用：用 Python 从 S3 读取数据&lt;/h2&gt;
&lt;div&gt;亚马逊在 2022 年 6 月发布了 CodeWhisperer 预览版，现在它支持 Python、Java 和 JavaScript。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Python猫注：截至2022年9月17日，这个服务还未全面开放。&lt;/p&gt;
&lt;p&gt;若要试用，可在官网申请：&lt;a href=&quot;https://pages.awscloud.com/codewhisperer-sign-up-form.html&quot;&gt;https://pages.awscloud.com/codewhisperer-sign-up-form.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;附官方介绍：&lt;a href=&quot;https://aws.amazon.com/cn/blogs/compute/introducing-amazon-codewhisperer-in-the-aws-lambda-console-in-preview&quot;&gt;https://aws.amazon.com/cn/blogs/compute/introducing-amazon-codewhisperer-in-the-aws-lambda-console-in-preview&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;在 AWS 博客的&lt;a href=&quot;https://aws.amazon.com/blogs/compute/introducing-amazon-codewhisperer-in-the-aws-lambda-console-in-preview/&quot;&gt;一篇文章&lt;/a&gt;中，Mark Richman 解释说，CodeWhisperer 的模型是在“包括 Amazon 开源代码在内的各种数据源”上训练的。有了这个语料库（显然&lt;a href=&quot;https://www.techrepublic.com/article/aws-getting-better-at-open-source/&quot;&gt;确实存在&lt;/a&gt;）完善 CodeWhisperer 的模型，编写从 S3 读取文件的代码应该是一个很好的测试用例。&lt;/div&gt;
&lt;div&gt;在使用 CodeWhisperer（CW）时，你需要写一个注释，描述你希望函数去做什么。注释的描述性和准确性越高，系统就越能更好地推断出你想要的逻辑。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;Function to open an S3 file&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;注释以 Function 开头，让 CW 知道你想要创建一个函数。也就是说，你需要添加一个注释，作为给 CW 的提示。&lt;/div&gt;
&lt;div&gt;CW 分析注释并生成一个函数的定义。此时，你可以在生成函数体之前修改函数定义。CW 还可能提供多种函数定义供你选择。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;IntelliJ 集成 CodeWhisperer 的截图&lt;/div&gt;
&lt;div&gt;点击“插入代码”，你的函数就在注释的下方创建好了。注意 CodeWhisperer 不仅插入了代码，还创建了一个文档字符串。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# Function to open an S3 file
def open_s3_file(filename):
    &quot;&quot;&quot;
    :param filename:
    :return:
    &quot;&quot;&quot;
    s3 = boto3.resource(&apos;s3&apos;)
    return s3.Object(bucket, filename).get()[&apos;Body&apos;].read()&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;看起来不错！这段代码实现了你的注释所期望的功能，并且是在几秒钟内就生成了。节省了查找&lt;code&gt;boto3&lt;/code&gt; API 的时间，你只需要检查代码，确保语义正确。&lt;/div&gt;
&lt;div&gt;接着看看提出更多要求时，会发生什么。&lt;/div&gt;
&lt;div&gt;这有一个很有用的例子：写一个函数从 S3 的文件中返回前“n”行。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# Function to get first n lines from a file in S3
def get_first_n_lines_from_s3(filename, n):
    &quot;&quot;&quot;
    Get the first n lines of a file in S3
    :param filename:
    :param n:
    :return:
    &quot;&quot;&quot;
    lines = []
    for line in open_s3_file(filename):
        lines.append(line)
        if len(lines) &amp;gt;= n:
            break
    return lines&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;真厉害！CodeWhisperer 使用了之前创建的辅助方法 open_s3_file，并生成了正确的函数。&lt;/div&gt;
&lt;div&gt;在 CW 生成函数体之前，你可以修改参数名，提高代码的可读性。例如，如果我们输入：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# Function to find common elements in lists&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;CW 会提示：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;def find_common_elements(list1, list2)&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在生成函数体之前，我们可以修改函数定义，使其更具描述性：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;def find_common_elements(first, second)&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;如果我们接受它的函数定义，CodeWhisperer 将使用函数签名和注释来构建函数体。得到的函数将使用改进后的参数名。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# Function to find common elements in lists
def find_common_elements(first, second):
        return list(set(first) &amp;amp; set(second))&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;CodeWhisperer 不仅仅可以创建整个函数；它还可以在函数中插入代码片段，并在过程中推断相关变量。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;  # reverse the list order
  lines.reverse()&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;CodeWhisperer 是一个重要的生产力助推器&lt;/h2&gt;
&lt;div&gt;使用 CodeWhisperer，我能够更快地编写代码。到目前为止，最大的价值是 S3 示例所演示的功能。&lt;/div&gt;
&lt;div&gt;如果我自己写代码，大部分时间将会用来查找 boto API 文档，以确保写出正确的调用。使用 CodeWhisperer，则只需三秒钟。&lt;/div&gt;
&lt;div&gt;这让我想到了一段曾花了很多时间的烦人代码：给 CloudWatch 发送数据。让我们看看 CodeWhisperer 能否有所帮助，试试提供注释：“Function to emit a CloudWatch metric”。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# Function to emit a cloudwatch metric
def put_metric_data(metric_name, metric_data):
    &quot;&quot;&quot;
    Put a metric data into cloudwatch
    :param metric_name:
    :param metric_data:
    :return:
    &quot;&quot;&quot;
    cloudwatch = boto3.client(&apos;cloudwatch&apos;)
    cloudwatch.put_metric_data(
        Namespace=&apos;my_namespace&apos;,
        MetricData=[
            {
                &apos;MetricName&apos;: metric_name,
                &apos;Dimensions&apos;: [
                    {
                        &apos;Name&apos;: &apos;string&apos;,
                        &apos;Value&apos;: &apos;string&apos;
                    },
                ],
                &apos;Unit&apos;: &apos;Seconds&apos;,
                &apos;Value&apos;: metric_data
            },
        ]
    )&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;非常有用！CW 为我节省了许多打字和查阅 API 文档的时间。&lt;/div&gt;
&lt;div&gt;我有可能需要重构这段代码，但即使我从零开始编写它，第一步也要写出类似这样的原始逻辑。如今只花三秒钟，我节省了编写大量样板代码的时间，有了一个很好的自定义或重构的起点。&lt;/div&gt;
&lt;h2&gt;那么 CodeWhisperer 是一个比我更好的程序员吗?&lt;/h2&gt;
&lt;div&gt;尽管有一丝标题党，但 CW 的代码是否比我的好，这并不重要。重要的是，它可以为我节省大量的时间和精力，让我能够专注于改进、重构和测试。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;它通过承担一些同质化的繁重工作，让我有机会成为一个更好的程序员。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;上面的例子是 Amazon 工具（经过 Amazon 开源代码训练）能够表现出色的例子。当然，在大多数开发人员需要花费很多时间的地方，比如编写领域相关的逻辑时，CW 也许不会非常有用。让我们看看 CW 会出什么问题。&lt;/div&gt;
&lt;div&gt;我们可以从 Python 文档中的数据类示例开始。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;@dataclass
class InventoryItem:
    &quot;&quot;&quot;Class for keeping track of an item in inventory.&quot;&quot;&quot;
    name: str
    unit_price: float
    quantity_on_hand: int = 0

    def total_cost(self) -&amp;gt; float:
        return self.unit_price * self.quantity_on_hand&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我想知道 CodeWhisperer 是否可以向这个类添加一个方法。让我们看看如果添加注释：” Function that return this item costs more than $10”，会发生什么？&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;@dataclass
class InventoryItem:
    &quot;&quot;&quot;Class for keeping track of an item in inventory.&quot;&quot;&quot;
    name: str
    unit_price: float
    quantity_on_hand: int = 0

    def total_cost(self) -&amp;gt; float:
        return self.unit_price * self.quantity_on_hand

    # Function that returns whether this item costs more than $10
    def expensive(self) -&amp;gt; bool:
        return self.unit_price &amp;gt; 10&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;非常酷。值得注意的是，CW 给函数起了一个直观的名字，并包含了对 self 的引用。&lt;/div&gt;
&lt;div&gt;接着，让我们尝试用 CW 来做测试，看是否会触及它的极限。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# Function to test InventoryItem class
def test_inventory_item():
     &quot;&quot;&quot;
    Test InventoryItem class
    :return:
    &quot;&quot;&quot;
    item = InventoryItem(&quot;Widget&quot;, 10, 5)
    assert item.name == &quot;Widget&quot;
    assert item.unit_price == 10
    assert item.quantity_on_hand == 5
    assert item.total_cost() == 50
    assert not item.expensive()&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;🤯哇！在上面的代码中，我输入了注释，CW 自动完成了剩下的工作。&lt;/div&gt;
&lt;div&gt;测试似乎是一个极好的证明 CW 可以节省时间的例子。我不需要浪费时间去想测试的值，也不用输入所有的成员变量和方法。&lt;/div&gt;
&lt;h2&gt;CodeWhisperer 的局限性&lt;/h2&gt;
&lt;div&gt;它现在还处于初级阶段，还有很多问题。&lt;/div&gt;
&lt;div&gt;研究人员发现，GitHub CoPilot 生成的代码&lt;a href=&quot;https://cyber.nyu.edu/2021/10/15/ccs-researchers-find-github-copilot-generates-vulnerable-code-40-of-the-time/&quot;&gt;有 40% 存在安全漏洞&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;CodeWhisperer 还没有这类的统计数据，但 AWS 似乎强调了对安全性的关注。&lt;/div&gt;
&lt;div&gt;据我测试，在一些例子中，CW 生成的函数有 bug，或者结果没有符合我的意图。&lt;/div&gt;
&lt;div&gt;下方的例子应该返回两个文件中最长的公共行，但它只返回了第一个匹配的行：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# Function to find the longest common line in two files
def find_longest_common_line(file1, file2):
    &quot;&quot;&quot;
    Find the longest common line in two files
    :param file1:
    :param file2:
    :return:
    &quot;&quot;&quot;
    with open(file1, &apos;r&apos;) as f1:
        with open(file2, &apos;r&apos;) as f2:
            for line in f1:
                if line in f2:
                    return line&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;CW 还出现了其它问题，原因是它没有足够的上下文来理解我的意图。经过反思，我觉得如果周围的代码结构很好的话，也是可以实现的。&lt;/div&gt;
&lt;div&gt;如果你在设计代码时用了准确表示领域的名词，那么，在给出了良好注释的前提下，很容易想象 CW 能够创建出特定于领域的逻辑。至于 bug，将来肯定会得到改善的。&lt;/div&gt;
&lt;h2&gt;写在最后&lt;/h2&gt;
&lt;div&gt;如果你尝试使用 CW，它可能会让你想象：可能有一天，有人会写出历史上最后一行由人类编写的代码。&lt;/div&gt;
&lt;div&gt;在那之前，CW 可以帮助你成为一个更好的程序员，这样即使世界上最后一个程序员是你，人类的最后一行代码也不会有 bug。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Spring 使用 Mypy 检查 30 万行代码，总结出 3 大痛点与 6 个技巧</title>
            <link>https://pythoncat.top/posts/2022-09-05-mypy/</link>
            <guid>https://pythoncat.top/posts/2022-09-05-mypy/</guid>
            <description>Mypy 是要用的，但大型项目要实现全覆盖，坑就少不了，好消息是，你能总结出一些有用的经验</description>
            <pubDate>Mon, 05 Sep 2022 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;作者：Charlie Marsh&lt;/div&gt;
&lt;div&gt;译者：豌豆花下猫@Python猫&lt;/div&gt;
&lt;div&gt;英文：Using Mypy in production at Spring (&lt;a href=&quot;https://notes.crmarsh.com/using-mypy-in-production-at-spring&quot;&gt;https://notes.crmarsh.com/using-mypy-in-production-at-spring&lt;/a&gt;)&lt;/div&gt;
&lt;div&gt;在 &lt;a href=&quot;https://www.springdiscovery.com/&quot;&gt;Spring&lt;/a&gt; ，我们维护了一个大型的 Python 单体代码库（英：monorepo），用上了 Mypy &lt;a href=&quot;https://blog.wolt.com/engineering/2021/09/30/professional-grade-mypy-configuration/&quot;&gt;最严格的配置项&lt;/a&gt;，实现了 Mypy 全覆盖。简而言之，这意味着每个函数签名都是带注解的，并且不允许有隐式的 &lt;code&gt;Any&lt;/code&gt; 转换。&lt;/div&gt;
&lt;div&gt;（译注：此处的 Spring 并不是 Java 中那个著名的 Spring 框架，而是一家生物科技公司，专注于找到与年龄相关的疾病的疗法，2022 年 3 月曾获得比尔&amp;amp;梅琳达·盖茨基金会 120 万美元的资助。）&lt;/div&gt;
&lt;div&gt;诚然，代码行数是一个糟糕的衡量标准，但可作一个粗略的估计：我们的代码仓有超过 30 万行 Python 代码，其中大约一半构成了核心的数据平台，另一半是由数据科学家和机器学习研究员编写的终端用户代码。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;我有个大胆的猜测，就这个规模而言，这是最全面的加了类型的 Python 代码仓之一。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;我们在 2019 年 7 月首次引入了 Mypy，大约一年后实现了全面的类型覆盖，从此成为了快乐的 Mypy 用户。&lt;/div&gt;
&lt;div&gt;几周前，我跟 &lt;a href=&quot;https://twitter.com/srchvrs/status/1551676839856377859?s=20&amp;amp;t=KKSFIcDQnWbm2kYxm0vtbg&quot;&gt;Leo Boytsov&lt;/a&gt; 和 &lt;a href=&quot;https://twitter.com/bernhardsson/status/1551677664754389003?s=20&amp;amp;t=KKSFIcDQnWbm2kYxm0vtbg&quot;&gt;Erik Bernhardsson&lt;/a&gt; 在 Twitter 上对 Python 类型有一次简短的讨论——然后我看到 &lt;a href=&quot;https://twitter.com/charliermarsh/status/1558460385665114113?s=20&amp;amp;t=LagGcX_CKH6zQeutBWYzKg&quot;&gt;Will McGugan&lt;/a&gt; 也对类型大加赞赏。由于 Mypy 是我们在 Spring 公司发布和迭代 Python 代码的关键部分，我想写一下我们在过去几年中大规模使用它的经验。&lt;/div&gt;
&lt;div&gt;**一句话总结：**虽然采用 Mypy 是有代价的（前期和持续的投入、学习曲线等），但我发现它对于维护大型 Python 代码库有着不可估量的价值。Mymy 可能不适合于所有人，但它十分适合我。&lt;/div&gt;
&lt;h2&gt;Mypy 是什么？&lt;/h2&gt;
&lt;div&gt;&lt;em&gt;（如果你很熟悉 Mypy，可跳过本节。）&lt;/em&gt;&lt;/div&gt;
&lt;div&gt;Mypy 是 Python 的一个静态类型检查工具。如果你写过 Python 3，你可能会注意到 Python 支持类型注解，像这样:&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;greeting&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name&lt;span&gt;:&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&apos;Hello &apos;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; name&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 在 2014 年通过 &lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn/blob/master/StandardsTrack/484--%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA.md&quot;&gt;PEP-484&lt;/a&gt; 定义了这种类型注解语法。虽然这些注解是语言的一部分，但 Python（以及相关的第一方工具）实际上并不拿它们来强制做到类型安全。&lt;/div&gt;
&lt;div&gt;相反，类型检查通过第三方工具来实现。Mypy 就是这样的工具。Facebook 的 &lt;a href=&quot;https://github.com/facebook/pyre-check&quot;&gt;Pyre &lt;/a&gt;也是这样的工具——但就我所知，Mypy 更受欢迎（Mypy 在 GitHub 上有两倍多的星星，它是 &lt;a href=&quot;https://www.pantsbuild.org/docs/python-check-goal&quot;&gt;Pants&lt;/a&gt; 默认使用的工具）。IntelliJ 也有自己的类型检查工具，支持在 PyCharm 中实现类型推断。这些工具都声称自己“兼容 PEP-484”，因为它们使用 Python 本身定义的类型注解。&lt;/div&gt;
&lt;div&gt;（译注：最著名的类型检查工具还有谷歌的&lt;code&gt;pytype&lt;/code&gt; 和微软的&lt;code&gt;pyright&lt;/code&gt; ，关于基本情况介绍与对比，可查阅这篇&lt;a href=&quot;https://mp.weixin.qq.com/s/l8FyTp_oxdBEcg95fgWrDA&quot;&gt;文章&lt;/a&gt; ）&lt;/div&gt;
&lt;div&gt;换句话说：Python 认为自己的责任是定义类型注解的语法和语义（尽管 &lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn/blob/master/StandardsTrack/484--%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA.md&quot;&gt;PEP-484&lt;/a&gt; 本身很大程度上受到了 Mypy 现有版本的启发），但有意让第三方工具来检查这些语义。&lt;/div&gt;
&lt;div&gt;请注意，当你使用像 Mypy 这样的工具时，你是在 Python 本身之外运行它的——比如，当你运行&lt;code&gt;mypy path/to/file.py&lt;/code&gt; 后，Mypy 会把推断出的违规代码都吐出来。Python 在运行时显露但不利用那些类型注解。&lt;/div&gt;
&lt;div&gt;（顺便一提：在写本文时，我了解到相比于 Pypy 这样的项目，Mypy 最初有着非常不同的目标。那时还没有 PEP-484（它的灵感来自 Mypy！），所以 Mypy 定义了自己的语法，与 Python 不同，并实现了自己的运行时（也就是说，Mypy 代码是通过 Mypy 执行的）。当时，Mypy 的目标之一是利用静态类型、不可变性等来提高性能——而且明确地避开了与 CPython 兼容。Mypy 在 2013 年切换到兼容 Python 的语法，而 PEP-484 在 2015 年才推出。（“使用静态类型加速 Python”的概念催生了 Mypyc，它仍然是一个活跃的项目，可用于编译 Mypy 本身。））&lt;/div&gt;
&lt;h2&gt;在 Spring 集成 Mypy&lt;/h2&gt;
&lt;div&gt;我们在 2019 年 7 月将 Mypy 引入代码库（&lt;a href=&quot;https://github.com/spring-discovery/spring-experiments/pull/1724&quot;&gt;#1724&lt;/a&gt;）。当首次发起提议时，我们有两个主要的考虑：&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;虽然 Mypy 在 2012 年的 PyCon 芬兰大会上首次亮相，并在 2015 年初发布了兼容 PEP-484 的版本，但它仍然是一个相当新的工具——至少对我们来说是这样。尽管我们在一些相当大的 Python 代码库上工作过（在可汗学院和其它地方），但团队中没有人使用过它。&lt;/li&gt;
&lt;li&gt;像其它增量类型检查工具一样（例如 Flow），随着代码库的注解越来越多，Mypy 的价值会与时俱增。由于 Mypy 可以并且将会用最少的注解捕获 bug，所以你在代码库上投入注解的时间越多，它就会变得越有价值。&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;尽管有所犹豫，我们还是决定给 Mypy 一个机会。在公司内部，我们有强烈偏好于静态类型的工程师文化（除了 Python，我们写了很多 Rust 和 TypeScript）。所以，我们准备使用 Mypy。&lt;/div&gt;
&lt;div&gt;我们首先类型化了一些文件。一年后，我们完成了全部代码的类型化（#2622），并升级到最严格的 Mypy 设置（最关键的是 &lt;code&gt;disallow_untyped_defs&lt;/code&gt; ，它要求对所有函数签名进行注解），从那时起，我们一直维护着这些设置。（&lt;a href=&quot;https://blog.wolt.com/engineering/2021/09/30/professional-grade-mypy-configuration/&quot;&gt;Wolt&lt;/a&gt; 团队有一篇很好的文章，他们称之为“专业级的 Mypy 配置”，巧合的是，我们使用的正是这种配置。）&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Mypy 配置：&lt;a href=&quot;https://blog.wolt.com/engineering/2021/09/30/professional-grade-mypy-configuration/&quot;&gt;https://blog.wolt.com/engineering/2021/09/30/professional-grade-mypy-configuration/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;反馈&lt;/h2&gt;
&lt;div&gt;总体而言：&lt;strong&gt;我对 Mypy 持积极的看法。&lt;/strong&gt; 作为核心基础设施的开发人员（跨服务和跨团队使用的公共库），我认为它极其有用。&lt;/div&gt;
&lt;div&gt;我将在以后的任何 Python 项目中继续使用它。&lt;/div&gt;
&lt;h2&gt;好处&lt;/h2&gt;
&lt;div&gt;Zulip 早在 2016 年写了一篇漂亮的文章，内容关于使用 Mypy 的好处（这篇文章也被收入了 &lt;a href=&quot;https://mypy.readthedocs.io/en/stable/getting_started.html#next-steps&quot;&gt;Mypy 官方文档&lt;/a&gt; 中）。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Zulip 博文：&lt;a href=&quot;https://blog.zulip.com/2016/10/13/static-types-in-python-oh-mypy/#benefitsofusingmypy&quot;&gt;https://blog.zulip.com/2016/10/13/static-types-in-python-oh-mypy/#benefitsofusingmypy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;我不想重述静态类型的所有好处（它很好），但我想简要地强调他们在帖子中提到的几个好处：&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;改善可读性&lt;/strong&gt;：有了类型注解，代码趋向于自描述（与文档字符串不同，这种描述的准确性可以静态地强制执行）。（英：self-documenting）&lt;/li&gt;
&lt;li&gt;**捕获错误：**是真的！Mypy 确实能找出 bug。从始至终。&lt;/li&gt;
&lt;li&gt;**自信地重构：**这是 Mypy 最有影响力的一个好处。有了 Mypy 的广泛覆盖，我可以自信地发布涉及数百甚至数千个文件的更改。当然，这与上一条好处有关——我们用 Mypy 找出的大多数 bug 都是在重构时发现的。&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;第三点的价值怎么强调都不为过。毫不夸张地说，在 Mypy 的帮助下，我发布更改的速度快了十倍，甚至快了一百倍。&lt;/div&gt;
&lt;div&gt;虽然这是完全主观的，但在写这篇文章时，我意识到：&lt;strong&gt;我信任 Mypy&lt;/strong&gt;。虽然程度还不及，比如说 OCaml 编译器，但它完全改变了我维护 Python 代码的关系，我无法想象回到没有注解的世界。&lt;/div&gt;
&lt;h2&gt;痛点&lt;/h2&gt;
&lt;div&gt;Zulip 的帖子同样强调了他们在迁移 Mypy 时所经历的痛点（与静态代码分析工具的交互，循环导入）。&lt;/div&gt;
&lt;div&gt;坦率地说，我在 Mypy 上经历的痛点与 Zulip 文章中提到的不一样。我把它们分成三类：&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;外部库缺乏类型注解&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mypy 学习曲线&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对抗类型系统&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;让我们来逐一回顾一下：&lt;/div&gt;
&lt;h3&gt;1. 外部库缺乏类型注解&lt;/h3&gt;
&lt;div&gt;最重要的痛点是，我们引入的大多数第三方 Python 库要么是无类型的，要么不兼容 &lt;a href=&quot;https://peps.python.org/pep-0561/&quot;&gt;PEP-561&lt;/a&gt;。在实践中，这意味着对这些外部库的引用会被解析为不兼容，这会大大削弱类型的覆盖率。&lt;/div&gt;
&lt;div&gt;每当在环境里添加一个第三方库时，我们都会在&lt;code&gt;mypy.ini&lt;/code&gt; 里添加一个许可条目，它告诉 Mypy 要忽略那些模块的类型注解（有类型或提供类型存根的库，比较罕见）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;[&lt;/span&gt;mypy&lt;span&gt;-&lt;/span&gt;altair&lt;span&gt;.&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
ignore_missing_imports &lt;span&gt;=&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;

&lt;span&gt;[&lt;/span&gt;mypy&lt;span&gt;-&lt;/span&gt;apache_beam&lt;span&gt;.&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
ignore_missing_imports &lt;span&gt;=&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;

&lt;span&gt;[&lt;/span&gt;mypy&lt;span&gt;-&lt;/span&gt;bokeh&lt;span&gt;.&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
ignore_missing_imports &lt;span&gt;=&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;

&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;由于有了这样的安全出口，即使是随便写的注解也不会生效。例如，Mypy 允许这样做：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; pandas &lt;span&gt;as&lt;/span&gt; pd

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;return_data_frame&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; pd&lt;span&gt;.&lt;/span&gt;DataFrame&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;Mypy interprets pd.DataFrame as Any, so returning a str is fine!&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Hello, world!&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;除了第三方库，我们在 Python 标准库上也遇到了一些不顺。例如，&lt;code&gt;functools.lru_cache&lt;/code&gt; 尽管在  &lt;a href=&quot;https://github.com/python/typeshed/blob/a57e1826083b80fa564e8d46b72981f005bbdd65/stdlib/functools.pyi&quot;&gt;typeshed&lt;/a&gt; 里有类型注解，但由于复杂的原因，它不保留底层函数的签名，所以任何用 &lt;code&gt;@functools.lru_cache&lt;/code&gt; 装饰的函数都会被移除所有类型注解。&lt;/div&gt;
&lt;div&gt;例如，Mypy 允许这样做：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; functools

&lt;span&gt;@functools&lt;span&gt;.&lt;/span&gt;lru_cache&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;add_one&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;:&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; x &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;

add_one&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Hello, world!&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;第三方库的情况正在改善。例如，NumPy 在 1.20 版本中开始提供类型。Pandas 也有一系列公开的&lt;a href=&quot;https://github.com/pandas-dev/pandas-stubs&quot;&gt;类型存根&lt;/a&gt; ，但它们被标记为不完整的。（添加存根到这些库是非常重要的，这是一个巨大的成就！）另外值得一提的是，我最近在 Twitter 上看到了 Wolt 的 Python 项目&lt;a href=&quot;https://blog.wolt.com/engineering/2022/08/11/project-template-for-modern-python-packages/&quot;&gt;模板&lt;/a&gt; ，它也默认包括类型。&lt;/div&gt;
&lt;div&gt;所以，类型正在变得不再罕见。过去当我们添加一个有类型注解的依赖时，我会感到惊讶。有类型注解的库还是少数，并未成为主流。&lt;/div&gt;
&lt;h3&gt;2. Mypy 学习曲线&lt;/h3&gt;
&lt;div&gt;大多数加入 Spring 的人没有使用过 Mypy（写过 Python），尽管他们基本知道并熟悉 Python 的类型注解语法。&lt;/div&gt;
&lt;div&gt;同样地，在面试中，候选人往往不熟悉&lt;code&gt;typing&lt;/code&gt; 模块。我通常在跟候选人作广泛的技术讨论时，会展示一个使用了&lt;code&gt;typing.Protocol&lt;/code&gt; 的代码片段，我不记得有任何候选人看到过这个特定的构造——当然，这完全没问题！但这体现了 typing 在 Python 生态的流行程度。&lt;/div&gt;
&lt;div&gt;所以，当我们招募团队成员时，Mypy 往往是他们必须学习的新东西。虽然类型注解语法的基础很简单，但我们经常听到这样的问题：“为什么 Mypy 会这样？”、“为什么 Mypy 在这里报错？”等等。&lt;/div&gt;
&lt;div&gt;例如，这是一个通常需要解释的例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; condition&lt;span&gt;:&lt;/span&gt;
	value&lt;span&gt;:&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Hello, world&quot;&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;# Not ok -- we declared `value` as `str`, and this is `None`!&lt;/span&gt;
  value &lt;span&gt;=&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;

&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; condition&lt;span&gt;:&lt;/span&gt;
	value&lt;span&gt;:&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Hello, world&quot;&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;# Not ok -- we already declared the type of `value`.&lt;/span&gt;
  value&lt;span&gt;:&lt;/span&gt; Optional&lt;span&gt;[&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;

&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

&lt;span&gt;# This is ok!&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; condition&lt;span&gt;:&lt;/span&gt;
	value&lt;span&gt;:&lt;/span&gt; Optional&lt;span&gt;[&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Hello, world&quot;&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  value &lt;span&gt;=&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;另外，还有一个容易混淆的例子:&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; typing &lt;span&gt;import&lt;/span&gt; Literal

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;my_func&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;value&lt;span&gt;:&lt;/span&gt; Literal&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;b&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;b&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
	&lt;span&gt;# Not ok -- `value` is `str`, not `Literal[&apos;a&apos;, &apos;b&apos;]`.&lt;/span&gt;
  my_func&lt;span&gt;(&lt;/span&gt;value&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;当解释之后，这些例子的“原因”是有道理的，但我不可否认的是，团队成员需要耗费时间去熟悉 Mypy。有趣的是，我们团队中有人说 PyCharm 的类型辅助感觉还不如在同一个 IDE 中使用 TypeScript 得到的有用和完整（即使有足够的静态类型）。不幸的是，这只是使用 Mypy 的代价。&lt;/div&gt;
&lt;div&gt;除了学习曲线之外，还有持续地注解函数和变量的开销。我曾建议对某些“种类”的代码（如探索性数据分析）放宽我们的 Mypy 规则——然而，团队的感觉是注解是值得的，这件事很酷。&lt;/div&gt;
&lt;h3&gt;3. 对抗类型系统&lt;/h3&gt;
&lt;div&gt;在编写代码时，我会尽量避免几件事，以免导致自己与类型系统作斗争：写出我知道可行的代码，并强迫 Mypy 接受。&lt;/div&gt;
&lt;div&gt;首先是&lt;code&gt;@overload&lt;/code&gt; ，来自&lt;code&gt;typing&lt;/code&gt; 模块：非常强大，但很难正确使用。当然，如果需要重载一个方法，我就会使用它——但是，就像我说的，如果可以的话，我宁可避免它。&lt;/div&gt;
&lt;div&gt;基本原理很简单：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;@overload&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;clean&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;:&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

&lt;span&gt;@overload&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;clean&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;:&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;clean&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;:&lt;/span&gt; Optional&lt;span&gt;[&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; Optional&lt;span&gt;[&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; s&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; s&lt;span&gt;.&lt;/span&gt;strip&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;replace&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;\u00a0&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;但通常，我们想要做一些事情，比如“基于布尔值返回不同的类型，带有默认值”，这需要这样的技巧：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;@overload&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;lookup&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;
    paths&lt;span&gt;:&lt;/span&gt; Iterable&lt;span&gt;[&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; strict&lt;span&gt;:&lt;/span&gt; Literal&lt;span&gt;[&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; Mapping&lt;span&gt;[&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; Optional&lt;span&gt;[&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;


&lt;span&gt;@overload&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;lookup&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;
    paths&lt;span&gt;:&lt;/span&gt; Iterable&lt;span&gt;[&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; strict&lt;span&gt;:&lt;/span&gt; Literal&lt;span&gt;[&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; Mapping&lt;span&gt;[&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;


&lt;span&gt;@overload&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;lookup&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;
    paths&lt;span&gt;:&lt;/span&gt; Iterable&lt;span&gt;[&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; Mapping&lt;span&gt;[&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; Optional&lt;span&gt;[&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt; &lt;span&gt;lookup&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;
    paths&lt;span&gt;:&lt;/span&gt; Iterable&lt;span&gt;[&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; strict&lt;span&gt;:&lt;/span&gt; Literal&lt;span&gt;[&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;
&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; Any&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;pass&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;即使这是一个 hack——你不能传一个&lt;code&gt;bool&lt;/code&gt;到 &lt;code&gt;find_many_latest&lt;/code&gt;，你必须传一个字面量 &lt;code&gt;True&lt;/code&gt; 或&lt;code&gt;False&lt;/code&gt;。&lt;/div&gt;
&lt;div&gt;同样地，我也遇到过其它问题，使用 &lt;code&gt;@typing.overload&lt;/code&gt; 或者&lt;code&gt;@overload&lt;/code&gt; 、在类方法中使用&lt;code&gt;@overload&lt;/code&gt; ，等等。&lt;/div&gt;
&lt;div&gt;其次是&lt;code&gt;TypedDict&lt;/code&gt; ，同样来自&lt;code&gt;typing&lt;/code&gt; 模块：可能很有用，但往往会产生笨拙的代码。&lt;/div&gt;
&lt;div&gt;例如，你不能解构一个&lt;code&gt;TypedDict&lt;/code&gt; ——它必须用字面量 key 构造——所以下方第二种写法是行不通的：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; typing &lt;span&gt;import&lt;/span&gt; TypedDict

&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Point&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;TypedDict&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    x&lt;span&gt;:&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;
    y&lt;span&gt;:&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;

a&lt;span&gt;:&lt;/span&gt; Point &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;&quot;x&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;y&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;# error: Expected TypedDict key to be string literal&lt;/span&gt;
b&lt;span&gt;:&lt;/span&gt; Point &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;**&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;y&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在实践中，很难用&lt;code&gt;TypedDict&lt;/code&gt;对象做一些 Pythonic 的事情。我最终倾向于使用 &lt;code&gt;dataclass&lt;/code&gt; 或 &lt;code&gt;typing.NamedTuple&lt;/code&gt; 对象。&lt;/div&gt;
&lt;div&gt;第三是装饰器。Mypy 的&lt;a href=&quot;https://mypy.readthedocs.io/en/stable/generics.html#declaring-decorators&quot;&gt; 文档&lt;/a&gt; 对保留签名的装饰器和装饰器工厂有一个规范的建议。它很先进，但确实有效：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;F &lt;span&gt;=&lt;/span&gt; TypeVar&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;F&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; bound&lt;span&gt;=&lt;/span&gt;Callable&lt;span&gt;[&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; Any&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;decorator&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;func&lt;span&gt;:&lt;/span&gt; F&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; F&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;wrapper&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;args&lt;span&gt;:&lt;/span&gt; Any&lt;span&gt;,&lt;/span&gt; &lt;span&gt;**&lt;/span&gt;kwargs&lt;span&gt;:&lt;/span&gt; Any&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; func&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;args&lt;span&gt;,&lt;/span&gt; &lt;span&gt;**&lt;/span&gt;kwargs&lt;span&gt;)&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt; cast&lt;span&gt;(&lt;/span&gt;F&lt;span&gt;,&lt;/span&gt; wrapper&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;@decorator&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;:&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;但是，我发现使用装饰器做任何花哨的事情（特别是不保留签名的情况），都会导致代码难以类型化或者充斥着强制类型转换。&lt;/div&gt;
&lt;div&gt;这可能是一件好事！&lt;strong&gt;Mypy 确实改变了我编写 Python 的方式：耍小聪明的代码更难被正确地类型化，因此我尽量避免编写讨巧的代码。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;（装饰器的另一个问题是我前面提过的&lt;code&gt;@functools.lru_cache&lt;/code&gt; ：由于装饰器最终定义了一个全新的函数，所以如果你不正确地注解代码，就可能会出现严重而令人惊讶的错误。）&lt;/div&gt;
&lt;div&gt;我对循环导入也有类似的感觉——由于要导入类型作为注解使用，这就可能导致出现本可避免的循环导入（这也是 Zulip 团队强调的一个痛点）。虽然循环导入是 Mypy 的一个痛点*，*但这通常意味着系统或代码本身存在着设计缺陷，这是 Mypy 强迫我们去考虑的问题。&lt;/div&gt;
&lt;div&gt;不过，根据我的经验，即使是经验丰富的 Mypy 用户，在类型检查通过之前，他们也需对本来可以正常工作的代码进行一两处更正。&lt;/div&gt;
&lt;div&gt;（顺便说一下：Python 3.10 使用&lt;code&gt;ParamSpec&lt;/code&gt; 对装饰器的情况作了重大的改进。）&lt;/div&gt;
&lt;h2&gt;提示与技巧&lt;/h2&gt;
&lt;div&gt;最后，我要介绍几个在使用 Mypy 时很有用的技巧。&lt;/div&gt;
&lt;h3&gt;1. reveal_type&lt;/h3&gt;
&lt;div&gt;在代码中添加&lt;code&gt;reveal_type&lt;/code&gt; *，*可以让 Mypy 在对文件进行类型检查时，显示出变量的推断类型。这是非常非常非常有用的。&lt;/div&gt;
&lt;div&gt;最简单的例子是：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# No need to import anything. Just call `reveal_type`.&lt;/span&gt;
&lt;span&gt;# Your editor will flag it as an undefined reference -- just ignore that.&lt;/span&gt;
x &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
reveal_type&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# Revealed type is &quot;builtins.int&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;当你处理泛型时，&lt;code&gt;reveal_type&lt;/code&gt; 特别地有用，因为它可以帮助你理解泛型是如何被“填充”的、类型是否被缩小了，等等。&lt;/div&gt;
&lt;h3&gt;2. Mypy 作为一个库&lt;/h3&gt;
&lt;div&gt;Mypy 可以用作一个运行时库！&lt;/div&gt;
&lt;div&gt;我们内部有一个工作流编排库，看起来有点像 Flyte 或 Prefect。细节并不重要，但值得注意的是，它是完全类型化的——因此我们可以静态地提升待运行任务的类型安全性，因为它们被链接在一起。&lt;/div&gt;
&lt;div&gt;把类型弄准确是非常具有挑战性的。为了确保它完好，不被意外的&lt;code&gt;Any&lt;/code&gt;毒害，我们在一组文件上写了调用 Mypy 的单元测试，并断言 Mypy 抛出的错误能匹配一系列预期内的异常：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;test_check_function&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
	  result &lt;span&gt;=&lt;/span&gt; api&lt;span&gt;.&lt;/span&gt;run&lt;span&gt;(&lt;/span&gt;
	      &lt;span&gt;[&lt;/span&gt;
	          os&lt;span&gt;.&lt;/span&gt;path&lt;span&gt;.&lt;/span&gt;join&lt;span&gt;(&lt;/span&gt;
	              os&lt;span&gt;.&lt;/span&gt;path&lt;span&gt;.&lt;/span&gt;dirname&lt;span&gt;(&lt;/span&gt;__file__&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
	              &lt;span&gt;&quot;type_check_examples/function.py&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
	          &lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
	          &lt;span&gt;&quot;--no-incremental&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
	      &lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
	  &lt;span&gt;)&lt;/span&gt;
	
	  actual &lt;span&gt;=&lt;/span&gt; result&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;splitlines&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
	  expected &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;
	      &lt;span&gt;# fmt: off&lt;/span&gt;
	      &lt;span&gt;&apos;type_check_examples/function.py:14: error: Incompatible return value type (got &quot;str&quot;, expected &quot;int&quot;)&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;  &lt;span&gt;# noqa: E501&lt;/span&gt;
	      &lt;span&gt;&apos;type_check_examples/function.py:19: error: Missing positional argument &quot;x&quot; in call to &quot;__call__&quot; of &quot;FunctionPipeline&quot;&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;  &lt;span&gt;# noqa: E501&lt;/span&gt;
	      &lt;span&gt;&apos;type_check_examples/function.py:22: error: Argument &quot;x&quot; to &quot;__call__&quot; of &quot;FunctionPipeline&quot; has incompatible type &quot;str&quot;; expected &quot;int&quot;&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;  &lt;span&gt;# noqa: E501&lt;/span&gt;
	      &lt;span&gt;&apos;type_check_examples/function.py:25: note: Revealed type is &quot;builtins.int&quot;&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;  &lt;span&gt;# noqa: E501&lt;/span&gt;
	      &lt;span&gt;&apos;type_check_examples/function.py:28: note: Revealed type is &quot;builtins.int&quot;&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;  &lt;span&gt;# noqa: E501&lt;/span&gt;
	      &lt;span&gt;&apos;type_check_examples/function.py:34: error: Unexpected keyword argument &quot;notify_on&quot; for &quot;options&quot; of &quot;Expression&quot;&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;  &lt;span&gt;# noqa: E501&lt;/span&gt;
	      &lt;span&gt;&apos;pipeline.py:307: note: &quot;options&quot; of &quot;Expression&quot; defined here&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;  &lt;span&gt;# noqa: E501&lt;/span&gt;
	      &lt;span&gt;&quot;Found 4 errors in 1 file (checked 1 source file)&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
	      &lt;span&gt;# fmt: on&lt;/span&gt;
	  &lt;span&gt;]&lt;/span&gt;
	
	  self&lt;span&gt;.&lt;/span&gt;assertEqual&lt;span&gt;(&lt;/span&gt;actual&lt;span&gt;,&lt;/span&gt; expected&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;3. GitHub 上的问题&lt;/h3&gt;
&lt;div&gt;当搜索如何解决某个类型问题时，我经常会找到 Mypy 的 &lt;a href=&quot;https://github.com/python/mypy/issues&quot;&gt;GitHub Issues&lt;/a&gt; （比 Stack Overflow 还多）。它可能是 Mypy 类型相关问题的解决方案和 How-To 的最佳知识源头。你会发现其核心团队（包括 Guido）对重要问题的提示和建议。&lt;/div&gt;
&lt;div&gt;主要的缺点是，GitHub Issue 中的每个评论仅仅是某个特定时刻的评论——2018 年的一个问题可能已经解决了，去年的一个变通方案可能有了新的最佳实践。所以在查阅 issue 时，一定要把这一点牢记于心。&lt;/div&gt;
&lt;h3&gt;4. typing-extensions&lt;/h3&gt;
&lt;div&gt;&lt;code&gt;typing&lt;/code&gt; 模块在每个 Python 版本中都有很多改进，同时，还有一些特性会通过&lt;code&gt;typing-extensions&lt;/code&gt; 模块向后移植。&lt;/div&gt;
&lt;div&gt;例如，虽然只使用 Python 3.8，但我们借助&lt;code&gt;typing-extensions&lt;/code&gt; ，在前面提到的工作流编排库中使用了3.10 版本的&lt;code&gt;ParamSpec&lt;/code&gt;。（遗憾的是，PyCharm 似乎不支持通过&lt;code&gt;typing-extensions&lt;/code&gt; 引入的&lt;code&gt;ParamSpec&lt;/code&gt; 语法，并将其标记为一个错误，但是，还算好吧。）当然，Python 本身语法变化而出现的特性，不能通过&lt;code&gt;typing-extensions&lt;/code&gt; 获得。&lt;/div&gt;
&lt;h3&gt;5. NewType&lt;/h3&gt;
&lt;div&gt;在 &lt;code&gt;typing&lt;/code&gt; 模块中有很多有用的辅助对象，&lt;code&gt;NewType&lt;/code&gt; 是我的最爱之一。&lt;/div&gt;
&lt;div&gt;&lt;code&gt;NewType&lt;/code&gt; 可让你创建出不同于现有类型的类型。例如，你可以使用&lt;code&gt;NewType&lt;/code&gt; 来定义合规的谷歌云存储 URL，而不仅是&lt;code&gt;str&lt;/code&gt; 类型，比如：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; typing &lt;span&gt;import&lt;/span&gt; NewType

GCSUrl &lt;span&gt;=&lt;/span&gt; NewType&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;GCSUrl&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;download_blob&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;url&lt;span&gt;:&lt;/span&gt; GCSUrl&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

&lt;span&gt;# Incompatible type &quot;str&quot;; expected &quot;GCSUrl&quot;&lt;/span&gt;
download_blob&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;gs://my_bucket/foo/bar/baz.jpg&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# Ok!&lt;/span&gt;
download_blob&lt;span&gt;(&lt;/span&gt;GCSUrl&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;gs://my_bucket/foo/bar/baz.jpg&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;通过向&lt;code&gt;download_blob&lt;/code&gt; 的调用者指出它的意图，我们使这个函数具备了自描述能力。&lt;/div&gt;
&lt;div&gt;我发现 &lt;code&gt;NewType&lt;/code&gt;对于将原始类型（如 &lt;code&gt;str&lt;/code&gt; 和 &lt;code&gt;int&lt;/code&gt; ）转换为语义上有意义的类型特别有用。&lt;/div&gt;
&lt;h3&gt;6. 性能&lt;/h3&gt;
&lt;div&gt;Mypy 的性能并不是我们的主要问题。Mypy 将类型检查结果保存到缓存中，能加快重复调用的速度（据其文档称：“Mypy 增量地执行类型检查，复用前一次运行的结果，以加快后续运行的速度”）。&lt;/div&gt;
&lt;div&gt;在我们最大的服务中运行 &lt;code&gt;mypy&lt;/code&gt;，冷缓存大约需要 50-60 秒，热缓存大约需要 1-2 秒。&lt;/div&gt;
&lt;div&gt;至少有两种方法可以加速 Mypy，这两种方法都利用了以下的技术（我们内部没有使用）：&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://mypy.readthedocs.io/en/stable/mypy_daemon.html&quot;&gt;Mypy 守护进程&lt;/a&gt;在后台持续运行 Mypy，让它在内存中保持缓存状态。虽然 Mypy 在运行后将结果缓存到磁盘，但是守护进程确实是更快。（我们使用了一段时间的默认 Mypy 守护进程，但因共享状态导致一些问题后，我禁用了它——我不记得具体细节了。）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mypy.readthedocs.io/en/stable/additional_features.html#using-a-remote-cache-to-speed-up-mypy-runs&quot;&gt;共享远程缓存&lt;/a&gt;。如前所述，Mypy 在每次运行后都会将类型检查结果缓存到磁盘——但是如果在新机器或新容器上运行 Mypy（就像在 CI 上一样），则不会有缓存的好处。解决方案是在磁盘上预置一个最近的缓存结果（即，预热缓存）。Mypy 文档概述了这个过程，但它相当复杂，具体内容取决于你自己的设置。我们最终可能会在自己的 CI 系统中启用它——暂时还没有去做。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;div&gt;Mypy 对我们产生了很大的影响，提升了我们发布代码时的信心。虽然采纳它需要付出一定的成本，但我们并不后悔。&lt;/div&gt;
&lt;div&gt;除了工具本身的价值之外，Mypy 还是一个让人印象非常深刻的项目，我非常感谢维护者们多年来为它付出的工作。在每一个 Mypy 和 Python 版本中，我们都看到了对 &lt;code&gt;typing&lt;/code&gt;模块、注解语法和 Mypy 本身的显著改进。（例如：新的联合类型语法（ &lt;code&gt;X|Y&lt;/code&gt;）、 &lt;code&gt;ParamSpec&lt;/code&gt; 和 &lt;code&gt;TypeAlias&lt;/code&gt;，这些都包含在 Python 3.10 中。）&lt;/div&gt;
&lt;div&gt;英文原文发布于 2022 年 8 月 21 日。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>PyCharm 2022.2 发布了，支持最新 Python 3.11 和 PyScript 框架！</title>
            <link>https://pythoncat.top/posts/2022-08-13-pycharm/</link>
            <guid>https://pythoncat.top/posts/2022-08-13-pycharm/</guid>
            <description>PyCharm 依然是最专业的 Python IDE，新版本紧跟社区发展，让人不得不爱</description>
            <pubDate>Sat, 13 Aug 2022 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;英文：&lt;a href=&quot;https://blog.jetbrains.com/pycharm/2022/07/2022-2&quot;&gt;Jet Brains官网&lt;/a&gt;；翻译：Python猫&lt;/div&gt;
&lt;div&gt;通常而言，使用新潮的或者快速发展的技术，可能会挺有挑战性，你可能得经常阅读文档，才能熟悉新的语法、API 和协议。&lt;/div&gt;
&lt;div&gt;PyCharm 2022.2 通过提供对 Python 3.11 的语言特性和新的 PyScript 框架的支持，能够帮助你完成这一过程。&lt;/div&gt;
&lt;div&gt;让我们来看看它里面有什么吧！&lt;/div&gt;
&lt;h2&gt;Python 3.11&lt;/h2&gt;
&lt;div&gt;PyCharm 2022.2 已经为 Python 3.11 中一些主要的功能提供了代码洞察（code insight），例如异常组和 &lt;code&gt;except *&lt;/code&gt; 运算符（&lt;a href=&quot;https://peps.python.org/pep-0654/&quot;&gt;PEP 654&lt;/a&gt;）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;以及新的用于 TypedDict 个别键的 Required[] 和 NotRequired[] 标记符号（&lt;a href=&quot;https://peps.python.org/pep-0655/&quot;&gt;PEP 655&lt;/a&gt;）。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;HTTP Client&lt;/h2&gt;
&lt;div&gt;PyCharm 2022.2 支持 WebSocket 连接。有了这个 API，你可以在给服务端发送消息后，接收由事件驱动的响应，而不需轮询服务器来获取结果。&lt;/div&gt;
&lt;div&gt;PyCharm 如今可以基于开箱即用的 HTTP 和 WebSocket 协议来发送请求。&lt;code&gt;ws://&lt;/code&gt; 与 &lt;code&gt;wss://&lt;/code&gt;  表示的是使用 WebSocket 请求协议。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;此外，PyCharm 2022.2 还提供了一种更简单的方法来选择运行环境——使用代码侧边栏上的图标。&lt;a href=&quot;https://mp.weixin.qq.com/s/3UD7vOwdV9j0F5yjW5X8KA&quot;&gt;原文&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;若要启用此功能，请从*“Run with*”下拉框中选择“&lt;em&gt;Select Environment Before Run&lt;/em&gt;”选项。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;用于设置远程解释器的新 UI&lt;/h2&gt;
&lt;div&gt;PyCharm 2022.2 引入了一个新的向导，用于在远程目标上设置解释器（如 WSL、SSH、Docker、Docker Compose 或 Vagrant）。它使得设置的过程更加结构化且易于操作。&lt;/div&gt;
&lt;div&gt;若要找到新向导，依次打开“Settings | Preferences | Python Interpreter”，然后单击窗口右上角的“Add Interpreter”链接，或单击编辑器右下角的解释器，并选择“Add New Interpreter”。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;运行当前文件&lt;/h2&gt;
&lt;div&gt;在没有使用运行配置的情况下，想要立即运行和调试单个文件，请从*“&lt;strong&gt;Run/Debug&lt;/strong&gt;”&lt;em&gt;小组件中，选择&lt;/em&gt;“&lt;strong&gt;Run Current File&lt;/strong&gt;”*。&lt;a href=&quot;https://mp.weixin.qq.com/s/3UD7vOwdV9j0F5yjW5X8KA&quot;&gt;原文&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它拥有一个二级菜单，这个菜单提供了几个实用的运行器以及*“&lt;strong&gt;Run with Parameters&lt;/strong&gt;”*操作，你可以在运行文件之前，调整这个操作的运行配置参数。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;对 PyScript 的初步支持&lt;/h2&gt;
&lt;div&gt;PyScript 是一个可在浏览器中创建丰富的 Python 应用的框架，使用 HTML 界面和 Pyodide、WASM 以及其它现代的 web 技术。  &lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUyOTk2MTcwNg==&amp;amp;action=getalbum&amp;amp;album_id=1413329638813827073&amp;amp;scene=21#wechat_redirect&quot;&gt;+&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&amp;lt;py-script&amp;gt; 标签支持执行多行 Python 脚本，可与页面作交互。 PyCharm 2022.2 能够识别 HTML 文件的 &amp;lt;py-script&amp;gt; 标签内的 Python 代码，包括 NumPy 和 Matplotlib 库的语法，并为其提供正确的代码补全和高亮显示。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;目前，代码补全和语法高亮功能已支持部分的 PyScript 标签，例如用于声明依赖项的 &amp;lt;py-env&amp;gt; 标签，以及用于创建 REPL 组件的 &amp;lt;py-repl&amp;gt; 标签。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;Jupyter Notebooks&lt;/h2&gt;
&lt;div&gt;PyCharm 2022.2 增强了 Jupyter Notebook 的用户体验。&lt;/div&gt;
&lt;div&gt;你可以使用 Jupyter 编辑器工具栏中相应的按钮和图标，更轻松地剪切、复制和粘贴单元格。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;你还可以轻松地拖动图像的下边框来调整图像的大小。从而提高这些执行结果的可读性。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;数据库管理&lt;/h2&gt;
&lt;div&gt;PyCharm 2022.2 支持将多个 CSV 文件导入到新的或现有的数据库表中。&lt;/div&gt;
&lt;div&gt;操作方法：在“项目视图”中选择多个文件，并将它们拖到数据库 schema 中。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;PyCharm 2022.2 有两种解析 SQL 脚本的模式。在 &lt;em&gt;Playground&lt;/em&gt; 模式中, 对象根据上下文而被解析。这种模式如今是查询控制台的默认解析模式。&lt;/div&gt;
&lt;div&gt;在 Script 模式中，文件的开头部分被解析成上下文，但是，只要脚本中出现“SET CURRENT SCHEMA” 语句，它就会改变用于解析的上下文。这种模式如今是本地文件的默认解析模式。&lt;/div&gt;
&lt;div&gt;想要切换解析模式，只需使用工具栏的下拉选项。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;Docker&lt;/h2&gt;
&lt;div&gt;现在，你可以使用新的“Copy Docker Image”操作，轻松地将镜像从一个 Docker 进程复制到另一个 Docker 里，该操作会将镜像保存成一个文件，然后将其推送到所选的连接。&lt;/div&gt;
&lt;div&gt;PyCharm 还与 Colima 和 Racher 集成，可支持更多与 Docker 进程建立连接的操作。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;此外，PyCharm 2022.2 会在重启 IDE 后，自动连接到 Docker。&lt;/div&gt;
&lt;div&gt;默认情况下，此新设置处于启用状态，可以在“Settings | Preferences | Advanced Settings | Docker”关闭。&lt;/div&gt;
&lt;div&gt;以上内容是新版本 Pycharm 中最显著的新功能和可用性改进。更多详情，还可查阅 &lt;a href=&quot;https://www.jetbrains.com/pycharm/whatsnew&quot;&gt;https://www.jetbrains.com/pycharm/whatsnew&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>7 行代码搞崩溃 B 站，原因令人唏嘘！</title>
            <link>https://pythoncat.top/posts/2022-07-29-Bilibili/</link>
            <guid>https://pythoncat.top/posts/2022-07-29-Bilibili/</guid>
            <description>B 站去年崩溃的罪魁祸首竟然只是 7 行代码，Lua 这门语言真让人印象深刻啊</description>
            <pubDate>Fri, 29 Jul 2022 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;前不久，哔哩哔哩（一般常称为 B 站）发布了一篇文章《2021.07.13 我们是这样崩的》，详细回顾了他们在 2021.07.13 晚上全站崩溃约 3 小时的至暗时刻，以及万分紧张的故障定位与恢复过程。&lt;/div&gt;
&lt;div&gt;那篇文章将定位过程、问题分析、优化改进等方面写得很详细，在我印象中，国内互联网大厂在发生类似事故后，能够如此开诚布公地“检讨”“还债”的并不多见。（值得送上一键三连~~~）&lt;/div&gt;
&lt;div&gt;对于搞技术的同学来说，这篇文章是不错的学习材料。而我最为关注的内容，其实是关于编程语言的特性，也就是在代码层面上的细节问题。&lt;/div&gt;
&lt;div&gt;在关于问题根因的分析中，我们看到了罪魁祸首的 7 行代码，它是用 Lua 语言写的一个求最大公约数的函数：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;简单而言，这个函数预期接收的参数是两个数字（普通的数字或者字符串类型的数字，即两种类型都可以），然而，它的 if 语句却只判断了一种类型（普通数字），忽略了字符串类型的“0”。&lt;/div&gt;
&lt;div&gt;在故障发生时，它的第二个参数传入的是字符串类型“0”而不是数字类型 0，导致 if 语句判断失效！&lt;/div&gt;
&lt;div&gt;由于 Lua 是动态类型语言，只有在程序运行时才知道传入的参数是什么类型。这属于是所有动态类型语言的特色，在 Python、JavaScript、PHP、Ruby 等动态类型语言中，也会有同样的表现。这不是啥新鲜事物。&lt;/div&gt;
&lt;div&gt;然而，真正该死的问题在于，Lua 还是一门&lt;strong&gt;弱类型语言&lt;/strong&gt;，它不像 Python、Ruby、Java 等&lt;strong&gt;强类型语言&lt;/strong&gt;那样，它竟支持&lt;strong&gt;隐式类型转换！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;在 Lua 中，数字字符串在与普通数字作算术运算时，会将字符串类型隐式地转换成数字类型，如上图所示的“a % b”，如果 b 是字符串类型的数字，那它就会被转换成数字类型！&lt;/div&gt;
&lt;div&gt;而在 Python 这种&lt;a href=&quot;https://mp.weixin.qq.com/s/GRq8Hg4jqIzCglHRdrWtww&quot;&gt;强类型动态类型语言&lt;/a&gt;中，这样的转换是不可思议的，数字与字符串作算术运算，能得到的只会是报错：TypeError: unsupported operand type(s) for %: ‘int’ and ‘str’&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Lua 语言的这种“字符串隐式变数字”的行为，即使在大意不察觉的情况下，似乎也不会造成太大问题。在 B 站代码中，除了出事故时传的字符串“0”以外，估计它一直接收的都是其它字符串数字，一直也没出问题，显然程序员是把这当成一种便利手段了（因为不需作类型转换）。&lt;/div&gt;
&lt;div&gt;然而，不幸的是，Lua 中还有一个特殊的“nan”，它会进一步将这一个“小小的错误”传递下去，直至传到了地老天荒不受控制的死循环里……&lt;/div&gt;
&lt;div&gt;在大多数编程语言中，除零操作都是不可饶恕的错误，这跟我们在小学数学课堂上就掌握的常识相吻合：&lt;strong&gt;数字零不允许作为除数&lt;/strong&gt;！&lt;/div&gt;
&lt;div&gt;掏出手机，打开计算器，看看它是怎么说的：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;看到了吧！不能除以0！！！&lt;/div&gt;
&lt;div&gt;继续看看 Python 对于这种操作的反应：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;ZeroDivisionError 除零错误，这是在捍卫我们根深蒂固的数学常识。&lt;/div&gt;
&lt;div&gt;那么，Lua 语言在除零操作后得到的 nan 到底是个什么东西呢？&lt;/div&gt;
&lt;div&gt;nan 一般也被称为“NaN”，是“No a Number”的缩写，表示“不是一个数”。它来头不小，是在 1985 年的	IEEE 754	浮点数标准中首次引入的。&lt;/div&gt;
&lt;div&gt;直白地讲，它也是数字类型中的一个值，但是表示的是一个“不可表示的值”。也就是说，它表示的是一个非常抽象概念的数。&lt;/div&gt;
&lt;div&gt;也许我们比较容易理解另一个抽象的数“无穷大”，因为在中学数学课上就经常接触到，而 nan 也是类似的一种特殊的数，只不过它较为少用且更难以捉摸罢了。&lt;/div&gt;
&lt;div&gt;Python 中也有这两个数的存在，即 float(‘inf’) 表示无穷大、float(‘nan’) 表示非数。它们就像是两个黑洞，会吞噬掉任何试图前来“搭讪”的数：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;那么，当这两个黑洞相互靠近时，谁的引力更大些呢？请看示例：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;看来还是 nan 的优先级更高一筹啊。&lt;/div&gt;
&lt;div&gt;然而，尽管 Python 中有 nan，但它并不因为这个数而抛弃前文提到的常识。而同为脚本语言的 Lua 却抛弃了常识， 在出现除零这种非法操作时，它不是报错，而是得到 nan 的结果。&lt;/div&gt;
&lt;div&gt;这样的特性简直是自由得过分，也许在某些时候会挺有用吧，但它也会埋下未知的隐患。&lt;/div&gt;
&lt;div&gt;回到 B 站的问题代码，弱类型的 Lua 语言由于太过自由，它放行了字符串数字与普通数字的运算，又因为对 nan 过于自由的使用，它放行了数字除零的操作，两次的放行，使得短短几行代码一路畅行不止，一路消耗服务器资源，直到 CPU 100%，直到牵动服务集群故障，直到高可用的多活机房服务不可用，导致全站崩溃 3 小时的事故……&lt;/div&gt;
&lt;div&gt;当然了，如果当初写下这段代码的程序员多加一个条件判断，这一次的事故就完全可以避免。从另外的视角看，这就是程序员在递归程序的终止条件上处理不当，不能甩锅给编程语言那两项自由不羁的语言特性。&lt;/div&gt;
&lt;div&gt;但是，我相信写下那段代码的程序员大概率是长期使用其它编程语言，现学现卖上手写 Lua，尽管知道 Lua 语言动态弱类型的特点，但思维习惯上仍深受其它语言影响，这才“一时失足、小河翻船”……程序员内心有苦说不出！！&lt;/div&gt;
&lt;div&gt;短短的 7 行代码，说简单就简单，说不简单也不简单。本文就不展开说辗转相除法求最大公约数了（说来话长），单单是前面提及的隐式类型转换加上除零得 nan 的细节问题，就足够导致一场大事故了。&lt;/div&gt;
&lt;div&gt;从 7 行问题代码中，作为吃瓜群众的我们，能得到些什么收获呢？到底是涨见识了，还是“又学废了”呢？&lt;/div&gt;
&lt;div&gt;人生苦短，不求无 Bug，但求读者老爷们赏个一键三连吧~~~&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>警惕！Python 中少为人知的 10 个安全陷阱！</title>
            <link>https://pythoncat.top/posts/2022-02-14-security/</link>
            <guid>https://pythoncat.top/posts/2022-02-14-security/</guid>
            <description>分享一些容易忽视的安全问题：被优化掉的断言、MakeDirs 权限、绝对路径拼接、任意的临时文件、扩展的 Zip Slip、不完整的正则表达式匹配、Unicode 清洗器绕过、Unicode 编码碰撞、IP 地址归一化、URL 查询参数解析</description>
            <pubDate>Mon, 14 Feb 2022 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;作者：Dennis Brinkrolf&lt;/div&gt;
&lt;div&gt;译者：豌豆花下猫@Python猫&lt;/div&gt;
&lt;div&gt;英文：&lt;a href=&quot;https://blog.sonarsource.com/10-unknown-security-pitfalls-for-python&quot;&gt;10 Unknown Security Pitfalls for Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;声明：本翻译是出于交流学习的目的，基于 CC BY-NC-SA 4.0 授权协议。为便于阅读，内容略有改动。&lt;/div&gt;
&lt;div&gt;Python 开发者们在使用标准库和通用框架时，都以为自己的程序具有可靠的安全性。然而，在 Python 中，就像在任何其它编程语言中一样，有一些特性可能会被开发者们误解或误用。通常而言，只有极少的微妙之处或细节会使开发者们疏忽大意，从而在代码中引入严重的安全漏洞。&lt;/div&gt;
&lt;div&gt;在这篇博文中，我们将分享在实际 Python 项目中遇到的 10 个安全陷阱。我们选择了一些在技术圈中不太为人所知的陷阱。通过介绍每个问题及其造成的影响，我们希望提高人们对这些问题的感知，并提高大家的安全意识。如果你正在使用这些特性，请一定要排查你的 Python 代码！&lt;/div&gt;
&lt;h2&gt;1.被优化掉的断言&lt;/h2&gt;
&lt;div&gt;Python 支持以优化的方式执行代码。这使代码运行得更快，内存用得更少。当程序被大规模使用，或者可用的资源很少时，这种方法尤其有效。一些预打包的 Python 程序提供了优化的字节码。&lt;/div&gt;
&lt;div&gt;然而，当代码被优化时，所有的 assert 语句都会被忽略。开发者有时会使用它们来判断代码中的某些条件。例如，如果使用断言来作身份验证检查，则可能导致安全绕过。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;superuser_action&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;request&lt;span&gt;,&lt;/span&gt; user&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;assert&lt;/span&gt; user&lt;span&gt;.&lt;/span&gt;is_super_user
    &lt;span&gt;# execute action as super user&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在这个例子中，第 2 行中的 assert 语句将被忽略，导致非超级用户也可以运行到下一行代码。不推荐使用 assert 语句进行安全相关的检查，但我们确实在实际的项目中看到过它们。&lt;/div&gt;
&lt;h2&gt;2. MakeDirs 权限&lt;/h2&gt;
&lt;div&gt;&lt;code&gt;os.makdirs&lt;/code&gt; 函数可以在操作系统中创建一个或多个文件夹。它的第二个参数 mode 用于指定创建的文件夹的默认权限。在下面代码的第 2 行中，文件夹 A/B/C 是用 rwx------ (0o700) 权限创建的。这意味着只有当前用户（所有者）拥有这些文件夹的读、写和执行权限。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;init_directories&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;request&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    os&lt;span&gt;.&lt;/span&gt;makedirs&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;A/B/C&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; mode&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0o700&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; HttpResponse&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Done!&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在 Python &amp;lt; 3.6 版本中，创建出的文件夹 A、B 和 C 的权限都是 700。但是，在 Python &amp;gt; 3.6 版本中，只有最后一个文件夹 C 的权限为 700，其它文件夹 A 和 B 的权限为默认的 755。&lt;/div&gt;
&lt;div&gt;因此，在 Python &amp;gt; 3.6 中，&lt;code&gt;os.makdirs&lt;/code&gt; 函数等价于 Linux 的这条命令：&lt;code&gt;mkdir -m 700 -p A/B/C&lt;/code&gt;。
有些开发者没有意识到版本之间的差异，这已经在 Django 中造成了一个权限越级漏洞（cve - 2022 -24583），无独有偶，这在 WordPress 中也造成了一个&lt;a href=&quot;https://blog.sonarsource.com/wordpress-hardening-bypass&quot;&gt;加固绕过&lt;/a&gt;&lt;a href=&quot;https://blog.sonarsource.com/wordpress-hardening-bypass&quot;&gt;问题&lt;/a&gt;。&lt;/div&gt;
&lt;h2&gt;3.绝对路径拼接&lt;/h2&gt;
&lt;div&gt;&lt;code&gt;os.path.join(path, *paths)&lt;/code&gt; 函数用于将多个文件路径连接成一个组合的路径。第一个参数通常包含了基础路径，而之后的每个参数都被当做组件拼接到基础路径后。&lt;/div&gt;
&lt;div&gt;然而，这个函数有一个少有人知的特性。如果拼接的某个路径以 / 开头，那么包括基础路径在内的所有前缀路径都将被删除，该路径将被视为绝对路径。下面的示例揭示了开发者可能遇到的这个陷阱。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;read_file&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;request&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    filename &lt;span&gt;=&lt;/span&gt; request&lt;span&gt;.&lt;/span&gt;POST&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;filename&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
    file_path &lt;span&gt;=&lt;/span&gt; os&lt;span&gt;.&lt;/span&gt;path&lt;span&gt;.&lt;/span&gt;join&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;var&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;lib&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; filename&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; file_path&lt;span&gt;.&lt;/span&gt;find&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;.&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; HttpResponse&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Failed!&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;file_path&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; HttpResponse&lt;span&gt;(&lt;/span&gt;f&lt;span&gt;.&lt;/span&gt;read&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; content_type&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;text/plain&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在第 3 行中，我们使用 os.path.join 函数将用户输入的文件名构造出目标路径。在第 4 行中，检查生成的路径是否包含”.“，防止出现路径遍历漏洞。&lt;/div&gt;
&lt;div&gt;但是，如果攻击者传入的文件名参数为”/a/b/c.txt“，那么第 3 行得到的变量 file_path 会是一个绝对路径（/a/b/c.txt）。即 os.path.join 会忽略掉”var/lib“部分，攻击者可以不使用“.”字符就读取到任何文件。尽管 os.path.join 的文档中描述了这种行为，但这还是导致了许多漏洞（&lt;a href=&quot;https://www.gdatasoftware.com/blog/2014/10/23943-cuckoo-sandbox-evasion-poc-available&quot;&gt;Cuckoo Sandbox&lt;/a&gt;&lt;a href=&quot;https://www.gdatasoftware.com/blog/2014/10/23943-cuckoo-sandbox-evasion-poc-available&quot;&gt; Evasion&lt;/a&gt;， &lt;a href=&quot;https://www.cvedetails.com/cve/CVE-2020-35736/&quot;&gt;CVE-2020-35736&lt;/a&gt;）。&lt;/div&gt;
&lt;h2&gt;4. 任意的临时文件&lt;/h2&gt;
&lt;div&gt;&lt;code&gt;tempfile.NamedTemporaryFile&lt;/code&gt; 函数用于创建具有特定名称的临时文件。但是，prefix（前缀）和 suffix（后缀）参数很容易受到路径遍历攻击（&lt;a href=&quot;https://bugs.python.org/issue35278&quot;&gt;Issue &lt;/a&gt;&lt;a href=&quot;https://bugs.python.org/issue35278&quot;&gt;35278&lt;/a&gt;）。如果攻击者控制了这些参数之一，他就可以在文件系统中的任意位置创建出一个临时文件。下面的示例揭示了开发者可能遇到的一个陷阱。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;touch_tmp_file&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;request&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;id&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; request&lt;span&gt;.&lt;/span&gt;GET&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;id&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
    tmp_file &lt;span&gt;=&lt;/span&gt; tempfile&lt;span&gt;.&lt;/span&gt;NamedTemporaryFile&lt;span&gt;(&lt;/span&gt;prefix&lt;span&gt;=&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; HttpResponse&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;tmp file: &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;tmp_file&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt; created!&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; content_type&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;text/plain&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在第 3 行中，用户输入的 id 被当作临时文件的前缀。如果攻击者传入的 id 参数是“/../var/www/test”，则会创建出这样的临时文件：/var/www/test_zdllj17。粗看起来，这可能是无害的，但它会为攻击者创造出挖掘更复杂的漏洞的基础。&lt;/div&gt;
&lt;h2&gt;5.扩展的 Zip Slip&lt;/h2&gt;
&lt;div&gt;在 Web 应用中，通常需要解压上传后的压缩文件。在 Python 中，很多人都知道 TarFile.extractall 与 TarFile.extract 函数容易受到 Zip Slip 攻击。攻击者通过篡改压缩包中的文件名，使其包含路径遍历（../）字符，从而发起攻击。&lt;/div&gt;
&lt;div&gt;这就是为什么压缩文件应该始终被视为不受信来源的原因。zipfile.extractall 与 zipfile.extract 函数可以对 zip 内容进行清洗，从而防止这类路径遍历漏洞。&lt;/div&gt;
&lt;div&gt;但是，这并不意味着在 ZipFile 库中不会出现路径遍历漏洞。下面是一段解压缩文件的代码。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;extract_html&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;request&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    filename &lt;span&gt;=&lt;/span&gt; request&lt;span&gt;.&lt;/span&gt;FILES&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;filename&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
    zf &lt;span&gt;=&lt;/span&gt; zipfile&lt;span&gt;.&lt;/span&gt;ZipFile&lt;span&gt;(&lt;/span&gt;filename&lt;span&gt;.&lt;/span&gt;temporary_file_path&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;r&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; entry &lt;span&gt;in&lt;/span&gt; zf&lt;span&gt;.&lt;/span&gt;namelist&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; entry&lt;span&gt;.&lt;/span&gt;endswith&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;.html&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            file_content &lt;span&gt;=&lt;/span&gt; zf&lt;span&gt;.&lt;/span&gt;read&lt;span&gt;(&lt;/span&gt;entry&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;entry&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;wb&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; fp&lt;span&gt;:&lt;/span&gt;
                fp&lt;span&gt;.&lt;/span&gt;write&lt;span&gt;(&lt;/span&gt;file_content&lt;span&gt;)&lt;/span&gt;
    zf&lt;span&gt;.&lt;/span&gt;close&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; HttpResponse&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;HTML files extracted!&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;第 3 行代码根据用户上传文件的临时路径，创建出一个 ZipFile 处理器。第 4 - 8 行代码将所有以“.html”结尾的压缩项提取出来。第 4 行中的 zf.namelist 函数会取到 zip 内压缩项的名称。注意，只有 zipfile.extract 与 zipfile.extractall 函数会对压缩项进行清洗，其它任何函数都不会。&lt;/div&gt;
&lt;div&gt;在这种情况下，攻击者可以创建一个文件名，例如“../../../var/www/html”，内容随意填。该恶意文件的内容会在第 6 行被读取，并在第 7-8 行写入被攻击者控制的路径。因此，攻击者可以在整个服务器上创建任意的 HTML 文件。&lt;/div&gt;
&lt;div&gt;如上所述，压缩包中的文件应该被看作是不受信任的。如果你不使用 zipfile.extractall 或者 zipfile.extract，你就必须对 zip 内文件的名称进行“消毒”，例如使用 os.path.basename。否则，它可能导致严重的安全漏洞，就像在 NLTK Downloader （&lt;a href=&quot;https://nvd.nist.gov/vuln/detail/CVE-2019-14751&quot;&gt;CVE-2019-14751&lt;/a&gt;）中发现的那样。&lt;/div&gt;
&lt;h2&gt;6. 不完整的正则表达式匹配&lt;/h2&gt;
&lt;div&gt;正则表达式（regex）是大多数 Web 程序不可或缺的一部分。我们经常能看到它被自定义的 Web 应用防火墙（WAF，Web Application Firewalls）用来作输入验证，例如检测恶意字符串。在 Python 中，re.match 和 re.search 之间有着细微的区别，我们将在下面的代码片段中演示。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;is_sql_injection&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;request&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    pattern &lt;span&gt;=&lt;/span&gt; re&lt;span&gt;.&lt;/span&gt;&lt;span&gt;compile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;r&quot;.*(union)|(select).*&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    name_to_test &lt;span&gt;=&lt;/span&gt; request&lt;span&gt;.&lt;/span&gt;GET&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; re&lt;span&gt;.&lt;/span&gt;search&lt;span&gt;(&lt;/span&gt;pattern&lt;span&gt;,&lt;/span&gt; name_to_test&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在第 2 行中，我们定义了一个匹配 union 或者 select 的模式，以检测可能的 SQL 注入。这是一个糟糕的写法，因为你可以轻易地绕过这些黑名单，但我们已经在线上的程序中见过它。在第 4 行中，函数 re.match 使用前面定义好的模式，检查第 3 行中的用户输入内容是否包含这些恶意的值。&lt;/div&gt;
&lt;div&gt;然而，与 re.search 函数不同的是，re.match 函数不匹配新行。例如，如果攻击者提交了值 aaaaaa \n union select，这个输入就匹配不上正则表达式。因此，检查可以被绕过，失去保护作用。&lt;/div&gt;
&lt;div&gt;总而言之，我们不建议使用正则表达式黑名单进行任何安全检查。&lt;/div&gt;
&lt;h2&gt;7. Unicode 清洗器绕过&lt;/h2&gt;
&lt;div&gt;Unicode 支持用多种形式来表示字符，并将这些字符映射到码点。在 Unicode 标准中，不同的 Unicode 字符有四种归一化方案。程序可以使用这些归一化方法，以独立于人类语言的标准方式来存储数据，例如用户名。&lt;/div&gt;
&lt;div&gt;然而，攻击者可以利用这些归一化，这已经导致了 Python 的 urllib 出现漏洞（CVE-2019-9636）。下面的代码片段演示了一个基于 NFKC 归一化的跨站点脚本漏洞（XSS,Cross-Site Scripting）。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; unicodedata
&lt;span&gt;from&lt;/span&gt; django&lt;span&gt;.&lt;/span&gt;shortcuts &lt;span&gt;import&lt;/span&gt; render
&lt;span&gt;from&lt;/span&gt; django&lt;span&gt;.&lt;/span&gt;utils&lt;span&gt;.&lt;/span&gt;html &lt;span&gt;import&lt;/span&gt; escape

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;render_input&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;request&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    user_input &lt;span&gt;=&lt;/span&gt; escape&lt;span&gt;(&lt;/span&gt;request&lt;span&gt;.&lt;/span&gt;GET&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;p&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    normalized_user_input &lt;span&gt;=&lt;/span&gt; unicodedata&lt;span&gt;.&lt;/span&gt;normalize&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;NFKC&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; user_input&lt;span&gt;)&lt;/span&gt;
    context &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;my_input&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; normalized_user_input&lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; render&lt;span&gt;(&lt;/span&gt;request&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;test.html&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; context&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在第 6 行中，用户输入的内容被 Django 的 escape 函数处理了，以防止 XSS 漏洞。在第 7 行中，经过清洗的输入被 NFKC 算法归一化，以便在第 8-9 行中通过 test.html 模板正确地渲染。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;templates/test.html&lt;/strong&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE&lt;/span&gt; &lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;html&lt;/span&gt; &lt;span&gt;lang&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;en&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
{{ my_input | safe}}
&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在模板 test.html 中，第 4 行的变量 my_input 被标记为安全的，因为开发人员预期有特殊字符，并且认为该变量已经被 escape 函数清洗了。通过标记关键字 safe, Django 不会再次对变量进行清洗。&lt;/div&gt;
&lt;div&gt;但是，由于第 7 行（view.py）的归一化，字符“%EF%B9%A4”会被转换为“&amp;lt;”，“%EF%B9%A5”被转换为“&amp;gt;”。这导致攻击者可以注入任意的 HTML 标记，进而触发 XSS 漏洞。为了防止这个漏洞，就应该在把用户输入做完归一化之后，再进行清洗。&lt;/div&gt;
&lt;h2&gt;8. Unicode 编码碰撞&lt;/h2&gt;
&lt;div&gt;前文说过，Unicode 字符会被映射成码点。然而，有许多不同的人类语言，Unicode 试图将它们统一起来。这就意味着不同的字符很有可能拥有相同的“layout”。例如，小写的土耳其语 ı（没有点）的字符是英语中大写的 I。在拉丁字母中，字符 i 也是用大写的 I 表示。在 Unicode 标准中，这两个不同的字符都以大写形式映射到同一个码点。&lt;/div&gt;
&lt;div&gt;这种行为是可以被利用的，实际上已经在 Django 中导致了一个严重的漏洞（&lt;a href=&quot;https://nvd.nist.gov/vuln/detail/CVE-2019-19844&quot;&gt;CVE-2019-19844&lt;/a&gt;）。下面的代码是一个重置密码的示例。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; django&lt;span&gt;.&lt;/span&gt;core&lt;span&gt;.&lt;/span&gt;mail &lt;span&gt;import&lt;/span&gt; send_mail
&lt;span&gt;from&lt;/span&gt; django&lt;span&gt;.&lt;/span&gt;http &lt;span&gt;import&lt;/span&gt; HttpResponse
&lt;span&gt;from&lt;/span&gt; vuln&lt;span&gt;.&lt;/span&gt;models &lt;span&gt;import&lt;/span&gt; User

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;reset_pw&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;request&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    email &lt;span&gt;=&lt;/span&gt; request&lt;span&gt;.&lt;/span&gt;GET&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;email&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
    result &lt;span&gt;=&lt;/span&gt; User&lt;span&gt;.&lt;/span&gt;objects&lt;span&gt;.&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;email__exact&lt;span&gt;=&lt;/span&gt;email&lt;span&gt;.&lt;/span&gt;upper&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;first&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; result&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; HttpResponse&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;User not found!&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    send_mail&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;Reset Password&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;Your new pw: 123456.&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;from@example.com&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;email&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; fail_silently&lt;span&gt;=&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; HttpResponse&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Password reset email send!&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;第 6 行代码获取了用户输入的 email，第 7-9 行代码检查这个 email 值，查找是否存在具有该 email 的用户。如果用户存在，则第 10 行代码依据第 6 行中输入的 email 地址，给用户发送邮件。需要指出的是，第 7-9 行中对邮件地址的检查是不区分大小写的，使用了 upper 函数。&lt;/div&gt;
&lt;div&gt;至于攻击，我们假设数据库中存在一个邮箱地址为 &lt;a href=&quot;mailto:foo@mix.com&quot;&gt;foo@mix.com&lt;/a&gt; 的用户。那么，攻击者可以简单地传入 foo@mıx.com 作为第 6 行中的 email，其中 i 被替换为土耳其语 ı。第 7 行代码将邮箱转换成大写，结果是 &lt;a href=&quot;mailto:FOO@MIX.COM&quot;&gt;FOO@MIX.COM&lt;/a&gt;。这意味着找到了一个用户，因此会发送一封重置密码的邮件。&lt;/div&gt;
&lt;div&gt;然而，邮件被发送到第 6 行未转换的邮件地址，也就是包含了土耳其语的 ı。换句话说，其他用户的密码被发送到了攻击者控制的邮件地址。为了防止这个漏洞，可以将第 10 行替换成使用数据库中的用户邮箱。即使发生编码冲突，攻击者在这种情况下也得不到任何好处。&lt;/div&gt;
&lt;h2&gt;9. IP 地址归一化&lt;/h2&gt;
&lt;div&gt;在 Python &amp;lt; 3.8 中，IP 地址会被 ipaddress 库归一化，因此前缀的零会被删除。这种行为乍一看可能是无害的，但它已经在 Django 中导致了一个高严重性的漏洞（&lt;a href=&quot;https://nvd.nist.gov/vuln/detail/CVE-2021-33571&quot;&gt;CVE-2021-33571&lt;/a&gt;）。攻击者可以利用归一化绕过校验程序，发起服务端请求伪造攻击（SSRF，Server-Side Request Forgery）。&lt;/div&gt;
&lt;div&gt;下面的代码展示了如何绕过这样的校验器。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; requests
&lt;span&gt;import&lt;/span&gt; ipaddress

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;send_request&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;request&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    ip &lt;span&gt;=&lt;/span&gt; request&lt;span&gt;.&lt;/span&gt;GET&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;ip&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ip &lt;span&gt;in&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;127.0.0.1&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;0.0.0.0&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; HttpResponse&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Not allowed!&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        ip &lt;span&gt;=&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;ipaddress&lt;span&gt;.&lt;/span&gt;IPv4Address&lt;span&gt;(&lt;/span&gt;ip&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt; ipaddress&lt;span&gt;.&lt;/span&gt;AddressValueError&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; HttpResponse&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Error at validation!&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    requests&lt;span&gt;.&lt;/span&gt;get&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;https://&apos;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; ip&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; HttpResponse&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Request send!&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;第 5 行代码获取用户传入的一个 IP 地址，第 7 行代码使用一个黑名单来检查该 IP 是否为本地地址，以防止可能的 SSRF 漏洞。这份黑名单并不完整，仅作为示例。&lt;/div&gt;
&lt;div&gt;第 9 行代码检查该 IP 是否为 IPv4 地址，同时将 IP 归一化。在完成验证后，第 12 行代码会对该 IP 发起实际的请求。&lt;/div&gt;
&lt;div&gt;但是，攻击者可以传入 127.0.001 这样的 IP 地址，在第 7 行的黑名单列表中找不到。然后，第 9 行代码使用 ipaddress.IPv4Address 将 IP 归一化为 127.0.0.1。因此，攻击者就能够绕过 SSRF 校验器，并向本地网络地址发送请求。&lt;/div&gt;
&lt;h2&gt;10. URL 查询参数解析&lt;/h2&gt;
&lt;div&gt;在 Python &amp;lt; 3.7 中，urllib.parse.parse_qsl 函数允许使用“;”和“&amp;amp;”字符作为 URL 的查询变量的分隔符。有趣的是“;”字符不能被其它语言识别为分隔符。&lt;/div&gt;
&lt;div&gt;在下面的例子中，我们将展示为什么这种行为会导致漏洞。假设我们正在运行一个基础设施，其中前端是一个 PHP 程序，后端则是一个 Python 程序。&lt;/div&gt;
&lt;div&gt;攻击者向 PHP 前端发送以下的 GET 请求:&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;GET https://victim.com/?a=1;b=2&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;PHP 前端只识别出一个查询参数“a”，其内容为“1;b=2”。PHP 不把“;”字符作为查询参数的分隔符。现在，前端会将攻击者的请求直接转发给内部的 Python 程序:&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;GET https://internal.backend/?a=1;b=2&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;如果使用了 urllib.parse.parse_qsl，Python 程序会处理成两个查询参数，即“a=1”和“b=2”。这种查询参数解析的差异可能会导致致命的安全漏洞，比如 Django 中的 Web 缓存投毒漏洞（&lt;a href=&quot;https://nvd.nist.gov/vuln/detail/CVE-2021-23336&quot;&gt;CVE-2021-23336&lt;/a&gt;）。&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;div&gt;在这篇博文中，我们介绍了 10 个 Python 安全陷阱，我们认为开发者不太了解它们。每个细微的陷阱都很容易被忽视，并在过去导致了线上程序的安全漏洞。&lt;/div&gt;
&lt;div&gt;正如前文所述，安全陷阱可能出现在各种操作中，从处理文件、目录、压缩文件、URL、IP 到简单的字符串。一种常见的情况是库函数的使用，这些函数可能有意想不到的行为。这提醒我们一定要升级到最新版本，并仔细阅读文档。在 SonarSource 中，我们正在研究这些缺陷，以便将来不断改进我们的代码分析器。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 为什么不设计 do-while 循环结构？</title>
            <link>https://pythoncat.top/posts/2022-01-17-do-while/</link>
            <guid>https://pythoncat.top/posts/2022-01-17-do-while/</guid>
            <description>为什么 Python 不提供这种语法结构呢，这种现状的背后有何种设计考量因素呢？</description>
            <pubDate>Mon, 17 Jan 2022 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在某些编程语言中，例如 C/C++、C#、PHP、Java、JavaScript 等等，do-while 是一种基本的循环结构。&lt;/div&gt;
&lt;div&gt;它的核心语义是：先执行一遍&lt;strong&gt;循环体代码&lt;/strong&gt;，然后执行一遍&lt;strong&gt;条件语句&lt;/strong&gt;，若条件语句判断为真，则继续执行循环体代码，并再次执行条件语句；直到条件语句判断为假，则跳出循环结构。&lt;/div&gt;
&lt;div&gt;流程图如下（Java 示例）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;// 打印小于 20 的数字&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
      &lt;span&gt;int&lt;/span&gt; x &lt;span&gt;=&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
      &lt;span&gt;do&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
         &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;out&lt;span&gt;.&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;value of x : &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; x &lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
         x&lt;span&gt;++&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
         &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;out&lt;span&gt;.&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;\n&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
      &lt;span&gt;}&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 并不支持 do-while 结构，“do”并不是一个有效的关键字。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;那么，为什么 Python 不提供这种语法结构呢，这种现状的背后有何种设计考量因素呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;在回答这个问题之前，让我们再仔细思考一下 do-while 语法可以解决什么问题，看看使用这种结构能带来什么好处？&lt;/div&gt;
&lt;div&gt;最显而易见的好处是：do-while 语法保证了会先执行一遍循环体代码。&lt;/div&gt;
&lt;div&gt;它的使用场景也许不多，但是，跟普通的 while 循环或者 for 循环语法的“&lt;strong&gt;条件前置&lt;/strong&gt;”思想不同，它体现的是一种“&lt;strong&gt;条件后置&lt;/strong&gt;”的编程逻辑，也是一种控制循环的常见方式。&lt;/div&gt;
&lt;div&gt;它们的关系似乎有点像 C/C++ 这些语言中的&lt;code&gt;i++&lt;/code&gt;与&lt;code&gt;++i&lt;/code&gt;操作的区别，在某些特殊场合中，也许会更为高效。&lt;/div&gt;
&lt;div&gt;除了这一特点，这种结构最大的应用场景其实是在 C/C++ 中特殊的&lt;code&gt;do {...} while (0)&lt;/code&gt; 用法。这在很多开源项目的源码中都能找到踪迹，例如 Linux、Redis 以及 CPython 解释器，等等。&lt;/div&gt;
&lt;div&gt;这里面的数字 0 表示布尔值 False，意味着循环只会执行一遍，然后就跳出。&lt;/div&gt;
&lt;div&gt;这样的写法是不是很诡异？所谓“循环”，一般就意味着程序体会被反复执行多次，但是，&lt;code&gt;do {...} while (0)&lt;/code&gt; 却偏偏只需要它执行一遍，这初看起来是有点多余啊。&lt;/div&gt;
&lt;div&gt;这种写法主要用在宏函数的定义中，可以解决宏代码块的编译问题，使代码按照我们的意图而合理分块。&lt;/div&gt;
&lt;div&gt;另外，&lt;code&gt;do {...} while (0)&lt;/code&gt; 结合 break 使用，还可以实现很优雅的跳转控制效果。&lt;/div&gt;
&lt;div&gt;在下面的示例中，步骤 1、4 和 5 要求必须执行，而步骤 2 取决于步骤 1 的执行结果，步骤 3 则取决于步骤 2 的执行结果。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;do&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  &lt;span&gt;// 执行步骤 1 &lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;条件&lt;span&gt;1&lt;/span&gt;失败&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;// 执行步骤 2 &lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;条件&lt;span&gt;2&lt;/span&gt;失败&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;// 执行步骤 3 &lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;条件&lt;span&gt;3&lt;/span&gt;失败&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;// 执行步骤 4&lt;/span&gt;
&lt;span&gt;// 执行步骤 5&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在这种场景中，我们确实只需要按照顺序执行一遍。do-while 结构很清晰，避免造成多层条件嵌套或者设置诸多额外标记的局面。&lt;/div&gt;
&lt;div&gt;最后还有一点，在汇编层面，do-while 比 while 更接近汇编语言的逻辑，可以节省使用指令，在过去的低内存时代，算得上是一种优化写法。&lt;/div&gt;
&lt;div&gt;分析完 do-while 的好处后，让我们回到主题：Python 为什么不需要设计 do-while 循环语法呢？&lt;/div&gt;
&lt;div&gt;首先，Python 离底层应用编程太远了，就不用考虑汇编指令的优化了，同时，它也不涉及宏的使用。&lt;/div&gt;
&lt;div&gt;至于“条件前置”和“条件后置”的区别，其实并没有太大影响，而且，由于 Python 使用简洁优雅的缩进加冒号语法来划分代码块，导致直译过来的 do-while 语法看起来会很怪异（注意，直译的 while 的条件后没有其它内容）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;do&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;想要引入新的语法特性，必然要遵守既定的风格习惯。其它语言的 do-while 结构直译成 Python 的话，肯定不合适。&lt;/div&gt;
&lt;div&gt;事实上，在 2003 年时，有一个 PEP 提议给 Python 加上 do-while 语法支持：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;PEP-315 Enhanced While Loop&lt;/div&gt;
&lt;div&gt;该 PEP 提议增加一个可选的 do 子句，支持将 while 循环扩展成这样子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;do&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;setup code&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;condition&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;loop body&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这不是简单地从其它语言翻译成 Python，它的 while 语句后保留了 Python 的缩进用法，并不会造成直译形式的突兀结果。&lt;/div&gt;
&lt;div&gt;加上 while 循环本身已支持的可选的 else 子句，因此，while 完整的语法结构是这样的：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;while_stmt : [&quot;do&quot; &quot;:&quot; suite]
            &quot;while&quot; expression &quot;:&quot; suite
            [&quot;else&quot; &quot;:&quot; suite]&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;（PS.在本系列的下一篇文章，我们将解释为什么 Python 要支持 while-else 语法）&lt;/div&gt;
&lt;div&gt;也就是说，在保持原 while 循环语法不变的情况下，PEP-315 提议支持在 while 前面使用一个可选的 do 子句。&lt;/div&gt;
&lt;div&gt;do 子句只会执行一遍，当它里面出现 break 时，则跳出整个 do-while 循环；当 do 子句中出现 continue 时，则跳出 do 子句，进到 while 的条件判断中。&lt;/div&gt;
&lt;div&gt;有了 do 子句后，很容易就能实现 &lt;code&gt;do {...} while (0)&lt;/code&gt; 的跳转控制效果。&lt;/div&gt;
&lt;div&gt;但是，这个 PEP 遭到了一些核心开发者的反对。&lt;/div&gt;
&lt;div&gt;反对的理由是，不需要引入新的关键字和语法，仅使用现有语法就能很好地实现同样的功能：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;setup code&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;condition&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;break&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;loop body&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 之父 Guido van Rossum 也持反对意见，他的原话是：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;内容如下：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Please reject the PEP. More variations along these lines won’t make the
language more elegant or easier to learn. They’d just save a few hasty
folks some typing while making others who have to read/maintain their code wonder what it means.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;简单翻译一下，这种 do-while 语法并不会使 Python 更优雅好用，反而会产生阅读/维护代码的理解负担。&lt;/div&gt;
&lt;div&gt;就个人的感觉而言，我也不赞成引入 PEP-315 那种可选的 do-while 语法，虽然它比固定形式的 do-while 结构更为灵活和优雅一点。&lt;/div&gt;
&lt;div&gt;最后稍微总结一下，do-while 作为一种常见的循环结构，在其它语言中有所发挥，它甚至还发展出了 &lt;code&gt;do {...} while (0)&lt;/code&gt; 的典型用法，但是，do-while 能够解决的几个问题要么在 Python 中并不存在（宏定义、汇编指令），要么就是已经有更为合适而低成本的实现（跳转控制）。&lt;/div&gt;
&lt;div&gt;看完这篇文章，你是否还有其它补充的内容呢？欢迎交流讨论。&lt;/div&gt;
&lt;div&gt;如果你对 Python 语言设计相关的话题感兴趣，欢迎订阅 Github 上的《&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;Python为什么&lt;/a&gt;》系列文章&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>我的 2021 年文章小结，翻译竟比原创多！</title>
            <link>https://pythoncat.top/posts/2022-01-04-articles/</link>
            <guid>https://pythoncat.top/posts/2022-01-04-articles/</guid>
            <description>2021 年主要以翻译为主，而且有超长的几篇。公众号读者没有什么增长，这一年目标没有达成...</description>
            <pubDate>Tue, 04 Jan 2022 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;最近给自己放了两周的“长假”，刷视频、看小说、玩游戏，就是不写文章不更新公众号。&lt;/div&gt;
&lt;div&gt;半途而废的事情令得 2021 年的时间流逝加快，最后留下只是遗憾和不甘。&lt;/div&gt;
&lt;div&gt;又到了新的一年，按照惯例应该做一个年度小结了。&lt;/div&gt;
&lt;div&gt;但是，虽然我早早就把 2021 年的文章罗列了一遍，却迟迟难以续笔。&lt;/div&gt;
&lt;div&gt;如今已经过完了元旦，收拾好心情，还是得把开了头的篇章补完啊！&lt;/div&gt;
&lt;div&gt;去年的这个时候，公众号读者数刚破 2 万，我那时给自己定了个小目标是今年达到 3.5 万。&lt;/div&gt;
&lt;div&gt;然而，在过去一年里，我几乎没有为提升订阅数而多花心思，不参加互推，少数的几次赠书活动也基本只在读者群和朋友圈的小范围内进行。&lt;/div&gt;
&lt;div&gt;照着去年的增长趋势，我估计把去年目标放到今年里面也还算是有不小的挑战了。&lt;/div&gt;
&lt;div&gt;2021 年写作的文章少得可怜，这并不是因为我无话题可写，恰恰相反，我的写作计划/话题库本就丰富，在一年里又增加了不少。&lt;/div&gt;
&lt;div&gt;新的一年里，可能需要重拾一种&lt;strong&gt;无知无畏的笨鸟精神&lt;/strong&gt;了，去把那些任务完成掉。&lt;/div&gt;
&lt;div&gt;2021 年里翻译了 12 篇文章。好几篇有超级长的篇幅，过程很花费精力，耗费的时间常常需要两周以上。&lt;/div&gt;
&lt;div&gt;翻译了这么多篇，远超出自己原创的，这倒是超出了我的预期。&lt;/div&gt;
&lt;div&gt;不过，在这一年里，我确实是挺享受在公交车和地铁上做着翻译的事，在那种摇晃的、拥挤的环境下，我竟然能够保持着专注，琢磨着遣词造句，真是难得的体验和收获。&lt;/div&gt;
&lt;div&gt;新的一年里，继续写作与翻译，需要把数量增加上来，但求不像过去一年那样了，不要断层出很多的时间空白。&lt;/div&gt;
&lt;div&gt;闲聊了这么多有的没的，主要是想找找写作的状态，把娱乐事项驱逐出思维空间。&lt;/div&gt;
&lt;div&gt;那么，闲聊结束。&lt;/div&gt;
&lt;div&gt;主要罗列一下去年口碑最佳的几篇文章吧：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/DWVVoh2oj1GQ20WlTYo3cg&quot;&gt;Python 之父爆料：明年至少令 Python 提速 1 倍！&lt;/a&gt;   被转载 35 次，转载阅读 4.9 万+&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/eaxlo71sN4JRnBiPNBxKzQ&quot;&gt;醒醒！Python已经支持中文变量名啦！&lt;/a&gt;  被转载 29 次，转载阅读 3.5 万+&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/YGgW1Pb79RWzs9X_etx1Rw&quot;&gt;与 Python 之父聊天：更快的 Python！&lt;/a&gt;   被转载 13 次，转载阅读 1.9 万+&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/p1Zb_linFLWwPlNyA5Ui1Q&quot;&gt;Python优化机制：常量折叠&lt;/a&gt;    被转载 18 次，转载阅读 1 万+&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/p1YpduF0Nevl6toUx6Vuyg&quot;&gt;为什么 Python 没有函数重载？如何用装饰器实现函数重载？&lt;/a&gt;   被转载 15 次，转载阅读 7 千+&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;这些文章在 Python 猫里也有着不错的阅读和互动，就像过去盘点的文章一样，既是一种回顾，也是给我未来创作方向的参考。&lt;/div&gt;
&lt;div&gt;按照时间顺序，全年原创及翻译文章的清单：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/eaxlo71sN4JRnBiPNBxKzQ&quot;&gt;醒醒！Python已经支持中文变量名啦！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/p1Zb_linFLWwPlNyA5Ui1Q&quot;&gt;Python优化机制：常量折叠&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/EIuKOSBm7ym9_myWzA9xXw&quot;&gt;深入 Python 解释器源码，我终于搞明白了字符串驻留的原理！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/yocY-LW2SQi1PbuCmtUDng&quot;&gt;为什么 Python 的 f-string 可以连接字符串与数字？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/DWVVoh2oj1GQ20WlTYo3cg&quot;&gt;Python 之父爆料：明年至少令 Python 提速 1 倍！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/oDE3-pMj-AV7M6XMXKtSog&quot;&gt;坚持原创很难，但我不会放弃！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/p1YpduF0Nevl6toUx6Vuyg&quot;&gt;为什么 Python 没有函数重载？如何用装饰器实现函数重载？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/t-jXhteR4w2B3Yaj9VtiEA&quot;&gt;Python 的上下文管理器是怎样设计的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/JVZQjoQv6TdoVOoM4H9-sA&quot;&gt;Python 数值中的下划线是怎么回事？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/W4I4DVf4aGcYDcrjl-XkMA&quot;&gt;Python 列表解析式竟然支持异步？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/nc7wbzje-4KmP5ekD2AOtg&quot;&gt;联合迭代器与生成器，这个内置函数真香！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/YGgW1Pb79RWzs9X_etx1Rw&quot;&gt;与 Python 之父聊天：更快的 Python！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/SvUyyUGLZFbqEyERWWJIYQ&quot;&gt;Python 官方研讨会：彻底移除 GIL 真的可行么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/t3kAV_L7S01cz8pImYw9-A&quot;&gt;通过 for 循环，比较 Python 与 Ruby 编程思想的差别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/BBvhOCqKzNN7INx13yiUmQ&quot;&gt;博采 27 门语言之长，提升 Python 的能力&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/clDgVrZkHUYWkJcdQTgA1A&quot;&gt;Python 的切片为什么不会索引越界？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/m6RdXiU9KC9WRpC8AOP6ng&quot;&gt;Python 的元类设计起源自哪里？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;在这些文章里，我重点推荐一下《&lt;a href=&quot;https://mp.weixin.qq.com/s/BBvhOCqKzNN7INx13yiUmQ&quot;&gt;博采 27 门语言之长，提升 Python 的能力&lt;/a&gt;》。原文被我放在收藏夹里真的是太久了，早几年前，我还没有写技术博客和翻译技术文章的习惯，万万想不到有一天能把它翻译出来，甚至一度都把它给忘掉了。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;文章比较了 27 门主流编程语言的优秀特性，有助于我们开阔编程视野。&lt;/div&gt;
&lt;div&gt;另外，Python 社区在 2021 年里最重要的事情之二就是：Guido 加入的香农计划、以及 CPython 对于移除 GIL 的新探索，推荐阅读：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/DWVVoh2oj1GQ20WlTYo3cg&quot;&gt;Python 之父爆料：明年至少令 Python 提速 1 倍！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/YGgW1Pb79RWzs9X_etx1Rw&quot;&gt;与 Python 之父聊天：更快的 Python！ &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/SvUyyUGLZFbqEyERWWJIYQ&quot;&gt;Python 官方研讨会：彻底移除 GIL 真的可行么？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;最后，关联阅读往年小结：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/DgYP8TBg2kEWRx6A-cXjgA&quot;&gt;2020年Python文章盘点，我选出了个人TOP10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/GPMkOE1ZR9bbCjFWkhndDg&quot;&gt;我的 2019 年 Python 文章榜单&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 的元类设计起源自哪里？</title>
            <link>https://pythoncat.top/posts/2021-12-22-metaclass/</link>
            <guid>https://pythoncat.top/posts/2021-12-22-metaclass/</guid>
            <description>Python 的元类设计有着很大的原创性，并非借鉴自哪种语言的成熟设计</description>
            <pubDate>Wed, 22 Dec 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;一个元老级的 Python 核心开发者曾建议我们（ &lt;a href=&quot;https://mp.weixin.qq.com/s/BBvhOCqKzNN7INx13yiUmQ&quot;&gt;点击阅读&lt;/a&gt;），应该广泛学习其它编程语言的优秀特性，从而提升 Python 在相关领域的能力。在关于元编程方面，他的建议是学习 Hy 和 Ruby。但是，他也提到，他并不知道学习哪种语言，可以加深对 Python 元类设计的理解。&lt;/div&gt;
&lt;div&gt;这其实意味着，Python 的元类设计有着很大的原创性，并非借鉴自哪种语言的成熟设计！&lt;/div&gt;
&lt;div&gt;既然不是从其它语言中学习来的，那么，Python 的元类思想到底起源自哪里呢？Guido 不会是“无中生有”开创出来的设计吧？&lt;/div&gt;
&lt;div&gt;下面的一篇译文，作者是 Guido van Rossum（Python 之父），原文写于 2013 年 10 月，正是要回答 Python 元类的起源问题：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://python-history.blogspot.com/2013/10/origin-of-metaclasses-in-python.html&quot;&gt;Origin of metaclasses in python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：豌豆花下猫@Python猫&lt;/p&gt;
&lt;p&gt;声明：本翻译是出于交流学习的目的，基于 CC BY-NC-SA 4.0 授权协议。为便于阅读，内容略有改动，所有图片皆为译者所加。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;python-ideas 上有人猜测 Python 的元类设计是起源自 Ruby。事实并非如此。既然是关于语言特性的起源，我觉得我有必要来澄清下事实。&lt;/div&gt;
&lt;div&gt;关于元类，我并没有受过 Ruby 的启发（今后也不会）。事实上，Ruby 受到过 Python 的启发。Mats 曾经告诉我，他的灵感有 20% 来自 Python，有 80% 来自 Perl，而且 Larry Wall 是他心目中的英雄。&lt;/div&gt;
&lt;div&gt;（译注：Larry Wall  是 Perl 语言之父。他曾在 2014 年访华，《程序员》杂志做过一期专访，&lt;a href=&quot;https://mp.weixin.qq.com/s/Y0phOijYNu3ONZE_0ekvpA&quot;&gt;推荐一读&lt;/a&gt; 。）&lt;/div&gt;
&lt;div&gt;我在 1998 年写过&lt;a href=&quot;http://www.python.org/doc/essays/metaclasses/&quot;&gt;关于 Python 元类的文章&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;（作者注：那篇 1998 年的文章里包含了一个功能完整的 Enum 实现，它有许多与 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0435/&quot;&gt;PEP-435&lt;/a&gt; 相同的特性。）&lt;/div&gt;
&lt;div&gt;新式类只是这个想法的第二或第三次迭代物。&lt;/div&gt;
&lt;div&gt;我实现新式类的灵感来自于一本书，即 Ira Forman 和 Scott Danforth 写的《Putting Metaclasses to Work》。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;但即便是在 Python 最初的设计中（1990 年，发布于 1991 年），类型（type）本身就是一个对象。任何对象中的类型指针总是指向一个特殊对象，该对象的“数据”是一堆实现其它对象行为的 C 函数指针，类似于 C++ 的虚函数表。&lt;/div&gt;
&lt;div&gt;一个类型的类型始终是一个特殊的类型对象（The type of a type was always a special type object），你可以将其称为元类型（meta-type），因为它是自己的类型。&lt;/div&gt;
&lt;div&gt;当时我对 Smalltalk 只有模糊的了解；当我后来读到它的元类设计时，我感到很惊讶，因为它与 Python 或 Ruby 中的元类有很大的不同！&lt;/div&gt;
&lt;div&gt;但是，Smalltalk 的字节码对 Python 的字节码影响很大。我在 Adele Goldberg 和其他人的一本书中读到过，好像是《Smalltalk-80: The Language and its Implementation》。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;（译文完）&lt;/div&gt;
&lt;div&gt;以上文章出自 Guido 的《The History of Python》系列，该系列主要是关于 Python 语言及社区的发展历史。我曾翻译过该系列的最新一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/ovIiw7ZmXJM4qUSTGDk7kQ&quot;&gt;pgen 解析器的起源&lt;/a&gt;》，曾打算把其它文章也陆续翻译出来……（只是曾）……&lt;/div&gt;
&lt;div&gt;巧合的是，就在本文刚译完而查资料时，我无意中发现有人在 2019 年上半年已经把该系列翻译出来了（他翻译了 25 篇，正好不含我所译的最新一篇）！这些译文，我竟然一直从未阅读过！&lt;/div&gt;
&lt;div&gt;该译者也有公众号，我好奇翻看了一些文章，发现不少的阅读量只有 10 几个！看来那位译者是没有怎么花心思运营啊，纯粹是当做了一种学习兴趣，默默做事，不求掌声。&lt;/div&gt;
&lt;div&gt;所以，如果你对 Python 历史相关内容感兴趣的话，我诚心推荐你关注“&lt;strong&gt;ReadingPython&lt;/strong&gt;”，查看其历史文章。（另外，该译者正在译《Python behind the scenes》系列，这也是我的翻译计划之一，而且实际已经把一篇 1.4 万字的译了一半后就搁置了好几个月……）&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 的切片为什么不会索引越界？</title>
            <link>https://pythoncat.top/posts/2021-12-20-slice/</link>
            <guid>https://pythoncat.top/posts/2021-12-20-slice/</guid>
            <pubDate>Mon, 20 Dec 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;切片（slice）是 Python 中一种很有特色的特性，在正式开始之前，我们先来复习一下关于切片的知识吧。&lt;/div&gt;
&lt;div&gt;切片主要用于序列对象中，按照索引区间截取出一段索引的内容。&lt;/div&gt;
&lt;div&gt;切片的书写形式：[i : i+n : m] ；其中，i 是切片的起始索引值，为列表首位时可省略；i+n 是切片的结束位置，为列表末位时可省略；m 可以不提供，默认值是 1，不允许为 0，当 m 为负数时，列表翻转。&lt;/div&gt;
&lt;div&gt;切片的基本含义是：&lt;strong&gt;从序列的第 i 位索引起，向右取到后 n 位元素为止，按 m 间隔过滤&lt;/strong&gt; 。&lt;/div&gt;
&lt;div&gt;下面是一些很有代表性的例子，基本涵盖了切片语法的使用要点：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# @Python猫&lt;/span&gt;
li &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;# 以下写法都可以表示整个列表，其中 X &amp;gt;= len(li)&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;X&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;X&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;X&lt;span&gt;:&lt;/span&gt;X&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;X&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 从1起，取5-1位元素&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 从1起，取5-1位元素，按2间隔过滤&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 取倒数第一个元素&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 从倒数第四起，取-2-(-4)=2位元素&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;li&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 从头开始，取-2-(-len(li))=7位元素&lt;/span&gt;

&lt;span&gt;# 步长为负数时，列表先翻转，再截取&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 翻转整个列表&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 翻转整个列表，再按2间隔过滤&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 翻转整个列表，取-5-(-len(li))=4位元素&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 翻转整个列表，取-5-(-len(li))=4位元素，再按3间隔过滤&lt;/span&gt;

&lt;span&gt;# 切片的步长不可以为0&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;  &lt;span&gt;# 报错（ValueError: slice step cannot be zero）&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;像 C/C++、Java 和 JavaScript 等语言，虽然也支持某些“切片”功能，例如截取数组或字符串的片段，但是，它们并没有一种在语法层面上的通用性支持。&lt;/div&gt;
&lt;div&gt;根据维基百科资料，Fortran 是最早支持切片语法的语言（1966），而 Python 则是最具代表性的语言之一。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;另外，像 Perl、Ruby、Go 和 Rust 等语言，虽然也有切片，但都不及 Python 那样灵活和自由（因为它支持 step、负数索引、缺省索引）。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;切片的基本用法就能够满足大部分的需求，但是，Python 切片还有一些进阶的用法，例如：切片占位符用法（可实现列表的赋值、删除与拼接操作）、自定义对象实现切片功能、迭代器切片（itertools.islice()）、文件对象切片等等。关联阅读：&lt;a href=&quot;https://mp.weixin.qq.com/s/IRAjR-KHZBPEEkdiofseGQ&quot;&gt;Python进阶：全面解读高级特性之切片！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;关于切片的介绍与温习，就到这里了。&lt;/div&gt;
&lt;div&gt;下面进入文章标题的问题：&lt;strong&gt;Python 的切片语法为什么不会出现索引越界呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;当我们根据单个索引进行取值时，如果索引越界，就会得到报错：“IndexError: list index out of range”。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; li &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  File &lt;span&gt;&quot;&amp;lt;stdin&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; line &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;module&lt;span&gt;&amp;gt;&lt;/span&gt;
IndexError&lt;span&gt;:&lt;/span&gt; &lt;span&gt;list&lt;/span&gt; index out of &lt;span&gt;range&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;对于一个非空的序列对象，假设其长度为 length，则它有效的索引值是从 0 到（length - 1）。如果把负数索引也考虑进去，则单个索引值的有效区间是 [-length, length - 1] 闭区间。&lt;/div&gt;
&lt;div&gt;但是，当 Python 切片中的索引超出这个范围时，程序并不会报错。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; li &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;  &lt;span&gt;# 右索引超出&lt;/span&gt;
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;  &lt;span&gt;# 左右索引都超出&lt;/span&gt;
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;其实，对于这种现象，官方文档中有所介绍：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;The slice of &lt;em&gt;s&lt;/em&gt; from &lt;em&gt;i&lt;/em&gt; to &lt;em&gt;j&lt;/em&gt; is defined as the sequence of items with index &lt;em&gt;k&lt;/em&gt; such that &lt;code&gt;i &amp;lt;= k &amp;lt; j&lt;/code&gt;. If &lt;em&gt;i&lt;/em&gt; or &lt;em&gt;j&lt;/em&gt; is greater than &lt;code&gt;len(s)&lt;/code&gt;, use &lt;code&gt;len(s)&lt;/code&gt;. If &lt;em&gt;i&lt;/em&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, use &lt;code&gt;0&lt;/code&gt;. If &lt;em&gt;j&lt;/em&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, use &lt;code&gt;len(s)&lt;/code&gt;. If &lt;em&gt;i&lt;/em&gt; is greater than or equal to &lt;em&gt;j&lt;/em&gt;, the slice is empty.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;也就是说：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;当左或右索引值大于序列的长度值时，就用长度值作为该索引值；&lt;/li&gt;
&lt;li&gt;当左索引值缺省或者为 None 时，就用 0 作为左索引值；&lt;/li&gt;
&lt;li&gt;当右索引值缺省或者为 None 时，就用序列长度值作为右索引值；&lt;/li&gt;
&lt;li&gt;当左索引值大于等于右索引值时，切片结果为空对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;对照上面的例子，可以得到：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; li &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;  &lt;span&gt;# 等价于 li[1:2]&lt;/span&gt;
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;  &lt;span&gt;# 等价于 li[2:2]&lt;/span&gt;
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;归结起来一句话：Python 解释器把可能导致索引越界的操作给屏蔽了，你的写法可以很自由，但是最终的结果会被死死限制在合法的索引区间内。&lt;/div&gt;
&lt;div&gt;对于这个现象，我其实是有点疑惑的，为什么 Python 不直接报索引越界呢，为什么要修正切片的边界值，为什么一定要返回一个值呢，即便这个值可能是个空序列？&lt;/div&gt;
&lt;div&gt;当我们使用“li[5:6]”时，至少在字面意义上想表达的是“取出索引从 5 到 6 所对应的值”，就像是在说“取出书架上从左往右数的第 6 和 7 本书”。&lt;/div&gt;
&lt;div&gt;如果程序是如实地遵照我们的指令的话，它就应该报错，就应该说：对不起，书架上的书不够数。&lt;/div&gt;
&lt;div&gt;实话说，我并没有查到这方面的解释，这篇文章也不是要给大家科普 Python  在设计上有什么独到的见解。恰恰相反，这篇文章的主要目的之一是希望得到大家的回复解答。&lt;/div&gt;
&lt;div&gt;在 Go 语言中，遇到同样的场景时，它的做法是报错“runtime error: slice bounds out of range”。&lt;/div&gt;
&lt;div&gt;在 Rust 语言中，遇到同样的场景时，它的做法是报错“byte index 5 is out of bounds of …”。&lt;/div&gt;
&lt;div&gt;在其它支持切片语法的语言中，也许还有跟 Python 一样的设计。但是，我还不知道有没有（学识浅薄）……&lt;/div&gt;
&lt;div&gt;最后，继续回到标题中的问题“Python 的切片为什么不会索引越界”。我其实想问的问题有两个：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;当切片语法中的索引超出边界时，为什么 Python 还能返回结果，返回结果的计算原理是什么？&lt;/li&gt;
&lt;li&gt;为什么 Python 的切片语法要允许索引超出边界呢，为什么不设计成抛出索引错误？&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;对于第一个问题的回答，官方文档已经写得很明白了。&lt;/div&gt;
&lt;div&gt;对于第二个问题，本文暂时没有答案。&lt;/div&gt;
&lt;div&gt;也许我很快就能找到答案，但是，也可能需要很久。不管如何，本文先到此为止了。&lt;/div&gt;
&lt;div&gt;如果你喜欢研究 Python 设计上的小细节，感兴趣探求“为什么”问题的解答，欢迎关注“Python为什么”系列文章。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>博采 27 门语言之长，提升 Python 的能力</title>
            <link>https://pythoncat.top/posts/2021-12-13-languages/</link>
            <guid>https://pythoncat.top/posts/2021-12-13-languages/</guid>
            <pubDate>Mon, 13 Dec 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 语言诞生 30 年了，如今的发展势头可谓如火如荼，这很大程度上得益于其易学易用的优秀设计，而不可否认的是，Python 从其它语言中偷师了不少。本文作者是一名资深的核心开发者，他广博的视野和精准的认识，让我对 Python 的设计了解得更为全面，同时，他“利用自豪感而非恐惧感”的说法，传达出来的是“专注于自我的进步，不嫉妒他人的成功”的原则，对我也很有帮助。原文写于 2015 年，躺在我的收藏夹里很久很久了，如今顺利翻译掉，这是一件能提升自豪感的有意义的事。最后祝大家开卷有益，读有所获。&lt;/div&gt;
&lt;div&gt;作者：Nick Coghlan&lt;/div&gt;
&lt;div&gt;译者：豌豆花下猫@Python猫&lt;/div&gt;
&lt;div&gt;英文：&lt;a href=&quot;https://www.curiousefficiency.org/posts/2015/10/languages-to-improve-your-python.html&quot;&gt;27 languages to improve your Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;声明：本翻译是出于交流学习的目的，基于 CC BY-NC-SA 4.0 授权协议。为便于阅读，内容略有改动。&lt;/div&gt;
&lt;h2&gt;目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;拓宽我们的视野&lt;/li&gt;
&lt;li&gt;过程式编程：C、Rust、Cython&lt;/li&gt;
&lt;li&gt;面向对象的数据模型：Java、C#、Eiffel&lt;/li&gt;
&lt;li&gt;面向对象的 C 派生：C++、D&lt;/li&gt;
&lt;li&gt;面向数组的数据处理：MATLAB/Octave、Julia&lt;/li&gt;
&lt;li&gt;统计数据分析：R&lt;/li&gt;
&lt;li&gt;计算管道建模：Haskell、Scala、Clojure、F#&lt;/li&gt;
&lt;li&gt;事件驱动编程：JavaScript、Go、Erlang、Elixir&lt;/li&gt;
&lt;li&gt;渐变类型：TypeScript&lt;/li&gt;
&lt;li&gt;动态元编程：Hy、Ruby&lt;/li&gt;
&lt;li&gt;务实问题解决：Lua、PHP、Perl&lt;/li&gt;
&lt;li&gt;编程思维：Scratch、Logo&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;作为世界上最流行的编程语言之一的共同设计者，我经常看到一个令人沮丧的行为（在 Python 社区和其它社区）：有影响力者试图激发人们对“败给”其它开源社区的恐惧，从而调动人们对社区作贡献的积极性。（我自己偶尔也会犯这种错误，这让我更容易发现其他人是否也落入了同样的陷阱）。&lt;/div&gt;
&lt;div&gt;虽然学习其它编程语言社区的经验是件好事，但基于恐惧的方法来激励行动是有严重问题的，因为这会刺激本社区成员将其它社区的人视为争夺开源贡献者关注的敌人，而不是作为在更大挑战中的潜在盟友（推动软件开发艺术发展）。这还会告诉那些喜欢其它语言的人，在一个把他们以及他们的同伴视为“敌对竞争对手”的社区里，他们是不受欢迎的。&lt;/div&gt;
&lt;div&gt;事实上，我们希望有多种多样的跨平台的开源编程语言供选择，因为编程语言是思考的首要工具——使我们能够以明确的方式表达我们的想法，从而让计算机也能够理解。如果有人找到了一种适合大脑的语言，能够解决眼前的问题，那就太好了，不管他们选择的是哪种（些）语言。&lt;/div&gt;
&lt;div&gt;因此，我对 Python 社区有三个具体的请求，以及一个较为宽泛的建议。首先，我的请求是：&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;如果我们要利用社区的本能来激励行动，就应该避免利用恐惧感，而应该利用自豪感。&lt;/strong&gt; 当我们将恐惧作为激励因素时，就像在说“如果我们不做 X，就会失去开发者对 Python 的关注”，这等于是故意地在自由的开源贡献者中创造悲观的情绪。然而，依赖社区的自豪感就像在说“目前尚不清楚如何在 Python 中解决 X 问题。如果我们看看 Y 语言，就可以看到他们有一个非常好的方法来解决问题 X，我们可以吸收进 Python，以提供类似的舒适的用户体验。”积极的态度让我们对自己的努力感到自豪，而不是贬低他人的努力，这有助于在 Python 社区内促成一种持续学习的文化，并促进与其它社区改善协作关系，共同发展。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;克制对其它开源编程语言社区采取轻蔑的态度，尤其当这些社区授权人们解决自己的问题，而不是等待商业软件供应商来解决问题。&lt;/strong&gt; 世界上大多数重要的问题解决起来都是无利可图的（因为受苦于这些问题的人并不富裕，而且无法左右机构基金的决定），所以我们应该鼓励试图解决这些问题的人，不管我们如何看待他们的技术选择。&lt;/li&gt;
&lt;li&gt;**如果我们认识的人刚开始学习编程，并且他们选了一种我们不喜欢的语言，我们应该支持他们的选择。 **他们比我们更知道什么适合自己，适合我们的语言不一定适合他们。如果他们对自己最初的选择感到了沮丧，甚至已经对学习编程变得没有动力，此时再给他们推荐别的编程语言。这个建议还适用于那些在改善糟糕的网络安全状况的人：我们在面对天生不安全的语言时，采取的方法是改进操作系统的沙箱功能，逐步学习有更好的本地安全属性的语言，并改善现有语言的默认行为，而不是列举为什么从程序安全性的角度来看，他们选择的语言是一个糟糕的选择，来迷惑初学者。（如果有人部署了由初学者编写的未经审核的软件来处理安全敏感的任务，那就不是开发者的问题，而且部署者的问题，他们没有对软件的出处和安全属性进行适当的尽职调查。）&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;我的宽泛的建议针对那些遇到了 Python 核心程序的限制，并因此希望探索 Python 中可用的“思考工具”的人。这个建议就是：&lt;/div&gt;
&lt;h2&gt;拓宽我们的视野&lt;/h2&gt;
&lt;div&gt;在开发 Python 核心程序的过程中，我们会做的一件事是查看其它语言中解决了我们正面临的问题的特性，看看是否有办法既吸收它们，又使 Python 代码更易于阅读和编写。这意味着学习其它专注于特定软件开发风格的编程语言，可以帮助我们在使用 Python 时，提高对这种编程风格的理解。&lt;/div&gt;
&lt;div&gt;为了提供帮助，我在下面列出了一些值得探索的领域，以及可能加深对这些领域的理解的语言。我尽可能链接了维基百科的页面，而不是直接链接到语言的主页，因为维基百科经常会提供有趣的历史背景，当你为了教育目的学习一门新的编程语言，而不是直接用于实际应用时，这些背景值得去了解。&lt;/div&gt;
&lt;div&gt;虽然我知道这些语言中的大部分（并且在开发生产系统时使用过几种），但这份推荐清单中还包括我间接知道的语言（通常是通过阅读教程和设计文档，或者通过与我信任的人交谈，以获取对一门语言的优点与缺陷的洞察）。&lt;/div&gt;
&lt;div&gt;还有很多本应该放但没有放进名单里的语言&lt;a href=&quot;https://github.com/mame/quine-relay&quot;&gt;语言&lt;/a&gt;，所以下面罗列的仅是我感兴趣的部分（例如，我主要感兴趣的是 Linux、Android 和 Windows 的生态系统，所以我舍弃了 Apple 生态中的 Objective-C 和 Swift 语言，另外我也不熟悉 &lt;a href=&quot;https://en.wikipedia.org/wiki/Processing_%28programming_language%29&quot;&gt;Processing&lt;/a&gt; 这种专注于艺术的编程语言，无法想象学习它们能教给 Python 开发者什么）。&lt;/div&gt;
&lt;div&gt;除了考虑一门语言可能教给你的东西，如果你想获得一份更全面的清单，可以去查看 IEEE Spectrum 关于编程语言流行度和增长度的&lt;a href=&quot;http://spectrum.ieee.org/static/interactive-the-top-programming-languages-2015&quot;&gt;年度榜单&lt;/a&gt;。&lt;/div&gt;
&lt;h2&gt;过程式编程：C、Rust、Cython&lt;/h2&gt;
&lt;div&gt;Python 默认的执行模型是过程式的：从主模块的顶部开始，逐条语句地执行。Python 对下面介绍的所有数据和编程建模方法的支持，都建立在这种过程式的执行模型上。&lt;/div&gt;
&lt;div&gt;C 语言仍然是无可争议的底层过程式编程的统治者。它是 Python 官方解释器以及 Linux 操作系统内核的核心实现语言。作为一名软件开发人员，学习 C 语言是更多地了解底层硬件的最好方法之一——C 语言经常被称为“可移植的汇编语言”，对于任何新的 CPU 架构来说，第一个交叉编译的应用程序将是 C 编译器。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Rust_%28programming_language%29&quot;&gt;Rust&lt;/a&gt; 是一种相对较新的编程语言，由 Mozilla 创造。Rust 的目标是吸取整个行业在不使用 C 时遇到的所有教训，设计一门能与 C 库相互操作的新语言，提供底层的系统编程所需的对硬件用途的精确控制，但使用不同的编译方法来进行数据建模和内存管理，从结构上消除许多困扰 C 程序的常见缺陷（如缓冲区溢出、指针重复释放错误、空指针访问和线程同步问题）。经过培训和早期的专业经验，我是一名嵌入式系统工程师，而 Rust 是我见过的第一种看起来有潜力缩减当前由 C 语言和自定义汇编代码所主导的生态位的新语言。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cython&quot;&gt;Cython&lt;/a&gt; 也是一种较底层的过程式语言，但与 C 和 Rust 等通用语言不同，Cython 专门用于编写 CPython 的扩展模块。为了实现这一目标，Cython 被设计为 Python 的超集，允许程序员选择何时支持纯 Python 语法以获得灵活性，何时支持 Cython 的语法扩展，以便生成在速度和内存效率方面能与原生 C 代码相当的代码。&lt;/div&gt;
&lt;div&gt;学习这些语言，你可以加深在内存管理、算法效率、二进制接口（ABI）兼容性、软件可移植性、以及将源代码转换为运行系统等实践方面的见解。&lt;/div&gt;
&lt;h2&gt;面向对象的数据模型：Java、C#、Eiffel&lt;/h2&gt;
&lt;div&gt;编程最主要做的事情之一是为现实世界建模，最流行的做法是提供原生的语法支持面向对象编程：对数据作结构化的分组，使用类方法操作那些数据结构。&lt;/div&gt;
&lt;div&gt;Python 本身是经过精心设计的，无需先编写自己的类就可以使用面向对象的特性。并不是每种语言都采用这种方法——本小节中列出的语言都认为学习面向对象设计是使用该语言的必要条件。&lt;/div&gt;
&lt;div&gt;在 20 世纪 90 年代中后期，Sun Microsystems 公司进行了一次大规模的市场推广，&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; 成为了许多高等院校中计算机科学入门课的默认语言。虽然如今在许多教学活动中，Java 已经被 Python 所取代，但它仍然是开发商用程序时最流行的语言之一。还有一些基于通用 JVM（Java 虚拟机）运行时的语言，例如 Python 的 Jython 实现。Android 系统的 Dalvik 和 ART 环境则是基于 Java 开放的 API 二次开发。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29&quot;&gt;C#&lt;/a&gt; 在许多方面与 Java 相似，在 Sun 和微软未能解决他们关于微软的 Java 实现（即 J++）的业务差异之后，C# 成为了一种替代方案。像 Java 一样，这是一门开发商用程序的流行语言，还有其它一些语言共享着 .NET CLR（公共语言运行时），包括 Python 的 IronPython 实现 （最早的 IronPython 1.0 的核心组件被提取成了与语言无关的 .NET 动态语言运行库）。在很长一段时间里，. NET 是一种专用于 Windows 的技术，而 &lt;a href=&quot;https://en.wikipedia.org/wiki/Mono_%28software%29&quot;&gt;mono&lt;/a&gt; 作为一种跨平台的开源实现，但微软在 2015 年初转向了&lt;a href=&quot;http://radar.oreilly.com/2015/06/net-open-source.html&quot;&gt;开源生态系统战略&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;与此清单中的大多数语言不同，我不推荐在日常工作中使用 &lt;a href=&quot;https://en.wikipedia.org/wiki/Eiffel_%28programming_language%29&quot;&gt;Eiffel&lt;/a&gt;。但是，我依然推荐学习它，因为它教会了我许多关于良好的面向对象设计的知识，比如它认为“可验证的正确性”是应用程序的设计目标。（学习 Eiffel 也让我明白了为什么“可验证的正确性”并不是大多数软件开发时的设计目标，因为可验证的正确软件实在不能很好地处理模糊性，并且完全不适用于那些你不清晰相关的约束条件却需要给自己留下足够的回旋余地，以便能够通过迭代开发找出更具体的细节的情况。）&lt;/div&gt;
&lt;div&gt;学习这些语言，你可以深入了解继承模型、契约式设计、类不变性（class invariant）、前置条件、后置条件、协方差、逆变、类方法解析顺序、泛型编程以及其它适用于 Python 类型系统的概念。还有很多标准库模块和第三方框架使用这种“看得见的面向对象”的设计风格，比如 unittest 和 logging 模块，以及 Django 框架中基于类的视图。&lt;/div&gt;
&lt;h2&gt;面向对象的 C 派生：C++、D&lt;/h2&gt;
&lt;div&gt;CPython 运行环境可以被视为一个“带有对象的 C”的编程环境——在其核心，CPython 使用 C 的方法实现面向对象编程，即定义 C 结构体来保存相关的数据，并将结构体的实例作为第一个参数传递给函数，然后对数据进行操作（这就是 CPython C API 中全能的 PyObject * 指针）。这种设计模式对应到 Python 层面，就是实例方法的显式 self 参数以及类方法的显式 cls 参数。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/C%2B%2B&quot;&gt;C++&lt;/a&gt; 的目标是保持与 C 语言源代码的完全兼容，同时添加更高级的特性，例如支持原生的面向对象编程和基于模板的元编程。它是出了名的冗长和难以编程（尽管 2011 年对语言标准的更新解决了许多糟糕的问题），但它也是许多领域的编程首选，包括 3D 建模的图形化引擎和跨平台应用的开发框架（例如 Qt）。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/D_%28programming_language%29&quot;&gt;D&lt;/a&gt; 语言也很有趣，因为它与 C++ 的关系类似于 Rust 与 C 的关系：它的目标是保留 C++ 的大多数令人满意的特性，同时也避免它的许多问题（如缺乏内存安全）。不像 Rust，D 不是一种从头开始设计的新编程语言——恰恰相反，D 是 C++ 的衍生物，虽然它不像 C++ 一样是一个严格的 C 超集，但它遵循着一个设计原则，即任何落入 C 和 D 的共同子集的代码，在两种语言中必须要表现一致。&lt;/div&gt;
&lt;div&gt;学习这些语言，你可以更深入地了解将高级语言的特性与底层 C 运行时模型相结合的复杂性。学习 C++，在 Python 中操作用 C++ 编写的库和工具包时，也可能会有帮助。&lt;/div&gt;
&lt;h2&gt;面向数组的数据处理：MATLAB/Octave、Julia&lt;/h2&gt;
&lt;div&gt;面向数组的编程是为了支持数值编程模型：那些基于矩阵代数和相关数值方法的模型。&lt;/div&gt;
&lt;div&gt;虽然 Python 的标准库不直接支持这一点，但 Python 在设计时考虑了面向数组的编程，并专门为第三方 &lt;a href=&quot;https://en.wikipedia.org/wiki/NumPy&quot;&gt;NumPy&lt;/a&gt; 库和类似的面向数组的工具添加了一系列语法和语义特性。&lt;/div&gt;
&lt;div&gt;在许多方面，Python 的&lt;a href=&quot;https://en.wikipedia.org/wiki/SciPy&quot;&gt;科学技术栈&lt;/a&gt; 被作为商业 &lt;a href=&quot;https://en.wikipedia.org/wiki/MATLAB&quot;&gt;MATLAB&lt;/a&gt; 的替代方案，后者被广泛用于科学和工程领域的建模、仿真和数据分析。&lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_Octave&quot;&gt;GNU Octave&lt;/a&gt; 是一个开源的方案，目标是兼容 MATLAB 代码的语法，允许人们对照这两种面向数组的编程方法。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Julia_%28programming_language%29&quot;&gt;Julia&lt;/a&gt; 是另一种相对较新的语言，重点关注面向数组的编程和基于类型的函数重载。&lt;/div&gt;
&lt;div&gt;学习这些语言，你可以了解 Python 的科学技术栈，以及有机会通过像 OpenCL 和 Nvidia 的 CUDA 这种技术来探索硬件层面的并行执行，并通过 &lt;a href=&quot;https://spark.apache.org/&quot;&gt;Apache Spark&lt;/a&gt; 和专用于 Python 的 &lt;a href=&quot;https://blaze.pydata.org/&quot;&gt;Blaze&lt;/a&gt; 来了解分布式数据处理。&lt;/div&gt;
&lt;h2&gt;统计数据分析：R&lt;/h2&gt;
&lt;div&gt;随着对大型数据集的接触越来越多，对灵活处理这些数据集的分析工具的需求也越来越大。R 编程语言就是这样的工具，它特别关注统计性的数据分析和可视化。&lt;/div&gt;
&lt;div&gt;学习 R 能会让你深入了解 Python 在科学技术栈的统计分析能力，尤其是 &lt;a href=&quot;https://en.wikipedia.org/wiki/Pandas_%28software%29&quot;&gt;pandas&lt;/a&gt; 数据处理库和 &lt;a href=&quot;http://stanford.edu/~mwaskom/software/seaborn/&quot;&gt;seaborn&lt;/a&gt; 统计可视化库。&lt;/div&gt;
&lt;h2&gt;计算管道建模：Haskell、Scala、Clojure、F#&lt;/h2&gt;
&lt;div&gt;面向对象的数据建模和面向数组的数据处理主要关注静态的数据，无论是以命名的属性形成集合的形式，还是以结构化数据形成数组的形式。&lt;/div&gt;
&lt;div&gt;相比之下，函数式编程语言强调以计算流的形式对动态数据进行建模。即便只学习函数式编程的基本知识，也能极大地改进数据转换操作的结构，即使在其它过程式、面向对象或面向数组的程序中也是如此。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Haskell_%28programming_language%29&quot;&gt;Haskell&lt;/a&gt; 是一种函数式编程语言，对 Python 的设计产生了重大影响，最显著的是在 Python 2.0 中引入的列表推导式。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Scala_%28programming_language%29&quot;&gt;Scala&lt;/a&gt; 是一种（存疑的）JVM 函数式编程语言，加上 Java、Python 和 R，它们是 Apache Spark 数据分析平台的四种主要编程语言。尽管 Scala 的设计偏重于函数式编程，但它的语法、数据模型和执行模型的设计也最大限度地降低 Java 程序员使用的门槛（因此所谓“存疑的”——其实是因为，Scala 最好被归类为一门具有强函数式编程支持的面向对象编程语言）。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Clojure&quot;&gt;Clojure&lt;/a&gt; 是另一种基于 JVM 的函数式编程语言，是 &lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_%28programming_language%29&quot;&gt;Lisp&lt;/a&gt; 的一种方言。它之所以出现在这份清单里，因为它是 Python 的 toolz 函数式编程工具包的灵感来源。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/F_Sharp_%28programming_language%29&quot;&gt;F#&lt;/a&gt; 不是我自己特别熟悉的语言，但它作为 .net CLR（公共语言运行时）推荐的函数式编程语言，所以还是值得关注。&lt;/div&gt;
&lt;div&gt;学习这些语言，你可以深入了解 Python 自己的计算管道建模工具，包括容器推导式、&lt;a href=&quot;https://mp.weixin.qq.com/s/vjQLlmH5QV-zAre7tVCxSA&quot;&gt;生成器&lt;/a&gt;、生成器表达式、functools 和 itertools 标准库，以及第三方的 Python 函数工具包，比如 toolz。&lt;/div&gt;
&lt;h2&gt;事件驱动编程：JavaScript、Go、Erlang、Elixir&lt;/h2&gt;
&lt;div&gt;计算管道是处理数据转换和分析问题的一种极佳的方法，但许多问题需要程序作为持久性服务运行，等待事件发生，然后处理那些事件。在这类服务中，为了能够同时容纳多个用户（或多个操作），通常必须要并发地处理多个事件。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt; 最初是作为 Web 浏览器的事件处理语言而开发的，允许网站开发者在本地响应客户端操作（如鼠标点击和按键敲击）和事件（如网页完成了渲染）。所有现代浏览器都支持它，它与 HTML5 领域对象模型（DOM）一起，已经成为一种定义用户界面外观和行为的事实上的标准。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Go_%28programming_language%29&quot;&gt;Go&lt;/a&gt; 是谷歌设计的一种用于创建高度可伸缩的 Web 服务的专用语言，并且已经被证明是一种非常适合开发命令行应用程序的语言。从编程语言设计的角度来看，Go 最有趣的方面是在其核心并发模型中使用了通信顺序进程（&lt;a href=&quot;https://en.wikipedia.org/wiki/Communicating_sequential_processes&quot;&gt;Communicating Sequential Processes&lt;/a&gt;）概念。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Erlang_%28programming_language%29&quot;&gt;Erlang&lt;/a&gt; 是由爱立信设计的专用语言，用于创建高度可靠的电话交换机以及类似的设备。它被用于开发出了流行的 RabbitMQ 消息代理中间件。Erlang 使用 Actor 模型作为核心的并发原语，在执行线程之间传递消息，而不是让它们直接共享数据。虽然我从未用过 Erlang 编程，但我的第一份全职工作涉及一个基于 Actor 的 C++ 并发框架，而该框架由一名前爱立信工程师开发，另外，我自己也开发了一个这样的框架，基于德州仪器（Texas Instrument）的轻量级 DSP/BIOS 运行时（现在的 TI-RTOS）里面的 TSK （Task）和 MBX （Mailbox）原语。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Elixir_%28programming_language%29&quot;&gt;Elixir&lt;/a&gt; 出现在这份清单里，因为它被设计运行在 Erlang VM 上，提供了与 Erlang 相同的并发语义，同时还提供了一系列在语言层面上的特性，打造出一个更加全面的环境，更有可能吸引其它语言例如 Python、Java 或 Ruby 的开发者。&lt;/div&gt;
&lt;div&gt;学习这些语言，你可以深入了解 Python 对并发和并行的支持，包括&lt;a href=&quot;https://mp.weixin.qq.com/s/M79svUpskZQz15SxEfIWbQ&quot;&gt;原生协程&lt;/a&gt;、基于生成器的协程、concurrent.futures 和 asyncio 标准库模块、第三方网络服务开发框架（如 twisted 和 Tornado）、Django 中引入的 channel 概念、GUI 框架中的事件处理循环。&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUyOTk2MTcwNg==&amp;amp;action=getalbum&amp;amp;album_id=1413329638813827073#wechat_redirect&quot;&gt;Python进阶&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;渐变类型：TypeScript&lt;/h2&gt;
&lt;div&gt;在 Python 3.5 中出现的一个比较有争议的特性是新引入的 typing 模块，它为 Python 生态带来了一个支持渐变类型的标准词典。&lt;/div&gt;
&lt;div&gt;Python猫注：Gradual typing 是 Jeremy Siek 和 Walid Taha 在 2006 年提出的理论，允许程序中同时出现动态类型与静态类型。国内有人将其翻译为“渐进类型”、“渐近类型”、“渐进定型”、“动静混合类型”等等，但我觉得并不够好。&lt;strong&gt;渐变类型&lt;/strong&gt;也许是我的首创，借鉴自 Photoshop 的渐变颜色，表达出从动态类型到静态类型的过渡（或者说交融共处的）特点。“渐变”一词有打破界限分明的状态（如大小、远近、明暗），从而达到中和状态的含义。&lt;/div&gt;
&lt;div&gt;对于那些主要从 C、C++ 和 Java 等语言中接触静态类型的人来说，这似乎是一个令人吃惊的糟糕特性（因此引发了争议）。&lt;/div&gt;
&lt;div&gt;微软的 &lt;a href=&quot;https://en.wikipedia.org/wiki/TypeScript&quot;&gt;TypeScript&lt;/a&gt; 为 Javascript 程序提供了渐变类型，因此它能更好地解释这个概念。TypeScript 代码会被编译成 JavaScript 代码（然后就不包含运行时类型检查），流行的 JavaScript 库的 TypeScript 注解会维护在专用的 &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;DefinitelyTyped&lt;/a&gt; 仓中。&lt;/div&gt;
&lt;div&gt;正如 Chris Neugebauer 在&lt;a href=&quot;https://www.youtube.com/watch?v=_PPQLeimyOM&quot;&gt;澳大利亚 PyCon 演讲&lt;/a&gt; 中指出的，这很像是 Python 与 &lt;a href=&quot;https://github.com/python/typeshed&quot;&gt;typeshed&lt;/a&gt; 类型提示库、以及像 mypy 这种类型推断和分析工具之间的关系。&lt;/div&gt;
&lt;div&gt;在本质上，TypeScript 和 Python 中的类型提示都是编写特定种类的测试的方式，要么使用单独的文件（就像普通测试一样），要么嵌入在代码体中（就像静态类型语言中的类型声明一样）。对于这两种情况，你都要运行一个单独的命令，来检查其余代码是否与已添加的类型断言一致（对于 TypeScript，这是在编译成 JavaScript 时隐式地发生的；对于 Python 的类型提示，这是一个完全可选的静态分析任务）。&lt;/div&gt;
&lt;h2&gt;动态元编程：Hy、Ruby&lt;/h2&gt;
&lt;div&gt;C、C++、C# 和 Java 等语言的学习者在接触 Python 时，经常感到不安的一个特性是“代码即数据”（code is data）：函数和类之类的东西是运行时对象，可以像其它对象一样被操纵。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hy&quot;&gt;Hy&lt;/a&gt; 是一种 Lisp 方言，可以同时在 CPython VM 和 PyPy VM 上运行。Lisp 及其方言将“代码即数据”的概念推到了极致，因为 Lisp 代码由嵌套列表组成，这些列表描述了要执行的操作（这门语言的名称本身就代表列表处理器“LISt Processor”）。Lisp 风格语言的强大之处在于，它让你非常容易编写出自己的领域特定代码。Lisp 风格语言的最大缺点是，它让你非常容易编写出自己的领域特定代码，但这可能导致每个人写的代码变得难以阅读。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Ruby_%28programming_language%29&quot;&gt;Ruby&lt;/a&gt; 语言在许多方面与 Python 相似，但对于 Python 中“支持但不鼓励”的动态元编程特性，Ruby 社区则相对开放。这包括在已有类定义中添加新的方法，以及使用闭包来实现语言的核心结构，例如迭代。（Python猫注：关于两种语言中迭代结构的实现对比，可阅读 &lt;a href=&quot;https://mp.weixin.qq.com/s/t3kAV_L7S01cz8pImYw9-A&quot;&gt;这篇文章&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;学习这些语言，可以让你深入了解 Python 自己的动态元编程特性，包括&lt;a href=&quot;https://mp.weixin.qq.com/s/jLrcS5c5lLOU-k2B0Y31QQ&quot;&gt;函数和类装饰器&lt;/a&gt;、猴子补丁、unittest.mock 标准库、以及像 wrapt 这样的第三方对象代理模块。（我不知道学习哪种语言可以深入了解 Python 的元类系统，如果有人在这方面有任何建议，请在评论中告知我。Python 的元类驱动着很多特性，例如核心的类型系统、抽象基类、枚举类型和渐变类型表达式的运行时求值。）&lt;/div&gt;
&lt;h2&gt;务实问题解决：Lua、PHP、Perl&lt;/h2&gt;
&lt;div&gt;主流的编程语言并不是孤立存在的——它们作为一个更大的生态系统的一部分而存在，这个生态系统由发行者（企业和社区组织）、终端用户、框架开发者、工具开发者、教育工作者等等组成。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Lua_%28programming_language%29&quot;&gt;Lua&lt;/a&gt; 是一种流行的编程语言，作为一种脚本引擎嵌入到大型程序中。标志性的例子是它被魔兽世界游戏用来编写客户端插件，它也被嵌入到了许多 Linux 发行版所使用的 RPM 组件中。与 CPython 相比，Lua 运行时的大小通常只有 CPython 的十分之一，而且由于较弱的自省能力，它更容易与程序的其它部分以及服务器的操作系统隔离开来。Lua 社区对 Python 生态的一个显著贡献是 LuaJIT FFI（Foreign Function Interface 外来函数接口），它被 CPython 和 PyPy 采用，作为支持 JIT 的 cffi 接口库的基础。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt; 是另一种流行的编程语言，作为 Linux-Apache-MySQL-PHP LAMP 技术栈中的“P”而崛起，因为它专注于生成 HTML 页面，并且在早期的虚拟专用服务器（Virtual Private Server，简称 VPS） 提供商中广泛使用。尽管其设计上有诸多的概念性缺陷让人感到绝望，但它如今是几个极其流行的开源 Web 服务的基础，包括 Drupal 内容管理系统、Wordpress 博客引擎和维基百科的 MediaWiki 引擎。PHP 还支撑着一些重要的服务，比如 &lt;a href=&quot;https://en.wikipedia.org/wiki/Ushahidi&quot;&gt;Ushahidi&lt;/a&gt; 平台，它是一个开源的社会化新闻发布社区。&lt;/div&gt;
&lt;div&gt;像 PHP 一样，&lt;a href=&quot;https://en.wikipedia.org/wiki/Perl&quot;&gt;Perl&lt;/a&gt; 也是基于 Linux 而崛起。但跟 PHP 专门作为 Web 开发平台不同，Perl 是系统管理员的工具，在基于文本的 Linux 操作系统中，它使用正则表达式将命令的输出转成字符串，并进行操作。当 sh、awk 和 sed 都无法胜任某些任务时，Perl 出现并派上了用场。&lt;/div&gt;
&lt;div&gt;学习这些语言，在编程语言设计方面，不大可能获得什么漂亮审美或者优雅概念。学习它们，最可能的是了解编程语言在现实中是如何被分发和采用的，以及这些在多大程度上取决于偶然的机会、历史意外事件、以及发行商在系统中默认集成而降低了使用门槛，而不是取决于语言本身固有的能力。&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUyOTk2MTcwNg==&amp;amp;action=getalbum&amp;amp;album_id=1413329638813827073#wechat_redirect&quot;&gt;Python进阶&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;特别是，它可以提供对以下项目的重要性的洞察：CKAN、OpenStack NFV、Blender、SciPy、OpenMDAO、PyGMO、PyCUDA、树莓派基金会和 Python 被大量商业组织采用，以保护它们在 Python 生态中不断的投入。&lt;/div&gt;
&lt;h2&gt;编程思维：Scratch、Logo&lt;/h2&gt;
&lt;div&gt;我经常跟函数式编程以及面向对象编程的拥护者们讨论，他们声称这类语言就像过程式语言一样易于学习。&lt;/div&gt;
&lt;div&gt;如果我们谈论的是通过嵌入式编程（例如机器人）进行教学，在软件中建模的对象都有现实世界的对应物，比如学生们可以触摸的传感器、马达和继电器，那么，那我会认为 OOP 的人有一定的道理。&lt;/div&gt;
&lt;div&gt;但是对于其他人，我现在有一个标准的挑战：拿起一本烹饪书，把其中一个食谱翻译成你认为是容易学习的编程语言，然后找一个能理解烹饪书中语言的学生，让其按照翻译好的食谱操作。其实，他们不需要真正地操作下去——只需做一个思想实验，就足以意识到他们声称的“很容易学”是假设了多少先验知识。（我很期待看到学术研究人员在现实中做这种研究——我真的很希望看到结果）&lt;/div&gt;
&lt;div&gt;另一种解决这个问题的方法是去学习那些实际上被用来教孩子们编程思维的语言。&lt;/div&gt;
&lt;div&gt;其中最受欢迎的是 &lt;a href=&quot;https://en.wikipedia.org/wiki/Scratch_%28programming_language%29&quot;&gt;Scratch&lt;/a&gt;，它使用了拖放编程界面，让学生们操纵一个独立的图形环境，它里面的电子图形可以移动，并响应环境中的事件。像 Scratch 这样的图形环境就相当于我们用来教孩子阅读和书写的图画书。&lt;/div&gt;
&lt;div&gt;使用特殊的教育语言来操作图形环境的想法并不新鲜，最早的例子之一是 1960 年代发明的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Logo_%28programming_language%29&quot;&gt;Logo&lt;/a&gt; 环境。在 Logo 中（以及类似的环境，如 Python 的 turtle 模块），你主要打交道的是一个“乌龟（turtle）”，你可以通过绘制线条来指导它移动和修改环境。这样的话，命令序列、重复和状态（例如，“起笔”、“落笔”）可以基于人们的自然直觉来使用（“想象你是那只乌龟，如果你右转 90 度会发生什么？”）&lt;/div&gt;
&lt;div&gt;回顾并重新学习这些语言，有助于有经验的程序员放下固化的观念：它们所用的概念可以提醒我们，这些概念是我们如今认为理所当然的，但初学者们需要先学习。当这样做的时候，我们能够更好地与学生和其他初学者们相处，因为我们更有可能打开逻辑的枷锁，也不会再忽略那些有必要的学习步骤。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>通过 for 循环，比较 Python 与 Ruby 编程思想的差别</title>
            <link>https://pythoncat.top/posts/2021-11-23-ruby/</link>
            <guid>https://pythoncat.top/posts/2021-11-23-ruby/</guid>
            <pubDate>Tue, 23 Nov 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;作者：Doug Turnbull&lt;/div&gt;
&lt;div&gt;译者：豌豆花下猫@Python猫&lt;/div&gt;
&lt;div&gt;原文：&lt;a href=&quot;https://softwaredoug.com/blog/2021/11/12/ruby-vs-python-for-loop.html&quot;&gt;https://softwaredoug.com/blog/2021/11/12/ruby-vs-python-for-loop.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Ruby 与 Python 之间的差异在很大程度上可通过 &lt;code&gt;for&lt;/code&gt; 循环看出本质。&lt;/div&gt;
&lt;div&gt;Python 拥有&lt;code&gt;for&lt;/code&gt;语句。对象告诉&lt;code&gt;for&lt;/code&gt;如何进行协作，而&lt;code&gt;for&lt;/code&gt;的循环体会处理对象返回的内容。&lt;/div&gt;
&lt;div&gt;Ruby 则相反。在 Ruby 中，&lt;code&gt;for&lt;/code&gt; 本身（通过 &lt;code&gt;each&lt;/code&gt;）是对象的一个方法。调用者将&lt;code&gt;for&lt;/code&gt;循环体传递给这个方法。&lt;/div&gt;
&lt;div&gt;在 Python 的语言习惯中，对象模型服从于 for 循环。而在 Ruby 中，for 循环服从于对象模型。&lt;/div&gt;
&lt;div&gt;也就是说，在 Python 中，如果你想自定义迭代的过程，可以让对象告诉解释器该如何作迭代：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Stuff&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;a_list &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;position &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            value &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;a_list&lt;span&gt;[&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;position&lt;span&gt;]&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;position &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; value
        &lt;span&gt;except&lt;/span&gt; IndexError&lt;span&gt;:&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;position &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
            &lt;span&gt;raise&lt;/span&gt; StopIteration
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在这里，Stuff 使用 __next__ 和 __iter__ 魔术方法使自身可迭代（变为了可迭代对象）。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; data &lt;span&gt;in&lt;/span&gt; Stuff&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;然而，在 Ruby 的用法中，你要做的恰恰相反。你要将 for 创建成一个方法，它接收代码（body 体）来运行。Ruby 将过程代码放在代码块中，这样它们就可以被用于传递。&lt;/div&gt;
&lt;div&gt;然后，在&lt;code&gt;each&lt;/code&gt;方法中，使用&lt;code&gt;yield&lt;/code&gt;与代码块进行交互，将值传递给代码块来做你需要做的事情（对于任何方法，代码块都是一种隐式参数）。&lt;/div&gt;
&lt;div&gt;如果我们重写上面的代码，会成这样：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Stuff&lt;/span&gt;
  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;&lt;span&gt;initialize&lt;/span&gt;&lt;/span&gt;
    &lt;span&gt;@a_list&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
  &lt;span&gt;end&lt;/span&gt;

  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;&lt;span&gt;each&lt;/span&gt;&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; &lt;span&gt;@a_list&lt;/span&gt;
      &lt;span&gt;yield&lt;/span&gt; item
    &lt;span&gt;end&lt;/span&gt;
  &lt;span&gt;end&lt;/span&gt;
&lt;span&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;使用&lt;code&gt;each&lt;/code&gt;进行迭代：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;Stuff&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;each&lt;/span&gt; &lt;span&gt;do&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;item&lt;span&gt;|&lt;/span&gt;
  puts item
&lt;span&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;不是将数据传给 for 循环（Python），而是将循环代码传给数据（Ruby）。&lt;/div&gt;
&lt;div&gt;但区别还远不止于此：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Python 构建类似于 for 的结构，用于各种处理；Ruby 将数据处理工作放到方法中。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;优秀的 Python 代码使用列表和字典解析式来实现&lt;code&gt;map&lt;/code&gt; 和&lt;code&gt;filter&lt;/code&gt;，这些表达式的核心与 for/迭代的语义是相同的。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;item &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; Stuff&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
Out&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;item &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; Stuff&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; item &lt;span&gt;%&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
Out&lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Ruby 则继续使用方法优先的方式，除了&lt;code&gt;each&lt;/code&gt; 方法，还有一系列常用于处理集合的新方法，如下所示：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Stuff&lt;/span&gt;
  &lt;span&gt;...&lt;/span&gt;

  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;&lt;span&gt;select&lt;/span&gt;&lt;/span&gt;
    out &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
    &lt;span&gt;each&lt;/span&gt; &lt;span&gt;do&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;e&lt;span&gt;|&lt;/span&gt;
      &lt;span&gt;# If block returns truthy on e, append to out&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; &lt;span&gt;yield&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;e&lt;span&gt;)&lt;/span&gt;
        out &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; e
      &lt;span&gt;end&lt;/span&gt;
    &lt;span&gt;end&lt;/span&gt;
    out
  &lt;span&gt;end&lt;/span&gt;

  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;&lt;span&gt;map&lt;/span&gt;&lt;/span&gt;
    out &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
    &lt;span&gt;# One line block syntax, append output of block processed on e to out&lt;/span&gt;
    &lt;span&gt;each&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;e&lt;span&gt;|&lt;/span&gt; out &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;yield&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;}&lt;/span&gt; 
    out
&lt;span&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;puts &lt;span&gt;Stuff&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;map &lt;span&gt;{&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;item&lt;span&gt;|&lt;/span&gt; item&lt;span&gt;}&lt;/span&gt;
puts &lt;span&gt;Stuff&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;select&lt;span&gt;{&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;item&lt;span&gt;|&lt;/span&gt; item&lt;span&gt;.&lt;/span&gt;even&lt;span&gt;?&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 说：“你告诉我们如何迭代你的实例，我们将决定如何处理你的数据。” Python 有一些基于语言的用作迭代和处理的原语，如果要自定义迭代，只需将正确的代码添加到 for 循环体（或表达式）中。&lt;/div&gt;
&lt;div&gt;Ruby 反转了剧本，赋予对象更深层的可定制性。是的，在某些情况下，我们可以在代码块中添加更多的控制流。是的，我们也可以把 each 方法用来做 map。但是 Ruby 允许对象们实现不同的 map 和 each（如果将“each”的实现用于“map”，可能会非常不理想，甚至不安全）。Ruby 的对象在处理其数据方面，有着更好的方法。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;在 Ruby 中，对象控制着功能可见性。而在 Python 中，是语法做着控制。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;地道的 Python 对数据处理有着强势的看法。Python 说：“看，90% 的代码都能很好地融入这些想法，只要遵从它，完成工作就行了。”把你的对象变成可以 for-循环的，别再烦我了。&lt;/div&gt;
&lt;div&gt;然而 Ruby 说：“在一些重要的情况下，我们不想给调用者太多能力。”所以 Ruby 让对象去控制它们被处理的方式，并要求开发人员遵循对象想要被交互的方式。Ruby 在数据处理上没那么强势。&lt;/div&gt;
&lt;div&gt;Python 更像是基于 C 语言的“面向对象”编程的扩展。在基于 C 的 OO 中，就像 posix 文件描述符或 Win32 窗口句柄一样，语言并不强制将“方法”与对象本身绑定。相反，对象到方法的绑定只是基于约定。&lt;/div&gt;
&lt;div&gt;Python 认为这个过程世界是可以进化的——它升级了这种思维方式，使之更安全。自由函数是存在的（Python猫注：应该指的是内置函数，因不依赖于任何类对象，故是“自由的”），而且确实经常比对象方法更受推荐。对象是存在的，但以一种相对犹豫的方式。&lt;/div&gt;
&lt;div&gt;类方法接收“self”作为其第一个参数，几乎与 Win32 或 Posix API 中的 C 函数接受句柄的方式相同。当函数被传递时，它们几乎被当作 C 函数指针来对待。&lt;/div&gt;
&lt;div&gt;Python 认为程序范式（procedural paradigm）是最重要的，它是一切的关键基础，在它之上是面向对象的语义层。&lt;/div&gt;
&lt;div&gt;然而，Ruby 却将其颠倒过来。Ruby 将面向对象作为金字塔的基础。Ruby 在代码块中包含了混乱的过程世界，让对象使用这些过程块。&lt;/div&gt;
&lt;div&gt;Ruby 并没有为了遵循语言的过程性基础而破坏对象，而是使过程性代码适应对象的世界观。Ruby 有真正的私有方法，不像 Python 的私有方法/参数，只是出于约定。&lt;/div&gt;
&lt;div&gt;毫无疑问，当我从系统编程的角度接触 Python 时，它对我的观感来说是很自然的。具备着在必要的时候编写 C 语言的能力，它进化了，令那个世界更加安全。也许这就是为什么它在系统资源密集的数值计算领域中，找到了用武之地。&lt;/div&gt;
&lt;div&gt;难怪 Ruby 很适合开发人员构建更流畅、也许更安全的 API 和 DSL。Ruby 希望程序员对领域进行建模，而不是对编程环境进行建模，这对于许多工作来说，似乎是正确的方法。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 官方研讨会，彻底移除 GIL 真的可行么？</title>
            <link>https://pythoncat.top/posts/2021-11-14-GIL/</link>
            <guid>https://pythoncat.top/posts/2021-11-14-GIL/</guid>
            <pubDate>Sun, 14 Nov 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;作者：Łukasz Langa&lt;/div&gt;
&lt;div&gt;译者：豌豆花下猫@Python猫&lt;/div&gt;
&lt;div&gt;原文：&lt;a href=&quot;https://lukasz.langa.pl/5d044f91-49c1-4170-aed1-62b6763e6ad0&quot;&gt;Notes From the Meeting On Python GIL Removal Between Python Core and Sam Gross&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在一年一度的 Python 核心开发者 sprint 会议期间，我们与 Sam Gross 举行了一次会议，他是 nogil 的作者。nogil 是 Python 3.9 的分叉版本，移除了 GIL。这是一份非正式的会议纪要。&lt;/div&gt;
&lt;h2&gt;简单总结&lt;/h2&gt;
&lt;div&gt;Sam 的工作证明了以他的方式删除 GIL 是可行的，即生成的 Python 解释器的性能良好，并且可以随着 CPU 内核的增加而扩展。为了最终达到正面的效果，还需要有其它看似无关的解释器工作。&lt;/div&gt;
&lt;div&gt;目前还不可能将 Sam 的更改合并到 CPython，因为他的更改是针对 3.9 分支进行的，便于用户拿当前 pip 可安装的库和 C 扩展对 nogil 解释器进行测试。如果要合并 nogil，就不得不基于 main 分支进行更改（目前 main 分支已规划为 3.11）。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;不要指望 Python 3.11 会移除 GIL。&lt;/strong&gt; 将 Sam 的工作合并到 CPython 本身将是一个艰苦的过程，但这仅仅是所需的一部分：在 CPython 移除 GIL 之前，需要为社区制定一个良好的向后兼容的迁移计划。这些都还没有计划好，所以我们认为时机还没到。&lt;/div&gt;
&lt;div&gt;有些人在谈论如此巨大的变化时提到了 Python 4。核心开发人员当前没有计划发布 Python 4，事实上恰恰相反：我们正积极地避免发布 Python 4，因为 Python 2 到 3 的转换对社区来说已经足够困难了。现在考虑或者担心 Python 4，肯定还为时过早。&lt;/div&gt;
&lt;h2&gt;介绍 nogil&lt;/h2&gt;
&lt;div&gt;Sam 发布了他的代码，同时还有一篇详细的文章，解释了该项目的动机和设计。&lt;/div&gt;
&lt;div&gt;nogil 代码地址：&lt;a href=&quot;https://github.com/colesbury/nogil&quot;&gt;https://github.com/colesbury/nogil&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;他的设计可以总结为：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;为了线程安全，将 Python 内置的分配器&lt;code&gt;pymalloc&lt;/code&gt;替换成&lt;code&gt;mimalloc&lt;/code&gt; ，对字典和其它集合对象采用无锁读写，同时提升效率（堆内存布局允许在不维护显式列表的情况下找到 GC 跟踪的对象）&lt;/li&gt;
&lt;li&gt;用有偏见的引用计数（&lt;a href=&quot;https://dl.acm.org/doi/10.1145/3243176.3243195&quot;&gt;biased reference counting&lt;/a&gt;）替代非原子的急切的引用计数（non-atomic eager reference counting）：
&lt;ul&gt;
&lt;li&gt;将每个对象与创建它的线程（称为 owner thread）绑定；&lt;/li&gt;
&lt;li&gt;对象在 owner thread 内使用时，采用快速的非原子的局部型引用计数；&lt;/li&gt;
&lt;li&gt;对象在其它线程内使用时，采用较慢的但原子的共享型引用计数；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为了加快跨线程的对象访问（因为会被原子的共享型引用计数拖慢），引入两种技术：
&lt;ul&gt;
&lt;li&gt;有些特殊对象是永生的，这意味着它们的引用计数永远不会被计算，也永远不会被释放：这包含像 None、True、False 这样的单例对象，小整数和常驻的字符串，以及静态分配的内置类型 PyTypeObjects；&lt;/li&gt;
&lt;li&gt;其它全局可访问对象使用延迟引用计数（deferred reference counting），如顶级的函数、代码对象和模块；它们不是永生的，并不总是在程序的生命周期内存活；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调整循环的垃圾回收器成一个单线程的 stop-the-world 垃圾回收器：
&lt;ul&gt;
&lt;li&gt;等待所有线程在一个安全点（任何字节码的边界）挂起；&lt;/li&gt;
&lt;li&gt;不等待阻塞在 I/O 的线程（使用&lt;code&gt;PyEval_ReleaseThread&lt;/code&gt; ，相当于在当前 Python 中释放 GIL）；&lt;/li&gt;
&lt;li&gt;高效地构造对象的列表，以便即时地释放：得益于&lt;code&gt;mimalloc&lt;/code&gt;， GC 跟踪的对象都保存在一个单独的轻量级的堆中；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将全局进程的 MRO 缓存迁移到局部线程里，避免查找 MRO 时的争用；缓存失效仍然是全局性的；&lt;/li&gt;
&lt;li&gt;修改内置的集合类对象，使之成为线程安全的。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;Sam 的设计文档包含了这些设计元素的细节，包含线程状态与 GIL API 的信息，以及解释器和字节码的其它修改（用带有累加器的寄存器 VM 替换堆栈VM；通过避免创建 C 语言的栈帧来优化函数调用；ceval.c 的其它变更；标签指针的使用；LOAD_ATTR、LOAD_METHOD、 LOAD_GLOBAL 操作码的线程安全的元数据；等等）。我建议你完整地阅读它。&lt;/div&gt;
&lt;div&gt;Python猫注：上文出现的“stop-the-world”，有时缩写成“STW”，这是多数垃圾回收器的工作机制，表示在垃圾回收器工作时，其它线程全部暂时挂起，从而保证引用对象的准确更新，其缺点是对程序性能有所影响；“MRO”是“method resolution order”的缩写，即“类方法解析顺序”，表示在所有基类中搜索成员方法时的次序。&lt;/div&gt;
&lt;h2&gt;早期的基准测试&lt;/h2&gt;
&lt;div&gt;在 &lt;a href=&quot;https://github.com/python/pyperformance&quot;&gt;pyperformance&lt;/a&gt; 基准测试套上，&lt;strong&gt;作为概念验证的 nogil 解释器比 3.9 快 10%&lt;/strong&gt;。据估计，在解释器的全部修改中，移除 GIL 会导致性能变慢 9%，主要是因为有偏见的引用计数和延迟引用计数。换句话说，Python 3.9 加上 nogil 的所有更改，但不移除 GIL 本身，可以快 19%。然而，这样并不能解决多核的可伸缩性问题。&lt;/div&gt;
&lt;div&gt;顺便说一下，nogil 的一些更改，比如将 C 调用栈与 Python 调用栈解耦，已经在 Python 3.11 中实现了。事实上，我们有&lt;a href=&quot;https://gist.github.com/markshannon/553004b52d1e175ceb5548e4a43bced8&quot;&gt;针对当前 main 分支的初步的基准测试&lt;/a&gt; ，结果表明在单线程的性能上，&lt;strong&gt;Python 3.11 比 nogil 快 16%&lt;/strong&gt;。&lt;/div&gt;
&lt;div&gt;需要有更多的基准测试，特别是使用 Larry Hastings 在对 Gilectomy 进行测试时使用的基准测试（当时基于 Python 3.5，后来移植到 3.6 alpha 1）。&lt;/div&gt;
&lt;div&gt;Python猫注：gilectomy 是由 GIL ectomy 两个单词组合而成，ectomy 是一个医学上的术语“切除术”，可见这个项目的用意跟 nogil 是一样的！这是 5-6 年前的项目，作者曾在 PyCon 大会上做过几次分享。但这个项目反而导致 Python 总体性能下降了，最后无疾而终。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;gilectomy 项目作者在 PyCon 上的分享：&lt;/p&gt;
&lt;p&gt;2015年分享：&lt;a href=&quot;https://www.youtube.com/watch?v=KVKufdTphKs&quot;&gt;https://www.youtube.com/watch?v=KVKufdTphKs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2016年分享：&lt;a href=&quot;https://www.youtube.com/watch?v=P3AyI_u66Bw&quot;&gt;https://www.youtube.com/watch?v=P3AyI_u66Bw&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2017年分享：&lt;a href=&quot;https://www.youtube.com/watch?v=pLqv11ScGsQ&quot;&gt;https://www.youtube.com/watch?v=pLqv11ScGsQ&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;Sam 提醒我们，一个用户程序在无 GIL 的 Python 上的伸缩性实际上取决于最终的代码。如果不进行测试，就不可能预测代码在没有 GIL 的情况下表现如何。因此，如果提供一个单一的数字来说明无 GIL 的 Python 速度会提升 x 倍，这是不负责任的。&lt;/div&gt;
&lt;h2&gt;会议中向 Sam 提出的问题&lt;/h2&gt;
&lt;div&gt;为了清晰易懂，这里的问题基于会议上的内容进行了重新排序。答案是由 Sam 的回答转述而来的，并得到了他阅读草稿后的认可。要注意的是，核心团队的成员可能对其中一些主题有其它观点。&lt;/div&gt;
&lt;h3&gt;Q：有哪些可感知的风险是阻碍 nogil 项目合入到 CPython 中的？&lt;/h3&gt;
&lt;div&gt;目前的代码库已经证明了它在技术上的可行性。它可以运行，而且比普通的 CPython 解释器和 Gilectomy 项目更具有可伸缩性和好性能。我在该项目中投入了将近两年的全职工作。&lt;/div&gt;
&lt;div&gt;这完全取决于社区对 C 扩展程序的改造程度，以确保它们不会导致解释器彻底崩溃。然后，剩下的长尾就是社区要以一种既正确又可扩展的方式在应用程序中采用自由线程。这两个是最大的挑战，但我们必须乐观应对。&lt;/div&gt;
&lt;h3&gt;Q：你打算如何改进你的工作？对 commit 次序有什么建议吗？你将如何保持你的工作与 main 分支的同步？&lt;/h3&gt;
&lt;div&gt;Sam 目前正在重构他的工作，最初是基于 3.9.0a3，将匹配 3.9.7 最终版本。这项工作的一部分是将 commit 重构为逻辑单元，以便更好地说明哪些内容需要更改（哪些地方改了，以及为什么要改）。&lt;/div&gt;
&lt;div&gt;目前还不计划把这项工作移到 main 分支（未来的 3.11），因为这个分支太不稳定了。相比之下，3.9 有大量已发布的可通过 pip 安装的库和 C 扩展，可用于测试。这使得 Sam 能够评估该项目与真实世界的第三方代码的行为。基于 main 的修改将花费不少时间，而这些时间本可以花在改进无 GIL 的解释器上，所以，现在就基于主分支的话，还为时过早。&lt;/div&gt;
&lt;div&gt;将工作进行分割然后再合并是可行的，但必须记住，许多更新需要在串联起来时，性能才会提升。单独而言，它们会导致（暂时的？）性能下降。&lt;/div&gt;
&lt;div&gt;核心开发者注：我们现在不能合并对 3.9 分支所做的更改。在项目的这个阶段使用 3.9 是有意义的，但关键的是要将它分割成可消费的数据块，然后一个一个地合并到 main 分支中。一块一块地做，很有可能会损害性能，但这是唯一现实的集成途径。&lt;/div&gt;
&lt;h3&gt;Q：可以只引入寄存器 VM 和编译器而不做其它更改吗？在不改变引用计数或 GIL 的情况下使用寄存器 VM 会有什么特殊的困难吗？&lt;/h3&gt;
&lt;div&gt;VM 使用延迟/永生的引用计数。可以将其转换为只使用经典的引用计数，但最终结果的效率还不清楚（例如，出于性能考虑，堆栈上的所有对象都使用了延迟引用计数）。&lt;/div&gt;
&lt;h3&gt;Q：跟前一问相反的问题：只引入 nogil，而不使用新的寄存器 VM，会有什么困难呢？&lt;/h3&gt;
&lt;div&gt;虽然新的 VM 只提高了性能，而不是准确性，但它也提高了可伸缩性，使得无 GIL 的 Python 可以充分利用 CPU 内核而不发生争用。因此要使用 3.11 解释器也是可行的，但最好保留一些寄存器 VM 的设计思想，这对可伸缩性和线程安全很重要。这需要做大量的工作。但是将寄存器 VM 更新成跟 main 分支一样（以及修复遗留的 bug），也需要大量的工作。这两种选择都是可行的。&lt;/div&gt;
&lt;h3&gt;Q：对于那些不希望自己的代码被其它线程并行运行的 C 扩展，有什么建议么？在适应新的自由线程环境之前，难道不需要 CPython 给它们提供一些 API 来弥补差距吗？&lt;/h3&gt;
&lt;div&gt;这需要花时间。目标是渐进式采纳，最终推广至大多数 C 扩展。GIL 可以作为解释器启动时的一个选项。如果没有启用 GIL，并且 C 扩展不支持新的操作模式，可能就要产生告警或者不让其导入。Python 社区不得不适配 C 扩展，让它们适应无 GIL 的模式。&lt;/div&gt;
&lt;div&gt;作为概念验证的 nogil 项目，默认使用无 GIL 模式，并接受任何 C 扩展。如果它被 CPython 采用了，那么在开始时默认应该启用 GIL（要求在启动 Python 时使用 &lt;code&gt;-X nogil&lt;/code&gt; 禁用 GIL），以便让第三方库做适配。然后，在发布几个版本后，默认值再切换成无 GIL 的模式。&lt;/div&gt;
&lt;div&gt;虽然要移植全部东西并不容易（并行是很难的），但在多数情况下，移植并不会很难，特别是对于封装外部库的 C 扩展来说。&lt;/div&gt;
&lt;div&gt;核心开发者注：有大量的“暗物质” Python 代码（和 C 扩展）不是开源的。我们需要小心不去破坏它们，因为它们的用户可能无法做出所需的更改，或者向上游报告问题给我们。特别地，有些 C 扩展使用 GIL 来保护它们自己的内部状态。这是一个很大的担忧，可能是采用无 GIL Python 的一个很大的障碍。&lt;/div&gt;
&lt;h3&gt;Q：你会添加一个 PEP-489 的“插槽”么，以便 C 扩展用来表示其支持 nogil，这样当遇到不支持 nogil 的库时，就不让它导入？&lt;/h3&gt;
&lt;div&gt;很多人也提过，这可能是一个好主意，但我不完全清楚这意味着什么。选择无 GIL 模式并不能保证没有 bug。相反，在默认情况下，我们运行所有的扩展（现在的 nogil 就是这么做的）。不兼容的扩展可以使用 PyInit 模块的代码，主动地询问解释器是否启用了 GIL，如果不兼容的话，就在导入时产生警告甚至异常。&lt;/div&gt;
&lt;h3&gt;Q：在运行期启用 nogil 是一项长期可行的选择，还是过渡性的功能呢？&lt;/h3&gt;
&lt;div&gt;理想的结局是 CPython 不再有 GIL，句号。然而，预计将有一个漫长的社区适应期。我们希望避免从 Python2 到 Python3 过渡时的断裂。准确地说，我们希望过渡得越平滑越好，即使这意味着需要延展更长的时间。&lt;/div&gt;
&lt;h3&gt;Q: 确认一下，最终状态是只有 nogil，并且不支持再开启 GIL 么？&lt;/h3&gt;
&lt;div&gt;目前我们还不确定。理想的结局是只存在一个无 GIL 的 Python，但尚不清楚这能否实现。&lt;/div&gt;
&lt;h3&gt;Q：如果这些特性标志会持续很长一段时间，这是否意味着我们需要大幅增加测试矩阵？&lt;/h3&gt;
&lt;div&gt;是的，测试矩阵需要加倍。然而，测试无 GIL 版本可能是判断经典的 GIL 版本是否有效的一个很好的预测器。有必要偶尔（每晚？）运行启用了 GIL 的测试。&lt;/div&gt;
&lt;div&gt;核心开发者注：如果不做测试，代码将加速退化。在 CPython 中，由于需要运行时间（例如测试引用泄漏时），我们不会在每次更改时都运行所有测试，但如果有更改导致每日测试失败，我们会立即回退更改，因为在已经失败的构建点之后，很可能会出现其它的回归问题。&lt;/div&gt;
&lt;h3&gt;Q：你认为多个 Python 解释器并行运行，每个解释器一个 GIL 怎么样？&lt;/h3&gt;
&lt;div&gt;Python猫注：给大家科普一下这个问题的背景，PEP-554 提议实现多解释器来解决 GIL 的问题。这是在 2017 年提出的，受到挺多关注。在 2019 年时，我曾翻译过《&lt;a href=&quot;https://mp.weixin.qq.com/s/8KvQemz0SWq2hw-2aBPv2Q&quot;&gt;Has the Python GIL been slain?&lt;/a&gt;》介绍它。但是，目前该提案依然是草稿状态，具体的开发情况不甚明朗。&lt;/div&gt;
&lt;div&gt;跟无 GIL 提案相比，这既是互补的，又是相互竞争的。在无 GIL 解释器中也可以支持副解释器。&lt;/div&gt;
&lt;div&gt;目前还不清楚多解释器方案能否实现。有了 nogil，就不需要担心跨线程共享对象，也不需要担心 C 扩展的兼容性，因为有了多解释器，就没有任何状态是真正全局的，因此需要特别地隔离。对于可变对象，在多解释器之间传递时，需要某种形式的序列化/反序列化。对于不可变对象，解释器可能会添加特殊的支持，但如果它们不是已知的不可变的内置类型，用户代码就需要适配这些对象。这是从 PyTorch 的相关工作中得到的启发，它使用了某种形式的多解释器。&lt;/div&gt;
&lt;div&gt;由于我最感兴趣的用例实际上是科学数据（PyTorch 训练工作流），直接而有效地共享数据的能力对多线程性能至关重要。如果采用多解释器，这种共享只能在 C 扩展级别上开启，与无 GIL 的 Python 相比，将导致更多使用 C/C++ 代码。&lt;/div&gt;
&lt;h3&gt;Q：你已经详细介绍了字典和列表的实现。其它可变类型例如队列、集合、数组等等，是如何实现的呢？&lt;/h3&gt;
&lt;div&gt;nogil 是一个开发中的项目。由于字典和列表在解释器的内部运作中很普遍，所以它们的开发最多。同样地，队列的开发已经完成，但其它类型还没有。集合是下一个要覆盖的重要内容。&lt;/div&gt;
&lt;div&gt;队列非常重要，因为它被&lt;code&gt;concurrent.futures&lt;/code&gt; 和&lt;code&gt;asyncio&lt;/code&gt; 用于并发线程之间的通信。队列比字典和列表简单，它使用细粒度的锁而不是无锁读取。其它的对象很可能需要组合使用。&lt;/div&gt;
&lt;div&gt;这项工作很棘手，因为在获取和释放锁时需要小心，例如 Py_DECREFs 是可重入的。还可以考虑使用更“粗粒度”的锁，但当然了，这些锁都有死锁的风险。&lt;/div&gt;
&lt;h3&gt;Q：nogil 有多依赖 mimalloc? 如果我们把它作为一个编译期选项，可以用或不用它，那么使用平台的 malloc 来代替没有 C 预处理器地狱的低性能构建是否可行？&lt;/h3&gt;
&lt;div&gt;mimalloc 不仅仅是用于线程安全。它对于启用字典的无锁读取是必要的，还支持高效的 GC 追踪。&lt;/div&gt;
&lt;div&gt;mimalloc 的维护者对显式地支持 CPython 很感兴趣，并且乐意为实现这一点进行必要的更改。&lt;/div&gt;
&lt;div&gt;其它实现的 malloc 据说也稳定支持 CPython：在 Facebook 中使用的&lt;code&gt;jemalloc&lt;/code&gt;，在谷歌中使用&lt;code&gt;tcmalloc&lt;/code&gt;，尽管集成得较少，更像是默认分配器的简单替换。（Python猫注：前文提到的 mimalloc 是微软的）&lt;/div&gt;
&lt;div&gt;核心开发者注：Christian Heimes 和 Pablo Galindo Salgado 正在评估 CPython 使用 mimalloc。早期测试在平均上（几何平均数）没有性能衰退，大多数基准测试做得更好，少数基准测试做得稍微差一些。还有一些待评估的问题：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;mimalloc 的 API 和 ABI 的稳定性；&lt;/li&gt;
&lt;li&gt;授权许可；&lt;/li&gt;
&lt;li&gt;跨所有 CPython 支持的平台的可移植性，例如 stdatomic.h 仅在 C11 中可用；&lt;/li&gt;
&lt;li&gt;集成分析和检测工具（Valgrind、asan、ubsan 等等）；&lt;/li&gt;
&lt;li&gt;可能还有其它。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Q：你的项目和 Larry 的 Gilectomy 有什么相似之处？你能利用他的项目吗？&lt;/h3&gt;
&lt;div&gt;在顶层设计上，两个项目是相似的：延迟引用计数，细粒度锁，关于返回借用的引用的挑战。没有复用 Gilectomy 的代码。&lt;/div&gt;
&lt;h3&gt;Q：你说你的项目在顶层上类似于 Larry 的 Gilectomy。他的项目也是基于延迟引用计数。然而，他在 Gilectomy 上只得到了性能下降的结果，而你的“nogil”却有很好的性能表现。你认为这种差异是怎么回事？&lt;/h3&gt;
&lt;div&gt;切换到基于寄存器的编译器和其它优化，比如由 mimalloc 提供的无锁的字典读取，以及使用延迟引用计数来避免争用，对 nogil 的扩展性和性能都至关重要。而且，在某些情况下，Python 本身变得更快了。例如， Python 3.9 中的函数调用比 Python 3.5 的要快得多。&lt;/div&gt;
&lt;div&gt;让它支持扩展，肯定比预期要花更多的工作。&lt;/div&gt;
&lt;h3&gt;Q：有没有可能在无 GIL 模式中加入一个（不兼容的） C 扩展或剔除它吗？&lt;/h3&gt;
&lt;div&gt;顾名思义，GIL 就是一个全局锁。为了保护任意一段共享数据，它需要在所有线程上开启，包括不兼容的扩展所处的线程。&lt;/div&gt;
&lt;div&gt;在已经运行的进程中，将无 GIL 的解释器切换为使用 GIL 的解释器是很棘手的（反之亦然）。最好的做法是在启动时选择：要么在进程中启用 GIL，要么不启用。如果 C 扩展没有标记为兼容，就引发警告或无法导入。&lt;/div&gt;
&lt;div&gt;或者，当访问 C 扩展时，也可以“stop the world”，但这与移除 GIL 而所想达成的目的不符。&lt;/div&gt;
&lt;div&gt;核心开发者注：到目前为止，还有其它的想法需要深入探讨。有种想法是将 GIL 转换为“单写多读”锁。在这种情况下，无 GIL 的模式将获取“多读”锁，也就是说，不会阻塞其它新代码做同样的事情。而历史遗留的代码将获得一个“单写”锁，阻塞其它所有线程执行，直到锁释放。这种设计需要保留获取/释放 GIL 的 api，nogil 已经这样做了，为了告知 GC 一个线程被阻塞在 I/O 上。&lt;/div&gt;
&lt;h3&gt;Q：有没有可能将函数标记为非线程安全的（比如使用装饰器），并让 nogil 在运行代码时加锁，以防止其它线程调用它？（有点像临时的 GIL）&lt;/h3&gt;
&lt;div&gt;如果担心的是状态被其它线程访问，则需要锁定每一次访问。这在装饰器层面上不是特别可行。正如之前说过，条件性地为不安全的代码开启 GIL 是很难实现的。&lt;/div&gt;
&lt;h3&gt;Q：用你自己的锁代替 GIL 会很困难。使用 nogil，你认为与线程相关的问题会增加么？&lt;/h3&gt;
&lt;div&gt;不清楚。对于 C API 扩展，至少有一种好的设计模式：它们通常有类似的结构，并在单个结构中保持共享状态。目前，Pybind11 看起来与这个模式距离最远，因此用它编写的 C 扩展可能需要进行大量更改。&lt;/div&gt;
&lt;div&gt;许多复杂的 C 扩展已经不得不处理锁和多线程，因为它们的目的是尽可能多地释放 GIL，比如 numpy。所以，也许令人惊讶的是，那些项目可能更容易迁移。&lt;/div&gt;
&lt;h2&gt;下一步工作&lt;/h2&gt;
&lt;div&gt;在这次会议之后，核心开发者们讨论了将 nogil 纳入主项目的可行性，以及这对社区意味着什么。毫无疑问，这种程度的改变必须非常小心。&lt;/div&gt;
&lt;div&gt;在作出决定之前，我们觉得先引入它的一些代码更为可行。特别地，mimalloc 看起来很有趣，已经有一个 open 的 &lt;a href=&quot;https://github.com/python/cpython/pull/29123&quot;&gt;pull 请求&lt;/a&gt;，旨在探索引入它。在那里可以找到基准测试的链接。&lt;/div&gt;
&lt;div&gt;在个人层面上，我们对 Sam 所做的工作印象深刻，并邀请他加入 CPython 项目。我很高兴地告诉大家，他对此很感兴趣，为了帮助他成为一名核心开发者，我将为他提供指导。Guido 和 Neil Schemenauer 将帮我检视我不熟悉的解释器部分的代码。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>与 Python 之父聊天：更快的 Python！</title>
            <link>https://pythoncat.top/posts/2021-10-30-Guido/</link>
            <guid>https://pythoncat.top/posts/2021-10-30-Guido/</guid>
            <description>Guido 上了一档英文播客节目（30分钟），谈论了他正在做的与高性能相关的工作，解答了几个问题。播客作者整理了一份内容纪要，本文是对该纪要的翻译</description>
            <pubDate>Sat, 30 Oct 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在今年 5 月的 Python 语言峰会上，Guido van Rossum 作了一场《Making CPython Faster》的分享（&lt;a href=&quot;https://mp.weixin.qq.com/s/DWVVoh2oj1GQ20WlTYo3cg&quot;&gt;材料在此&lt;/a&gt;），宣告他加入了激动人心的“香农计划”，旨在 4 年内提升 Python 性能至 5 倍。近日，Guido 上了一档英文播客节目（时长 30 分钟），谈论了他正在做的与高性能相关的工作，解答了几个问题。播客作者整理了一份内容纪要，本文是对该纪要的翻译。注：文末有音频及文稿下载&lt;/div&gt;
&lt;div&gt;作者：Software at Scale&lt;/div&gt;
&lt;div&gt;译者：豌豆花下猫@Python猫&lt;/div&gt;
&lt;div&gt;原文：&lt;a href=&quot;https://www.softwareatscale.dev/p/software-at-scale-34-faster-python&quot;&gt;Software at Scale 34 - Faster Python with Guido van Rossum&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;1、为什么你会对研究 Python 的性能感兴趣？&lt;/h3&gt;
&lt;div&gt;Guido：在某种意义上，它对我来说是一个相对舒服的话题，因为这意味着与 Python 的核心打交道，而我对这方面还算熟悉。当我在微软工作时，我曾短暂地关注过 Azure，但我意识到我在谷歌或 Dropbox 时就不喜欢这类工作。然后我关注了机器学习，但这需要花很多时间来做一些与 Python 无关的事情，甚至它与 Python 相关的部分就很少。&lt;/div&gt;
&lt;h3&gt;2、Mark Shannon 关于 Python 性能的那些想法有何不同，怎么能说服你去实现它们的呢？&lt;/h3&gt;
&lt;div&gt;Guido：我喜欢他思考问题的方式。大多数其它聚焦于 Python 性能的方法，如 PyPy 和 Cinder，并不适用于所有的使用场景，因为它们不能向后兼容扩展模块。Mark 具有 CPython 开发者的视角和经验，并且有一种可行的方法来维持向后兼容性，这是最难解决的问题。Python 的字节码解释器经常要在小版本之间（例如 3.8→3.9）进行修改，原因有很多，比如新的操作码，所以修改它是一种相对安全的方案。&lt;/div&gt;
&lt;h3&gt;3、你能给我们解释一下 Python 解释器的分层执行的概念么？&lt;/h3&gt;
&lt;div&gt;Guido：当执行一个程序时，你不知道它会在运行了几分之一毫秒后崩溃，还是会持续运行三周时间。因为对于同一份代码，在第一种情况下，它可能触发了一个 bug。如果运行程序需要三周时间，也许提前半小时优化所有待运行的代码是有意义的。&lt;/div&gt;
&lt;div&gt;但很明显，特别是在像 Python 这样的动态语言中，我们尽可能多地做，而不要求用户告诉我们他们到底需要怎么做，你只是想尽快开始执行代码。所以，如果有一个小脚本，或者一个大程序，它碰巧执行失败了或者因为某些原因提前退出了，你就不用花费时间去优化全部的代码了。&lt;/div&gt;
&lt;div&gt;所以，我们要做的就是保持字节码编译器的简单化，以便能尽快地开始执行代码。如果有某些函数被多次执行，那么我们就称其为 hot 函数。“hot”存在多种定义。在某些情况下，如果一个函数被调用超过一次，或者超过两次，或者超过 10 次，那么它被定义成一个热门函数。而在其它保守的情况下，你可能说“只有被调用 1000 次才算 hot”。&lt;/div&gt;
&lt;div&gt;然后，当参数的类型是某些特定类型时，专门化的自适应编译器（PEP-659 Specializing Adaptive Compiler）会尝试用更快的字节码来替换某些字节码。一个简单的假想的例子是 Python 中的加号运算符，它可以令很多对象相加，比如整数、字符串、列表，甚至元组。但是，你不能将整数与字符串相加。&lt;/div&gt;
&lt;div&gt;因此，优化的方法就是提供一个单独的“两个整数相加”的字节码，它是一个对用户隐藏的第二层字节码。（“优化”通常被称为加速 quickening，但一般在我们的语境中，我们称之为专门化 specializing）。这个操作码假设它的两个参数都是真正的 Python 整型对象，直接读取这些对象的值，并在机器寄存器中将这些值相加，最后将结果推回堆栈。&lt;/div&gt;
&lt;div&gt;两个整数相加的操作仍然需要对参数进行类型检查。因此，它不是完全不受约束的，但这种类型检查相比于完全泛化的面向对象的加号操作，前者在实现上要快得多。&lt;/div&gt;
&lt;div&gt;最后，有可能一个函数被整型参数调用了数百万次，然后突然一小段代码用浮点型参数调用它，或者出现更糟的情况。此时，解释器会直接执行原始的字节码。这是一个重要的部分，让你始终能得到完整的 Python 语义。&lt;/div&gt;
&lt;div&gt;Python猫注：“香农计划”的最终目标是将解释器的执行过程分层，并对不同层做出定制的优化。详情请查阅 Github &lt;a href=&quot;https://github.com/markshannon/faster-cpython/blob/master/tiers.md&quot;&gt;项目的介绍&lt;/a&gt;。&lt;/div&gt;
&lt;h3&gt;4、通常你会在谈 JIT（Just-In-Time）编译器时听到这些技术，但官方 Python 现在还没有实现&lt;/h3&gt;
&lt;div&gt;Guido：即时编译的方案有一大堆我们想要避免的情感包袱。比如，我们不清楚到底编译什么，以及什么时候编译。在程序开始执行之前，解释器将源代码编译成字节码，然后，再将字节码转换为专门的字节码。这意味着，所有的事情都在运行时的某个时刻发生，那么，哪个部分是所谓的即时（Just-In-Time）呢？&lt;/div&gt;
&lt;div&gt;另外，人们通常认为 JIT 会自动地使所有代码变得更好。不幸的是，你通常无法真正地预测代码的性能。由于有现代的 CPU 和它们神奇的分支预测，我们已经拥有了足够的性能。例如，我们以一种本认为能够明显减少内存访问次数的方式，编写了一份代码。但是，当对它进行基准测试时，我们发现它的运行速度与旧的未优化代码一样快，因为 CPU 在没有我们任何帮助的情况下，计算出了优化的访问模式。我希望我知道现代 CPU 在分支预测和内联缓存方面做了什么，因为这就像是魔法一般。&lt;/div&gt;
&lt;h3&gt;完整内容&lt;/h3&gt;
&lt;div&gt;以上就是播客节目纪要的翻译。更多完整的对话内容，以及对话音频，我已保存好了。你如果感兴趣的话，请在 &lt;strong&gt;Python猫&lt;/strong&gt; 公众号里发送数字“&lt;strong&gt;1030&lt;/strong&gt;”，即可获取下载链接。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>联合迭代器与生成器，这个内置函数真香！</title>
            <link>https://pythoncat.top/posts/2021-08-22-enumerate/</link>
            <guid>https://pythoncat.top/posts/2021-08-22-enumerate/</guid>
            <pubDate>Sun, 22 Aug 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 中很多内置函数的作用都非常大，比如说 enumerate() 和 zip()，它们使得我们在作迭代操作时极为顺手。这是一篇很多年前的 PEP，提议在 Python 2.3 版本中引入 enumerate()，该文档整合了其它几篇 PEP 的想法（包括当时新引入的迭代器与生成器），提出了更好的实现方案以及函数名。经过这么多年的发展，enumerate() 不可避免地有了一些变化，但不变的是，它跟 19 年前一样，还是很有必要、很好用，用着真香！&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP原文：&lt;/strong&gt; &lt;a href=&quot;https://www.python.org/dev/peps/pep-0279&quot;&gt;https://www.python.org/dev/peps/pep-0279&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP标题：&lt;/strong&gt; The enumerate() built-in function&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP作者：&lt;/strong&gt; Raymond Hettinger&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;创建日期：&lt;/strong&gt; 2002-06-30&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;合入版本：&lt;/strong&gt; 2.3&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt;：豌豆花下猫@Python猫&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP翻译计划&lt;/strong&gt;：&lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;https://github.com/chinesehuazhou/peps-cn&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;摘要&lt;/h2&gt;
&lt;div&gt;本 PEP 引进了一个新的内置函数 enumerate() 来简化常用的循环写法。它为所有的可迭代对象赋能，作用就像字典的 iteritems() 那样——一种紧凑、可读、可靠的索引表示法。&lt;/div&gt;
&lt;h2&gt;基本原理&lt;/h2&gt;
&lt;div&gt;Python 2.2 在 PEP 234[3] 中提出了可迭代对象接口的概念。iter() 工厂函数作为一种通用的调用约定而被提出，深入修改了迭代器的使用方式，作为整个 Python 的统一规范。这种统一的规范就是为映射类型、序列类型和文件对象建立一个通用的可迭代对象接口。&lt;/div&gt;
&lt;div&gt;PEP 255[1] 中提出的生成器是作为一种更容易创建迭代器的方法引入的，特别是具有复杂的内部执行过程或变量状态的迭代器。有了生成器以后，PEP 212[2] 中关于循环的计数器的想法就有可能改进了。&lt;/div&gt;
&lt;div&gt;那些想法是提供一种干净的迭代语法，带有索引和值，但不适用于所有的可迭代对象。而且，那种方法没有生成器提供的内存友好的优点（生成器不会一次性计算整个序列）。&lt;/div&gt;
&lt;div&gt;（Python猫注：关于生成器的 PEP 也有翻译，请查看 &lt;a href=&quot;https://mp.weixin.qq.com/s/vjQLlmH5QV-zAre7tVCxSA&quot;&gt;PEP-255&lt;/a&gt;、&lt;a href=&quot;https://mp.weixin.qq.com/s/M79svUpskZQz15SxEfIWbQ&quot;&gt;PEP-342&lt;/a&gt;、&lt;a href=&quot;https://mp.weixin.qq.com/s/bbfeKZesZZDsioX6X-H_mg&quot;&gt;PEP-380&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;新的提议是添加一个内置函数 enumerate()，在有了迭代器和生成器以后，它就可以实现。它为所有的可迭代对象赋能，作用就像字典的 iteritems() 那样——一种紧凑、可读、可靠的索引表示法。像 zip() 一样，它有望成为一种常用的循环习语（idiom）。&lt;/div&gt;
&lt;div&gt;（Python猫注：zip() 函数非常强，推荐阅读《&lt;a href=&quot;https://mp.weixin.qq.com/s/MXVUxndXEPq5EZ4o66mdyQ&quot;&gt;一篇文章掌握 Python 内置 zip() 的全部内容&lt;/a&gt;》）&lt;/div&gt;
&lt;div&gt;这一提议的目的是利用现有的实现，再加一点点的努力来整合。它是向后兼容的，不需要新的关键字。本提案将合入 Python 2.3，不需要从 __future__ 中导入。&lt;/div&gt;
&lt;h2&gt;新内置函数的规范&lt;/h2&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;enumerate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;collection&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
   &lt;span&gt;&apos;Generates an indexed series:  (0,coll[0]), (1,coll[1]) ...&apos;&lt;/span&gt;
   i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
   it &lt;span&gt;=&lt;/span&gt; &lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;collection&lt;span&gt;)&lt;/span&gt;
   &lt;span&gt;while&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
      &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt; it&lt;span&gt;.&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
      i &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;注A&lt;/strong&gt; ：PEP 212 循环计数器迭代[2]讨论了几个实现索引的提议。有些提议只适用于列表，不像上面的函数适用于任意生成器、xrange、序列或可迭代对象。&lt;/div&gt;
&lt;div&gt;另外，那些提议是在 Python 2.2 之前提出并评估的，但是 Python 2.2 没有包含生成器。因此，PEP 212 中的非生成器版本有一个缺点，即会用一个巨大的元组列表，导致消耗太多内存。&lt;/div&gt;
&lt;div&gt;这里提供的生成器版本快速且轻便，适用于所有可迭代对象，并允许用户在不浪费计算量的情况下中途放弃。&lt;/div&gt;
&lt;div&gt;还有一些涉及相关问题的 PEP：整型迭代器、整型 for 循环，以及一个修改 range 和 xrange 的参数的 PEP。enumerate() 提案并不排斥其它提案，即使那些提案被采纳，它仍然满足一个重要的需求——对任意可迭代对象中的元素进行计数的需求。&lt;/div&gt;
&lt;div&gt;其它的提案给出了一种产生索引的方法，但没有相应的值。如果给定的序列不支持随机访问，比如文件对象、生成器或用__getitem__定义的序列，这就特别成问题。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;注B&lt;/strong&gt; ：几乎所有的 PEP 审阅人都欢迎这个函数，但对于“是否应该把它作为内置函数”&lt;/div&gt;
&lt;div&gt;存在分歧。一方提议使用独立的模块，主要理由是减缓语言膨胀的速度。&lt;/div&gt;
&lt;div&gt;另一方提议使用内置函数，主要理由是该函数符合 Python 核心编程风格，适用于任何具有可迭代接口的对象。正如 zip() 解决了在多个序列上循环的问题，enumerate() 函数解决了循环计数器的问题。&lt;/div&gt;
&lt;div&gt;如果只允许加一个内置函数，那么 enumerate() 就是最重要的通用工具，可以解决最广泛的问题，同时提高程序的简洁性、清晰度和可靠性。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;注C&lt;/strong&gt; ：讨论了多种备选名称：&lt;/div&gt;













































&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数名&lt;/th&gt;&lt;th&gt;分析&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;iterindexed()&lt;/td&gt;&lt;td&gt;五个音节太拗口了&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;index()&lt;/td&gt;&lt;td&gt;很好的动词，但是可能会跟 .index () 方法混淆&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;indexed()&lt;/td&gt;&lt;td&gt;很受欢迎，但是应该避免形容词&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;indexer()&lt;/td&gt;&lt;td&gt;在 for 循环中，名词读起来不太好&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;count()&lt;/td&gt;&lt;td&gt;直接而明确，但常用于其它语境&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;itercount()&lt;/td&gt;&lt;td&gt;直接、明确，但被不止一个人讨厌&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;iteritems()&lt;/td&gt;&lt;td&gt;与字典的 key:value 概念冲突&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;itemize()&lt;/td&gt;&lt;td&gt;让人困惑，因为 amap.items() != list(itemize(amap))&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;enum()&lt;/td&gt;&lt;td&gt;简练；不及enumerate 清楚；与其它语言中的枚举太相似，但有着不同的含义&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;div&gt;所有涉及“count”的名称还有一个缺点，即隐含着计数是从 1 开始而不是从 0 开始的意思。&lt;/div&gt;
&lt;div&gt;所有涉及“index”的名称与数据库语言的用法冲突，数据库的索引表示一种排序操作，但不是线性排序。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;注D：&lt;/strong&gt; 在最初的提案中，这个函数带有可选的 start 和 stop 参数。GvR 指出，函数enumerate(seqn,4,6) 还有一种看似合理的解释，即返回序列的第 4 和第 5 个元素的切片。为了避免歧义，这两个可选参数被摘掉了，尽管这意味着循环计数器失去了部分的灵活性。&lt;/div&gt;
&lt;div&gt;在从 1 开始计数的常见用例中，这种可选参数的写法很有用，比如：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; linenum&lt;span&gt;,&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; &lt;span&gt;enumerate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;source&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt; linenum&lt;span&gt;,&lt;/span&gt; line&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;（Python猫注：这篇文档说 enumerate 没有起止参数，然而，在后续版本中（例如我用的 3.9），它支持使用一个可选的 start 参数！我暂未查到这个变更是在何时加入的，如有知情者，烦请告知我，以便修正！）&lt;/div&gt;
&lt;div&gt;GvR 评论道：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;filter 和 map 应该 die，被纳入列表推导式，不增加更多的变体。我宁可引进做迭代器运算的内置函数（例如 iterzip，我经常举的例子）。
我认可用某种方法并行地遍历序列及其索引的想法。把它作为一个内置函数，没有问题。
我不喜欢“indexed”这个名字；形容词不是好的函数名。可以用 iterindexed() ?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;Ka-Ping Yee 评论道：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;我对你的提议也很满意……新增的内置函数（倾向于用“indexed”）是我期盼了很久的东西。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;Neil Schemenauer 评论道：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;新的内置函数听起来不错。Guido 可能会担心增加太多内置对象。你最好把它们作为某个模块的一部分。如果你用模块的话，那么你可以添加很多有用的函数（Haskell 有很多，我们可以去“偷”）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;Magnus Lie Hetland 评论道：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;我认为 indexed 会是一个有用和自然的内置函数。我肯定会经常使用它。
我非常喜欢 indexed()；+1。 很高兴它淘汰了 PEP-281。为迭代器添加一个单独的模块似乎是个好主意。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;来自社区的反馈：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;对于 enumerate() 提案，几乎 100% 赞成。几乎所有人都喜欢这个想法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;作者的注释：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;在这些评论之前，共有四种内置函数被提出来。经过评论之后，xmap、xfilter 和 xzip 被撤销了。剩下的一个对 Python 来说是至关重要的。Indexed() 非常容易实现，并且立马就可以写进文档。更重要的是，它在日常编程中很有用，如果不用它，就需要显式地使用生成器。
这个提案最初包含了另一个函数 iterzip()。但之后在 itertools 模块中实现成了一个 izip() 函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;参考材料&lt;/h2&gt;
&lt;div&gt;1、PEP 255 Simple Generators &lt;a href=&quot;http://www.python.org/dev/peps/pep-0255&quot;&gt;http://www.python.org/dev/peps/pep-0255&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;2、(1, 2) PEP 212 Loop Counter Iteration &lt;a href=&quot;http://www.python.org/dev/peps/pep-0212&quot;&gt;http://www.python.org/dev/peps/pep-0212&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;3、PEP 234 Iterators &lt;a href=&quot;http://www.python.org/dev/peps/pep-0234&quot;&gt;http://www.python.org/dev/peps/pep-0234&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;版权&lt;/h2&gt;
&lt;div&gt;本文档已经进入公共领域。源文档：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/python/peps/blob/master/pep-0279.txt&quot;&gt;https://github.com/python/peps/blob/master/pep-0279.txt&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 列表解析式竟然支持异步？</title>
            <link>https://pythoncat.top/posts/2021-08-11-aysn/</link>
            <guid>https://pythoncat.top/posts/2021-08-11-aysn/</guid>
            <pubDate>Wed, 11 Aug 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;PEP原文：&lt;a href=&quot;https://www.python.org/dev/peps/pep-0530&quot;&gt;https://www.python.org/dev/peps/pep-0530&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PEP标题：PEP 530 — Asynchronous Comprehensions&lt;/div&gt;
&lt;div&gt;PEP作者：Yury Selivanov&lt;/div&gt;
&lt;div&gt;创建日期：2016-09-03&lt;/div&gt;
&lt;div&gt;合入版本：3.6&lt;/div&gt;
&lt;div&gt;译者：豌豆花下猫@Python猫&lt;/div&gt;
&lt;div&gt;PEP翻译计划：&lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;https://github.com/chinesehuazhou/peps-cn&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;摘要&lt;/h2&gt;
&lt;div&gt;PEP-492 和 PEP-525 通过 async/await 语法，引入了对原生协程和异步生成器的支持。本 pep 提议给列表、集合、字典解析式和生成器表达式添加异步的版本。&lt;/div&gt;
&lt;h2&gt;基本原理和目标&lt;/h2&gt;
&lt;div&gt;Python 广泛地支持同步的推导式，允许使用简单而简洁的语法生成列表、字典和集合。我们提议为异步代码实现类似的语法结构。&lt;/div&gt;
&lt;div&gt;为了说明可读性的改善，请考虑下面的例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;async&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; aiter&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; i &lt;span&gt;%&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        result&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;有了提议的异步解析式语法，上面的代码会变得非常简短：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;i &lt;span&gt;async&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; aiter&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; i &lt;span&gt;%&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;本 PEP 也使得在各种解析式中使用 await 表达式成为可能：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; fun&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; fun &lt;span&gt;in&lt;/span&gt; funcs&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;规范&lt;/h2&gt;
&lt;h3&gt;异步的解析式&lt;/h3&gt;
&lt;div&gt;我们提议允许在列表、集合与字典解析式中使用 async。待 PEP-525 被批准之后，我们还可以创建异步的生成器表达式。&lt;/div&gt;
&lt;div&gt;例子：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;集合解析式：{i async for i in agen()}&lt;/li&gt;
&lt;li&gt;列表解析式：[i async for i in agen()]&lt;/li&gt;
&lt;li&gt;字典解析式：{i: i ** 2 async for i in agen()}&lt;/li&gt;
&lt;li&gt;生成器表达式：(i ** 2 async for i in agen())&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;允许在异步解析式和生成器表达式中使用 async for 与 if 以及 for 子句：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;dataset &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;data &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; aiter&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;async&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; data &lt;span&gt;in&lt;/span&gt; line
                &lt;span&gt;if&lt;/span&gt; check&lt;span&gt;(&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
data &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;data &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; aiter&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; data &lt;span&gt;in&lt;/span&gt; line &lt;span&gt;if&lt;/span&gt; check&lt;span&gt;(&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;异步解析式只允许在“async def”函数中使用。&lt;/div&gt;
&lt;div&gt;原则上，异步生成器表达式允许用在任何上下文中。然而，在 Python 3.6 中，由于 async 和 await 只是“软关键字”（soft-keyword），异步生成器表达式只允许在 async def 函数中使用。一旦 async 和 await 在 Python 3.7 中成为保留关键字，这个限制将被移除。&lt;/div&gt;
&lt;h3&gt;解析式中的 await&lt;/h3&gt;
&lt;div&gt;我们提议允许在异步和同步解析式中使用 await 表达式：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; fun&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; fun &lt;span&gt;in&lt;/span&gt; funcs&lt;span&gt;]&lt;/span&gt;
result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; fun&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; fun &lt;span&gt;in&lt;/span&gt; funcs&lt;span&gt;}&lt;/span&gt;
result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;fun&lt;span&gt;:&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; fun&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; fun &lt;span&gt;in&lt;/span&gt; funcs&lt;span&gt;}&lt;/span&gt;

result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; fun&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; fun &lt;span&gt;in&lt;/span&gt; funcs &lt;span&gt;if&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; smth&lt;span&gt;]&lt;/span&gt;
result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; fun&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; fun &lt;span&gt;in&lt;/span&gt; funcs &lt;span&gt;if&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; smth&lt;span&gt;}&lt;/span&gt;
result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;fun&lt;span&gt;:&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; fun&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; fun &lt;span&gt;in&lt;/span&gt; funcs &lt;span&gt;if&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; smth&lt;span&gt;}&lt;/span&gt;

result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; fun&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; fun &lt;span&gt;in&lt;/span&gt; funcs&lt;span&gt;]&lt;/span&gt;
result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; fun&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; fun &lt;span&gt;in&lt;/span&gt; funcs&lt;span&gt;}&lt;/span&gt;
result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;fun&lt;span&gt;:&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; fun&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; fun &lt;span&gt;in&lt;/span&gt; funcs&lt;span&gt;}&lt;/span&gt;

result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; fun&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; fun &lt;span&gt;in&lt;/span&gt; funcs &lt;span&gt;if&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; smth&lt;span&gt;]&lt;/span&gt;
result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; fun&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; fun &lt;span&gt;in&lt;/span&gt; funcs &lt;span&gt;if&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; smth&lt;span&gt;}&lt;/span&gt;
result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;fun&lt;span&gt;:&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; fun&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; fun &lt;span&gt;in&lt;/span&gt; funcs &lt;span&gt;if&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; smth&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这只在 async def 函数体中有效。&lt;/div&gt;
&lt;h3&gt;语法的更新&lt;/h3&gt;
&lt;div&gt;本提议需要在语法层面做一个修改：在 comp_for 中添加可选的“async”关键字：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;comp_for&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;ASYNC&lt;span&gt;]&lt;/span&gt; &lt;span&gt;&apos;for&apos;&lt;/span&gt; exprlist &lt;span&gt;&apos;in&apos;&lt;/span&gt; or_test &lt;span&gt;[&lt;/span&gt;comp_iter&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;解析式的 AST 节点将有一个新的 is_async 参数。&lt;/div&gt;
&lt;h2&gt;向后兼容性&lt;/h2&gt;
&lt;div&gt;本提案是完全向后兼容的。&lt;/div&gt;
&lt;h2&gt;接受&lt;/h2&gt;
&lt;div&gt;在 2016 年 9 月 6 日[1]，PEP-530 被 Guido 接受。&lt;/div&gt;
&lt;h2&gt;参考材料&lt;/h2&gt;
&lt;div&gt;1、 &lt;a href=&quot;https://mail.python.org/pipermail/python-ideas/2016-September/042141.html&quot;&gt;https://mail.python.org/pipermail/python-ideas/2016-September/042141.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://github.com/1st1/cpython/tree/asyncomp&quot;&gt;https://github.com/1st1/cpython/tree/asyncomp&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;http://bugs.python.org/issue28008&quot;&gt;http://bugs.python.org/issue28008&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;致谢&lt;/h2&gt;
&lt;div&gt;感谢 Guido van Rossum、Victor Stinner 和 Elvis pranskevichuss 对于这个 pep 的反馈、代码检视和讨论。&lt;/div&gt;
&lt;h2&gt;版权&lt;/h2&gt;
&lt;div&gt;本文档已进入公共领域。&lt;/div&gt;
&lt;div&gt;源文件：&lt;a href=&quot;https://github.com/python/peps/blob/master/pep-0530.txt&quot;&gt;https://github.com/python/peps/blob/master/pep-0530.txt&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 数值中的下划线是怎么回事？</title>
            <link>https://pythoncat.top/posts/2021-08-01-number/</link>
            <guid>https://pythoncat.top/posts/2021-08-01-number/</guid>
            <description>Python 中下划线的用法令人叹为观止，相信你已在各种文章或教程中见识过了。在 2016 年的 3.6 版本之后，Python 还引入了一种新的语法，使得下划线也可以出现在数值中</description>
            <pubDate>Sun, 01 Aug 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;PEP原文：&lt;a href=&quot;https://www.python.org/dev/peps/pep-0515&quot;&gt;PEP 515 — Underscores in Numeric Literals&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PEP作者：Guido van Rossum, Nick Coghlan&lt;/div&gt;
&lt;div&gt;创建日期：Georg Brandl, Serhiy Storchaka&lt;/div&gt;
&lt;div&gt;合入版本：3.6&lt;/div&gt;
&lt;div&gt;译者：豌豆花下猫@Python猫&lt;/div&gt;
&lt;div&gt;PEP翻译计划：&lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;https://github.com/chinesehuazhou/peps-cn&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;概要和原理&lt;/h2&gt;
&lt;div&gt;本 PEP 提议扩展 Python 的语法，使得在“字符串变成数”（number-from-string）构造器中，下划线可以作为视觉分隔符，对整数、浮点和复数字面量的数字进行分组。&lt;/div&gt;
&lt;div&gt;（Python猫注：关于 Python 的数值类型，可以查看 &lt;a href=&quot;https://mp.weixin.qq.com/s/0XpPaH53II5yO9Lfh80ZOw&quot;&gt;PEP-314&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;这是其它现代语言的一个常见特性，有助于理解长的或者值应该被直观地分成几部分的字面量，如十六进制表示法中的字节或单词。&lt;/div&gt;
&lt;div&gt;例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# grouping decimal numbers by thousands&lt;/span&gt;
amount &lt;span&gt;=&lt;/span&gt; &lt;span&gt;10_000_000.0&lt;/span&gt;

&lt;span&gt;# grouping hexadecimal addresses by words&lt;/span&gt;
addr &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0xCAFE_F00D&lt;/span&gt;

&lt;span&gt;# grouping bits into nibbles in a binary literal&lt;/span&gt;
flags &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0b_0011_1111_0100_1110&lt;/span&gt;

&lt;span&gt;# same, for string conversions&lt;/span&gt;
flags &lt;span&gt;=&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;0b_1111_0000&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;规范&lt;/h2&gt;
&lt;div&gt;目前的提议是在数字之间和在数字字面量的基本标识符之后，允许有一个下划线。下划线没有语义上的意义，数字字面量会被解析得就像没有下划线一样。&lt;/div&gt;
&lt;h3&gt;字面量语法&lt;/h3&gt;
&lt;div&gt;因此，整型字面量的表示法看起来像这样：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;integer&lt;span&gt;:&lt;/span&gt; decinteger &lt;span&gt;|&lt;/span&gt; bininteger &lt;span&gt;|&lt;/span&gt; octinteger &lt;span&gt;|&lt;/span&gt; hexinteger
decinteger&lt;span&gt;:&lt;/span&gt; nonzerodigit &lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;_&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; digit&lt;span&gt;)&lt;/span&gt;&lt;span&gt;*&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;&quot;0&quot;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;_&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;&quot;0&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;
bininteger&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;0&quot;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;b&quot;&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;&quot;B&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;_&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; bindigit&lt;span&gt;)&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;
octinteger&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;0&quot;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;o&quot;&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;&quot;O&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;_&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; octdigit&lt;span&gt;)&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;
hexinteger&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;0&quot;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;x&quot;&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;&quot;X&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;_&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; hexdigit&lt;span&gt;)&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;
nonzerodigit&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;1&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;9&quot;&lt;/span&gt;
digit&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;0&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;9&quot;&lt;/span&gt;
bindigit&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;0&quot;&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;&quot;1&quot;&lt;/span&gt;
octdigit&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;0&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;7&quot;&lt;/span&gt;
hexdigit&lt;span&gt;:&lt;/span&gt; digit &lt;span&gt;|&lt;/span&gt; &lt;span&gt;&quot;a&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;f&quot;&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;&quot;A&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;F&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;浮点数和复数的字面量：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;floatnumber&lt;span&gt;:&lt;/span&gt; pointfloat &lt;span&gt;|&lt;/span&gt; exponentfloat
pointfloat&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;digitpart&lt;span&gt;]&lt;/span&gt; fraction &lt;span&gt;|&lt;/span&gt; digitpart &lt;span&gt;&quot;.&quot;&lt;/span&gt;
exponentfloat&lt;span&gt;:&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;digitpart &lt;span&gt;|&lt;/span&gt; pointfloat&lt;span&gt;)&lt;/span&gt; exponent
digitpart&lt;span&gt;:&lt;/span&gt; digit &lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;_&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; digit&lt;span&gt;)&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;
fraction&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;.&quot;&lt;/span&gt; digitpart
exponent&lt;span&gt;:&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;e&quot;&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;&quot;E&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;+&quot;&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;&quot;-&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; digitpart
imagnumber&lt;span&gt;:&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;floatnumber &lt;span&gt;|&lt;/span&gt; digitpart&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;j&quot;&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;&quot;J&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;构造函数&lt;/h3&gt;
&lt;div&gt;遵循相同的放置规则，下划线可以在以下构造函数中使用：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;int()（任意进制）&lt;/li&gt;
&lt;li&gt;float()&lt;/li&gt;
&lt;li&gt;complex()&lt;/li&gt;
&lt;li&gt;Decimal()&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;进一步的变更&lt;/h3&gt;
&lt;div&gt;新式的数字转字符串（number-to-string）格式化语法将被扩展，允许 _ 作为千位分隔符。这可以用更具可读性的字面量来轻松地生成代码。[11]&lt;/div&gt;
&lt;div&gt;The syntax would be the same as for the comma, e.g. {:10_} for a width of 10 with _ separator.（这句没看懂…不译）&lt;/div&gt;
&lt;div&gt;对于 b、x 和 o 格式符，_ 也将支持，并按 4 位数分组。&lt;/div&gt;
&lt;h2&gt;现有的技术&lt;/h2&gt;
&lt;div&gt;那些允许下划线分组的语言，实现了大量放置下划线的规则。在语言规范与实际行为相矛盾的情况下，以下会列出实际的行为。(“单个”或“多个”指的是允许多少连续的下划线。)&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Ada：单个，仅在数字间 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0515/#id21&quot;&gt;[8]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;C# （7.0 版本的提案）：多个，仅在数字间 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0515/#id19&quot;&gt;[6]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;C++14：单个，在数字之间（选了其它分隔符） &lt;a href=&quot;https://www.python.org/dev/peps/pep-0515/#id14&quot;&gt;[1]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;D：多个，任意位置，包括末尾 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0515/#id15&quot;&gt;[2]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Java：多个，仅在数字间 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0515/#id20&quot;&gt;[7]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Julia：单个，仅在数字间（但不含浮点指数部分） &lt;a href=&quot;https://www.python.org/dev/peps/pep-0515/#id22&quot;&gt;[9]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Perl 5：多个，基本是任意位置，尽管文档说数字间限制 1 个下划线 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0515/#id16&quot;&gt;[3]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Ruby：单个，仅在数字间（尽管文档说“任意位置”）&lt;a href=&quot;https://www.python.org/dev/peps/pep-0515/#id23&quot;&gt;[10]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Rust：多个，任意位置，除了指数“e”与数字间 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0515/#id17&quot;&gt;[4]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Swift：多个，数字之间和末尾（尽管文档说仅在“数字之间”） &lt;a href=&quot;https://www.python.org/dev/peps/pep-0515/#id18&quot;&gt;[5]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;被否决的语法&lt;/h2&gt;
&lt;div&gt;（Python猫注：每个 PEP 在初提出阶段，都可能引起很多关于语法设计的讨论，在正式采纳的 PEP 中，一般会保留一些有代表性的被否决的方案，例如下面的两项）&lt;/div&gt;
&lt;h3&gt;1、下划线的放置规则&lt;/h3&gt;
&lt;div&gt;减少下划线的使用限制，而不是上面声明的相对严格的规则。在其它语言中，常见的规则包括：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;只允许一个连续的下划线，并且只能在数字之间。&lt;/li&gt;
&lt;li&gt;允许多个连续的下划线，但只能在数字之间。&lt;/li&gt;
&lt;li&gt;允许多个连续的下划线，在大多数位置，除了字面量的开头，或特殊的位置（例如小数点后）。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;本 PEP 中的语法最终被选中，因为它涵盖了常见的用例，并且不会出现被 Python 风格指南所不鼓励使用的语法。&lt;/div&gt;
&lt;div&gt;一个不太常见的规则是只允许每 N 位数字有下划线（其中 N 可能是 3 个十进制字面量，或 4 个十六进制字面量）。这是不必要的限制，特别是考虑到这些分隔符位置在不同的文化中是不同的。（Python猫注：例如，我们国家习惯将 4 个数字分为一组，即 10000 是 1 万，而不是英语文化中的 10 thousand）&lt;/div&gt;
&lt;h3&gt;2、其它的分隔符&lt;/h3&gt;
&lt;div&gt;还有一种建议是使用空格进行分组。虽然字符串是一种结合相邻字面量的先例，但这种行为可能会导致意外的效果，而下划线则不会。而且，除了那些基本会忽略任何空格的语言外，没有其它语言使用此规则。&lt;/div&gt;
&lt;div&gt;c++ 14 引入了单引号来进行分组（因为下划线会与用户定义的字面量产生歧义），由于单引号已经被 Python 的字符串字面量使用了，所以没有考虑它。［1］&lt;/div&gt;
&lt;h2&gt;实现&lt;/h2&gt;
&lt;div&gt;实现上述规范的初步补丁已经发布到问题跟踪器。&lt;a href=&quot;https://www.python.org/dev/peps/pep-0515/#id25&quot;&gt;[12]&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;参考内容&lt;/h2&gt;
&lt;div&gt;[1] (1, 2) &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3499.html&quot;&gt;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3499.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[2] &lt;a href=&quot;https://dlang.org/spec/lex.html#integerliteral&quot;&gt;https://dlang.org/spec/lex.html#integerliteral&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[3] &lt;a href=&quot;https://perldoc.perl.org/perldata#Scalar-value-constructors&quot;&gt;https://perldoc.perl.org/perldata#Scalar-value-constructors&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[4] &lt;a href=&quot;https://web.archive.org/web/20160304121349/http://doc.rust-lang.org/reference.html#integer-literals&quot;&gt;https://web.archive.org/web/20160304121349/http://doc.rust-lang.org/reference.html#integer-literals&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[5] &lt;a href=&quot;https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html&quot;&gt;https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[6] &lt;a href=&quot;https://github.com/dotnet/roslyn/issues/216&quot;&gt;https://github.com/dotnet/roslyn/issues/216&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[7] &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/language/underscores-literals.html&quot;&gt;https://docs.oracle.com/javase/7/docs/technotes/guides/language/underscores-literals.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[8] &lt;a href=&quot;http://archive.adaic.com/standards/83lrm/html/lrm-02-04.html#2.4&quot;&gt;http://archive.adaic.com/standards/83lrm/html/lrm-02-04.html#2.4&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[9] &lt;a href=&quot;https://web.archive.org/web/20160223175334/http://docs.julialang.org/en/release-0.4/manual/integers-and-floating-point-numbers/&quot;&gt;https://web.archive.org/web/20160223175334/http://docs.julialang.org/en/release-0.4/manual/integers-and-floating-point-numbers/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[10] &lt;a href=&quot;https://ruby-doc.org/core-2.3.0/doc/syntax/literals_rdoc.html#label-Numbers&quot;&gt;https://ruby-doc.org/core-2.3.0/doc/syntax/literals_rdoc.html#label-Numbers&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[11] &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2016-February/143283.html&quot;&gt;https://mail.python.org/pipermail/python-dev/2016-February/143283.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[12] &lt;a href=&quot;http://bugs.python.org/issue26331&quot;&gt;http://bugs.python.org/issue26331&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;版权&lt;/h2&gt;
&lt;div&gt;该文档已放入公共领域。&lt;/div&gt;
&lt;div&gt;源文件：&lt;a href=&quot;https://github.com/python/peps/blob/master/pep-0515.txt&quot;&gt;https://github.com/python/peps/blob/master/pep-0515.txt&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 的上下文管理器是怎么设计的？</title>
            <link>https://pythoncat.top/posts/2021-07-14-with/</link>
            <guid>https://pythoncat.top/posts/2021-07-14-with/</guid>
            <pubDate>Wed, 14 Jul 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;最近，我在看 Python 3.10 版本的更新内容时，发现有一个关于上下文管理器的小更新，然后，突然发现上下文管理器的设计 PEP 竟然还没人翻译过！于是，我断断续续花了两周时间，终于把这篇 PEP 翻译出来了。如果你不了解什么是 PEP，可以先查看这篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/oRoBxZ2-IyuPOf_MWyKZyw&quot;&gt;学习Python，怎能不懂点PEP呢？&lt;/a&gt;》，如果你也对翻译 PEP 感兴趣，欢迎加入 Github 上的 &lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;peps-cn&lt;/a&gt; 项目。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP原文 ：&lt;/strong&gt; &lt;a href=&quot;https://www.python.org/dev/peps/pep-0343/&quot;&gt;https://www.python.org/dev/peps/pep-0343&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP标题：&lt;/strong&gt; PEP 343 — The “with” Statement&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP作者：&lt;/strong&gt; Guido van Rossum, Nick Coghlan&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;创建日期：&lt;/strong&gt; 2005-05-13&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;合入版本：&lt;/strong&gt; 2.5&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; ：豌豆花下猫@Python猫公众号&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP翻译计划&lt;/strong&gt; ：&lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;https://github.com/chinesehuazhou/peps-cn&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;摘要&lt;/h2&gt;
&lt;div&gt;本 PEP 提议在 Python 中新增一种”with”语句，可以取代常规的 try/finally 语句。&lt;/div&gt;
&lt;div&gt;在本 PEP 中，上下文管理器提供__enter__() 和 __exit__() 方法，在进入和退出 with 语句体时，这俩方法分别会被调用。&lt;/div&gt;
&lt;h2&gt;作者的批注&lt;/h2&gt;
&lt;div&gt;本 PEP 最初由 Guido 以第一人称编写，随后由 Nick Coghlan 根据 python-dev 上的讨论，做出了更新补充。所有第一人称的内容都出自于 Guido 的原文。&lt;/div&gt;
&lt;div&gt;Python 的 alpha 版本发布周期暴露了本 PEP 以及相关文档和实现[14]中的术语问题。直到 Python 2.5 的第一个 beta 版本发布时，本 PEP 才稳定下来。&lt;/div&gt;
&lt;div&gt;是的，本文某些地方的动词时态是混乱的。到现在为止，我们已经创作此 PEP 一年多了，所以，有些原本在未来的事情，现在已经成为过去了:)&lt;/div&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;div&gt;经过对 PEP-340 及其替代方案的大量讨论后，我决定撤销 PEP-340，并提出了 PEP-310 的一个小变种。经过更多的讨论后，我又添加了一种机制，可以使用 throw() 方法，在挂起的生成器中抛出异常，或者用一个 close() 方法抛出一个 GeneratorExitexception；这些想法最初是在 python-dev [2] 上提出的，并得到了普遍的认可。我还将关键字改为了“with”。&lt;/div&gt;
&lt;div&gt;（Python猫注：PEP-340 也是 Guido 写的，他最初用的关键字是“block”，后来改成了其它 PEP 提议的“with”。）&lt;/div&gt;
&lt;div&gt;在本 PEP 被接受后，以下 PEP 由于重叠而被拒绝：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;PEP-310，可靠的获取/释放对。这是 with 语句的原始提案。&lt;/li&gt;
&lt;li&gt;PEP-319，Python 同步/异步代码块。通过提供合适的 with 语句控制器，本 PEP 可以涵盖它的使用场景：对于’synchronize’，我们可以使用示例 1 中的”locking”模板；对于’asynchronize’，我们可以使用类似的”unlock”模板。我认为不必要给代码块加上“匿名的”锁；事实上，应该尽可能地使用明确的互斥锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;PEP-340 和 PEP-346 也与本 PEP 重叠，但当本 PEP 被提交时，它们就自行撤销了。&lt;/div&gt;
&lt;div&gt;关于本 PEP 早期版本的一些讨论，可以在 Python Wiki[3] 上查看。&lt;/div&gt;
&lt;h2&gt;动机与摘要&lt;/h2&gt;
&lt;div&gt;PEP-340（即匿名的 block 语句）包含了许多强大的创意：使用生成器作为代码块模板、给生成器添加异常处理和终结，等等。除了赞扬之外，它还被很多人所反对，他们不喜欢它是一个（潜在的）循环结构。这意味着块语句中的 break 和 continue 可以中断或继续块语句，即使它原本被当作非循环的资源管理工具。&lt;/div&gt;
&lt;div&gt;但是，直到我读了 Raymond Chen 对流量控制宏[1]的抨击时，PEP-340 才走入了末路。Raymond 令人信服地指出，在宏中藏有流程控制会让你的代码变得难以捉摸，我觉得他的论点不仅适用于 C，同样适用于 Python。我意识到，PEP-340 的模板可以隐藏各种控制流；例如，它的示例 4 （auto_retry()）捕获了异常，并将代码块重复三次。&lt;/div&gt;
&lt;div&gt;然而，在我看来，PEP-310 的 with 语句并没有隐藏控制流：虽然 finally 代码部分会暂时挂起控制流，但到了最后，控制流会恢复，就好像 finally 子句根本不存在一样。&lt;/div&gt;
&lt;div&gt;在 PEP-310 中，它大致提出了以下的语法（“VAR =“部分是可选的）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;with&lt;/span&gt; VAR &lt;span&gt;=&lt;/span&gt; EXPR&lt;span&gt;:&lt;/span&gt;
    BLOCK&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;大致可以理解为：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;VAR &lt;span&gt;=&lt;/span&gt; EXPR
VAR&lt;span&gt;.&lt;/span&gt;__enter__&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    BLOCK
&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    VAR&lt;span&gt;.&lt;/span&gt;__exit__&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;现在考虑这个例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;with&lt;/span&gt; f &lt;span&gt;=&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;/etc/passwd&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    BLOCK1
BLOCK2&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在上例中，第一行就像是一个“if True”，我们知道如果 BLOCK1 在执行时没有抛异常，那么 BLOCK2 将会被执行；如果 BLOCK1 抛出异常，或执行了非局部的 goto （即 break、continue 或 return），那么 BLOCK2 就不会被执行。也就是说，with 语句所加入的魔法并不会影响到这种流程逻辑。&lt;/div&gt;
&lt;div&gt;（你可能会问，如果__exit__() 方法因为 bug 导致抛异常怎么办？那么一切都完了——但这并不比其他情况更糟；异常的本质就是，它们可能发生在&lt;strong&gt;任何地方&lt;/strong&gt;，你只能接受这一点。即便你写的代码没有 bug，KeyboardInterrupt 异常仍然会导致程序在任意两个虚拟机操作码之间退出。）&lt;/div&gt;
&lt;div&gt;这个论点几乎让我采纳了 PEP-310，但是， PEP-340 还有一个亮点让我不忍放弃：使用生成器作为某些抽象化行为的“模板”，例如获取及释放一个锁，或者打开及关闭一个文件，这是一种很强大的想法，通过该 PEP 的例子就能看得出来。&lt;/div&gt;
&lt;div&gt;受到 Phillip Eby 对 PEP-340 的反提议（counter-proposal）的启发，我尝试创建一个装饰器，将合适的生成器转换为具有必要的__enter__() 和 __exit__() 方法的对象。我在这里遇到了一个障碍：虽然这对于锁的例子来说并不太难，但是对于打开文件的例子，却不可能做到这一点。我的想法是像这样定义模板：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;@contextmanager&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;opening&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;filename&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    f &lt;span&gt;=&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;filename&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;yield&lt;/span&gt; f
    &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        f&lt;span&gt;.&lt;/span&gt;close&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;并这样使用它：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;with&lt;/span&gt; f &lt;span&gt;=&lt;/span&gt; opening&lt;span&gt;(&lt;/span&gt;filename&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;read data &lt;span&gt;from&lt;/span&gt; f&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;问题是在 PEP-310 中，EXPR 的调用结果直接分配给 VAR，然后 VAR 的__exit__() 方法会在 BLOCK1 退出时被调用。但是这里，VAR 显然需要接收打开的文件，这意味着__exit__() 必须是文件对象的一个方法。&lt;/div&gt;
&lt;div&gt;虽然这可以使用代理类来解决，但会很别扭，同时我还意识到，只需做出一个小小的转变，就能轻轻松松地写出所需的装饰器：让 VAR 接收__enter__() 方法的调用结果，接着保存 EXPR 的值，以便最后调用它的__exit__() 方法。&lt;/div&gt;
&lt;div&gt;然后，装饰器可以返回一个包装器的实例，其__enter__() 方法调用生成器的 next() 方法，并返回 next() 所返回的值；包装器实例的__exit__() 方法再次调用 next()，但期望它抛出 StopIteration。（详细信息见下文的生成器装饰器部分。）&lt;/div&gt;
&lt;div&gt;因此，最后一个障碍便是 PEP-310 语法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;with&lt;/span&gt; VAR &lt;span&gt;=&lt;/span&gt; EXPR&lt;span&gt;:&lt;/span&gt;
    BLOCK1&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这是有欺骗性的，因为 VAR 不接收 EXPR 的值。借用 PEP-340 的语法，很容易改成：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;with&lt;/span&gt; EXPR &lt;span&gt;as&lt;/span&gt; VAR&lt;span&gt;:&lt;/span&gt;
    BLOCK1&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在其他的讨论中，人们真的很喜欢能够“看到”生成器中的异常，尽管仅仅是为了记日志；生成器不允许产生（yield）其它的值，因为 with 语句不应该作为循环使用（引发不同的异常是勉强可以接受的）。&lt;/div&gt;
&lt;div&gt;为了做到这点，我建议为生成器提供一个新的 throw() 方法，该方法以通常的方式接受 1 到 3 个参数（类型、值、回溯），表示一个异常，并在生成器挂起的地方抛出。&lt;/div&gt;
&lt;div&gt;一旦我们有了这个，下一步就是添加另一个生成器方法 close()，它用一个特殊的异常（即 GeneratorExit）调用 throw()，可以令生成器退出。有了这个，在生成器被当作垃圾回收时，可以让程序自动调用 close()。&lt;/div&gt;
&lt;div&gt;最后，我们可以允许在 try-finally 语句中使用 yield 语句，因为我们现在可以保证 finally 子句必定被执行。关于终结（finalization）的常见注意事项——进程可能会在没有终结任何对象的情况下突然被终止，而这些对象可能会因程序的周期或内存泄漏而永远存活（在 Python 的实现中，周期或内存泄漏会由 GC 妥善处理）。&lt;/div&gt;
&lt;div&gt;请注意，在使用完生成器对象后，我们不保证会立即执行 finally 子句，尽管在 CPython 中是这样实现的。这类似于自动关闭文件：像 CPython 这样的引用计数型解释器，它会在最后一个引用消失时释放一个对象，而使用其他 GC 算法的解释器不保证也是如此。这指的是 Jython、IronPython，可能包括运行在 Parrot 上的 Python。&lt;/div&gt;
&lt;div&gt;（关于对生成器所做的更改，可以在 PEP-342 中找到细节，而不是在当前 PEP 中。）&lt;/div&gt;
&lt;h2&gt;用例&lt;/h2&gt;
&lt;div&gt;请参阅文档末尾的示例部分。&lt;/div&gt;
&lt;h2&gt;规格说明：‘with’语句&lt;/h2&gt;
&lt;div&gt;提出了一种新的语句，语法如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;with&lt;/span&gt; EXPR &lt;span&gt;as&lt;/span&gt; VAR&lt;span&gt;:&lt;/span&gt;
    BLOCK&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在这里，“with”和“as”是新的关键字；EXPR 是任意一个表达式（但不是表达式列表），VAR 是一个单一的赋值目标。它不能是以逗号分隔的变量序列，但可以是以圆括号包裹的以逗号分隔的变量序列。（这个限制使得将来的语法扩展可以出现多个逗号分隔的资源，每个资源都有自己的可选 as 子句。）&lt;/div&gt;
&lt;div&gt;“as VAR”部分是可选的。&lt;/div&gt;
&lt;div&gt;上述语句可以被翻译为:&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;mgr &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;EXPR&lt;span&gt;)&lt;/span&gt;
exit &lt;span&gt;=&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mgr&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;__exit__  &lt;span&gt;# Not calling it yet&lt;/span&gt;
value &lt;span&gt;=&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mgr&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;__enter__&lt;span&gt;(&lt;/span&gt;mgr&lt;span&gt;)&lt;/span&gt;
exc &lt;span&gt;=&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        VAR &lt;span&gt;=&lt;/span&gt; value  &lt;span&gt;# Only if &quot;as VAR&quot; is present&lt;/span&gt;
        BLOCK
    &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;# The exceptional case is handled here&lt;/span&gt;
        exc &lt;span&gt;=&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; exit&lt;span&gt;(&lt;/span&gt;mgr&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;sys&lt;span&gt;.&lt;/span&gt;exc_info&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;raise&lt;/span&gt;
        &lt;span&gt;# The exception is swallowed if exit() returns true&lt;/span&gt;
&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;# The normal and non-local-goto cases are handled here&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; exc&lt;span&gt;:&lt;/span&gt;
        exit&lt;span&gt;(&lt;/span&gt;mgr&lt;span&gt;,&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在这里，小写变量（mgr、exit、value、exc）是内部变量，用户不能访问；它们很可能是由特殊的寄存器或堆栈位置来实现。&lt;/div&gt;
&lt;div&gt;上述详细的翻译旨在说明确切的语义。解释器会按照顺序查找相关的方法（__exit__、__enter__），如果没有找到，将引发 AttributeError。类似地，如果任何一个调用引发了异常，其效果与上述代码中的效果完全相同。&lt;/div&gt;
&lt;div&gt;最后，如果 BLOCK 包含 break、continue 或 return 语句，__exit__() 方法就会被调用，带三个 None 参数，就跟 BLOCK 正常执行完成一样。（也就是说，__exit__() 不会将这些“伪异常”视为异常。）&lt;/div&gt;
&lt;div&gt;如果语法中的”as VAR”部分被省略了，则翻译中的”VAR =“部分也要被忽略（但 mgr.__enter__() 仍然会被调用）。&lt;/div&gt;
&lt;div&gt;mgr.__exit__() 的调用约定如下。如果 finally 子句是通过 BLOCK 的正常完成或通过非局部 goto（即 BLOCK 中的 break、continue 或 return 语句）到达，则使用三个 None 参数调用mgr.__exit__()。如果 finally 子句是通过 BLOCK 引发的异常到达，则使用异常的类型、值和回溯这三个参数调用 mgr.__exit__()。&lt;/div&gt;
&lt;div&gt;重要：如果 mgr.__exit__() 返回“true”，则异常将被“吞灭”。也就是说，如果返回”true”，即便在 with 语句内部发生了异常，也会继续执行 with 语句之后的下一条语句。然而，如果 with 语句通过非局部 goto （break、continue 或 return）跳出，则这个非局部返回将被重置，不管 mgr.__exit__() 的返回值是什么。这个细节的动机是使 mgr.__exit__() 能够吞咽异常，而不使异常产生影响（因为默认的返回值 None为 false，这会导致异常被重新 raise）。吞下异常的主要用途是使编写 @contextmanager 装饰器成为可能，这样被装饰的生成器中的 try/except 代码块的行为就好像生成器的主体在 with-语句里内联展开了一样。&lt;/div&gt;
&lt;div&gt;之所以将异常的细节传给__exit__()，而不用 PEP -310 中不带参数的__exit__()，原因是考虑到下面例子 3 的 transactional()。该示例会根据是否发生异常，从而决定提交或回滚事务。我们没有用一个 bool 标志区分是否发生异常，而是传了完整的异常信息，目的是可以记录异常日志。依赖于 sys.exc_info() 获取异常信息的提议被拒绝了；因为 sys.exc_info() 有着非常复杂的语义，它返回的异常信息完全有可能是很久之前就捕获的。有人还提议添加一个布尔值，用于区分是到达 BLOCK 结尾，还是非局部 goto。这因为过于复杂和不必要而被拒绝；对于数据库事务回滚，非局部 goto 应该被认为是正常的。&lt;/div&gt;
&lt;div&gt;为了促进 Python 代码中上下文的链接作用，__exit__() 方法不应该继续 raise 传递给它的错误。在这种情况下，__exit__() 方法的调用者应该负责处理 raise。&lt;/div&gt;
&lt;div&gt;这样，如果调用者想知道__exit__() 是否调用失败（而不是在传出原始错误之前就完成清理），它就可以自己判断。&lt;/div&gt;
&lt;div&gt;如果__exit__() 没有返回错误，那么就可以将__exit__() 方法本身解释为成功（不管原始错误是被传播还是抑制）。&lt;/div&gt;
&lt;div&gt;然而，如果__exit__() 向其调用者传播了异常，这就意味着__exit__() 本身已经失败。因此，__exit__() 方法应该避免引发错误，除非它们确实失败了。(允许原始错误继续并不是失败。)&lt;/div&gt;
&lt;h2&gt;过渡计划&lt;/h2&gt;
&lt;div&gt;在 Python 2.5 中，新语法需要通过 future 引入：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;from __future__ import with_statement&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;它会引入’with’和’as’关键字。如果没有导入，使用’with’或’as’作为标识符时，将导致报错。&lt;/div&gt;
&lt;div&gt;在 Python 2.6 中，新语法总是生效的，‘with’和’as’已经是关键字。&lt;/div&gt;
&lt;h2&gt;生成器装饰器&lt;/h2&gt;
&lt;div&gt;随着 PEP-342 被采纳，我们可以编写一个装饰器，令其使用只 yield 一次的生成器来控制 with 语句。这是一个装饰器的粗略示例：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GeneratorContextManager&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
   &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; gen&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
       self&lt;span&gt;.&lt;/span&gt;gen &lt;span&gt;=&lt;/span&gt; gen
   &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__enter__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
       &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
           &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;gen&lt;span&gt;.&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
       &lt;span&gt;except&lt;/span&gt; StopIteration&lt;span&gt;:&lt;/span&gt;
           &lt;span&gt;raise&lt;/span&gt; RuntimeError&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;generator didn&apos;t yield&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
   &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__exit__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; traceback&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
       &lt;span&gt;if&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
           &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
               self&lt;span&gt;.&lt;/span&gt;gen&lt;span&gt;.&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
           &lt;span&gt;except&lt;/span&gt; StopIteration&lt;span&gt;:&lt;/span&gt;
               &lt;span&gt;return&lt;/span&gt;
           &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
               &lt;span&gt;raise&lt;/span&gt; RuntimeError&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;generator didn&apos;t stop&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
       &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
           &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
               self&lt;span&gt;.&lt;/span&gt;gen&lt;span&gt;.&lt;/span&gt;throw&lt;span&gt;(&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; traceback&lt;span&gt;)&lt;/span&gt;
               &lt;span&gt;raise&lt;/span&gt; RuntimeError&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;generator didn&apos;t stop after throw()&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
           &lt;span&gt;except&lt;/span&gt; StopIteration&lt;span&gt;:&lt;/span&gt;
               &lt;span&gt;return&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
           &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
               &lt;span&gt;# only re-raise if it&apos;s *not* the exception that was&lt;/span&gt;
               &lt;span&gt;# passed to throw(), because __exit__() must not raise&lt;/span&gt;
               &lt;span&gt;# an exception unless __exit__() itself failed.  But&lt;/span&gt;
               &lt;span&gt;# throw() has to raise the exception to signal&lt;/span&gt;
               &lt;span&gt;# propagation, so this fixes the impedance mismatch&lt;/span&gt;
               &lt;span&gt;# between the throw() protocol and the __exit__()&lt;/span&gt;
               &lt;span&gt;# protocol.&lt;/span&gt;
               &lt;span&gt;#&lt;/span&gt;
               &lt;span&gt;if&lt;/span&gt; sys&lt;span&gt;.&lt;/span&gt;exc_info&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; value&lt;span&gt;:&lt;/span&gt;
                   &lt;span&gt;raise&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;contextmanager&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;func&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
   &lt;span&gt;def&lt;/span&gt; &lt;span&gt;helper&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;args&lt;span&gt;,&lt;/span&gt; &lt;span&gt;**&lt;/span&gt;kwds&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
       &lt;span&gt;return&lt;/span&gt; GeneratorContextManager&lt;span&gt;(&lt;/span&gt;func&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;args&lt;span&gt;,&lt;/span&gt; &lt;span&gt;**&lt;/span&gt;kwds&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; helper&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这个装饰器可以这样使用：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;@contextmanager&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;opening&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;filename&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
   f &lt;span&gt;=&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;filename&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# IOError is untouched by GeneratorContext&lt;/span&gt;
   &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
       &lt;span&gt;yield&lt;/span&gt; f
   &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
       f&lt;span&gt;.&lt;/span&gt;close&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# Ditto for errors here (however unlikely)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这个装饰器的健壮版本将会加入到标准库中。&lt;/div&gt;
&lt;h2&gt;标准库中的上下文管理器&lt;/h2&gt;
&lt;div&gt;可以将__enter__() 和__exit__() 方法赋予某些对象，如文件、套接字和锁，这样就不用写:&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;with&lt;/span&gt; locking&lt;span&gt;(&lt;/span&gt;myLock&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    BLOCK&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;而是简单地写成：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;with&lt;/span&gt; myLock&lt;span&gt;:&lt;/span&gt;
    BLOCK&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我想我们应该谨慎对待它；它可能会导致以下的错误:&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;f &lt;span&gt;=&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;filename&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;with&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    BLOCK1
&lt;span&gt;with&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    BLOCK2&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;它可能跟你想的不一样（在进入 block2 之前，f 已经关闭了）。&lt;/div&gt;
&lt;div&gt;另一方面，这样的错误很容易诊断；例如，当第二个 with 语句再调用 f.__enter__() 时，上面的生成器装饰器将引发 RuntimeError。如果在一个已关闭的文件对象上调用__enter__，则可能引发类似的错误。&lt;/div&gt;
&lt;div&gt;在 Python 2.5中，以下类型被标识为上下文管理器：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;- file
- thread.LockType
- threading.Lock
- threading.RLock
- threading.Condition
- threading.Semaphore
- threading.BoundedSemaphore&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;还将在 decimal 模块添加一个上下文管理器，以支持在 with 语句中使用本地的十进制算术上下文，并在退出 with 语句时，自动恢复原始上下文。&lt;/div&gt;
&lt;h2&gt;标准术语&lt;/h2&gt;
&lt;div&gt;本 PEP 提议将由__enter__() 和 __exit__() 方法组成的协议称为“上下文管理器协议”，并将实现该协议的对象称为“上下文管理器”。［4]&lt;/div&gt;
&lt;div&gt;紧跟着 with 关键字的表达式被称为“上下文表达式”，该表达式提供了上下文管理器在with 代码块中所建立的运行时环境的主要线索。&lt;/div&gt;
&lt;div&gt;目前为止， with 语句体中的代码和 as 关键字后面的变量名（一个或多个）还没有特殊的术语。可以使用一般的术语“语句体”和“目标列表”，如果这些术语不清晰，可以使用“with”或“with statement”作为前缀。&lt;/div&gt;
&lt;div&gt;考虑到可能存在 decimal 模块的算术上下文这样的对象，因此术语“上下文”是有歧义的。如果想要更加具体的话，可以使用术语“上下文管理器”，表示上下文表达式所创建的具体对象；使用术语“运行时上下文”或者（最好是）“运行时环境”，表示上下文管理器所做出的实际状态的变更。当简单地讨论 with 语句的用法时，歧义性无关紧要，因为上下文表达式完全定义了对运行时环境所做的更改。当讨论 with 语句本身的机制以及如何实际实现上下文管理器时，这些术语的区别才是重要的。&lt;/div&gt;
&lt;h2&gt;缓存上下文管理器&lt;/h2&gt;
&lt;div&gt;许多上下文管理器（例如文件和基于生成器的上下文）都是一次性的对象。一旦__exit__() 方法被调用，上下文管理器将不再可用（例如：文件已经被关闭，或者底层生成器已经完成执行）。&lt;/div&gt;
&lt;div&gt;对于多线程代码，以及嵌套的 with 语句想要使用同一个上下文管理器，最简单的方法是给每个 with 语句一个新的管理器对象。并非巧合的是，标准库中所有支持重用的上下文管理器都来自 threading 模块——它们都被设计用来处理由线程和嵌套使用所产生的问题。&lt;/div&gt;
&lt;div&gt;这意味着，为了保存带有特定初始化参数（为了用在多个 with 语句）的上下文管理器，通常需要将它存储在一个无参数的可调用对象，然后在每个语句的上下文表达式中调用，而不是直接把上下文管理器缓存起来。&lt;/div&gt;
&lt;div&gt;如果此限制不适用，在受影响的上下文管理器的文档中，应该清楚地指出这一点。&lt;/div&gt;
&lt;h2&gt;解决的问题&lt;/h2&gt;
&lt;div&gt;以下的问题经由 BDFL 的裁决而解决（并且在 python-dev 上没有重大的反对意见）。&lt;/div&gt;
&lt;div&gt;1、当底层的生成器-迭代器行为异常时，GeneratorContextManager 应该引发什么异常？下面引用的内容是 Guido 为本 PEP及 PEP-342 （见[8]）中生成器的 close() 方法选择 RuntimeError 的原因：“我不愿意只是为了它而引入一个新的异常类，因为这不是我想让人们捕获的异常：我想让它变成一个回溯（traceback），被程序员看到并且修复。因此，我认为它们都应该引发 RuntimeError。有一些引发 RuntimeError 的先例：Python 核心代码在检测到无限递归时，遇到未初始化的对象时（以及其它各种各样的情况）。”&lt;/div&gt;
&lt;div&gt;2、如果在with语句所涉及的类中没有相关的方法，则最好是抛出AttributeError而不是TypeError。抽象对象C API引发TypeError而不是AttributeError，这只是历史的一个偶然，而不是经过深思熟虑的设计决策[11]。&lt;/div&gt;
&lt;div&gt;3、带有__enter__ /__exit__方法的对象被称为“上下文管理器”，将生成器函数转化为上下文管理器工厂的是 contextlib.contextmanager 装饰器。在 2.5版本发布期间，有人提议使用其它的叫法[16]，但没有足够令人信服的理由。&lt;/div&gt;
&lt;h2&gt;拒绝的选项&lt;/h2&gt;
&lt;div&gt;在长达几个月的时间里，对于是否要抑制异常（从而避免隐藏的流程控制），出现了一场令人痛苦的拉锯战，最终，Guido 决定要抑制异常[13]。&lt;/div&gt;
&lt;div&gt;本 PEP 的另一个话题也引起了无休止的争论，即是否要提供一个__context__() 方法，类似于可迭代对象的__iter__() 方法[5][7][9]。源源不断的问题[10][13]在解释它是什么、为什么是那样、以及它是如何工作的，最终导致 Guido 完全抛弃了这个东西[15]（这很让人欢欣鼓舞！）&lt;/div&gt;
&lt;div&gt;还有人提议直接使用 PEP-342 的生成器 API 来定义 with 语句[6]，但这很快就不予考虑了，因为它会导致难以编写不基于生成器的上下文管理器。&lt;/div&gt;
&lt;h2&gt;例子&lt;/h2&gt;
&lt;div&gt;基于生成器的示例依赖于 PEP-342。另外，有些例子是不实用的，因为标准库中有现成的对象可以在 with 语句中直接使用，例如 threading.RLock。&lt;/div&gt;
&lt;div&gt;例子中那些函数名所用的时态并不是随意的。过去时态（“-ed”）的函数指的是在__enter__方法中执行，并在__exit__方法中反执行的动作。进行时态（“-ing”）的函数指的是准备在__exit__方法中执行的动作。&lt;/div&gt;
&lt;div&gt;1、一个锁的模板，在开始时获取，在离开时释放：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;@contextmanager&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;locked&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lock&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    lock&lt;span&gt;.&lt;/span&gt;acquire&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;yield&lt;/span&gt;
    &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        lock&lt;span&gt;.&lt;/span&gt;release&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;使用如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;with&lt;/span&gt; locked&lt;span&gt;(&lt;/span&gt;myLock&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;# Code here executes with myLock held.  The lock is&lt;/span&gt;
    &lt;span&gt;# guaranteed to be released when the block is left (even&lt;/span&gt;
    &lt;span&gt;# if via return or by an uncaught exception).&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;2、一个打开文件的模板，确保当代码被执行后，文件会被关闭：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;@contextmanager&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;opened&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;filename&lt;span&gt;,&lt;/span&gt; mode&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;r&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    f &lt;span&gt;=&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;filename&lt;span&gt;,&lt;/span&gt; mode&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;yield&lt;/span&gt; f
    &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        f&lt;span&gt;.&lt;/span&gt;close&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;使用如下:&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;with&lt;/span&gt; opened&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;/etc/passwd&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt; line&lt;span&gt;.&lt;/span&gt;rstrip&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;3、一个数据库事务的模板，用于提交或回滚：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;@contextmanager&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;transaction&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;db&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    db&lt;span&gt;.&lt;/span&gt;begin&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        db&lt;span&gt;.&lt;/span&gt;rollback&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;raise&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        db&lt;span&gt;.&lt;/span&gt;commit&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;4、不使用生成器，重写例子 1：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;locked&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
   &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; lock&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
       self&lt;span&gt;.&lt;/span&gt;lock &lt;span&gt;=&lt;/span&gt; lock
   &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__enter__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
       self&lt;span&gt;.&lt;/span&gt;lock&lt;span&gt;.&lt;/span&gt;acquire&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
   &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__exit__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; tb&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
       self&lt;span&gt;.&lt;/span&gt;lock&lt;span&gt;.&lt;/span&gt;release&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;（这个例子很容易被修改来实现其他相对无状态的例子；这表明，如果不需要保留特殊的状态，就不必要使用生成器。）&lt;/div&gt;
&lt;div&gt;5、临时重定向 stdout：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;@contextmanager&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;stdout_redirected&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;new_stdout&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    save_stdout &lt;span&gt;=&lt;/span&gt; sys&lt;span&gt;.&lt;/span&gt;stdout
    sys&lt;span&gt;.&lt;/span&gt;stdout &lt;span&gt;=&lt;/span&gt; new_stdout
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;
    &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        sys&lt;span&gt;.&lt;/span&gt;stdout &lt;span&gt;=&lt;/span&gt; save_stdout&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;使用如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;with&lt;/span&gt; opened&lt;span&gt;(&lt;/span&gt;filename&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;w&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;with&lt;/span&gt; stdout_redirected&lt;span&gt;(&lt;/span&gt;f&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;Hello world&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;当然，这不是线程安全的，但是若不用管理器的话，本身也不是线程安全的。在单线程程序（例如脚本）中，这种做法很受欢迎。&lt;/div&gt;
&lt;div&gt;6、opened() 的一个变体，也返回一个错误条件：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;@contextmanager&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;opened_w_error&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;filename&lt;span&gt;,&lt;/span&gt; mode&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;r&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        f &lt;span&gt;=&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;filename&lt;span&gt;,&lt;/span&gt; mode&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt; IOError&lt;span&gt;,&lt;/span&gt; err&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; err
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;yield&lt;/span&gt; f&lt;span&gt;,&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;
        &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            f&lt;span&gt;.&lt;/span&gt;close&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;使用如下:&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;with&lt;/span&gt; opened_w_error&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;/etc/passwd&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;a&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;f&lt;span&gt;,&lt;/span&gt; err&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; err&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;IOError:&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; err
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        f&lt;span&gt;.&lt;/span&gt;write&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;guido::0:0::/:/bin/sh\n&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;7、另一个有用的操作是阻塞信号。它的用法是这样的：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; signal
&lt;span&gt;with&lt;/span&gt; signal&lt;span&gt;.&lt;/span&gt;blocked&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;# code executed without worrying about signals&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;它的参数是可选的，表示要阻塞的信号列表；在默认情况下，所有信号都被阻塞。具体实现就留给读者作为练习吧。&lt;/div&gt;
&lt;div&gt;8、此特性还有一个用途是 Decimal 上下文。下面是 Michael Chermside 发布的一个简单的例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; decimal
&lt;span&gt;@contextmanager&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;extra_precision&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;places&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    c &lt;span&gt;=&lt;/span&gt; decimal&lt;span&gt;.&lt;/span&gt;getcontext&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    saved_prec &lt;span&gt;=&lt;/span&gt; c&lt;span&gt;.&lt;/span&gt;prec
    c&lt;span&gt;.&lt;/span&gt;prec &lt;span&gt;+=&lt;/span&gt; places
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;
    &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        c&lt;span&gt;.&lt;/span&gt;prec &lt;span&gt;=&lt;/span&gt; saved_prec&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;示例用法（摘自 Python 库参考文档）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;sin&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;Return the sine of x as measured in radians.&quot;&lt;/span&gt;
    &lt;span&gt;with&lt;/span&gt; extra_precision&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        i&lt;span&gt;,&lt;/span&gt; lasts&lt;span&gt;,&lt;/span&gt; s&lt;span&gt;,&lt;/span&gt; fact&lt;span&gt;,&lt;/span&gt; num&lt;span&gt;,&lt;/span&gt; sign &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; x&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; x&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; s &lt;span&gt;!=&lt;/span&gt; lasts&lt;span&gt;:&lt;/span&gt;
            lasts &lt;span&gt;=&lt;/span&gt; s
            i &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
            fact &lt;span&gt;*=&lt;/span&gt; i &lt;span&gt;*&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;i&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
            num &lt;span&gt;*=&lt;/span&gt; x &lt;span&gt;*&lt;/span&gt; x
            sign &lt;span&gt;*=&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
            s &lt;span&gt;+=&lt;/span&gt; num &lt;span&gt;/&lt;/span&gt; fact &lt;span&gt;*&lt;/span&gt; sign
    &lt;span&gt;# The &quot;+s&quot; rounds back to the original precision,&lt;/span&gt;
    &lt;span&gt;# so this must be outside the with-statement:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;s&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;9、下面是 decimal 模块的一个简单的上下文管理器：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;@contextmanager&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;localcontext&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;ctx&lt;span&gt;=&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;Set a new local decimal context for the block&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;# Default to using the current context&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ctx &lt;span&gt;is&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        ctx &lt;span&gt;=&lt;/span&gt; getcontext&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;# We set the thread context to a copy of this context&lt;/span&gt;
    &lt;span&gt;# to ensure that changes within the block are kept&lt;/span&gt;
    &lt;span&gt;# local to the block.&lt;/span&gt;
    newctx &lt;span&gt;=&lt;/span&gt; ctx&lt;span&gt;.&lt;/span&gt;copy&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    oldctx &lt;span&gt;=&lt;/span&gt; decimal&lt;span&gt;.&lt;/span&gt;getcontext&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    decimal&lt;span&gt;.&lt;/span&gt;setcontext&lt;span&gt;(&lt;/span&gt;newctx&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;yield&lt;/span&gt; newctx
    &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;# Always restore the original context&lt;/span&gt;
        decimal&lt;span&gt;.&lt;/span&gt;setcontext&lt;span&gt;(&lt;/span&gt;oldctx&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;示例用法:&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; decimal &lt;span&gt;import&lt;/span&gt; localcontext&lt;span&gt;,&lt;/span&gt; ExtendedContext
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;sin&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;with&lt;/span&gt; localcontext&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; ctx&lt;span&gt;:&lt;/span&gt;
        ctx&lt;span&gt;.&lt;/span&gt;prec &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
        &lt;span&gt;# Rest of sin calculation algorithm&lt;/span&gt;
        &lt;span&gt;# uses a precision 2 greater than normal&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;s &lt;span&gt;# Convert result to normal precision&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;sin&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;with&lt;/span&gt; localcontext&lt;span&gt;(&lt;/span&gt;ExtendedContext&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;# Rest of sin calculation algorithm&lt;/span&gt;
        &lt;span&gt;# uses the Extended Context from the&lt;/span&gt;
        &lt;span&gt;# General Decimal Arithmetic Specification&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;s &lt;span&gt;# Convert result to normal context&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;10、一个通用的“对象关闭”上下文管理器：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;closing&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; obj&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;obj &lt;span&gt;=&lt;/span&gt; obj
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__enter__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;obj
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__exit__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;exc_info&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            close_it &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;obj&lt;span&gt;.&lt;/span&gt;close
        &lt;span&gt;except&lt;/span&gt; AttributeError&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;pass&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            close_it&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这可以确保关闭任何带有 close 方法的东西，无论是文件、生成器，还是其他东西。它甚至可以在对象并不需要关闭的情况下使用（例如，一个接受了任意可迭代对象的函数）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# emulate opening():&lt;/span&gt;
&lt;span&gt;with&lt;/span&gt; closing&lt;span&gt;(&lt;/span&gt;&lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;argument.txt&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; contradiction&lt;span&gt;:&lt;/span&gt;
   &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; contradiction&lt;span&gt;:&lt;/span&gt;
       &lt;span&gt;print&lt;/span&gt; line
&lt;span&gt;# deterministically finalize an iterator:&lt;/span&gt;
&lt;span&gt;with&lt;/span&gt; closing&lt;span&gt;(&lt;/span&gt;&lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data_source&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; data&lt;span&gt;:&lt;/span&gt;
   &lt;span&gt;for&lt;/span&gt; datum &lt;span&gt;in&lt;/span&gt; data&lt;span&gt;:&lt;/span&gt;
       process&lt;span&gt;(&lt;/span&gt;datum&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;（Python 2.5 的 contextlib 模块包含了这个上下文管理器的一个版本）&lt;/div&gt;
&lt;div&gt;11、PEP-319 给出了一个用例，它也有一个 release() 上下文，能临时释放先前获得的锁；这个用例跟前文的例子 4 很相似，只是交换了 acquire() 和 release() 的调用：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;released&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; lock&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
      self&lt;span&gt;.&lt;/span&gt;lock &lt;span&gt;=&lt;/span&gt; lock
  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__enter__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
      self&lt;span&gt;.&lt;/span&gt;lock&lt;span&gt;.&lt;/span&gt;release&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__exit__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; tb&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
      self&lt;span&gt;.&lt;/span&gt;lock&lt;span&gt;.&lt;/span&gt;acquire&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;示例用法:&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;with&lt;/span&gt; my_lock&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;# Operations with the lock held&lt;/span&gt;
    &lt;span&gt;with&lt;/span&gt; released&lt;span&gt;(&lt;/span&gt;my_lock&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;# Operations without the lock&lt;/span&gt;
        &lt;span&gt;# e.g. blocking I/O&lt;/span&gt;
    &lt;span&gt;# Lock is held again here&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;12、一个“嵌套型”上下文管理器，自动从左到右嵌套所提供的上下文，可以避免过度缩进：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;@contextmanager&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;nested&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;contexts&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    exits &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
    &lt;span&gt;vars&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; context &lt;span&gt;in&lt;/span&gt; contexts&lt;span&gt;:&lt;/span&gt;
                exit &lt;span&gt;=&lt;/span&gt; context&lt;span&gt;.&lt;/span&gt;__exit__
                enter &lt;span&gt;=&lt;/span&gt; context&lt;span&gt;.&lt;/span&gt;__enter__
                &lt;span&gt;vars&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;enter&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                exits&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;exit&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;vars&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            exc &lt;span&gt;=&lt;/span&gt; sys&lt;span&gt;.&lt;/span&gt;exc_info&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            exc &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; exits&lt;span&gt;:&lt;/span&gt;
            exit &lt;span&gt;=&lt;/span&gt; exits&lt;span&gt;.&lt;/span&gt;pop&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                exit&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;exc&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                exc &lt;span&gt;=&lt;/span&gt; sys&lt;span&gt;.&lt;/span&gt;exc_info&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                exc &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; exc &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;# sys.exc_info() may have been&lt;/span&gt;
            &lt;span&gt;# changed by one of the exit methods&lt;/span&gt;
            &lt;span&gt;# so provide explicit exception info&lt;/span&gt;
            &lt;span&gt;raise&lt;/span&gt; exc&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; exc&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; exc&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;示例用法:&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;with&lt;/span&gt; nested&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; b&lt;span&gt;,&lt;/span&gt; c&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt; y&lt;span&gt;,&lt;/span&gt; z&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;# Perform operation&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;等价于:&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;with&lt;/span&gt; a &lt;span&gt;as&lt;/span&gt; x&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;with&lt;/span&gt; b &lt;span&gt;as&lt;/span&gt; y&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;with&lt;/span&gt; c &lt;span&gt;as&lt;/span&gt; z&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;# Perform operation&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;（Python 2.5 的 contextlib 模块包含了这个上下文管理器的一个版本）&lt;/div&gt;
&lt;h2&gt;参考实现&lt;/h2&gt;
&lt;div&gt;在 2005 年 6 月 27 日的 EuroPython 会议上，Guido 首次采纳了这个 PEP。之后它添加了__context__方法，并被再次采纳。此 PEP 在 Python 2.5 a1 子版本中实现，__context__() 方法在 Python 2.5b1 中被删除。&lt;/div&gt;
&lt;h2&gt;致谢&lt;/h2&gt;
&lt;div&gt;许多人对这个 PEP 中的想法和概念作出了贡献，包括在 PEP-340 和 PEP-346 的致谢中提到的所有人。&lt;/div&gt;
&lt;div&gt;另外，还要感谢（排名不分先后）：Paul Moore, Phillip J. Eby, Greg Ewing, Jason Orendorff, Michael Hudson, Raymond Hettinger, Walter Dörwald, Aahz, Georg Brandl, Terry Reedy, A.M. Kuchling, Brett Cannon，以及所有参与了 python-dev 讨论的人。&lt;/div&gt;
&lt;h2&gt;参考链接&lt;/h2&gt;
&lt;div&gt;[1]	Raymond Chen’s article on hidden flow control&lt;a href=&quot;https://devblogs.microsoft.com/oldnewthing/20050106-00/?p=36783&quot;&gt;https://devblogs.microsoft.com/oldnewthing/20050106-00/?p=36783&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[2]	Guido suggests some generator changes that ended up in PEP 342&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-May/053885.html&quot;&gt;https://mail.python.org/pipermail/python-dev/2005-May/053885.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[3]	Wiki discussion of PEP 343&lt;a href=&quot;http://wiki.python.org/moin/WithStatement&quot;&gt;http://wiki.python.org/moin/WithStatement&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[4]	Early draft of some documentation for the with statement&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-July/054658.html&quot;&gt;https://mail.python.org/pipermail/python-dev/2005-July/054658.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[5]	Proposal to add the &lt;strong&gt;with&lt;/strong&gt; method&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-October/056947.html&quot;&gt;https://mail.python.org/pipermail/python-dev/2005-October/056947.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[6]	Proposal to use the PEP 342 enhanced generator API directly&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-October/056969.html&quot;&gt;https://mail.python.org/pipermail/python-dev/2005-October/056969.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[7]	Guido lets me (Nick Coghlan) talk him into a bad idea ;)&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-October/057018.html&quot;&gt;https://mail.python.org/pipermail/python-dev/2005-October/057018.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[8]	Guido raises some exception handling questions&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-June/054064.html&quot;&gt;https://mail.python.org/pipermail/python-dev/2005-June/054064.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[9]	Guido answers some questions about the &lt;strong&gt;context&lt;/strong&gt; method&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-October/057520.html&quot;&gt;https://mail.python.org/pipermail/python-dev/2005-October/057520.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[10]	Guido answers more questions about the &lt;strong&gt;context&lt;/strong&gt; method&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-October/057535.html&quot;&gt;https://mail.python.org/pipermail/python-dev/2005-October/057535.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[11]	Guido says AttributeError is fine for missing special methods&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-October/057625.html&quot;&gt;https://mail.python.org/pipermail/python-dev/2005-October/057625.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[12]	Original PEP 342 implementation patch&lt;a href=&quot;http://sourceforge.net/tracker/index.php?func=detail&amp;amp;aid=1223381&amp;amp;group_id=5470&amp;amp;atid=305470&quot;&gt;http://sourceforge.net/tracker/index.php?func=detail&amp;amp;aid=1223381&amp;amp;group_id=5470&amp;amp;atid=305470&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[13]	&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2006-February/061909.html&quot;&gt;(1, 2) Guido restores the ability to suppress exceptions&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[14]	&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2006-April/063859.html&quot;&gt;A simple question kickstarts a thorough review of PEP 343&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[15]	&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2006-April/064632.html&quot;&gt;Guido kills the &lt;strong&gt;context&lt;/strong&gt;() method&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[16]	&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2006-May/064676.html&quot;&gt;Proposal to use ‘context guard’ instead of ‘context manager’&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;版权&lt;/h2&gt;
&lt;div&gt;本文档已进入公共领域。&lt;/div&gt;
&lt;div&gt;源文档：&lt;a href=&quot;https://github.com/python/peps/blob/master/pep-0343.txt&quot;&gt;https://github.com/python/peps/blob/master/pep-0343.txt&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>为什么 Python 没有函数重载？如何用装饰器实现函数重载？</title>
            <link>https://pythoncat.top/posts/2021-06-27-overload/</link>
            <guid>https://pythoncat.top/posts/2021-06-27-overload/</guid>
            <pubDate>Sun, 27 Jun 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;英文：&lt;a href=&quot;https://arpitbhayani.me/blogs/function-overloading&quot;&gt;Function Overloading in Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者：arprit&lt;/div&gt;
&lt;div&gt;译者：豌豆花下猫（“Python猫”公众号作者）&lt;/div&gt;
&lt;div&gt;声明：本翻译是出于交流学习的目的，基于 CC BY-NC-SA 4.0 授权协议。为便于阅读，内容略有改动。&lt;/div&gt;
&lt;div&gt;函数重载指的是有多个同名的函数，但是它们的签名或实现却不同。当调用一个重载函数 fn 时，程序会检验传递给函数的实参/形参，并据此而调用相应的实现。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;int area(int length, int breadth) {
  return length * breadth;
}

float area(int radius) {
  return 3.14 * radius * radius;
}&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在以上例子中（用 c++ 编写），函数 area 被重载了两个实现。第一个函数接收两个参数（都是整数），表示矩形的长度和宽度，并返回矩形的面积。另一个函数只接收一个整型参数，表示圆的半径。&lt;/div&gt;
&lt;div&gt;当我们像 area(7) 这样调用函数 area 时，它会调用第二个函数，而 area(3,4) 则会调用第一个函数。&lt;/div&gt;
&lt;h2&gt;为什么 Python 中没有函数重载？&lt;/h2&gt;
&lt;div&gt;Python 不支持函数重载。当我们定义了多个同名的函数时，后面的函数总是会覆盖前面的函数，因此，在一个命名空间中，每个函数名仅会有一个登记项（entry）。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Python猫注：这里说 Python 不支持函数重载，指的是在不用语法糖的情况下。使用 functools 库的 singledispatch 装饰器，Python 也可以实现函数重载。原文作者在文末的注释中专门提到了这一点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;通过调用 locals() 和 globals() 函数，我们可以看到 Python 的命名空间中有什么，它们分别返回局部和全局命名空间。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;area&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;radius&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;3.14&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; radius &lt;span&gt;**&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;locals&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;
  &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
  &lt;span&gt;&apos;area&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;function area at &lt;span&gt;0x10476a440&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
  &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在定义一个函数后，接着调用 locals() 函数，我们会看到它返回了一个字典，包含了定义在局部命名空间中的所有变量。字典的键是变量的名称，值是该变量的引用/值。&lt;/div&gt;
&lt;div&gt;当程序在运行时，若遇到另一个同名函数，它就会更新局部命名空间中的登记项，从而消除两个函数共存的可能性。因此 Python 不支持函数重载。这是在创造语言时做出的设计决策，但这并不妨碍我们实现它，所以，让我们来重载一些函数吧。&lt;/div&gt;
&lt;h2&gt;在 Python 中实现函数重载&lt;/h2&gt;
&lt;div&gt;我们已经知道 Python 是如何管理命名空间的，如果想要实现函数重载，就需要这样做：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;维护一个虚拟的命名空间，在其中管理函数定义&lt;/li&gt;
&lt;li&gt;根据每次传递的参数，设法调用适当的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;为了简单起见，我们在实现函数重载时，通过不同的参数数量来区分同名函数。&lt;/div&gt;
&lt;h2&gt;把函数封装起来&lt;/h2&gt;
&lt;div&gt;我们创建了一个名为&lt;code&gt;Function&lt;/code&gt;的类，它可以封装任何函数，并通过重写的&lt;code&gt;__call__&lt;/code&gt;方法来调用该函数，还提供了一个名为&lt;code&gt;key&lt;/code&gt;的方法，该方法返回一个元组，使该函数在整个代码库中是唯一的。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; inspect &lt;span&gt;import&lt;/span&gt; getfullargspec

&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Function&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;&quot;&quot;&quot;Function类是对标准的Python函数的封装&quot;&quot;&quot;&lt;/span&gt;
  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; fn&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    self&lt;span&gt;.&lt;/span&gt;fn &lt;span&gt;=&lt;/span&gt; fn
    
  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;args&lt;span&gt;,&lt;/span&gt; &lt;span&gt;**&lt;/span&gt;kwargs&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;当像函数一样被调用时，它就会调用被封装的函数，并返回该函数的返回值&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;fn&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;args&lt;span&gt;,&lt;/span&gt; &lt;span&gt;**&lt;/span&gt;kwargs&lt;span&gt;)&lt;/span&gt;

  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; args&lt;span&gt;=&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;返回一个key，能唯一标识出一个函数（即便是被重载的）&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;# 如果不指定args，则从函数的定义中提取参数&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; args &lt;span&gt;is&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
      args &lt;span&gt;=&lt;/span&gt; getfullargspec&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;fn&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;args
    
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;tuple&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;
      self&lt;span&gt;.&lt;/span&gt;fn&lt;span&gt;.&lt;/span&gt;__module__&lt;span&gt;,&lt;/span&gt;
      self&lt;span&gt;.&lt;/span&gt;fn&lt;span&gt;.&lt;/span&gt;__class__&lt;span&gt;,&lt;/span&gt;
      self&lt;span&gt;.&lt;/span&gt;fn&lt;span&gt;.&lt;/span&gt;__name__&lt;span&gt;,&lt;/span&gt;
      &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;args &lt;span&gt;or&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    &lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在上面的代码片段中，&lt;code&gt;key&lt;/code&gt;函数返回一个元组，该元组唯一标识了代码库中的函数，并且记录了：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;函数所属的模块&lt;/li&gt;
&lt;li&gt;函数所属的类&lt;/li&gt;
&lt;li&gt;函数名&lt;/li&gt;
&lt;li&gt;函数接收的参数量&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;被重写的&lt;code&gt;__call__&lt;/code&gt;方法会调用被封装的函数，并返回计算的值（这没有啥特别的）。这使得&lt;code&gt;Function&lt;/code&gt;的实例可以像函数一样被调用，并且它的行为与被封装的函数完全一样。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;area&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;l&lt;span&gt;,&lt;/span&gt; b&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; l &lt;span&gt;*&lt;/span&gt; b

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; func &lt;span&gt;=&lt;/span&gt; Function&lt;span&gt;(&lt;/span&gt;area&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; func&lt;span&gt;.&lt;/span&gt;key&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;__main__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;&apos;function&apos;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;area&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; func&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在上面的例子中，函数&lt;code&gt;area&lt;/code&gt;被封装在&lt;code&gt;Function&lt;/code&gt;中，并被实例化成&lt;code&gt;func&lt;/code&gt;。key() 返回一个元组，其第一个元素是模块名&lt;code&gt;__main__&lt;/code&gt;，第二个是类&lt;code&gt;&amp;lt;class &apos;function&apos;&amp;gt;&lt;/code&gt;，第三个是函数名&lt;code&gt;area&lt;/code&gt;，而第四个则是该函数接收的参数数量，即 2。&lt;/div&gt;
&lt;div&gt;这个示例还显示出，我们可以像调用普通的 area函数一样，去调用实例 func，当传入参数 3 和 4时，得到的结果是 12，这正是调用 area(3,4) 时会得到的结果。当我们接下来运用装饰器时，这种行为将会派上用场。&lt;/div&gt;
&lt;h2&gt;构建虚拟的命名空间&lt;/h2&gt;
&lt;div&gt;我们要创建一个虚拟的命名空间，用于存储在定义阶段收集的所有函数。&lt;/div&gt;
&lt;div&gt;由于只有一个命名空间/注册表，我们创建了一个单例类，并把函数保存在字典中。该字典的键不是函数名，而是我们从 key 函数中得到的元组，该元组包含的元素能唯一标识出一个函数。&lt;/div&gt;
&lt;div&gt;通过这样，我们就能在注册表中保存所有的函数，即使它们有相同的名称（但不同的参数），从而实现函数重载。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Namespace&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;&quot;&quot;&quot;Namespace是一个单例类，负责保存所有的函数&quot;&quot;&quot;&lt;/span&gt;
  __instance &lt;span&gt;=&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;
    
  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;__instance &lt;span&gt;is&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
      self&lt;span&gt;.&lt;/span&gt;function_map &lt;span&gt;=&lt;/span&gt; &lt;span&gt;dict&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
      Namespace&lt;span&gt;.&lt;/span&gt;__instance &lt;span&gt;=&lt;/span&gt; self
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
      &lt;span&gt;raise&lt;/span&gt; Exception&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;cannot instantiate a virtual Namespace again&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    
  &lt;span&gt;@staticmethod&lt;/span&gt;
  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;get_instance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; Namespace&lt;span&gt;.&lt;/span&gt;__instance &lt;span&gt;is&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
      Namespace&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; Namespace&lt;span&gt;.&lt;/span&gt;__instance

  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; fn&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;在虚拟的命名空间中注册函数，并返回Function类的可调用实例&quot;&quot;&quot;&lt;/span&gt;
    func &lt;span&gt;=&lt;/span&gt; Function&lt;span&gt;(&lt;/span&gt;fn&lt;span&gt;)&lt;/span&gt;
    self&lt;span&gt;.&lt;/span&gt;function_map&lt;span&gt;[&lt;/span&gt;func&lt;span&gt;.&lt;/span&gt;key&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; fn
    &lt;span&gt;return&lt;/span&gt; func&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;code&gt;Namespace&lt;/code&gt;类有一个&lt;code&gt;register&lt;/code&gt;方法，该方法将函数 fn 作为参数，为其创建一个唯一的键，并将函数存储在字典中，最后返回封装了 fn 的&lt;code&gt;Function&lt;/code&gt;的实例。这意味着 register 函数的返回值也是可调用的，并且（到目前为止）它的行为与被封装的函数 fn 完全相同。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;area&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;l&lt;span&gt;,&lt;/span&gt; b&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; l &lt;span&gt;*&lt;/span&gt; b

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; namespace &lt;span&gt;=&lt;/span&gt; Namespace&lt;span&gt;.&lt;/span&gt;get_instance&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; func &lt;span&gt;=&lt;/span&gt; namespace&lt;span&gt;.&lt;/span&gt;register&lt;span&gt;(&lt;/span&gt;area&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; func&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;使用装饰器作为钩子&lt;/h2&gt;
&lt;div&gt;既然已经定义了一个能够注册函数的虚拟命名空间，那么，我们还需要一个钩子来在函数定义期间调用它。在这里，我们会使用 Python 装饰器。&lt;/div&gt;
&lt;div&gt;在 Python 中，装饰器用于封装一个函数，并允许我们在不修改该函数的结构的情况下，向其添加新功能。装饰器把被装饰的函数 fn 作为参数，并返回一个新的函数，用于实际的调用。新的函数会接收原始函数的 args 和 kwargs，并返回最终的值。&lt;/div&gt;
&lt;div&gt;以下是一个装饰器的示例，演示了如何给函数添加计时功能。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; time

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;my_decorator&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;fn&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;&quot;&quot;&quot;这是一个自定义的函数，可以装饰任何函数，并打印其执行过程的耗时&quot;&quot;&quot;&lt;/span&gt;
  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;wrapper_function&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;args&lt;span&gt;,&lt;/span&gt; &lt;span&gt;**&lt;/span&gt;kwargs&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    start_time &lt;span&gt;=&lt;/span&gt; time&lt;span&gt;.&lt;/span&gt;time&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;# 调用被装饰的函数，并获取其返回值&lt;/span&gt;
    value &lt;span&gt;=&lt;/span&gt; fn&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;args&lt;span&gt;,&lt;/span&gt; &lt;span&gt;**&lt;/span&gt;kwargs&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;the function execution took:&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; time&lt;span&gt;.&lt;/span&gt;time&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; start_time&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;seconds&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;# 返回被装饰的函数的调用结果&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; value
  &lt;span&gt;return&lt;/span&gt; wrapper_function

&lt;span&gt;@my_decorator&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;area&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;l&lt;span&gt;,&lt;/span&gt; b&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; l &lt;span&gt;*&lt;/span&gt; b

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; area&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
the function execution took&lt;span&gt;:&lt;/span&gt; &lt;span&gt;9.5367431640625e-07&lt;/span&gt; seconds
&lt;span&gt;12&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在上面的例子中，我们定义了一个名为 my_decorator 的装饰器，它封装了函数 area，并在标准输出上打印出执行 area 所需的时间。&lt;/div&gt;
&lt;div&gt;每当解释器遇到一个函数定义时，就会调用装饰器函数 my_decorator（用它封装被装饰的函数，并将封装后的函数存储在 Python 的局部或全局命名空间中），对于我们来说，它是在虚拟命名空间中注册函数的理想钩子。&lt;/div&gt;
&lt;div&gt;因此，我们创建了名为&lt;code&gt;overload&lt;/code&gt;的装饰器，它能在虚拟命名空间中注册函数，并返回一个可调用对象。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;overload&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;fn&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;&quot;&quot;&quot;用于封装函数，并返回Function类的一个可调用对象&quot;&quot;&quot;&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; Namespace&lt;span&gt;.&lt;/span&gt;get_instance&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;register&lt;span&gt;(&lt;/span&gt;fn&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;code&gt;overload&lt;/code&gt;装饰器借助命名空间的 .register() 函数，返回 Function 的一个实例。现在，无论何时调用函数（被 overload 装饰的），它都会调用由 .register() 函数所返回的函数——Function 的一个实例，其 &lt;strong&gt;call&lt;/strong&gt; 方法会在调用期间使用指定的 args 和 kwargs 执行。&lt;/div&gt;
&lt;div&gt;现在剩下的就是在 Function 类中实现__call__方法，使得它能根据调用期间传入的参数而调用相应的函数。&lt;/div&gt;
&lt;h2&gt;从命名空间中找到正确的函数&lt;/h2&gt;
&lt;div&gt;想要区别出不同的函数，除了通常的模块、类和函数名以外，还可以依据函数的参数数量，因此，我们在虚拟的命名空间中定义了一个 get 方法，它会从 Python 的命名空间中读取待区分的函数以及实参，最后依据参数的不同，返回出正确的函数。我们没有更改 Python 的默认行为，因此在原生的命名空间中，同名的函数只有一个。&lt;/div&gt;
&lt;div&gt;这个 get 函数决定了会调用函数的哪个实现（如果重载了的话）。找到正确的函数的过程非常简单——先使用 key 方法，它利用函数和参数来创建出唯一的键（正如注册时所做的那样），接着查找这个键是否存在于函数注册表中；如果存在，则获取其映射的实现。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; fn&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;args&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;&quot;&quot;&quot;从虚拟命名空间中返回匹配到的函数，如果没找到匹配，则返回None&quot;&quot;&quot;&lt;/span&gt;
  func &lt;span&gt;=&lt;/span&gt; Function&lt;span&gt;(&lt;/span&gt;fn&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;function_map&lt;span&gt;.&lt;/span&gt;get&lt;span&gt;(&lt;/span&gt;func&lt;span&gt;.&lt;/span&gt;key&lt;span&gt;(&lt;/span&gt;args&lt;span&gt;=&lt;/span&gt;args&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;get 函数创建了 Function 类的一个实例，这样就可以复用类的 key 函数来获得一个唯一的键，而不用再写创建键的逻辑。然后，这个键将用于从函数注册表中获取正确的函数。&lt;/div&gt;
&lt;h2&gt;实现函数的调用&lt;/h2&gt;
&lt;div&gt;前面说过，每次调用被 overload 装饰的函数时，都会调用 Function 类中的__call__方法。我们需要让__call__方法从命名空间的 get 函数中，获取出正确的函数，并调用之。&lt;/div&gt;
&lt;div&gt;__call__方法的实现如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;args&lt;span&gt;,&lt;/span&gt; &lt;span&gt;**&lt;/span&gt;kwargs&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;&quot;&quot;&quot;重写能让类的实例变可调用对象的__call__方法&quot;&quot;&quot;&lt;/span&gt;
  &lt;span&gt;# 依据参数，从虚拟命名空间中获取将要调用的函数&lt;/span&gt;
  fn &lt;span&gt;=&lt;/span&gt; Namespace&lt;span&gt;.&lt;/span&gt;get_instance&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;get&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;fn&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;args&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; fn&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;raise&lt;/span&gt; Exception&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;no matching function found.&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;# 调用被封装的函数，并返回调用的结果&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; fn&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;args&lt;span&gt;,&lt;/span&gt; &lt;span&gt;**&lt;/span&gt;kwargs&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;该方法从虚拟命名空间中获取正确的函数，如果没有找到任何函数，它就抛出一个 Exception，如果找到了，就会调用该函数，并返回调用的结果。&lt;/div&gt;
&lt;h2&gt;运用函数重载&lt;/h2&gt;
&lt;div&gt;准备好所有代码后，我们定义了两个名为 area 的函数：一个计算矩形的面积，另一个计算圆的面积。下面定义了两个函数，并使用&lt;code&gt;overload&lt;/code&gt;装饰器进行装饰。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;@overload&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;area&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;l&lt;span&gt;,&lt;/span&gt; b&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; l &lt;span&gt;*&lt;/span&gt; b

&lt;span&gt;@overload&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;area&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;r&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;import&lt;/span&gt; math
  &lt;span&gt;return&lt;/span&gt; math&lt;span&gt;.&lt;/span&gt;pi &lt;span&gt;*&lt;/span&gt; r &lt;span&gt;**&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; area&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; area&lt;span&gt;(&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;153.93804002589985&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;当我们用一个参数调用 area 时，它返回了一个圆的面积，当我们传递两个参数时，它会调用计算矩形面积的函数，从而实现了函数 area 的重载。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;原作者注：从 Python 3.4 开始，Python 的 functools.singledispatch 支持函数重载。从 Python 3.8 开始，functools.singledispatchmethod 支持重载类和实例方法。感谢 Harry Percival 的指正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;div&gt;Python 不支持函数重载，但是通过使用它的基本结构，我们捣鼓了一个解决方案。&lt;/div&gt;
&lt;div&gt;我们使用装饰器和虚拟的命名空间来重载函数，并使用参数的数量作为区别函数的因素。我们还可以根据参数的类型（在装饰器中定义）来区别函数——即重载那些参数数量相同但参数类型不同的函数。&lt;/div&gt;
&lt;div&gt;重载能做到什么程度，这仅仅受限于&lt;code&gt;getfullargspec&lt;/code&gt;函数和我们的想象。使用前文的思路，你可能会实现出一个更整洁、更干净、更高效的方法，所以，请尝试实现一下吧。&lt;/div&gt;
&lt;div&gt;正文到此结束。以下附上完整的代码：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 模块：overload.py&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; inspect &lt;span&gt;import&lt;/span&gt; getfullargspec

&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Function&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;&quot;&quot;&quot;Function is a wrap over standard python function
  An instance of this Function class is also callable
  just like the python function that it wrapped.
  When the instance is &quot;called&quot; like a function it fetches
  the function to be invoked from the virtual namespace and then
  invokes the same.
  &quot;&quot;&quot;&lt;/span&gt;
  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; fn&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    self&lt;span&gt;.&lt;/span&gt;fn &lt;span&gt;=&lt;/span&gt; fn
  
  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;args&lt;span&gt;,&lt;/span&gt; &lt;span&gt;**&lt;/span&gt;kwargs&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;Overriding the __call__ function which makes the
    instance callable.
    &quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;# fetching the function to be invoked from the virtual namespace&lt;/span&gt;
    &lt;span&gt;# through the arguments.&lt;/span&gt;
    fn &lt;span&gt;=&lt;/span&gt; Namespace&lt;span&gt;.&lt;/span&gt;get_instance&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;get&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;fn&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;args&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; fn&lt;span&gt;:&lt;/span&gt;
      &lt;span&gt;raise&lt;/span&gt; Exception&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;no matching function found.&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;# invoking the wrapped function and returning the value.&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; fn&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;args&lt;span&gt;,&lt;/span&gt; &lt;span&gt;**&lt;/span&gt;kwargs&lt;span&gt;)&lt;/span&gt;

  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; args&lt;span&gt;=&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;Returns the key that will uniquely identifies
    a function (even when it is overloaded).
    &quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; args &lt;span&gt;is&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
      args &lt;span&gt;=&lt;/span&gt; getfullargspec&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;fn&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;args
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;tuple&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;
      self&lt;span&gt;.&lt;/span&gt;fn&lt;span&gt;.&lt;/span&gt;__module__&lt;span&gt;,&lt;/span&gt;
      self&lt;span&gt;.&lt;/span&gt;fn&lt;span&gt;.&lt;/span&gt;__class__&lt;span&gt;,&lt;/span&gt;
      self&lt;span&gt;.&lt;/span&gt;fn&lt;span&gt;.&lt;/span&gt;__name__&lt;span&gt;,&lt;/span&gt;
      &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;args &lt;span&gt;or&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    &lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Namespace&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;&quot;&quot;&quot;Namespace is the singleton class that is responsible
  for holding all the functions.
  &quot;&quot;&quot;&lt;/span&gt;
  __instance &lt;span&gt;=&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;
    
  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;__instance &lt;span&gt;is&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
      self&lt;span&gt;.&lt;/span&gt;function_map &lt;span&gt;=&lt;/span&gt; &lt;span&gt;dict&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
      Namespace&lt;span&gt;.&lt;/span&gt;__instance &lt;span&gt;=&lt;/span&gt; self
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
      &lt;span&gt;raise&lt;/span&gt; Exception&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;cannot instantiate Namespace again.&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    
  @&lt;span&gt;staticmethod&lt;/span&gt;
  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;get_instance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; Namespace&lt;span&gt;.&lt;/span&gt;__instance &lt;span&gt;is&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
      Namespace&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; Namespace&lt;span&gt;.&lt;/span&gt;__instance

  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; fn&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;registers the function in the virtual namespace and returns
    an instance of callable Function that wraps the function fn.
    &quot;&quot;&quot;&lt;/span&gt;
    func &lt;span&gt;=&lt;/span&gt; Function&lt;span&gt;(&lt;/span&gt;fn&lt;span&gt;)&lt;/span&gt;
    specs &lt;span&gt;=&lt;/span&gt; getfullargspec&lt;span&gt;(&lt;/span&gt;fn&lt;span&gt;)&lt;/span&gt;
    self&lt;span&gt;.&lt;/span&gt;function_map&lt;span&gt;[&lt;/span&gt;func&lt;span&gt;.&lt;/span&gt;key&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; fn
    &lt;span&gt;return&lt;/span&gt; func
  
  &lt;span&gt;def&lt;/span&gt; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; fn&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;args&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;get returns the matching function from the virtual namespace.
    return None if it did not fund any matching function.
    &quot;&quot;&quot;&lt;/span&gt;
    func &lt;span&gt;=&lt;/span&gt; Function&lt;span&gt;(&lt;/span&gt;fn&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;function_map&lt;span&gt;.&lt;/span&gt;get&lt;span&gt;(&lt;/span&gt;func&lt;span&gt;.&lt;/span&gt;key&lt;span&gt;(&lt;/span&gt;args&lt;span&gt;=&lt;/span&gt;args&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;overload&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;fn&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;&quot;&quot;&quot;overload is the decorator that wraps the function
  and returns a callable object of type Function.
  &quot;&quot;&quot;&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; Namespace&lt;span&gt;.&lt;/span&gt;get_instance&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;register&lt;span&gt;(&lt;/span&gt;fn&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;最后，演示代码如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; overload &lt;span&gt;import&lt;/span&gt; overload

&lt;span&gt;@overload&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;area&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;length&lt;span&gt;,&lt;/span&gt; breadth&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; length &lt;span&gt;*&lt;/span&gt; breadth

&lt;span&gt;@overload&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;area&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;radius&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;import&lt;/span&gt; math
  &lt;span&gt;return&lt;/span&gt; math&lt;span&gt;.&lt;/span&gt;pi &lt;span&gt;*&lt;/span&gt; radius &lt;span&gt;**&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;

&lt;span&gt;@overload&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;area&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;length&lt;span&gt;,&lt;/span&gt; breadth&lt;span&gt;,&lt;/span&gt; height&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;length &lt;span&gt;*&lt;/span&gt; breadth &lt;span&gt;+&lt;/span&gt; breadth &lt;span&gt;*&lt;/span&gt; height &lt;span&gt;+&lt;/span&gt; height &lt;span&gt;*&lt;/span&gt; length&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;@overload&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;volume&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;length&lt;span&gt;,&lt;/span&gt; breadth&lt;span&gt;,&lt;/span&gt; height&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; length &lt;span&gt;*&lt;/span&gt; breadth &lt;span&gt;*&lt;/span&gt; height

&lt;span&gt;@overload&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;area&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;length&lt;span&gt;,&lt;/span&gt; breadth&lt;span&gt;,&lt;/span&gt; height&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; length &lt;span&gt;+&lt;/span&gt; breadth &lt;span&gt;+&lt;/span&gt; height

&lt;span&gt;@overload&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;area&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;area of cuboid with dimension (4, 3, 6) is: &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;area&lt;span&gt;(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;area of rectangle with dimension (7, 2) is: &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;area&lt;span&gt;(&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;area of circle with radius 7 is: &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;area&lt;span&gt;(&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;area of nothing is: &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;area&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;volume of cuboid with dimension (4, 3, 6) is: &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;volume&lt;span&gt;(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>荔枝</title>
            <link>https://pythoncat.top/posts/2021-06-20-lizhi/</link>
            <guid>https://pythoncat.top/posts/2021-06-20-lizhi/</guid>
            <description>每年入夏的时候，我就特别想念新鲜的荔枝。近几年来，物流和电商发达。在荔枝上市的时节，即便身在苏州，我也能很容易就吃上来自广东和海南的各个品种的荔枝，然而，却总有一些不满足。</description>
            <pubDate>Sun, 20 Jun 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;每年入夏的时候，我就特别想念新鲜的荔枝。近几年来，物流和电商发达。在荔枝上市的时节，即便身在苏州，我也能很容易就吃上来自广东和海南的各个品种的荔枝，然而，却总有一些不满足。&lt;/div&gt;
&lt;div&gt;荔枝是非常娇贵的水果，只生长在南方少数的区域，果实不能长久保存。古时候交通落后，那时的荔枝对多数人而言是奢侈品，甚至成为了诗人笔下劳民伤财的典范：“一骑红尘妃子笑，无人知是荔枝来”。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;△ 你能认出这些品种的区别么？&lt;/div&gt;
&lt;div&gt;如今时代，虽然凭借着便捷的物流网络，它已经成为了全国各地食客们触手可及的盘中餐，但是，我始终耿耿于怀，因为我知道，它的味道不对。&lt;/div&gt;
&lt;div&gt;为了保鲜，商家们会给荔枝覆上冰块，然而，这几乎抹掉了荔枝天然的馨馨果香。因为气味不对，所以味道也不对。&lt;/div&gt;
&lt;div&gt;我难以确切地描绘那是一种什么气味，但是，随便在超市买一瓶荔枝味的饮料，都比买到的荔枝闻起来更像荔枝。那不是普通的水果香，而是特有的荔枝香。&lt;/div&gt;
&lt;div&gt;对于香味的记忆，我有一种很奇妙的认知。去年端午节前不久的一天，我在下班回到小区外时，突然闻到了一股久违了十年的香味，一下子就认出了那是粽子刚刚煮好出锅时的香味！&lt;/div&gt;
&lt;div&gt;我家乡（广东茂名）那边用来包裹咸粽子的叶子是簕古叶，周身细长，叶边和叶脊上长满了锯齿样的尖刺。我所熟悉的那股粽子香大概跟这种植物有关（一直这样以为，但实际可能是用了某种香料），而且粽香跟荔枝香一样，在离开诞生地后就会快速消散，二次加热也难再催生。&lt;/div&gt;
&lt;div&gt;所以，当在苏州突然闻到那阵浓浓的粽子香时，我很是意外和恍惚。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;△ 布满刺的簕古叶&lt;/div&gt;
&lt;div&gt;粽子香激发了我的食欲，让我渴望吃到家乡的那种粽子。于是，十多年在外地过端午节的我，第一次在电话里让妈妈寄粽子。吃着带有熟悉的香味的粽子，尽管那味清淡，我却觉得满足。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;△ 刚拆出快递的家乡粽子&lt;/div&gt;
&lt;div&gt;气味让人记忆深刻，然而它只有短暂的保质期，不能像清风明月般，取之不尽用之不竭。独特和稀缺产生了意义，有时候仿佛没有了这捉摸不得的气，就损害了那形质完整的物。仿佛没了香味，粽子就不再是粽子，荔枝也不再是荔枝。&lt;/div&gt;
&lt;div&gt;我觉得荔枝的味道不对，还有一个原因是发现它的成熟度不够。熟透了的水果难以保存和运输，因此市面上很多水果都是半生摘后催熟的，比如芒果、菠萝蜜、香蕉和桃子。&lt;/div&gt;
&lt;div&gt;五六成熟的荔枝不影响商家们倾销市场，八九成熟的荔枝也有着不错的口感，然而，我最想念的是那些熟透了红透了甜胀了的荔枝。前两者易得，后一者难求。&lt;/div&gt;
&lt;div&gt;成熟度能严重地影响水果的味道，有些人可能吃不出来区别，或者更喜欢那样的风味，然而我却很挑剔，就像吃牛排只吃十成熟，吃水果也挑食。&lt;/div&gt;
&lt;div&gt;不在水果的种植地，就很难吃到最香最熟的水果。童年的一些生活经历让我记忆深刻，而且一直影响着我的饮食习惯。&lt;/div&gt;
&lt;div&gt;小时候，我家门前的园子里种了两棵芒果树，经常大丰收，硕果满枝。兄弟几人最大的乐趣就是去摇晃果树，然后瓜分掉落下来的新鲜美味。果熟蒂落，异常可口。&lt;/div&gt;
&lt;div&gt;在家门口不远的山上，我们家种有二三十棵荔枝树。有一年收成不错，我带着表哥表嫂们到了那片果林，大有一种孙悟空进入了蟠桃园的肆意。&lt;/div&gt;
&lt;div&gt;晴天中午的阳光把荔枝晒得格外地红，新摘下时还带着暖热，浓郁果香混着被折枝叶的树香，入口难忘，汁水爆留在手，甜味终日不散。&lt;/div&gt;
&lt;div&gt;当到了荔枝季末尾的时候，小孩们会组队去别人的果园里捡漏，攀爬寻觅。有些特立独行的荔枝长在枝叶丛掩盖的暗处，熟得很彻底，红得很彻底，幸运的话还胖得很彻底，每当遇到，就好似中了大奖。&lt;/div&gt;
&lt;div&gt;有了这样的经历，当提到“荔枝”这个词的时候，它在我脑子里的形象就跟大多数人完全不相同了，也就像同样提到“猫”这个词，养猫人和没养过猫的人，所联想出的内涵肯定不同。&lt;/div&gt;
&lt;div&gt;气味和熟度成了我评判荔枝好坏时不可或缺的标准。童年的食物和记忆对一个人的影响，潜移默化，在很多年以后，你可能会突然发现它们，就品出了莫名的况味来。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;△ 发芽的荔枝种子&lt;/div&gt;
&lt;div&gt;关于荔枝，我还有一个非常难忘的记忆片段。那时候我年龄很小，对于自然事物的演变还知之甚少，对于自然之美似乎刚开了朦胧的智。&lt;/div&gt;
&lt;div&gt;有一天清晨跟着妈妈在菜园里，我无意中掀起了一片树枝架子，突然就被一个东西强烈地吸引住了：一棵光滑的枣红色荔枝种子浅浅地侧埋在沙土里，须白的嫩根探钻入地，一株树苗长长直直，顶上撑开了几片粉嘟嘟的叶子，那和谐的色彩组合以及直立的平衡对称，一下子就把我全部的注意力定格了。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;△ 新生的荔枝苗&lt;/div&gt;
&lt;div&gt;当年幼小的我被同样幼小的荔枝苗打开了见识的新天地，对于什么是美的观念也开始在我的心中生根发芽。&lt;/div&gt;
&lt;div&gt;我记得那荔枝的品种是黑叶，种子总是很饱满，只要条件允许，就总能生根发芽。但是，由于种子大，它也极容易遭致虫害，加之果肉若不是很熟就会带有微酸，所以，这些年来它应该快被淘汰了吧。如今，外地朋友们能吃到的荔枝，大部分皆是果核很小的人工培育品种。&lt;/div&gt;
&lt;div&gt;除了以上的几个记忆片段，仔细搜罗组织的话，我还能想起很多的事情，例如给荔枝树除草施肥、用叶子卷出口笛、抓捕荔枝椿象、观赏荔枝花……这些事情偶尔还会在我梦中激活重演。&lt;/div&gt;
&lt;div&gt;关于粽子和荔枝的话题，我在几年前就有了写作的念头，自从前年写了《蝉！蝉！蝉！》之后，这个念头就更是难以冲散。去想那些体验，去写这些小事，到底有什么意义呢？我时常会想写作的动机，想以此来激发自己做事的动力。&lt;/div&gt;
&lt;div&gt;今年里吃了不少荔枝，虽然对味道仍有些不满足，我的口腹之欲却是满足了。每次吃荔枝的时候，它就在强化我的写作灵感，而豌豆就在一旁“煽风点火”。所以，我想，在今年的荔枝季节过去之前，该给荔枝一个交代了，也给自己一个交代。&lt;/div&gt;
&lt;div&gt;注：除了粽子图，其它图片来源于网络。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>坚持原创很难，但我不会放弃！</title>
            <link>https://pythoncat.top/posts/2021-05-26-writing/</link>
            <guid>https://pythoncat.top/posts/2021-05-26-writing/</guid>
            <pubDate>Wed, 26 May 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在最开始写公众号的时候，我几乎可以每周写三篇原创，后来，慢慢变成了一周一篇，再后来，演变成了两周一篇。在最近半年里，由于忙于其它事，这个原创周期变得非常漫长……&lt;/div&gt;
&lt;div&gt;在专门收集灵感、写作话题和翻译计划的未完成清单里，我罗列了至少 200 项内容，但是，大部分内容都难以动工。有些内容过于零散、有些内容过于浅显、有些内容过于冷门、有些内容我觉得能力难以把握、有些内容别人写过、有些内容需耗费很多时间精力……&lt;/div&gt;
&lt;div&gt;写公众号时间长了以后，我至少明白了一个道理：写文章不能自嗨，时时得考虑一下阅读者的观感，需要切中别人的痛点，需要让别人觉得这文章值得转载/分享。所以，坚持原创难，有一部分原因是“自我审查”。&lt;/div&gt;
&lt;div&gt;在运营公众号上，我相对于圈内比较熟的几个好友，算是非常的佛系了，总是在某些方面束手束脚。有的时候，我非常在乎订阅数和阅读量，当出现数据滑坡时，就会十分懊恼和不忿；但是，有的时候，明明可以尝试做一些改变（看到过很多运营套路），就可能获得一些改观，但我却又突然觉得不乐意做那些事，对这些数据不太在乎……所以，坚持原创难，有一部分原因是“死要面子活受罪”。&lt;/div&gt;
&lt;div&gt;在干扰原创方面，钱也是很关键的因素。技术公众号的广告金主非常多（但是最近半年不景气），广告中介更多，只要一个号的阅读上了小几百，就一定会有广告来约。在早期的一段时间里，我坚持着一个想法“不到一万订阅，不接广告”，因此，每当有广告来约，我的报价都超出阅读很多，以示婉拒。现实很骨感，达成万粉成就绝非易事（花了13个月）。&lt;/div&gt;
&lt;div&gt;我不记得自己从什么时候开始正式成为“恰饭号主”，不过初期还是很克制，一个月只排 2-3 次“恰饭”。有些软文的标题夸张不实，还有大部分的标题一眼就能看出是广告，所以，阅读量不高，严重拉低了数据的平均值。为了中和“恰饭”排期对读者的影响，为了有更好的数据来提升议价能力，转载文就多了起来。&lt;/div&gt;
&lt;div&gt;我不喜欢转载随处可见的文章，因为有一个稍微挑剔的选文标准（不从众、不贪多、获取第一手信息），而这导致我要花很多时间阅读、筛查、等授权和排版，其实占用了不少本可以用来写原创/翻译的时间。&lt;/div&gt;
&lt;div&gt;另外，还有一个很重要的干扰因素，那就是想要“涨粉”。当看到其他号主的量级突破消息，当看到自己辛苦原创或者翻译的文章，阅读量总在低位徘徊，你难免会动心思，也想要寻求一些突破。于是，互推、送书/送礼物、制作电子书、单推，各种运营手段都尝试一番。效果不能说是没有（比靠原创涨粉的效果好），但是收益越来越低，而负作用也日渐增加……&lt;/div&gt;
&lt;div&gt;干扰的因素有很多，坚持原创难啊。&lt;/div&gt;
&lt;div&gt;正因如此，我有时候就很佩服那些可以长期坚持原创的号主。比如，前不久来我们公众号里“作客”的 kingname 大佬（公众号：未闻Code），他已经写了五六年了，仍在源源不断地输出高质量的内容，已经积累下 400 篇原创。&lt;/div&gt;
&lt;div&gt;这么长的创作时间和可观的作品数量，在 Python 号圈里屈指可数，然而，要论佛系运营的话，他也是佛系的佼佼者：订阅数长期缓慢增长，阅读量也上不去，而且接广告的次数也非常非常少（最近半年有改观了，毕竟是领了证的男人，需要养家的 :）&lt;/div&gt;
&lt;div&gt;但凡你多关注几个技术号，绝对会认为 未闻Code 是少见的一股清流。虽然我前几天发了一篇商业互吹的文章，但估计很多同学都没点进去看，所以，我再隆重推荐你去关注一下。&lt;/div&gt;
&lt;div&gt;我关注了很多 Python 的号，知道一些能把原创+涨粉+恰饭几个方面都做得很好的号，但是，还知道有不少号只停留在第一项，或者曾经坚持过一段时间第一项，但已断更很久……&lt;/div&gt;
&lt;div&gt;在这里，我要友情推荐几个阅读量比较低，但更新比较稳定、且没有怎么发互推和恰饭的原创号吧（按照最近有发文的顺序）&lt;/div&gt;
&lt;div&gt;Python作业辅导员&lt;/div&gt;
&lt;div&gt;Python七号&lt;/div&gt;
&lt;div&gt;游戏不存在&lt;/div&gt;
&lt;div&gt;Python学会&lt;/div&gt;
&lt;div&gt;小菜学编程&lt;/div&gt;
&lt;div&gt;NLP奇幻之旅&lt;/div&gt;
&lt;div&gt;这些都是“小而美”的号，我都转载过他们的文章。另外，还有很多同样小而美的原创号，以后有机会再单独介绍吧。&lt;/div&gt;
&lt;div&gt;最后顺便提两组比较有意思的高质量原创号：piglei 和 Prodesire，两个号都是以“p”开头，而且公众号和作者微信号同名，一个在鹅厂一个在福报厂；懒编程 和 Manjusaka的编程屋，两个号都有“编程”，而且作者都活跃在我们的 1 号交流群里……&lt;/div&gt;
&lt;div&gt;在我写这篇文章的时候，猪哥（公众号：裸睡的猪）正好发起了“第二期Python优质原创号主评选活动”。Python猫曾有幸在第一期活动中被评为了第二名，但是，由于近半年的原创度严重降低，而优秀的原创号很多（群里已有 107 位作者），我们估计是排不进前十名了……&lt;/div&gt;
&lt;div&gt;在动笔写这篇文章的时候，我有些牢骚想发，虽然最终已尽量克制了许多，但难免还是透露出了一点点负能量……&lt;/div&gt;
&lt;div&gt;所以，最后给一个提升正能量的结尾吧：创作是一件非常值得持续投入的事情，如果你有写作的想法，赶紧行动起来吧；Python 原创圈子的氛围很赞，投稿与转载、讨论运营与恰饭、举办活动等等，写作可以不是一件孤军奋战的事，欢迎更多号主来结伴同行！&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python之父爆料：明年至少令 Python 提速 1 倍！</title>
            <link>https://pythoncat.top/posts/2021-05-16-Guido/</link>
            <guid>https://pythoncat.top/posts/2021-05-16-Guido/</guid>
            <pubDate>Sun, 16 May 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;大概在半年前，我偶然看到一篇文章，有人提出了给 Python 提速 5 倍的计划，并在寻找经费赞助。当时并没有在意，此后也没有看到这方面的消息。&lt;/div&gt;
&lt;div&gt;但是，就在 5 月 13 日“2021 年 Python 语言峰会”上，Python 之父 Guido van Rossum 作了一场《&lt;strong&gt;Making CPython Faster&lt;/strong&gt; 》的分享，他已经投入了这项计划！&lt;/div&gt;
&lt;div&gt;据 Guido 爆料，他因为“退休”无聊，申请加入了微软，因此组建起一个小团队。目前成员除了他还有两个：Eric Snow（Python 核心开发者之一、微软高级工程师）和 Mark Shannon（本文第一段那个计划的提出者，精通 Python 性能研究）。&lt;/div&gt;
&lt;div&gt;整个计划被称为“香农计划”（即“Shannon Plan”，得名于提出者），期望花 4 年时间把 Python 提速 5 倍，即每年 1.5 倍。现在短期的计划是在 Python 3.11 版本中实现至少提速 1 倍。&lt;/div&gt;
&lt;div&gt;按照官方的发布周期，今年 10 月会发布 3.10 版本，而 3.11 版本将在 2022 年 10 月发布。&lt;/div&gt;
&lt;div&gt;怎么做到令 3.11 版本提速一倍呢？&lt;/div&gt;
&lt;div&gt;根据 Guido 的分享，第一项优化工作是“适应性的、专门的字节码解释器”，相关的设想已经起草到 PEP-659 中：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;其它的优化内容还有：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;优化帧堆栈，更快的调用，调整分配（ optimize frame stack, faster calls, tweak allocation）&lt;/li&gt;
&lt;li&gt;“零开销”异常处理（“Zero overhead” exception handling）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;以及这些工作：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这些优化工作都要在不破坏接口兼容性的前提下实现，同时还要保持代码的可维护性。&lt;/div&gt;
&lt;div&gt;在 Guido 的分享中，还有很多细节内容。在这里，我们把完整的分享材料贴一下吧。（原文件是 PDF 版本，可在“Python猫”后台回复数字“0516”下载 ）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>为什么 Python 的 f-string 可以连接字符串与数字？</title>
            <link>https://pythoncat.top/posts/2021-02-19-fstring/</link>
            <guid>https://pythoncat.top/posts/2021-02-19-fstring/</guid>
            <pubDate>Fri, 19 Feb 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;本文出自&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;Python为什么&lt;/a&gt;系列，归档在 Github 上。&lt;/div&gt;
&lt;div&gt;毫无疑问，Python 是一门&lt;strong&gt;强类型&lt;/strong&gt;语言。&lt;strong&gt;强类型&lt;/strong&gt;语言。&lt;strong&gt;强类型&lt;/strong&gt;语言！（关于强弱类型话题，推荐阅读这篇 &lt;a href=&quot;https://mp.weixin.qq.com/s/GRq8Hg4jqIzCglHRdrWtww&quot;&gt;技术科普文&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;这就意味着，不同类型的对象通常需要先做&lt;strong&gt;显式地类型转化，&lt;/strong&gt; 然后才能进行某些操作。&lt;/div&gt;
&lt;div&gt;下面以字符串和数字为例，看看强行操作会产生什么结果：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&quot;Python猫&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;666&lt;/span&gt;
Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  File &lt;span&gt;&quot;&amp;lt;stdin&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; line &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;module&lt;span&gt;&amp;gt;&lt;/span&gt;
TypeError&lt;span&gt;:&lt;/span&gt; can only concatenate &lt;span&gt;str&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;not&lt;/span&gt; &lt;span&gt;&quot;int&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; to &lt;span&gt;str&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;它报类型错误了（TypeError），&lt;strong&gt;说字符串只能连接（concatenate）字符串，不能连接 int 类型。&lt;/strong&gt; 这正是强类型语言的基本约束。&lt;/div&gt;
&lt;div&gt;但是，如果我们先把数字“转化”成字符串类型，再执行“+”操作，就不会报错了：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&quot;Python猫&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;666&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&apos;Python猫666&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上面的这个例子，对读者们来说，应该并不难理解。&lt;/div&gt;
&lt;div&gt;由此，我们要引出一个问题：&lt;strong&gt;如何在不作显式类型转化的情况下，进行字符串与数字类型的拼接呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;在《&lt;a href=&quot;https://mp.weixin.qq.com/s/Whrd6NiD4Y2Z-YSCy4XJ1w&quot;&gt;详解Python拼接字符串的七种方式&lt;/a&gt;》这篇文章中，它梳理了七种拼接字符串的写法，我们可以逐个来试验一下。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;几种字符串拼接方式：&lt;/p&gt;
&lt;p&gt;1、格式化类：%、format()、template&lt;/p&gt;
&lt;p&gt;2、拼接类：+、()、join()&lt;/p&gt;
&lt;p&gt;3、插值类：f-string&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;为了节省篇幅，此处直接把可以顺利拼接的 4 种写法罗列如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&quot;%s %d&quot;&lt;/span&gt; &lt;span&gt;%&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Python猫&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;666&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&apos;Python猫 666&apos;&lt;/span&gt;

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; string &lt;span&gt;import&lt;/span&gt; Template
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; s &lt;span&gt;=&lt;/span&gt; Template&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;${s1}${s2}&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; s&lt;span&gt;.&lt;/span&gt;safe_substitute&lt;span&gt;(&lt;/span&gt;s1&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;Python猫&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;s2&lt;span&gt;=&lt;/span&gt;&lt;span&gt;666&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&apos;Python猫666&apos;&lt;/span&gt;

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&quot;Python猫{}&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;666&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&apos;Python猫666&apos;&lt;/span&gt;

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; num &lt;span&gt;=&lt;/span&gt; &lt;span&gt;666&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;f&quot;Python猫&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;num&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&apos;Python猫666&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;第一种写法（即 % 格式化）来自古老的 C 语言，其中的“%d”是一个占位符，表示它将要接收一个整数，并格式化成字符串。&lt;/div&gt;
&lt;div&gt;第二和第三种写法，它们是第一种写法的升级版，不同的是，它们的占位符是通用型的，不必指定“%s”、“%d”等等明确的类型。这两种写法中，数字类型的参数被传给特定的格式化方法（即 safe_substitute 与 format），在这些方法的内部，它们会作类型转化处理。&lt;/div&gt;
&lt;div&gt;可以说，上述三种写法都不难理解，它们的意图都有迹可循。&lt;/div&gt;
&lt;div&gt;但是，现在再看看最后一种写法，也就是 f-string 写法，似乎就不是那么明显了。&lt;/div&gt;
&lt;div&gt;首先，在字符串内部，它并没有像“%格式化”那样指定占位符的类型；其次，所要拼接的数字并没有作为任何函数的参数来传递。&lt;/div&gt;
&lt;div&gt;也就是说，在明面上根本看不出任何要作类型转化的意图。但是，由于我们已知 Python 是强类型语言，已知数字类型绝对不可能直接拼接到字符串里，因此，&lt;strong&gt;只能说明 f-string 语法在底层作了某种类型转化的操作！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;那么，我们就可以再提出一个新的问题：&lt;strong&gt;f-string 语法在处理字符串与数字时，是如何实现数字的类型转化的呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;也许有的读者会猜想它是调用了内置的 str() 或 repr()（或它们对应的魔术方法__str__() 与 __repr__()），从而实现类型转化，但是，答案并没有如此简单！&lt;/div&gt;
&lt;div&gt;f-string 语法是在 Python 3.6 版本引入的。为了省事，我们直接找到 PEP-498 文档，在里面查阅看是否有关于实现原理的线索。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;文档地址：&lt;a href=&quot;https://www.python.org/dev/peps/pep-0498&quot;&gt;https://www.python.org/dev/peps/pep-0498&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PEP 里提到，f-string 的语法格式是这样的：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;f&apos;&amp;lt;text&amp;gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;expression&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;optional !s&lt;span&gt;,&lt;/span&gt; !r&lt;span&gt;,&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; !a&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;optional &lt;span&gt;:&lt;/span&gt;&lt;span&gt; format specifier&amp;gt; &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &amp;lt;text&amp;gt; ...&apos;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;其中，花括号里的内容就是要作格式化的内容，除去可选的“optional”部分后，“expression”部分就是真正要处理的内容。对应前文的例子，数字 666 就是一个 expression。&lt;/div&gt;
&lt;div&gt;expression 会按 __format__ 协议进行格式化，但是并不会直接调用 __format__() 这个方法。&lt;/div&gt;
&lt;div&gt;文档上指出，&lt;strong&gt;实际的执行过程等效于&lt;code&gt;type(value).__format__(value, format_spec)&lt;/code&gt; 或者  &lt;code&gt;format(value, format_spec)&lt;/code&gt; 。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;事实上，字符串对象的 foramt() 方法跟 Python 内置的 foramt() 函数，它们都会调用__format__() 魔术方法，所以，&lt;strong&gt;f-string 其实是前文中 format() 格式化写法的升级版。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;在默认情况下，&lt;code&gt;format_spec&lt;/code&gt; 是一个空字符串，而&lt;code&gt;format(value, &quot;&quot;)&lt;/code&gt; 的效果等同于&lt;code&gt;str(value)&lt;/code&gt; ，因此，在不指定其它 format_spec 的情况下，&lt;strong&gt;可以简单地认为 f-string 就是调用了 str() 来作的类型转化……&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;至此，我们看到了 f-string 的实现原理，明白了它在拼接字符串与数字时，效果等效于前文的 format() 格式化方法，也等效于使用 str() 进行类型转化。&lt;/div&gt;
&lt;div&gt;写在最后：本文属于“&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;Python为什么&lt;/a&gt;”系列（Python猫出品），该系列主要关注 Python 的语法、设计和发展等话题，以一个个“为什么”式的问题为切入点，试着展现 Python 的迷人魅力。更多精彩文章，请移步 Github 查看，项目地址：&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;https://github.com/chinesehuazhou/python-whydo&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>深入 Python 解释器源码，我终于搞明白了字符串驻留的原理！</title>
            <link>https://pythoncat.top/posts/2021-02-15-intern/</link>
            <guid>https://pythoncat.top/posts/2021-02-15-intern/</guid>
            <pubDate>Mon, 15 Feb 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;英文：&lt;a href=&quot;https://arpitbhayani.me/blogs/string-interning&quot;&gt;https://arpitbhayani.me/blogs/string-interning&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者：arpit&lt;/div&gt;
&lt;div&gt;译者：豌豆花下猫（“Python猫”公众号作者）&lt;/div&gt;
&lt;div&gt;声明：本翻译是出于交流学习的目的，基于 CC BY-NC-SA 4.0 授权协议。为便于阅读，内容略有改动。&lt;/div&gt;
&lt;div&gt;每种编程语言为了表现出色，并且实现卓越的性能，都需要有大量编译器级与解释器级的优化。&lt;/div&gt;
&lt;div&gt;由于字符串是任何编程语言中不可或缺的一个部分，因此，如果有快速操作字符串的能力，就可以迅速地提高整体的性能。&lt;/div&gt;
&lt;div&gt;在本文中，&lt;strong&gt;我们将深入研究 Python 的内部实现，并了解 Python 如何使用一种名为字符串驻留（&lt;a href=&quot;https://en.wikipedia.org/wiki/String_interning&quot;&gt;String Interning&lt;/a&gt;）的技术，实现解释器的高性能。&lt;/strong&gt; 本文的目的不仅在于介绍 Python 的内部知识，而且还旨在使读者能够轻松地浏览 Python 的源代码；因此，本文中将有很多出自 &lt;a href=&quot;https://github.com/python/cpython/&quot;&gt;CPython&lt;/a&gt; 的代码片段。&lt;/div&gt;
&lt;div&gt;全文提纲如下：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;（在 &lt;strong&gt;Python猫&lt;/strong&gt; 公众号回复数字“0215”，下载高清思维导图）&lt;/div&gt;
&lt;h2&gt;1、什么是“字符串驻留”？&lt;/h2&gt;
&lt;div&gt;&lt;strong&gt;字符串驻留是一种编译器/解释器的优化方法，它通过&lt;code&gt;缓存&lt;/code&gt;一般性的字符串，从而节省字符串处理任务的空间和时间。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;这种优化方法不会每次都创建一个新的字符串副本，而是仅为每个&lt;em&gt;适当的&lt;/em&gt;不可变值保留一个字符串副本，并使用指针引用之。&lt;/div&gt;
&lt;div&gt;每个字符串的唯一拷贝被称为它的&lt;code&gt;intern&lt;/code&gt;，并因此而得名 String Interning。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Python猫注：String Interning 一般被译为“字符串驻留”或“字符串留用”，在某些语言中可能习惯用 String Pool（字符串常量池）的概念，其实是对同一种机制的不同表述。intern 作为名词时，是“实习生、实习医生”的意思，在此可以理解成“驻留物、驻留值”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;查找字符串 intern 的方法可能作为公开接口公开，也可能不公开。现代编程语言如 Java、Python、PHP、Ruby、Julia 等等，都支持字符串驻留，以使其编译器和解释器做到高性能。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;2、为什么要驻留字符串？&lt;/h2&gt;
&lt;div&gt;&lt;strong&gt;字符串驻留提升了字符串比较的速度。&lt;/strong&gt; 如果没有驻留，当我们要比较两个字符串是否相等时，它的时间复杂度将上升到 O(n)，即需要检查两个字符串中的每个字符，才能判断出它们是否相等。&lt;/div&gt;
&lt;div&gt;但是，如果字符串是固定的，由于相同的字符串将使用同一个对象引用，因此只需检查指针是否相同，就足以判断出两个字符串是否相等，不必再逐一检查每个字符。由于这是一个非常普遍的操作，因此，它被典型地实现为指针相等性校验，仅使用一条完全没有内存引用的机器指令。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;字符串驻留减少了内存占用。&lt;/strong&gt; Python 避免内存中充斥多余的字符串对象，通过&lt;a href=&quot;https://en.wikipedia.org/wiki/Flyweight_pattern&quot;&gt;&lt;code&gt;享元设计模式&lt;/code&gt;&lt;/a&gt;共享和重用已经定义的对象，从而优化内存占用。&lt;/div&gt;
&lt;h2&gt;3、Python的字符串驻留&lt;/h2&gt;
&lt;div&gt;像大多数其它现代编程语言一样，Python 也使用字符串驻留来提高性能。在 Python 中，我们可以使用&lt;code&gt;is&lt;/code&gt;运算符，检查两个对象是否引用了同一个内存对象。&lt;/div&gt;
&lt;div&gt;因此，如果两个字符串对象引用了相同的内存对象，则&lt;code&gt;is&lt;/code&gt;运算符将得出&lt;code&gt;True&lt;/code&gt;，否则为&lt;code&gt;False&lt;/code&gt;。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&apos;python&apos;&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;&apos;python&apos;&lt;/span&gt;
&lt;span&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我们可以使用这个特定的运算符，来判断哪些字符串是被驻留的。在 CPython 的，字符串驻留是通过以下函数实现的，声明在 unicodeobject.h 中，定义在 unicodeobject.c 中。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;PyAPI_FUNC&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;PyUnicode_InternInPlace&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;PyObject &lt;span&gt;*&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;为了检查一个字符串是否被驻留，CPython 实现了一个名为&lt;code&gt;PyUnicode_CHECK_INTERNED&lt;/code&gt;的宏，同样是定义在 unicodeobject.h 中。&lt;/div&gt;
&lt;div&gt;这个宏表明了 Python 在&lt;code&gt;PyASCIIObject&lt;/code&gt;结构中维护着一个名为&lt;code&gt;interned&lt;/code&gt;的成员变量，它的值表示相应的字符串是否被驻留。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;define&lt;/span&gt; &lt;span&gt;PyUnicode_CHECK_INTERNED&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;op&lt;span&gt;)&lt;/span&gt; &lt;/span&gt;&lt;span&gt;\&lt;/span&gt;
    &lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;PyASCIIObject &lt;span&gt;*&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;op&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;state&lt;span&gt;.&lt;/span&gt;interned&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;4、字符串驻留的原理&lt;/h2&gt;
&lt;div&gt;&lt;strong&gt;在 CPython 中，字符串的引用被一个名为&lt;code&gt;interned&lt;/code&gt;的 Python 字典所存储、访问和管理。&lt;/strong&gt; 该字典在第一次调用字符串驻留时，被延迟地初始化，并持有全部已驻留字符串对象的引用。&lt;/div&gt;
&lt;h3&gt;4.1 如何驻留字符串？&lt;/h3&gt;
&lt;div&gt;负责驻留字符串的核心函数是&lt;code&gt;PyUnicode_InternInPlace&lt;/code&gt;，它定义在 unicodeobject.c 中，当调用时，它会创建一个准备容纳所有驻留的字符串的字典&lt;code&gt;interned&lt;/code&gt;，然后登记入参中的对象，令其键和值都使用相同的对象引用。&lt;/div&gt;
&lt;div&gt;以下函数片段显示了 Python 实现字符串驻留的过程。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;void&lt;/span&gt;
&lt;span&gt;PyUnicode_InternInPlace&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;PyObject &lt;span&gt;*&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;p&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;
    PyObject &lt;span&gt;*&lt;/span&gt;s &lt;span&gt;=&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;p&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

    &lt;span&gt;// Lazily build the dictionary to hold interned Strings&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;interned &lt;span&gt;==&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        interned &lt;span&gt;=&lt;/span&gt; &lt;span&gt;PyDict_New&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;interned &lt;span&gt;==&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;PyErr_Clear&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    PyObject &lt;span&gt;*&lt;/span&gt;t&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;// Make an entry to the interned dictionary for the&lt;/span&gt;
    &lt;span&gt;// given object&lt;/span&gt;
    t &lt;span&gt;=&lt;/span&gt; &lt;span&gt;PyDict_SetDefault&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;interned&lt;span&gt;,&lt;/span&gt; s&lt;span&gt;,&lt;/span&gt; s&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
    
    &lt;span&gt;// The two references in interned dict (key and value) are&lt;/span&gt;
    &lt;span&gt;// not counted by refcnt.&lt;/span&gt;
    &lt;span&gt;// unicode_dealloc() and _PyUnicode_ClearInterned() take&lt;/span&gt;
    &lt;span&gt;// care of this.&lt;/span&gt;
    &lt;span&gt;Py_SET_REFCNT&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Py_REFCNT&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;// Set the state of the string to be INTERNED&lt;/span&gt;
    &lt;span&gt;_PyUnicode_STATE&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;interned &lt;span&gt;=&lt;/span&gt; SSTATE_INTERNED_MORTAL&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;4.2 如何清理驻留的字符串？&lt;/h3&gt;
&lt;div&gt;清理函数从&lt;code&gt;interned&lt;/code&gt;字典中遍历所有的字符串，调整这些对象的引用计数，并把它们标记为&lt;code&gt;NOT_INTERNED&lt;/code&gt;，使其被垃圾回收。一旦所有的字符串都被标记为&lt;code&gt;NOT_INTERNED&lt;/code&gt;，则&lt;code&gt;interned&lt;/code&gt;字典会被清空并删除。&lt;/div&gt;
&lt;div&gt;这个清理函数就是&lt;code&gt;_PyUnicode_ClearInterned&lt;/code&gt;，在&lt;a href=&quot;https://github.com/python/cpython/blob/master/Objects/unicodeobject.c&quot;&gt; unicodeobject.c 中&lt;/a&gt;定义。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;void&lt;/span&gt;
&lt;span&gt;_PyUnicode_ClearInterned&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;PyThreadState &lt;span&gt;*&lt;/span&gt;tstate&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

    &lt;span&gt;// Get all the keys to the interned dictionary&lt;/span&gt;
    PyObject &lt;span&gt;*&lt;/span&gt;keys &lt;span&gt;=&lt;/span&gt; &lt;span&gt;PyDict_Keys&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;interned&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

    &lt;span&gt;// Interned Unicode strings are not forcibly deallocated;&lt;/span&gt;
    &lt;span&gt;// rather, we give them their stolen references back&lt;/span&gt;
    &lt;span&gt;// and then clear and DECREF the interned dict.&lt;/span&gt;

    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;Py_ssize_t i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; n&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        PyObject &lt;span&gt;*&lt;/span&gt;s &lt;span&gt;=&lt;/span&gt; &lt;span&gt;PyList_GET_ITEM&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;keys&lt;span&gt;,&lt;/span&gt; i&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

        &lt;span&gt;switch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;PyUnicode_CHECK_INTERNED&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;case&lt;/span&gt; SSTATE_INTERNED_IMMORTAL&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;Py_SET_REFCNT&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Py_REFCNT&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;case&lt;/span&gt; SSTATE_INTERNED_MORTAL&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;// Restore the two references (key and value) ignored&lt;/span&gt;
            &lt;span&gt;// by PyUnicode_InternInPlace().&lt;/span&gt;
            &lt;span&gt;Py_SET_REFCNT&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Py_REFCNT&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;case&lt;/span&gt; SSTATE_NOT_INTERNED&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;/* fall through */&lt;/span&gt;
        &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;Py_UNREACHABLE&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// marking the string to be NOT_INTERNED&lt;/span&gt;
        &lt;span&gt;_PyUnicode_STATE&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;interned &lt;span&gt;=&lt;/span&gt; SSTATE_NOT_INTERNED&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;// decreasing the reference to the initialized and&lt;/span&gt;
    &lt;span&gt;// access keys object.&lt;/span&gt;
    &lt;span&gt;Py_DECREF&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;keys&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;// clearing the dictionary&lt;/span&gt;
    &lt;span&gt;PyDict_Clear&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;interned&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;// clearing the object interned&lt;/span&gt;
    &lt;span&gt;Py_CLEAR&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;interned&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;5、字符串驻留的实现&lt;/h2&gt;
&lt;div&gt;既然了解了字符串驻留及清理的内部原理，我们就可以找出 Python 中所有会被驻留的字符串。&lt;/div&gt;
&lt;div&gt;为了做到这点，我们要做的就是在 CPython 源代码中查找&lt;code&gt;PyUnicode_InternInPlace&lt;/code&gt; 函数的调用，并查看其附近的代码。下面是在 Python 中关于字符串驻留的一些有趣的发现。&lt;/div&gt;
&lt;h3&gt;5.1 变量、常量与函数名&lt;/h3&gt;
&lt;div&gt;&lt;strong&gt;CPython 对常量（例如函数名、变量名、字符串字面量等）执行字符串驻留。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;以下代码出自&lt;a href=&quot;https://github.com/python/cpython/blob/master/Objects/codeobject.c&quot;&gt;codeobject.c&lt;/a&gt;，它表明在创建新的&lt;code&gt;PyCode&lt;/code&gt;对象时，解释器将对所有编译期的常量、名称和字面量进行驻留。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;PyCodeObject &lt;span&gt;*&lt;/span&gt;
&lt;span&gt;PyCode_NewWithPosOnlyArgs&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; argcount&lt;span&gt;,&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; posonlyargcount&lt;span&gt;,&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; kwonlyargcount&lt;span&gt;,&lt;/span&gt;
                          &lt;span&gt;int&lt;/span&gt; nlocals&lt;span&gt;,&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; stacksize&lt;span&gt;,&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; flags&lt;span&gt;,&lt;/span&gt;
                          PyObject &lt;span&gt;*&lt;/span&gt;code&lt;span&gt;,&lt;/span&gt; PyObject &lt;span&gt;*&lt;/span&gt;consts&lt;span&gt;,&lt;/span&gt; PyObject &lt;span&gt;*&lt;/span&gt;names&lt;span&gt;,&lt;/span&gt;
                          PyObject &lt;span&gt;*&lt;/span&gt;varnames&lt;span&gt;,&lt;/span&gt; PyObject &lt;span&gt;*&lt;/span&gt;freevars&lt;span&gt;,&lt;/span&gt; PyObject &lt;span&gt;*&lt;/span&gt;cellvars&lt;span&gt;,&lt;/span&gt;
                          PyObject &lt;span&gt;*&lt;/span&gt;filename&lt;span&gt;,&lt;/span&gt; PyObject &lt;span&gt;*&lt;/span&gt;name&lt;span&gt;,&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; firstlineno&lt;span&gt;,&lt;/span&gt;
                          PyObject &lt;span&gt;*&lt;/span&gt;linetable&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;intern_strings&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;names&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;intern_strings&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;varnames&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;intern_strings&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;freevars&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;intern_strings&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;cellvars&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;intern_string_constants&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;consts&lt;span&gt;,&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;5.2 字典的键&lt;/h3&gt;
&lt;div&gt;&lt;strong&gt;CPython 还会驻留任何字典对象的字符串键。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;当在字典中插入元素时，解释器会对该元素的键作字符串驻留。以下代码出自 &lt;a href=&quot;https://github.com/python/cpython/blob/master/Objects/dictobject.c&quot;&gt;dictobject.c，&lt;/a&gt;展示了实际的行为。&lt;/div&gt;
&lt;div&gt;有趣的地方：在&lt;code&gt;PyUnicode_InternInPlace&lt;/code&gt;函数被调用处有一条注释，它问道，我们是否真的需要对所有字典中的全部键进行驻留？&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt;
&lt;span&gt;PyDict_SetItemString&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;PyObject &lt;span&gt;*&lt;/span&gt;v&lt;span&gt;,&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; PyObject &lt;span&gt;*&lt;/span&gt;item&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;
    PyObject &lt;span&gt;*&lt;/span&gt;kv&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; err&lt;span&gt;;&lt;/span&gt;
    kv &lt;span&gt;=&lt;/span&gt; &lt;span&gt;PyUnicode_FromString&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;kv &lt;span&gt;==&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;// Invoking String Interning on the key&lt;/span&gt;
    &lt;span&gt;PyUnicode_InternInPlace&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;kv&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;/* XXX Should we really? */&lt;/span&gt;

    err &lt;span&gt;=&lt;/span&gt; &lt;span&gt;PyDict_SetItem&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;v&lt;span&gt;,&lt;/span&gt; kv&lt;span&gt;,&lt;/span&gt; item&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;Py_DECREF&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;kv&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; err&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;5.3 任何对象的属性&lt;/h3&gt;
&lt;div&gt;Python 中对象的属性可以通过&lt;code&gt;setattr&lt;/code&gt;函数显式地设置，也可以作为类成员的一部分而隐式地设置，或者在其数据类型中预定义。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;CPython 会驻留所有这些属性名，以便实现快速查找。&lt;/strong&gt; 以下是函数&lt;code&gt;PyObject_SetAttr&lt;/code&gt;的代码片段，该函数定义在文件&lt;a href=&quot;https://github.com/python/cpython/blob/master/Objects/object.c&quot;&gt;object.c中&lt;/a&gt;，负责为 Python 对象设置新属性。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt;
&lt;span&gt;PyObject_SetAttr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;PyObject &lt;span&gt;*&lt;/span&gt;v&lt;span&gt;,&lt;/span&gt; PyObject &lt;span&gt;*&lt;/span&gt;name&lt;span&gt;,&lt;/span&gt; PyObject &lt;span&gt;*&lt;/span&gt;value&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

    &lt;span&gt;PyUnicode_InternInPlace&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;name&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;5.4 显式地驻留&lt;/h3&gt;
&lt;div&gt;&lt;strong&gt;Python 还支持通过&lt;code&gt;sys&lt;/code&gt;模块中的&lt;code&gt;intern&lt;/code&gt;函数进行显式地字符串驻留。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;当使用任何字符串对象调用此函数时，该字符串对象将被驻留。以下是 &lt;a href=&quot;https://github.com/python/cpython/blob/master/Python/sysmodule.c&quot;&gt;sysmodule.c&lt;/a&gt; 文件的代码片段，它展示了在&lt;code&gt;sys_intern_impl&lt;/code&gt;函数中的字符串驻留过程。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; PyObject &lt;span&gt;*&lt;/span&gt;
&lt;span&gt;sys_intern_impl&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;PyObject &lt;span&gt;*&lt;/span&gt;module&lt;span&gt;,&lt;/span&gt; PyObject &lt;span&gt;*&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;PyUnicode_CheckExact&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;Py_INCREF&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;PyUnicode_InternInPlace&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; s&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;6、字符串驻留的其它发现&lt;/h2&gt;
&lt;div&gt;&lt;strong&gt;只有编译期的字符串会被驻留。&lt;/strong&gt; 在解释时或编译时指定的字符串会被驻留，而动态创建的字符串则不会。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Python猫注：这一条规则值得展开思考，我曾经在上面踩过坑……有两个知识点，我相信 99% 的人都不知道：字符串的 join() 方法是动态创建字符串，因此其创建的字符串不会被驻留；&lt;a href=&quot;https://mp.weixin.qq.com/s/p1Zb_linFLWwPlNyA5Ui1Q&quot;&gt;常量折叠机制&lt;/a&gt;也发生在编译期，因此有时候容易把它跟字符串驻留搞混淆。推荐阅读《&lt;a href=&quot;https://mp.weixin.qq.com/s/M2uHVqaHe_nyO5jT60V_6Q&quot;&gt;join()方法的神奇用处与Intern机制的软肋&lt;/a&gt;》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;&lt;strong&gt;包含 ASCII 字符和下划线的字符串会被驻留。&lt;/strong&gt; 在编译期间，当对字符串字面量进行驻留时，&lt;a href=&quot;https://github.com/python/cpython/blob/master/Objects/codeobject.c&quot;&gt;CPython&lt;/a&gt; 确保仅对匹配正则表达式&lt;code&gt;[a-zA-Z0-9_]*&lt;/code&gt;的常量进行驻留，因为它们非常贴近于 Python 的标识符。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Python猫注：关于 Python 中标识符的命名规则，在 Python2 版本只有“字母、数字和下划线”，但在 Python 3.x 版本中，已经支持 Unicode 编码。这部分内容推荐阅读《&lt;a href=&quot;https://mp.weixin.qq.com/s/eaxlo71sN4JRnBiPNBxKzQ&quot;&gt;醒醒！Python已经支持中文变量名啦！&lt;/a&gt;》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;参考材料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;字符串驻留(&lt;a href=&quot;https://en.wikipedia.org/wiki/String_interning&quot;&gt;https://en.wikipedia.org/wiki/String_interning&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;CPython优化(&lt;a href=&quot;https://stummjr.org/post/cpython-optimizations/&quot;&gt;https://stummjr.org/post/cpython-optimizations/&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Python对象第三部分：字符串驻留(&lt;a href=&quot;https://medium.com/@bdov_/https-medium-com-bdov-python-objects-part-iii-string-interning-625d3c7319de&quot;&gt;https://medium.com/@bdov_/https-medium-com-bdov-python-objects-part-iii-string-interning-625d3c7319de&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Python字符串驻留的内部原理(&lt;a href=&quot;http://guilload.com/python-string-interning/&quot;&gt;http://guilload.com/python-string-interning/&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Python优化机制：常量折叠(&lt;a href=&quot;https://mp.weixin.qq.com/s/p1Zb_linFLWwPlNyA5Ui1Q&quot;&gt;https://mp.weixin.qq.com/s/p1Zb_linFLWwPlNyA5Ui1Q&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;join()方法的神奇用处与Intern机制的软肋(&lt;a href=&quot;https://mp.weixin.qq.com/s/M2uHVqaHe_nyO5jT60V_6Q&quot;&gt;https://mp.weixin.qq.com/s/M2uHVqaHe_nyO5jT60V_6Q&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 优化机制：常量折叠</title>
            <link>https://pythoncat.top/posts/2021-02-12-constant/</link>
            <guid>https://pythoncat.top/posts/2021-02-12-constant/</guid>
            <pubDate>Fri, 12 Feb 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;英文：&lt;a href=&quot;https://arpitbhayani.me/blogs/constant-folding-python&quot;&gt;Constant Folding in Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者：arprit&lt;/div&gt;
&lt;div&gt;译者：豌豆花下猫（“Python猫”公众号作者）&lt;/div&gt;
&lt;div&gt;声明：本翻译是出于交流学习的目的，基于 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt; 授权协议。为便于阅读，内容略有改动。&lt;/div&gt;
&lt;div&gt;每种编程语言为了表现出色，并且实现卓越的性能，都需要大量编译器级的优化。&lt;/div&gt;
&lt;div&gt;一种著名的优化技术是“&lt;code&gt;常量折叠&lt;/code&gt;”（Constant Folding）：在编译期间，编译器会设法识别出常量表达式，对其进行求值，然后用求值的结果来替换表达式，从而使得运行时更精简。&lt;/div&gt;
&lt;div&gt;在本文中，&lt;strong&gt;我们深入探讨了什么是常量折叠，了解了它在 Python 世界中的适用范围，最后解读了 Python 的源代码（即 &lt;a href=&quot;https://github.com/python/cpython/&quot;&gt;CPython&lt;/a&gt;），并分析出 Python 是如何优雅地实现它。&lt;/strong&gt;&lt;/div&gt;
&lt;h2&gt;常量折叠&lt;/h2&gt;
&lt;div&gt;所谓常量折叠，指的是&lt;strong&gt;在编译时&lt;/strong&gt;就查找并计算常量表达式，而不是&lt;strong&gt;在运行时&lt;/strong&gt;再对其进行计算，从而会使运行时更加精简和快速。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; day_sec = 24 * 60 * 60&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;当编译器遇到一个常量表达式时，如上所述，它将对表达式求值，并作替换。&lt;/div&gt;
&lt;div&gt;通常而言，表达式会被“&lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;抽象语法树&lt;/a&gt;”（ Abstract Syntax Tree，简写为 AST）中的计算值所替换，但是这完全取决于语言的实现。&lt;/div&gt;
&lt;div&gt;因此，上述表达式可以等效地被执行为：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; day_sec &lt;span&gt;=&lt;/span&gt; &lt;span&gt;86400&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;Python 中的常量折叠&lt;/h2&gt;
&lt;div&gt;在 Python 中，我们可以使用&lt;code&gt;反汇编模块&lt;/code&gt;（Disassembler）获取 CPython 字节码，从而更好地了解代码执行的过程。&lt;/div&gt;
&lt;div&gt;当使用&lt;code&gt;dis&lt;/code&gt;模块反汇编上述常量表达式时，我们会得到以下字节码：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; dis
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; dis&lt;span&gt;.&lt;/span&gt;dis&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;day_sec = 24 * 60 * 60&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

        &lt;span&gt;0&lt;/span&gt; LOAD_CONST               &lt;span&gt;0&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;86400&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;2&lt;/span&gt; STORE_NAME               &lt;span&gt;0&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;day_sec&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;4&lt;/span&gt; LOAD_CONST               &lt;span&gt;1&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;6&lt;/span&gt; RETURN_VALUE&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;从字节码中可以看出，它只有一个&lt;code&gt;LOAD_CONST&lt;/code&gt; ，以及一个已经计算好的值&lt;code&gt;86400&lt;/code&gt;。&lt;/div&gt;
&lt;div&gt;这表明 CPython 解释器在解析和构建抽象语法树期间，会折叠常量表达式 24 * 60 * 60，并将其替换为计算值 86400。&lt;/div&gt;
&lt;h3&gt;常量折叠的适应范围&lt;/h3&gt;
&lt;div&gt;Python 会尝试折叠每一个常量表达式，但在某些情况下，即使该表达式是常量，但是 Python 并不会对其进行折叠。&lt;/div&gt;
&lt;div&gt;例如，Python 不会折叠&lt;code&gt;x = 4 ** 64&lt;/code&gt;，但会折叠 &lt;code&gt;x = 2 ** 64&lt;/code&gt;。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;除了算术表达式，Python 还会折叠涉及字符串和元组的表达式，其中，长度不超过 4096 的字符串常量表达式会被折叠。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;-&quot;&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;4096&lt;/span&gt;   &lt;span&gt;# folded&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;-&quot;&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;4097&lt;/span&gt;   &lt;span&gt;# not folded&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;--&quot;&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;4096&lt;/span&gt;  &lt;span&gt;# not folded&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;常量折叠的内部细节&lt;/h2&gt;
&lt;div&gt;现在，我们将重点转移到内部的实现细节，即关注 CPython 在哪里以及如何实现常量折叠。&lt;/div&gt;
&lt;div&gt;所有的 AST 优化（包括常量折叠）都可以在 &lt;a href=&quot;https://github.com/python/cpython/blob/master/Python/ast_opt.c&quot;&gt;ast_opt.c&lt;/a&gt; 文件中找到。基本的开始函数是 astfold_expr，它会折叠 Python 源码中包含的所有表达式。&lt;/div&gt;
&lt;div&gt;这个函数以递归方式遍历 AST，并试着折叠每个常量表达式，如下面的代码片段所示：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;astfold_expr 在折叠某个表达式之前，会尝试折叠其子表达式（操作对象），然后将折叠操作代理给特定的表达式折叠函数。&lt;/div&gt;
&lt;div&gt;特定操作的折叠函数对表达式求值，并返回计算后的常数，然后将其放入 AST 中。&lt;/div&gt;
&lt;div&gt;例如，每当 astfold_expr 遇到二值运算时，它便调用 fold_binop，递归地计算两个子操作对象（表达式） 。&lt;/div&gt;
&lt;div&gt;fold_binop 函数返回计算后的常量值，如下面的代码片段所示：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;fold_binop 函数通过检查当前运算符的种类，然后调用其相应的处理函数来折叠二值运算。例如，如果当前的操作是加法运算，为了计算最终值，它会对其左侧和右侧操作数调用 PyNumber_Add。&lt;/div&gt;
&lt;h3&gt;怎样优雅？&lt;/h3&gt;
&lt;div&gt;为了有效地折叠某些模式或类型的常量表达式，CPython 不会写特殊的逻辑，而是调用相同的通用代码。例如，在折叠时，它会调用通用的 PyNumber_Add 函数，跟执行常规的加法操作一样。&lt;/div&gt;
&lt;div&gt;因此，CPython 通过确保其通用代码/计算过程可以处理常量表达式的求值，从而消除了编写特殊函数来处理常量折叠的需要。&lt;/div&gt;
&lt;h2&gt;参考材料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Constant_folding&quot;&gt;Wiki：常量折叠&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stummjr.org/post/cpython-optimizations/&quot;&gt;CPython 优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://yasoob.me/2019/02/26/python-dis-module-and-constant-folding/&quot;&gt;Python dis 模块与常量折叠&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://utcc.utoronto.ca/~cks/space/blog/python/CPythonConstantFolding&quot;&gt;CPython 实现常量折叠的简单方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;​&lt;a href=&quot;https://bugs.python.org/issue1346238&quot;&gt;AST 的常量折叠优化过程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>醒醒！Python已经支持中文变量名啦！</title>
            <link>https://pythoncat.top/posts/2021-01-13-books/</link>
            <guid>https://pythoncat.top/posts/2021-01-13-books/</guid>
            <pubDate>Wed, 13 Jan 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;最近，我在翻阅两本比较新的 Python 书籍时，发现它们都犯了一个严重的低级错误！&lt;/div&gt;
&lt;div&gt;这两本书分别是《Python编程：从入门到实践》和《父与子的编程之旅》，它们都是畅销书，都在 2020 年 10 月出了新版本，都使用 Python3.7+ 版本的语法。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;然而，在关于变量的命名规则部分，它们犯下了一样的错误，即还在使用 Python2 时代的那套说辞，误以为命名仅仅支持“字母、数字和下划线”的组合。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;事实上，Python3.x 已经支持全面 Unicode 编码，比如支持使用中文作为变量名。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 姓名 &lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;Python猫&quot;&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;我是&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;姓名&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，欢迎关注！&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
我是Python猫，欢迎关注！&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;由于我手头上没有其它样本，所以，我不确定有多少新版的书籍还在使用老的规则。但是，翻译类的书籍大概率都会有这样的问题，另外，有些不严谨的国内书籍，也可能因为借鉴了过时的材料而犯错。&lt;/div&gt;
&lt;div&gt;如此一来，恐怕有些新接触 Python 的同学，就会形成错误的认识。虽然这可能不会造成严重的问题，但是它终归是一个应该避免而且很容易就能避免的问题。&lt;/div&gt;
&lt;div&gt;因此，我觉得这个话题值得聊一聊。&lt;/div&gt;
&lt;div&gt;在编程语言中有一个很常见的概念，即标识符（identifier），通常又会称之为名字（name），用于标识出变量、常量、函数、类、符号等实体的名字。&lt;/div&gt;
&lt;div&gt;在定义标识符时，有一些必须要考虑的基本规则：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;它可以由哪些字符组成？&lt;/li&gt;
&lt;li&gt;它是否区分大小写？（即大小写敏感）&lt;/li&gt;
&lt;li&gt;它是否允许出现某些特殊的单词？（即关键字/保留字）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;对于第一个问题，大多数的编程语言&lt;strong&gt;在早期版本&lt;/strong&gt;都遵循这条规则：&lt;strong&gt;标识符由字母、数字和下划线组成，并且不能以数字为开头。&lt;/strong&gt; 少数的编程语言有例外，还支持使用$、@、%等特殊符号（例如PHP、Ruby、Perl等等）。&lt;/div&gt;
&lt;div&gt;Python 的早期版本，确切地说是 3.0 之前的版本，就遵循以上的命名规则。下面是官方文档中的描述：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;identifier &lt;span&gt;:&lt;/span&gt;&lt;span&gt;:=&lt;/span&gt;  &lt;span&gt;(&lt;/span&gt;letter&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;_&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;letter &lt;span&gt;|&lt;/span&gt; digit &lt;span&gt;|&lt;/span&gt; &lt;span&gt;&quot;_&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;
letter     &lt;span&gt;:&lt;/span&gt;&lt;span&gt;:=&lt;/span&gt;  lowercase &lt;span&gt;|&lt;/span&gt; uppercase
lowercase  &lt;span&gt;:&lt;/span&gt;&lt;span&gt;:=&lt;/span&gt;  &lt;span&gt;&quot;a&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;z&quot;&lt;/span&gt;
uppercase  &lt;span&gt;:&lt;/span&gt;&lt;span&gt;:=&lt;/span&gt;  &lt;span&gt;&quot;A&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;Z&quot;&lt;/span&gt;
digit      &lt;span&gt;:&lt;/span&gt;&lt;span&gt;:=&lt;/span&gt;  &lt;span&gt;&quot;0&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;9&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;
&lt;div&gt;出处：&lt;a href=&quot;https://docs.python.org/2.7/reference/lexical_analysis.html#identifiers&quot;&gt;https://docs.python.org/2.7/reference/lexical_analysis.html#identifiers&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;但是，这条规则从 3.0 版本起，就被打破了。最新的官方文档已经变成了这样：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;出处：&lt;a href=&quot;https://docs.python.org/3/reference/lexical_analysis.html#identifiers&quot;&gt;https://docs.python.org/3/reference/lexical_analysis.html#identifiers&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;随着互联网的普及，各国语言进入了国际化的语境中，编程语言也与时俱进地增长了对国际化的诉求。&lt;/div&gt;
&lt;div&gt;Unicode（译作统一码、万国码）编码标准在 1994 年发布，随后逐步被主流的编程语言所接纳。到目前为止，至少有 73 种编程语言支持 Unicode 变量名（数据依据：&lt;a href=&quot;https://rosettacode.org/wiki/Unicode_variable_names%EF%BC%89%E3%80%82&quot;&gt;https://rosettacode.org/wiki/Unicode_variable_names）。&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;2007 年，当 Python 正在设计划时代的 3.0 版本时，官方也考虑了对 Unicode 编码的支持，于是，诞生了重要的《PEP 3131 — Supporting Non-ASCII Identifiers》。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;出处：&lt;a href=&quot;https://www.python.org/dev/peps/pep-3131&quot;&gt;https://www.python.org/dev/peps/pep-3131&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;事实上，除了我们最关心的中文，Unicode 字符集还包含非常非常多的内容。&lt;/div&gt;
&lt;div&gt;在对变量命名时，下面这些用法都是可行的（谨慎使用，如若被打，本猫概不负责……）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; ψ &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; Δ &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; ಠ_ಠ &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;hello&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;综上所述，某些 Python 书籍中关于变量命名规则的内容已经过时了，不应该被其所误导！&lt;/div&gt;
&lt;div&gt;Python 3 作为一门面向现代化/国际化的语言，对于 Unicode 编码有很好的支持。至于该不该在项目中使用中文给标识符命名，那就是另外的问题啦……&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>2020年Python文章盘点，我选出了个人TOP10</title>
            <link>https://pythoncat.top/posts/2021-01-01-python/</link>
            <guid>https://pythoncat.top/posts/2021-01-01-python/</guid>
            <pubDate>Fri, 01 Jan 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;大家好，我是猫哥。2020年过得真快啊！总感觉这一年里还没有做成多少事，一眨眼就又到了写年度总结的时候了……&lt;/div&gt;
&lt;div&gt;去年1月1日的时候，我写了《&lt;a href=&quot;https://mp.weixin.qq.com/s/GPMkOE1ZR9bbCjFWkhndDg&quot;&gt;我的 2019 年 Python 文章榜单&lt;/a&gt;》，简单列了自己比较满意的 11 篇文章。今年延续传统，我想盘点出一份 2020 年的文章榜单。&lt;/div&gt;
&lt;div&gt;在列榜单之前，我们先来闲聊几件事，作为铺垫吧。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;1、公众号订阅数破 20000 啦！&lt;/strong&gt;  就在 2020 年结束前的两天，Python猫的订阅数终于迈上了新的台阶。从 2018 年国庆到现在，我们共花了 26 个月。&lt;/div&gt;
&lt;div&gt;这个成绩非常非常普通，当初我第一次参加公众号互推时，认识了明哥（@Python编程时光）、小帅B（@学习Python的正确姿势）和涛哥（@涛哥聊Python），当时大家差别不太多（一起出新手村），而如今他们的订阅数达到了 4万、6万和10万，把我远远甩在了身后……&lt;/div&gt;
&lt;div&gt;2021年，我会花适当的精力在运营上，不敢奢望太多，争取明年达成 3.5 万目标。因此，希望能得到大家的持续支持，请帮忙分享、转载、在看，推荐Python猫给其他学习者。我在此鞠躬感谢了！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;2、被评选为“优质原创号主”第2名。&lt;/strong&gt; 在猪哥（@裸睡的猪）建的Python原创作者投稿群里，Python猫有幸被票选成了第2名！能够被众多优秀的同行号主们认可，真是难得而且荣幸！&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;3、有文章被国际友人翻译了。&lt;/strong&gt; 去年7月份的时候，我偶然发现自己的 3 篇“Python为什么”系列文章被一个印度人翻译成了英文，当时写了一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/cnOrKu71vmzsDrhjoEG9CA&quot;&gt;当我发现国际友人翻译了我的文章之后……&lt;/a&gt; 》说明了原由。然而，意想不到的惊喜发生了，其中一篇文章竟被发上了 PyCoder’s Weekly，而且还被CSDN的作者翻译成了中文！真是太戏剧化了！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;那篇文章是《&lt;a href=&quot;https://mp.weixin.qq.com/s/1ehySR5NH2v1U8WIlXflEQ&quot;&gt;Python 为什么没有 main 函数？为什么我不推荐写 main 函数？&lt;/a&gt;》，在国内个平台上也引发了不少的讨论。我其实是有的放矢的，但行文比较精简没有充分展开。有一些反驳声是误读，还有一些则没有驳到点上。那篇文章体现了我对优雅代码的感觉，有一种锐意思考的闪光，我个人非常满意。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;4、短暂的视频UP主尝试。&lt;/strong&gt; 我去年尝试制作了几期短视频，其实是念稿录音+PPT式图文剪辑而成的。一开始的目标是60秒短视频，但后来发现想表达的内容太多，这个时长完全不够。但是，更长的视频则意味着更大的工作量，所以我干脆暂时放弃了。已发布的视频在B站有，欢迎大家去观摩指导，地址：&lt;a href=&quot;https://space.bilibili.com/97566624/video&quot;&gt;https://space.bilibili.com/97566624/video&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;5、整理了一本电子书。&lt;/strong&gt; 我整理了过往的文章，编成了一本电子书，还美其名为《优雅的Python》（可在Python猫后台发送数字“1”领取。《&lt;a href=&quot;https://mp.weixin.qq.com/s/WqqDVtteRunZuTDwFM6pMg&quot;&gt;耗时两年，我终于出了一本电子书！&lt;/a&gt;》里有内容介绍）。很大的动因是学习其他号主，用来给自己引流。但是，陆续收到了几名读者正向的反馈后，我觉得这件事还是蛮有价值的。&lt;/div&gt;
&lt;div&gt;陆续有出版社的编辑来联系出书，我很惶恐，都婉拒了。我知道有些文章还不错，但是离出书还远着呢，不想去误人子弟。（PS.正在跟某编辑合作，但跟自己出书有所不同。以后详说。）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;6、在苏州买了首套房。&lt;/strong&gt; 去年办成了一件大事，就是在苏州园区买了房，成为了“房奴”。不用说，家庭生活的压力大了很多，而且被催生娃的压力也大增了……人的年龄到了某个阶段，家庭的责任可能促使你做出重大的抉择。我觉得在做成这件事后，自己的内心世界成熟了很多。&lt;/div&gt;
&lt;div&gt;因此，需要给读者们打个预防针：Python猫以后“恰饭”的时候会适当变多，我觉得发挥自己写作的特长，适当地挣点钱，这件事很光荣，所以希望大家也适当地包容理解哈~~~&lt;/div&gt;
&lt;div&gt;闲聊先到此为止，下面是文章梳理时刻。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;在过去一年里，猫哥原创及翻译了 Python 技术文 62 篇，总被转载次数达到了 500+。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;我的兴趣主要集中在 Python 语法、技术原理、进阶思考、文章翻译等内容，大部分文章是比较小众的，阅读量也十分惨淡。&lt;/div&gt;
&lt;div&gt;幸运的是，有几篇文章成为了小爆款，阅读量还挺可观的。从受众喜爱的维度看，下面这些文章的效果很好：&lt;/div&gt;
&lt;div&gt;【01】&lt;a href=&quot;https://mp.weixin.qq.com/s/U4n3aEhznPx7lJ8lj6rU_A&quot;&gt;Python 为什么推荐蛇形命名法？&lt;/a&gt; —（被转载32次，转载阅读量达8万+）&lt;/div&gt;
&lt;div&gt;【02】&lt;a href=&quot;https://mp.weixin.qq.com/s/GpBOO0MLsc6g_mNq85Zy0A&quot;&gt;Python 为什么要有 pass 语句？&lt;/a&gt; —（被转载32次，转载阅读量达5万+）&lt;/div&gt;
&lt;div&gt;【03】&lt;a href=&quot;https://mp.weixin.qq.com/s/gEydiMaiknQNgE9Ub9iTPg&quot;&gt;Python 之父为什么嫌弃 lambda 匿名函数？&lt;/a&gt; — —（被转载25次，转载阅读量达3万+）&lt;/div&gt;
&lt;div&gt;【04】&lt;a href=&quot;https://mp.weixin.qq.com/s/vaFL75hm1lx3mvURY4V6_A&quot;&gt;你可能不知道的 Python 技巧&lt;/a&gt;  —（被转载24次，转载阅读量达1.7万+）&lt;/div&gt;
&lt;div&gt;【05】&lt;a href=&quot;https://mp.weixin.qq.com/s/f9JVNKvSIKAEp0xM3ckUzg&quot;&gt;Python 为什么不支持 switch 语句？&lt;/a&gt; —（被转载20次，转载阅读量达1.3万+）&lt;/div&gt;
&lt;div&gt;但是，依我个人喜爱度选择的话，我列出的TOP10榜单是这些（按时间排序）：&lt;/div&gt;
&lt;div&gt;【01】&lt;a href=&quot;https://mp.weixin.qq.com/s/hbRxNt8KxftvpcSUI2iMcA&quot;&gt;Flask 作者 Armin Ronacher：我不觉得有异步压力&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;【02】&lt;a href=&quot;https://mp.weixin.qq.com/s/EPU9TjEqm_GxnVZRwxq5Vw&quot;&gt;Python在计算内存时应该注意的问题？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;【03】&lt;a href=&quot;https://mp.weixin.qq.com/s/1ehySR5NH2v1U8WIlXflEQ&quot;&gt;Python 为什么没有 main 函数？为什么我不推荐写 main 函数？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;【04】&lt;a href=&quot;https://mp.weixin.qq.com/s/Bdn5XPUkH9Ssz4UZc4NKvQ&quot;&gt;Python 为什么不支持 i++ 自增语法，不提供 ++ 操作符？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;【05】&lt;a href=&quot;https://mp.weixin.qq.com/s/VSLLuPwurNEsNLnYf7oGJg&quot;&gt;Python 为什么只需一条语句“a,b=b,a”，就能直接交换两个变量？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;【06】&lt;a href=&quot;https://mp.weixin.qq.com/s/g6jZX0IdH9xpM7BMV3-ToQ&quot;&gt;Python 为什么能支持任意的真值判断？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;【07】&lt;a href=&quot;https://mp.weixin.qq.com/s/GRq8Hg4jqIzCglHRdrWtww&quot;&gt;Python到底是强类型语言，还是弱类型语言？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;【08】&lt;a href=&quot;https://mp.weixin.qq.com/s/gEydiMaiknQNgE9Ub9iTPg&quot;&gt;Python 之父为什么嫌弃 lambda 匿名函数？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;【09】&lt;a href=&quot;https://mp.weixin.qq.com/s/FtlVNTYq60KSPti2xD4psA&quot;&gt;为什么继承 Python 内置类型会出问题？！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;【10】&lt;a href=&quot;https://mp.weixin.qq.com/s/eAZ-b5LyswMPHon2nJ8z8A&quot;&gt;Python最会变魔术的魔术方法，我觉得是它！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这里面有几篇是出自“Python为什么”系列，该系列还有一些文章也不错，全部归档在 Github 上了，大家可以去那里查阅：&lt;strong&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;https://github.com/chinesehuazhou/python-whydo&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;在新的一年里，我写作的主体方向基本不会变，也许会增加一些偏基础向的内容，让自己更接地气一些。同时，PEP和社区好文的翻译工作，也会偶尔做做。&lt;/div&gt;
&lt;div&gt;Flag不敢随便立，但管继续求知与分享，但求无愧于心！&lt;/div&gt;
&lt;div&gt;最后，我把2020全年的文章罗列出来了，按照的是时间顺序：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/A8buJng2qJLKo4BVnyj9Wg&quot;&gt;开发者请注意：Python2 的最后版本将于 4 月发布，但它确实是在 1 月 1 日就寿命终止了！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/-zwZWV3MaFeat96_AoVJCg&quot;&gt;Python 打包的现状：包的三种类型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/aq_u0i5TJUnovXRf6NuGFw&quot;&gt;Python 打包——过去、现在与未来&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Kmqhr9szPdvBI0KQPm9JsA&quot;&gt;Python 官方团队在打包项目中踩过的坑&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/4kN2cu_SwjzubLHWmJ7D7Q&quot;&gt;Python 任务自动化工具 tox 教程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/a-PfI8ogSqAn6vdweVI-xQ&quot;&gt;2019 年 stackoverflow 网站最受欢迎的 20 个 Python 问题&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/y7noTM1F4SNAjwyjwPY5bA&quot;&gt;11 个最佳的 Python 编译器和解释器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/hbRxNt8KxftvpcSUI2iMcA&quot;&gt;Flask 作者 Armin Ronacher：我不觉得有异步压力&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/pZR8VQblbaedtBhPUFoznQPython&quot;&gt;更好用的 Python 任务自动化工具：nox 官方教程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/BBTk1hN0kTnVyk7-hM-dTA&quot;&gt;任务自动化工具：nox 的配置与 API&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/hTROzPdqbCT9M1JlSAbOgQ&quot;&gt;进一步学习 nox 教程，轻松掌握命令行用法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/vaFL75hm1lx3mvURY4V6_A&quot;&gt;你可能不知道的 Python 技巧&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/up8lxuRhJQAXRzxkirF3nA&quot;&gt;强大的 Python 任务自动化工具！invoke 十分钟入门指南&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/UHtPaxO2ojql5ps4hTn3Vg&quot;&gt;如何高效地远程部署？自动化运维利器 Fabric 教程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/EPU9TjEqm_GxnVZRwxq5Vw&quot;&gt;Python在计算内存时应该注意的问题？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Qy5oSGbpkv4GKWalpJpoKA&quot;&gt;Fabric 源码学习：如何实现批量管理远程服务器？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/5f6HSP6hkI859aEaYt2-8g&quot;&gt;Python 小技巧：如何实现操作系统兼容性打包？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/uRdpqZga6P2zaF67VNQz6w&quot;&gt;Python 3.9 新特性：任意表达式可作为装饰器！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/e6rIc-dPhbqWAeJvekawwQ&quot;&gt;学编程这么久，还傻傻分不清什么是方法（method），什么是函数（function）？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/cyR-XWN9bURjb_5cwhSzMw&quot;&gt;官宣！Python 开发者大会（PyCon US）提供在线订阅啦！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Be18db4P03iEL2mOGWuAFg&quot;&gt;不使用 if-elif 语句，如何优雅地判断某个数字所属的等级？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/bjQjVmf7dP5fOqCS1cObqQ&quot;&gt;Python 3.9 性能优化：更快的 list()、dict() 和 range() 等内置类型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/PIhtEIzBgy_ujcTeAQ2dxg&quot;&gt;Python 如何移除旧的版本特性，如何迎接新的特性？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/aU5HZvj9nIj6bljMEKUIRA&quot;&gt;天大福利！世界第一科技出版公司 Springer 免费开放 400 多本电子书！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/byhJnKoKSDnhUNUE9WWopw&quot;&gt;Python为什么使用缩进来划分代码块？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/pi1x6lT88dMmfUUqcVet-A&quot;&gt;Python 的缩进是不是反人类的设计？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/jobdpO7BWWON0ruLNpn31Q&quot;&gt;Python的十万个为什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/yOMC1cxcmMDUxYyeB-dtpw&quot;&gt;Python小技巧：如何批量更新已安装的库？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/LZ2ocKBfYurJtllU4asP2Q&quot;&gt;Python 为什么不用分号作语句终止符？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/1ehySR5NH2v1U8WIlXflEQ&quot;&gt;Python 为什么没有 main 函数？为什么我不推荐写 main 函数？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/EgKuG79GFgI0ovPCPyPPRA&quot;&gt;涨见识了，在终端执行 Python 代码的 6 种方式！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/BA_Lm1XIpAmIib5Ht-417g&quot;&gt;Python 3.9 beta2 版本发布了，看看这 7 个新的 PEP 都是什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/U4n3aEhznPx7lJ8lj6rU_A&quot;&gt;Python 为什么推荐蛇形命名法？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Bdn5XPUkH9Ssz4UZc4NKvQ&quot;&gt;Python 为什么不支持 i++ 自增语法，不提供 ++ 操作符？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/-BnPelXBgA10Vsj92Azihg&quot;&gt;Python 3.10 版本采纳了首个 PEP，中文翻译即将推出&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/W6XkRjDHvVSqtZKRceqwdw&quot;&gt;Python 3.10 的首个 PEP 诞生，内置类型 zip() 将迎来新特性&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/MXVUxndXEPq5EZ4o66mdyQ&quot;&gt;一篇文章掌握 Python 内置 zip() 的全部内容&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/VSLLuPwurNEsNLnYf7oGJg&quot;&gt;Python 为什么只需一条语句“a,b=b,a”，就能直接交换两个变量？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/2mQBlGtI04HK7dSMd7kkkA&quot;&gt;Python 为什么用 # 号作注释符？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/cnOrKu71vmzsDrhjoEG9CA&quot;&gt;当我发现国际友人翻译了我的文章之后……&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/GpBOO0MLsc6g_mNq85Zy0A&quot;&gt;Python 为什么要有 pass 语句？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/SOSN_p74eDHv3tJnSJIZfg&quot;&gt;Python 为什么会有个奇怪的“…”对象？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/g6jZX0IdH9xpM7BMV3-ToQ&quot;&gt;Python 为什么能支持任意的真值判断？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/JVhXjQKcd8uds8yTUumZJw&quot;&gt;Python 为什么要在 18 年前引入布尔类型？且与 C、C++ 和 Java 都不同？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/tnP1tjB0D1CFXBbt5E2soQ&quot;&gt;一个在交流群里讨论过两轮的问题，答案竟然跟一个 PEP 有关&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/e31XEz7z2Wl2jZaaYYGgbA&quot;&gt;Python 函数为什么会默认返回 None？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/wWCgwMofSvKBbi3gZLxsAQ&quot;&gt;Python 为什么没有 void 关键字？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/GRq8Hg4jqIzCglHRdrWtww&quot;&gt;Python到底是强类型语言，还是弱类型语言？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/0XpPaH53II5yO9Lfh80ZOw&quot;&gt;Python中的数字到底是什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ZNztqjp76OMibn9uesstHg&quot;&gt;详解 Python 的二元算术运算，为什么说减法只是语法糖？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/alDZVIM_QOSHYP6lL6wTXQ&quot;&gt;详解增强算术赋值：“-=”操作是怎么实现的？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/gEydiMaiknQNgE9Ub9iTPg&quot;&gt;Python 之父为什么嫌弃 lambda 匿名函数？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/WqqDVtteRunZuTDwFM6pMg&quot;&gt;耗时两年，我终于出了一本电子书！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/f9JVNKvSIKAEp0xM3ckUzg&quot;&gt;Python 为什么不支持 switch 语句？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/-yi4HcNVI6rKBOJ25fwQDg&quot;&gt;Python 疑难问题：[] 与 list() 哪个快？为什么快？快多少呢？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/YtfPlE9JAIS3tpLBGFo5ag&quot;&gt;为什么说 Python 内置函数并不是万能的？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/A4_DD2fvceNk1apn9MQcXA&quot;&gt;如果只推荐一本 Python 书，我要 Pick 它！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/rP7K8rbdgRJ6HXXJ9iciog&quot;&gt;Python有序字典的两个小“惊喜”~~ &lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Q6NXkzzgWT2qsCM5k669iQ&quot;&gt;Python 幕后解释器：一系列的学习资源&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/FtlVNTYq60KSPti2xD4psA&quot;&gt;为什么继承 Python 内置类型会出问题？！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/eAZ-b5LyswMPHon2nJ8z8A&quot;&gt;Python最会变魔术的魔术方法，我觉得是它！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/CX6QQ3CZEFEqF8rOZxWg9w&quot;&gt;脑洞：如何用一个整数来表示一个列表？&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>脑洞：如何用一个整数来表示一个列表？</title>
            <link>https://pythoncat.top/posts/2020-12-22-int/</link>
            <guid>https://pythoncat.top/posts/2020-12-22-int/</guid>
            <pubDate>Tue, 22 Dec 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;原题 | &lt;a href=&quot;https://iantayler.com/2020/12/07/storing-a-list-in-an-int&quot;&gt;Storing a list in an int&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者 | Computer Wit&lt;/div&gt;
&lt;div&gt;译者 | 豌豆花下猫（“Python猫”公众号作者）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;声明&lt;/strong&gt; | 本翻译已得到原作者授权。为便于阅读，内容略有改动。&lt;/div&gt;
&lt;h2&gt;概要&lt;/h2&gt;
&lt;div&gt;与 C、Rust 和 Go 不同，Python 默认的&lt;code&gt;int&lt;/code&gt; 具有任意大小。&lt;a href=&quot;https://iantayler.com/2020/12/07/storing-a-list-in-an-int/%23footnotes#footnotes&quot;&gt;[注1]&lt;/a&gt; 、&lt;a href=&quot;https://iantayler.com/2020/12/07/storing-a-list-in-an-int/%23footnotes#footnotes&quot;&gt;[注2] &lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这意味着，一个整数可以存储无限大的值，只要内存足够。&lt;/div&gt;
&lt;div&gt;例如，你可以打开 Python3 并运行以下命令：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; math
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; math&lt;span&gt;.&lt;/span&gt;factorial&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;[&lt;/span&gt;number omitted&lt;span&gt;]&lt;/span&gt;  &lt;span&gt;# Python猫注：此处求2020的阶乘，结果是一长串数字，所以省略&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; math&lt;span&gt;.&lt;/span&gt;log2&lt;span&gt;(&lt;/span&gt;math&lt;span&gt;.&lt;/span&gt;factorial&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;19272.453841606068&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;math&lt;span&gt;.&lt;/span&gt;factorial&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;&apos;int&apos;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;也就是说，在 Python 中，平常使用的 int 可以轻松地保存一个占用 19273 比特的 C 类型固定大小无符号 int 类型的值（&lt;em&gt;C-style fixed-size unsigned int&lt;/em&gt; ）。在 Python 这样的语言中，便利性高于速度和内存效率，这确实很有用。&lt;/div&gt;
&lt;div&gt;这种无限的精度，也意味着我们可以在单个 int 中存储任意数量的信息。只要编码正确，一整本书、一整个数据库、甚至任何东西，都可以被存入一个单独的 Python int 中。&lt;/div&gt;
&lt;div&gt;&lt;em&gt;(Python猫注：这有&lt;a href=&quot;https://mp.weixin.qq.com/s/IT4QFc7yd-rAOpKtIimQtQ&quot;&gt;一篇文章&lt;/a&gt; ，深度剖析了 Python 整型不会溢出的实现原理，可作关联阅读)&lt;/em&gt;&lt;/div&gt;
&lt;div&gt;因此，我们可以设想出一种 Python 的方言，它只有整型，需要用 int 表示其它所有的类型（字典、列表、等等）。我们还有一些特殊的函数和方法，可以将 int 视为 list 、dict 等等。&lt;/div&gt;
&lt;div&gt;这将会是一个有趣而好玩的练习，而这就是本文想要做的事。&lt;/div&gt;
&lt;div&gt;有一个显而易见的实现方法：所有数据结构只是内存中的位数组（bit-arrays）。最坏的情况下，它是一组相关的位数组（例如，像链表或树中的每个节点），并且它们的集合也只是位数组。位数组可以被解释为二进制数。所以我们必然能这样做。但这有点无聊。&lt;/div&gt;
&lt;div&gt;在本博文以及本系列的后续博文中，我将介绍一些用 int 来表示复杂数据结构的方法。它们不一定是最紧凑、最合理或最有效的，其共同的目标是找到这些数据结构的有趣的表示方式。&lt;a href=&quot;https://iantayler.com/2020/12/07/storing-a-list-in-an-int/%23footnotes#footnotes&quot;&gt;[注3]&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;哥德尔数（Gödel numbering）简介&lt;/h2&gt;
&lt;div&gt;我们要表示的第一个数据结构是 list。我们将使用以逻辑学家 &lt;a href=&quot;https://en.wikipedia.org/wiki/Kurt_G%25C3%25B6del&quot;&gt;KurtGödel&lt;/a&gt; 命名的&lt;a href=&quot;https://en.wikipedia.org/wiki/G%25C3%25B6del_numbering&quot;&gt;Gödel数&lt;/a&gt;。为了方便起见，我们仅处理由无符号整数（即自然数）组成的列表。&lt;/div&gt;
&lt;div&gt;哥德尔数的原理是令每个大于 1 的自然数都用唯一的质数分解来表示。它依据的是&lt;a href=&quot;https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic&quot;&gt;算术的基本定理&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;&lt;em&gt;（Python猫注：质数分解，即 prime factorization，又译作质因数分解、素因子分解等，指的是把每个数都写成用质数相乘的形式）&lt;/em&gt;&lt;/div&gt;
&lt;div&gt;看一些例子：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;一个数字可以通过其质因子（&lt;em&gt;prime factors&lt;/em&gt; ）的指数列表来唯一标识（直到其最高位的非零指数）。所以，我们可以用 126 来表示列表[1, 2, 0, 1] 。列表中的第一个数字是 126 作质数分解后 2 的指数，第二个数是 3 的指数，依此类推。&lt;/div&gt;
&lt;div&gt;再来几个例子：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;如果列表末尾有 0 ，该怎么办呢？好吧，基于这样的编码，不会出现这种情况。&lt;/div&gt;
&lt;div&gt;在我们的质数分解中，指数为 0 的质数可能有无限个，因此我们需要停在某个地方。&lt;a href=&quot;https://iantayler.com/2020/12/07/storing-a-list-in-an-int/%23footnotes#footnotes&quot;&gt;[注4]&lt;/a&gt; 我们选择在最后一个非零指数处停止。&lt;/div&gt;
&lt;div&gt;当列表中包含较大的数字时，这种表示形式也会使用非常大的数字。那是因为列表中的数字表示的是指数，所以 int 的大小与它们成指数增长。例如，[50, 1000, 250] 需要使用大小为 2266 比特的数字表示。&lt;/div&gt;
&lt;div&gt;另一方面，相比于其它用 int 编码的列表，那些包含非常多小整数的长列表，尤其是大型稀疏列表（即大部分的值都为 0），则拥有非常紧凑的表示形式。&lt;/div&gt;
&lt;div&gt;提醒一下，将 list 编码为 int，这不是很好的编程实践，仅仅是一个好玩的实验。&lt;/div&gt;
&lt;h2&gt;Python实现&lt;/h2&gt;
&lt;div&gt;让我们看一下 Python 的实现。这里有几点注意事项：&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;我们会使用带有 yield 的函数，因为它极大地简化了操作。&lt;a href=&quot;https://iantayler.com/2020/12/07/storing-a-list-in-an-int/%23footnotes#footnotes&quot;&gt;[注5]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;你会看到大量的 while 循环。这是因为列表生成式、range 和大多数你打算在 for 循环中使用的东西，都被禁止用在只有 int 类型的方言中。所有这些都被 while 循环替代了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;质数生成器&lt;/h3&gt;
&lt;div&gt;我们要编写的第一个函数是一个迭代器，它将按顺序生成质数。它从头到尾都很关键。这里的实现是最简单可行的版本。&lt;/div&gt;
&lt;div&gt;我可能很快会写一篇完整的关于生成质数的算法的文章，因为这是一个很酷的话题，本身也是一个古老的研究领域。最广为人知的算法是爱拉托逊斯筛法（&lt;a href=&quot;https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes&quot;&gt;Sieve of Erathosthenes&lt;/a&gt; ），但这只是冰山一角。&lt;a href=&quot;https://iantayler.com/2020/12/07/storing-a-list-in-an-int/%23footnotes#footnotes&quot;&gt;[注6]&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;在这里，一个非常幼稚的实现就够了：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;primes&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;starting&lt;span&gt;:&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;Yield the primes in order.
     
    Args:
        starting: sets the minimum number to consider.
     
    Note: `starting` can be used to get all prime numbers
    _larger_ than some number. By default it doesn&apos;t skip
    any candidate primes.
    &quot;&quot;&quot;&lt;/span&gt;
    candidate_prime &lt;span&gt;=&lt;/span&gt; starting
    &lt;span&gt;while&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        candidate_factor &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
        is_prime &lt;span&gt;=&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
        &lt;span&gt;# We&apos;ll try all the numbers between 2 and&lt;/span&gt;
        &lt;span&gt;# candidate_prime / 2. If any of them divide&lt;/span&gt;
        &lt;span&gt;# our candidate_prime, then it&apos;s not a prime!&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; candidate_factor &lt;span&gt;&amp;lt;=&lt;/span&gt; candidate_prime &lt;span&gt;//&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; candidate_prime &lt;span&gt;%&lt;/span&gt; candidate_factor &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                is_prime &lt;span&gt;=&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;
            candidate_factor &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; is_prime&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;yield&lt;/span&gt; candidate_prime
        candidate_prime &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;创建空列表&lt;/h3&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;empty_list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;Create a new empty list.&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;# 1 is the empty list. It isn&apos;t divisible by any prime.&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;遍历元素&lt;/h3&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;iter_list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;l&lt;span&gt;:&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;Yields elements in the list, from first to last.&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;# We go through each prime in order. The next value of&lt;/span&gt;
    &lt;span&gt;# the list is equal to the number of times the list is&lt;/span&gt;
    &lt;span&gt;# divisible by the prime.&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt; primes&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;# We decided we will have no trailing 0s, so when&lt;/span&gt;
        &lt;span&gt;# the list is 1, it&apos;s over.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; l &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;# Count the number of divisions until the list is&lt;/span&gt;
        &lt;span&gt;# not divisible by the prime number.&lt;/span&gt;
        num_divisions &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; l &lt;span&gt;%&lt;/span&gt; p &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            num_divisions &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
            l &lt;span&gt;=&lt;/span&gt; l &lt;span&gt;//&lt;/span&gt; p  &lt;span&gt;# could be / as well&lt;/span&gt;
        &lt;span&gt;yield&lt;/span&gt; num_divisions&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;访问元素&lt;/h3&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;access&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;l&lt;span&gt;:&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; i&lt;span&gt;:&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;Return i-th element of l.&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;# First we iterate over all primes until we get to the&lt;/span&gt;
    &lt;span&gt;# ith prime.&lt;/span&gt;
    j &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt; primes&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; j &lt;span&gt;==&lt;/span&gt; i&lt;span&gt;:&lt;/span&gt;
            ith_prime &lt;span&gt;=&lt;/span&gt; p
            &lt;span&gt;break&lt;/span&gt;
        j &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;# Now we divide the list by the ith-prime until we&lt;/span&gt;
    &lt;span&gt;# cant divide it no more.&lt;/span&gt;
    num_divisions &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; l &lt;span&gt;%&lt;/span&gt; ith_prime &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        num_divisions &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
        l &lt;span&gt;=&lt;/span&gt; l &lt;span&gt;//&lt;/span&gt; ith_prime
    &lt;span&gt;return&lt;/span&gt; num_divisions&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;添加元素&lt;/h3&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;l&lt;span&gt;:&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; elem&lt;span&gt;:&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;# The first step is finding the largest prime factor.&lt;/span&gt;
    &lt;span&gt;# We look at all primes until l.&lt;/span&gt;
    &lt;span&gt;# The next prime after the last prime factor is going&lt;/span&gt;
    &lt;span&gt;# to be the base we need to use to append.&lt;/span&gt;
    &lt;span&gt;# E.g. if the list if 18 -&amp;gt; 2**1 * 3**2 -&amp;gt; [1, 2]&lt;/span&gt;
    &lt;span&gt;# then the largest prime factor is 3, and we will&lt;/span&gt;
    &lt;span&gt;# multiply by the _next_ prime factor to some power to&lt;/span&gt;
    &lt;span&gt;# append to the list.&lt;/span&gt;
    last_prime_factor &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;# Just a placeholder&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt; primes&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; p &lt;span&gt;&amp;gt;&lt;/span&gt; l&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; l &lt;span&gt;%&lt;/span&gt; p &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            last_prime_factor &lt;span&gt;=&lt;/span&gt; p
    &lt;span&gt;# Now get the _next_ prime after the last in the list.&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt; primes&lt;span&gt;(&lt;/span&gt;starting&lt;span&gt;=&lt;/span&gt;last_prime_factor &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        next_prime &lt;span&gt;=&lt;/span&gt; p
        &lt;span&gt;break&lt;/span&gt;
    &lt;span&gt;# Now finally we append an item by multiplying the list&lt;/span&gt;
    &lt;span&gt;# by the next prime to the `elem` power.&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; l &lt;span&gt;*&lt;/span&gt; next_prime &lt;span&gt;**&lt;/span&gt; elem&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;试用这些函数&lt;/h3&gt;
&lt;div&gt;你可以打开一个 Python、iPython 或 bPython会话，并试试这些函数！&lt;/div&gt;
&lt;div&gt;建议列表元素使用从 1 到 10 之间的数字。如果使用比较大的数字，则 append 和 access 可能会花费很长时间。&lt;/div&gt;
&lt;div&gt;从某种程度上说，使用哥德尔数来表示列表并不实用，尽管可以通过优化质数生成及分解算法，来极大地扩大可用数值的范围。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; l &lt;span&gt;=&lt;/span&gt; empty_list&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
 
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; l &lt;span&gt;=&lt;/span&gt; append&lt;span&gt;(&lt;/span&gt;l&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
 
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; l &lt;span&gt;=&lt;/span&gt; append&lt;span&gt;(&lt;/span&gt;l&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
 
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;iter_list&lt;span&gt;(&lt;/span&gt;l&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
Out&lt;span&gt;[&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
 
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; access&lt;span&gt;(&lt;/span&gt;l&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
Out&lt;span&gt;[&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
 
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; access&lt;span&gt;(&lt;/span&gt;l&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
Out&lt;span&gt;[&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;
 
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; l
Out&lt;span&gt;[&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;972&lt;/span&gt;  &lt;span&gt;# Python猫注：2^2*3^5=972&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;其它 int 编码&lt;/h2&gt;
&lt;div&gt;我们看到了一种将自然数列表表示为 int 的方法。还有其它更实用的方法，这些方法依赖于将数字的二进制形式细分为大小不一的块。我相信你可以提出这样的建议。&lt;/div&gt;
&lt;div&gt;我以后可能会写其它文章，介绍更好的用于生成和分解质数的算法，以及其它复杂数据结构的 int 表示形式。&lt;/div&gt;
&lt;h2&gt;脚注&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;我认为在内存不足之前，程序也会出现中断，但是文档确实明确地提到它们具有&lt;a href=&quot;https://docs.Python.org/3/library/stdtypes.html%23numeric-types-int-float-complex#numeric-types-int-float-complex&quot;&gt;无限的精度&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;请注意，对于 Python3，这是正确的，但对于 Python2 则不然。对于 Python2，int 是固定大小的。我认为在 2020 年用 Python 指代 Python3 是没问题的，但我也认为这个细节值得加一条脚注。&lt;/li&gt;
&lt;li&gt;对于用哥德尔数表示列表，这很容易被反驳说是一种糟糕的表示形式。在后续的博文中，我们会讨论有关表示形式的权衡问题。&lt;/li&gt;
&lt;li&gt;我们可以将列表的长度存储在单独的 int 中，据此知道要在列表末尾考虑多少个 0。（猫注：还有几句话没看懂，不译）If we don’t want to have a &lt;em&gt;whole separate&lt;/em&gt; &lt;code&gt;int&lt;/code&gt;, we can always write the length of the list as the exponent of 2 and start the &lt;em&gt;actual&lt;/em&gt; list with the exponent of 3. This has some redundant information, though. The way to avoid redundant information is to store &lt;em&gt;the number of final 0s&lt;/em&gt; in the list, instead of the entire length. We won’t be worrying about &lt;em&gt;any&lt;/em&gt; of this, though.&lt;/li&gt;
&lt;li&gt;请注意，跟使用 return 并将状态变量作为参数相比，使用 yield 没有区别（通常足以获得最后一个返回的元素）。这有点像 &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuation-passing_style&quot;&gt;Continuation Passing Style&lt;/a&gt;。也类似于平常的使非尾递归函数尾递归的累加器。如果你从未听说过累加器技巧，这里有一些链接&lt;a href=&quot;https://raganwald.com/2018/05/27/tail.html&quot;&gt;[1]&lt;/a&gt; 、&lt;a href=&quot;https://blog.appsignal.com/2019/03/19/elixir-alchemy-recursion.html&quot;&gt;[2]&lt;/a&gt; 。我未来可能会在没有它们的语言中，写模仿迭代器的东西。&lt;/li&gt;
&lt;li&gt;另请参见&lt;a href=&quot;https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf&quot;&gt;《 The Genuine Sieve of Erathosthenes》论文&lt;/a&gt;，它澄清了这一算法是如何被定义的。&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;&lt;strong&gt;Python猫注：&lt;/strong&gt; 以上是全部译文，但我最后还想补充一个有趣的内容。在《黑客与画家》中，保罗·格雷大师有一个惊人的预言，他认为在逻辑上不需要有整数类型，因为整数 n 可以用一个 n 元素的列表来表示。哈哈，这跟上文的脑洞恰好反过来了！想象一下，一个只有整数类型没有列表的编程语言，以及一个只有列表类型没有整数的编程语言，哪一个更有可能在未来出现呢？&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python最会变魔术的魔术方法，我觉得是它！</title>
            <link>https://pythoncat.top/posts/2020-12-14-magic/</link>
            <guid>https://pythoncat.top/posts/2020-12-14-magic/</guid>
            <pubDate>Mon, 14 Dec 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s/FtlVNTYq60KSPti2xD4psA&quot;&gt;上篇文章中&lt;/a&gt;，我有一个核心的发现：&lt;strong&gt;Python 内置类型的特殊方法（含魔术方法与其它方法）由 C 语言独立实现，在 Python 层面不存在调用关系。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;但是，文中也提到了一个例外：一个非常神秘的魔术方法。&lt;/div&gt;
&lt;div&gt;这个方法非常不起眼，用途狭窄，我几乎从未注意过它，然而，当发现它可能是上述“定律”的唯一例外情况时，我认为值得再写一篇文章来详细审视一下它。&lt;/div&gt;
&lt;div&gt;本文主要关注的问题有：&lt;/div&gt;
&lt;div&gt;(1) __missing__()到底是何方神圣？&lt;/div&gt;
&lt;div&gt;(2) __missing__()有什么特别之处？擅长“大变活人”魔术？&lt;/div&gt;
&lt;div&gt;(3) __missing__()是否真的是上述发现的例外？如果是的话，为什么会有这种特例？&lt;/div&gt;
&lt;h2&gt;1、有点价值的__missing__()&lt;/h2&gt;
&lt;div&gt;从普通的字典中取值时，可能会出现 key 不存在的情况：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;dd &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&apos;PythonCat&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
dd&lt;span&gt;.&lt;/span&gt;get&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;age&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;        &lt;span&gt;# 结果：None&lt;/span&gt;
dd&lt;span&gt;.&lt;/span&gt;get&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;age&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;    &lt;span&gt;# 结果：18&lt;/span&gt;
dd&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;age&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;            &lt;span&gt;# 报错 KeyError&lt;/span&gt;
dd&lt;span&gt;.&lt;/span&gt;__getitem__&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;age&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 等同于 dd[&apos;age&apos;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;
&lt;div&gt;对于 get() 方法，它是有返回值的，而且可以传入第二个参数，作为 key 不存在时的返回内容，因此还可以接受。但是，另外两种写法都会报错。&lt;/div&gt;
&lt;div&gt;为了解决后两种写法的问题，就可以用到 __missing__() 魔术方法。&lt;/div&gt;
&lt;div&gt;现在，假设我们有一个这样的诉求：从字典中取某个 key 对应的 value，如果有值则返回值，如果没有值则插入 key，并且给它一个默认值（例如一个空列表）。&lt;/div&gt;
&lt;div&gt;如果用原生的 dict，并不太好实现，但是，Python 提供了一个非常好用的扩展类&lt;code&gt;collections.defaultdict&lt;/code&gt;：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;如图所示，当取不存在的 key 时，没有再报 KeyError，而是默认存入到字典中。&lt;/div&gt;
&lt;div&gt;为什么 defaultdict 可以做到这一点呢？&lt;/div&gt;
&lt;div&gt;原因是 defaultdict 在继承了内置类型 dict 之后，还定义了一个 __missing__() 方法，当 __getitem__取不存在的值时，它就会调用入参中传入的工厂函数（上例是调用 list()，创建空列表）。&lt;/div&gt;
&lt;div&gt;作为最典型的示例，defaultdict 在文档注释中写到：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;简而言之，&lt;strong&gt;__missing__()的主要作用就是由__getitem__在缺失 key 时调用，从而避免出现 KeyError。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;另外一个典型的使用例子是&lt;code&gt;collections.Counter&lt;/code&gt; ，它也是 dict 的子类，在取未被统计的 key 时，返回计数 0：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;2、神出鬼没的__missing__()&lt;/h2&gt;
&lt;div&gt;由上可知，__missing__()在__getitem__()取不到值时会被调用，但是，我不经意间还发现了一个细节：&lt;strong&gt;__getitem__()在取不到值时，并不一定会调用__missing__()。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;这是因为它并非内置类型的必要属性，并没有在字典基类中被预先定义。&lt;/div&gt;
&lt;div&gt;如果你直接从 dict 类型中取该属性值，会报属性不存在：&lt;code&gt;AttributeError: type object &apos;object&apos; has no attribute &apos;__missing__&apos;&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;使用 dir() 查看，发现确实不存在该属性：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;如果从 dict 的父类即 object 中查看，也会发现同样的结果。&lt;/div&gt;
&lt;div&gt;这是怎么回事呢？为什么在 dict 和 object 中都没有__missing__属性呢？&lt;/div&gt;
&lt;div&gt;然而，查阅最新的官方文档，object 中分明包含这个属性：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;出处：&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html?highlight=%5C_%5C_missing%5C_%5C_#object.%5C_%5C_missing%5C_%5C&quot;&gt;https://docs.python.org/3/reference/datamodel.html?highlight=\_\_missing\_\_#object.\_\_missing\_\&lt;/a&gt;_&lt;/div&gt;
&lt;div&gt;也就是说，理论上 object 类中会预定义__missing__，其文档证明了这一点，然而实际上它并没有被定义！文档与现实出现了偏差！&lt;/div&gt;
&lt;div&gt;如此一来，当 dict 的子类（例如 defaultdict 和 Counter）在定义__missing__ 时，这个魔术方法事实上只属于该子类，也就是说，&lt;strong&gt;它是一个诞生于子类中的魔术方法！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;据此，我有一个不成熟的猜想：__getitem__()会判断当前对象是否是 dict 的子类，且是否拥有__missing__()，然后才会去调用它（如果父类中也有该方法，则不会先作判断，而是直接就调用了）。&lt;/div&gt;
&lt;div&gt;我在交流群里说出了这个猜想，有同学很快在 CPython 源码中找到验证：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;而这就有意思了，&lt;strong&gt;在内置类型的子类上才存在的魔术方法，&lt;/strong&gt; 纵观整个 Python 世界，恐怕再难以找出第二例。&lt;/div&gt;
&lt;div&gt;我突然有一个联想：这神出鬼没的__missing__()，就像是一个擅长玩“大变活人”的魔术师，先让观众在外面透过玻璃看到他（即官方文档），然而揭开门时，他并不在里面（即内置类型），再变换一下道具，他又完好无损就出现了（即 dict 的子类）。&lt;/div&gt;
&lt;h2&gt;3、被施魔法的__missing__()&lt;/h2&gt;
&lt;div&gt;__missing__() 的神奇之处，除了它本身会变“魔术”之外，它还需要一股强大的“魔法”才能驱动。&lt;/div&gt;
&lt;div&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s/FtlVNTYq60KSPti2xD4psA&quot;&gt;上篇文章中&lt;/a&gt;，我发现原生的魔术方法间相互独立，它们在 C 语言界面可能有相同的核心逻辑，但是在 Python 语言界面，却并不存在着调用关系：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;魔术方法的这种“老死不相往来”的表现，违背了一般的代码复用原则，也是导致内置类型的子类会出现某些奇怪表现的原因。&lt;/div&gt;
&lt;div&gt;官方 Python 宁肯提供新的 UserString、UserList、UserDict 子类，也不愿意复用魔术方法，唯一合理的解释似乎是令魔术方法相互调用的代价太大。&lt;/div&gt;
&lt;div&gt;但是，对于特例__missing__()，Python 却不得不妥协，不得不付出这种代价！&lt;/div&gt;
&lt;div&gt;__missing__() 是魔术方法的“&lt;strong&gt;二等公民&lt;/strong&gt; ”，它没有独立的调用入口，只能被动地由 __getitem__() 调用，即__missing__() 依赖于__getitem__()。&lt;/div&gt;
&lt;div&gt;不同于那些“&lt;strong&gt;一等公民&lt;/strong&gt; ”，例如 __init__()、__enter__()、__len__()、__eq__() 等等，它们要么是在对象生命周期或执行过程的某个节点被触发，要么由某个内置函数或操作符触发，这些都是相对独立的事件，无所依赖。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;__missing__() 依赖于__getitem__()，才能实现方法调用；而 __getitem__() 也要依赖 __missing__()，才能实现完整功能。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;为了实现这一点，__getitem__()在解释器代码中开了个后门，从 C 语言界面折返回 Python 界面，去调用那个名为“__missing__”的特定方法。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;而这就是真正的“魔法”了，目前为止，__missing__()似乎是唯一一个享受了此等待遇的魔术方法！&lt;/div&gt;
&lt;h2&gt;4、小结&lt;/h2&gt;
&lt;div&gt;Python 的字典提供了两种取值的内置方法，即__getitem__() 和 get()，当取值不存在时，它们的处理策略是不一样的：&lt;strong&gt;前者会报错&lt;code&gt;KeyError&lt;/code&gt;，而后者会返回 None。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;为什么 Python 要提供两个不同的方法呢？或者应该问，为什么 Python 要令这两个方法做出不一样的处理呢？&lt;/div&gt;
&lt;div&gt;这可能有一个很复杂（也可能是很简单）的解释，本文暂不深究了。&lt;/div&gt;
&lt;div&gt;不过有一点是可以确定的：即原生 dict 类型简单粗暴地抛&lt;code&gt;KeyError&lt;/code&gt; 的做法有所不足。&lt;/div&gt;
&lt;div&gt;为了让字典类型有更强大的表现（或者说让__getitem__()作出 get() 那样的表现），Python 让字典的子类可以定义__missing__()，供__getitem__()查找调用。&lt;/div&gt;
&lt;div&gt;本文梳理了__missing__()的实现原理，从而揭示出它并非是一个毫不起眼的存在，恰恰相反，&lt;strong&gt;它是唯一一个打破了魔术方法间壁垒，支持被其它魔术方法调用的特例！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;Python 为了维持魔术方法的独立性，不惜煞费苦心地引入了 UserString、UserList、UserDict 这些派生类，但是对于 __missing__()，它却选择了妥协。&lt;/div&gt;
&lt;div&gt;本文揭示出了这个魔术方法的神秘之处，不知你读后有何感想呢？欢迎留言讨论。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>为什么继承 Python 内置类型会出问题？！</title>
            <link>https://pythoncat.top/posts/2020-11-15-builtin/</link>
            <guid>https://pythoncat.top/posts/2020-11-15-builtin/</guid>
            <pubDate>Sun, 15 Nov 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;不久前，&lt;code&gt;Python猫&lt;/code&gt; 给大家推荐了一本书《流畅的Python》（&lt;a href=&quot;https://mp.weixin.qq.com/s/A4_DD2fvceNk1apn9MQcXA&quot;&gt;点击可跳转阅读&lt;/a&gt;），那篇文章有比较多的“溢美之词”，显得比较空泛……&lt;/div&gt;
&lt;div&gt;但是，《流畅的Python》一书值得反复回看，可以温故知新。最近我偶然翻到书中一个有点诡异的知识点，因此准备来聊一聊这个话题——&lt;strong&gt;子类化内置类型可能会出问题？！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;1、内置类型有哪些？&lt;/h2&gt;
&lt;div&gt;在正式开始之前，我们首先要科普一下：&lt;strong&gt;哪些是 Python 的内置类型？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;根据官方文档的分类，内置类型（Built-in Types）主要包含如下内容：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;详细文档：&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html&quot;&gt;https://docs.python.org/3/library/stdtypes.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;其中，有大家熟知的&lt;a href=&quot;https://mp.weixin.qq.com/s/0XpPaH53II5yO9Lfh80ZOw&quot;&gt;数字类型&lt;/a&gt;、序列类型、文本类型、映射类型等等，当然还有我们之前介绍过的&lt;a href=&quot;https://mp.weixin.qq.com/s/JVhXjQKcd8uds8yTUumZJw&quot;&gt;布尔类型&lt;/a&gt;、&lt;a href=&quot;https://mp.weixin.qq.com/s/SOSN_p74eDHv3tJnSJIZfg&quot;&gt;…对象&lt;/a&gt; 等等。&lt;/div&gt;
&lt;div&gt;在这么多内容里，本文只关注那些作为&lt;code&gt;可调用对象&lt;/code&gt;（callable）的内置类型，也就是跟内置函数（built-in function）在表面上相似的那些：&lt;strong&gt;int、str、list、tuple、range、set、dict……&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;这些类型（type）可以简单理解成其它语言中的类（class），但是 Python 在此并没有用习惯上的大驼峰命名法，因此容易让人产生一些误解。&lt;/div&gt;
&lt;div&gt;在 Python 2.2 之后，这些内置类型可以被子类化（subclassing），也就是可以被继承（inherit）。&lt;/div&gt;
&lt;h2&gt;2、内置类型的子类化&lt;/h2&gt;
&lt;div&gt;众所周知，对于某个普通对象 x，Python 中求其长度需要用到公共的内置函数 len(x)，它不像 Java 之类的面向对象语言，后者的对象一般拥有自己的 x.length() 方法。（PS：关于这两种设计风格的分析，推荐阅读 &lt;a href=&quot;https://mp.weixin.qq.com/s/pKQT5wvyaSNFvnJexiCC8w&quot;&gt;这篇文章&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;现在，假设我们要定义一个列表类，希望它拥有自己的 length() 方法，同时保留普通列表该有的所有特性。&lt;/div&gt;
&lt;div&gt;实验性的代码如下（仅作演示）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 定义一个list的子类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyList&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;length&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我们令 MyList这个自定义类继承 list，同时新定义一个 length() 方法。这样一来，MyList 就拥有 append()、pop() 等等方法，同时还拥有 length() 方法。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 添加两个元素&lt;/span&gt;
ss &lt;span&gt;=&lt;/span&gt; MyList&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
ss&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Python&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
ss&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;猫&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;ss&lt;span&gt;.&lt;/span&gt;length&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# 输出：2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;前面提到的其它内置类型，也可以这样作子类化，应该不难理解。&lt;/div&gt;
&lt;div&gt;顺便发散一下，&lt;strong&gt;内置类型的子类化有何好处/使用场景呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;有一个很直观的例子，当我们在自定义的类里面，需要频繁用到一个列表对象时（给它添加/删除元素、作为一个整体传递……），这时候如果我们的类继承自 list，就可以直接写 self.append()、self.pop()，或者将 self 作为一个对象传递，从而不用额外定义一个列表对象，在写法上也会简洁一些。&lt;/div&gt;
&lt;div&gt;还有其它的好处/使用场景么？欢迎大家留言讨论~~&lt;/div&gt;
&lt;h2&gt;3、内置类型子类化的“问题”&lt;/h2&gt;
&lt;div&gt;终于要进入本文的正式主题了:)&lt;/div&gt;
&lt;div&gt;通常而言，在我们教科书式的认知中，&lt;strong&gt;子类中的方法会覆盖父类的同名方法，也就是说，子类方法的查找优先级要高于父类方法。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;下面看一个例子，父类 Cat，子类 PythonCat，都有一个 say() 方法，作用是说出当前对象的 inner_voice：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# Python猫是一只猫&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Cat&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;say&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;inner_voice&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;inner_voice&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;喵&quot;&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PythonCat&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Cat&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;inner_voice&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;喵喵&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;当我们创建子类 PythonCat 的对象时，它的 say() 方法会优先取到自己定义出的 inner_voice() 方法，而不是 Cat 父类的 inner_voice() 方法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;my_cat &lt;span&gt;=&lt;/span&gt; PythonCat&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# 下面的结果符合预期&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;my_cat&lt;span&gt;.&lt;/span&gt;inner_voice&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 输出：喵喵&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;my_cat&lt;span&gt;.&lt;/span&gt;say&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;         &lt;span&gt;# 输出：喵喵&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这是编程语言约定俗成的惯例，是一个基本原则，学过面向对象编程基础的同学都应该知道。&lt;/div&gt;
&lt;div&gt;然而，当 Python 在实现继承时，&lt;strong&gt;似乎不完全&lt;/strong&gt;会按照上述的规则运作。它分为两种情况：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;符合常识：对于用 Python 实现的类，它们会遵循“子类先于父类”的原则&lt;/li&gt;
&lt;li&gt;违背常识：对于实际是用 C 实现的类（即str、list、dict等等这些内置类型），在显式调用子类方法时，会遵循“子类先于父类”的原则；但是，**在存在隐式调用时，**它们似乎会遵循“父类先于子类”的原则，即通常的继承规则会在此失效&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;对照 PythonCat 的例子，相当于说，直接调用 my_cat.inner_voice() 时，会得到正确的“喵喵”结果，但是在调用 my_cat.say() 时，则会得到超出预期的“喵”结果。&lt;/div&gt;
&lt;div&gt;下面是《流畅的Python》中给出的例子（12.1章节）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DoppelDict&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;dict&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; 
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__setitem__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; 
        &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;__setitem__&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;value&lt;span&gt;]&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

dd &lt;span&gt;=&lt;/span&gt; DoppelDict&lt;span&gt;(&lt;/span&gt;one&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# {&apos;one&apos;: 1}&lt;/span&gt;
dd&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;two&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;           &lt;span&gt;# {&apos;one&apos;: 1, &apos;two&apos;: [2, 2]}&lt;/span&gt;
dd&lt;span&gt;.&lt;/span&gt;update&lt;span&gt;(&lt;/span&gt;three&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;      &lt;span&gt;# {&apos;three&apos;: 3, &apos;one&apos;: 1, &apos;two&apos;: [2, 2]}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;
&lt;div&gt;在这个例子中，dd[‘two’] 会直接调用子类的__setitem__()方法，所以结果符合预期。如果其它测试也符合预期的话，最终结果会是{‘three’: [3, 3], ‘one’: [1, 1], ‘two’: [2, 2]}。&lt;/div&gt;
&lt;div&gt;然而，初始化和 update() 直接调用的分别是从父类继承的__init__()和__update__()，再由它们&lt;strong&gt;隐式地&lt;/strong&gt;调用__setitem__()方法，此时却并没有调用子类的方法，而是调用了父类的方法，导致结果超出预期！&lt;/div&gt;
&lt;div&gt;官方 Python 这种实现双重规则的做法，有点违背大家的常识，如果不加以注意，搞不好就容易踩坑。&lt;/div&gt;
&lt;div&gt;那么，为什么会出现这种例外的情况呢？&lt;/div&gt;
&lt;h2&gt;4、内置类型的方法的真面目&lt;/h2&gt;
&lt;div&gt;我们知道了内置类型不会隐式地调用子类覆盖的方法，接着，就是&lt;code&gt;Python猫&lt;/code&gt;的刨根问底时刻：为什么它不去调用呢？&lt;/div&gt;
&lt;div&gt;《&lt;a href=&quot;https://mp.weixin.qq.com/s/A4_DD2fvceNk1apn9MQcXA&quot;&gt;流畅的Python&lt;/a&gt;》书中没有继续追问，不过，我试着胡乱猜测一下（应该能从源码中得到验证）：&lt;strong&gt;内置类型的方法都是用 C 语言实现的，事实上它们彼此之间并不存在着相互调用，所以就不存在调用时的查找优先级问题。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;也就是说，前面的“__init__()和__update__()会隐式地调用__setitem__()方法”这种说法并不准确！&lt;/div&gt;
&lt;div&gt;这几个魔术方法其实是相互独立的！__init__()有自己的 setitem 实现，并不会调用父类的__setitem__()，当然跟子类的__setitem__()就更没有关系了。&lt;/div&gt;
&lt;div&gt;从逻辑上理解，字典的__init__()方法中包含__setitem__()的功能，因此我们以为前者会调用后者，**这是惯性思维的体现，**然而实际的调用关系可能是这样的：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;左侧的方法打开语言界面之门进入右侧的世界，在那里实现它的所有使命，并不会折返回原始界面查找下一步的指令（即不存在图中的红线路径）。不折返的原因很简单，即 C 语言间代码调用效率更高，实现路径更短，实现过程更简单。&lt;/div&gt;
&lt;div&gt;同理，dict 类型的 get() 方法与__getitem__()也不存在调用关系，如果子类只覆盖了__getitem__()的话，当子类调用 get() 方法时，实际会使用到父类的 get() 方法。（PS：关于这一点，《流畅的Python》及 PyPy 文档的描述都不准确，它们误以为 get() 方法会调用__getitem__()）&lt;/div&gt;
&lt;div&gt;也就是说，Python 内置类型的方法本身不存在调用关系，尽管它们在底层 C 语言实现时，可能存在公共的逻辑或能被复用的方法。&lt;/div&gt;
&lt;div&gt;我想到了“&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;Python为什么&lt;/a&gt;”系列曾分析过的《&lt;a href=&quot;https://mp.weixin.qq.com/s/g6jZX0IdH9xpM7BMV3-ToQ&quot;&gt;Python 为什么能支持任意的真值判断？&lt;/a&gt;》。在我们写&lt;code&gt;if xxx&lt;/code&gt;时，它似乎会隐式地调用__bool__()和__len__()魔术方法，然而实际上程序依据 POP_JUMP_IF_FALSE 指令，会直接进入纯 C 代码的逻辑，并不存在对这俩魔术方法的调用！&lt;/div&gt;
&lt;div&gt;因此，在意识到 C 实现的特殊方法间相互独立之后，我们再回头看内置类型的子类化，就会有新的发现：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;父类的__init__()魔术方法会打破语言界面实现自己的使命，然而它跟子类的__setitem__()并不存在通路，即图中红线路径不可达。&lt;/div&gt;
&lt;div&gt;特殊方法间各行其是，由此，我们会得出跟前文不同的结论：&lt;strong&gt;实际上 Python 严格遵循了“子类方法先于父类方法”继承原则，并没有破坏常识！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;最后值得一提的是，__missing__()是一个特例。《流畅的Python》仅仅简单而含糊地写了一句，没有过多展开。&lt;/div&gt;
&lt;div&gt;经过初步实验，我发现当子类定义了此方法时，get() 读取不存在的 key 时，正常返回 None；但是 __getitem__() 和 dd[‘xxx’] 读取不存在的 key 时，都会按子类定义的__missing__()进行处理。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;我还没空深入分析，恳请知道答案的同学给我留言。&lt;/div&gt;
&lt;h2&gt;5、内置类型子类化的最佳实践&lt;/h2&gt;
&lt;div&gt;综上所述，内置类型子类化时并没有出问题，只是由于我们没有认清特殊方法（C 语言实现的方法）的真面目，才会导致结果偏差。&lt;/div&gt;
&lt;div&gt;那么，这又召唤出了一个新的问题：&lt;strong&gt;如果非要继承内置类型，最佳的实践方式是什么呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;首先，如果在继承内置类型后，并不重写（overwrite）它的特殊方法的话，子类化就不会有任何问题。&lt;/div&gt;
&lt;div&gt;其次，如果继承后要重写特殊方法的话，记得要把所有希望改变的方法都重写一遍，例如，如果想改变 get() 方法，就要重写 get() 方法，如果想改变 __getitem__()方法，就要重写它……&lt;/div&gt;
&lt;div&gt;但是，如果我们只是想重写某种逻辑（即 C 语言的部分），以便所有用到该逻辑的特殊方法都发生改变的话，例如重写__setitem__()的逻辑，同时令初始化和update()等操作跟着改变，那么该怎么办呢？&lt;/div&gt;
&lt;div&gt;我们已知特殊方法间不存在复用，也就是说单纯定义新的__setitem__()是不够的，那么，怎么才能对多个方法同时产生影响呢？&lt;/div&gt;
&lt;div&gt;PyPy 这个非官方的 Python 版本发现了这个问题，它的做法是令内置类型的特殊方法发生调用，建立它们之间的连接通路。&lt;/div&gt;
&lt;div&gt;官方 Python 当然也意识到了这么问题，不过它并没有改变内置类型的特性，而是提供出了新的方案：UserString、UserList、UserDict……&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;除了名字不一样，基本可以认为它们等同于内置类型。&lt;/div&gt;
&lt;div&gt;这些类的基本逻辑是用 Python 实现的，相当于是把前文 C 语言界面的某些逻辑搬到了 Python 界面，在左侧建立起调用链，如此一来，就解决了某些特殊方法的复用问题。&lt;/div&gt;
&lt;div&gt;对照前文的例子，采用新的继承方式后，结果就符合预期了：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt; UserDict

&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DoppelDict&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;UserDict&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__setitem__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; 
        &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;__setitem__&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;value&lt;span&gt;]&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

dd &lt;span&gt;=&lt;/span&gt; DoppelDict&lt;span&gt;(&lt;/span&gt;one&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# {&apos;one&apos;: [1, 1]}&lt;/span&gt;
dd&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;two&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;           &lt;span&gt;# {&apos;one&apos;: [1, 1], &apos;two&apos;: [2, 2]}&lt;/span&gt;
dd&lt;span&gt;.&lt;/span&gt;update&lt;span&gt;(&lt;/span&gt;three&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;      &lt;span&gt;# {&apos;one&apos;: [1, 1], &apos;two&apos;: [2, 2], &apos;three&apos;: [3, 3]}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;显然，&lt;strong&gt;如果要继承 str/list/dict 的话，最佳的实践就是继承&lt;code&gt;collections&lt;/code&gt;库提供的那几个类。&lt;/strong&gt;&lt;/div&gt;
&lt;h2&gt;6、小结&lt;/h2&gt;
&lt;div&gt;写了这么多，是时候作 ending 了~~&lt;/div&gt;
&lt;div&gt;在本系列的前一篇文章中，Python猫从查找顺序与运行速度两方面，分析了“&lt;a href=&quot;https://mp.weixin.qq.com/s/YtfPlE9JAIS3tpLBGFo5ag&quot;&gt;为什么内置函数/内置类型不是万能的&lt;/a&gt;”，本文跟它一脉相承，也是揭示了内置类型的某种神秘的看似是缺陷的行为特征。&lt;/div&gt;
&lt;div&gt;本文虽然是从《流畅的Python》书中获得的灵感，然而在语言表象之外，我们还多追问了一个“为什么”，从而更进一步地分析出了现象背后的原理。&lt;/div&gt;
&lt;div&gt;简而言之，&lt;strong&gt;内置类型的特殊方法是由 C 语言独立实现的，它们在 Python 语言界面中不存在调用关系，因此在内置类型子类化时，被重写的特殊方法只会影响该方法本身，不会影响其它特殊方法的效果。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;如果我们对特殊方法间的关系有错误的认知，就可能会认为 Python 破坏了“子类方法先于父类方法”的基本继承原则。（很遗憾《流畅的Python》和 PyPy 都有此错误的认知）&lt;/div&gt;
&lt;div&gt;为了迎合大家对内置类型的普遍预期，Python 在标准库中提供了 UserString、UserList、UserDict 这些扩展类，方便程序员来继承这些基本的数据类型。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>如果只推荐一本 Python 书，我要 Pick 它！</title>
            <link>https://pythoncat.top/posts/2020-10-22-fluent/</link>
            <guid>https://pythoncat.top/posts/2020-10-22-fluent/</guid>
            <description>《流畅的Python》一书的作者发布了一条激动人心的消息：他正在写作第二版</description>
            <pubDate>Thu, 22 Oct 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;今年二月初，我偶然看到了一条推特：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;《流畅的Python》一书的作者发布了一条激动人心的消息：他正在写作第二版！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;如果要票选最佳的 Python 进阶类书目，这本书肯定会是得票率最高的书籍之一。我在最早写“Python猫荐书系列”时，就想推荐它，但又觉得好东西应该留到最后，所以一直拖到了现在……&lt;/div&gt;
&lt;div&gt;如果你读过它，肯定也会认为它值得推荐；如果你没有，那请往下阅读，看我的介绍能否打动你把它列为必读书目吧~&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这本书的英文名是《Fluent Python》，在 2015 年 8 月出版。两年后，国内的图灵教育出品了译本，出版时间是 2017 年 5 月，获得豆瓣 9.4 高分。（图书翻译/出版真是个漫长的过程啊）&lt;/div&gt;
&lt;div&gt;作者 Luciano Ramalho 是个巴西人、资深的 Python 程序员/演讲者、PSF（Python软件基金会）成员。书籍的技术审校与推荐人囊括了圈内的一众大咖。&lt;/div&gt;
&lt;div&gt;此书一出，大受圈内好评，各国出版社纷纷引进版权，目前至少已有 9 种语言版本（来数数你认识几种？）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;PS：图片出自@fluentpython官推，简体中文版最薄，巧合占据C位。根据图灵教育统计，简体中文版销量超过4万册，预计在2020年能超越英文版的销量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;那么，这本书到底写了些什么呢？又有哪些特别之处呢？&lt;/div&gt;
&lt;div&gt;全书内容充实，除去前言、附录和术语表这些内容，共分为六个部分 21 章节。我将核心章节内容制作了一份思维导图：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;（在&lt;code&gt;Python猫&lt;/code&gt;公众号回复『&lt;strong&gt;流畅&lt;/strong&gt;』，有完整的高清原图）&lt;/div&gt;
&lt;div&gt;以上是主要章节的思维导图，图中的数字是折叠起来的分支数。&lt;/div&gt;
&lt;div&gt;下面给大家看看部分的细节图：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;原图太大，展示不下。在&lt;code&gt;Python猫&lt;/code&gt;公众号内回复『&lt;strong&gt;流畅&lt;/strong&gt;』，有完整的高清原图、PDF 版本和 MarkDown 版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;从章节上可以看出，这本书主要面向中高级的开发者。它基本不涉及入门级内容，反而聚焦在数据模型、数据结构、函数对象、面向对象、控制流程与元编程等话题上。&lt;/div&gt;
&lt;div&gt;打开书本第一章，作者用寥寥十几行 Python 代码，就徒手实现了一副扑克牌：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; collections

Card &lt;span&gt;=&lt;/span&gt; collections&lt;span&gt;.&lt;/span&gt;namedtuple&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;Card&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;rank&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;suit&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FrenchDeck&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    ranks &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;n&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;JQKA&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    suits &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;spades diamonds clubs hearts&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;split&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;_cards &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;Card&lt;span&gt;(&lt;/span&gt;rank&lt;span&gt;,&lt;/span&gt; suit&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; suit &lt;span&gt;in&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;suits &lt;span&gt;for&lt;/span&gt; rank &lt;span&gt;in&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;ranks&lt;span&gt;]&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__len__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;_cards&lt;span&gt;)&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; position&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;_cards&lt;span&gt;[&lt;/span&gt;position&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;然后，直接就点出了全书最关注的核心话题：&lt;strong&gt;由各种特殊方法构成的数据模型。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;特殊方法（special method）是__xxx__() 这种以前后双下划线命名的东西，通常又被称为魔术方法（magic method）和双下方法（dunder method），是 Python 独有的设计。&lt;/div&gt;
&lt;div&gt;数据模型（data model）无疑是 Python 语言的关键核心，是得以形成所谓 Python 风格（pythonic）的基石。Python 中一切皆对象，而数据模型则是这些对象的接口规范，正是因为它，Python 得以获得极强的行为一致性。&lt;/div&gt;
&lt;div&gt;《流畅的Python》以数据模型为始，定下了全文的风格基调，&lt;strong&gt;即关注 Python 对象的构造以及语言内部的特性细节，目的是让读者写出更地道、简洁高效、可读易用的代码。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;《流畅的Python》作者与中文版合影&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;接着，它介绍了 Python 中一些内置类型的特性（序列类型、映射类型、文本和字节类型），介绍作为特殊对象的函数以及一般性对象的用法，介绍控制流程（迭代器、生成器、上下文管理器、协程和并发编程），最后深入到素有黑魔法之称的元编程（描述符和元类）。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;全书 600 多页，洋洋洒洒，旁征博引，内容充实到让人应接不暇，让人时不时就产生一种“又学到了新知识”的感觉，以及一种“哦我想进一步学习 xxx”的求知欲望。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;很多读过书的同学会有一个同感：它的“延伸阅读/杂谈”并不是闲笔，反而有些内容比正文更精彩，作者在此展示了他丰富的知识面（官方文档、社区典故、语法演进、文章视频、开源项目、语言差异等等），每一章都值得挖掘阅读。目前没有任何一本 Python 书籍能在这方面与它匹敌。&lt;/div&gt;
&lt;div&gt;我推荐大家找到自己感兴趣的章节进行阅读，另外，有人做了非常不错的读书笔记（都挺长的），我放在这里：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.hongweipeng.com/index.php/archives/1345/&quot;&gt;http://www.hongweipeng.com/index.php/archives/1345&lt;/a&gt; （by hongweipeng）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://frankorz.com/2017/07/01/fluent-python-note/&quot;&gt;http://frankorz.com/2017/07/01/fluent-python-note&lt;/a&gt; （by 猫冬）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;《流畅的Python》第一版基于当时最新的 Python 3.4。这些年来，Python 不断丰富自己，既正式宣告了 Python 2 版本的终结，又快速地演进到了最新的 3.9 版本。&lt;/div&gt;
&lt;div&gt;但是，由于作者关注的是 Python 的核心概念，探讨的是基本不会变化的特性，因此倒不必太担忧内容过时，它仍是一本非常推荐购买和阅读参考的书籍。&lt;/div&gt;
&lt;div&gt;我非常关心它的第二版，但是也知道，写作需要时间，英文出版、中文翻译和中文出版也都需要时间，所以我们就一起静候佳音吧。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>为什么说 Python 内置函数并不是万能的？</title>
            <link>https://pythoncat.top/posts/2020-10-18-function/</link>
            <guid>https://pythoncat.top/posts/2020-10-18-function/</guid>
            <pubDate>Sun, 18 Oct 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在&lt;code&gt;Python猫&lt;/code&gt;的&lt;a href=&quot;https://mp.weixin.qq.com/s/-yi4HcNVI6rKBOJ25fwQDg&quot;&gt;上一篇文章&lt;/a&gt;中，我们对比了两种创建列表的方法，即字面量用法 [] 与内置类型用法 list()，进而分析出它们在运行速度上的差异。&lt;/div&gt;
&lt;div&gt;在分析为什么 list() 会更慢的时候，文中说到它需要经过名称查找与函数调用两个步骤，那么，这就引出了一个新的问题：&lt;strong&gt;list() 不是内置类型么，为什么它不能直接就调用创建列表的逻辑呢？也就是说，为什么解释器必须经过名称查找，才能“认识”到该做什么呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;其实原因很简单：内置函数/内置类型的名称并不是关键字，它们只是解释器内置的一种便捷功能，方便开发者开箱即用而已。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;PS：内置函数 built-in function 和内置类型 built-in type 很相似，但 list() 实际是一种内置类型而不是内置函数。我曾对这两种易混淆的概念做过辨析，请查看&lt;a href=&quot;https://mp.weixin.qq.com/s/cCWfbHeptEUKtI19GIxF8A&quot;&gt;这篇文章&lt;/a&gt;。为了方便理解与表述，以下统称为内置函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;1、内置函数的查找优先级最低&lt;/h2&gt;
&lt;div&gt;&lt;strong&gt;内置函数的名称并不属于关键字，它们是可以被重新赋值的。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;比如下面这个例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 正常调用内置函数&lt;/span&gt;
&lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 结果：[0, 1, 2]&lt;/span&gt;

&lt;span&gt;# 定义任意函数，然后赋值给 list&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;n&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Hello World!&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;list&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; test
&lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 结果：Hello World！&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;
&lt;div&gt;在这个例子中，我们将自定义的 test 赋值给了 list，程序并没有报错。这个例子甚至还可以改成直接定义新的同名函数，即”def list(): …“。&lt;/div&gt;
&lt;div&gt;这说明了 list 并不是 Python 限定的关键字/保留字。&lt;/div&gt;
&lt;div&gt;查看官方文档，可以发现 Python 3.9 有 35 个关键字，明细如下：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;如果我们将上例的 test 赋值给任意一个关键字，例如”pass=test”，就会报错：SyntaxError: invalid syntax。&lt;/div&gt;
&lt;div&gt;由此，我们可以从这个角度看出内置函数并不是万能的：&lt;strong&gt;它们的名称并不像关键字那般稳固不变，虽然它们处在系统内置作用域里，但是却可以被用户局部作用域的对象所轻松拦截掉！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;因为解释器查找名称的顺序是“局部作用域-&amp;gt;全局作用域-&amp;gt;内置作用域”，因此内置函数其实是处在最低优先级。&lt;/div&gt;
&lt;div&gt;对于新手来说，这有一定的可能会发生意想不到的情况（内置函数有 69 个，要全记住是有难度的）。&lt;/div&gt;
&lt;div&gt;那么，&lt;strong&gt;为什么 Python 不把所有内置函数的名称都设为不可复写的关键字呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;一方面原因是它想控制关键字的数量，另一方面可能是想留给用户更多的自由。内置函数只是解释器的推荐实现而已，开发者可以根据需要，实现出与内置函数同名的函数。&lt;/div&gt;
&lt;div&gt;不过，这样的场景极少，而且开发者一般会定义成不同名的函数，以 Python 标准库为例，&lt;code&gt;ast&lt;/code&gt;模块有 &lt;a href=&quot;https://mp.weixin.qq.com/s/6V8z2Gr94PpLbbUUo1K3AQ&quot;&gt;literal_eval() 函数&lt;/a&gt;（对标 eval() 内置函数）、&lt;code&gt;pprint&lt;/code&gt; 模块有 &lt;a href=&quot;https://mp.weixin.qq.com/s/d1dQH1Fqaj_U3AXKYluhSw&quot;&gt;pprint() 函数&lt;/a&gt;（对标 print() 内置函数）、以及&lt;code&gt;itertools&lt;/code&gt;模块有 &lt;a href=&quot;https://mp.weixin.qq.com/s/MXVUxndXEPq5EZ4o66mdyQ&quot;&gt;zip_longest() 函数&lt;/a&gt;（对标 zip() 内置函数）……&lt;/div&gt;
&lt;h2&gt;2、内置函数可能不是最快的&lt;/h2&gt;
&lt;div&gt;由于内置函数的名称并非保留的关键字，以及它处于名称查找的末位顺序，所以内置函数有可能不是最快的。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/-yi4HcNVI6rKBOJ25fwQDg&quot;&gt;上篇文章&lt;/a&gt;展示了 [] 比 list() 快 2~3 倍的事实，其实这还可以推广到 str()、tuple()、set()、dict() 等等内置类型中，都是字面量用法稍稍快于内置类型用法。&lt;/div&gt;
&lt;div&gt;对于这些内置类型，当我们调用 xxx() 时，可以简单理解成正在做类的实例化。在面向对象语言中，类先实例化再使用，这是再正常不过的。&lt;/div&gt;
&lt;div&gt;但是，这样的做法有时也显得繁琐。&lt;strong&gt;为了方便使用，Python 给一些常用的内置类型提供了字面量表示法，也就是&quot;&quot;、[]、()、{} 等等，表示字符串、列表、元组和字典等数据类型。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;文档出处：&lt;a href=&quot;https://docs.python.org/3/reference/lexical_analysis.html#delimiters&quot;&gt;https://docs.python.org/3/reference/lexical_analysis.html#delimiters&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;一般而言，所有编程语言都必须有一些字面量表示，但基本都局限在数字类型、字符串、布尔类型以及 null 之类的基础类型。&lt;/div&gt;
&lt;div&gt;Python 中还增加了几种数据结构类型的字面量，所以是更为方便的，同时这也解释了为什么内置函数可能不是最快的。&lt;/div&gt;
&lt;div&gt;一般而言，同样的完备功能，内置函数总是比我们自定义的函数要快，因为解释器可以做一些底层的优化，例如 &lt;a href=&quot;https://mp.weixin.qq.com/s/pKQT5wvyaSNFvnJexiCC8w&quot;&gt;len() 内置函数&lt;/a&gt;肯定比用户定义的 x.len() 函数快。&lt;/div&gt;
&lt;div&gt;有些人据此形成了“内置函数总是更快”的认识误区。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;解释器内置函数相对于用户定义函数，前者接近于走后门；而字面量表示法相对于内置函数，前者是在走更快的后门。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;也就是说，在有字面量表示法的情况下，某些内置函数/内置类型并不是最快的！&lt;/div&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;div&gt;诚然，Python 本身并不是万能的，那它的任何语法构成部分（内置函数/类型），就更不是万能的了。但是，一般我们会认为内置函数/类型总归是“高人一等”的，是受到诸多特殊优待的，显得像是“万能的”。&lt;/div&gt;
&lt;div&gt;本文从“list() 竟然会败给 []”破题，从两个角度揭示了内置函数其实存在着某种不足：&lt;strong&gt;内置函数的名称并不是关键字，而内置作用域位于名称查找的最低优先级，因此在调用时，某些内置函数/类型的执行速度就明显慢于它们对应的字面量表示法。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;本文对上一个“Python为什么”话题做了延展讨论，一方面充实了前面的内容，另一方面，也有助于大家理解 Python 的几个基础概念及其实现。&lt;/div&gt;
&lt;div&gt;如果你喜欢本文，请点赞支持下吧！另外，我还写了 20+ 篇类似的话题，请关注&lt;code&gt;Python猫&lt;/code&gt;查看，并在 Github 上&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;给我一颗小星星&lt;/a&gt;吧~~&lt;/div&gt;
&lt;div&gt;---&amp;gt;&amp;gt;&amp;gt;最后是福利时刻：&lt;/div&gt;
&lt;div&gt;我把两年写作的 100 多篇精品文章集结成了一本 700 多页的《优雅的Python》电子书，诚意推荐！！请在微信关注&lt;code&gt;Python猫&lt;/code&gt; ，回复“优雅”两字获取~~&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 疑难问题：[] 与 list() 哪个快？为什么快？快多少呢？</title>
            <link>https://pythoncat.top/posts/2020-10-14-list/</link>
            <guid>https://pythoncat.top/posts/2020-10-14-list/</guid>
            <pubDate>Wed, 14 Oct 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在日常使用 Python 时，我们经常需要创建一个列表，相信大家都很熟练了吧？&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 方法一：使用成对的方括号语法&lt;/span&gt;
list_a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;# 方法二：使用内置的 list()&lt;/span&gt;
list_b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上面的两种写法，你经常使用哪一个呢？是否思考过它们的区别呢？&lt;/div&gt;
&lt;div&gt;让我们开门见山，直接抛出本文的问题吧：&lt;strong&gt;两种创建列表的 [] 与 list() 写法，哪一个更快呢，为什么它会更快呢？&lt;/strong&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;注：为了简化问题，我们以创建空列表为例进行分析。关于列表的更多介绍与用法说明，可以查看&lt;a href=&quot;https://mp.weixin.qq.com/s/OKf7N3xxrS0tJ_K8Srw-jA&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;1、 [] 是 list() 的三倍快&lt;/h2&gt;
&lt;div&gt;对于第一个问题，使用&lt;code&gt;timeit&lt;/code&gt;模块的 timeit() 函数就能简单地测算出来：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; timeit
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; timeit&lt;span&gt;.&lt;/span&gt;timeit&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;[]&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; number&lt;span&gt;=&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;**&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; timeit&lt;span&gt;.&lt;/span&gt;timeit&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;list()&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; number&lt;span&gt;=&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;**&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;
&lt;div&gt;如上图所示，在各自调用一千万次的情况下，[] 创建方式只花费了 0.47 秒，而 list() 创建方式要花费 1.75 秒，所以，后者的耗时是前者的 3.7 倍！&lt;/div&gt;
&lt;div&gt;这就回答了刚才的问题：&lt;strong&gt;创建空列表时，[] 要比 list() 快不少。&lt;/strong&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;注：timeit() 函数的效率跟运行环境相关，每次执行结果会有微小差异。我在 Python3.8 版本实验了几次，总体上 [] 速度是 list() 的 3 倍多一点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2、list() 比 [] 执行步骤多&lt;/h2&gt;
&lt;div&gt;那么，我们继续来分析一下第二个问题：为什么 [] 会更快呢？&lt;/div&gt;
&lt;div&gt;这一次我们可以使用&lt;code&gt;dis&lt;/code&gt;模块的 dis() 函数，看看两者执行的字节码有何差别：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; dis &lt;span&gt;import&lt;/span&gt; dis
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; dis&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;[]&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; dis&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;list()&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;
&lt;div&gt;如上图所示，[] 的字节码有两条指令（BUILD_LIST 与 RETURN_VALUE），而 list() 的字节码有三条指令（LOAD_NAME、CALL_FUNCTION 与 RETURN_VALUE）。&lt;/div&gt;
&lt;div&gt;这些指令意味着什么呢？该如何理解它们呢？&lt;/div&gt;
&lt;div&gt;首先，对于 []，它是 Python 中的一组字面量（literal），像数字之类的字面量一样，表示确切的固定值。&lt;/div&gt;
&lt;div&gt;也就是说，Python 在解析到它时，就知道它要表示一个列表，因此会直接调用解释器中构建列表的方法（对应 BUILD_LIST ），来创建列表，所以是一步到位。&lt;/div&gt;
&lt;div&gt;而对于 list()，“list”只是一个普通的名称，并不是字面量，也就是说解释器一开始并不认识它。&lt;/div&gt;
&lt;div&gt;因此，解释器的第一步是要找到这个名称（对应 LOAD_NAME）。它会按照一定的顺序，在各个作用域中逐一查找（局部作用域—全局作用域—内置作用域），直到找到为止，找不到则会抛出&lt;code&gt;NameError&lt;/code&gt;。&lt;/div&gt;
&lt;div&gt;解释器看到“list”之后是一对圆括号，因此第二步是把这个名称当作可调用对象来调用，即把它当成一个函数进行调用（对应 CALL_FUNCTION）。&lt;/div&gt;
&lt;div&gt;因此，list() 在创建列表时，需要经过名称查找与函数调用两个步骤，才能真正开始创建列表（注：CALL_FUNCTION 在底层还会有一些函数调用过程，才能走到跟 BUILD_LIST 相通的逻辑，此处我们忽略不计）。&lt;/div&gt;
&lt;div&gt;至此，我们就可以回答前面的问题了：&lt;strong&gt;因为 list() 涉及的执行步骤更多，因此它比 [] 要慢一些。&lt;/strong&gt;&lt;/div&gt;
&lt;h2&gt;3、list() 的速度提升&lt;/h2&gt;
&lt;div&gt;看完前两个问题的解答过程，你也许觉得还不够过瘾，而且可能觉得就算知道了这个冷知识，也不会有多大的帮助，似乎那微弱的提升显得微不足道。&lt;/div&gt;
&lt;div&gt;但是，我们&lt;code&gt;Python猫&lt;/code&gt;出品的《&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;Python为什么&lt;/a&gt;》系列一直秉承着孜孜不倦的求知精神，是不可能放着这个问题不去回答的。&lt;/div&gt;
&lt;div&gt;而且，由于有发散性思考的习惯，我还想到了另外一个挺有意思的问题：&lt;strong&gt;list() 的速度能否提升呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;我不久前写过&lt;a href=&quot;https://mp.weixin.qq.com/s/bjQjVmf7dP5fOqCS1cObqQ&quot;&gt;一篇文章&lt;/a&gt; 正好讨论到这个问题，也就是在刚刚发布的 Python 3.9.0 版本中，它给 list() 实现了更快的 vectorcall 协议，因此执行速度会有一定的提升。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;感兴趣的同学可以去&lt;a href=&quot;https://www.python.org/downloads/&quot;&gt; Python 官网&lt;/a&gt;下载 3.9 版本。&lt;/div&gt;
&lt;div&gt;根据我多轮的测试结果，在新版本中运行 list() 一千万次，耗时大概在 1 秒左右，也就是 [] 运行耗时的 2 倍，相比于前面接近 4 倍的数据，当前版本总体上是提升了不少。&lt;/div&gt;
&lt;div&gt;至此，我们已回答完一连串的疑问，如果你觉得有收获，请点赞支持！欢迎大家关注后续更多精彩内容。&lt;/div&gt;
&lt;div&gt;本文属于“Python为什么”系列（Python猫出品），该系列主要关注 Python 的语法、设计和发展等话题，以一个个“为什么”式的问题为切入点，试着展现 Python 的迷人魅力。所有文章将会归档在 Github 上，欢迎大家给颗小星星，项目地址：&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;https://github.com/chinesehuazhou/python-whydo&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 为什么不支持 switch 语句？</title>
            <link>https://pythoncat.top/posts/2020-10-08-switch/</link>
            <guid>https://pythoncat.top/posts/2020-10-08-switch/</guid>
            <pubDate>Thu, 08 Oct 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在这篇文章里，我们会聊一聊为什么 Python 决定不支持 switch 语句。&lt;/div&gt;
&lt;div&gt;为什么想要聊这个话题呢？&lt;/div&gt;
&lt;div&gt;主要是因为 switch 在其它语言中太常见了，而 Python 却不支持，这样的独特性本身就值得关注，而回答这个问题，也能更加看清 Python 在程序设计上的理念，了解 Python 在语法设计中的决策过程。&lt;/div&gt;
&lt;div&gt;本文除了会详细分析 PEP-275 和 PEP-3103，还会介绍到 Python 最新的发展动态（PEP-622），即可能要引入的模式匹配（pattern matching）语法，相信这个话题会开阔大家的眼界，从而对 switch 语法有更为全面的认识。&lt;/div&gt;
&lt;h2&gt;1、switch 是什么？&lt;/h2&gt;
&lt;div&gt;在开始正题之前，我们需要先聊聊 switch 是什么？&lt;/div&gt;
&lt;div&gt;有些同学可能会第一时间想到它……&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;喂喂，麻烦收收心，别总想着游戏啦，我们要说的是编程语言中的 switch 语句。&lt;/div&gt;
&lt;div&gt;一般而言，switch 的语法格式如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;expression&lt;span&gt;)&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;case&lt;/span&gt; value1&lt;span&gt;:&lt;/span&gt;
       &lt;span&gt;// 语句&lt;/span&gt;
       &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;// 可选&lt;/span&gt;
    &lt;span&gt;case&lt;/span&gt; value2&lt;span&gt;:&lt;/span&gt;
       &lt;span&gt;// 语句&lt;/span&gt;
       &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;// 可选&lt;/span&gt;
    &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;// 可选&lt;/span&gt;
       &lt;span&gt;// 语句&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;使用流程图来表示，大概是这样的：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;它的用法不难理解：switch 语句的值满足哪一个 case 情况，就会执行对应的代码块，执行时遇到 break 就跳出，否则就继续执行下一个 case 分支；一般会在最后放一个 default 分支，作为兜底。&lt;/div&gt;
&lt;div&gt;大多数语言都提供了 switch 语句或者极其相似的东西，例如，在 C/C++/Java /Go 等静态语言中，它们都支持 switch-case 结构；在 Ruby 中有类似的 case-when 结构，在 Shell 语言中，有相似的 case-in 结构，在 Perl 中，有 switch-case-else……&lt;/div&gt;
&lt;div&gt;switch 语句的好处是支持“单条件多分支”的选择结构，相比 if-else 的二分选择结构，在某些时候会更为简洁清晰。&lt;/div&gt;
&lt;div&gt;但是，在 Python 中，我们看不到 switch-case 或者相近的语法结构，这是为什么呢？&lt;/div&gt;
&lt;h2&gt;2、Python 为什么不支持 switch?&lt;/h2&gt;
&lt;div&gt;官方文档中有一篇 FAQ 包含了这个问题：&lt;a href=&quot;https://docs.python.org/3.8/faq/design.html#why-isn-t-there-a-switch-or-case-statement-in-python&quot;&gt;Why isn’t there a switch or case statement in Python?&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;FAQ 即 Frequently Asked Questions 的缩写，表示常见问题，官方列了 27 个常见问题，完整清单在此：&lt;a href=&quot;https://mp.weixin.qq.com/s/zabIvt4dfu_rf7SmGZXqXg&quot;&gt;https://mp.weixin.qq.com/s/zabIvt4dfu_rf7SmGZXqXg&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;该文档给出了几个建议，告诉了我们几个 switch/case 的替代方案：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;使用 if-elif-else 条件判断语句&lt;/li&gt;
&lt;li&gt;使用字典，将 case 值与调用的函数映射起来&lt;/li&gt;
&lt;li&gt;使用内置 getattr() 检索特定的对象调用方法&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;曾有人提出过一些提案（即 PEP-275 和 PEP-3103），想给 Python 引入 switch 语法，然而，对于“&lt;strong&gt;是否以及如何进行靶场测试&lt;/strong&gt;”，大家没有达成一致的共识。&lt;/div&gt;
&lt;div&gt;靶场测试，即 range test，指的是对武器弹药的技术性能作各种测试验证，与药物的临床试验一样，都是在最终产品交付前的一项关键性测试。&lt;/div&gt;
&lt;div&gt;官方文档对于“为什么 Python 不引入 switch”的解释，实际上来源于 Python 之父 Guido van Rossum 在 PEP-3103 中的意见：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;出处：&lt;a href=&quot;https://www.python.org/dev/peps/pep-3103/&quot;&gt;https://www.python.org/dev/peps/pep-3103/&lt;/a&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;A quick poll during my keynote presentation at PyCon 2007 shows this proposal has no popular support. I therefore reject it.&lt;/p&gt;
&lt;p&gt;我在 PyCon 2007 的主题演讲中做了一个快速的民意调查，结果表明这个提案没有得到广泛的支持。因此，我拒绝了它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;简而言之，&lt;strong&gt;PEP 提案有了，语法实现也有了雏形，但是核心开发者们似乎没有达成一致意见，最终导致提案流产了。&lt;/strong&gt;&lt;/div&gt;
&lt;h2&gt;3、PEP-275 与 PEP-3103 说了什么？&lt;/h2&gt;
&lt;div&gt;PEP-3103 是在 2006 年提出的，PEP-275 则是在 2001 年提出的，它们的共同之处是提出了引入 switch 语句的某种必要性、分析了好几种备选的实现方案，然而，结局是都被拒绝了。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;出处：&lt;a href=&quot;https://www.python.org/dev/peps/pep-0275/&quot;&gt;https://www.python.org/dev/peps/pep-0275/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;那么，我们就先来回顾一下核心开发者们都做出了哪些讨论，看一看如果 Python 要实现 switch 结构，会是怎么样子的？（PS：PEP 里还涉及其它内容，本文只摘取与 switch 直接相关的部分）&lt;/div&gt;
&lt;div&gt;PEP-275 提出的语法结构如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;switch EXPR&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;case&lt;/span&gt; CONSTANT&lt;span&gt;:&lt;/span&gt;
        SUITE
    &lt;span&gt;case&lt;/span&gt; CONSTANT&lt;span&gt;:&lt;/span&gt;
        SUITE
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        SUITE&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;其中 else 分支是可选的，如果没有它，并且前面的分支都不满足的话，就什么也不做。另外 case 值 constant 支持不同类型，因为 expr 表达式的类型是动态的。&lt;/div&gt;
&lt;div&gt;PEP-275 还提出让 switch 不支持掉落（fall-through）行为，即每个 case 分支相互独立而完整，不用像 C 语言那样需要写 break。&lt;/div&gt;
&lt;div&gt;该 PEP 还列举了一些其它的 issue：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;重用现有关键字，不引入“switch”和“case”&lt;/li&gt;
&lt;li&gt;使用新的关键字，避免与 C 的 switch 概念混淆&lt;/li&gt;
&lt;li&gt;支持单分支多值选择（例如：case ‘a’, ‘b’, ‘c’: …）&lt;/li&gt;
&lt;li&gt;还有建议支持范围取值判断（例如：case 10..14: …）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;除了首选方案，该 PEP 还记录了几种风格各异的语法方案：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;case&lt;/span&gt; EXPR&lt;span&gt;:&lt;/span&gt;
    of CONSTANT&lt;span&gt;:&lt;/span&gt;
        SUITE
    of CONSTANT&lt;span&gt;:&lt;/span&gt;
        SUITE
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        SUITE

&lt;span&gt;case&lt;/span&gt; EXPR&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; CONSTANT&lt;span&gt;:&lt;/span&gt;
         SUITE
    &lt;span&gt;if&lt;/span&gt; CONSTANT&lt;span&gt;:&lt;/span&gt;
        SUITE
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        SUITE

when EXPR&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;in&lt;/span&gt; CONSTANT_TUPLE&lt;span&gt;:&lt;/span&gt;
        SUITE
    &lt;span&gt;in&lt;/span&gt; CONSTANT_TUPLE&lt;span&gt;:&lt;/span&gt;
        SUITE
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
     SUITE&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;PEP-275 记录下了不少重要的思路和问题，为 PEP-3103 的出现做了很好的铺垫。&lt;/div&gt;
&lt;div&gt;那么，我们再来看看由 Guido 编写的 PEP-3103 说了些什么吧。&lt;/div&gt;
&lt;div&gt;它首先认可了 PEP-275 中的两个基础设定，例如，实现“隐式的 break”，不让 case 分支出现 fall-through 这种转移控制权的情况（其它语言似乎都要求显式地写 break）；else 分支是可选的，复用 else 关键字，而不用引入“default”。&lt;/div&gt;
&lt;div&gt;对于 PEP-275 提倡的那种风格，Guido 比较认可，但也认为它的问题是缩进层次太多，因此建议减少代码分支缩进的空格数，例如本来缩进 4 空格，改为缩进 2 空格。&lt;/div&gt;
&lt;div&gt;PEP-3103 还列举了另外三种实现方案，分析了它们的差异以及问题，具体内容从略，这里只给大家看看它们的风格：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# case 分支不缩进&lt;/span&gt;
switch EXPR&lt;span&gt;:&lt;/span&gt;
&lt;span&gt;case&lt;/span&gt; EXPR&lt;span&gt;:&lt;/span&gt;
    SUITE
&lt;span&gt;case&lt;/span&gt; EXPR&lt;span&gt;:&lt;/span&gt;
    SUITE
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    SUITE

&lt;span&gt;# switch 语句后不加冒号&lt;/span&gt;
switch EXPR
&lt;span&gt;case&lt;/span&gt; EXPR&lt;span&gt;:&lt;/span&gt;
    SUITE
&lt;span&gt;case&lt;/span&gt; EXPR&lt;span&gt;:&lt;/span&gt;
    SUITE
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    SUITE

&lt;span&gt;# 省略 case 关键字&lt;/span&gt;
switch EXPR&lt;span&gt;:&lt;/span&gt;
    EXPR&lt;span&gt;:&lt;/span&gt;
        SUITE
    EXPR&lt;span&gt;:&lt;/span&gt;
        SUITE
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        SUITE&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在基础语法之外，Guido 花了很多篇幅来讨论扩展语法（Extended Syntax），即在一个 case 分支中实现匹配多个值的复杂情况：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;case&lt;/span&gt; EXPR&lt;span&gt;,&lt;/span&gt; EXPR&lt;span&gt;,&lt;/span&gt; &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;

&lt;span&gt;# Guido 优选的&lt;/span&gt;
&lt;span&gt;case&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; EXPR_LIST&lt;span&gt;:&lt;/span&gt;

&lt;span&gt;case&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;EXPR&lt;span&gt;:&lt;/span&gt;

&lt;span&gt;case&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;EXPR&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;EXPR&lt;span&gt;,&lt;/span&gt; &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;

&lt;span&gt;case&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;EXPR&lt;span&gt;,&lt;/span&gt; EXPR&lt;span&gt;,&lt;/span&gt; &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;他重点考虑到的问题包括：switch 中表达式的结果是元组或可迭代对象的情况、case 的值被看成元组解包的情况、在 case 分支作“*”星号操作……&lt;/div&gt;
&lt;div&gt;接着，Guido 又用了非常非常多的篇幅来分析该如何实现 switch，其中讨论到的主要思路有：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;使用等价的 if-elif 链来定义 switch 语句（可能会做些优化）&lt;/li&gt;
&lt;li&gt;同上，另外所有表达式都必须是可哈希的（hashable）&lt;/li&gt;
&lt;li&gt;看作是预先计算的字典的分派（dispatch）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;PEP 中这部分的内容非常多，因为在每个思路上，Guido 还考虑到了好几种实现路径，这导致了他在复杂分析后的结论是：It is too early to decide（ 现在做决定为时尚早）。&lt;/div&gt;
&lt;div&gt;阅读完 PEP-3103 后，我总体的感觉是：Guido 的思路非常发散、层次丰富，但是，缺少了他在面对其它问题时那“快刀斩乱麻”式的洞察力。&lt;/div&gt;
&lt;div&gt;也就是说，在诸多的可能性方案中，他力求面面俱到，最终无法说服自己做出一个独裁的决定。阻力主要来自于他自己，而不是其他人。&lt;/div&gt;
&lt;div&gt;不过，之所以会出现这种情况，也许跟他的预设立场有关：他似乎认为“Python is fine without a switch statement”，因此尽管写了很长的 PEP，但只是在把问题复杂化，把议题搁置起来。&lt;/div&gt;
&lt;div&gt;最后，他在 PyCon 上做了一个小范围调查，借此“名正言顺”地拒绝了自己发起的 PEP，试图堵住众人的悠悠之口……&lt;/div&gt;
&lt;h2&gt;4、未来会有 switch 语句么？&lt;/h2&gt;
&lt;div&gt;归结起来，之所以 Python 没有 switch 语句，原因有：&lt;strong&gt;switch 的实现细节/功能点未经敲定、没有 switch 也挺好的、有其它不错的方法替代 switch、Guido 的小任性……&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;但是，我们还是要追问一句：&lt;strong&gt;未来会有 switch 语句么？或者类似的多分支选择结构？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;为什么要有此一问呢？原因是有太多语言自带 switch 语句，而且也有很多人尝试编写提供 switch 功能的库（我记得在 &lt;em&gt;PyCoder’s Weekly&lt;/em&gt; 里曾见到过两次）。&lt;/div&gt;
&lt;div&gt;我（Python猫）本人自始至终并不喜欢 switch，几乎可以肯定地说，Python 未来也不会有 switch，但是，它很可能会引入一个类似于 switch 且更为复杂的语法结构！&lt;/div&gt;
&lt;div&gt;2020 年 6 月，PEP-622 被提出了，它建议引入在 Scala、Erlang 和 Rust 等语言中的模式匹配语法（&lt;strong&gt;pattern matching&lt;/strong&gt;）。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;截至 2020 年 10 月，该 PEP 已被分解成另外三个 PEP（634-636），目前都处于草案阶段。考虑到核心开发者们的参与情况以及话题讨论的情况，这些提案极有可能会在未来版本（比如正在开发中的 3.10）中实现。&lt;/div&gt;
&lt;div&gt;以一个求平均数的函数为例，模式匹配语法可以实现成这样：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;average&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;args&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;match&lt;/span&gt; args&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt; y&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;           &lt;span&gt;# captures the two elements of a sequence&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;x &lt;span&gt;+&lt;/span&gt; y&lt;span&gt;)&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;x&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;              &lt;span&gt;# captures the only element of a sequence&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; x
        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
        &lt;span&gt;case&lt;/span&gt; x&lt;span&gt;:&lt;/span&gt;                &lt;span&gt;# captures the entire sequence&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;)&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;match-case 结构神似于 switch-case 结构，然而它基于模式（pattern）而非表达式（expression），因此有更多待考虑的细节问题，也有更为广阔的应用空间。&lt;/div&gt;
&lt;div&gt;对此话题感兴趣的读者，建议去查阅这几个新的 PEP。&lt;/div&gt;
&lt;div&gt;最后，让我们回到标题中的问题：&lt;strong&gt;Python 为什么不支持 switch 语句？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;官方文档的 FAQ 对此问题有一个解答，告诉我们有几个不错的替代写法，同时也留下了一条线索：曾有 PEP 提议引入 switch，只是没有成功实现。&lt;/div&gt;
&lt;div&gt;沿着这条线索，本文拆解了 PEP-275 和 PEP-3103 这两篇文档，带大家看到了 Python 社区里提出过的风格各异的 switch 方案，以及诸多的悬而未决的问题。&lt;/div&gt;
&lt;div&gt;最后，我们还关注到了最新的 PEP-622 的动态，看起来 switch 的“孪生兄弟” match 语法有望引入到 Python 中！switch 话题的讨论似乎要终止了，但是另一个更大的话题正在进行中！&lt;/div&gt;
&lt;div&gt;本文属于“Python为什么”系列（Python猫出品），该系列主要关注 Python 的语法、设计和发展等话题，以一个个“为什么”式的问题为切入点，试着展现 Python 的迷人魅力。所有文章将会归档在 Github 上，欢迎大家给颗小星星，项目地址：&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;https://github.com/chinesehuazhou/python-whydo&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>耗时两年，我终于出了一本电子书！</title>
            <link>https://pythoncat.top/posts/2020-10-06-my-book/</link>
            <guid>https://pythoncat.top/posts/2020-10-06-my-book/</guid>
            <pubDate>Tue, 06 Oct 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;2018 年国庆节前，我开通了微信公众号“Python猫”，写下了“喵星来客”系列的第一篇文章。&lt;/div&gt;
&lt;div&gt;2020 年国庆节前，我累计创作和翻译了 130+ Python 技术文章。&lt;/div&gt;
&lt;div&gt;时光匆匆，两年光阴很快就过去了。&lt;/div&gt;
&lt;div&gt;在这个特殊的时间节点上，我感觉有必要把创作的内容做一下梳理，于是，也就诞生出了这一本自制的电子书——&lt;strong&gt;《优雅的Python》。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;看得出来，书名模仿了《流畅的Python》，主要原因是我非常喜欢它，而且正是因为这本书带给我学习 Python 时的很多启发，我才敢于走上技术写作的道路。&lt;/div&gt;
&lt;div&gt;Python 简明优雅，使用体验极为舒服，因此在书名中使用“优雅的”这个形容词，不仅是在致敬“流畅的”，而且也非常之贴切。&lt;/div&gt;
&lt;div&gt;在 Python 简单易学的基础知识之上，我想要更进一步探索它的进阶内容，了解它在语言设计上的方方面面，同时，我还非常关心 Python 官方动态和技术社区的信息，这些东西构成了我创作/翻译的主体内容。&lt;/div&gt;
&lt;div&gt;这本电子书收录了我绝大部分的原创作品，划分成了六个章节：&lt;/div&gt;
&lt;div&gt;第一章是“基础与进阶”，占据了全书最大的篇幅。这里没有循序渐进的入门级内容，所以多数文章并不适合初学者。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;第二章是“Python为什么”系列，该系列主要关注 Python 的语法、设计和发展等话题，以一个个“为什么”式的问题为切入点，试着展现 Python 的迷人魅力。&lt;/div&gt;
&lt;div&gt;该系列是我现阶段最主要的创作方向，慢慢地会由基础的语法点触及到 Python 的更多面貌。文章内容有较高的独创性，彼此之间也有比较多的关联性，可读性很强。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;第三章是“翻译与写作”。我翻译了 20 多篇材料，在 Github 上开了两个翻译系列的仓库（甚至建了一个翻译交流群），其中有些故事/看法/经验值得与大家分享。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;第四章是“荐书系列”。这个系列会推荐一些技术书籍，早期预想是一两周写一篇，但后来由于逐渐走向了“精读书评”的风格，导致难以为续……&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;第五章”社区时事“主要收录了几篇关于 Python 之父”退位—选举—重回决策层“的内容，以及 Python2 落幕和 PyCon 大会的新闻。&lt;/div&gt;
&lt;div&gt;关注社区最新动态，这应该是一种提升”Python世界观“的主要途径。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;最后一章是“喵星来客”系列。它是我的创作“初心”之所在，念念不忘！&lt;/div&gt;
&lt;div&gt;小说创作与技术写作，对应文学思维与理工科思维，差别太大了，而我的野心是在它们之中再加上哲学。在尝试了几篇之后，我审慎地暂时搁笔了，期待着自己有更多的知识积淀和写作经验，到时机成熟的时候，我会再回来的。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;以上就是电子书《优雅的Python》的内容梗概。&lt;/div&gt;
&lt;div&gt;也许在章节编排和制作设计上，它还很粗糙，但我可以保证，它的内容诚意十足！&lt;/div&gt;
&lt;div&gt;那么，如何获取这本免费的电子书呢？&lt;/div&gt;
&lt;div&gt;方式一：关注“Python猫”公众号，回复【优雅的Python】，就能获取到下载链接啦。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;方式二：本书已分享在语雀上（&lt;a href=&quot;https://www.yuque.com/wandouhuaxiamao/pythoncat&quot;&gt;https://www.yuque.com/wandouhuaxiamao/pythoncat&lt;/a&gt;），可在线阅读&amp;amp;留言评论。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 之父为什么嫌弃 lambda 匿名函数？</title>
            <link>https://pythoncat.top/posts/2020-09-20-lambda/</link>
            <guid>https://pythoncat.top/posts/2020-09-20-lambda/</guid>
            <pubDate>Sun, 20 Sep 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 支持 lambda 匿名函数，其扩展的 BNF 表示法是&lt;code&gt;lambda_expr ::= &quot;lambda&quot; [parameter_list] &quot;:&quot; expression&lt;/code&gt; ，也就是 &lt;code&gt;lambda 参数序列:表达式&lt;/code&gt;。&lt;/div&gt;
&lt;div&gt;这是一种便捷的函数定义方式，若翻译成我们熟知的函数形式，会是这个样子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;def (parameter_list):
    return expression&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;也就是说，&lt;strong&gt;Python 中的 lambda 函数是一种可接收多个参数的函数，返回值是一个表达式。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;它最大的好处是单行简洁，不需要函数命名与换行缩进。&lt;/div&gt;
&lt;div&gt;不得不说，匿名函数有时候是挺好用的，比如下文会介绍到的一些常见用法，它因此受到了不少人的推崇。&lt;/div&gt;
&lt;div&gt;但是，匿名函数通常也会造成代码难以阅读，容易被人滥用，再加上 Python 只提供了对它的“残疾的”支持，所以又有一些观点不建议使用匿名函数。&lt;/div&gt;
&lt;div&gt;事实上，&lt;strong&gt;Python 之父 Guido van Rossum 就属于“不推荐使用派”，他甚至曾经（2005年）想要移除 lambda，只不过最后妥协了。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;出处：&lt;a href=&quot;https://www.artima.com/weblogs/viewpost.jsp?thread=98196&quot;&gt;https://www.artima.com/weblogs/viewpost.jsp?thread=98196&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;lambda 这一个由其他开发者贡献进来的特性（借鉴自 lisp 语言），存在了十多年，但是却被这门语言的创造者（兼首席设计师）所嫌弃，最后竟然还奇迹般地幸存了下来，对于这个故事，大家是否觉得挺有戏剧性的？&lt;/div&gt;
&lt;div&gt;接下来，本文就仔细聊一聊这个处境尴尬却生命力顽强的 lambda 匿名函数吧！&lt;/div&gt;
&lt;h2&gt;1、lambda 怎么使用？&lt;/h2&gt;
&lt;div&gt;lambda 函数通常的用法是结合 map()、reduce()、filter()、sorted() 等函数一起使用，这些函数的共性是：&lt;strong&gt;都可以接收其它函数作为参数。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;例如下面的几个例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;my_list &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;# 元素全加1，结果：[4, 2, 6, 5, 11]&lt;/span&gt;
&lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;lambda&lt;/span&gt; i&lt;span&gt;:&lt;/span&gt;i&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; my_list&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; 

&lt;span&gt;# 过滤小于10的元素，结果：[3, 1, 5, 4]&lt;/span&gt;
&lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;lambda&lt;/span&gt; i&lt;span&gt;:&lt;/span&gt;i&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; my_list&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; 

&lt;span&gt;# 元素累加，结果：33&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt; &lt;span&gt;reduce&lt;/span&gt;
&lt;span&gt;reduce&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;lambda&lt;/span&gt; i&lt;span&gt;,&lt;/span&gt;j&lt;span&gt;:&lt;/span&gt;i&lt;span&gt;+&lt;/span&gt;j&lt;span&gt;,&lt;/span&gt; my_list&lt;span&gt;,&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 字典按值排序，结果：[(&apos;b&apos;, 1), (&apos;a&apos;, 3), (&apos;d&apos;, 4), (&apos;c&apos;, 5)]&lt;/span&gt;
my_dict &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;b&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;c&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;d&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;sorted&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;my_dict&lt;span&gt;.&lt;/span&gt;items&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; key&lt;span&gt;=&lt;/span&gt;&lt;span&gt;lambda&lt;/span&gt; item&lt;span&gt;:&lt;/span&gt;item&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;初学者也许会觉得代码读不懂，但是只要记住“&lt;strong&gt;Python中的函数是一等公民&lt;/strong&gt;”，知道一个函数可以被作为另一个函数的参数或者返回值，就容易理解了。&lt;/div&gt;
&lt;div&gt;比如对于 map() 函数的例子，你可以理解成这个形式：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;my_func &lt;span&gt;=&lt;/span&gt; &lt;span&gt;lambda&lt;/span&gt; i&lt;span&gt;:&lt;/span&gt;i&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;my_func&lt;span&gt;,&lt;/span&gt; my_list&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;甚至可以还原成普通的函数：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;add_one&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
	&lt;span&gt;return&lt;/span&gt; i&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;

&lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;add_one&lt;span&gt;,&lt;/span&gt; my_list&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;map() 函数的第一个参数是一个函数，第二个参数是一个可迭代对象。这第一个参数会迭代地调用第二个参数中的元素，调用的结果以迭代器的形式返回。&lt;/div&gt;
&lt;div&gt;这个例子使用了 list()，是为了方便一次性取出迭代器中的元素，直观地展示出来，在实际使用中，很可能会是基于迭代器的形式。&lt;/div&gt;
&lt;div&gt;由这几种用法，我们可以总结出 lambda 函数的使用规律：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;它出现在需要使用函数的地方&lt;/li&gt;
&lt;li&gt;它适合实现简单的功能&lt;/li&gt;
&lt;li&gt;它是一次性的用途，不能在其它地方复用&lt;/li&gt;
&lt;li&gt;它一般不会被独立使用，总是作为其它函数的一部分&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2、lambda 有什么问题？&lt;/h2&gt;
&lt;div&gt;由上面的用法可以看出，使用 lambda 函数的代码比较紧凑简洁，所以有人称它体现了“Pythonic”的优雅思想。&lt;/div&gt;
&lt;div&gt;但是，lambda 函数有没有什么缺陷呢？&lt;/div&gt;
&lt;div&gt;有！当前的 lambda 函数有一个最大的问题，即只支持单行表达式，无法实现丰富的功能，例如无法在函数创建时使用语句（statement），无法使用 if-else 的判断条件，也无法使用 try-except 的异常捕获机制，等等。&lt;/div&gt;
&lt;div&gt;这极大地限制了它的能力，导致了它被人诟病为“残疾的”。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;从技术实现的角度上看，&lt;/strong&gt; 这个问题可以通过语法层面的设计来解决。&lt;/div&gt;
&lt;div&gt;在当年的邮件组讨论中，有人提出过一些解决思路，比如这封邮件：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;出处：&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2006-February/060654.html&quot;&gt;https://mail.python.org/pipermail/python-dev/2006-February/060654.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它提出了一个&lt;code&gt;lambda args::suite&lt;/code&gt; 的想法，支持写成这样的形式：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;ss &lt;span&gt;=&lt;/span&gt; &lt;span&gt;sorted&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;seq&lt;span&gt;,&lt;/span&gt; key&lt;span&gt;=&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;lambda&lt;/span&gt; x&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;abs&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;except&lt;/span&gt; TypeError&lt;span&gt;:&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;但是，Guido 很快就否决了这个思路。&lt;/div&gt;
&lt;div&gt;他写了一篇文章《Language Design Is Not Just Solving Puzzles》来回应：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;出处：&lt;a href=&quot;https://www.artima.com/weblogs/viewpost.jsp?thread=147358&quot;&gt;https://www.artima.com/weblogs/viewpost.jsp?thread=147358&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;其基本观点是：&lt;strong&gt;不能光顾着解决一个问题/实现某种功能，就引入缺乏“Pythonicity”的语言设计。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;那么，为什么 Guido 会认为这是一种不好的设计呢？&lt;/div&gt;
&lt;div&gt;我试着概括一下，理由是：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;双冒号“::”凭空在此引入，但是跟切片语法中的“::”完全不同，而且跟 C++/Perl 中的作用域操作符用法也不同&lt;/li&gt;
&lt;li&gt;即使不用双冒号，用其它符号表示（比如单冒号），还是难以接受，因为都会在一个表达式中嵌入缩进代码块。这就跟使用花括号和 begin/end 关键字来作语句分组（statement grouping）一样，都令人难以接受&lt;/li&gt;
&lt;li&gt;在 lambda 中实现其它功能并不重要，这还会让解析器变得复杂（需区分是否有缩进、记录缩进级别），显得小题大做了&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;简而言之，&lt;strong&gt;他认为简洁友好的用户体验更为重要，如果简洁的语法无法满足需求，就应该写成具名函数的形式，而非设计出复杂的匿名函数。&lt;/strong&gt;&lt;/div&gt;
&lt;h2&gt;3、为什么 Guido 想移除 lambda？&lt;/h2&gt;
&lt;div&gt;上文提到的多行 lambda 语句（multi-statement lambda）事件发生在 2006 年，我们看到了 Guido 不想给 lambda 引入复杂设计的原因。&lt;/div&gt;
&lt;div&gt;但是，早在 2005 年，Guido 就曾经想要从 Python 移除 lambda，他对它的“嫌弃”是一个“历史悠久”的传统……&lt;/div&gt;
&lt;div&gt;在《The fate of reduce() in Python 3000》这篇短文中，Guido 提出要一次性移除 reduce()、map()、filter() 以及 lambda。&lt;/div&gt;
&lt;div&gt;移除 lambda 的理由如下：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;对于不熟悉 Lisp 或 Scheme 的用户，lambda 这名字容易造成混淆&lt;/li&gt;
&lt;li&gt;很多人误以为匿名函数能做嵌套函数不能做的事，但其实并无区别；存在lambda，就会造成不必要的选择，减少选择，可以简化思维&lt;/li&gt;
&lt;li&gt;移除 reduce()、map() 和 filter() 后，就没必要写简短的局部函数了&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;回顾一下我们在前文中总结出的 lambda 的 4 条使用规律，可以发现它跟几个高阶函数（可以接收其它函数作为参数的函数）有较强的“寄生关系”，如果它们能移除了的话，lambda 确实就没有什么独立存留的意义了。&lt;/div&gt;
&lt;div&gt;那么，为什么 Guido 觉得应该移除那几个高阶函数呢？&lt;/div&gt;
&lt;div&gt;主要的理由有：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;可以替换成更加清晰的列表解析式或者生成器表达式，例如 filter(P,S) 可以写成 [x for x in S if P(x)]，map(F, S) 写成 [F(x) for x in S]&lt;/li&gt;
&lt;li&gt;至于 reduce()，他说这是最讨厌的，除了涉及 + 和 * 的少数用法，其它时候他总要拿出纸笔来画图解才能搞清楚。除了显式地写循环，他还针对 reduce() 的几种用法而提出了几个替代用法，包括引入新的 any() 和 all() 函数&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;总体而言，Guido 的想法暗合了《The Zen of Python》中的这一条：&lt;strong&gt;There should be one— and preferably only one —obvious way to do it。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;但是回到现实，为了照顾某些人的习惯，以及对兼容性的考虑，Guido 最后保守地放弃了“清理异端”的计划。&lt;/div&gt;
&lt;div&gt;因此，lambda 得以从 Python 最高独裁者的手上死里逃生。直到一年后，它试图兴风作浪（多行表达式），却惨遭镇压。&lt;/div&gt;
&lt;div&gt;我仿佛听到了 Guido 的内心 OS：当初我想删除东西的时候，你们百般阻挠，现在你们想添加东西，哼，没门！……&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;哈哈，开了个玩笑。&lt;/div&gt;
&lt;div&gt;Guido 的所有决定都体现了他的 Pythonic 设计美学、自恰的逻辑一致性以及对社区声音的权衡。&lt;/div&gt;
&lt;div&gt;对于 lambda，我认可他的观点，而通过回溯语法发展的历史，我觉得自己对于 Python 的理解变得更为丰富了。不知道你可有同感？&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>详解增强算术赋值：“-=”操作是怎么实现的？</title>
            <link>https://pythoncat.top/posts/2020-09-10-arithmetic/</link>
            <guid>https://pythoncat.top/posts/2020-09-10-arithmetic/</guid>
            <description>本篇译文仍是 Brett 大佬的“Python语法糖”系列，他在演示“-=”操作的实现时，竟发现 CPython 的一个 bug，顺手就修复了，这才是大佬……</description>
            <pubDate>Thu, 10 Sep 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;原题&lt;/strong&gt; | &lt;a href=&quot;https://snarky.ca/unravelling-augmented-arithmetic-assignment/&quot;&gt;Unravelling augmented arithmetic assignment&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;作者&lt;/strong&gt; | Brett Cannon&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; | 豌豆花下猫（“Python猫”公众号作者）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;声明&lt;/strong&gt; | 本翻译是出于交流学习的目的，基于 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt; 授权协议。为便于阅读，内容略有改动。&lt;/div&gt;
&lt;h2&gt;序言&lt;/h2&gt;
&lt;div&gt;本文是 &lt;a href=&quot;https://snarky.ca/tag/syntactic-sugar/&quot;&gt;Python语法糖&lt;/a&gt; 系列文章之一。最新的源代码可以在 desugar 项目中找到（&lt;a href=&quot;https://github.com/brettcannon/desugar%EF%BC%89%E3%80%82&quot;&gt;https://github.com/brettcannon/desugar）。&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;div&gt;Python 有一种叫做&lt;code&gt;增强算术赋值&lt;/code&gt;（augmented arithmetic assignment）的东西。可能你不熟悉这个叫法，其实就是在做数学运算的同时进行赋值，例如 a -= b 就是减法的增强算术赋值。&lt;/div&gt;
&lt;div&gt;增强赋值是在 &lt;a href=&quot;https://docs.python.org/3/whatsnew/2.0.html#augmented-assignment&quot;&gt;Python 2.0 版本中&lt;/a&gt; 加入进来的。（译注：在 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0203/&quot;&gt;PEP-203&lt;/a&gt; 中引入）&lt;/div&gt;
&lt;h2&gt;剖析&lt;code&gt;-=&lt;/code&gt;&lt;/h2&gt;
&lt;div&gt;因为 Python 不允许覆盖式赋值，所以相比其它有特殊/魔术方法的操作，它实现增强赋值的方式可能跟你想象的不完全一样。&lt;/div&gt;
&lt;div&gt;首先，要知道&lt;code&gt;a -= b&lt;/code&gt;在语义上与 &lt;code&gt;a = a-b&lt;/code&gt; 相同。但也要意识到，如果你预先知道要将一个对象赋给一个变量名，相比&lt;code&gt;a - b&lt;/code&gt; 的盲操作，就可能会更高效。&lt;/div&gt;
&lt;div&gt;例如，最起码的好处是可以避免创建一个新对象：如果可以就地修改一个对象，那么返回 self，就比重新构造一个新对象要高效。&lt;/div&gt;
&lt;div&gt;因此，Python 提供了一个&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#object.isub&quot;&gt;__isub__()&lt;/a&gt; 方法。如果它被定义在赋值操作的左侧（通常称为 &lt;a href=&quot;https://en.wikipedia.org/wiki/Value_(computer_science)#lrvalue&quot;&gt;lvalue&lt;/a&gt;），则会调用右侧的值（通常称为 rvalue ）。所以对于&lt;code&gt;a -= b&lt;/code&gt; ，就会尝试去调用 a.__isub__(b)。&lt;/div&gt;
&lt;div&gt;如果调用的结果是 NotImplemented，或者根本不存在结果，那么 Python 会退回到常规的&lt;a href=&quot;https://snarky.ca/unravelling-binary-arithmetic-operations-in-python/&quot;&gt;二元算术运算&lt;/a&gt;：&lt;code&gt;a - b&lt;/code&gt;。（译注：作者关于二元运算的文章，译文&lt;a href=&quot;https://mp.weixin.qq.com/s/ZNztqjp76OMibn9uesstHg&quot;&gt;在此&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;最终无论用了哪种方法，返回值都会被赋值给 a。&lt;/div&gt;
&lt;div&gt;下面是简单的伪代码，&lt;code&gt;a -= b&lt;/code&gt; 被分解成：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 实现 a -= b 的伪代码&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;hasattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;__isub__&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    _value &lt;span&gt;=&lt;/span&gt; a&lt;span&gt;.&lt;/span&gt;__isub__&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; _value &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; NotImplemented&lt;span&gt;:&lt;/span&gt;
        a &lt;span&gt;=&lt;/span&gt; _value
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        a &lt;span&gt;=&lt;/span&gt; a &lt;span&gt;-&lt;/span&gt; b
    &lt;span&gt;del&lt;/span&gt; _value
 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
     a &lt;span&gt;=&lt;/span&gt; a &lt;span&gt;-&lt;/span&gt; b&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;归纳这些方法&lt;/h2&gt;
&lt;div&gt;由于我们已经实现了&lt;a href=&quot;https://snarky.ca/unravelling-binary-arithmetic-operations-in-python/&quot;&gt;二元算术运算&lt;/a&gt;，因此归纳增强算术运算并不太复杂。&lt;/div&gt;
&lt;div&gt;通过传入二元算术运算函数，并做一些自省（以及处理可能发生的 TypeError），它可以被漂亮地归纳成：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;_create_binary_inplace_op&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;binary_op&lt;span&gt;:&lt;/span&gt; _BinaryOp&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; Callable&lt;span&gt;[&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;Any&lt;span&gt;,&lt;/span&gt; Any&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; Any&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;

    binary_operation_name &lt;span&gt;=&lt;/span&gt; binary_op&lt;span&gt;.&lt;/span&gt;__name__&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
    method_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&lt;span&gt;f&quot;__i&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;binary_operation_name&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;__&quot;&lt;/span&gt;&lt;/span&gt;
    operator &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&lt;span&gt;f&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;binary_op&lt;span&gt;.&lt;/span&gt;_operator&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;binary_inplace_op&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lvalue&lt;span&gt;:&lt;/span&gt; Any&lt;span&gt;,&lt;/span&gt; rvalue&lt;span&gt;:&lt;/span&gt; Any&lt;span&gt;,&lt;/span&gt; &lt;span&gt;/&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; Any&lt;span&gt;:&lt;/span&gt;
        lvalue_type &lt;span&gt;=&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lvalue&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            method &lt;span&gt;=&lt;/span&gt; debuiltins&lt;span&gt;.&lt;/span&gt;_mro_getattr&lt;span&gt;(&lt;/span&gt;lvalue_type&lt;span&gt;,&lt;/span&gt; method_name&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt; AttributeError&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;pass&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            value &lt;span&gt;=&lt;/span&gt; method&lt;span&gt;(&lt;/span&gt;lvalue&lt;span&gt;,&lt;/span&gt; rvalue&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; value &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; NotImplemented&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; value
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; binary_op&lt;span&gt;(&lt;/span&gt;lvalue&lt;span&gt;,&lt;/span&gt; rvalue&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt; TypeError &lt;span&gt;as&lt;/span&gt; exc&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;# If the TypeError is due to the binary arithmetic operator, suppress&lt;/span&gt;
            &lt;span&gt;# it so we can raise the appropriate one for the agumented assignment.&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; exc&lt;span&gt;.&lt;/span&gt;_binary_op &lt;span&gt;!=&lt;/span&gt; binary_op&lt;span&gt;.&lt;/span&gt;_operator&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;raise&lt;/span&gt;
        &lt;span&gt;raise&lt;/span&gt; TypeError&lt;span&gt;(&lt;/span&gt;
            &lt;span&gt;&lt;span&gt;f&quot;unsupported operand type(s) for &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;operator&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;lvalue_type&lt;span&gt;!r&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt; and &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;rvalue&lt;span&gt;)&lt;/span&gt;&lt;span&gt;!r&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
        &lt;span&gt;)&lt;/span&gt;

    binary_inplace_op&lt;span&gt;.&lt;/span&gt;__name__ &lt;span&gt;=&lt;/span&gt; binary_inplace_op&lt;span&gt;.&lt;/span&gt;__qualname__ &lt;span&gt;=&lt;/span&gt; method_name
    binary_inplace_op&lt;span&gt;.&lt;/span&gt;__doc__ &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;
        &lt;span&gt;&lt;span&gt;f&quot;&quot;&quot;Implement the augmented arithmetic assignment `a &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;operator&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt; b`.&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; binary_inplace_op&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这使得定义的 -= 支持 _create_binary_inplace_op(__ sub__)，且可以推断出其它内容：函数名、调用什么 __i*__ 函数，以及当二元算术运算出问题时，该调用哪个可调用对象。&lt;/div&gt;
&lt;h2&gt;我发现几乎没有人使用&lt;code&gt;**=&lt;/code&gt;&lt;/h2&gt;
&lt;div&gt;在写本文的代码时，我碰上了 **= 的一个奇怪的测试错误。在所有确保 __pow__ 会被适当地调用的测试中，有个测试用例对于 Python 标准库中的&lt;code&gt;operator&lt;/code&gt; 模块却是失败。&lt;/div&gt;
&lt;div&gt;我的代码通常没问题，如果代码与 CPython 的代码之间存在差异，通常会意味着是我哪里出错了。&lt;/div&gt;
&lt;div&gt;但是，无论我多么仔细地排查代码，我都无法定位出为什么我的测试会通过，而标准库则失败。&lt;/div&gt;
&lt;div&gt;我决定深入地了解 CPython 内部发生了什么。从反汇编字节码开始：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; a &lt;span&gt;**=&lt;/span&gt; b
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt; 
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; dis
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; dis&lt;span&gt;.&lt;/span&gt;dis&lt;span&gt;(&lt;/span&gt;test&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;1&lt;/span&gt;           &lt;span&gt;0&lt;/span&gt; LOAD_FAST                &lt;span&gt;0&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
              &lt;span&gt;2&lt;/span&gt; LOAD_GLOBAL              &lt;span&gt;0&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt;
              &lt;span&gt;4&lt;/span&gt; INPLACE_POWER
              &lt;span&gt;6&lt;/span&gt; STORE_FAST               &lt;span&gt;0&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
              &lt;span&gt;8&lt;/span&gt; LOAD_CONST               &lt;span&gt;0&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
             &lt;span&gt;10&lt;/span&gt; RETURN_VALUE&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;通过它，我找到了在 eval 循环中的&lt;code&gt;INPLACE_POWER&lt;/code&gt;：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;TARGET&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;INPLACE_POWER&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            PyObject &lt;span&gt;*&lt;/span&gt;exp &lt;span&gt;=&lt;/span&gt; &lt;span&gt;POP&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            PyObject &lt;span&gt;*&lt;/span&gt;base &lt;span&gt;=&lt;/span&gt; &lt;span&gt;TOP&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            PyObject &lt;span&gt;*&lt;/span&gt;res &lt;span&gt;=&lt;/span&gt; &lt;span&gt;PyNumber_InPlacePower&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;base&lt;span&gt;,&lt;/span&gt; exp&lt;span&gt;,&lt;/span&gt; Py_None&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;Py_DECREF&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;base&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;Py_DECREF&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;exp&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;SET_TOP&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;res&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;res &lt;span&gt;==&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;goto&lt;/span&gt; error&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;DISPATCH&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;出处：&lt;a href=&quot;https://github.com/python/cpython/blob/v3.8.3/Python/ceval.c#L1677&quot;&gt;https://github.com/python/cpython/blob/v3.8.3/Python/ceval.c#L1677&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;然后找到&lt;code&gt;PyNumber_InPlacePower()&lt;/code&gt;：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;PyObject &lt;span&gt;*&lt;/span&gt;
&lt;span&gt;PyNumber_InPlacePower&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;PyObject &lt;span&gt;*&lt;/span&gt;v&lt;span&gt;,&lt;/span&gt; PyObject &lt;span&gt;*&lt;/span&gt;w&lt;span&gt;,&lt;/span&gt; PyObject &lt;span&gt;*&lt;/span&gt;z&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;v&lt;span&gt;-&amp;gt;&lt;/span&gt;ob_type&lt;span&gt;-&amp;gt;&lt;/span&gt;tp_as_number &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        v&lt;span&gt;-&amp;gt;&lt;/span&gt;ob_type&lt;span&gt;-&amp;gt;&lt;/span&gt;tp_as_number&lt;span&gt;-&amp;gt;&lt;/span&gt;nb_inplace_power &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;ternary_op&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;v&lt;span&gt;,&lt;/span&gt; w&lt;span&gt;,&lt;/span&gt; z&lt;span&gt;,&lt;/span&gt; &lt;span&gt;NB_SLOT&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;nb_inplace_power&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;**=&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;ternary_op&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;v&lt;span&gt;,&lt;/span&gt; w&lt;span&gt;,&lt;/span&gt; z&lt;span&gt;,&lt;/span&gt; &lt;span&gt;NB_SLOT&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;nb_power&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;**=&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;出处：&lt;a href=&quot;https://github.com/python/cpython/blob/v3.8.3/Objects/abstract.c#L1172&quot;&gt;https://github.com/python/cpython/blob/v3.8.3/Objects/abstract.c#L1172&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;松了口气~代码显示如果定义了__ipow__，则会调用它，但是只在没有__ipow__ 时，才会调用__pow__。&lt;/div&gt;
&lt;div&gt;然而，正确的做法应该是：&lt;strong&gt;如果调用__ipow__ 时出问题，返回了 NotImplemented 或者根本不存在返回，那么就应该调用 __pow__ 和__rpow__。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;换句话说，当存在__ipow__ 时，以上代码会意外地跳过 a**b 的后备语义！&lt;/div&gt;
&lt;div&gt;实际上，大约11个月前，这个问题被部分地发现，并&lt;a href=&quot;https://bugs.python.org/issue38302&quot;&gt;提交了 bug&lt;/a&gt;。我修复了该问题，并&lt;a href=&quot;https://mail.python.org/archives/list/python-dev%40python.org/thread/MJTHPFSHGH7RIEKXQKYUBHCZBW3T3JTR/&quot;&gt;在 python-dev 上&lt;/a&gt;作了说明。&lt;/div&gt;
&lt;div&gt;截至目前，这似乎会在 Python 3.10 中修复，我们还需要在 3.8 和 3.9 的文档中添加关于 **= 有 bug 的通知（该问题可能很早就有了，但较旧的 Python 版本已处于仅安全维护模式，因此文档不会变更）。&lt;/div&gt;
&lt;div&gt;修复的代码很可能不会被移植，因为它是语义上的变化，并且很难判断是否有人意外地依赖了有问题的语义。但是这个问题花了很长时间才被注意到，这就表明 **= 的使用并不广泛，否则问题早就被发现了。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>详解 Python 的二元算术运算，为什么说减法只是语法糖？</title>
            <link>https://pythoncat.top/posts/2020-09-09-binary/</link>
            <guid>https://pythoncat.top/posts/2020-09-09-binary/</guid>
            <pubDate>Wed, 09 Sep 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;原题&lt;/strong&gt; | &lt;a href=&quot;https://snarky.ca/unravelling-binary-arithmetic-operations-in-python/&quot;&gt;Unravelling binary arithmetic operations in Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;作者&lt;/strong&gt; | Brett Cannon&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; | 豌豆花下猫（“Python猫”公众号作者）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;声明&lt;/strong&gt; | 本翻译是出于交流学习的目的，基于 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt; 授权协议。为便于阅读，内容略有改动。&lt;/div&gt;
&lt;div&gt;大家对我解读&lt;a href=&quot;https://snarky.ca/unravelling-attribute-access-in-python/&quot;&gt;属性访问&lt;/a&gt;的博客文章反应热烈，这启发了我再写一篇关于 Python 有多少语法实际上只是语法糖的文章。在本文中，我想谈谈二元算术运算。&lt;/div&gt;
&lt;div&gt;具体来说，我想解读减法的工作原理：&lt;code&gt;a - b&lt;/code&gt;。我故意选择了减法，因为它是不可&lt;a href=&quot;https://en.wikipedia.org/wiki/Commutative_property&quot;&gt;交换的&lt;/a&gt;。这可以强调出操作顺序的重要性，与加法操作相比，你可能会在实现时误将 a 和 b 翻转，但还是得到相同的结果。&lt;/div&gt;
&lt;h2&gt;查看 C 代码&lt;/h2&gt;
&lt;div&gt;按照惯例，我们从查看 CPython 解释器编译的字节码开始。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; &lt;span&gt;sub&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; a &lt;span&gt;-&lt;/span&gt; b
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt; 
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; dis
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; dis&lt;span&gt;.&lt;/span&gt;dis&lt;span&gt;(&lt;/span&gt;sub&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;1&lt;/span&gt;           &lt;span&gt;0&lt;/span&gt; LOAD_GLOBAL              &lt;span&gt;0&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
              &lt;span&gt;2&lt;/span&gt; LOAD_GLOBAL              &lt;span&gt;1&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt;
              &lt;span&gt;4&lt;/span&gt; BINARY_SUBTRACT
              &lt;span&gt;6&lt;/span&gt; POP_TOP
              &lt;span&gt;8&lt;/span&gt; LOAD_CONST               &lt;span&gt;0&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
             &lt;span&gt;10&lt;/span&gt; RETURN_VALUE&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;看起来我们需要深入研究 &lt;a href=&quot;https://docs.python.org/3/library/dis.html%23opcode-BINARY_SUBTRACT#opcode-BINARY_SUBTRACT&quot;&gt;BINARY_SUBTRACT &lt;/a&gt; 操作码。翻查 Python/ceval.c 文件，可以看到实现该操作码的 C 代码如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;TARGET&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;BINARY_SUBTRACT&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    PyObject &lt;span&gt;*&lt;/span&gt;right &lt;span&gt;=&lt;/span&gt; &lt;span&gt;POP&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    PyObject &lt;span&gt;*&lt;/span&gt;left &lt;span&gt;=&lt;/span&gt; &lt;span&gt;TOP&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    PyObject &lt;span&gt;*&lt;/span&gt;diff &lt;span&gt;=&lt;/span&gt; &lt;span&gt;PyNumber_Subtract&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;left&lt;span&gt;,&lt;/span&gt; right&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;Py_DECREF&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;right&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;Py_DECREF&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;left&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;SET_TOP&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;diff&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;diff &lt;span&gt;==&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;goto&lt;/span&gt; error&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;DISPATCH&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;来源：&lt;a href=&quot;https://github.com/python/cpython/blob/6f8c8320e9eac9bc7a7f653b43506e75916ce8e8/Python/ceval.c#L1569-L1579&quot;&gt;https://github.com/python/cpython/blob/6f8c8320e9eac9bc7a7f653b43506e75916ce8e8/Python/ceval.c#L1569-L1579&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这里的关键代码是&lt;a href=&quot;https://github.com/python/cpython/blob/v3.8.3/Objects/abstract.c%23L952#L952&quot;&gt;PyNumber_Subtract()&lt;/a&gt;，实现了减法的实际语义。继续查看该函数的一些宏，可以找到&lt;a href=&quot;https://github.com/python/cpython/blob/v3.8.3/Objects/abstract.c#L775-L820&quot;&gt;binary_op1()&lt;/a&gt; 函数。它提供了一种管理二元操作的通用方法。&lt;/div&gt;
&lt;div&gt;不过，我们不把它作为实现的参考，而是要用&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html&quot;&gt;Python的数据模型&lt;/a&gt;，官方文档很好，清楚介绍了减法所使用的语义。&lt;/div&gt;
&lt;h2&gt;从数据模型中学习&lt;/h2&gt;
&lt;div&gt;通读数据模型的文档，你会发现在实现减法时，有两个方法起到了关键作用：&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__sub__&quot;&gt;__sub__&lt;/a&gt; 和 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__rsub__&quot;&gt;__rsub__&lt;/a&gt;。&lt;/div&gt;
&lt;h3&gt;1、__sub__()方法&lt;/h3&gt;
&lt;div&gt;当执行&lt;code&gt;a - b&lt;/code&gt; 时，会在 a 的类型中查找__sub__()，然后把 b 作为它的参数。这很像我写&lt;a href=&quot;https://snarky.ca/unravelling-attribute-access-in-python/&quot;&gt;属性访问的文章&lt;/a&gt; 里的__getattribute__()，特殊/魔术方法是根据对象的类型来解析的，并不是出于性能目的而解析对象本身；在下面的示例代码中，我使用_mro_getattr() 表示此过程。&lt;/div&gt;
&lt;div&gt;因此，如果已定义 __sub__()，则 type(a).__sub__(a,b) 会被用来作减法操作。（译注：魔术方法属于对象的类型，不属于对象）&lt;/div&gt;
&lt;div&gt;这意味着在本质上，减法只是一个方法调用！你也可以将它理解成标准库中的 &lt;a href=&quot;https://docs.python.org/3.8/library/operator.html%23operator.sub#operator.sub&quot;&gt;operator.sub()&lt;/a&gt; 函数。&lt;/div&gt;
&lt;div&gt;我们将仿造该函数实现自己的模型，用 lhs 和 rhs 两个名称，分别表示 a-b 的左侧和右侧，以使示例代码更易于理解。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 通过调用__sub__()实现减法 &lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;sub&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lhs&lt;span&gt;:&lt;/span&gt; Any&lt;span&gt;,&lt;/span&gt; rhs&lt;span&gt;:&lt;/span&gt; Any&lt;span&gt;,&lt;/span&gt; &lt;span&gt;/&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; Any&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;Implement the binary operation `a - b`.&quot;&quot;&quot;&lt;/span&gt;
    lhs_type &lt;span&gt;=&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lhs&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        subtract &lt;span&gt;=&lt;/span&gt; _mro_getattr&lt;span&gt;(&lt;/span&gt;lhs_type&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;__sub__&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt; AttributeError&lt;span&gt;:&lt;/span&gt;
        msg &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&lt;span&gt;f&quot;unsupported operand type(s) for -: &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;lhs_type&lt;span&gt;!r&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt; and &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;rhs&lt;span&gt;)&lt;/span&gt;&lt;span&gt;!r&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
        &lt;span&gt;raise&lt;/span&gt; TypeError&lt;span&gt;(&lt;/span&gt;msg&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; subtract&lt;span&gt;(&lt;/span&gt;lhs&lt;span&gt;,&lt;/span&gt; rhs&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;2、让右侧使用__rsub__()&lt;/h3&gt;
&lt;div&gt;但是，如果 a 没有实现__sub__() 怎么办？如果 a 和 b 是不同的类型，那么我们会尝试调用 b 的 __rsub__()（__rsub__ 里面的“r”表示“右”，代表在操作符的右侧）。&lt;/div&gt;
&lt;div&gt;当操作的双方是不同类型时，这样可以确保它们都有机会尝试使表达式生效。当它们相同时，我们假设__sub__() 就能够处理好。但是，即使两边的实现相同，你仍然要调用__rsub__()，以防其中一个对象是其它的（子）类。&lt;/div&gt;
&lt;h3&gt;3、不关心类型&lt;/h3&gt;
&lt;div&gt;现在，表达式双方都可以参与运算！但是，如果由于某种原因，某个对象的类型不支持减法怎么办（例如不支持 4 - “stuff”）？在这种情况下，__sub__ 或__rsub__ 能做的就是返回 NotImplemented。&lt;/div&gt;
&lt;div&gt;这是给 Python 返回的信号，它应该继续执行下一个操作，尝试使代码正常运行。对于我们的代码，这意味着需要先检查方法的返回值，然后才能假定它起作用。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 减法的实现，其中表达式的左侧和右侧均可参与运算&lt;/span&gt;
_MISSING &lt;span&gt;=&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;sub&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lhs&lt;span&gt;:&lt;/span&gt; Any&lt;span&gt;,&lt;/span&gt; rhs&lt;span&gt;:&lt;/span&gt; Any&lt;span&gt;,&lt;/span&gt; &lt;span&gt;/&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; Any&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;# lhs.__sub__&lt;/span&gt;
        lhs_type &lt;span&gt;=&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lhs&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            lhs_method &lt;span&gt;=&lt;/span&gt; debuiltins&lt;span&gt;.&lt;/span&gt;_mro_getattr&lt;span&gt;(&lt;/span&gt;lhs_type&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;__sub__&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt; AttributeError&lt;span&gt;:&lt;/span&gt;
            lhs_method &lt;span&gt;=&lt;/span&gt; _MISSING

        &lt;span&gt;# lhs.__rsub__ (for knowing if rhs.__rub__ should be called first)&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            lhs_rmethod &lt;span&gt;=&lt;/span&gt; debuiltins&lt;span&gt;.&lt;/span&gt;_mro_getattr&lt;span&gt;(&lt;/span&gt;lhs_type&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;__rsub__&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt; AttributeError&lt;span&gt;:&lt;/span&gt;
            lhs_rmethod &lt;span&gt;=&lt;/span&gt; _MISSING

        &lt;span&gt;# rhs.__rsub__&lt;/span&gt;
        rhs_type &lt;span&gt;=&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;rhs&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            rhs_method &lt;span&gt;=&lt;/span&gt; debuiltins&lt;span&gt;.&lt;/span&gt;_mro_getattr&lt;span&gt;(&lt;/span&gt;rhs_type&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;__rsub__&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt; AttributeError&lt;span&gt;:&lt;/span&gt;
            rhs_method &lt;span&gt;=&lt;/span&gt; _MISSING

        call_lhs &lt;span&gt;=&lt;/span&gt; lhs&lt;span&gt;,&lt;/span&gt; lhs_method&lt;span&gt;,&lt;/span&gt; rhs
        call_rhs &lt;span&gt;=&lt;/span&gt; rhs&lt;span&gt;,&lt;/span&gt; rhs_method&lt;span&gt;,&lt;/span&gt; lhs

        &lt;span&gt;if&lt;/span&gt; lhs_type &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; rhs_type&lt;span&gt;:&lt;/span&gt;
            calls &lt;span&gt;=&lt;/span&gt; call_lhs&lt;span&gt;,&lt;/span&gt; call_rhs
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            calls &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;call_lhs&lt;span&gt;,&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

        &lt;span&gt;for&lt;/span&gt; first_obj&lt;span&gt;,&lt;/span&gt; meth&lt;span&gt;,&lt;/span&gt; second_obj &lt;span&gt;in&lt;/span&gt; calls&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; meth &lt;span&gt;is&lt;/span&gt; _MISSING&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;continue&lt;/span&gt;
            value &lt;span&gt;=&lt;/span&gt; meth&lt;span&gt;(&lt;/span&gt;first_obj&lt;span&gt;,&lt;/span&gt; second_obj&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; value &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; NotImplemented&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; value
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;raise&lt;/span&gt; TypeError&lt;span&gt;(&lt;/span&gt;
                &lt;span&gt;&lt;span&gt;f&quot;unsupported operand type(s) for -: &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;lhs_type&lt;span&gt;!r&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt; and &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;rhs_type&lt;span&gt;!r&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
            &lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;4、子类优先于父类&lt;/h3&gt;
&lt;div&gt;如果你看一下&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html%23object.rsub#object.rsub&quot;&gt;__rsub__()&lt;/a&gt; 的文档，就会注意到一条注释。它说如果一个减法表达式的右侧是左侧的子类（真正的子类，同一类的不算），并且两个对象的__rsub__() 方法不同，则在调用__sub__() 之前会先调用__rsub__()。换句话说，如果 b 是 a 的子类，调用的顺序就会被颠倒。&lt;/div&gt;
&lt;div&gt;这似乎是一个很奇怪的特例，但它背后是有原因的。当你创建一个子类时，这意味着你要在父类提供的操作上注入新的逻辑。这种逻辑不一定要加给父类，否则父类在对子类操作时，就很容易覆盖子类想要实现的操作。&lt;/div&gt;
&lt;div&gt;具体来说，假设有一个名为 Spam 的类，当你执行 Spam() - Spam() 时，得到一个 LessSpam 的实例。接着你又创建了一个 Spam 的子类名为 Bacon，这样，当你用 Spam 去减 Bacon 时，你得到的是 VeggieSpam。&lt;/div&gt;
&lt;div&gt;如果没有上述规则，Spam() - Bacon() 将得到 LessSpam，因为 Spam 不知道减掉 Bacon 应该得出 VeggieSpam。&lt;/div&gt;
&lt;div&gt;但是，有了上述规则，就会得到预期的结果 VeggieSpam，因为 Bacon.__rsub__() 首先会在表达式中被调用（如果计算的是 Bacon() - Spam()，那么也会得到正确的结果，因为首先会调用 Bacon.__sub__()，因此，规则里才会说两个类的不同的方法需有区别，而不仅仅是一个由 issubclass() 判断出的子类。）&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# Python中减法的完整实现&lt;/span&gt;
_MISSING &lt;span&gt;=&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;sub&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lhs&lt;span&gt;:&lt;/span&gt; Any&lt;span&gt;,&lt;/span&gt; rhs&lt;span&gt;:&lt;/span&gt; Any&lt;span&gt;,&lt;/span&gt; &lt;span&gt;/&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; Any&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;# lhs.__sub__&lt;/span&gt;
        lhs_type &lt;span&gt;=&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lhs&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            lhs_method &lt;span&gt;=&lt;/span&gt; debuiltins&lt;span&gt;.&lt;/span&gt;_mro_getattr&lt;span&gt;(&lt;/span&gt;lhs_type&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;__sub__&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt; AttributeError&lt;span&gt;:&lt;/span&gt;
            lhs_method &lt;span&gt;=&lt;/span&gt; _MISSING

        &lt;span&gt;# lhs.__rsub__ (for knowing if rhs.__rub__ should be called first)&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            lhs_rmethod &lt;span&gt;=&lt;/span&gt; debuiltins&lt;span&gt;.&lt;/span&gt;_mro_getattr&lt;span&gt;(&lt;/span&gt;lhs_type&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;__rsub__&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt; AttributeError&lt;span&gt;:&lt;/span&gt;
            lhs_rmethod &lt;span&gt;=&lt;/span&gt; _MISSING

        &lt;span&gt;# rhs.__rsub__&lt;/span&gt;
        rhs_type &lt;span&gt;=&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;rhs&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            rhs_method &lt;span&gt;=&lt;/span&gt; debuiltins&lt;span&gt;.&lt;/span&gt;_mro_getattr&lt;span&gt;(&lt;/span&gt;rhs_type&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;__rsub__&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt; AttributeError&lt;span&gt;:&lt;/span&gt;
            rhs_method &lt;span&gt;=&lt;/span&gt; _MISSING

        call_lhs &lt;span&gt;=&lt;/span&gt; lhs&lt;span&gt;,&lt;/span&gt; lhs_method&lt;span&gt;,&lt;/span&gt; rhs
        call_rhs &lt;span&gt;=&lt;/span&gt; rhs&lt;span&gt;,&lt;/span&gt; rhs_method&lt;span&gt;,&lt;/span&gt; lhs

        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;
            rhs_type &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; _MISSING  &lt;span&gt;# Do we care?&lt;/span&gt;
            &lt;span&gt;and&lt;/span&gt; rhs_type &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; lhs_type  &lt;span&gt;# Could RHS be a subclass?&lt;/span&gt;
            &lt;span&gt;and&lt;/span&gt; &lt;span&gt;issubclass&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;rhs_type&lt;span&gt;,&lt;/span&gt; lhs_type&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# RHS is a subclass!&lt;/span&gt;
            &lt;span&gt;and&lt;/span&gt; lhs_rmethod &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; rhs_method  &lt;span&gt;# Is __r*__ actually different?&lt;/span&gt;
        &lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            calls &lt;span&gt;=&lt;/span&gt; call_rhs&lt;span&gt;,&lt;/span&gt; call_lhs
        &lt;span&gt;elif&lt;/span&gt; lhs_type &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; rhs_type&lt;span&gt;:&lt;/span&gt;
            calls &lt;span&gt;=&lt;/span&gt; call_lhs&lt;span&gt;,&lt;/span&gt; call_rhs
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            calls &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;call_lhs&lt;span&gt;,&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

        &lt;span&gt;for&lt;/span&gt; first_obj&lt;span&gt;,&lt;/span&gt; meth&lt;span&gt;,&lt;/span&gt; second_obj &lt;span&gt;in&lt;/span&gt; calls&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; meth &lt;span&gt;is&lt;/span&gt; _MISSING&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;continue&lt;/span&gt;
            value &lt;span&gt;=&lt;/span&gt; meth&lt;span&gt;(&lt;/span&gt;first_obj&lt;span&gt;,&lt;/span&gt; second_obj&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; value &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; NotImplemented&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; value
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;raise&lt;/span&gt; TypeError&lt;span&gt;(&lt;/span&gt;
                &lt;span&gt;&lt;span&gt;f&quot;unsupported operand type(s) for -: &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;lhs_type&lt;span&gt;!r&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt; and &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;rhs_type&lt;span&gt;!r&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
            &lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;推广到其它二元运算&lt;/h2&gt;
&lt;div&gt;解决掉了减法运算，那么其它二元运算又如何呢？好吧，事实证明它们的操作相同，只是碰巧使用了不同的特殊/魔术方法名称。&lt;/div&gt;
&lt;div&gt;所以，如果我们可以推广这种方法，那么我们就可以实现 13 种操作的语义：+ 、-、*、@、/、//、％、**、&amp;lt;&amp;lt;、&amp;gt;&amp;gt;、＆、^、和 |。&lt;/div&gt;
&lt;div&gt;由于闭包和 Python 在对象自省上的灵活性，我们可以提炼出 operator 函数的创建。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 一个创建闭包的函数，实现了二元运算的逻辑&lt;/span&gt;
_MISSING &lt;span&gt;=&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt; &lt;span&gt;_create_binary_op&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name&lt;span&gt;:&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; operator&lt;span&gt;:&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; Any&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;Create a binary operation function.

    The `name` parameter specifies the name of the special method used for the
    binary operation (e.g. `sub` for `__sub__`). The `operator` name is the
    token representing the binary operation (e.g. `-` for subtraction).

    &quot;&quot;&quot;&lt;/span&gt;

    lhs_method_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&lt;span&gt;f&quot;__&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;name&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;__&quot;&lt;/span&gt;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;binary_op&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lhs&lt;span&gt;:&lt;/span&gt; Any&lt;span&gt;,&lt;/span&gt; rhs&lt;span&gt;:&lt;/span&gt; Any&lt;span&gt;,&lt;/span&gt; &lt;span&gt;/&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; Any&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;&quot;&quot;&quot;A closure implementing a binary operation in Python.&quot;&quot;&quot;&lt;/span&gt;
        rhs_method_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&lt;span&gt;f&quot;__r&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;name&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;__&quot;&lt;/span&gt;&lt;/span&gt;

        &lt;span&gt;# lhs.__*__&lt;/span&gt;
        lhs_type &lt;span&gt;=&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lhs&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            lhs_method &lt;span&gt;=&lt;/span&gt; debuiltins&lt;span&gt;.&lt;/span&gt;_mro_getattr&lt;span&gt;(&lt;/span&gt;lhs_type&lt;span&gt;,&lt;/span&gt; lhs_method_name&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt; AttributeError&lt;span&gt;:&lt;/span&gt;
            lhs_method &lt;span&gt;=&lt;/span&gt; _MISSING

        &lt;span&gt;# lhs.__r*__ (for knowing if rhs.__r*__ should be called first)&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            lhs_rmethod &lt;span&gt;=&lt;/span&gt; debuiltins&lt;span&gt;.&lt;/span&gt;_mro_getattr&lt;span&gt;(&lt;/span&gt;lhs_type&lt;span&gt;,&lt;/span&gt; rhs_method_name&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt; AttributeError&lt;span&gt;:&lt;/span&gt;
            lhs_rmethod &lt;span&gt;=&lt;/span&gt; _MISSING

        &lt;span&gt;# rhs.__r*__&lt;/span&gt;
        rhs_type &lt;span&gt;=&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;rhs&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            rhs_method &lt;span&gt;=&lt;/span&gt; debuiltins&lt;span&gt;.&lt;/span&gt;_mro_getattr&lt;span&gt;(&lt;/span&gt;rhs_type&lt;span&gt;,&lt;/span&gt; rhs_method_name&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt; AttributeError&lt;span&gt;:&lt;/span&gt;
            rhs_method &lt;span&gt;=&lt;/span&gt; _MISSING

        call_lhs &lt;span&gt;=&lt;/span&gt; lhs&lt;span&gt;,&lt;/span&gt; lhs_method&lt;span&gt;,&lt;/span&gt; rhs
        call_rhs &lt;span&gt;=&lt;/span&gt; rhs&lt;span&gt;,&lt;/span&gt; rhs_method&lt;span&gt;,&lt;/span&gt; lhs

        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;
            rhs_type &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; _MISSING  &lt;span&gt;# Do we care?&lt;/span&gt;
            &lt;span&gt;and&lt;/span&gt; rhs_type &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; lhs_type  &lt;span&gt;# Could RHS be a subclass?&lt;/span&gt;
            &lt;span&gt;and&lt;/span&gt; &lt;span&gt;issubclass&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;rhs_type&lt;span&gt;,&lt;/span&gt; lhs_type&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# RHS is a subclass!&lt;/span&gt;
            &lt;span&gt;and&lt;/span&gt; lhs_rmethod &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; rhs_method  &lt;span&gt;# Is __r*__ actually different?&lt;/span&gt;
        &lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            calls &lt;span&gt;=&lt;/span&gt; call_rhs&lt;span&gt;,&lt;/span&gt; call_lhs
        &lt;span&gt;elif&lt;/span&gt; lhs_type &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; rhs_type&lt;span&gt;:&lt;/span&gt;
            calls &lt;span&gt;=&lt;/span&gt; call_lhs&lt;span&gt;,&lt;/span&gt; call_rhs
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            calls &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;call_lhs&lt;span&gt;,&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

        &lt;span&gt;for&lt;/span&gt; first_obj&lt;span&gt;,&lt;/span&gt; meth&lt;span&gt;,&lt;/span&gt; second_obj &lt;span&gt;in&lt;/span&gt; calls&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; meth &lt;span&gt;is&lt;/span&gt; _MISSING&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;continue&lt;/span&gt;
            value &lt;span&gt;=&lt;/span&gt; meth&lt;span&gt;(&lt;/span&gt;first_obj&lt;span&gt;,&lt;/span&gt; second_obj&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; value &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; NotImplemented&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; value
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            exc &lt;span&gt;=&lt;/span&gt; TypeError&lt;span&gt;(&lt;/span&gt;
                &lt;span&gt;&lt;span&gt;f&quot;unsupported operand type(s) for &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;operator&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;lhs_type&lt;span&gt;!r&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt; and &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;rhs_type&lt;span&gt;!r&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
            &lt;span&gt;)&lt;/span&gt;
            exc&lt;span&gt;.&lt;/span&gt;_binary_op &lt;span&gt;=&lt;/span&gt; operator
            &lt;span&gt;raise&lt;/span&gt; exc&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;有了这段代码，你可以将减法运算定义为 _create_binary_op(“sub”, “-”)，然后根据需要重复定义出其它运算。&lt;/div&gt;
&lt;h2&gt;更多信息&lt;/h2&gt;
&lt;div&gt;通过本博客的&lt;a href=&quot;https://snarky.ca/tag/syntactic-sugar/&quot;&gt;“语法糖”标签&lt;/a&gt;，你可以找到更多详解 Python 语法的文章。源代码可以在&lt;a href=&quot;https://github.com/brettcannon/desugar&quot;&gt;https://github.com/brettcannon/desugar&lt;/a&gt;上找到。&lt;/div&gt;
&lt;h2&gt;更正&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2020-08-19：修复了当__rsub__() 比 __sub__() 先调用时的规则。&lt;/li&gt;
&lt;li&gt;2020-08-22：修复了当类型相同时不调用__rsub__ 的问题；还精简了过渡代码，仅保留开头和结尾代码，这让我轻松些。&lt;/li&gt;
&lt;li&gt;2020-08-23：在多数示例中添加了内容。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 到底是强类型语言，还是弱类型语言？</title>
            <link>https://pythoncat.top/posts/2020-08-30-typed/</link>
            <guid>https://pythoncat.top/posts/2020-08-30-typed/</guid>
            <pubDate>Sun, 30 Aug 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;h2&gt;0、前言&lt;/h2&gt;
&lt;div&gt;我在上一篇文章中分析了 &lt;a href=&quot;https://mp.weixin.qq.com/s/wWCgwMofSvKBbi3gZLxsAQ&quot;&gt;为什么 Python 没有 void 类型&lt;/a&gt; 的话题，在文章发布后，有读者跟我讨论起了另一个关于类型的问题，但是，我们很快就出现了重大分歧。&lt;/div&gt;
&lt;div&gt;我们主要的分歧就在于：&lt;strong&gt;Python 到底是不是强类型语言？&lt;/strong&gt; 我认为是，而他认为不是。&lt;/div&gt;
&lt;div&gt;他写了一篇很长的文章《&lt;a href=&quot;https://blog.csdn.net/nokiaguy/article/details/108218260&quot;&gt;谁告诉的你们Python是强类型语言！站出来，保证不打你！&lt;/a&gt;》，专门重申了他的观点，但可惜错漏百出。&lt;/div&gt;
&lt;div&gt;我曾有想法要写写关于 Python 类型的问题，现在借着这个机会，就来系统地梳理一下吧。&lt;/div&gt;
&lt;div&gt;（PS：在我写作进行到差不多一半的时候，微信读者群里恰好也讨论到“强弱类型”的话题！在与大家讨论时，我的一些想法得到了验证，同时我也学到了很多新知识，所以本文的部分内容有群友们的功劳，特此鸣谢！）&lt;/div&gt;
&lt;h2&gt;1、动静类型与强弱类型&lt;/h2&gt;
&lt;div&gt;很多读者应该都熟悉&lt;code&gt;动态类型&lt;/code&gt; 与&lt;code&gt;静态类型&lt;/code&gt; ，但是很多人也会把它们跟&lt;code&gt;强弱类型&lt;/code&gt; 混为一谈，所以我们有必要先作一下概念上的澄清。&lt;/div&gt;
&lt;div&gt;这两组类型都是针对于编程语言而言的，但关注的核心问题不同。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;对于“动静类型”概念，它的核心问题是“什么时候知道一个变量是哪种类型”？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;一般而言，在编译期就确定变量类型的是静态类型语言，在运行期才确定变量类型的则是动态类型语言。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;例如，某些语言中定义函数“int func(int a){…}”，在编译时就能确定知道它的参数和返回值是 int 类型，所以是静态类型；而典型如 Python，定义函数时写“def func(a):…”，并不知道参数和返回值的类型，只有到运行时调用函数，才最终确定参数和返回值的类型，所以是动态类型&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;对于“强弱类型”概念，它的核心问题是“不同类型的变量是否允许隐式转化”？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;一般而言，编译器有很少（合理）隐式类型转化的是强类型语言，有较多（过分）隐式类型转化的是弱类型语言。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;例如，Javascript 中的 &lt;code&gt;&quot;1000&quot;+1&lt;/code&gt; 会得到字符串“10001”，而 &lt;code&gt;&quot;1000&quot;-1&lt;/code&gt; 则会得到数字 999，也就是说，编译器根据使用场合，对两种不同类型的对象分别做了隐式的类型转化，但是相似的写法，在强类型语言中则会报类型出错。（数字与字符串的转化属于过分的转化，下文会再提到一些合理的转化。）&lt;/div&gt;
&lt;div&gt;按照以上的定义，有人将常见的编程语言画了一张分类图：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;按强弱类型维度的划分，可以归纳出：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;强类型：Java、C#、Python、Ruby、Erlang（再加GO、Rust）……&lt;/li&gt;
&lt;li&gt;弱类型：C、C++、Javascript、Perl、PHP、VB……&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2、过去的强弱类型概念&lt;/h2&gt;
&lt;div&gt;动静类型的概念基本上被大家所认可，然而，强弱类型的概念在问答社区、技术论坛和学术讨论上却有很多的争议。此处就不作罗列了。&lt;/div&gt;
&lt;div&gt;为什么会有那么多争议呢？&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;最主要的原因之一是有人把它与动静类型混用了。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;最明显的一个例子就是 Guido van Rossum 在 2003 年参加的一个访谈，它的话题恰好是关于强弱类型的（&lt;a href=&quot;https://www.artima.com/intv/strongweak.html&quot;&gt;Strong versus Weak Typing&lt;/a&gt;）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;但是，他们谈论的明显只是动静类型的区别。&lt;/div&gt;
&lt;div&gt;访谈中还引述了 Java 之父 James Gosling 的话，从他的表述中也能看出，他说的“强弱类型”其实也是动静类型的区分。&lt;/div&gt;
&lt;div&gt;另外还有一个经典的例子，C 语言之父 Dennis Ritchie 曾经说 C 语言是一种“强类型但是弱检查”**的语言。如果对照成前文的定义，那他其实指的是“静态类型弱类型”。&lt;/div&gt;
&lt;div&gt;为什么这些大佬们会有混淆呢？&lt;/div&gt;
&lt;div&gt;其实原因也很简单，&lt;strong&gt;那就是在当时还没有明确的动静类型与强弱类型的概念之分！或者说，那时候的强弱类型指的就是动静类型。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;维基百科上给出了 1970 年代对强类型的定义，基本可以还原成前文提到的静态类型：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;In 1974, Liskov and Zilles defined a strongly-typed language as one in which “whenever an object is passed from a calling function to a called function, its type must be compatible with the type declared in the called function.“[&lt;a href=&quot;https://en.wikipedia.org/wiki/Strong_and_weak_typing#cite_note-2&quot;&gt;3]&lt;/a&gt; In 1977, Jackson wrote, “In a strongly typed language each data area will have a distinct type and each process will state its communication requirements in terms of these types.“[&lt;a href=&quot;https://en.wikipedia.org/wiki/Strong_and_weak_typing#cite_note-3&quot;&gt;4]&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;前面几位编程语言之父应该就是持有类似的观念。&lt;/div&gt;
&lt;div&gt;不过，大佬们也意识到了当时的“强弱类型”概念并不充分准确，所以 Dennis Ritchie 才会说成“&lt;strong&gt;强类型但是弱检查&lt;/strong&gt;”，而且在访谈中，Guido 也特别强调了 Python 不应该被称为弱类型，而应该说是&lt;strong&gt;运行时类型（runtime typing）&lt;/strong&gt; 。&lt;/div&gt;
&lt;div&gt;但是在那个早期年代，基本上强弱类型就等同于动静类型，而这样的想法至今仍在影响着很多人。&lt;/div&gt;
&lt;h2&gt;3、现在的强弱类型概念&lt;/h2&gt;
&lt;div&gt;早期对于编程语言的分类其实是混杂了动静与强弱两个维度，但是，它们并不是一一对应重合的关系，并不足以表达编程语言间的区别，因此就需要有更为明确/丰富的定义。&lt;/div&gt;
&lt;div&gt;有人提出了“type safety”、“memory safety”等区分维度，也出现了静态检查类型和动态检查类型，与强弱类型存在一定的交集。&lt;/div&gt;
&lt;div&gt;直到出现 2004 年的一篇集大成的学术论文《&lt;a href=&quot;http://lucacardelli.name/Papers/TypeSystems.pdf&quot;&gt;Type Systems&lt;/a&gt;》（出自微软研究院，作者 Luca Cardelli），专门研究编程语言的不同类型系统：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;论文中对于强弱检查（也即强弱类型）有一个简短的归纳如下：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Strongly checked language: A language where no forbidden errors can occur at run time (depending on the definition of forbidden error).&lt;/li&gt;
&lt;li&gt;Weakly checked language: A language that is statically checked but provides no clear guarantee of absence of execution errors.&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;其关键则是程序对于 &lt;em&gt;untrapped errors&lt;/em&gt; 的检查强度，在某些实际已出错的地方，弱类型程序并不作捕获处理，例如 C 语言的一些指针计算和转换，而《&lt;a href=&quot;http://doc.cat-v.org/henry_spencer/ten-commandments&quot;&gt;C 程序员十诫&lt;/a&gt;》的前几个都是弱类型导致的问题。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;论文对于这些概念的定义还是比较抽象的，由于未捕获的错误（untrapped errors）大多是由于隐式类型转换所致，所以又演化出了第一节中的定义，以隐式类型转换作为判断标准。&lt;/div&gt;
&lt;div&gt;如今将“&lt;strong&gt;对隐式类型转换的容忍度&lt;/strong&gt;”**作为强弱类型的分类标准，已经是很多人的共识（虽然不够全面，而且有一些不同的声音）。&lt;/div&gt;
&lt;div&gt;例如，维基百科就把隐式类型转换作为弱类型的主要特点之一：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;A weakly typed language has looser typing rules and may produce unpredictable results or may perform implicit type conversion at runtime.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;例如，以 Python 为例，&lt;strong&gt;社区的主流看法认为它是强类型语言，而判断的标准也是看隐式类型转换。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;例子有很多，比如 Python 官方的 wiki，它专门回答了&lt;a href=&quot;https://wiki.python.org/moin/Why%20is%20Python%20a%20dynamic%20language%20and%20also%20a%20strongly%20typed%20language&quot;&gt;Why is Python a dynamic language and also a strongly typed language&lt;/a&gt; ，给出了 4 个答案，为 Python 的“动态强类型”定性：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;再比如，在《流畅的Python》第11章的杂谈中，也专门提到了强弱类型的分类。（它的用语是“很少隐式类型转换”，算是比较严谨的，但是也错误地把 C++ 归为了强类型。）&lt;/div&gt;
&lt;h2&gt;4、Python 是不是强类型语言？&lt;/h2&gt;
&lt;div&gt;关于“Python 是否属于强类型”话题，在主流观点之外，还存在着不少误解的看法。&lt;/div&gt;
&lt;div&gt;一方面的原因有些人混用了强弱类型与动静类型，这有历史的原因，前面已经分析了。&lt;/div&gt;
&lt;div&gt;另外还有一个同样重要的原因，即有人把弱类型等同于“完全没有隐式类型转换”了，这种想法并不对。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;事实上，强弱类型的概念中包含着部分相对主义的含义，强类型语言中也可能有隐式类型转换。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;比如，Rust 语言为了实现“内存安全”的设计哲学，设计了很强大的类型系统，但是它里面也有隐式类型转换（自动解引用）。&lt;/div&gt;
&lt;div&gt;问题在于：&lt;strong&gt;怎么样的隐式类型转换是在合理范围内的？以及，某些表面的隐式类型转换，是否真的是隐式类型转换？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;回到 Python 的例子，我们可以分析几种典型的用法。&lt;/div&gt;
&lt;div&gt;比如，&lt;code&gt;&quot;test&quot;*3&lt;/code&gt; 这种字符串“乘法”运算，虽然是两种类型的操作，但是并不涉及隐式类型转换转化。&lt;/div&gt;
&lt;div&gt;比如，&lt;code&gt;x=10; x=&quot;test&quot;&lt;/code&gt; 先后给一个变量不同类型的赋值，表面上看 x 的类型变化了，用 type(x) 可以判断出不同，但是，Python 中的类型是跟值绑定的（右值绑定），并不是跟变量绑定的。&lt;/div&gt;
&lt;div&gt;变量 x 准确地说只是变量名，是绑定到实际变量上的一个标签，它没有类型。type(x) 判断出的并不是 x 本身的类型，而是 x 指向的对象的类型，就像内置函数 id(x) 算出的也不是 x 本身的地址，而是实际的对象的地址。&lt;/div&gt;
&lt;div&gt;比如，&lt;code&gt;1 + True&lt;/code&gt; 这种数字与布尔类型的加法运算，也没有发生隐式类型转换。因为 Python 中的布尔类型其实是整型的子类，是同一种类型！（如果有疑问，可查阅 &lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn/blob/master/StandardsTrack/285--%E6%B7%BB%E5%8A%A0%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B.md&quot;&gt;PEP-285&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;再比如，整数/布尔值与浮点数相加，在 Python 中也不需要作显式类型转换。但是，它的实现过程其实是用了数字的&lt;code&gt;__add__()&lt;/code&gt; 方法，Python 中一切皆对象，数字对象也有自己的方法。（其它语言可不一定）&lt;/div&gt;
&lt;div&gt;也就是说，&lt;strong&gt;数字间的算术运算操作，其实是一个函数调用的过程，跟其它语言中的算术运算有着本质的区别。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;另外，不同的数字类型虽然在计算机存储层面有很大差异，但在人类眼中，它们是同一种类型（宽泛地分），所以就算发生了隐式类型转换，在逻辑上也是可以接受的。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;最后，还有一个例子，即 Python 在 if/while 之后的真值判断，我之前分析过它的&lt;a href=&quot;https://mp.weixin.qq.com/s/g6jZX0IdH9xpM7BMV3-ToQ&quot;&gt;实现原理&lt;/a&gt; ，它会把其它类型的对象转化成布尔类型的值。&lt;/div&gt;
&lt;div&gt;但是，它实际上也只是函数调用的结果（__bool__() 和 __len__()），是通过计算而得出的合理结果，并不属于隐式的强制类型转换，不在 untrapped errors 的范畴里。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;所以，严格来说，前面 5 个例子中都没有发生类型转换。&lt;/strong&gt; 浮点数和真值判断的例子，直观上看是发生了类型转换，但它们其实是 Python 的特性，是可控的、符合预期的、并没有对原有类型造成破坏。&lt;/div&gt;
&lt;div&gt;退一步讲，若放宽“隐式类型转换”的含义，认为后两个例子发生了隐式类型转换，但是，它们是通过严谨的函数调用过程实现的，也不会出现 forbidden errors，所以还是属于强检查类型。&lt;/div&gt;
&lt;h2&gt;5、其它相关的问题&lt;/h2&gt;
&lt;div&gt;前文对概念的含义以及 Python 中的表现，作了细致的分析。接下来，为了逻辑与话题的完整性，我们还需要回答几个小问题：&lt;/div&gt;
&lt;div&gt;（1）能否以“隐式类型转换”作为强弱类型的分类依据？&lt;/div&gt;
&lt;div&gt;明确的分类定义应该以《&lt;a href=&quot;http://lucacardelli.name/Papers/TypeSystems.pdf&quot;&gt;Type Systems&lt;/a&gt;》为准，它有一套针对不同 error 的分类，强弱类型其实是对于 forbidden errors 的处理分类。隐式类型转换是其明显的特征，但并不是全部，也不是唯一的判断依据。&lt;/div&gt;
&lt;div&gt;本文为了方便理解，使用这个主要特征来划分强弱类型，但是要强调，强类型不是没有隐式类型转换，而是可能有很少且合理的隐式类型转换。&lt;/div&gt;
&lt;div&gt;（2）假如有其它解释器令 Python 支持广泛的隐式类型转换，那 Python 还是强类型语言么？&lt;/div&gt;
&lt;div&gt;语言的标准规范就像是法律，而解释器是执法者。如果有错误的执法解释，那法律还是那个法律，应该改掉错误的执法行为；如果是法律本身有问题（造成了解释歧义和矛盾，或者该废弃），那就应该修改法律，保证它的确定性（要么是强类型，要么是弱类型）。&lt;/div&gt;
&lt;div&gt;（3）为什么说 Javascript 是弱类型？&lt;/div&gt;
&lt;div&gt;因为它的隐式类型转换非常多、非常复杂、非常过分！比如，Javascript 中&lt;code&gt;123 + null&lt;/code&gt; 结果为 123，&lt;code&gt;123 + {} &lt;/code&gt; 结果为字符串“123[object Object]”。&lt;/div&gt;
&lt;div&gt;另外，它的双等号“==”除了有基本的比较操作，还可能发生多重的隐式类型转换，例如&lt;code&gt;true==[&apos;2&apos;]&lt;/code&gt; 判断出的结果为 false，而&lt;code&gt;true==[&apos;1&apos;]&lt;/code&gt; 的结果是 true，还有&lt;code&gt;[]==![]&lt;/code&gt; 和&lt;code&gt;[undefined]==false&lt;/code&gt; 的结果都为 true……&lt;/div&gt;
&lt;div&gt;（4）C++ 是不是弱类型语言？&lt;/div&gt;
&lt;div&gt;前文提到《流畅的Python》中将 C++ 归为强类型，但实际上它应该被归为弱类型。C++ 的类型转换是个非常复杂的话题，@樱雨楼 小姐姐曾写过一个系列文章做了系统论述，文章地址：&lt;a href=&quot;https://mp.weixin.qq.com/s/lJiva3BUJXUV0cpX1dOe2Q&quot;&gt;如何攻克 C++ 中复杂的类型转换？&lt;/a&gt; 、&lt;a href=&quot;https://mp.weixin.qq.com/s/S_1KPn_GWJ7hmLH19Dajfg&quot;&gt;详解 C++ 的隐式类型转换与函数重载！&lt;/a&gt;  、&lt;a href=&quot;https://mp.weixin.qq.com/s/q3iwtvqMSp6lNC_ZR_SP6A&quot;&gt;谁说 C++ 的强制类型转换很难懂？&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;6、小结&lt;/h2&gt;
&lt;div&gt;强弱类型概念在网上有比较多的争议，不仅在 Python 是如此，在 C/C++ 之类的语言更甚。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;其实在学术上，这个概念早已有明确的定义，而且事实上也被很多人所接纳。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;那些反对的声音大多是因为概念混用，因为他们忽略了另一种对语言进行分类的维度；同时，还有一部分值得注意的原因，即不能认为强类型等于“完全无隐式类型转换”或“只要没有xxx隐式类型转换”。&lt;/div&gt;
&lt;div&gt;本文介绍了社区中对 Python 的主流分类，同时对几类疑似隐式类型转换的用法进行了分析，论证出它是一种强类型语言。&lt;/div&gt;
&lt;div&gt;文章体现了作者一贯的刨根问底精神，这是“&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;Python为什么&lt;/a&gt;”系列文章的风格，如果你喜欢本文，欢迎订阅关注！&lt;/div&gt;
&lt;h2&gt;相关链接&lt;/h2&gt;
&lt;div&gt;[1] 谁告诉的你们Python是强类型语言！站出来，保证不打你！: &lt;a href=&quot;https://blog.csdn.net/nokiaguy/article/details/108218260&quot;&gt;https://blog.csdn.net/nokiaguy/article/details/108218260&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[2] Strong versus Weak Typing: &lt;a href=&quot;https://www.artima.com/intv/strongweak.html&quot;&gt;https://www.artima.com/intv/strongweak.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[3] &lt;a href=&quot;https://en.wikipedia.org/wiki/Strong_and_weak_typing#cite_note-2&quot;&gt;https://en.wikipedia.org/wiki/Strong_and_weak_typing#cite_note-2&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[4] &lt;a href=&quot;https://en.wikipedia.org/wiki/Strong_and_weak_typing#cite_note-3&quot;&gt;https://en.wikipedia.org/wiki/Strong_and_weak_typing#cite_note-3&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[5] Type Systems: &lt;a href=&quot;http://lucacardelli.name/Papers/TypeSystems.pdf&quot;&gt;http://lucacardelli.name/Papers/TypeSystems.pdf&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[6] C 程序员十诫: &lt;a href=&quot;http://doc.cat-v.org/henry_spencer/ten-commandments&quot;&gt;http://doc.cat-v.org/henry_spencer/ten-commandments&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[7] Why is Python a dynamic language and also a strongly typed language: &lt;a href=&quot;https://wiki.python.org/moin/Why%20is%20Python%20a%20dynamic%20language%20and%20also%20a%20strongly%20typed%20language&quot;&gt;https://wiki.python.org/moin/Why%20is%20Python%20a%20dynamic%20language%20and%20also%20a%20strongly%20typed%20language&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[8] PEP-285: &lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn/blob/master/StandardsTrack/285--%E6%B7%BB%E5%8A%A0%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B.md&quot;&gt;https://github.com/chinesehuazhou/peps-cn/blob/master/StandardsTrack/285—%E6%B7%BB%E5%8A%A0%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B.md&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[9] Type Systems: &lt;a href=&quot;http://lucacardelli.name/Papers/TypeSystems.pdf&quot;&gt;http://lucacardelli.name/Papers/TypeSystems.pdf&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[10] Python为什么: &lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;https://github.com/chinesehuazhou/python-whydo&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 为什么没有 void 关键字？</title>
            <link>https://pythoncat.top/posts/2020-08-21-void/</link>
            <guid>https://pythoncat.top/posts/2020-08-21-void/</guid>
            <pubDate>Fri, 21 Aug 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;code&gt;void&lt;/code&gt; 是编程语言中最常见的关键字之一，从字面上理解，它是“空的、空集、空白”的意思，&lt;strong&gt;最常用于&lt;/strong&gt; 表示函数的一种返回值类型。&lt;/div&gt;
&lt;div&gt;维基百科上有一个定义：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;The void type, in several programming languages derived from C and Algol68, is the type for the result of a function that returns normally, but does not provide a result value to its caller.&lt;/p&gt;
&lt;p&gt;在 C、Algol68 及它们所派生的几种编程语言中，void 类型是函数正常返回的一种类型，但是不会给调用者返回一个值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;&lt;strong&gt;简单来说，void 是一种类型（type），但是没有具体的值（value）。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;这到底是什么意思呢？&lt;/div&gt;
&lt;div&gt;以 Python 的几种常见类型为例，我们可以从对比中看出规律：int 是一种表示整数的类型，它有无限个可能的整数值；bool 是一种布尔类型，它有两个可能的值（True 和 False）；NoneType 是一种表示 None 的类型，它只有一个值（None）。&lt;/div&gt;
&lt;div&gt;至于 void，它是一种更为抽象的特殊类型，但是不包含任何值。&lt;/div&gt;
&lt;div&gt;介绍完概念上的含义，我们就可以进入正题了。标题中的问题可以进一步分解成两个：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;其它语言为什么要使用 void 关键字？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python 为什么不设计出 void 关键字？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;对于第一个问题，我们以 C/C++ 为例，先看看 void 的两种使用场景（PS：此处只考虑函数的用法，不考虑指针的用法，因为 Python 没有指针）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;当 void 用在函数的参数位置时，它表示该函数不需要传参。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;最初 C 语言的&lt;code&gt;f()&lt;/code&gt; 表示参数数量不确定，为了另外表达“不需要参数”的语义，所以引入&lt;code&gt;f(void)&lt;/code&gt; 作为限定。后来的语言（包括 Python）基本不在参数中使用 void，而是直接用&lt;code&gt;f()&lt;/code&gt; 表示不需传参。C++ 为了兼容 C，所以才同时支持这两种语法。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;当 void 用在函数前作修饰时，它表示该函数没有返回值。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;在 C 语言中，若不声明返回类型，则&lt;code&gt;f()&lt;/code&gt; 函数在编译后会返回整型的值。为了避免混乱，当不需要返回值时，就使用&lt;code&gt;void f()&lt;/code&gt; 来作限定。&lt;/div&gt;
&lt;div&gt;同时，更主要的是，它还起到了占位符的作用，表明一个函数的类型是已知的，这对代码可读性和编译都有所帮助。&lt;/div&gt;
&lt;div&gt;void 作为函数的空返回值类型，这种用法在 C++/Java 中也被继承了。另外，在 Javascript 中也有 void 的身影，只不过它成了一种操作符，起到了完全不同的作用，此处不表。&lt;/div&gt;
&lt;div&gt;但是，&lt;strong&gt;Python 从头到尾都没有 void 关键字。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;为什么会这样？难道是因为在 Python 中不存在其它语言所面对的问题么？还是说，Python 中有自己的一套解决方案？&lt;/div&gt;
&lt;div&gt;仍以跟函数相关的两种用法为例作分析吧。&lt;/div&gt;
&lt;div&gt;在表示函数不需传参时，&lt;code&gt;f(void)&lt;/code&gt; 这种写法根本就是多余的，所以 Python 使用了最简单明了的无参式写法&lt;code&gt;f()&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;至于返回值类型的用法，在我们定义出一个函数时，例如最简单的&lt;code&gt;def func():pass&lt;/code&gt; ，为了让它的调用结果&lt;code&gt;func()&lt;/code&gt; 是一个合法的对象，那它必须具有一个有效的类型（type）。&lt;/div&gt;
&lt;div&gt;这应该是以类型为基的编程语言都会遇到的共性问题，Python 也不例外。&lt;/div&gt;
&lt;div&gt;这个时候，如果函数本身没有显式地 return 出一个对象的话，就有两种可能的解决办法：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;方法一，即声明该函数为 void 类型，像 C 和其它语言所做的那样，只要能通过类型检查即可&lt;/li&gt;
&lt;li&gt;方法二，则是 Python 所用的方法，即令解释器隐式地返回一个 None 对象，也就是令函数默认得到一个 NoneType 类型，再用于类型检查（PS：Javascript 也类似，只不过它默认返回的是 undefined，它不是一个对象，而是一种表示“未定义”的类型，类似于 void）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;strong&gt;简单而言，Python 的设计思路是直接复用已有的 NoneType 类型，并让解释器来填补缺失掉的函数类型。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;关于 Python 解释器的这个隐式填补过程，我已在上一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/e31XEz7z2Wl2jZaaYYGgbA&quot;&gt;Python 函数为什么会默认返回 None？&lt;/a&gt;》文章详细分析过，感兴趣的同学可去查阅。&lt;/div&gt;
&lt;div&gt;这样做的好处至少有两点：&lt;strong&gt;一是没有引入新的 void 类型和关键字；二是不需要程序员在函数前声明返回类型，这就跟有显式返回值的写法保持了一致。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;试想一下，如果 Python 不让函数默认有返回值的话，就可能要写成 &lt;code&gt;void def func():...&lt;/code&gt; 这样的形式，那它就变成了函数定义时的一种特例。与另一种特例函数相比，即异步函数&lt;code&gt;asyc def func():... &lt;/code&gt; ，就可能引起混乱。&lt;/div&gt;
&lt;div&gt;总体而言，Python 似乎认为 void 空类型不是那么有存在的必要，似乎 NoneType 类型就足够了，而当缺少返回值时，让解释器统一注入是极为方便的，因此才出现了我们看到的现状。&lt;/div&gt;
&lt;div&gt;至此，文章标题的问题算是圆满回答了。&lt;/div&gt;
&lt;div&gt;最后，让我们开始进入 ending 吧：本文明面上是以“Python 为什么没有 void 关键字”为切入点，然而，它实际上瞄准的却是“Python 为什么需要返回 None”的问题。&lt;/div&gt;
&lt;div&gt;在《&lt;a href=&quot;https://mp.weixin.qq.com/s/e31XEz7z2Wl2jZaaYYGgbA&quot;&gt;Python 函数为什么会默认返回 None？&lt;/a&gt;》这篇文章中，我介绍了  Python 中函数默认返回 None 的机制，它是属于“how can”的内容。但是为什么要默认返回 None 呢？这则是属于“why need”或者“why should”的问题，而它需要从 void 关键字的缺失开始谈起……&lt;/div&gt;
&lt;div&gt;那么，为什么 Python 没有 void 关键字呢？请往上翻，重新阅读本文……&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 函数为什么会默认返回 None？</title>
            <link>https://pythoncat.top/posts/2020-08-15-None/</link>
            <guid>https://pythoncat.top/posts/2020-08-15-None/</guid>
            <pubDate>Sat, 15 Aug 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 有一项默认的做法，很多编程语言都没有——&lt;strong&gt;它的所有函数都会有一个返回值，不管你有没有写 return 语句。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;在正式开始之前，我们就用之前讨论过的 &lt;a href=&quot;https://mp.weixin.qq.com/s/GpBOO0MLsc6g_mNq85Zy0A&quot;&gt;pass语句&lt;/a&gt; 和 &lt;a href=&quot;https://mp.weixin.qq.com/s/SOSN_p74eDHv3tJnSJIZfg&quot;&gt;…对象&lt;/a&gt; 作为例子，看看 Python 的函数是怎样“无中生有”的：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;可以看出，我们定义的两个函数都没有写任何的 return 语句，但是在函数调用后，都能取到一个返回值。&lt;/div&gt;
&lt;div&gt;它们的执行效果跟直接写 return 语句相比，是完全相同的：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这 4 个例子属于两种类型：一种没有写 return，但是都有隐藏的 return 返回值；一种写了 return，而且实际也有返回值。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;也就是说，后者在语义和行为上表现一致，前者虽然在语义上缺失，但是却有实际的行为和结果；后者的行为是显性的，前者却是隐性的。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;《Python之禅》中有一句“显性胜于隐性（Explicit is better than implicit）”，但是，出于简洁和便利的考虑（Simple is better than complex），实际上 Python 中有很多行为都是隐性的，会把一些在语法层面的事交给解释器去完成。&lt;/div&gt;
&lt;div&gt;上一期的 &lt;a href=&quot;https://mp.weixin.qq.com/s/g6jZX0IdH9xpM7BMV3-ToQ&quot;&gt;真值判断&lt;/a&gt; 是隐性的行为，本文前两个例子也是如此。&lt;/div&gt;
&lt;div&gt;使用&lt;code&gt;dis&lt;/code&gt; 查看字节码，就可以看到其背后的小动作：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;在这个对比图中，可以看出上述 4 个函数的解释器指令一模一样！&lt;/div&gt;
&lt;div&gt;不管有没有写 return，它们都会执行 return 的逻辑，而且默认的返回值就是  None。&lt;/div&gt;
&lt;div&gt;那么，问题来了：&lt;strong&gt;Python 的函数为什么能默认返回 None 呢？它是如何实现的呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;答案就在解释器中，当 CPython 解释器执行到函数的最后一个代码块时，若发现没有返回值，它就会主动地加上一个 Py_None 值返回（出自：compile.c）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;也就是说，如果定义的函数没有返回值，Python 解释器就会（强行地）默认给我们注入一段返回逻辑！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;对于解释器的这种附赠的服务，大家是觉得很贴心，还是嫌弃它多事呢？&lt;/div&gt;
&lt;div&gt;这样的做法似乎没多少好处，但似乎也没有坏处？&lt;/div&gt;
&lt;div&gt;那么，这就会引出新的问题：&lt;strong&gt;Python 为什么要求函数都要有返回值呢？为什么它不像某些语言那样，提供一个 void 关键字，支持定义无返回值的空函数呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;请查看本系列的下一篇文章！&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>一个在交流群里讨论过两轮的问题，答案竟然跟一个 PEP 有关</title>
            <link>https://pythoncat.top/posts/2020-08-14-PEP/</link>
            <guid>https://pythoncat.top/posts/2020-08-14-PEP/</guid>
            <pubDate>Fri, 14 Aug 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 中有没有办法通过类方法找到其所属的类？&lt;/div&gt;
&lt;div&gt;这个问题看起来不容易理解，我可以给出一个例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;@xxx&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;foo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;现在有一个类和一个类方法，其中类方法上有一个装饰器。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;我们的问题就是要在装饰器代码中动态地获得 Test 这个类（类名+类对象）。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;去年 11 月份的时候，我在微信读者群里提出了这个问题，当时引起了小范围的讨论。&lt;/div&gt;
&lt;div&gt;没想到在今年上个月的时候，群里又有人提了同样的问题（我在讨论结束后才看到），而且最终都找到了 stackoverflow 上一个同样的问题：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;stackoverflow 上的问题提得很明确：&lt;a href=&quot;https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3&quot;&gt;Get defining class of unbound method object in Python 3&lt;/a&gt; 。但是 unbound method 的叫法已经不常见了，详细的讨论也就不展开了，感兴趣的同学可以去查阅。&lt;/div&gt;
&lt;div&gt;这个问题的关键是要使用在 Python 3.3 中引入的__qualname__ 属性，通过它可以获取上层类的名称。&lt;/div&gt;
&lt;div&gt;铺垫了这么多，开始进入本文的正题了：&lt;strong&gt;__qualname__ 属性是什么东西？为什么 Python 3 要特别引入它呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;下文是 PEP-3155 的翻译摘录，清楚地说明了这个属性的来龙去脉。&lt;/div&gt;
&lt;div&gt;完整内容可在 Github 仓库查看：&lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn/blob/master/StandardsTrack/3155--%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E7%89%B9%E5%AE%9A%E5%90%8D%E7%A7%B0.md&quot;&gt;https://github.com/chinesehuazhou/peps-cn/blob/master/StandardsTrack/3155—%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E7%89%B9%E5%AE%9A%E5%90%8D%E7%A7%B0.md&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;-------------------摘录开始--------------------&lt;/div&gt;
&lt;h2&gt;原理&lt;/h2&gt;
&lt;div&gt;一直以来，对于嵌套类的自省，Python 的支持很不够。给定一个类对象，根本不可能知道它是在某个类中定义的，还是在顶层模块中定义的；而且，如果是前者，也不可能知道它具体是在哪个类中定义的。虽然嵌套类通常被认为是不太好的用法，但这不应该成为不支持内层自省的理由。&lt;/div&gt;
&lt;div&gt;Python 3 因为丢弃了以前的未绑定方法（unbound method），而受到了侮辱性的伤害。&lt;/div&gt;
&lt;div&gt;在 Python 2 中，给出以下定义：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;C&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;你可以从&lt;code&gt;C.f&lt;/code&gt; 对象中获得其所属的类：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; C&lt;span&gt;.&lt;/span&gt;f&lt;span&gt;.&lt;/span&gt;im_class
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;&apos;__main__.C&apos;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这种用法在 Python 3 中已经没有了：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; C&lt;span&gt;.&lt;/span&gt;f&lt;span&gt;.&lt;/span&gt;im_class
Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  File &lt;span&gt;&quot;&amp;lt;stdin&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; line &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;module&lt;span&gt;&amp;gt;&lt;/span&gt;
AttributeError&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;function&apos;&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; has no attribute &lt;span&gt;&apos;im_class&apos;&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;dir&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;C&lt;span&gt;.&lt;/span&gt;f&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;__annotations__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__call__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__class__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__closure__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__code__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
&lt;span&gt;&apos;__defaults__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__delattr__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__dict__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__dir__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__doc__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
&lt;span&gt;&apos;__eq__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__format__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__ge__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__get__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__getattribute__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
&lt;span&gt;&apos;__globals__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__gt__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__hash__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__init__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__kwdefaults__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
&lt;span&gt;&apos;__le__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__lt__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__module__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__name__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__ne__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__new__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
&lt;span&gt;&apos;__reduce__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__reduce_ex__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__repr__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__setattr__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__sizeof__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
&lt;span&gt;&apos;__str__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__subclasshook__&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这就限制了用户可以使用的自省能力。当将程序移植到 Python 3 时，它可能会产生一些实际的问题，例如在 Twisted 的核心代码中，就多次使用到了这种自省方法。此外，这还限制了对 pickle &lt;a href=&quot;http://bugs.python.org/issue9276&quot;&gt;序列化的支持&lt;/a&gt; 。&lt;/div&gt;
&lt;h2&gt;提议&lt;/h2&gt;
&lt;div&gt;本 PEP 提议在函数和类中添加 __qualname__ 属性。&lt;/div&gt;
&lt;div&gt;对于顶层的函数和类，__qualname__ 属性等于__name__ 属性。对于嵌套的类、方法和嵌套函数，__qualname__ 属性包含一个点式路径（dotted path），通向顶层模块下的对象。函数的局部命名空间在点式路径中由名为 &amp;lt;locals&amp;gt; 的组件表示。&lt;/div&gt;
&lt;div&gt;函数和类的 repr() 和 str() 被修改为使用__qualname__ 而不再是__name__。&lt;/div&gt;
&lt;h2&gt;嵌套类的示例&lt;/h2&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;C&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;   &lt;span&gt;def&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;   &lt;span&gt;class&lt;/span&gt; &lt;span&gt;D&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;g&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; C&lt;span&gt;.&lt;/span&gt;__qualname__
&lt;span&gt;&apos;C&apos;&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; C&lt;span&gt;.&lt;/span&gt;f&lt;span&gt;.&lt;/span&gt;__qualname__
&lt;span&gt;&apos;C.f&apos;&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; C&lt;span&gt;.&lt;/span&gt;D&lt;span&gt;.&lt;/span&gt;__qualname__
&lt;span&gt;&apos;C.D&apos;&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; C&lt;span&gt;.&lt;/span&gt;D&lt;span&gt;.&lt;/span&gt;g&lt;span&gt;.&lt;/span&gt;__qualname__
&lt;span&gt;&apos;C.D.g&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;嵌套函数的示例&lt;/h2&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;   &lt;span&gt;def&lt;/span&gt; &lt;span&gt;g&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; g
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; f&lt;span&gt;.&lt;/span&gt;__qualname__
&lt;span&gt;&apos;f&apos;&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; f&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;__qualname__
&lt;span&gt;&apos;f.&amp;lt;locals&amp;gt;.g&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;不足之处&lt;/h2&gt;
&lt;div&gt;对于嵌套函数（以及在函数内部定义的类），由于无法从外部获得函数的命名空间，因此点式路径无法以动态编程的方式遍历。相比于空的__name__，它对于人类读者还是有些帮助的。&lt;/div&gt;
&lt;div&gt;跟__name__属性一样，__qualname__ 属性是静态计算的，不会自动地重新绑定。&lt;/div&gt;
&lt;h2&gt;讨论&lt;/h2&gt;
&lt;h3&gt;去除模块名称&lt;/h3&gt;
&lt;div&gt;跟__name__一样，__ qualname__ 不包含模块的名称。这使得它不受制于模块别名和重新绑定，也得以在编译期进行计算。&lt;/div&gt;
&lt;h3&gt;恢复 unbound 方法&lt;/h3&gt;
&lt;div&gt;恢复 unbound 方法只能解决此 PEP 解决了的部分问题，而且代价更高（额外的对象类型和额外的间接寻址，不如用额外的属性）。&lt;/div&gt;
&lt;div&gt;-------------------摘录结束--------------------&lt;/div&gt;
&lt;h2&gt;后记&lt;/h2&gt;
&lt;div&gt;去年我在阅读&lt;code&gt;ddt&lt;/code&gt; 库关于&lt;a href=&quot;https://mp.weixin.qq.com/s/nfCFwFSLoaVLM2Q4mPqpSw&quot;&gt;参数化测试的源码&lt;/a&gt; 时，偶然想到了文章开头的问题，但是没有作进一步的梳理（似乎感兴趣的人也不多）。没想到的是在群里又出现了同样的讨论，这让我意识到这个问题是有价值的。&lt;/div&gt;
&lt;div&gt;前几天，我偶然间发现__qualname__ 属性有一个专门的 PEP，所以我就抽空把它翻译出来了——既是一种知识梳理，也是给大家做一个“科普”吧。说不定什么时候，还有人会遇到同样的问题呢，希望对大家有所帮助。&lt;/div&gt;
&lt;div&gt;更多的 PEP 中文翻译内容，可在 Github 查阅：&lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;https://github.com/chinesehuazhou/peps-cn&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 为什么能支持任意的真值判断？</title>
            <link>https://pythoncat.top/posts/2020-08-08-truth-value/</link>
            <guid>https://pythoncat.top/posts/2020-08-08-truth-value/</guid>
            <pubDate>Sat, 08 Aug 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 在涉及&lt;code&gt;真值判断&lt;/code&gt;（&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#truth-value-testing&quot;&gt;Truth Value Testing&lt;/a&gt;）时，语法很简便。&lt;/div&gt;
&lt;div&gt;比如，在判断某个对象是否不为 None 时，或者判断容器对象是否不为空时，并不需要显示地写出判断条件，只需要在 if 或 while 关键字后面直接写上该对象即可。&lt;/div&gt;
&lt;div&gt;下图以列表为例，&lt;code&gt;if my_list&lt;/code&gt; 这个简短的写法可以表达出两层意思：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;如果需要作出相反的判断，即“如果为 None 或为空”，只需要写成&lt;code&gt;if not my_list&lt;/code&gt; 即可。&lt;/div&gt;
&lt;h2&gt;与众不同的真值判断方式&lt;/h2&gt;
&lt;div&gt;通常而言，当一个值本身是布尔类型时，写成”if xxx”（如果真），在语义上就很好理解。如果 xxx 本身不是布尔类型时，写成“if xxx”（如果某东西），则在语义上并不好理解。&lt;/div&gt;
&lt;div&gt;在 C/C++/Java 之类的&lt;code&gt;静态语言&lt;/code&gt;中，通常要先基于 xxx 作一个比较操作，比如“if (xxx == null)”，以此得到一个布尔类型的值的结果，然后再进行真值判断。否则的话，若“if xxx”中有非布尔类型的值，则会报类型错误。&lt;/div&gt;
&lt;div&gt;Python 这门&lt;code&gt;动态语言&lt;/code&gt;在这种场景中表现出了一种灵活性，那么，我们的问题来了：&lt;strong&gt;为什么 Python 不需要先做一次比较操作，直接就能对任意对象作真值判断呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;先来看看&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#truth-value-testing&quot;&gt;文档&lt;/a&gt; 中对真值判断的描述：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;简单而言，Python 的任何对象都可以用在 if 或 while 或布尔操作（and、or、not）中，默认情况下认为它是 true，除非它有__bool__() 方法返回&lt;code&gt;False&lt;/code&gt; 或者有__len__() 方法返回&lt;code&gt;0&lt;/code&gt; 。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;对于前面的例子，my_list 没有__bool__() 方法，但是它有__len__() 方法，所以它是否为 true，取决于这个方法的返回值。&lt;/div&gt;
&lt;h2&gt;真值判断的字节码&lt;/h2&gt;
&lt;div&gt;接着，我们继续刨根问底：&lt;strong&gt;Python 为什么可以支持如此宽泛的真值判断呢？在执行&lt;code&gt;if xxx&lt;/code&gt; 这样的语句时，它到底在做些什么？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;对于第一个问题，Python 有个内置的 bool() 类型，可以将任意对象转化成布尔值。那么，这是否意味着 Python 在进行真值判断时，会&lt;code&gt;隐式地&lt;/code&gt; 调用 bool() 呢（即转化成&lt;code&gt;if bool(xxx)&lt;/code&gt;）？（答案为否，下文有分析）&lt;/div&gt;
&lt;div&gt;对于第二个问题，可以先用&lt;code&gt;dis&lt;/code&gt; 模块来查看下：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://docs.python.org/3/library/dis.html?highlight=pop_jump_if_false#opcode-POP_JUMP_IF_FALSE&quot;&gt;&lt;code&gt;POP_JUMP_IF_FALSE&lt;/code&gt;&lt;/a&gt;指令对应的是 if 语句那行，它的含义是：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;If TOS is false, sets the bytecode counter to &lt;em&gt;target&lt;/em&gt;. TOS is popped.&lt;/p&gt;
&lt;p&gt;如果栈顶元素为 false，则跳转到目标位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;这里只有跳转动作的描述，仍看不到一个普通对象是如何变成布尔对象的。&lt;/div&gt;
&lt;div&gt;Python 在解释器中到底是如何实现真值判断的呢？&lt;/div&gt;
&lt;h2&gt;真值判断的源码实现&lt;/h2&gt;
&lt;div&gt;在微信群友 Jo 的帮助下，我找到了 CPython 的源码（文件：ceval.c、object.c）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;可以看出，对于布尔类型的对象（即 Py_True 和 Py_False），代码会进入到快速处理的分支；而对于其它对象，则会用 PyObject_IsTrue() 计算出一个 int 类型的值。&lt;/div&gt;
&lt;div&gt;PyObject_IsTrue() 函数在计算过程中，依次会获取 nb_bool、mp_length 和 sq_length 的值，对应的应该就是 __bool__() 和 __len__() 这两个魔术方法的返回值。&lt;/div&gt;
&lt;div&gt;这个过程就是前文中所引用的官方文档的描述，正是我们想要找的答案！&lt;/div&gt;
&lt;div&gt;另外，对于内置的 bool()，它的核心实现逻辑正是上面的  PyObject_IsTrue() 函数，源码如下（boolobject.c）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;所以，Python 在对普通对象作真值判断时，并没有隐式地调用 bool()，相反它调用了一个独立的函数（PyObject_IsTrue()），而这个函数又被 bool() 所使用。&lt;/div&gt;
&lt;div&gt;也就是说，&lt;strong&gt;bool() 与 if/while 语句对普通对象的真值判断，事实上是基本相同的处理逻辑。&lt;/strong&gt; 知道了原理，就会明白&lt;code&gt;if bool(xxx)&lt;/code&gt; 这种写法是多此一举的了（我曾见到过）。&lt;/div&gt;
&lt;div&gt;至此，我们已经回答了前文中提出的问题。&lt;/div&gt;
&lt;h2&gt;验证真值判断的过程&lt;/h2&gt;
&lt;div&gt;接下来，有 3 个测试例子，可以作进一步的验证：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;你可以暂停而思考下：&lt;code&gt;bool(Test1)&lt;/code&gt; 与 &lt;code&gt;bool(Test1())&lt;/code&gt; 各是什么结果？然后依次判断剩下的两个类，结果又会是什么？&lt;/div&gt;
&lt;div&gt;揭晓答案：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Test1&lt;span&gt;)&lt;/span&gt;    &lt;span&gt;# True&lt;/span&gt;
&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Test2&lt;span&gt;)&lt;/span&gt;    &lt;span&gt;# True&lt;/span&gt;
&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Test3&lt;span&gt;)&lt;/span&gt;    &lt;span&gt;# True&lt;/span&gt;

&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Test1&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# True&lt;/span&gt;
&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Test2&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# False&lt;/span&gt;
&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Test3&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;原因如下：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;类对象没被实例化时，bool() 不会调用它的 __bool__() 或 __len__() 这两个魔术方法&lt;/li&gt;
&lt;li&gt;类对象被实例化后，若同时存在 __bool__() 或 __len__() 魔术方法，则 bool() 会先调用 __bool__() 方法（PS：这个方法要求返回值必须为 bool 类型，因此只要有它，就必然不需要再用__len__() 方法来判断真假）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数字类型如何作真值判断？&lt;/h2&gt;
&lt;div&gt;除了这 3 个例子，还有一种情况值得验证，那就是&lt;strong&gt;对于数字类型，它们是怎么做真值判断的呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;我们可以验证一下数字类型是否拥有那两个魔术方法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;hasattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;__bool__&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;hasattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;__len__&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;不难验证出，数字拥有的是 __bool__() 魔术方法，并没有__len__() 魔术方法，而且所有类型的数字其实被分成了两类：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__bool__()&lt;/code&gt; 返回 False：所有表示 0 的数字，例如&lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0.0&lt;/code&gt;, &lt;code&gt;0j&lt;/code&gt;, &lt;code&gt;Decimal(0)&lt;/code&gt;, &lt;code&gt;Fraction(0, 1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__bool__()&lt;/code&gt; 返回 True：所有其它非 0 的数字&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;文章小结&lt;/h2&gt;
&lt;div&gt;Python 中&lt;code&gt;if xxx&lt;/code&gt; 这种简便的写法，虽然是正规的真值判断语法，并它但并不符合常规的语义。在 C/C++/Java 之类的语言中，要么 xxx 本身是布尔类型的值，要么是一种可返回布尔类型值的操作，但是在 Python 中，这个“xxx”竟然还可以是&lt;strong&gt;任意的 Python 对象！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;本文通过对文档、字节码和 CPython 解释器的源码逐步分析，发现了 Python 的真值判断过程并不简单，可以提炼出以下的几个要点：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;if/while 是隐性的布尔操作符：&lt;/strong&gt; 它们除了有“判断”真假的作用，还具有隐式地将普通对象计算出布尔结果的功能。实际的操作是解释器根据“POP_JUMP_IF_FALSE”指令来完成的，其核心逻辑跟内置的 bool() 是共用了一个底层方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;真值判断过程依赖两个魔术方法：&lt;/strong&gt; 除非被判断对象有__bool__() 方法返回&lt;code&gt;False&lt;/code&gt; 或者有__len__() 方法返回&lt;code&gt;0&lt;/code&gt; ，否则布尔操作的结果都是 True。两个魔术方法总是会先计算__bool__()&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数字类型也可做真值判断：&lt;/strong&gt; 数字有__bool__() 魔术方法，但没有__len__() 魔术方法，除了表示 0 的数字为 False，其它数字都为 True&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 为什么会有个奇怪的“...”对象？</title>
            <link>https://pythoncat.top/posts/2020-08-01-Ellipsis/</link>
            <guid>https://pythoncat.top/posts/2020-08-01-Ellipsis/</guid>
            <pubDate>Sat, 01 Aug 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在写上一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/GpBOO0MLsc6g_mNq85Zy0A&quot;&gt;Python 为什么要有 pass 语句？&lt;/a&gt;》时，我想到一种特别的写法，很多人会把它当成 pass 语句的替代。在文章发布后，果然有三条留言提及了它。&lt;/div&gt;
&lt;div&gt;所谓特别的写法就是下面这个：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 用 ... 替代 pass&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;foo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
	&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;它是中文标点符号中的半个省略号，也即由英文的 3 个点组成。如果你是第一次看到，很可能会觉得奇怪：这玩意是怎么回事？（PS：如果你知道它，仔细看过本文后，你同样可能会觉得奇怪！）&lt;/div&gt;
&lt;h2&gt;1、认识一下“…”内置常量&lt;/h2&gt;
&lt;div&gt;事实上，它是 Python 3 中的一个内置对象，有个正式的名字叫作——Ellipsis，翻译成中文就是“省略号”。&lt;/div&gt;
&lt;div&gt;更准确地说，它是一个&lt;a href=&quot;https://docs.python.org/3/library/constants.html&quot;&gt;内置常量&lt;/a&gt;（Built-in Constant），是 6 大内置常量之一（另外几个是 None、False、True、NotImplemented、__debug__）。&lt;/div&gt;
&lt;div&gt;关于这个对象的基础性质，下面给出了一张截图，你们应该能明白我的意思：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;“…“并不神秘，它只是一个可能不多见的符号型对象而已。用它替换 pass，在语法上并不会报错，因为 Python 允许一个对象不被赋值引用。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;严格来说，&lt;/strong&gt; 这是旁门左道，在语义上站不住脚——把“…”或其它常量或已被赋值的变量放在一个空的缩进代码块中，它们是与动作无关的，只能表达出“这有个没用的对象，不用管它”。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Python 允许这些不被实际使用的对象存在，然而聪明的 IDE 应该会有所提示（我用的是 Pycharm），比如告诉你：&lt;code&gt;Statement seems to have no effect &lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;但是“…”这个常量似乎受到了特殊对待，我的 IDE 上没有作提示。&lt;/div&gt;
&lt;div&gt;很多人已经习惯上把它当成 pass 那样的空操作来用了（在最早引入它的邮件组讨论中，就是举了这种用法的例子）。但我本人还是倾向于使用 pass，不知道你是怎么想的呢？&lt;/div&gt;
&lt;h2&gt;2、奇怪的 Ellipsis 和 …&lt;/h2&gt;
&lt;div&gt;… 在 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3100/&quot;&gt;PEP-3100&lt;/a&gt; 中被引入，最早合入在 Python 3.0 版本，而 Ellipsis 则在更早的版本中就已包含。&lt;/div&gt;
&lt;div&gt;虽然官方说它们是同一个对象的两种写法，而且说成是单例的（singleton），但我还发现一个非常奇怪的现象，与文档的描述是冲突的：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;如你所见，赋值给 … 时会报错&lt;code&gt;SyntaxError: cannot assign to Ellipsis&lt;/code&gt; ，然而 Ellipsis 却可以被赋值，它们的行为根本就不同嘛！被赋值之后，Ellipsis 的内存地址以及类型属性都改变了，它成了一个“变量”，不再是常量。&lt;/div&gt;
&lt;div&gt;作为对比，给 True 或 None 之类的常量赋值时，会报错&lt;code&gt;SyntaxError: cannot assign to XXX&lt;/code&gt;，但是给 NotImplemented 常量赋值时不会报错。&lt;/div&gt;
&lt;div&gt;众所周知，在 Python 2 中也可以给布尔对象（True/False）赋值，然而 Python 3 已经把它们改造成不可修改的。&lt;/div&gt;
&lt;div&gt;所以有一种可能的解释：&lt;strong&gt;Ellipsis 和 NotImplemented 是 Python 2 时代的遗留产物，为了兼容性或者只是因为核心开发者遗漏了，所以它们在当前版本（3.8）中还可以被赋值修改。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;… 出生在 Python 3 的时代，或许在将来会完全取代 Ellipsis。目前两者共存，它们不一致的行为值得我们注意。我的建议：只使用”…”吧，就当 Ellipsis 已经被淘汰了。&lt;/div&gt;
&lt;h2&gt;3、为什么要使用“…”对象？&lt;/h2&gt;
&lt;div&gt;接下来，让我们回到标题的问题：&lt;strong&gt;Python 为什么要使用“…”对象？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;这里就只聚焦于 Python 3 的“…”了，不去追溯 Ellipsis 的历史和现状。&lt;/div&gt;
&lt;div&gt;之所以会问这个问题，我的意图是想知道：&lt;strong&gt;它有什么用处，能够解决什么问题？从而窥探到 Python 语言设计中的更多细节。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;大概有如下的几种答案：&lt;/div&gt;
&lt;h3&gt;（1）扩展切片语法&lt;/h3&gt;
&lt;div&gt;官方文档中给出了这样的说明：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Special value used mostly in conjunction with extended slicing syntax for user-defined container data types.&lt;/p&gt;
&lt;p&gt;这是个特殊的值，通常跟扩展的切片语法相结合，用在自定义的数据类型容器上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;文档中没有给出具体实现的例子，但用它结合__getitem__() 和 slice() 内置函数，可以实现类似于 [1, …, 7] 取出 7 个数字的切片片段的效果。&lt;/div&gt;
&lt;div&gt;由于它主要用在数据操作上，可能大部分人很少接触。听说 Numpy 把它用在了一些语法糖用法上，如果你在用 Numpy 的话，可以探索一下都有哪些玩法？&lt;/div&gt;
&lt;h3&gt;（2）表达“未完成的代码”语义&lt;/h3&gt;
&lt;div&gt;… 可以被用作占位符，也就是我在《&lt;a href=&quot;https://mp.weixin.qq.com/s/GpBOO0MLsc6g_mNq85Zy0A&quot;&gt;Python 为什么要有 pass 语句？&lt;/a&gt;》中提到 pass 的作用。前文中对此已有部分分析。&lt;/div&gt;
&lt;div&gt;有人觉得这样很 cute，这种想法获得了 Python 之父 Guido 的&lt;a href=&quot;https://mail.python.org/pipermail/python-3000/2008-January/011793.html&quot;&gt;支持&lt;/a&gt; ：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h3&gt;（3）Type Hint 用法&lt;/h3&gt;
&lt;div&gt;Python 3.5 引入的 Type Hint 是“…”的主要使用场合。&lt;/div&gt;
&lt;div&gt;它可以表示不定长的参数，比如&lt;code&gt;Tuple[int, ...]&lt;/code&gt; 表示一个元组，其元素是 int 类型，但数量不限。&lt;/div&gt;
&lt;div&gt;它还可以表示不确定的变量类型，比如文档中给出的这个例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; typing &lt;span&gt;import&lt;/span&gt; TypeVar&lt;span&gt;,&lt;/span&gt; Generic

T &lt;span&gt;=&lt;/span&gt; TypeVar&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;T&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;fun_1&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;:&lt;/span&gt; T&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; T&lt;span&gt;:&lt;/span&gt; &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;  &lt;span&gt;# T here&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;fun_2&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;:&lt;/span&gt; T&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; T&lt;span&gt;:&lt;/span&gt; &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;  &lt;span&gt;# and here could be different&lt;/span&gt;

fun_1&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;                   &lt;span&gt;# This is OK, T is inferred to be int&lt;/span&gt;
fun_2&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;                 &lt;span&gt;# This is also OK, now T is str&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;T 在函数定义时无法确定，当函数被调用时，T 的实际类型才被确定。&lt;/div&gt;
&lt;div&gt;在 .pyi 格式的文件中，… 随处可见。这是一种存根文件（stub file），主要用于存放 Python 模块的类型提示信息，给 mypy、pytype 之类的&lt;a href=&quot;https://mp.weixin.qq.com/s/l8FyTp_oxdBEcg95fgWrDA&quot;&gt;类型检查工具&lt;/a&gt; 以及 IDE 来作静态代码检查。&lt;/div&gt;
&lt;h3&gt;（4）表示无限循环&lt;/h3&gt;
&lt;div&gt;最后，我认为有一个非常终极的原因，除了引入“…”来表示，没有更好的方法。&lt;/div&gt;
&lt;div&gt;先看看两个例子：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;两个例子的结果中都出现了“…”，它表示的是什么东西呢？&lt;/div&gt;
&lt;div&gt;对于列表和字典这样的容器，如果其内部元素是可变对象的话，则存储的是对可变对象的引用。那么，当其内部元素又引用容器自身时，就会递归地出现无限循环引用。&lt;/div&gt;
&lt;div&gt;无限循环是无法穷尽地表示出来的，Python 中用 … 来表示，比较形象易懂，除了它，恐怕没有更好的选择。&lt;/div&gt;
&lt;div&gt;最后，我们来总结一下本文的内容：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;… 是 Python 3 中的一个内置常量，它是一个单例对象，虽然是 Python 2 中就有的 Ellipsis 的别称，但它的性质已经跟旧对象分道扬镳&lt;/li&gt;
&lt;li&gt;… 可以替代 pass 语句作为占位符使用，但是它作为一个常量对象，在占位符语义上并不严谨。很多人已经在习惯上接受它了，不妨一用&lt;/li&gt;
&lt;li&gt;… 在 Python 中不少的使用场景，除了占位符用法，还可以支持扩展切片语法、丰富 Type Hint 类型检查，以及表示容器对象的无限循环&lt;/li&gt;
&lt;li&gt;… 对大多数人来说，可能并不多见（有人还可能因为它是一种符号特例而排斥它），但它的存在，有些时候能够带来便利。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;希望本文能让更多人认识它，那么文章的目的也就达成了~&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 为什么要有 pass 语句？</title>
            <link>https://pythoncat.top/posts/2020-07-27-pass/</link>
            <guid>https://pythoncat.top/posts/2020-07-27-pass/</guid>
            <pubDate>Mon, 27 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;关于 Python 中的&lt;code&gt;pass&lt;/code&gt;语句，它似乎很简单（只有 4 个字母），即使是没有任何编程经验的初学者也能很快地掌握它的用法。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#pass-statements&quot;&gt;官方文档&lt;/a&gt; 的介绍十分简单，下面的三个例子可以让我们快速地了解到如何使用它：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;简单而言，pass 是一种空操作（null operation），解释器执行到它的时候，除了检查语法是否合法，什么也不做就直接跳过。&lt;/div&gt;
&lt;div&gt;它跟 return、break、continue 和 yield 之类的非空操作相比，最大的区别是它不会改变程序的执行顺序。它就像我们写的注释，除了占用一行代码行，不会对所处的作用域产生任何影响。&lt;/div&gt;
&lt;div&gt;但是，如果你有其它语言的基础，你也许会好奇：&lt;strong&gt;为什么 Python 有这么独特的 pass 语句，而别的语言却没有？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;Python 这么设计，到底是出于什么原因呢？&lt;/div&gt;
&lt;div&gt;是为了解决大部分编程语言都要面对的共性问题，还是因为它有自己的新发现，所以创造出来一个新的特性？&lt;/div&gt;
&lt;div&gt;换句话说：&lt;strong&gt;Python 为什么要有 pass 语句，它能解决什么问题（好处），如果没有它，会导致什么问题（坏处）？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;接下来，本文将从两个维度展开分析。&lt;/div&gt;
&lt;h2&gt;1、对人：作为空间占位符&lt;/h2&gt;
&lt;div&gt;我把它看作是一种言简意赅的注释方式，等于是说“&lt;strong&gt;这里先预留位置，回头再补上具体的代码实现&lt;/strong&gt;”。&lt;/div&gt;
&lt;div&gt;比如在多层的 if-elif-else 结构中，我们可以先把判断条件写好，然后在对应的块中写上 pass，以后再慢慢完善。&lt;/div&gt;
&lt;div&gt;比如上文中给出的例子，我们可以先写好类/函数名及其入参，然后跳过（pass）主体代码，以后再慢慢填充。&lt;/div&gt;
&lt;div&gt;pass 写起来简单，而且由于是关键字，IDE 会给出显眼的颜色区分，所以就比我们写上注释内容来得方便些。&lt;/div&gt;
&lt;div&gt;pass 作为空间占位符，主要可以方便我们构思局部的代码结构，有一定的辅助提醒作用。&lt;/div&gt;
&lt;div&gt;但是，若作为一种注释方式，它就显得太单薄了，比不上写“# todo: xxxx”，后者也会被 IDE 用颜色突显，而且意思更明确。虽然写起来简单，但它也引入了一个看似多余的关键字 pass。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;所以，从空间占位符的角度来看，pass 不是编程语言中必须的设计要素。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;有了它，我们可以表达出“此处有东西，但暂时跳过”的语义，但如果没有它，则可以用注释内容来替代。&lt;/div&gt;
&lt;h2&gt;2、对机器：为了语法完整性&lt;/h2&gt;
&lt;div&gt;对于前一条的用法，pass 出现在代码中的位置在理论上是不受限的。&lt;/div&gt;
&lt;div&gt;但是，我们最常使用 pass 时，基本是在冒号的下一行，而且在该层缩进的代码块中，只有这一条语句。（参见前文的 3 个例子，为了方便，我们仅以以空函数为例）&lt;/div&gt;
&lt;div&gt;我们可以设想下，如果不写它，会怎样？&lt;/div&gt;
&lt;div&gt;答案是会报缩进错误：&lt;code&gt;IndentationError: expected an indented block&lt;/code&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 将函数体的 pass 去除，会报错&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;

func&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;因为 Python 使用缩进来划分代码块，而冒号标识着要出现新的缩进代码块，所以这个例子会报缺少缩进代码块。&lt;/div&gt;
&lt;div&gt;如果我们用前文说的注释来替代，看看会怎样？&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 将函数体的 pass 换成注释&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;# todo:此处有东西，以后补上&lt;/span&gt;
func&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这样写，也会报错：&lt;code&gt;IndentationError: expected an indented block&lt;/code&gt;&lt;/div&gt;
&lt;div&gt;原因是注释并非有效的语法内容，它会被 Python 解释器忽略掉（ignore），不像 pass 语句那样是“有效的语法内容，但是跳过”。&lt;/div&gt;
&lt;div&gt;也就是说，缩进代码块中必须包含有语法意义的内容，下面的例子都是有效的：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;这是一个字符串&quot;&quot;&quot;&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;func2&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;123456&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 在定义函数时，必须包含函数体，即同时包含声明加定义两种语义，不能像某些语言可以只使用声明的语义，即写成&lt;code&gt;void test();&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;但是，由于 Python 不使用花括号，它无法像某些语言那样直接定义出空函数，即写成&lt;code&gt;void test(){}&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;综合以上的分析，Python 在定义空函数时，必须要有合法的函数体，因此设计出表示空操作的 pass 语句。它是为了补充语法的完整性，连同冒号，等效于其它语言中一对空的花括号。&lt;/div&gt;
&lt;div&gt;从语法完整性的维度上看，它是必须的设计要素，如果没有的话，也必须用类似的空语句或特殊符号来替代。&lt;/div&gt;
&lt;div&gt;对人方面，pass 可以表示“暂时跳过”的含义，作为临时的占位符，最终会被实际的代码实现所替换；对机器方面，它则可以表示“直接跳过”，只为了补齐语法逻辑，并不会被其它代码所替换。&lt;/div&gt;
&lt;div&gt;其它语言没有专门的一种语句或者符号来表示这种占位符（即语义有所欠缺），但是它们也不需要费心思专门设计一个关键字来补齐语法完整性（即语法完备）。&lt;/div&gt;
&lt;div&gt;回到本文开头的问题：&lt;strong&gt;Python 为什么要有 pass 语句，它能解决什么问题（好处），如果没有它，会导致什么问题（坏处）？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Python 使用 pass 语句，是为了支持纯粹空操作的代码块（空函数、空类、空的循环控制块等等），有了它，还能额外表达出一种占位符的语义。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;前者是对于机器而言的，必须要有，等效于其它语言中空花括号的作用；后者是对于人而言的，非必须的，可以用注释来表达，但因为 Python 设计了这个语句，这种用法有时候还挺方便的。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>当我发现国际友人翻译了我的文章之后……</title>
            <link>https://pythoncat.top/posts/2020-07-20-translation/</link>
            <guid>https://pythoncat.top/posts/2020-07-20-translation/</guid>
            <description>我的一篇文章竟然不知何故流传到了外网，被一位印度小哥翻译成了英文……</description>
            <pubDate>Mon, 20 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;我今天在某博客平台上看到了一则留言：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;非常意外！不会只是巧合吧？&lt;/div&gt;
&lt;div&gt;我马上就点开链接去核实，然后发现那篇文章是全文翻译了我之前写的文章，而且该作者还翻译了另外的两篇。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;如果读者了解我，应该知道我也翻译过不少文章，比如有 &lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;PEP系列&lt;/a&gt; 、&lt;a href=&quot;https://github.com/chinesehuazhou/guido_blog_translation&quot;&gt;Guido的解析器系列&lt;/a&gt; 、Flask 作者 Armin Ronacher 的文章、Anthony Shaw 和 Brett Cannon 等社区大佬的文章。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;然而，我自己的文章被别人翻译，这是破天荒第一次！我感到非常开心！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;我自知自己的某些文章可算是“精品”（&lt;strong&gt;厚着脸皮说的&lt;/strong&gt; ），最起码大部分是非常之独特的。我有广泛阅读 Python 社区内中英文文章的习惯，对于自己所写的内容，心里还是有点数的，不想妄自菲薄。&lt;/div&gt;
&lt;div&gt;难得文章竟然被国际友人（根据作者博客的介绍，他是印度人）阅读到，并且还翻译了三篇，我心里是美滋滋的~&lt;/div&gt;
&lt;div&gt;但是，我也有点不开心！&lt;/div&gt;
&lt;div&gt;在 Medium 上仔细看完译文后，我发现文中并未提及到原作者及原文出处，更没有表示那是翻译的文章。&lt;/div&gt;
&lt;div&gt;我在翻译文章时，基本都联系了作者申请授权，而且会在文章开头的显著位置标注清楚出处，表示对原作者的知识产权的尊重。&lt;/div&gt;
&lt;div&gt;在申请 Guido 授权时，还发生过一件趣事，我写在了文章《&lt;a href=&quot;https://mp.weixin.qq.com/s/zpnLlIWEdLXkUlWCAh5XQg&quot;&gt;从 Python 之父的对话聊起，关于知识产权、知识共享与文章翻译&lt;/a&gt;》中，里面还提到了知识产权的话题，并回答了几个关于翻译的问题。&lt;/div&gt;
&lt;div&gt;所以，我对于知识产权和翻译权是挺敏感的。&lt;/div&gt;
&lt;div&gt;我不知道那位国际友人是从何处看到了我的文章，或许在他阅读到的地方，没有原作者的信息？我只在国内的几大平台发布过文章，但不知道国际友人能接触到的是哪个？&lt;/div&gt;
&lt;div&gt;为了方便文章的传播，方便文章的归档和修订，我现在把“Python为什么”系列文章传到了 Github 上（前几天恰好有读者询问，我还答复过会传到 Github 上）。&lt;/div&gt;
&lt;div&gt;地址：&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;https://github.com/chinesehuazhou/python-whydo&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;我写了一段话，传达给了这位国际友人，希望他能在译文中标注出原作信息。（PS：写到这里的时候，已收到他的答复，译文中加了一段“Footnotes”）。&lt;/div&gt;
&lt;div&gt;这件事在短短几个小时内得到了解决，非常好！&lt;/div&gt;
&lt;div&gt;这篇文章算是作为一个小小的里程碑式的记录吧，与大家分享。&lt;/div&gt;
&lt;div&gt;最后，还得多解释一下：“Python为什么”系列最初是想做成短视频内容的，但是很快我就发现自己更适合写文章（制作视频太麻烦，也太费时间），所以视频内容在短期内就不提供了。&lt;/div&gt;
&lt;div&gt;但是，我不会放弃做视频的想法，等过段时间吧，我会好好修订已发布的文章，到时候再找一个比较好的方式，制作成视频内容。敬请留意！&lt;/div&gt;
&lt;div&gt;update：想不到这件事还有后续！文章竟然被 CSDN 公众号从英文翻译回了中文，读着曾出自自己之手被二次翻译的文字，真是一种奇怪/奇妙的感觉啊……&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 为什么用 # 号作注释符？</title>
            <link>https://pythoncat.top/posts/2020-07-19-comments/</link>
            <guid>https://pythoncat.top/posts/2020-07-19-comments/</guid>
            <pubDate>Sun, 19 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;关于编程语言中的注释，其重要性基本上已为大家所共识。&lt;/div&gt;
&lt;div&gt;然而关于注释的规范，这个话题就像我们之前聊过的缩进、终止符和命名方式一样，众口难调。&lt;/div&gt;
&lt;div&gt;注释符通常可分为两种，即行注释与块注释（inline/block），它们在不同的编程语言中的符号可谓让人眼花缭乱。&lt;/div&gt;
&lt;div&gt;比如行注释符，它至少有以下的 17 种之多（出自&lt;a href=&quot;https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(syntax)&quot;&gt;维基百科&lt;/a&gt;）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;其中两个最大的阵营分别是“//”与“#”号：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;// 注释符：ActionScript, C (C99), C++, C#, D, F#, Go, Java, JavaScript, Kotlin, Object Pascal (Delphi), Objective-C, PHP, Rust, Scala, SASS, Swift, Xojo&lt;/li&gt;
&lt;li&gt;# 注释符：Bourne shell and other UNIX shells, Cobra, Perl, Python, Ruby, Seed7, Windows PowerShell, PHP, R, Make, Maple, Elixir, Nim&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;那么，&lt;strong&gt;Python 为什么用“#”号作注释符，而不是“//”呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;这个问题恐怕没办法从解析的效率、符号的辨识度和输入的便利性等方面回答，因为它们基本上没有区别。&lt;/div&gt;
&lt;div&gt;我没有找到官方的解释，但是从这些注释符的阵营中，已经不难得出一个较为合理的解释：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;// 注释符基本上被 C 语言家族所用&lt;/li&gt;
&lt;li&gt;# 注释符则基本上是被 Shell 和其它脚本语言所用&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;Python 在创造之初，从 C 和 Shell 语言中借鉴了不少东西，但它是一种脚本语言，因此在注释符这个最为基础的语言要素上，就偏向了脚本语言的传统。&lt;/div&gt;
&lt;div&gt;在某些“类脚本语言”中，比如 yaml、conf 和 ini 等格式的配置文件，它们大多也是采用脚本语言的“#”号作为注释符。&lt;/div&gt;
&lt;div&gt;所以，&lt;strong&gt;Python 行内注释符的选择，大概可以归结为一种历史原因，即借鉴了 Shell 脚本语言的写法。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;相比于行注释符的多样，块注释符更加是让人眼花缭乱：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;大多数写法是我从未见过的，有些甚至是难以忍受的，槽点太多！&lt;/div&gt;
&lt;div&gt;在这份表格里，我们看不到 Python，因为从严格意义上讲，&lt;strong&gt;Python 并没有块注释符！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;一般而言，我们在连续的每行内容前面加“#”号，达到块注释的效果。块注释被看作是多个行注释。&lt;/div&gt;
&lt;div&gt;PEP-8 中是这么建议的：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Each line of a block comment starts with a &lt;code&gt;#&lt;/code&gt; and a single space (unless it is indented text inside the comment).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;有人曾在 Twitter 上发问，&lt;strong&gt;为什么 Python 没有块注释符？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;Guido 回复称，可以将多行字符串用作块注释：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Python 的多行字符串用三对单引号或双引号表示，它还可以用作文档字符串（即Documentation Strings，简写docstrings）。&lt;/div&gt;
&lt;div&gt;但是，将它当做多行注释符使用，在语义上则有点怪怪的——它表示的是一段字符串，虽然没有赋值给变量，不会生成代码，但是它并非语义上的注释。&lt;/div&gt;
&lt;div&gt;由于脚本语言的特性，它允许我们写一段“无根的字符串”，在语法上没有问题，也没有负作用（negative effects），但是，如果把它作为注释使用，这就是一种副作用（side effects）了。&lt;/div&gt;
&lt;div&gt;从这点上考虑，我虽然不反对有人把多行字符串写法用作块注释，但是我会更推荐大家使用“#”号作注释。&lt;/div&gt;
&lt;div&gt;另外，对于无用的代码，最好的做法就是直接删除，如果后续发现有需要，再回退修改。详细的多行注释尽量放在文档字符串中，这样在核心代码中就会很少出现多行注释的情况了。&lt;/div&gt;
&lt;div&gt;对于 Python 的注释符用法，大家是怎么想的呢？欢迎留言交流。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 为什么只需一条语句“a,b=b,a”，就能直接交换两个变量？</title>
            <link>https://pythoncat.top/posts/2020-07-14-swap/</link>
            <guid>https://pythoncat.top/posts/2020-07-14-swap/</guid>
            <pubDate>Tue, 14 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;从接触 Python 时起，我就觉得 Python 的元组解包（unpacking）挺有意思，非常简洁好用。&lt;/div&gt;
&lt;div&gt;最显而易见的例子就是多重赋值，即在一条语句中同时给多个变量赋值：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; x&lt;span&gt;,&lt;/span&gt; y &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt; y&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 结果：1 2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在此例中，赋值操作符“=”号的右侧的两个数字会被存入到一个元组中，即变成 (1,2)，然后再被解包，依次赋值给“=”号左侧的两个变量。&lt;/div&gt;
&lt;div&gt;如果我们直接写&lt;code&gt;x = 1,2&lt;/code&gt; ，然后打印出 x，或者在“=”号右侧写成一个元组，就能证实到这一点：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; x &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;)&lt;/span&gt;     &lt;span&gt;# 结果：(1, 2)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; x&lt;span&gt;,&lt;/span&gt; y &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt; y&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 结果：1 2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;一些博客或公众号文章在介绍到这个特性时，通常会顺着举一个例子，即基于两个变量，直接交换它们的值：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; x&lt;span&gt;,&lt;/span&gt; y &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; x&lt;span&gt;,&lt;/span&gt; y &lt;span&gt;=&lt;/span&gt; y&lt;span&gt;,&lt;/span&gt; x
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt; y&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 结果：2 1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;一般而言，交换两个变量的操作需要引入第三个变量。道理很简单，如果要交换两个杯子中所装的水，自然会需要第三个容器作为中转。&lt;/div&gt;
&lt;div&gt;然而，Python 的写法并不需要借助中间变量，它的形式就跟前面的解包赋值一样。正因为这个形式相似，很多人就误以为 Python 的变量交换操作也是基于解包操作。&lt;/div&gt;
&lt;div&gt;但是，事实是否如此呢？&lt;/div&gt;
&lt;div&gt;我搜索了一番，发现有人试图回答过这个问题，但是他们的回答基本不够全面。（当然，有不少是错误的答案，还有更多人只是知其然，却从未想过要知其所以然）&lt;/div&gt;
&lt;div&gt;先把本文的答案放出来吧：&lt;strong&gt;Python 的交换变量操作不完全基于解包操作，有时候是，有时候不是！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;有没有觉得这个答案很神奇呢？是不是闻所未闻？！&lt;/div&gt;
&lt;div&gt;到底怎么回事呢？先来看看标题中最简单的两个变量的情况，我们上&lt;code&gt;dis&lt;/code&gt; 大杀器看看编译的字节码：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;上图开了两个窗口，可以方便比较“a,b=b,a”与“a,b=1,2”的不同：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;“a,b=b,a”操作：两个 LOAD_FAST 是从局部作用域中读取变量的引用，并存入栈中，接着是最关键的 ROT_TWO 操作，它会交换两个变量的引用值，然后两个 STORE_FAST 是将栈中的变量写入局部作用域中。&lt;/li&gt;
&lt;li&gt;“a,b=1,2”操作：第一步 LOAD_CONST 把“=”号右侧的两个数字作为元组放到栈中，第二步 UNPACK_SEQUENCE 是序列解包，接着把解包结果写入局部作用域的变量上。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;很明显，形式相似的两种写法实际上完成的操作并不相同。在交换变量的操作中，并没有装包和解包的步骤！&lt;/div&gt;
&lt;div&gt;ROT_TWO 指令是 CPython 解释器实现的对于栈顶两个元素的快捷操作，改变它们指向的引用对象。&lt;/div&gt;
&lt;div&gt;还有两个类似的指令是 ROT_THREE 和 ROT_FOUR，分别是快捷交换三和四个变量（摘自：ceval.c 文件，最新的 3.9 分支）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;预定义的栈顶操作如下：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;查看官方文档中对于这几个指令的解释，其中 ROT_FOUR 是 3.8 版本新加的：&lt;/div&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ROT_TWO&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Swaps the two top-most stack items.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ROT_THREE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Lifts second and third stack item one position up, moves top down to position three.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ROT_FOUR&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Lifts second, third and forth stack items one position up, moves top down to position four.
New in version 3.8.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;div&gt;CPython 应该是以为这几种变量的交换操作很常见，因此才提供了专门的优化指令。就像 [-5,256] 这些小整数被预先放到了整数池里一样。&lt;/div&gt;
&lt;div&gt;对于更多变量的交换操作，实际上则会用到前面说的解包操作：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;截图中的 BUILD_TUPLE 指令会将给定数量的栈顶元素创建成元组，然后被 UNPACK_SEQUENCE 指令解包，再依次赋值。&lt;/div&gt;
&lt;div&gt;值得一提的是，此处之所以比前面的“a,b=1,2”多出一个 build 操作，是因为每个变量的 LOAD_FAST 需要先单独入栈，无法直接被组合成 LOAD_CONST 入栈。也就是说，“=”号右侧有变量时，不会出现前文中的  LOAD_CONST 一个元组的情况。&lt;/div&gt;
&lt;div&gt;最后还有一个值得一提的细节，那几个指令是跟栈中元素的数量有关，而不是跟赋值语句中实际交换的变量数有关。看一个例子就明白了：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;分析至此，你应该明白前文中的结论是怎么回事了吧？&lt;/div&gt;
&lt;div&gt;我们稍微总结一下：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Python 能在一条语句中实现多重赋值，这是利用了序列解包的特性&lt;/li&gt;
&lt;li&gt;Python 能在一条语句中实现变量交换，不需引入中间变量，在变量数少于 4 个时（3.8 版本起是少于 5 个），CPython 是利用了 ROT_* 指令来交换栈中的元素，当变量数超出时，则是利用了序列解包的特性。&lt;/li&gt;
&lt;li&gt;序列解包是 Python 的一大特性，但是在本文的例子中，CPython 解释器在小小的操作中还提供了几个优化的指令，这绝对会超出大多数人的认知&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>一篇文章掌握 Python 内置 zip() 的全部内容</title>
            <link>https://pythoncat.top/posts/2020-07-09-zip/</link>
            <guid>https://pythoncat.top/posts/2020-07-09-zip/</guid>
            <pubDate>Thu, 09 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;zip() 是 Python 中最好用的内置类型之一，它可以接收多个可迭代对象参数，再返回一个迭代器，可以把不同可迭代对象的元素组合起来。&lt;/div&gt;
&lt;div&gt;我之前写迭代器系列的时候，在《&lt;a href=&quot;https://mp.weixin.qq.com/s/7MbRCn37fIIN42rLm6ho3g&quot;&gt;Python进阶：设计模式之迭代器模式&lt;/a&gt;》中简单地介绍过它，前几天翻译了 Python 3.10 采纳的 &lt;a href=&quot;https://mp.weixin.qq.com/s/W6XkRjDHvVSqtZKRceqwdw&quot;&gt;PEP-618&lt;/a&gt; ，介绍了它将会迎来的变更。&lt;/div&gt;
&lt;div&gt;但是，还有不少同学并不知道 zip()，或者不能熟练掌握它的用法，因此本文打算来做一个更为详细的梳理。&lt;/div&gt;
&lt;div&gt;内容主要分三部分：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;用法部分：介绍它的基础用法、高级用法、骚操作用法&lt;/li&gt;
&lt;li&gt;进阶部分：介绍它的实现原理，关注几个实现的细节&lt;/li&gt;
&lt;li&gt;发散部分：聚焦它的不足，以及解决方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;1、zip() 的 n 种用法&lt;/h2&gt;
&lt;div&gt;基本用法：像拉链一样，将多个可迭代对象组合起来，然后可以用 for 循环依次取出，或者一次性将结果存入列表、元组或者字典之类的容器中。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;它的结果是一个迭代器，迭代器生成的元素是元组，第 i 个元组的元素分别来自可迭代对象参数的第 i 个元素，如上图所示。&lt;/div&gt;
&lt;div&gt;另外，for 循环还可以把元组内的元素依次取出，这样会很方便：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;它的参数并不要求是同一类的可迭代对象，因此可以有非常多的组合方式，例如：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;但是，如果把字典作为 zip() 的参数，会是什么结果呢？字典是 key-value 键值对形式，跟列表之类的单一元素结构不同。&lt;/div&gt;
&lt;div&gt;实验一下，可以看出，zip() 默认只会遍历字典的 key 值：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;如果想要取出字典的 value 值，或者取出 key-value 键值对，那么可以使用字典自带的遍历方法 values() 和 items()：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;使用 zip()，还可以比较方便地对二维列表实现行列转换：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;上例中的星号（*）操作符可以解包（unpacking），即将 my_list 的元素（也是列表）解成多个参数给 zip()，从而将 3 个列表重新组合。&lt;/div&gt;
&lt;div&gt;解包操作符对于 zip 对象同样适用，因为 zip() 本身是一次行列转换的操作，若将它解包后作为参数给 zip()，等于再做一次行列转换，也就是回到了原点（除了最后的结果是元组）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;最后再介绍一种用法：创建 n*n 的方阵，每行的数字相同。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;2、zip() 的原理解析&lt;/h2&gt;
&lt;div&gt;官方文档中给出了 zip() 的 Python 伪代码（并非是 Python 解释器内置的实现，只为了展示基本的代码逻辑）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;zip&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;iterables&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;# zip(&apos;ABCD&apos;, &apos;xy&apos;) --&amp;gt; Ax By&lt;/span&gt;
    sentinel &lt;span&gt;=&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    iterators &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;it&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; it &lt;span&gt;in&lt;/span&gt; iterables&lt;span&gt;]&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; iterators&lt;span&gt;:&lt;/span&gt;
        result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; it &lt;span&gt;in&lt;/span&gt; iterators&lt;span&gt;:&lt;/span&gt;
            elem &lt;span&gt;=&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;it&lt;span&gt;,&lt;/span&gt; sentinel&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; elem &lt;span&gt;is&lt;/span&gt; sentinel&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;
            result&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;elem&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;tuple&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;result&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在这段简短的代码中，可以分析出几点关键的信息：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;zip 接收可变数量的可迭代对象参数，这些参数会经过 iter() 处理成迭代器。推论：若出现非可迭代对象，此处会报错&lt;/li&gt;
&lt;li&gt;while 循环在判断列表是否为空，而列表中的元素是将参数转化而成的迭代器。推论：若入参存在有效的可迭代对象，则 while 循环始终为真；若没有入参，则什么都不做&lt;/li&gt;
&lt;li&gt;next() 会依次读取迭代器中的下一个元素，它的第二个参数会作为迭代器耗尽时的返回值。推论：每一轮依次取出这些迭代器的一个元素，当某个迭代被耗尽时，则退出死循环，这就意味着未耗尽的迭代器会被直接舍弃&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3、zip() 的问题与解决&lt;/h2&gt;
&lt;div&gt;zip() 最明显的问题是它会舍弃掉未耗尽的迭代器：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这是一种木桶效应，最终的结果由最短的木板来决定。&lt;/div&gt;
&lt;div&gt;有一种解决思路是取长板，同时补足短板（用 None 值填充），这就是 itertools 中的 zip_longest 方法：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;它填充了冗余数据，同时最大限度地保证了原始数据的完整性。&lt;/div&gt;
&lt;div&gt;但是，如果我们不希望有冗余数据，只希望得到按最长方式对齐的数据呢？&lt;/div&gt;
&lt;div&gt;Python 官方最近采纳了 PEP-618，它就是为了应对这个问题。当出现迭代器长度不一致时，它既不向短板妥协，也不向长板妥协，而是抛出 ValueError。它认为入参值错误，也就是严格要求入参的数据完整性。&lt;/div&gt;
&lt;div&gt;该 PEP 会被合入到一年后的 Python 3.10 版本，关于更多的内容细节，可查阅这篇&lt;a href=&quot;https://mp.weixin.qq.com/s/W6XkRjDHvVSqtZKRceqwdw&quot;&gt;PEP-618 译文&lt;/a&gt; 。&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;公众号：Python猫&lt;/div&gt;
&lt;div&gt;头条号：Python猫&lt;/div&gt;
&lt;div&gt;知乎：豌豆花下猫&lt;/div&gt;
&lt;div&gt;掘金：豌豆花下猫&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 3.10 的首个 PEP 诞生，内置类型 zip() 迎来新特性</title>
            <link>https://pythoncat.top/posts/2020-07-02-PEP/</link>
            <guid>https://pythoncat.top/posts/2020-07-02-PEP/</guid>
            <pubDate>Thu, 02 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;译者前言：相信凡是用过 zip() 内置函数的人，都会赞同它很有用，但是，它的最大问题是可能会产生出非预期的结果。PEP-618 提出给它增加一个参数，可以有效地解决大家的痛点。&lt;/div&gt;
&lt;div&gt;这是 Python 3.10 版本正式采纳的第一个 PEP，「Python猫」一直有跟进社区最新动态的习惯，所以翻译了出来给大家尝鲜，强烈推荐一读。（PS：严格来说，zip() 是一个内置类（built-in type），而不是一个内置函数（built-in function），但我们一般都称它为一个内置函数。）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP原文 ：&lt;/strong&gt; &lt;a href=&quot;https://www.python.org/dev/peps/pep-0618/&quot;&gt;https://www.python.org/dev/peps/pep-0618/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP标题：&lt;/strong&gt; Add Optional Length-Checking To zip&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP作者：&lt;/strong&gt; Brandt Bucher&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;创建日期：&lt;/strong&gt; 2020-05-01&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;合入版本：&lt;/strong&gt; 3.10&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; ：&lt;a href=&quot;https://zhuanlan.zhihu.com/pythonCat&quot;&gt;豌豆花下猫&lt;/a&gt; @Python猫公众号&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;PEP翻译计划&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;摘要&lt;/h2&gt;
&lt;div&gt;本 PEP 建议给内置的 &lt;code&gt;zip&lt;/code&gt; 添加一个可选的 strict 布尔关键字参数。当启用时，如果其中一个参数先被用尽了，则会引发 ValueError 。&lt;/div&gt;
&lt;h2&gt;动机&lt;/h2&gt;
&lt;div&gt;从作者的个人经验和一份&lt;a href=&quot;https://www.python.org/dev/peps/pep-0618/%23examples#examples&quot;&gt;对标准库的调查&lt;/a&gt; 来看，明显有很多（如果不是绝大多数）zip 用例要求可迭代对象必须是等长的。有时候，周围代码的上下文可以保证这点，但是要 zip 处理的数据通常是由调用者传入的、单独提供的或者以某种方式生成的。在这些情况下，zip 的默认行为意味着错误的重构或逻辑错误，很容易悄悄地导致数据丢失。这些 bug 不仅难以定位，甚至难以被觉察到。&lt;/div&gt;
&lt;div&gt;很容易想到造成这种问题的简单案例。例如，以下代码在 items 为一个序列（sequence）时可以良好地运行，但是如果调用者将 item 重构为一个可消耗的迭代器，则代码会悄悄地产生缩短的、不匹配的结果：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;apply_calculations&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;items&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    transformed &lt;span&gt;=&lt;/span&gt; transform&lt;span&gt;(&lt;/span&gt;items&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i&lt;span&gt;,&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt; &lt;span&gt;zip&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;items&lt;span&gt;,&lt;/span&gt; transformed&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;yield&lt;/span&gt; calculate&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt; t&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;zip 还有几种常见用法。惯用的技巧性用法特别容易出问题，因为它们经常被不完全了解代码工作方式的用户使用。下面是一个示例，解包到 zip 中以转化成嵌套的可迭代对象：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; x &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;one&quot;&lt;/span&gt; &lt;span&gt;&quot;two&quot;&lt;/span&gt; &lt;span&gt;&quot;three&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; xt &lt;span&gt;=&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;zip&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;x&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;另一个例子是将数据“分块”成大小相等的组：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; n &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; x &lt;span&gt;=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;n &lt;span&gt;**&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; xn &lt;span&gt;=&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;zip&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; n&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在第一个例子中，非矩形数据通常会导致逻辑错误。在第二个例子中，长度不是 n 的倍数的数据通常也是错误。因为这两个习惯用法都会悄悄地忽略不匹配的尾部元素。&lt;/div&gt;
&lt;div&gt;最有说服力的例子来自使用了 zip 的标准库&lt;code&gt;ast&lt;/code&gt; ，它在 literal_eval 里产生过一个 bug，&lt;a href=&quot;https://bugs.python.org/issue40355&quot;&gt;会直接丢弃不匹配的节点&lt;/a&gt;：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; ast &lt;span&gt;import&lt;/span&gt; Constant&lt;span&gt;,&lt;/span&gt; Dict&lt;span&gt;,&lt;/span&gt; literal_eval
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; nasty_dict &lt;span&gt;=&lt;/span&gt; Dict&lt;span&gt;(&lt;/span&gt;keys&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;Constant&lt;span&gt;(&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; values&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; literal_eval&lt;span&gt;(&lt;/span&gt;nasty_dict&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# Like eval(&quot;{None: }&quot;)&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;实际上，笔者已经在 Python 的标准库和工具中&lt;a href=&quot;https://www.python.org/dev/peps/pep-0618/%23examples#examples&quot;&gt;找出了许多调用点，&lt;/a&gt; 立即在这些位置启用此新特性是恰当的。&lt;/div&gt;
&lt;h2&gt;基本原理&lt;/h2&gt;
&lt;div&gt;一些评论者声称：布尔开关常量是一种“代码坏气味（code-smell）”，或者与 Python 的设计哲学背道而驰。&lt;/div&gt;
&lt;div&gt;但是，Python 当前在内置函数上有几个布尔关键字参数的用法，它们通常使用编译期常量来调用：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;compile(..., dont_inherit=True)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;open(..., closefd=False)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;print(..., flush=True)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sorted(..., reverse=True)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;标准库中还有许多类似用法。&lt;/div&gt;
&lt;div&gt;这个新参数的想法和名称&lt;a href=&quot;https://mail.python.org/archives/list/python-ideas%40python.org/message/6GFUADSQ5JTF7W7OGWF7XF2NH2XUTUQM&quot;&gt;最初是&lt;/a&gt;由 Ram Rachum 提出的。该议题收到了 100 多个回复，而候选的“equal”也获得了相近的支持数。&lt;/div&gt;
&lt;div&gt;笔者对它们没有很强烈的偏好，尽管“equal equals” 读起来有点尴尬。它还可能（错误地）暗示了 zip 的对象是相等的：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; z &lt;span&gt;=&lt;/span&gt; &lt;span&gt;zip&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2.0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4.0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6.0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;8&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; equal&lt;span&gt;=&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;规范&lt;/h2&gt;
&lt;div&gt;当用关键字参数 strict=True 调用内置类 zip 时，如果参数的长度不同，则生成的迭代器会引发 ValueError。这个异常就发生在迭代器正常停止迭代的地方。&lt;/div&gt;
&lt;h2&gt;向上兼容&lt;/h2&gt;
&lt;div&gt;此项更改是完全向上兼容的。当前的 zip 不接受关键字参数，默认省略 strict 的“非严格”用法会保持不变。&lt;/div&gt;
&lt;h2&gt;参考实现&lt;/h2&gt;
&lt;div&gt;笔者设计了一个&lt;a href=&quot;https://github.com/python/cpython/pull/20921&quot;&gt;C 实现&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;用 Python 大致翻译如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;zip&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;iterables&lt;span&gt;,&lt;/span&gt; strict&lt;span&gt;=&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; iterables&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;
    iterators &lt;span&gt;=&lt;/span&gt; &lt;span&gt;tuple&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;iterable&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; iterable &lt;span&gt;in&lt;/span&gt; iterables&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            items &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; iterator &lt;span&gt;in&lt;/span&gt; iterators&lt;span&gt;:&lt;/span&gt;
                items&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;iterator&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;tuple&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;items&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt; StopIteration&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; strict&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; items&lt;span&gt;:&lt;/span&gt;
        i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;items&lt;span&gt;)&lt;/span&gt;
        plural &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; i &lt;span&gt;==&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;&quot;s 1-&quot;&lt;/span&gt;
        msg &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&lt;span&gt;f&quot;zip() argument &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;i&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt; is shorter than argument&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;plural&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;i&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
        &lt;span&gt;raise&lt;/span&gt; ValueError&lt;span&gt;(&lt;/span&gt;msg&lt;span&gt;)&lt;/span&gt;
    sentinel &lt;span&gt;=&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i&lt;span&gt;,&lt;/span&gt; iterator &lt;span&gt;in&lt;/span&gt; &lt;span&gt;enumerate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;iterators&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;iterator&lt;span&gt;,&lt;/span&gt; sentinel&lt;span&gt;)&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; sentinel&lt;span&gt;:&lt;/span&gt;
            plural &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; i &lt;span&gt;==&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;&quot;s 1-&quot;&lt;/span&gt;
            msg &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&lt;span&gt;f&quot;zip() argument &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;i&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt; is longer than argument&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;plural&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;i&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
            &lt;span&gt;raise&lt;/span&gt; ValueError&lt;span&gt;(&lt;/span&gt;msg&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;被拒绝的意见&lt;/h2&gt;
&lt;h3&gt;（1）添加 itertools.zip_strict&lt;/h3&gt;
&lt;div&gt;这是 Python-Ideas 邮件列表上获得最多支持的替代方案，因此值得在此处加以讨论。它没有任何严重的缺陷，如果本 PEP 被否绝，它是一个很好的替代。&lt;/div&gt;
&lt;div&gt;虽然考虑到这一点，但是在 zip 中添加可选参数可以用较小的更改而更好地解决诱发此 PEP 的问题。&lt;/div&gt;
&lt;h3&gt;（2）依照先例&lt;/h3&gt;
&lt;div&gt;itertools 中有一个 zip_longest，这似乎让人很有动机再添加一个 zip_strict。但是，zip_longest 在许多方面是一个更加复杂且特定的程序：它负责填写缺失的值，但其它函数都不需要操心这种事。&lt;/div&gt;
&lt;div&gt;如果 zip 和 zip_longest 同时放在 itertools 中，或者都作为内置函数，那么在相同的地方添加 zip_strict 就确实是一个更有效的论点。然而，新的“strict”用法在接口和行为方面，相比起 zip_longest，更接近于 zip 的概念，但又不足以成为内置对象。考虑到这个原因，令 zip 就地扩展出一个新的选项，似乎是最自然的选择。&lt;/div&gt;
&lt;h3&gt;（3）易用性&lt;/h3&gt;
&lt;div&gt;如果 zip 能够防止此类 bug，那么用户在调用的地方启动检查，就会变得非常简单。与其编写一套繁重的逻辑来处理，不如用这个新特性来直接检查。&lt;/div&gt;
&lt;div&gt;有人还认为，在标准库中放一个新的函数，相比在一个内置函数上加关键字参数，更“容易发现（discoverable）”。笔者不同意这一论断。&lt;/div&gt;
&lt;h3&gt;（4）维护成本&lt;/h3&gt;
&lt;div&gt;尽管在提升易用性时，具体的实现是个次要问题，但重要的是要认识到，添加新的程序比修改原有程序复杂得多。与此 PEP 一起提供的 CPython 实现非常简单，并且对 zip 的默认行为没有显著的性能影响，而在 itertools 中添加一个全新的程序将需要：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;复制 zip 的许多现有逻辑，zip_longest 就是这么干的。&lt;/li&gt;
&lt;li&gt;大刀阔斧地重构 zip 或 zip_longest 或这两者，以便共享一个公共的或者继承性的实现（这可能会影响性能）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;（5）添加多个“模式”以供切换&lt;/h3&gt;
&lt;div&gt;如果预期有三个或更多模式（mode），这个建议才会比二元标志更有意义。最显而易见的三种模式是：“最短的”（当前 zip 的行为），“严格的”（本 PEP 提议的行为）和“最长的”（itertools.zip_longest 的行为）。&lt;/div&gt;
&lt;div&gt;但是，除了当前的默认值以及本提案的“strict”模式，似乎不需要再添加其它模式。最可能的是添加一个“最长的”模式，但这需要一个新的 fillvalue 参数（它对于前两种模式都没有意义），另外，itertools.zip_longest 已经完美地处理了这种模式，若在 zip 中添加该模式，将会造成重复。目前尚不清楚哪一个是“显而易见的”选择：内置 zip 上的 mode 参数，还是已经长期存在于 itertools 中的 zip_longest。&lt;/div&gt;
&lt;h3&gt;（6）给 zip 添加方法或者构造函数&lt;/h3&gt;
&lt;div&gt;考虑以下两个被提出来的做法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; zm &lt;span&gt;=&lt;/span&gt; &lt;span&gt;zip&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;iters&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;strict&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; zd &lt;span&gt;=&lt;/span&gt; &lt;span&gt;zip&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;strict&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;iters&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;尚不清楚哪个更好，或者哪个更差。如果 zip.strict 作为一个方法来实现，则 zm 没问题，但是 zd 会出现几种令人困惑的情况：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;返回不包装在元组中的结果（如果 iters 仅包含一个元素，一个 zip 迭代器）。&lt;/li&gt;
&lt;li&gt;参数类型错误时抛出 TypeError（如果 iters 只包含一个元素，不是一个 zip 迭代器）。&lt;/li&gt;
&lt;li&gt;否则，参数数量不对时抛出 TypeError。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;如果 zip.strict 是作为 classmethod  或 staticmethod 实现，则 zd 将成功执行，而 zm 将不产生任何结果（这正是我们最初要避免的问题）。&lt;/div&gt;
&lt;div&gt;本提案还面临着更为复杂的问题，因为 CPython 中 zip 内置类的实现细节是未文档化的。这意味着若选择以上的某种行为，当前的实现就会被“锁定”（或至少要求对其进行仿真）。&lt;/div&gt;
&lt;h3&gt;（7）变更 zip 的默认行为&lt;/h3&gt;
&lt;div&gt;zip 的默认行为没有什么“错” ，因为在许多情况下，这确实是正确处理大小不等的输入的方法。例如，在处理无限迭代器时，它非常有用。&lt;/div&gt;
&lt;div&gt;itertools.zip_longest 已经用在仍然需要“额外”尾端数据的情况。&lt;/div&gt;
&lt;h3&gt;（8）使用回调来处理剩余对象&lt;/h3&gt;
&lt;div&gt;尽管基本上可以执行用户需要的任何操作，但此解决方案在处理常见问题时（例如舍弃不匹配的长度），变得不必要的复杂且不直观。&lt;/div&gt;
&lt;h3&gt;（9）引发一个 AssertionError&lt;/h3&gt;
&lt;div&gt;没有内置函数或内置类的 API 会引发 AssertionError。此外，&lt;a href=&quot;https://docs.python.org/3.9/library/exceptions.html%3Fhighlight%3Dassertionerror%23AssertionError#AssertionError&quot;&gt;官方文档&lt;/a&gt; 这么写的（它的全部）：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Raised when an &lt;code&gt;assert&lt;/code&gt; statement fails.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;由于此功能与 Python 的 assert 语句无关，因此不应该引发 AssertionError。用户若希望在优化模式下禁用检查（像一个 assert 语句），可以改用 strict = __debug__。&lt;/div&gt;
&lt;h3&gt;（10）在 map 上添加类似的特性&lt;/h3&gt;
&lt;div&gt;本 PEP 不建议对 map 作任何更改，因为很少使用带有多个可迭代参数的map。但是，本 PEP 的裁定可作为将来讨论类似特性的先例（应该出现）。&lt;/div&gt;
&lt;div&gt;如果本 PEP 被拒绝，则 map 的那种特性实际上也不值得追求。如果通过了，则对 map 的更改不需要新的 PEP（尽管像所有提案一样，都应仔细考虑其有用性）。为了保持一致性，它应遵循此处讨论的跟 zip 相同的 API 和语义。&lt;/div&gt;
&lt;h3&gt;（11）什么也不做&lt;/h3&gt;
&lt;div&gt;此建议可能最没有吸引力。&lt;/div&gt;
&lt;div&gt;悄悄地将数据截断是一种特别令人讨厌的 bug，而手写一个健壮的解决方案却&lt;a href=&quot;https://stackoverflow.com/questions/32954486/zip-iterators-asserting-for-equal-length-in-python&quot;&gt;并非易事&lt;/a&gt;。Python 自己的标准库（前文提到的 ast）是有现实意义的反例，很容易就陷入本 PEP 试图避免的那种陷阱。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 3.10 版本采纳了首个 PEP，中文翻译即将推出</title>
            <link>https://pythoncat.top/posts/2020-06-30-PEP/</link>
            <guid>https://pythoncat.top/posts/2020-06-30-PEP/</guid>
            <pubDate>Tue, 30 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;现在距离 Python 3.9.0 的最终版本还有 3 个月，官方公布的时间线是：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;3.9.0 beta 4: Monday, 2020-06-29&lt;/p&gt;
&lt;p&gt;3.9.0 beta 5: Monday, 2020-07-20&lt;/p&gt;
&lt;p&gt;3.9.0 candidate 1: Monday, 2020-08-10&lt;/p&gt;
&lt;p&gt;3.9.0 candidate 2: Monday, 2020-09-14&lt;/p&gt;
&lt;p&gt;3.9.0 final: Monday, 2020-10-05&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;详情参见 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0596/&quot;&gt;PEP-596&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;这其实也意味着 Python 3.10 的第一个 alpha 版本快要面世了——因为它会随着 3.9.0 的 final 版本一起发布！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;之前有读者问下个版本是不是 4.0，或者误以为下个版本是 4.0，还担心会再次出现 2 升 3 这种大版本不兼容的情况。其实官方早就有消息出来了，下个版本只会是 3.10，是个小版本的特性升级。&lt;/div&gt;
&lt;div&gt;Python 采用了&lt;a href=&quot;https://semver.org/&quot;&gt;语义化版本（Semantic Versioning）&lt;/a&gt; 命名风格，也就是“&lt;strong&gt;主版本号.次版本号.修订号&lt;/strong&gt; ”，在可预见的未来，主版本号还会保持为 3，继续 3.11、3.12 这样排下去……&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;在上个月末（即 5 月 25 日），Python 官方公布了 3.10 版本的发布计划：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;详情参见：&lt;a href=&quot;https://www.python.org/dev/peps/pep-0619/&quot;&gt;https://www.python.org/dev/peps/pep-0619/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;不仅如此，在 6 月中旬，3.10 版本的第一个正式的 PEP 也被采纳了。标题： &lt;a href=&quot;https://www.python.org/dev/peps/pep-0618/&quot;&gt;PEP-618 Add Optional Length-Checking To zip&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;zip 内置函数非常有用，通常用来把两个序列拼出元组，过程就像用拉链把两边拉起来一般，所以也被称为“拉链函数”。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;简单而言，PEP-618 会给 zip 函数增加一个可选参数，当拉链两边的序列不等长时，方便进行异常处理。更多具体内容，可查阅 PEP 文档。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;它的中文翻译工作正在紧锣密鼓地进行中，预计两天内会发布。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;等译完后，我会发布在 Python猫 公众号上，同时归档到 &lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;PEP中文翻译计划&lt;/a&gt; ，敬请大家期待。&lt;/div&gt;
&lt;div&gt;除了这个已被采纳的 PEP，社区里还有几个 PEP 引起了广泛的讨论，例如国内的华蟒社区邮件组这几天就正在讨论 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0622/&quot;&gt;PEP-622&lt;/a&gt;，还有 PEP-620、PEP-621、PEP-623 这些编号相近的提案都处在草案阶段，估计很快就会出现第二个被采纳的 PEP 了。&lt;/div&gt;
&lt;div&gt;按照 3.9.0 版本的开发情况，它最终采纳了 7 个 PEP，详情参见《&lt;a href=&quot;https://mp.weixin.qq.com/s/BA_Lm1XIpAmIib5Ht-417g&quot;&gt;Python 3.9 的 7 个 PEP 介绍&lt;/a&gt; 》。&lt;/div&gt;
&lt;div&gt;那么，3.10 版本又会引入多少个 PEP 呢？Python猫 会持续关注，尽量在第一时间把最新的 PEP 翻译出来，如果你也感兴趣的话，欢迎关注我在 Github 发布的 &lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;PEP中文翻译计划&lt;/a&gt; 。&lt;/div&gt;
&lt;div&gt;推荐阅读 3.9 版本的最新特性解读：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/uRdpqZga6P2zaF67VNQz6w&quot;&gt;Python 3.9 新特性：任意表达式可作为装饰器！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/bjQjVmf7dP5fOqCS1cObqQ&quot;&gt;Python 3.9 性能优化：更快的 list()、dict() 和 range() 等内置类型&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/BA_Lm1XIpAmIib5Ht-417g&quot;&gt;Python 3.9 beta2 版本发布了，看看这 7 个新的 PEP 都是什么？&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 为什么不支持 i++ 自增语法，不提供 ++ 操作符？</title>
            <link>https://pythoncat.top/posts/2020-06-21-increment/</link>
            <guid>https://pythoncat.top/posts/2020-06-21-increment/</guid>
            <pubDate>Sun, 21 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在 C/C++/Java 等等语言中，整型变量的自增或自减操作是标配，它们又可分为前缀操作（++i 和 —i）与后缀操作（i++ 和 i—），彼此存在着一些细微差别，各有不同的用途。&lt;/div&gt;
&lt;div&gt;这些语言的使用者在接触 Python 时，可能会疑惑为什么它不提供 ++ 或 — 的操作呢？&lt;/div&gt;
&lt;div&gt;Python 中虽然可能出现 ++i 这种前缀形式的写法，但是它并没有“++”自增操作符，此处只是两个“+”（正数符号）的叠加而已，至于后缀形式的“++”，则完全不支持（SyntaxError: invalid syntax）。&lt;/div&gt;
&lt;div&gt;本期“&lt;strong&gt;Python为什么&lt;/strong&gt; ”栏目，我们将会从两个主要的角度来回答：&lt;strong&gt;Python 为什么不支持 i++ 自增语法？&lt;/strong&gt; （PS：此处自增指代“自增和自减”，下同）&lt;/div&gt;
&lt;div&gt;首先，Python 当然可以实现自增效果，即写成&lt;code&gt;i += 1&lt;/code&gt; 或者 &lt;code&gt;i = i + 1&lt;/code&gt; ，这在其它语言中也是通用的。&lt;/div&gt;
&lt;div&gt;虽然 Python 在底层用了不同的魔术方法（&lt;code&gt;__add__()&lt;/code&gt; 和 &lt;code&gt;__iadd__()&lt;/code&gt; ）来完成计算，但表面上的效果完全相同。&lt;/div&gt;
&lt;div&gt;所以，我们的问题可以转化成：&lt;strong&gt;为什么上面的两种写法会胜过 i++，成为 Python 的最终选择呢？&lt;/strong&gt;&lt;/div&gt;
&lt;h2&gt;1、Python 的整数是不可变类型&lt;/h2&gt;
&lt;div&gt;当我们定义&lt;code&gt;i = 1000&lt;/code&gt; 时，不同语言会作出不同的处理：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;C 之类的语言（写法 &lt;code&gt;int i = 1000&lt;/code&gt;）会申请一块内存空间，并给它“绑定”一个固定的名称 i，同时写入一个可变的值 1000。在这里，i 的地址以及类型是固定的，而值是可变的（在一定的表示范围内）&lt;/li&gt;
&lt;li&gt;Python（写法&lt;code&gt;i = 1000&lt;/code&gt;）也会申请一块内存空间，但是它会“绑定”给数字 1000，即这个 1000 的地址以及类型是固定的（immutable），至于 i，只是一个名称标签贴在 1000 上，自身没有固定的地址和类型&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;所以当我们令 i “自增”时（i = i + 1），它们的处理是不同的：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;C 之类的语言先找到 i 的地址上存的数值，然后令它加 1，操作后新的数值就取代了旧的数值&lt;/li&gt;
&lt;li&gt;Python 的操作过程是把 i 指向的数字加 1，然后把结果绑定到新申请的一块内存空间，再把名称标签 i “贴”到新的数字上。新旧数字可以同时存在，不是取代关系&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;打一个不太恰当的比方：C 中的 i 就像一个宿主，数字 1000 寄生在它上面；而 Python 中的 1000 像个宿主，名称 i 寄生在它上面。C 中的 i 与 Python 中的 1000，它们则寄生在底层的内存空间上……&lt;/div&gt;
&lt;div&gt;还可以这样理解：&lt;strong&gt;C 中的变量 i 是一等公民，数字 1000 是它的一个可变的属性；Python 中的数字 1000 是一等公民，名称 i 是它的一个可变的属性。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;有了以上的铺垫，我们再来看看 i++，不难发现：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;C 之类的语言，i++ 可以表示 i 的数字属性的增加，&lt;strong&gt;它不会开辟新的内存空间，也不会产生新的一等公民&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Python 之类的语言，i++ 如果是对其名称属性的操作，那样就没有意义了（总不能按字母表顺序，把 i 变成 j 吧）；如果理解成对数字本体的操作，那么情况就会变得复杂：它会产生新的一等公民 1001，因此需要给它分配一个内存地址，此时若占用 1000 的地址，则涉及旧对象的回收，那原有对于 1000 的引用关系都会受到影响，所以只能开辟新的内存空间给 1001&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;Python 若支持 i++，其操作过程要比 C 的 i++ 复杂，而且其含义也&lt;strong&gt;不再是“令数字增加1”（自增），而是“创建一个新的数字”（新增），&lt;/strong&gt; 这样的话，“自增操作符”（increment operator）就名不副实了。&lt;/div&gt;
&lt;div&gt;Python 在理论上可以实现 i++ 操作，但它就必须重新定义“自增操作符”，还会令有其它语言经验的人产生误解，不如就让大家直接写成&lt;code&gt;i += 1&lt;/code&gt; 或者 &lt;code&gt;i = i + 1&lt;/code&gt; 好了。&lt;/div&gt;
&lt;h2&gt;2、Python 有可迭代对象&lt;/h2&gt;
&lt;div&gt;C/C++ 等语言设计出 i++，最主要的目的是为了方便使用三段式的 for 结构：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 执行 xxx&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这种程序关心的是数字本身的自增过程，数字做加法与程序体的执行相关联。&lt;/div&gt;
&lt;div&gt;Python 中没有这种 for 结构的写法，它提供了更为优雅的方式：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;# 执行 xxx&lt;/span&gt;

my_list &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;你好&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;我是Python猫&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;欢迎关注&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; info &lt;span&gt;in&lt;/span&gt; my_list&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;info&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这里体现了不同的思维方式，它关心的是在一个数值范围内的迭代遍历，并不关心也不需要人为对数字做加法。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Python 中的可迭代对象/迭代器/生成器提供了非常良好的迭代/遍历用法，能够做到对 i++ 的完全替代。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;例如，上例中实现了对列表内值的遍历，Python 还可以用 enumerate() 实现对下标与具体值的同时遍历：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;my_list &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;你好&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;我是Python猫&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;欢迎关注&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i&lt;span&gt;,&lt;/span&gt; info &lt;span&gt;in&lt;/span&gt; &lt;span&gt;enumerate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;my_list&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt; info&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 打印结果：&lt;/span&gt;
&lt;span&gt;0&lt;/span&gt; 你好
&lt;span&gt;1&lt;/span&gt; 我是Python猫
&lt;span&gt;2&lt;/span&gt; 欢迎关注&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;再例如对于字典的遍历，Python 提供了 keys()、values()、items() 等遍历方法，非常好用：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;my_dict &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;1&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;b&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;2&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;c&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;3&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt; my_dict&lt;span&gt;.&lt;/span&gt;keys&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt; my_dict&lt;span&gt;.&lt;/span&gt;items&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;有了这样的利器，哪里还有 i++ 的用武之地呢？&lt;/div&gt;
&lt;div&gt;不仅如此，Python 中基本上很少使用&lt;code&gt;i += 1&lt;/code&gt; 或者 &lt;code&gt;i = i + 1&lt;/code&gt; ，由于存在着随处可见的可迭代对象，开发者们很容易实现对一个数值区间的操作，也就很少有对于某个数值作累加的诉求了。&lt;/div&gt;
&lt;div&gt;所以，回到我们开头的问题，其实这两种“自增”写法并没有胜出 i++ 多少，只因为它们是通用型操作，又不需要引入新的操作符，所以 Python 才延续了一种基础性的支持。&lt;strong&gt;真正的赢家其实是各种各样的可迭代对象！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;稍微小结下：Python 不支持自增操作符，一方面是因为它的整数是不可变类型的一等公民，自增操作（++）若要支持，则会带来歧义；另一方面主要因为它有更合适的实现，即可迭代对象，对遍历操作有很好的支持。&lt;/div&gt;
&lt;h2&gt;其它资料&lt;/h2&gt;
&lt;div&gt;知乎上有一个问题“&lt;a href=&quot;https://www.zhihu.com/question/20913064&quot;&gt;为什么 Python、Ruby 等语言弃用了自增运算符？&lt;/a&gt;”，下面的&lt;a href=&quot;https://www.zhihu.com/question/20913064/answer/2606783090&quot;&gt;这个回答&lt;/a&gt; 非常详细，参考阅读。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 为什么推荐蛇形命名法？</title>
            <link>https://pythoncat.top/posts/2020-06-17-snake-case/</link>
            <guid>https://pythoncat.top/posts/2020-06-17-snake-case/</guid>
            <pubDate>Wed, 17 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;关于变量的命名，这又是一个容易引发程序员论战的话题。如何命名才能更具有可读性、易写性与明义性呢？众说纷纭。&lt;/div&gt;
&lt;div&gt;本期“Python为什么”栏目，我们将聚焦于变量命名中的连接方式，来切入这块是非之地，想要回答的问题是——&lt;strong&gt;Python 为什么要推荐蛇形命名法？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;首先一点，对于&lt;strong&gt;单个字符或者单词&lt;/strong&gt; （例如：a、A、PYTHON、Cat），当它们被用作变量名时，大致有全小写、全大写和首字母大写这几种情况。编程语言中出现这些情况时，它们基本上跟英语的表达习惯是相同的。&lt;/div&gt;
&lt;div&gt;但是，编程语言为了令变量名表达出更丰富的含义，通常需要使用&lt;strong&gt;多个单词或符号。&lt;/strong&gt; 英语习惯使用空格来间隔开单词，然而这种用法在编程语言中会带来一些麻烦，所以程序员们就创造出了另外的方法：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;蛇形命名法（snake case）&lt;/li&gt;
&lt;li&gt;驼峰命名法（camel case）&lt;/li&gt;
&lt;li&gt;匈牙利命名法（HN case）&lt;/li&gt;
&lt;li&gt;帕斯卡命名法（Pascal case）&lt;/li&gt;
&lt;li&gt;脊柱命名法（spinal case）&lt;/li&gt;
&lt;li&gt;自由命名法（studly caps）&lt;/li&gt;
&lt;li&gt;驼峰蛇形命名法&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;总体而言，这些命名法都是要&lt;strong&gt;克服单词间的空格，从而把不同单词串连起来，&lt;/strong&gt; 最终达到创造出一种新的“单词”的效果。&lt;/div&gt;
&lt;div&gt;我画了一张思维导图，大略区分了这几种命名法：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;如果按照受众量与知名程度排名，毫无疑问排前两位的是驼峰命名法和蛇形命名法。&lt;/div&gt;
&lt;div&gt;我们可以简单比较一下它们的优缺点：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;可读性：蛇形命名法用下划线拉大词距，更清楚易读；驼峰命名法的变量名紧凑，节省行宽&lt;/li&gt;
&lt;li&gt;易写性：驼峰命名法以大小写为区分，不引入额外的标识符；蛇形命名法统一小写，输入相对方便&lt;/li&gt;
&lt;li&gt;明义性：对于某些缩写成的专有名词，例如 HTTP、RGB、DNS等等，一般习惯全用大写表示，但是如果严格遵循这两种命名法的话，须得只留首字母大写或者全小写，这样对原意都会造成一些“破坏”，有时候甚至让人感觉到别扭。如果保留全大写，IDE 可能识别不准，反而会出现波浪提示&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;由此可见，它们各有优缺点，但哪一方都不具有压倒性。我个人稍微偏好于蛇形命名法，但是在需要用驼峰命名的时候（比如写 Java 时），也能无障碍切换。&lt;/div&gt;
&lt;div&gt;需要指出的是，Python 也推荐使用驼峰式命名，那是在类名、Type 变量、异常 exception 名这些情况。而在&lt;strong&gt;包名、模块名、方法名和普通变量名&lt;/strong&gt; 等情况，则是推荐用蛇形命名（lower_case_with_underscores）。&lt;/div&gt;
&lt;div&gt;那么，为什么 Python 会推荐用蛇形命名法呢？&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;最大的原因是历史原因。&lt;/strong&gt; 蛇形命名方式起源于 1960 年代，那时它甚至还没有特定的名称。Python 从 C 语言中借鉴过来后，给它起名为“lower_case_with_underscores”，即带下划线的小写命名。&lt;/div&gt;
&lt;div&gt;直到 21 世纪初的几年，在 Intel 和 Ruby 社区中，才有人开始以“snake_case”即蛇形命名来称呼它。&lt;/div&gt;
&lt;div&gt;现今有不少编程语言在某些场景下会推荐使用蛇形命名法，而 Python 则是其中最早这么做的之一，并且是使用场景最多的语言之一。&lt;/div&gt;
&lt;div&gt;维基百科上统计了一份清单，可以看出 Python 对它的偏好：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;其次，还有一个比较重要的原因，&lt;strong&gt;那就是 Python 对下划线“_”的独特偏爱。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;比如类似于 _xx、__xx、xx_、__xx__ 等等的写法就随处可见，甚至还有孤零零一个下划线 _ 作为变量的特殊情况。这样看来，下划线作为单词间的连接，恰恰是这种传统习惯的一部分。&lt;/div&gt;
&lt;div&gt;最后，我还看到过一种解释：&lt;strong&gt;因为 Python 是蟒蛇啊，理所当然是用蛇形命名……&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;对于这三个解释，你们是如何感想的呢？对于蛇形命名法，大家是喜欢还是不喜欢呢？欢迎留言交流。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 3.9 beta2 版本发布了，看看这 7 个新的 PEP 都是什么？</title>
            <link>https://pythoncat.top/posts/2020-06-09-PEP/</link>
            <guid>https://pythoncat.top/posts/2020-06-09-PEP/</guid>
            <pubDate>Tue, 09 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;原作：&lt;strong&gt;Jake Edge&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;译者：豌豆花下猫@Python猫&lt;/div&gt;
&lt;div&gt;英文：&lt;a href=&quot;https://lwn.net/Articles/819853/&quot;&gt;https://lwn.net/Articles/819853/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;随着 Python 3.9.0b1 的发布，即开发周期中计划的四个 beta 版本的首个，Python 3.9 的功能已经是完善了。在 10 月发布最终版本之前，还会有许多测试和稳定性方面的工作要做。&lt;/div&gt;
&lt;div&gt;（译注：beta1 版本发布于 5 月 18 日，作者文章写于 5 月 20，而到本篇译文发布时，beta2 刚好在今天即 6 月 9 日发布，这是一个巧合！）&lt;/div&gt;
&lt;div&gt;该发布说明中列出了被 3.9 接受的 7 个 Python 增强提案（PEP）。我们研究了其中的一些 PEP，看到有一些更新。现在似乎是一个介绍 Python 3.9 带来的一些东西的好时机。&lt;/div&gt;
&lt;h2&gt;1、字符串操作&lt;/h2&gt;
&lt;div&gt;有时最简单（表明上的）的事情最困难，或者至少会引起巨大的讨论。其中大部分的争议是关于命名（还能是什么？），但是给标准字符串对象添加函数，来删除前缀和后缀，这种想法是毫无争议的。&lt;/div&gt;
&lt;div&gt;是否可以将那些词缀（前缀和后缀的统称）指定为序列，以便在一次调用中处理多个词缀，这一点尚不明确，最后它被从提案中删除了，等待着其他人再次推动更改。&lt;/div&gt;
&lt;div&gt;在 3 月底，Dennis Sweeney 在 python-dev 邮件列表上请求核心开发者支持 PEP 616（“字符串删除前缀和后缀的方法”）。他指出了自 2019 年 3 月以来关于该话题的 python-ideas 讨论。埃里克·史密斯（Eric V. Smith）同意支持该 PEP，这促使 Sweeney 发布并启动了讨论。&lt;/div&gt;
&lt;div&gt;在最初版本中，他使用 cutprefix() 和 cutsuffix() 作为要添加给字符串对象的方法名。四种类型的 Python 对象将获得新的方法：str（Unicode 字符串），byte（二进制序列），bytearray（可变的二进制序列）和 collections.UserString（字符串对象的一种封装）。&lt;/div&gt;
&lt;div&gt;它的写法如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&apos;abcdef&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;cutprefix&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;abc&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 返回&apos;def&apos;&lt;/span&gt;
&lt;span&gt;&apos;abcdef&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;cutsuffix&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;ef&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 返回&apos;abcd&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;针对命名部分，出现了一大堆的建议。基本上很少有人喜欢“cut”，因此“strip”、“strim”和“remove”被提出来了，并且都获得了一些支持。&lt;/div&gt;
&lt;div&gt;stripprefix() 以及 stripsuffix() 由于 PEP 中指出的一种理由，至少是被部分地反对了；现有的“strip”函数令人困惑，因此应避免重用该名称。&lt;/div&gt;
&lt;div&gt;str.lstrip() 和 str.rstrip() 方法也用于删除前导字符和尾随字符，但是它们对于真正在寻找 cutprefix() 功能的程序员来说是一个困惑的来源。&lt;/div&gt;
&lt;div&gt;*strip() 在调用时接收一个字符串参数，但会将其视为一组字符，并从字符串开头或结尾消除：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&apos;abcdef&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;lstrip&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;abc&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 返回“def”，符合预期&lt;/span&gt;
&lt;span&gt;&apos;abcbadefed&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;lstrip&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;abc&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 返回&apos;defed&apos;，完全不符合预期&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;最终，removeprefix() 和 removesuffix() 似乎占据了上风，这正是 Sweeney 最终改成的版本。Guido van Rossum 也支持这些名字。&lt;/div&gt;
&lt;div&gt;埃里克·法格伦（Eric Fahlgren）这样搞笑地总结了命名的争论：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;我认为如果你先写文档，则名称的选择会更容易些：&lt;/p&gt;
&lt;p&gt;cutprefix - 删除指定的前缀。&lt;/p&gt;
&lt;p&gt;trimprefix - 删除指定的前缀。&lt;/p&gt;
&lt;p&gt;stripprefix - 删除指定的前缀。&lt;/p&gt;
&lt;p&gt;removeprefix - 删除指定的前缀。废话  :)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;Sweeney 更新了 PEP，回应了许多评论，但还增加了提议将字符串元组作为词缀的功能（可以在 PEP GitHub 仓库中看到该版本）。&lt;/div&gt;
&lt;div&gt;但是史蒂文·达普拉诺（Steven D’Aprano）不确定这样做是否合理。他指出，唯一接受元组参数的字符串操作是 str.startswith() 和 str.endswith()，而它们不返回字符串（只是一个布尔值）。他怀疑添加这一种接收元组参数却返回字符串的方法，因为无论选择何种规则来处理元组，对于某些人来说都是“错误的”选择。&lt;/div&gt;
&lt;div&gt;例如：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;这里的困难在于，如果两个或多个前缀都能匹配，则“剪切这些前缀中的一个”的概念是模棱两可的。对 startwith 没有区别：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &lt;span&gt;&quot;extraordinary&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;startswith&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;ex&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;extra&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为是从左到右，从最短到最大，甚至是随机顺序匹配都为True。但是对于 cutprefix，应该删除哪个前缀？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;如他所说，建议的规则是使用从左到右处理元组的第一个匹配字符串，但是有些人可能想要最长的匹配或最后一个匹配；这一切都取决于使用的上下文。他建议在提交添加此类行为之前，要给该功能更多的“浸泡时间”（译注：即预备时间）：“在添加多前缀/后缀的支持之前，我们首先应该对简单的情况进行一些实际的体验。”&lt;/div&gt;
&lt;div&gt;伊桑·弗曼（Ethan Furman）同意达普拉诺（D’Aprano）的意见。但是维克托·斯汀纳（Victor Stinner）强烈赞成元组参数的想法，只不过，他还想知道当传入的元组有空字符串时，会怎么处理。根据 PEP 提议，在处理元组时遇到空字符串（实际上可以匹配任何内容）只会返回原始字符串，这会导致令人惊讶的结果：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;cutsuffix&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot; World&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;    &lt;span&gt;# 返回 &quot;Hello World&quot;&lt;/span&gt;
cutsuffix&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot; World&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;    &lt;span&gt;# 返回 &quot;Hello&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这个例子不太明显；词缀不一定是硬编码的，因此空字符串可能会溜进意想不到的位置。Stinner 建议如果遇到空字符串，则抛出 ValueError，类似于 str.split()。但是 Sweeney 决定完全删除元组参数功能，以便“允许对此有更强见解的人在另外的 PEP 中提出并捍卫一系列的语义”。他在 3 月 28 日发布了该 PEP 的最新版本。&lt;/div&gt;
&lt;div&gt;4 月 9 日，Sweeney 发起了一个指导委员会 issue，请求对其 PEP 进行评审。4 月 20 日，Stinner 代表委员会接受了该提案。&lt;/div&gt;
&lt;div&gt;这是一个很小的更改，但值得花时间确保它具有长期适用的接口（和语义）。我们将在 Python 3.9 中看到 removeprefix() 和removesuffix()。&lt;/div&gt;
&lt;h2&gt;2、新解析器&lt;/h2&gt;
&lt;div&gt;并不令人感到惊讶的是，指导委员会已经接受了我们在 4 月中旬介绍过的 CPython 新解析器。PEP 617（“CPython 新的 PEG 解析器”）由 Python 创始人即前仁慈的独裁者（BDFL） Guido van Rossum 以及 Pablo Galindo Salgado 和 Lysandros Nikolaou 共同提出。&lt;/div&gt;
&lt;div&gt;它已经运行良好，并且在现有解析器的速度和内存使用方面提升了 10% 以内的性能。由于解析器是基于解析表达语法（PEG），因此也将简化语言规范。CPython 现有的 LL(1) 解析器存在诸多缺点和一些 hack，新的解析器将会消除掉。&lt;/div&gt;
&lt;div&gt;这一更改为 Python 超越 LL(1) 语法铺平了道路，尽管现有语言并不完全是 LL(1)。这一更改不会太快，因为计划是在 Python 3.9 的命令行中提供开关，保持现有解析器可用。&lt;/div&gt;
&lt;div&gt;但是 Python 3.10 将删除现有的解析器，这可能会导致语言变更。如果做了那些更改，那么，其它的 Python 实现（例如 PyPy 和 MicroPython）就需要切换解析器的 LL(1) 实现，以便跟上语言规范的要求。这可能会使核心开发者暂停进行此类更改。&lt;/div&gt;
&lt;h2&gt;3、更多内容&lt;/h2&gt;
&lt;div&gt;我们在三月初查看了 PEP 615（“在标准库中支持 IANA 时区数据库”）。它将在标准库中添加一个&lt;code&gt;zoneinfo&lt;/code&gt; 模块，该模块将有助于从 IANA 时区数据库中（也称为“Olson数据库”）获取时区信息，以填充时区对象。在撰写本文时，它看起来很顺利。&lt;/div&gt;
&lt;div&gt;在 3 月底，Paul Ganssle 请求就该 PEP 作出决议。他认为在一个有趣的时间范围内接受它，可能会很有趣：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;… 我希望（出于异想天开的原因）在 4 月 5 日（星期日）UTC 时间 02:00-04:00 或 13:00-17:30 之间接受它，因为这些时间代表着地球上某些地方的不明确时间（主要在澳大利亚）。还有另一个时机，那就是在 4 月 19 日星期日 UTC 01:00-03:00 之间，这段时间在西撒哈拉是不明确的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;他意识到这可能难以实现，它当然不是优先考虑的事。指导委员会没有错过第二个时间窗太多；Barry Warsaw 于 4 月 20 日宣布接受该 PEP。&lt;/div&gt;
&lt;div&gt;Python 现在将具有一种机制来访问系统的时区数据库，以创建和处理时区。另外，Python 软件包索引（PyPI）中有一个 tzdata 模块，它为缺少 IANA 数据的系统提供这些数据；它将由 Python 核心开发者维护。&lt;/div&gt;
&lt;div&gt;PEP 593（“灵活的函数和变量注释”）添加了一种将上下文特定的（context-specific）元数据与函数和变量关联的方法。实际上，type hint 注解已挤出了很多年前在 Python 3.0 中实现的 PEP 3107（“函数注释”）中设想的其它用例。PEP 593 使用注解的（Annotated）类型提示为这些用例创建了一种新的机制。&lt;/div&gt;
&lt;div&gt;PEP 585（“标准集合中的类型提示泛型”）提供了另一种清除方法。它将允许删除在 typing 模块中维护的一组并行的类型别名，以支持泛型。例如，type.List 类型将不再需要支持诸如“dict[str,list[int]]”之类的注解（例如，一个带有字符串键和整数列表的值的字典）。&lt;/div&gt;
&lt;div&gt;字典“加法”的联合操作也会是 Python 3.9 的一部分。它曾不时引起争议，但是 2 月中旬，PEP 584（“给字典添加联合操作符”）被 Van Rossum 推荐采纳。指导委员会迅速同意了，该特性于 2 月 24 日合入。&lt;/div&gt;
&lt;div&gt;最后一个 PEP 是 PEP 602（“Python 的年度发布周期”）。如提案所书，它将发布节奏从每 18 个月更改为每年一次。但是，开发和发布周期是重叠的，因此整个功能开发需要 12 个月的时间。当第一个 Python 3.9 beta 版本发布时（即现在），Python 3.10 的功能开发就开始了。请继续关注来年的下一轮 PEP。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>涨见识了，在终端执行 Python 代码的 6 种方式！</title>
            <link>https://pythoncat.top/posts/2020-06-06-terminal/</link>
            <guid>https://pythoncat.top/posts/2020-06-06-terminal/</guid>
            <pubDate>Sat, 06 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;原作：&lt;a href=&quot;https://snarky.ca/author/brett/&quot;&gt;BRETT CANNON&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;译者：豌豆花下猫@Python猫&lt;/div&gt;
&lt;div&gt;英文：&lt;a href=&quot;https://snarky.ca/the-many-ways-to-pass-code-to-python-from-the-terminal&quot;&gt;https://snarky.ca/the-many-ways-to-pass-code-to-python-from-the-terminal&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;为了我们推出的 &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=ms-python.python&quot;&gt;VS Code 的 Python 插件&lt;/a&gt; [1]，我写了一个&lt;a href=&quot;https://github.com/microsoft/vscode-python/tree/master/news&quot;&gt;简单的脚本来生成变更日志&lt;/a&gt; [2]（类似于&lt;a href=&quot;https://pypi.org/project/towncrier/&quot;&gt;Towncrier&lt;/a&gt; [3]，但简单些，支持 Markdown，符合我们的需求）。在发布过程中，有一个步骤是运行&lt;code&gt;python news&lt;/code&gt; ，它会将 Python 指向我们代码中的”news”目录。&lt;/div&gt;
&lt;div&gt;前几天，一位合作者问这是如何工作的，似乎我们团队中的每个人都知道如何使用&lt;code&gt;-m&lt;/code&gt; ？（请参阅我的有关&lt;a href=&quot;https://snarky.ca/why-you-should-use-python-m-pip/&quot;&gt;带 -m 使用 pip 的文章&lt;/a&gt; [4]，了解原因）（译注：关于此话题，我也写过一篇&lt;a href=&quot;https://mp.weixin.qq.com/s/co_OAaVQ49rPfgoAh6Pejw&quot;&gt;更为详细的文章&lt;/a&gt; ）&lt;/div&gt;
&lt;div&gt;这使我意识到其他人可能不知道有五花八门的方法可以将 Python 指向要执行的代码，因此有了这篇文章。&lt;/div&gt;
&lt;h2&gt;1、通过标准输入和管道&lt;/h2&gt;
&lt;div&gt;因为如何用管道传东西给一个进程是属于 shell 的内容，我不打算深入解释。毋庸置疑，你可以将代码传递到 Python 中。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 管道传内容给 python&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;print(&apos;hi&apos;)&quot;&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; python&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;如果将文件重定向到 Python，这显然也可以。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 重定向一个文件给 python&lt;/span&gt;
python &lt;span&gt;&amp;lt;&lt;/span&gt; spam.py&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;归功于 Python 的 UNIX 传统，这些都不太令人感到意外。&lt;/div&gt;
&lt;h2&gt;2、通过&lt;code&gt;-c&lt;/code&gt; 指定的字符串&lt;/h2&gt;
&lt;div&gt;如果你只需要快速地检查某些内容，则可以在命令行中将代码作为字符串传递。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 使用 python 的 -c 参数&lt;/span&gt;
python &lt;span&gt;-&lt;/span&gt;c &lt;span&gt;&quot;print(&apos;hi&apos;)&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;当需要检查仅一行或两行代码时，我个人会使用它，而不是启动 REPL（译注：Read Eval Print Loop，即交互式解释器，例如在 windows 控制台中输入&lt;code&gt;python&lt;/code&gt;， 就会进入交互式解释器。-c 参数用法可以省去进入解释器界面的过程） 。&lt;/div&gt;
&lt;h2&gt;3、文件的路径&lt;/h2&gt;
&lt;div&gt;最众所周知的传代码给 python 的方法很可能是通过文件路径。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 指定 python 的文件路径&lt;/span&gt;
python spam&lt;span&gt;.&lt;/span&gt;py&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;要实现这一点的关键是将包含该文件的目录放到&lt;code&gt;sys.path&lt;/code&gt; 里。这样你的所有导入都可以继续使用。但这也是为什么你不能/不应该传入包含在一个包里的模块路径。因为&lt;code&gt;sys.path&lt;/code&gt; 可能不包含该包的目录，因此所有的导入将相对于与你预期的包不同的目录。&lt;/div&gt;
&lt;h2&gt;4、对包使用 -m&lt;/h2&gt;
&lt;div&gt;执行 Python 包的正确方法是使用 -m 并指定要运行的包名。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;python -m spam&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;它在底层使用了&lt;a href=&quot;https://docs.python.org/3/library/runpy.html#module-runpy&quot;&gt;runpy&lt;/a&gt;  [5]。要在你的项目中做到这点，只需要在包里指定一个&lt;code&gt;__main__.py&lt;/code&gt; 文件，它将被当成&lt;code&gt;__main__&lt;/code&gt; 执行。而且子模块可以像任何其它模块一样导入，因此你可以对其进行各种测试。&lt;/div&gt;
&lt;div&gt;我知道有些人喜欢在一个包里写一个&lt;code&gt;main&lt;/code&gt; 子模块，然后将其&lt;code&gt;__main__.py&lt;/code&gt; 写成：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;.&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; main

&lt;span&gt;if&lt;/span&gt; __name__ &lt;span&gt;==&lt;/span&gt; &lt;span&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    main&lt;span&gt;.&lt;/span&gt;main&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;就我个人而言，我不感冒于单独的&lt;code&gt;main&lt;/code&gt; 模块，而是直接将所有相关的代码放入&lt;code&gt;__main__.py&lt;/code&gt; ，因为我感觉这些模块名是多余的。&lt;/div&gt;
&lt;div&gt;（译注：即作者不关心作为入口文件的”main”或者“__main__”模块，因为执行时只需用它们的包名即可。我认为这也暗示了入口模块不该再被其它模块 import。我&lt;a href=&quot;https://mp.weixin.qq.com/s/1ehySR5NH2v1U8WIlXflEQ&quot;&gt;上篇文章&lt;/a&gt; [6]比作者的观点激进，认为连那句 if 语句都不该写。）&lt;/div&gt;
&lt;h2&gt;5、目录&lt;/h2&gt;
&lt;div&gt;定义&lt;code&gt;__main__.py&lt;/code&gt;也可以扩展到目录。如果你看一下促成此博客文章的示例，&lt;code&gt;python news&lt;/code&gt; 可执行，就是因为 news 目录有一个 &lt;code&gt;__main__.py&lt;/code&gt; 文件。该目录就像一个文件路径被 Python 执行了。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;现在你可能会问：“为什么不直接指定文件路径呢？”好吧，坦白说，关于文件路径，有件事得说清楚。😄在发布过程中，我可以简单地写上说明，让运行&lt;code&gt;python news/announce.py&lt;/code&gt; ，但是并没有确切的理由说明这种机制何时存在。&lt;/div&gt;
&lt;div&gt;再加上我以后可以更改文件名，而且没人会注意到。再加上我知道代码会带有辅助文件，因此将其放在目录中而不是单独作为单个文件是有意义的。&lt;/div&gt;
&lt;div&gt;当然，我也可以将它变为一个使用 -m 的包，但是没必要，因为 announce 脚本很简单，我知道它要保持成为一个单独的自足的文件（少于 200 行，并且测试模块也大约是相同的长度）。&lt;/div&gt;
&lt;div&gt;况且，&lt;code&gt;__main__.py&lt;/code&gt; 文件非常简单。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; runpy
&lt;span&gt;# Change &apos;announce&apos; to whatever module you want to run.&lt;/span&gt;
runpy&lt;span&gt;.&lt;/span&gt;run_module&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;announce&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; run_name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;__main__&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; alter_sys&lt;span&gt;=&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;现在显然必须要处理依赖关系，但是如果你的脚本仅使用标准库或将依赖模块放在&lt;code&gt;__main__.py&lt;/code&gt; 旁边（译注：即同级目录），那么就足够了！&lt;/div&gt;
&lt;div&gt;（译注：我觉得作者在此有点“炫技”了，因为这种写法的前提是得知道 runpy 的用法，但是就像前一条所写的用 -m 参数运行一个包，在底层也是用了 runpy。不过炫技的好处也非常明显，即&lt;code&gt;__main__.py&lt;/code&gt; 里不用导入 announce 模块，还是以它为主模块执行，也就不会破坏原来的依赖导入关系）&lt;/div&gt;
&lt;h2&gt;6、执行一个压缩文件&lt;/h2&gt;
&lt;div&gt;如果你确实有多个文件和/或依赖模块，并且希望将所有代码作为一个单元发布，你可以用一个&lt;code&gt;__main__.py&lt;/code&gt; ，放置在一个压缩文件中，并把压缩文件所在目录放在 sys.path 里，Python 会替你运行&lt;code&gt;__main__.py&lt;/code&gt; 文件。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 将一个压缩包传给 Python&lt;/span&gt;
python app&lt;span&gt;.&lt;/span&gt;pyz&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;人们现在习惯上用 .pyz 文件扩展名来命名此类压缩文件，但这纯粹是传统，不会影响任何东西；你当然也可以用 .zip 文件扩展名。&lt;/div&gt;
&lt;div&gt;为了简化创建此类可执行的压缩文件，标准库提供了&lt;a href=&quot;https://docs.python.org/3/library/zipapp.html#module-zipapp&quot;&gt;zipapp&lt;/a&gt; [7]模块。它会为你生成&lt;code&gt;__main__.py&lt;/code&gt;并添加一条组织行（shebang line），因此你甚至不需要指定 python，如果你不想在 UNIX 上指定它的话。如果你想移动一堆纯 Python 代码，这是一种不错的方法。&lt;/div&gt;
&lt;div&gt;不幸的是，仅当压缩文件包含的所有代码都是纯 Python 时，才能这样运行压缩文件。执行压缩文件对扩展模块无效（这就是为什么 setuptools 有一个 &lt;a href=&quot;https://setuptools.readthedocs.io/en/latest/setuptools.html#setting-the-zip-safe-flag&quot;&gt;zip_safe&lt;/a&gt; [8]标志的原因）。（译注：扩展模块 extension module，即 C/C++ 之类的非 Python 文件）&lt;/div&gt;
&lt;div&gt;要加载扩展模块，Python 必须调用 &lt;a href=&quot;https://linux.die.net/man/3/dlopen&quot;&gt;dlopen()&lt;/a&gt; [9]函数，它要传入一个文件路径，但当该文件路径就包含在压缩文件内时，这显然不起作用。&lt;/div&gt;
&lt;div&gt;我知道至少有一个人与 glibc 团队交谈过，关于支持将内存缓冲区传入压缩文件，以便 Python 可以将扩展模块读入内存，并将其传给压缩文件，但是如果内存为此服务，glibc 团队并不同意。&lt;/div&gt;
&lt;div&gt;但是，并非所有希望都丧失了！你可以使用诸如&lt;a href=&quot;https://pypi.org/project/shiv/&quot;&gt;shiv&lt;/a&gt;  [10]之类的项目，它会捆绑（bundle）你的代码，然后提供一个&lt;code&gt;__main__.py&lt;/code&gt; 来处理压缩文件的提取、缓存，然后为你执行代码。尽管不如纯 Python 解决方案理想，但它确实可行，并且在这种情况下算得上是优雅的。&lt;/div&gt;
&lt;div&gt;（译注：翻译水平有限，难免偏差。我加注了部分内容，希望有助于阅读。请搜索关注“Python猫”，阅读更多优质的原创或译作。）&lt;/div&gt;
&lt;h3&gt;参考链接&lt;/h3&gt;
&lt;div&gt;[0] &lt;a href=&quot;https://snarky.ca/the-many-ways-to-pass-code-to-python-from-the-terminal/&quot;&gt;https://snarky.ca/the-many-ways-to-pass-code-to-python-from-the-terminal/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[1] &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=ms-python.python&quot;&gt;https://marketplace.visualstudio.com/items?itemName=ms-python.python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[2] &lt;a href=&quot;https://github.com/microsoft/vscode-python/tree/master/news&quot;&gt;https://github.com/microsoft/vscode-python/tree/master/news&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[3] &lt;a href=&quot;https://pypi.org/project/towncrier&quot;&gt;https://pypi.org/project/towncrier&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[4] &lt;a href=&quot;https://snarky.ca/why-you-should-use-python-m-pip&quot;&gt;https://snarky.ca/why-you-should-use-python-m-pip&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[5] &lt;a href=&quot;https://docs.python.org/3/library/runpy.html#module-runpy&quot;&gt;https://docs.python.org/3/library/runpy.html#module-runpy&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[6] &lt;a href=&quot;https://mp.weixin.qq.com/s/1ehySR5NH2v1U8WIlXflEQ&quot;&gt;https://mp.weixin.qq.com/s/1ehySR5NH2v1U8WIlXflEQ&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[7] &lt;a href=&quot;https://docs.python.org/3/library/zipapp.html#module-zipapp&quot;&gt;https://docs.python.org/3/library/zipapp.html#module-zipapp&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[8] &lt;a href=&quot;https://setuptools.readthedocs.io/en/latest/setuptools.html#setting-the-zip-safe-flag&quot;&gt;https://setuptools.readthedocs.io/en/latest/setuptools.html#setting-the-zip-safe-flag&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[9] &lt;a href=&quot;https://linux.die.net/man/3/dlopen&quot;&gt;https://linux.die.net/man/3/dlopen&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[10] &lt;a href=&quot;https://pypi.org/project/shiv/&quot;&gt;https://pypi.org/project/shiv/&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 为什么没有 main 函数？为什么我不推荐写 main 函数？</title>
            <link>https://pythoncat.top/posts/2020-06-03-main/</link>
            <guid>https://pythoncat.top/posts/2020-06-03-main/</guid>
            <description>一篇引发了较多争议的文章</description>
            <pubDate>Wed, 03 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;毫无疑问 Python 中没有所谓的 main 入口函数，但是网上经常看到一些文章提“Python 的 main 函数”、“建议写 main 函数”……&lt;/div&gt;
&lt;div&gt;有些人是知情的，他的意图可能是模仿那些正宗的 main 函数，但还有不少人明显是被误导了（或自己误解了），就写出来很累赘的代码。&lt;/div&gt;
&lt;div&gt;本期“Python 为什么”栏目来聊聊 &lt;strong&gt;Python 为什么没有 main 函数？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;在开始正题之前，先要来回答这两个问题：&lt;strong&gt;所谓的 “main 函数”是指什么？为什么有些编程语言需要强制写一个 main 函数？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;某些编程语言以 main 函数作为程序的执行入口，例如 C/C++、C#、 Java、Go 和 Rust 等，它们具有特定的含义：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;main 函数名是强制的，也就是要求必须有一个 main 函数&lt;/li&gt;
&lt;li&gt;main 函数最多只能有一个，也就是说程序的入口是唯一的&lt;/li&gt;
&lt;li&gt;语法格式有一定的要求，具有相对固定的模板&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;为什么要强制一个 main 入口函数呢？&lt;/div&gt;
&lt;div&gt;这些语言是编译型语言，需要把代码编译成可执行的二进制文件，为了让操作系统/启动器找到程序的起点，所以要约定这一个函数。简单地说，就是在一大堆代码里，需要定义一个显著的可用于执行的开头。&lt;/div&gt;
&lt;div&gt;不难看出，main 函数是那些语言中重要而不可缺的有机组成部分。&lt;/div&gt;
&lt;div&gt;然而，我们再来看看 Python，情况就大不相同了。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Python 是解释型语言，即脚本语言，运行过程是从上往下，逐行解析运行，也就是说它的起点是可知的&lt;/li&gt;
&lt;li&gt;每个 .py 文件就是一个可执行文件，都可作为整个程序的入口文件，也就是说程序的入口是灵活可变的，没有必须遵守的约定&lt;/li&gt;
&lt;li&gt;有时候运行 Python 项目，并没有指定入口文件（命令行中较常见，例如”python -m http.server 8000”）， 那可能是存在 &lt;code&gt;__main__.py&lt;/code&gt; 文件，它所在的包被当成一个“文件”来执行了&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;归结起来，意思是说 Python 这种脚本语言跟编译型语言不同，它不管是在单个模块层面（即一个 .py 文件），还是在由多个模块组成的包层面，都可选择灵活的执行方式，不像其它语言缺了约定好的入口就没法执行。&lt;/div&gt;
&lt;div&gt;也就是说，Python 没有必要在语法层面规定程序员必须定义出一个统一的入口（不管是函数还是类还是什么东西）。&lt;/div&gt;
&lt;div&gt;有些同学可能会有疑惑，因为他们经常看到或者自己写出下面这样的代码：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# main 里是某些主体代码&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    …… 
 
&lt;span&gt;if&lt;/span&gt; __name__ &lt;span&gt;==&lt;/span&gt; &lt;span&gt;&apos;__main__&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    main&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;难道这不就是 Python 的 main 函数么？相信有不少同学会这么想！&lt;/div&gt;
&lt;div&gt;非也！非也！&lt;/div&gt;
&lt;div&gt;除了函数名是“main”以外，它跟我们前面介绍的正统的 main 函数没有半毛钱关系，既没有强制性，也没有必然决定程序执行顺序的作用。缺少它，也不会导致什么语法问题。&lt;/div&gt;
&lt;div&gt;之所以有些知情人要命名出一个”main“函数，其实是想强调它的”主要“地位，想要人为地安排它作为第一个执行的函数。他们可能认为这样命名的函数，比较容易记忆。&lt;/div&gt;
&lt;div&gt;之所以有些知情人要写&lt;code&gt;if __name__ == &apos;__main__&apos;&lt;/code&gt; ，可能想表明 main() 只有在当前脚本被直接执行时才运行，不希望被导入其它模块时运行。&lt;/div&gt;
&lt;div&gt;对于这些“知情人”，他们有一定的道理。&lt;/div&gt;
&lt;div&gt;但是，我个人并不推荐这种写法，甚至有时候会非常反感！&lt;/div&gt;
&lt;div&gt;最明显的例子：明明只有几十行代码，或者仅有一个脚本文件，实现一个简单的功能（一小段爬虫、用 turtle 画张图等等），但是它们都按前面的样式写了。&lt;/div&gt;
&lt;div&gt;我每次看到这种不假思索的累赘代码，就觉得难受。为什么要写那行 if  语句呢？可能的话，应该拆分 main 函数，甚至不必封装成一个函数啊！&lt;/div&gt;
&lt;div&gt;我个人总结出以下的经验：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;打破惯性思维，写出地道的代码。main 入口函数是某些语言特有的，不该在 Python 中“照猫画虎”，应该了解脚本语言的特点，写出简洁优雅的风格&lt;/li&gt;
&lt;li&gt;使用 main.py 而非 main()。因为 Python 的程序执行单位其实是脚本文件，而非某个函数或者类，所以建议把入口文件命名为 main.py，内部的函数按需求而定&lt;/li&gt;
&lt;li&gt;可以的话，使用&lt;code&gt;__main__.py&lt;/code&gt; 作为入口文件。这个文件结合命令行的“-m”参数使用，非常好用。推荐阅读：&lt;a href=&quot;https://mp.weixin.qq.com/s/co_OAaVQ49rPfgoAh6Pejw&quot;&gt;Python 中 -m 的典型用法、原理解析与发展演变&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;不推荐写&lt;code&gt;if __name__ == &apos;__main__&apos;&lt;/code&gt; 。首先，如果只有一个文件的话，因为不存在导出的可能，不建议写。其次，存在多文件时，入口文件（main.py）中极不推荐写这一句，此文件的代码逻辑应该精炼，理论上其内容不该被导出到其它模块使用，因为它是起点！最后，多文件的非入口文件也不建议写，因为在非入口文件中写这个判断，最大的作用就是写一些测试代码，但是测试代码应该分离出来，写到专门的目录或文件中。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;小结：本文首先解释了什么是 main 入口函数，以及为什么某些语言会强制要求写 main 函数；接着，解释了为什么 Python 不需要写 main 函数；最后则是针对某些人存在的惯性误区，分享了我个人的四点编程经验。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 为什么不用分号作终止符？</title>
            <link>https://pythoncat.top/posts/2020-05-27-semicolons/</link>
            <guid>https://pythoncat.top/posts/2020-05-27-semicolons/</guid>
            <pubDate>Wed, 27 May 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;一般而言，编程语言中使用分号“;”来实现两种目的：&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;作为语句分隔符：使用分号来分隔语句（statement），这样就能在一行代码中书写多条语句（一行多句）&lt;/li&gt;
&lt;li&gt;作为语句终止符：使用分号来终止语句，这样就能把多行代码识别为一条语句（一句多行）&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;单纯看“分隔符”与“终止符”，它们都是必须的，然而是否都要用分号来表示呢？这个问题没有达成一致的标准。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Python 中使用了分号作为语句分隔符，但是不用分号作为终止符， 而是用了换行作为终止符。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;若在一句完整的语句末尾加了分号，然后换行，那么 IDE 一般会提示“Trailing semicolon in the statement”，提示着这个“尾随分号”是多余的。&lt;/div&gt;
&lt;div&gt;按我粗浅的理解，尾随分号实际会被当成分隔符，只不过它后面是“空语句”，然后是换行（即终止符）。分隔空语句是无必要的，所以尾随分号就成了多余的。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Python 不用分号作为终止符，大概有如下的原因：&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;它把缩进和换行当成文法的有效部分，可以表达出完整的语义，不会导致编译时的歧义。这是最主要的原因，是跟“分号党”的根本区别&lt;/li&gt;
&lt;li&gt;不用分号与花括号，但是使用缩进和冒号，这是一脉相承的思路，总体上形成了更高的可读性、简洁性和标准化。这体现了局部语法与整体规则的关系，1 + 1 &amp;gt; 2&lt;/li&gt;
&lt;li&gt;可以少写字符，也避免了在某些键盘上要敲“shift”键的麻烦&lt;/li&gt;
&lt;li&gt;分号主要是给机器看的，但 Python 更注重于人性化。早期硬件有所限制，加分号可以提升解析/编译的速度，但如今障碍已除，某些分号党语言只是在延续 B/C 语言的老传统&lt;/li&gt;
&lt;li&gt;对于需要换行的语句，Python 中使用反斜杠（\）来连接，可以理解成它把换行给转义了，能够解决一句多行的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;最后，本文完整的思维导图，可在 Python猫 公众号回复”0527”领取。&lt;/div&gt;
&lt;h3&gt;关联阅读&lt;/h3&gt;
&lt;div&gt;1、&lt;a href=&quot;https://medium.com/better-programming/a-brief-history-of-the-8efda9dde2b8&quot;&gt;A Brief History of the Semicolon in Programming&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://medium.com/@elizarov/the-end-of-the-semicolon-era-60ab95e669ab&quot;&gt;The End of the Semicolon Era&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://www.ntietz.com/blog/researching-why-we-use-semicolons-as-statement-terminators/&quot;&gt;The origin and virtues of semicolons in programming languages&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 小技巧：如何批量更新已安装的库？</title>
            <link>https://pythoncat.top/posts/2020-05-23-tip/</link>
            <guid>https://pythoncat.top/posts/2020-05-23-tip/</guid>
            <pubDate>Sat, 23 May 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;众所周知，升级某个库（假设为 xxx），可以用&lt;code&gt;pip install --upgrade xxx&lt;/code&gt; 命令，或者简写成&lt;code&gt;pip install -U xxx&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;如果有多个库，可以依次写在 xxx 后面，以空格间隔。那么，如何简单优雅地批量更新系统中全部已安装的库呢？&lt;/div&gt;
&lt;div&gt;接下来我们直奔主题，带大家学习几种方法/骚操作吧！&lt;/div&gt;
&lt;h3&gt;方法一：pip list 结合 Linux 命令&lt;/h3&gt;
&lt;div&gt;&lt;code&gt;pip list&lt;/code&gt; 命令可以查询已安装的库，结合 Linux 的一些命令（cut、sed、awk、grep……），可以直接在命令行中实现批量升级。&lt;/div&gt;
&lt;div&gt;先查询一下，看看是什么格式的：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;可以看到，前两行是一些提示信息，我们需要从第 3 行开始过滤，那就可以使用&lt;code&gt;awk&lt;/code&gt; 命令：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;python3 &lt;span&gt;-m&lt;/span&gt; pip list &lt;span&gt;|&lt;/span&gt; &lt;span&gt;awk&lt;/span&gt; &lt;span&gt;&apos;NR&amp;gt;=3{print}&apos;&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;awk&lt;/span&gt; &lt;span&gt;&apos;{print $1}&apos;&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;xargs&lt;/span&gt; python3 &lt;span&gt;-m&lt;/span&gt; pip &lt;span&gt;install&lt;/span&gt; &lt;span&gt;-U&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;解释一下这句命令的操作过程：先 list 查询，接着第一个 awk 取出行号大于等于 3 的内容，第二个 awk 取出第一列的内容，然后作为参数传给最后的升级命令。&lt;/div&gt;
&lt;div&gt;（PS：测试服务器上有不同版本的 Python，所以作了指定。关于“-m”的用法，推荐阅读：&lt;a href=&quot;https://mp.weixin.qq.com/s/co_OAaVQ49rPfgoAh6Pejw&quot;&gt;Python 中 -m 的典型用法、原理解析与发展演变&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;pip 还支持查询已过期的库，即使用&lt;code&gt;pip list --outdated&lt;/code&gt; 命令。默认情况下，查询出的格式跟&lt;code&gt;pip list&lt;/code&gt; 相似，有效内容从第三行开始，大家可以试试。&lt;/div&gt;
&lt;div&gt;另外，我们还可以指定&lt;code&gt;--format=freeze&lt;/code&gt; 格式，效果是这样的：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这样的格式，可以用 &lt;code&gt;cut&lt;/code&gt; 命令切割“=”号，然后取第一列：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;pip list &lt;span&gt;--outdated&lt;/span&gt; &lt;span&gt;--format&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;freeze &lt;span&gt;|&lt;/span&gt; &lt;span&gt;cut&lt;/span&gt; &lt;span&gt;-d&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;-f&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;xargs&lt;/span&gt; pip &lt;span&gt;install&lt;/span&gt; &lt;span&gt;-U&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;以上命令在 Windows 系统中用不了。有没有更为通用的方法呢？&lt;/div&gt;
&lt;h3&gt;方法二：使用 pip freeze&lt;/h3&gt;
&lt;div&gt;如果是全量升级已安装的库，可以先用&lt;code&gt;pip freeze&lt;/code&gt; 命令生成依赖文件，获取到已安装的库及其当前版本号：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;pip freeze &lt;span&gt;&amp;gt;&lt;/span&gt; requirements&lt;span&gt;.&lt;/span&gt;txt&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;然后修改文件中的“==”为“&amp;gt;=”，接着执行：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;pip install &lt;span&gt;-&lt;/span&gt;r requirements&lt;span&gt;.&lt;/span&gt;txt &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;upgrade&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;此方法比较适合于带有依赖文件的具体项目，可以针对该项目来升级所需的库。&lt;/div&gt;
&lt;h3&gt;方法三：代码中调用 pip 的方法&lt;/h3&gt;
&lt;div&gt;早期的 pip 库（&amp;lt;10.0.1）提供了 get_installed_distributions() 方法查询已安装的库，可以在代码中使用：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 只在早期 pip 版本中用&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; pip
&lt;span&gt;from&lt;/span&gt; subprocess &lt;span&gt;import&lt;/span&gt; call

packages &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;dist&lt;span&gt;.&lt;/span&gt;project_name &lt;span&gt;for&lt;/span&gt; dist &lt;span&gt;in&lt;/span&gt; pip&lt;span&gt;.&lt;/span&gt;get_installed_distributions&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
call&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;pip install --upgrade &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&apos; &apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;join&lt;span&gt;(&lt;/span&gt;packages&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; shell&lt;span&gt;=&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在较新版本中，此方法已被废弃，同样的功能要这样写：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 较新的 pip 版本。但不建议使用&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; subprocess &lt;span&gt;import&lt;/span&gt; call
&lt;span&gt;from&lt;/span&gt; pip&lt;span&gt;.&lt;/span&gt;_internal&lt;span&gt;.&lt;/span&gt;utils&lt;span&gt;.&lt;/span&gt;misc &lt;span&gt;import&lt;/span&gt; get_installed_distributions

&lt;span&gt;for&lt;/span&gt; dist &lt;span&gt;in&lt;/span&gt; get_installed_distributions&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    call&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;pip install --upgrade &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; dist&lt;span&gt;.&lt;/span&gt;project_name&lt;span&gt;,&lt;/span&gt; shell&lt;span&gt;=&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;但是，“_internal”带前缀下划线，表明它并不希望被导出使用。&lt;/div&gt;
&lt;h3&gt;方法四：使用 pkg_resources 库&lt;/h3&gt;
&lt;div&gt;跟方法二和方法三相似的还有一种方法。&lt;/div&gt;
&lt;div&gt;&lt;code&gt;pkg_resources&lt;/code&gt; 是 &lt;code&gt;setuptools&lt;/code&gt; 库的一部分，用于查找和管理 Python 库、版本依赖关系、相关联的资源文件等。可以这样写：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 需要安装 setuptools&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; pkg_resources
&lt;span&gt;from&lt;/span&gt; subprocess &lt;span&gt;import&lt;/span&gt; call

packages &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;dist&lt;span&gt;.&lt;/span&gt;project_name &lt;span&gt;for&lt;/span&gt; dist &lt;span&gt;in&lt;/span&gt; pkg_resources&lt;span&gt;.&lt;/span&gt;working_set&lt;span&gt;]&lt;/span&gt;
call&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;pip install --upgrade &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&apos; &apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;join&lt;span&gt;(&lt;/span&gt;packages&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; shell&lt;span&gt;=&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;方法五：使用 pip-review 库&lt;/h3&gt;
&lt;div&gt;&lt;code&gt;pip-review&lt;/code&gt; 库是一个专门用来方便升级 Python 库的工具，可以查看已过期的库、自动升级或者交互式选择性地升级：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;还有一个类似的&lt;code&gt;pip-upgrader&lt;/code&gt; 库，也是为了解决批量升级的问题，感兴趣的同学请自行搜索。&lt;/div&gt;
&lt;h3&gt;方法六：pip 计划的全量升级命令&lt;/h3&gt;
&lt;div&gt;pip 官方有计划要提供一个全量升级的（upgrade-all）命令，如果开发出来了，那应该会是最佳选择。&lt;/div&gt;
&lt;div&gt;然后，坏消息是这个计划被阻塞了近三年，目前 issue 仍处于 Open 状态，不知道何时能有进展。这里暂且一提吧，未来留意。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;前面介绍了六种方法，各有其适用的场景，小伙伴们都学会了么？&lt;/div&gt;
&lt;div&gt;除此之外，当然还有其它的方法，比如 stackoverflow 网站上有个“&lt;a href=&quot;https://stackoverflow.com/questions/2720014/how-to-upgrade-all-python-packages-with-pip&quot;&gt;How to upgrade all Python packages with pip?&lt;/a&gt;”问题，其下就有比较多的回答。&lt;/div&gt;
&lt;div&gt;感谢阅读，如果你喜欢本文，请搜索关注“Python猫”，阅读更多精彩内容！&lt;a href=&quot;https://mp.weixin.qq.com/s/yOMC1cxcmMDUxYyeB-dtpw&quot;&gt;https://mp.weixin.qq.com/s/yOMC1cxcmMDUxYyeB-dtpw&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 为什么使用缩进来划分代码块？</title>
            <link>https://pythoncat.top/posts/2020-05-10-indentation/</link>
            <guid>https://pythoncat.top/posts/2020-05-10-indentation/</guid>
            <description>Python 为什么使用缩进来划分代码块，而不像其它语言使用花括号 {} 或者 “end” 之类的语法？</description>
            <pubDate>Sun, 10 May 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 为什么使用缩进来划分代码块，而不像其它语言使用花括号 {} 或者 “end” 之类的语法？&lt;/div&gt;
&lt;div&gt;Python 的缩进是一个老生常谈的话题，经常有人会提及它，比如 Python 之父 2020 年 4 月曾在 Twitter 上转发过一篇文章&lt;a href=&quot;https://web.archive.org/web/20070922223915/http://www.secnetix.de/~olli/Python/block_indentation.hawk&quot;&gt;《Python: Myths about Indentation》&lt;/a&gt; 讨论这个话题。&lt;/div&gt;
&lt;div&gt;出处：&lt;a href=&quot;https://twitter.com/gvanrossum/status/1249549091584892928&quot;&gt;Guido 发的 twitter&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;因为这篇文章，Guido 还受邀在 Python Bytes 播客上录制了一期节目：&lt;a href=&quot;https://pythonbytes.fm/episodes/show/179/guido-van-rossum-drops-in-on-python-bytes&quot;&gt;179: Guido van Rossum drops in on Python Bytes&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;可在 Youtube 上观看&lt;a href=&quot;https://www.youtube.com/watch?v=PlvvVXeU0yw&amp;amp;feature=youtu.be&quot;&gt;播客节目的视频版&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;那么，Python 为什么要用缩进来划分代码块呢？&lt;/div&gt;
&lt;div&gt;我收集梳理了几份材料，接下来将带大家一起揭晓 Python 这么做的设计原因：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;缩进语法，更加优雅&lt;/li&gt;
&lt;li&gt;缩进语法，更加清晰&lt;/li&gt;
&lt;li&gt;使用缩进，保持一致性，避免造成误读&lt;/li&gt;
&lt;li&gt;使用缩进，代码更紧凑，便于浏览，没有累赘&lt;/li&gt;
&lt;li&gt;使用缩进，已足够令解释器执行，没必要使用多余的符号&lt;/li&gt;
&lt;li&gt;强制缩进，源自古老的 ABC 语言，Guido 是这门语言的设计者之一&lt;/li&gt;
&lt;li&gt;其思想可能出自 Don Knuth（高德纳，著名计算机科学家，经典巨著《计算机程序设计艺术》的作者），他在 1974 年提出，在当时是很时髦和前卫的思想&lt;/li&gt;
&lt;li&gt;使用缩进，可以终结大括号放在函数名后面还是再换一行的终极争论（据说此话题能令不同派系的程序员大打出手！）&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;以上罗列的原因主要来源于 Python &lt;a href=&quot;https://docs.python.org/3/faq/design.html#why-does-python-use-indentation-for-grouping-of-statements&quot;&gt;官方文档对缩进的解释&lt;/a&gt;、&lt;a href=&quot;https://wiki.python.org/moin/Why%20separate%20sections%20by%20indentation%20instead%20of%20by%20brackets%20or%20%27end%27&quot;&gt;官方早期 wiki 的解释&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;以及 Python 之父的早期访谈：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;问：为什么你在设计 Python 语言的时候采用了强制缩进的方式来划分程序域？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：这种强制缩进，并不是什么新概念。当年我在 CWI 使用 ABC 语言编程的时候，人家就这么干的。我从 ABC 语言中继承了这个概念。不过 occam 这种很古老的语言也是用了这种方式，我不知道他们是谁先采用的，也许都是独创。这种思想也可能出自 Don Knuth（高德纳，著名计算机科学家，经典巨著《计算机程序设计艺术》的作者），他早在 1974 年就提出过这种做法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;总而言之，Python 使用缩进语法，体现了它非常优雅、清晰的设计美学，对开发者、读者以及解释器，都极为友好。&lt;/div&gt;
&lt;div&gt;实话说，我本人非常赞许 Python 的缩进，因此才第一眼就迷上了它，如果是使用了花括号之类的语法，那 Python 就顿时黯淡，也就食之无味了！&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;附注1：《Python 的缩进是不是反人类的设计？》&lt;/h2&gt;
&lt;div&gt;我在中文的技术圈里发了文章后，收到了大量的反对意见，这非常出乎意料，因此又写了下面这篇文章作进一步解释。&lt;/div&gt;
&lt;div&gt;前些天，我写了《&lt;a href=&quot;https://mp.weixin.qq.com/s/byhJnKoKSDnhUNUE9WWopw&quot;&gt;Python为什么使用缩进来划分代码块？&lt;/a&gt;》，文中详细梳理了 Python 采用缩进语法的 8 大原因。我极其喜欢这种简洁优雅的风格，所以对它赞美有加。&lt;/div&gt;
&lt;div&gt;然而文章发出去后，非常意外，竟收到了大量的反对意见！！（以往文章的互动不多，此次创下了记录）&lt;/div&gt;
&lt;div&gt;我就不截图了，先摘录几则最刺眼的评论：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;最大的缺陷就是这个缩进机制&lt;/p&gt;
&lt;p&gt;去掉花括号是最愚蠢的设计&lt;/p&gt;
&lt;p&gt;绝对是过度设计了，缺陷很大&lt;/p&gt;
&lt;p&gt;最大的缺点就是缩进，太反人类了&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;对于这一类的评论，我认为他们是“睁着眼睛说瞎话”，颠倒是非黑白。Python 的缩进语法如此简洁好用，怎么就“过度设计/愚蠢/缺陷/反人类”了？&lt;/div&gt;
&lt;div&gt;常言道众口难调，有人爱甜粽子有人爱咸粽子，但是对于咸甜味道，大家是有所共识的，不至于感官紊乱，大放厥词。&lt;/div&gt;
&lt;div&gt;还有比较多的评论，认为缩进容易造成混乱：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;代码多了，自己看着累，别人更难懂&lt;/p&gt;
&lt;p&gt;眼花了，还是括号好些&lt;/p&gt;
&lt;p&gt;还是{}或end更清晰&lt;/p&gt;
&lt;p&gt;没有花括号老觉得没有安全感&lt;/p&gt;
&lt;p&gt;缩进层次看不清楚&lt;/p&gt;
&lt;p&gt;没有大括号不便于阅读&lt;/p&gt;
&lt;p&gt;层次一多看起来很乱，不知哪层是哪层，要缩多少。到底退出循环没有。&lt;/p&gt;
&lt;p&gt;看着明明缩进是对的，但运行时总是报错&lt;/p&gt;
&lt;p&gt;用python写上十万行试试，到时候你就知道，什么叫混乱看不下去&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;现在主流的 IDE 工具都很强大，应该善于使用其基本功能，例如：设置显示空格字符、设置 tab 自动转化为空格、设置 tab 键为 4 个空格……同一层级的缩进还会有浅浅的竖线，在视觉上辅助阅读。&lt;/div&gt;
&lt;div&gt;至于说层次过多、代码很长的情况，这本身就是一种代码坏味道！当出现过长的函数或者类时，&lt;strong&gt;优秀的程序员&lt;/strong&gt; 第一时间该考虑的就是重构。推荐一本书《重构：改善既有代码的设计》，里面有&lt;strong&gt;正道的价值观和详尽的方法论。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;还有说点击右括号，可以看到匹配的左括号，会清晰。有这东西确实不错，但没有，我并不诉求。本身紧凑简洁的代码，缩进阅读会很快。&lt;/div&gt;
&lt;div&gt;除了以上两大类的评论，我还收到以下几种比较有代表性的评论：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;有人说“取消花括号会大大降低运行速度”、“这个特性鲁棒性太低了”。——这纯粹是臆想，让他们给出论证和例子，无果。别以为在哪里看到有人说 Python 慢，就想当然把锅扣到缩进的头上。&lt;/li&gt;
&lt;li&gt;有人说“多人协同编辑时，有人用tab，有人用空格”。——我说开发团队应该统一规范，然后用 autopep8 之类的辅助工具。他说规范要不停花精力维护，要花成本。拜托！这年头还有人不重视代码规范，直接开除“猿籍”。&lt;/li&gt;
&lt;li&gt;有人说“缩进没办法自动格式化代码”。——这在复制移动代码，或者要改变代码层级时，有此诉求。我一直用比较笨的方法调节（tab、shift+tab、加减空格），确实是比较笨，但是会比较有把握。刚在 PyCharm 里研究了一下，我发现它是支持自动格式化的，只是有个小小的问题要注意！&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;关于缩进的自动格式化，这里有两个例子，给大家演示一下：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;上述例子，删除掉那行 if 条件语句，然后直接”ctrl+alt+l“作全局格式化，格式会出错。我们希望两句 print 向左缩进 4 格，但是 return 那句也会向左缩进。&lt;/div&gt;
&lt;div&gt;在删除 if 那行后，如果我们只选中两行 print，作局部”ctrl+alt+l“格式化，那只有这两行会缩进，就没问题。&lt;/div&gt;
&lt;div&gt;再看第二个例子，我们复制了一段新代码，但是它的缩进不对：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这时候，若直接“ctrl+alt+l”全局格式化，或者选中那三行再格式化，结果都不对！原因是第二个 if 的缩进格数小于 4 个，所以 PyCharm 认为它属于一级缩进（即不该有空格），所以自动格式化时就把它左移了。&lt;/div&gt;
&lt;div&gt;如果选中它们，先按 tab 键右移（即新代码变成缩进大于 4 格，小于 8 格）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;此时再作格式化的话，它们的缩进就跟第一层的 if 一致了（两层 if 是兄弟关系）。&lt;/div&gt;
&lt;div&gt;同理，如果你想把新代码缩进到第一层 if 的内部（变为父子关系），那只需选中上图三行代码再 tab 键右移 4 格，之后格式化就可以了！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;建议大家在编辑器里实操一下。等空了我会录制一期小视频（B 站搜“Python猫”），敬请留意。&lt;/div&gt;
&lt;div&gt;除了上面的评论/观点之外，我们在微信交流群里也讨论了这个话题。@樱雨楼（&lt;a href=&quot;https://github.com/yingyulou&quot;&gt;https://github.com/yingyulou&lt;/a&gt;） 小姐姐的观点对我挺有启发。&lt;/div&gt;
&lt;div&gt;群聊截图已记录&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/tree/master/zh_CN/img/2&quot;&gt;在此&lt;/a&gt;，其中她提到了编程语言在设计上的“比较抽象和哲学”的两点：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;缩进使得代码失去了形式语言里所谓的“上下文无关文法”，从而使得空格+数量的组合变得不再是可有可无的。&lt;/li&gt;
&lt;li&gt;block 作为一个“语法组分”，需要一个定界符，而空格一般不作为语法组分，所以就觉得少了些什么。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;三言两语没法转述清楚，但她谈论缩进话题的视角确实令人耳目一新！&lt;/div&gt;
&lt;div&gt;上次的文章发出后，也有不少小伙伴表示很喜欢 Python 的缩进。我本以为会听到很多这类的声音，没想到却是负面的评论更多。（也许更多认同的声音没有表现出来）&lt;/div&gt;
&lt;div&gt;本文对几类典型的评论作出了回应，再次表达了我在这个话题上的关注和理解（以及情绪的抒发），希望也能给读者们带来一些思考和收获吧。&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;附注2：CSDN 专访 Guido&lt;/h2&gt;
&lt;div&gt;2022 年 9 月，CSDN 的&lt;a href=&quot;https://mp.weixin.qq.com/s/cxuZ5JuTSFYb95MvczNosA&quot;&gt;《程序员》杂志专访 Guido&lt;/a&gt;，又谈到了缩进话题。谈话内容节选：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;邹欣：大家刚接触 Python 这门语言时都会好奇的就是强制的代码缩进。如果重来一次，你是否会放弃缩进这个强制要求？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;Guido：代码缩进（Indentation）其实并不是我发明的，当时的同事给了我启发。在 Python 中要求进行代码缩进的原因是 30 年前的代码编辑器都不能很好地对代码进行缩进排版，所以我就想鼓励程序员自己来对代码进行正确的排版，从而确保程序员从视觉上对代码的理解与编译器对代码的解析是一致的。这其实非常重要，几年前苹果公司就发生过一次非常严重的代码安全漏洞事故，就是由于代码中一个语句与程序员实际设想的 if-else 语法逻辑没有匹配而引起的，如图 1 。其实，严格要求代码缩进确实有点夸张，改用花括号，也不是不可以。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;图1：Apple的SSL/TLS错误&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;附注3：&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo/blob/master/zh_CN/27-the-origins-of-Python-indentation.md&quot;&gt;Python 缩进语法的起源：上世纪 60-70 年代的大胆创意&lt;/a&gt;&lt;/h2&gt;
&lt;div&gt;2022 年 11 月，Guido 在 CWI 时的导师写了一篇《&lt;a href=&quot;https://inference-review.com/article/the-origins-of-python&quot;&gt;The Origins of Python&lt;/a&gt;》，其中谈到了缩进语法的起源问题，因此，我继续挖掘了 Python 缩进语法的设计思想。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>天大福利！世界第一科技出版公司 Springer 免费开放 400 多本电子书！</title>
            <link>https://pythoncat.top/posts/2020-05-02-springer/</link>
            <guid>https://pythoncat.top/posts/2020-05-02-springer/</guid>
            <pubDate>Sat, 02 May 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;前几天，世界著名的科技期刊/图书出版公司施普林格（Springer）宣布：&lt;strong&gt;免费向公众开放 400 多本正版的电子书！！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;Springer 即施普林格出版社，于1842 年在德国柏林创立，20 世纪60年代建立了其国际性科技出版公司的地位。&lt;/div&gt;
&lt;div&gt;目前，施普林格是&lt;strong&gt;全球第一大科技图书出版公司和第二大科技期刊出版公司&lt;/strong&gt;，每年出版 6500 余种科技图书和约 2000 余种科技期刊。施普林格在网络出版方面居于全球领先地位，其 SpringeLink 是全球科技出版市场最受欢迎的电子出版物平台之一。（摘自百度百科）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;为了核实信息源，我在其官网上找到了&lt;a href=&quot;https://www.springernature.com/gp/librarians/news-events/all-news-articles/industry-news-initiatives/free-access-to-textbooks-for-institutions-affected-by-coronaviru/17855960&quot;&gt;这则公告&lt;/a&gt;：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;简单概括：&lt;strong&gt;此次爆发的新冠病毒疫情对教育行业产生了前所未有的影响，所以 Springer 开启了这项全球性的电子资源开放计划，希望对高等教育与医疗机构提供一些有效的帮助！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;开放的资源分三大类（德文紧急护理、英文电子书、德文电子书），官网上给出了相应的 Excel 清单：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;其中，英文电子书清单有 407 本，书单中对每本书都有比较详细的介绍，还附了下载的链接：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这个天大的福利，在外网上大受欢迎（毕竟这些正版电子书每本要几十或上百美元/欧元呢）！&lt;/div&gt;
&lt;div&gt;这么多书籍要下载并不容易，该 Python 爬虫技术登场了！Github 上有个“springer_free_books”项目，作者用他的爬虫下了 409 本，下载花了 4 个小时，下了 14 GB。&lt;/div&gt;
&lt;div&gt;项目地址：&lt;a href=&quot;https://github.com/alexgand/springer_free_books&quot;&gt;https://github.com/alexgand/springer_free_books&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;这么多书，没必要全下。Medium 上有程序员就梳理了 65 本 Python、机器学习、数据分析、计算机视觉、高等数学等领域的书籍。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这份子书单已被共享在 Google Drive 上（全是 PDF 版本）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这份资源对我们会比较有用，涵盖了 Python 编程的多个领域。先下载下来，压缩后有 856 MB。（看不看是一回事，难得的免费资源总想先存一份~~）&lt;/div&gt;
&lt;div&gt;（需要的同学请在公众号【Python猫】后台回复【0502】，获取下载链接）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;最后，不得不提一下，Springer 是一家具有极强社会公德心的企业，除了因疫情而开放的这批资源，它还有很多免费开放的资源（见：&lt;a href=&quot;https://www.springeropen.com/books&quot;&gt;https://www.springeropen.com/books&lt;/a&gt;）。&lt;/div&gt;
&lt;div&gt;甚至包括伟大的物理学家霍金的几篇研究（&lt;a href=&quot;https://www.springer.com/gp/campaigns/physics-journals&quot;&gt;https://www.springer.com/gp/campaigns/physics-journals&lt;/a&gt;）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;好了，福利信息已分享给大家，请按需索取吧。&lt;/div&gt;
&lt;h3&gt;如果觉得有帮助，希望老铁们来个三连击，给更多的人看到这篇文章&lt;/h3&gt;
&lt;div&gt;1、老铁们，我的原创微信公众号「&lt;strong&gt;Python猫&lt;/strong&gt;」，会分享从 Python基础到进阶、Python设计哲学、优质文章翻译、开源项目源码分析等内容，保证你看完有所收获，敬请关注。&lt;/div&gt;
&lt;div&gt;2、给俺点个赞呗，可以让更多的人看到这篇文章，顺便激励下我继续创作和分享，喵喵喵~~~&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 如何移除旧的版本特性，如何迎接新的特性？</title>
            <link>https://pythoncat.top/posts/2020-04-25-old/</link>
            <guid>https://pythoncat.top/posts/2020-04-25-old/</guid>
            <pubDate>Sat, 25 Apr 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;2020 年 4 月 20 日，Python 2 的最后一个版本 2.7.18 发布了，这意味着 Python 2 是真正的 EOL（end of life）了，一个时代终于落幕了。&lt;/div&gt;
&lt;div&gt;Python 2.0 版本是在 2000 年发布的，至今正好到 20 周年（差半年），一代版本竟然持续了这么长时间。其中，2.7 版本是在 Python 3 推出后才发布的，它在 2010 年发布，至今已是 10 年之久。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;事实上，Python 诞生了 30 年，但版本演进过程一直很慢，目前最新发布的版本只到 3.8.2。&lt;/div&gt;
&lt;div&gt;对比一下相差几岁的隔壁家选手，C++ 已经发展到了 20，JAVA 发展到了 14 ，PHP 到了 7.4，差距悬殊。&lt;/div&gt;
&lt;div&gt;但是，版本发布太频繁，也不总是一件好事。就在 Python 程序员抱怨自己的 Python 2 项目还没升 3 版本时，有些 JAVA 程序员还在维护 6、7 版本的项目呢。版本迁移之苦，大家彼此彼此，五十步笑百步。&lt;/div&gt;
&lt;div&gt;编程语言跨版本间出现不兼容的特性，几乎是常态。很多时候，并不是说过去的设计是 bug，只是因为编程语言也是某种“生命体”，它会学习其它语言，也会自我进化，所以就有新陈代谢。&lt;/div&gt;
&lt;div&gt;摆脱旧的不兼容性版本或者某些落后的设计，有时候需要挺漫长的过渡期。为了方便程序员迁移，核心开发者们形成了一些有效的惯例。&lt;/div&gt;
&lt;div&gt;以 Python 为例，我知道有以下的几种策略：&lt;/div&gt;
&lt;h3&gt;1、DeprecationWarning 提示&lt;/h3&gt;
&lt;div&gt;当使用过期的类或方法时，会出现 DeprecationWarning 告警。&lt;/div&gt;
&lt;div&gt;例如，从 collections 模块导入 ABC（Abstract Base Classes，即抽象基类）就是过期用法，会出现以下提示：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;DeprecationWarning: Using or importing the ABCs from ‘collections’ instead of from ‘collections.abc’ is deprecated since Python 3.3, and in 3.9 it will stop working&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;从 3.3 版本起，正确的用法是&lt;code&gt;from collections.abc import Iterable&lt;/code&gt; ，直到 3.9 版本时，会取消过期提示，出现报错。&lt;/div&gt;
&lt;h3&gt;2、将模块改名，约定为私有&lt;/h3&gt;
&lt;div&gt;在 Python 中，以单下划线“_”开头命名的变量，会被约定为私有的。如果在一个模块中定义了私有变量，理论上它就不该被导出到其它模块使用。&lt;/div&gt;
&lt;div&gt;这种命名方式也被推广到了标准模块上。例如，在 Python 的极早期版本中有一个&lt;code&gt;thread&lt;/code&gt; 模块，后来到 1.5.1 版本，以 thread 为基础又推出一个更方便好用的&lt;code&gt;threading&lt;/code&gt; 模块，也就是我们熟知的实现多线程的模块。&lt;/div&gt;
&lt;div&gt;为了摆脱/屏蔽旧的实现，Python 把 thread 模块重命名为&lt;code&gt;_thread&lt;/code&gt; ，约定为私有的，这种方式很灵活，普通程序员不会感知它的存在，骨灰级程序员却可以用它实现更加低层的开发。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h3&gt;3、文档中作 deprecated 提示&lt;/h3&gt;
&lt;div&gt;它跟 DeprecationWarning 是同样的意思。之所以要单独列出来，是因为在构思本文时，我正巧在 Python 3.8 文档中发现了一则提示，忍不住分享一下。&lt;/div&gt;
&lt;div&gt;文档中说： @asyncio.coroutine 装饰器不再支持基于&lt;code&gt;yield from&lt;/code&gt; 生成器实现的协程，需要显式地写成“asyc def”这种定义方式。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这意味着，3.8 版本对该特性来说就是个分界线，它将进入一个平稳的淘汰周期。&lt;/div&gt;
&lt;div&gt;以上三种方式可谓是“除旧”，是面向过去的版本所做的。与它们相对应，就少不了“迎新”的过程，要面向未来的版本。&lt;/div&gt;
&lt;div&gt;Python 中有时候会在当前版本中加入一些实验性的特性，期待在未来版本中再完全地实现。而这，就需要给程序员们指出一些过渡性的提示。&lt;/div&gt;
&lt;div&gt;例如，在《&lt;a href=&quot;https://mp.weixin.qq.com/s/bjQjVmf7dP5fOqCS1cObqQ&quot;&gt;Python 3.9 性能优化：更快的 list()、dict() 和 range() 等内置类型&lt;/a&gt;》一文中，我就介绍了隐藏在 3.8 版本中的“vectorcall”协议，它要在 3.9 版本中才会真正地实现（而且不排除在未来还会继续扩展）。&lt;/div&gt;
&lt;div&gt;此外，还有一个很著名的例子：3.2 版本中推出的 &lt;code&gt;concurrent.futures&lt;/code&gt; 标准库（依据 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3148/&quot;&gt;PEP-3148&lt;/a&gt;）。&lt;/div&gt;
&lt;div&gt;这是一个统合了多线程与多进程的异步开发库，“concurrent”指的是并发，而“并发”概念可以囊括多线程与多进程的实现方式。&lt;/div&gt;
&lt;div&gt;为什么在“concurrent”下面要加一个“futures”呢？PEP-3148 中指出了这样命名的三点原因，其中最后一点是：希望在将来（in the future）能够添加和移动现有的跟并发相关的库到&lt;code&gt;concurrent&lt;/code&gt; 库下面。&lt;/div&gt;
&lt;div&gt;也就是说，3.2 版本的&lt;code&gt;concurrent.futures&lt;/code&gt; 就是一种实验性的设计，它是为将来更好的&lt;code&gt;concurrent&lt;/code&gt; 库而作的准备。虽然说将来的最终实现，可能跟 PEP 中设想的不同，但是，这种面向将来的长远考虑的设计思路，会给整个社区带来某种预期和共同的信念。&lt;/div&gt;
&lt;div&gt;好了，聊了这么多，是时候收个尾了。&lt;/div&gt;
&lt;div&gt;我从未真正开发或维护过 Python 2 的项目，所以在这个本应纪念它 EOL 的日子，所能想到的就是一个更具普遍性的“除旧迎新”的话题：旧的版本特性是如何逐步退出的，新的版本特性又是如何逐步加入的？&lt;/div&gt;
&lt;div&gt;如果你喜欢这种风格的文章，欢迎搜索关注公众号“Python猫”。人生苦短，让我们一起用 Python！&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 3.9 性能优化：更快的 list()、dict() 和 range() 等内置类型</title>
            <link>https://pythoncat.top/posts/2020-04-21-list/</link>
            <guid>https://pythoncat.top/posts/2020-04-21-list/</guid>
            <pubDate>Tue, 21 Apr 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 的 3.9.0 版本正在开发中，计划在 2020-10-05 发布 final 版本。&lt;/div&gt;
&lt;div&gt;官方在 &lt;a href=&quot;https://docs.python.org/3.9/whatsnew/changelog.html&quot;&gt;changelog&lt;/a&gt; 中披露了很多细节，其中有一项“vectorcall”特性是最容易被接受的，本文打算带大家先来一探究竟。&lt;/div&gt;
&lt;div&gt;事实上，早在 Python 3.8 版本中就已部分地实现了 vectorcall，只不过它是暂时性的，被隐藏起来了，按计划是在 3.9 版本中实现完全体。下图是 3.8 版本中的简介：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;那么，什么是 vectorcall 呢？它会带来哪些变化呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;“a fast calling protocol for CPython”，即它是 CPython 的一种快速调用协议，&lt;strong&gt;可以加速 CPython 解释器在调用类对象时的速度。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;（PS：需要注意的是，这里说的“协议”是一种广义的称呼，它跟我们熟知的网络协议或通信协议不同，可理解为对代码作调用时的一种约定、一种实现方式）&lt;/div&gt;
&lt;div&gt;这种协议是在 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0590&quot;&gt;PEP-590&lt;/a&gt; 中被提出的（时间是 2019-03-29），对应的 bpo 是 &lt;a href=&quot;https://bugs.python.org/issue37207&quot;&gt;issue37207&lt;/a&gt;，历时近一年的开发，目前它的实现已合入了代码仓。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;用一句话概括它的核心要点是：&lt;strong&gt;它将提升 list()、tuple()、dict() 等主要类型的调用速度，同时它还可以被用在自定义的类上。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;结合 PEP 与 bpo 信息，我提炼了以下的详细要点：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;vectorcall 是对 fastcall 的正式化。在之前的 CPython 中存在一些零散的优化点（即 fastcall），如今官方把它们系统化了，给出了一个正式的“vectorcall”称呼&lt;/li&gt;
&lt;li&gt;vectorcall 适用于多数内置类型。据当前的披露信息，它适用于 list、tuple、dict、set、frozenset 与 range 这 6 种主要的内置类型（部分测量数据显示，速度提升率达 10%~30%）&lt;/li&gt;
&lt;li&gt;vectorcall 是对性能与灵活性的调和。之前的解释器具有很高的灵活性，但是在对象调用过程中，存在不必要的中间对象以及间接的调用开销，如今是设法消除了这部分开销，得以提升了性能&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;PEP-590 中还详细介绍了 CPython 的实现细节，并罗列了 C API 的变化点，这部分内容就不展开了，感兴趣的同学请自行查阅文档。&lt;/div&gt;
&lt;div&gt;--------猫哥碎碎念分割线--------&lt;/div&gt;
&lt;div&gt;主要的内容就算介绍完了，它很简单，并不难理解，不会带来学习的负担，也不会造成什么意见分歧。&lt;/div&gt;
&lt;div&gt;但是说句老实话，这个性能提升可能显得有点“费力不讨好”：内置类型的调用速度并不会造成什么性能问题（并不慢），而提升空间也仅是纳秒/微秒级别，非常有限。多名核心开发者花费大半年时间和精力，到底值不值得？&lt;/div&gt;
&lt;div&gt;我们恐怕都没有对此作出价值评判的资格。仁者见仁，智者见智。&lt;/div&gt;
&lt;div&gt;但是，也许我们可以往乐观的方面想：对于这种微不足道的性能提升，核心开发者们都能认真对待、精益求精、持续投入、考虑全面，那在其它方面上也绝不会逊色。所以，我们有理由对 Python 的未来保持乐观的希望！&lt;/div&gt;
&lt;div&gt;--------猫哥碎碎念分割线--------&lt;/div&gt;
&lt;div&gt;相关链接：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://docs.python.org/3.9/whatsnew/changelog.html&quot;&gt;https://docs.python.org/3.9/whatsnew/changelog.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-0590&quot;&gt;https://www.python.org/dev/peps/pep-0590&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://bugs.python.org/issue37207&quot;&gt;https://bugs.python.org/issue37207&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>不使用 if-elif 语句，如何优雅地判断某个数字所属的等级？</title>
            <link>https://pythoncat.top/posts/2020-04-19-if/</link>
            <guid>https://pythoncat.top/posts/2020-04-19-if/</guid>
            <pubDate>Sun, 19 Apr 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;偶然看到了 stackoverflow 上的一个问题，还挺有启发，故分享一下。&lt;/div&gt;
&lt;div&gt;题目大意是：有从 A 到 F 的 5 个等级，现要判断某个数值（从 0 到 1 之间）所属的等级。举例，如数值 &amp;gt;= 0.9，则属于 A；若数值 &amp;gt;= 0.8，则属于 B；以此类推。&lt;/div&gt;
&lt;div&gt;若使用 if-elif 语句，可能会写成这样：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; scr &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;0.9&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;A&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;elif&lt;/span&gt; scr &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;0.8&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;B&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;elif&lt;/span&gt; scr &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;0.7&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;C&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;elif&lt;/span&gt; scr &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;0.6&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;D&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;F&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;此写法出现了很多重复的模式，不够简洁优雅。有什么更好的写法，来实现这个目的呢？&lt;/div&gt;
&lt;div&gt;该问题下的回答挺多的，实现思路五花八门。我挑几个可读性比较好：&lt;/div&gt;
&lt;div&gt;方法一：使用&lt;code&gt;bisect&lt;/code&gt; 模块（数字可调）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;方法二：使用 zip() 与 next()&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;方法三：使用字典（仅适用于 Python 3.6 以上的有序字典）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;还有其它几个回答，虽然都能实现数字分级的目的，但是其可读性要差很多，因为它们要么需要你作计算和推理，要么就是引入了额外的变量。&lt;/div&gt;
&lt;div&gt;感兴趣的话，你可在这个地址查看全部答案：&lt;a href=&quot;https://stackoverflow.com/questions/61030617/how-can-i-simplify-repetitive-if-elif-statements&quot;&gt;https://stackoverflow.com/questions/61030617/how-can-i-simplify-repetitive-if-elif-statements&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;纵观全部答案后，我认为还是使用&lt;code&gt;bisect&lt;/code&gt; 的方法最高效优雅，不愧是它获得了最高的赞同票。&lt;/div&gt;
&lt;div&gt;这里简单分析下它的实现过程。&lt;/div&gt;
&lt;div&gt;&lt;code&gt;bisect&lt;/code&gt; 是 Python 内置的标准库，实现了二分查找算法。所谓二分查找，也被称为“折半查找”（Binary Search），其基本思想是把有序排列的 n 个元素平均分成两半，然后将待查找的 x 与中间元素比较，若 x 小于中间元素，则将左半段二分，再将 x 与其中间元素比对，以此类推。&lt;/div&gt;
&lt;div&gt;这是一个简单的图示例子：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;bisect&lt;/code&gt; 库中的 bisect() 方法，&lt;strong&gt;查找元素 x 在一个升序序列中的插入点 i，使得插入点左侧的元素都小于等于 x，插入点右侧的元素都大于 x。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;对照前面的例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; bisect &lt;span&gt;import&lt;/span&gt; bisect 

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;grade&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;score&lt;span&gt;,&lt;/span&gt; breakpoints&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;70&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;90&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; grades&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;FDCBA&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
     i &lt;span&gt;=&lt;/span&gt; bisect&lt;span&gt;(&lt;/span&gt;breakpoints&lt;span&gt;,&lt;/span&gt; score&lt;span&gt;)&lt;/span&gt;
     &lt;span&gt;return&lt;/span&gt; grades&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;可以化简成两部分：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;bisect([60, 70, 80, 90], score)，返回插入点的值。假如 score 是 59，计算得出插入点在 60 的左侧，而 Python 列表的索引值是以 0 开始，所以返回插入点的值为 0；假如 score 是 60，计算得出插入点在 60 的右侧，即返回索引值为 1。&lt;/li&gt;
&lt;li&gt;‘FDCBA’[i]，返回索引值为 i 的字符。假如 i 是 0，得到“F”；假如 i 是 3，得到“B”……&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;二分查找算法是效率较高的算法，时间复杂度为 O(logn)。该题目的查找范围很小，所以时间效率差别不大。但是其写法称得上是 Pythonic，值得借鉴。&lt;/div&gt;
&lt;div&gt;另外，再看看前面的方法三（使用字典），它的可读性很强，即顺次将 scr 与字典中的值比较（从高往低，即 0.9~0.5），以此得出对应的键值。（PS：它多分了一个“E”级，可去掉）&lt;/div&gt;
&lt;div&gt;如果 Python 版本低于 3.6，则 grades.items() 会是无序的，将会破坏比较的顺序。为了兼容性，可以修改成 sorted(grades.items())：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这种写法没有引入额外的库，使用的 items() 与 sorted() 都是基础知识（相比于方法二的 zip() 与 next()），简单实用，也非常值得推荐。&lt;/div&gt;
&lt;div&gt;不管怎么说，反复使用 if-elif 语句的判断方式是挺笨拙的，必须改进。文中列出的都是目前比较受认可的回答。&lt;/div&gt;
&lt;div&gt;如果有面试官把它作为面试题，我觉得会挺有意思：难度不大，有发挥空间。&lt;/div&gt;
&lt;div&gt;读者们可有其它想法？欢迎留言讨论。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>官宣！Python 开发者大会（PyCon US）提供在线订阅啦！</title>
            <link>https://pythoncat.top/posts/2020-04-11-pycon/</link>
            <guid>https://pythoncat.top/posts/2020-04-11-pycon/</guid>
            <pubDate>Sat, 11 Apr 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;2020年一开年，我们就遇到了一个天大的“黑天鹅”事件，如今它已蔓延成为了一个全球性事件，而且似乎还要持续一段挺长的时间。&lt;/div&gt;
&lt;div&gt;各行各业的人们都受到了牵连，各种计划和安排也要被迫作出调整。今年的 PyCon US 原计划于 4 月 15 日在匹茨堡（一座美国城市）举行，受到疫情影响，无奈取消！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;然而，官方很快又发布了新消息，宣布会通过线上方式，来分享录制好的演讲、教程和海报等内容！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;官方给出了以下的订阅通道：&lt;/strong&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;邮件订阅：&lt;a href=&quot;https://us.pycon.org/2020/online/&quot;&gt;https://us.pycon.org/2020/online/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;YouTube订阅：&lt;a href=&quot;https://www.youtube.com/channel/UCMjMBMGt0WJQLeluw6qNJuA&quot;&gt;https://www.youtube.com/channel/UCMjMBMGt0WJQLeluw6qNJuA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Twitter关注：&lt;a href=&quot;https://twitter.com/pycon&quot;&gt;https://twitter.com/pycon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;在两天前，最新的一封邮件披露了线上分享内容的细节：除了常规的资料型内容，还会有虚拟展厅；从 4 月 15 日开始，线上分享会持续一个月！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这应该是前所未有的先例，虽然不是在线直播，但对 Python 开发者/爱好者们来说，已是极大的好消息了！&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;我迫不及待地订阅/关注了！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;也许还有读者不是很了解 PyCon，我给大家稍微科普一下：&lt;/div&gt;
&lt;div&gt;所谓 PyCon，就是在 PSF （Python 软件基金会）授意下，各个国家或地区的开发者们自行组织的一种活动。一般而言，活动每年办一次，持续两三天时间，主体内容是嘉宾们的主题演讲，同时还有闪电开发、闪电演讲、聚餐和展览等丰富的内容。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;PyCon US 指的是美国的 PyCon，它是最早成立、最成熟、最高规格、最高质量的一个，基本上是每年开发者社区里最值得期待的事情。&lt;/div&gt;
&lt;div&gt;当然，世界各地还有不少本土化的 PyCon，比如我国的 PyCon China（大陆）、PyCon HK（香港）和 PyCon TW（台湾）。&lt;/div&gt;
&lt;div&gt;最近两年里，PyCon China 的组委会很给力，举办的活动口碑大涨。2019 年，它在上海、北京、深圳、杭州、成都、南宁六地联动举办，上万名开发者参与其中，呈现出一派蒸蒸日上的局面！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;如果你对国内 PyCon 感兴趣的话，可以关注 PyChina 公众号（id：&lt;strong&gt;PyChinaOrg&lt;/strong&gt; ），另外，&lt;strong&gt;捕蛇者说（目前最好的中文 Python 播客）&lt;/strong&gt; 在去年出了一期《主播带你逛 PyCon》（&lt;a href=&quot;https://pythonhunter.org/episodes/4&quot;&gt;https://pythonhunter.org/episodes/4&lt;/a&gt;）节目，推荐一听。&lt;/div&gt;
&lt;div&gt;现在距离 PyCon US 2020 活动开始的时间，只有不到一周了。官方之前发布过一份日程表，列出了 30+ 主题演讲的题目与嘉宾，很值得期待！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;最后来个结尾：人生苦短，我用 Python！&lt;/div&gt;
&lt;div&gt;原文地址：&lt;a href=&quot;https://mp.weixin.qq.com/s/cyR-XWN9bURjb_5cwhSzMw&quot;&gt;https://mp.weixin.qq.com/s/cyR-XWN9bURjb_5cwhSzMw&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>学编程这么久，还傻傻分不清什么是方法（method），什么是函数（function）？</title>
            <link>https://pythoncat.top/posts/2020-04-09-function/</link>
            <guid>https://pythoncat.top/posts/2020-04-09-function/</guid>
            <pubDate>Thu, 09 Apr 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在编程语言中有两个很基础的概念，即方法（method）和函数（function）。如果达到了编程初级/入门级水平，那么你肯定在心中已有了初步的答案。&lt;/div&gt;
&lt;div&gt;也许在你心中已有答案了&lt;/div&gt;
&lt;div&gt;除去入参、返回值、匿名函数之类的正确的形式内容之外，你也许会说“函数就是定义在类外面的，而方法就是定义在类里面的，跟类绑定的”。&lt;/div&gt;
&lt;div&gt;这种说法有没有问题呢？当然有！不然我就不会专门写这篇文章了，本文主要会来厘清这个问题。&lt;/div&gt;
&lt;div&gt;在标准库&lt;code&gt;inspect&lt;/code&gt; 中，它提供了两个自省的函数，即 ismethod() 和 isfunction()，可以用来判断什么是方法，什么是函数。&lt;/div&gt;
&lt;div&gt;因此，本文想要先来研究一下这两个函数，看看 Python 在处理方法/函数的概念时，是怎么做的？&lt;/div&gt;
&lt;div&gt;关于它们的用法，先看一个最简单的例子：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;运行的结果分别是“True”和“False”，表明我们所定义的 test() 是一个函数，而不是一个方法。&lt;/div&gt;
&lt;div&gt;这两个函数也可以用来检测自身，不难验证出它们都是一种函数：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;那么，接下来的问题是：&lt;strong&gt;inspect 库的两个函数是什么工作原理呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;先来看看 inspect 中的实现代码：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;在源码中，我们看到了 isinstance() 函数，它主要用于判断一个对象（object）是否是某个类（class）的实例（instance）。&lt;/div&gt;
&lt;div&gt;我们还看到了 &lt;code&gt;types.FunctionType&lt;/code&gt; 及&lt;code&gt;types.MethodType&lt;/code&gt; ，它们指的就是目标类。继续点进去看源码：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 摘自 types.py&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;_f&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;pass&lt;/span&gt;
FunctionType &lt;span&gt;=&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;_f&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; &lt;span&gt;_C&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;_m&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;pass&lt;/span&gt;
MethodType &lt;span&gt;=&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;_C&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;_m&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这里只是定义了两个空的 _f() 和 _m()，然后就使用了内置的 type() 函数。所以，我们完全可以把它们摘出来，看看庐山真面目：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;梳理它们的关系，可以得到：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;经过简化处理后，我们发现最关键的是两个问题：&lt;strong&gt;type() 函数如何判断出一个对象是 function 或 method 类？instance() 函数如何判断出一个对象是某个类的实例？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;这两个内置函数都是用 C 语言实现的，这里我就不打算继续深究了……&lt;/div&gt;
&lt;div&gt;但是，让我们再回头看看 inspect 中的注释，就会注意到一些端倪：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;isfunction() 判断出的是&lt;strong&gt;用户定义的函数（user-defined function），&lt;/strong&gt; 它拥有__doc__、__name__ 等等属性&lt;/li&gt;
&lt;li&gt;ismethod() 判断出的是&lt;strong&gt;实例方法（instance method），&lt;/strong&gt; 它拥有函数的一些属性，最特别的是还有一个 __self__ 属性&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;还是注释更管用啊，由此我们能得到如下的推论：&lt;/div&gt;
&lt;div&gt;1、非用户定义的函数，即内置函数，在 isfunction() 眼里并不是“函数”（FunctionType）！&lt;/div&gt;
&lt;div&gt;下面验证一下 len()、dir() 和 range()：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;事实上，它们有专属的类别（BuiltinFunctionType、BuiltinMethodType）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;特别需要注意的是，内置函数都是&lt;code&gt;builtin_function_or_method&lt;/code&gt; 类型，但是 range()、type()、list() 等看起来像是函数的，其实不然：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;（PS：关于这点，&lt;a href=&quot;https://mp.weixin.qq.com/s/cCWfbHeptEUKtI19GIxF8A&quot;&gt;我这篇文章&lt;/a&gt; 曾提到过，就不再展开了。）&lt;/div&gt;
&lt;div&gt;2、一个类的静态方法，在 ismethod() 眼里并不是方法（MethodType）！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;创建了类的实例后，再看看：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;可以看出，除了 classmethod 之外，只有类实例的实例方法，才会被 ismethod() 判定为真！而静态方法，不管绑定在类还是实例上，都不算是“方法”！&lt;/div&gt;
&lt;div&gt;有没有觉得很不可思议（或者有点理不清了）？&lt;/div&gt;
&lt;div&gt;好了，回到本文开头的问题，我们最后来小结一下吧。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;若以 inspect 库的两个函数为判断依据，则 Python 中的“方法与函数”具有一定的狭义性。在判断什么是函数时，它们并不把内置函数计算在内。同时，在判断什么是方法时，并非定义在类内部的都算，而是只有类方法及绑定了实例的实例方法才算是“方法”。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;也许你会说，inspect 的两个判断函数并不足信，内置函数也应该算是“函数”，类里面的所有方法都应该算是“方法”。&lt;/div&gt;
&lt;div&gt;我承认这种说法在广义上是可接受的，毕竟我们一直叫的就是“XX函数”、“XX方法”嘛。&lt;/div&gt;
&lt;div&gt;但是，理论和广义概念只是方便人们的沟通理解，而代码实现才是本质的区别。也就是说，Python 在实际区别“方法与函数”时，并不是文中开头的简单说法，还有更多的细节值得关注。&lt;/div&gt;
&lt;div&gt;看完本文，你有什么想法呢？欢迎一起交流。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 3.9 新特性：任意表达式可作为装饰器！</title>
            <link>https://pythoncat.top/posts/2020-03-20-PEP/</link>
            <guid>https://pythoncat.top/posts/2020-03-20-PEP/</guid>
            <pubDate>Fri, 20 Mar 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;一个月前（2月20日），一则新的 PEP 没有受到任何阻碍就被官方采纳了，这么快的速度，似乎并不多见。&lt;/div&gt;
&lt;div&gt;然而，更为高效率的是，仅在半个月内，它的实现就被合入了代码仓。也就是说，我们最快有望在 3 天后（3月23日）发布的 3.9.0 alpha 5 版本中看到它！&lt;/div&gt;
&lt;div&gt;Python 3.9 的发布计划：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这个 PEP 就是 &lt;strong&gt;PEP-614：放宽对装饰器的语法限制。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;当前装饰器的语法为：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;decorator&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;@&apos;&lt;/span&gt; dotted_name &lt;span&gt;[&lt;/span&gt; &lt;span&gt;&apos;(&apos;&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;arglist&lt;span&gt;]&lt;/span&gt; &lt;span&gt;&apos;)&apos;&lt;/span&gt; &lt;span&gt;]&lt;/span&gt; NEWLINE&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;PEP-614 提议将其简化为：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;decorator&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;@&apos;&lt;/span&gt; namedexpr_test NEWLINE&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我已经把 PEP 全文翻译出来了，Github 地址：&lt;a href=&quot;http://dwz.date/RV9&quot;&gt;http://dwz.date/RV9&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;放宽对装饰器的限制，这对之前的用法没有影响，但至于会带来哪些新的好处，我还不知道有哪些现实的例子。&lt;/div&gt;
&lt;div&gt;下面是 PEP 翻译后的核心内容摘录，先跟大家一睹为快吧：&lt;/div&gt;
&lt;div&gt;--------------摘录分割线----------------&lt;/div&gt;
&lt;h3&gt;概要&lt;/h3&gt;
&lt;div&gt;Python 当前要求所有装饰器都由 dotted name 组成，可选地带一个调用。本 PEP 提议消除这些限制，并允许任何有效的表达式作为装饰器。&lt;/div&gt;
&lt;div&gt;（译注：dotted name，指的是装饰器在“@”符号后是“xxx”或“xxx.yyy”这种格式。没有很好地译法，故未译。）&lt;/div&gt;
&lt;h3&gt;动机&lt;/h3&gt;
&lt;div&gt;在最初引入装饰器时，&lt;a href=&quot;https://mail.python.org/archives/list/python-dev%40python.org/message/P3JD24UFFPZUUDANOAI6GZAPIGY4CVK7&quot;&gt;Guido表示&lt;/a&gt;对其语法作限制是一种偏好，而不是因为技术的要求：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;我对此有一种直觉。我不确定它来自哪里，但我就是有……因此，尽管将来将语法更改为 @test 相当容易，但我仍想坚持使用更受限的形式，除非给出了真正的使用 @test 会增加可读性的用例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;尽管在实践中很少遇到问题，但是多年来，&lt;a href=&quot;https://bugs.python.org/issue19660&quot;&gt;BPO问题&lt;/a&gt;和&lt;a href=&quot;https://mail.python.org/archives/list/python-ideas%40python.org/thread/UQOCJH3KOPBP7P3AVNS3OYBGZPR3V2WO/%23CAOXYF4GV76AFJNCYSYMQTBM7CIPPH5M#CAOXYF4GV76AFJNCYSYMQTBM7CIPPH5M&quot;&gt;邮件列表帖子&lt;/a&gt;不断出现，要求去除限制。&lt;a href=&quot;https://mail.python.org/archives/list/python-ideas%40python.org/thread/WOWD4P323DYDIGUQVWMESDWUG6QOW4MP&quot;&gt;最近的一封邮件&lt;/a&gt;（它&lt;a href=&quot;https://mail.python.org/archives/list/python-ideas%40python.org/message/FKE7ZFGUDCU5WVOE2QTD5XGMCNCOMETV&quot;&gt;促成了本提案&lt;/a&gt;）提供了一段很好的使用 &lt;code&gt;PyQt5&lt;/code&gt; 库的示例代码，如果放宽现有的限制，它将变得更具可读性、地道性和可维护性。&lt;/div&gt;
&lt;div&gt;稍作修改的示例：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;buttons &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;QPushButton&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&apos;Button &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;i&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&apos;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;# Do stuff with the list of buttons...&lt;/span&gt;

&lt;span&gt;@buttons&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;clicked&lt;span&gt;.&lt;/span&gt;connect
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;spam&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

&lt;span&gt;@buttons&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;clicked&lt;span&gt;.&lt;/span&gt;connect
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;eggs&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

&lt;span&gt;# Do stuff with the list of buttons...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;当前，这些装饰必须重写成这样（译注：上方是假想的最优写法，但 Python 还不支持，只能用下方的啰嗦写法）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;button_0 &lt;span&gt;=&lt;/span&gt; buttons&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;@button_0&lt;span&gt;.&lt;/span&gt;clicked&lt;span&gt;.&lt;/span&gt;connect&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;spam&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

button_1 &lt;span&gt;=&lt;/span&gt; buttons&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;@button_1&lt;span&gt;.&lt;/span&gt;clicked&lt;span&gt;.&lt;/span&gt;connect&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;eggs&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;此外，当前的语法太过宽松，以至于无法将更复杂的装饰器表达式结合在一起。也就是说，当前的限制并没有像预期的那样去禁止任意复杂的表达式，而是使它们变得更丑陋且效率低下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# Identity function hack:&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; x

&lt;span&gt;@_&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;buttons&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;clicked&lt;span&gt;.&lt;/span&gt;connect&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;spam&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

&lt;span&gt;# eval hack:&lt;/span&gt;

&lt;span&gt;@eval&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;buttons[1].clicked.connect&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;eggs&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;原理&lt;/h3&gt;
&lt;h4&gt;允许任意表达式&lt;/h4&gt;
&lt;div&gt;在相当长的一段时间内，允许任意有效表达式的决定（而不仅仅是放宽当前的限制，如允许取下标），已被视为装饰器语法发展的下一个顺理成章的步骤。正如&lt;a href=&quot;https://mail.python.org/archives/list/python-ideas%40python.org/message/CAOXYF4GV76AFJNCYSYMQTBM7CIPPH5M&quot;&gt;Guido 在另一个邮件列表讨论中所说&lt;/a&gt;：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;我觉得强制约束它没有什么道理，因为它已不再是一个普通的表达式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;若对语法进行特殊设置以允许某些有用的用法，只会使当前情况复杂化，并且几乎能肯定此过程会在将来的某个时间重复。此外，这种语法上的改变的目的之一是阻止使用上述的 eval 和反模式的  identity-function 之类的诱惑。&lt;/div&gt;
&lt;div&gt;简而言之：如果要删除一些限制，我们应该删除所有限制。&lt;/div&gt;
&lt;h4&gt;什么算一个“表达式”&lt;/h4&gt;
&lt;div&gt;在本文档中，“表达式”一词的用法与《&lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html%23grammar-token-expression#grammar-token-expression&quot;&gt;Python语言参考&lt;/a&gt;》中定义的相同。可以概括为“任何在 if、elif 和 while 块中测试为有效的内容”。&lt;/div&gt;
&lt;div&gt;这与可能更流行的&lt;a href=&quot;https://docs.python.org/3/glossary.html%23term-expression#term-expression&quot;&gt;定义&lt;/a&gt;稍有不同，后者可以概括为“任何作为有效字符串输入给 eval 的内容”。&lt;/div&gt;
&lt;div&gt;前一个“表达式”的定义更方便，因为它非常贴合我们的需求，并且可以重用被现有语言结构所允许的语法。与其它定义相比，它有两个细微的差异：&lt;/div&gt;
&lt;h5&gt;1、元组必须加括号&lt;/h5&gt;
&lt;div&gt;这是基于 Guido 在同一封邮件中的洞察。紧接着前面的引述：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;但是我不会允许逗号，决不可能赞成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span&gt;@f&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; g
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;pooh&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;div&gt;确实，它可能甚至导致没有经验的读者得出结论，认为正在使用多个装饰器，就像它们被堆叠了一样。这里要求加括号，可以使意图变得清晰，而无需施加进一步的限制和复杂语法。&lt;/div&gt;
&lt;h5&gt;2、赋值表达式不需括号&lt;/h5&gt;
&lt;div&gt;在这里，语法的选择是明确的。&lt;a href=&quot;https://www.python.org/dev/peps/pep-0572&quot;&gt;PEP 572&lt;/a&gt;解释了为什么需要在顶级表达式语句的周围加上括号：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;加入此规则是为了简化用户在赋值语句和赋值表达式之间的选择——没有令两者都生效的语法位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;由于赋值语句在此处无效，因此赋值表达式就不必带括号。&lt;/div&gt;
&lt;div&gt;（译注：赋值表达式，即 Assignment Expressions 或 Named Expressions，是 Python 3.8 引入的新特性，就是它引入了新的“:=”海象操作符。）&lt;/div&gt;
&lt;div&gt;-----------------正文分割线---------------&lt;/div&gt;
&lt;div&gt;PEP 的全文翻译已收录在 Github 的《&lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;PEP中文翻译计划&lt;/a&gt;》中，目前已有 20+ 篇 PEP 翻译，欢迎感兴趣的同学查阅&amp;amp;参与翻译。&lt;/div&gt;
&lt;div&gt;附录：&lt;/div&gt;
&lt;div&gt;PEP614英文：&lt;a href=&quot;https://www.python.org/dev/peps/pep-0614/&quot;&gt;https://www.python.org/dev/peps/pep-0614/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PEP614中文：&lt;a href=&quot;http://dwz.date/RV9&quot;&gt;http://dwz.date/RV9&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PEP中文翻译计划：&lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;https://github.com/chinesehuazhou/peps-cn&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 小技巧：如何实现操作系统兼容性打包？</title>
            <link>https://pythoncat.top/posts/2020-03-17-tip/</link>
            <guid>https://pythoncat.top/posts/2020-03-17-tip/</guid>
            <pubDate>Tue, 17 Mar 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;有一个这样的问题：现要用 setuptools 把一个项目打包成 whl 文件，然后 pip install 在 Windows/Linux 两种操作系统上，但是该项目中有一些依赖库只有 Windows 上才有（例如 pywinauto、pywingui、pywinrm），那么问题是，如何实现打包文件的可兼容性安装？&lt;/div&gt;
&lt;div&gt;从打包的角度，这个问题的关键还是看 setup.py 和 requirements.txt 文件。&lt;/div&gt;
&lt;div&gt;关于 Python 的包构建分发和 setup.py 的使用，这里&lt;a href=&quot;https://mp.weixin.qq.com/s/mAoaIe_Sg3Vk2Sk_xZeI-w&quot;&gt;有篇文章&lt;/a&gt; 写得很好，推荐阅读。另外关于 Python 依赖库的管理（requirements.txt），&lt;a href=&quot;https://mp.weixin.qq.com/s/bdeUDLihiuwZVmmquRYEug&quot;&gt;这篇文章&lt;/a&gt; 详细比较了 pip、pipreqs、pigar、pip-tools 和 pipdeptree 等工具，也推荐一读。&lt;/div&gt;
&lt;div&gt;有一个比较笨的实现方法：维护两份 requirements.txt 文件，分别用来打包，然后分发给不同操作系统去使用。&lt;/div&gt;
&lt;div&gt;但是这样会有麻烦：维护两份依赖文件和两种包文件，本身就挺费劲的，而在生成过程中，每次还得对它们改名以作区分（注意包名有一定的规范约束，乱改的话，pip 可能识别不出），维护成本就很高。&lt;/div&gt;
&lt;div&gt;其实，维护软件包在不同操作系统的版本，并不少见。如果你曾留意过不同版本 Python 库文件的话，你会注意到很多库都会按不同操作系统而分发不同的版本。例如，下面是同一版本号的 Numpy 在不同操作系统上的分发版（&lt;a href=&quot;https://pypi.org/simple/numpy/&quot;&gt;https://pypi.org/simple/numpy/&lt;/a&gt;）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;可以看出它根据 macos、linux 和 win 三类操作系统及其位数，分成了 5 个版本。维护这么多版本，肯定是一件麻烦事，但是出现了这样的结果，就意味着 Numpy 官方认为分发不同系统版本是利大于弊的，而且是有办法实现的。&lt;/div&gt;
&lt;div&gt;回到我们的问题，是否有必要像 Numpy 那样设法打包成多个操作系统定制的包呢？&lt;/div&gt;
&lt;div&gt;答案是否定的。主要的原因：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Numpy 这么做是因为它是做科学计算的，为了提升效率，它把编译好的 C 拓展文件打包，从而不需要依赖环境上的 libxxx-devel 之类的库。如果你编译安装过 Python，应该有印象需要安装 zlib-devel、openssl-devel 和 libffi-devel 之类的系统依赖。但我们前面的问题比较简单，并不是有不同的编译依赖（系统级），而只是三方库依赖不同（项目级）。&lt;/li&gt;
&lt;li&gt;另一个主要的原因，Numpy 打包出的不同系统版本，并非简简单单地用 setuptools 之类的 Python 库就能打包，而是要借助标准的镜像进行构建。例如，manylinux 版本的打包，参见 Github（&lt;a href=&quot;https://github.com/pypa/manylinux&quot;&gt;https://github.com/pypa/manylinux&lt;/a&gt;），就需要使用官方提供的 Docker 镜像。对于我们的问题，显然不想做到这么麻烦。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;简而言之，根据前面的分析，如果要实现操作系统兼容的打包，维护多份依赖文件、使用不同构建包的方法、维护多系统专用的包，方法可行，但并不是很适用。&lt;/div&gt;
&lt;div&gt;如果没有新的办法，这不失为一种考虑，但是有没有别的办法了呢？&lt;/div&gt;
&lt;div&gt;我曾被这个问题困扰过，但是没有深入去研究解决，直到无意中在&lt;code&gt;loguru&lt;/code&gt; 这个用来记录日志的库的 setup.py 中看到：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;再翻看大名鼎鼎的&lt;code&gt;requests&lt;/code&gt; 库文件，发现还可以这样写：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;两个示例都是写在 setup.py 文件中，其实如果我们用 requirements.txt 文件，也可以按这种格式写，然后再读取进来。&lt;/div&gt;
&lt;div&gt;这种神奇的写法是怎么回事呢？&lt;/div&gt;
&lt;div&gt;它的依据是 2015 年 11 月创建的 PEP-508（以及相关的但已被撤销或拒绝了的 PEP-390、PEP-426、PEP-459、PEP-496），该 PEP 的主要意图是增强 pip 等工具查找软件包的能力。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;比较重要的部分就是跟我们的问题相关的，即对操作系统作区分的标识，相关的有：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;有了这样的扩展支持，在打包依赖项时，就可以解决兼容性问题了。&lt;/div&gt;
&lt;div&gt;例如 colorama 库，如果我们只在 win32 系统才需要依赖，那么在打包时就可以指定：“colorama&amp;gt;=0.3.4 ; sys_platform==‘win32’ ”；如果不需要限定 win32 系统，而是在 windows 环境都安装，那么可以写成“colorama&amp;gt;=0.3.4 ; platform_system==‘Windows’ ”。&lt;/div&gt;
&lt;div&gt;最终，我们解决了本文开头的问题。这个问题可能比较小众，解决起来也没有什么大文章可做，算是一个小小的 tips 分享给大家吧。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Fabric 源码学习：如何实现批量管理远程服务器？</title>
            <link>https://pythoncat.top/posts/2020-03-14-fabric/</link>
            <guid>https://pythoncat.top/posts/2020-03-14-fabric/</guid>
            <pubDate>Sat, 14 Mar 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;前不久，我写了一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/UHtPaxO2ojql5ps4hTn3Vg&quot;&gt;Fabric教程&lt;/a&gt;》，简单来说，它是一个用 Python 开发的轻量级的远程系统管理工具，在远程登录服务器、执行 Shell 命令、批量管理服务器、远程部署等场景中，十分好用。&lt;/div&gt;
&lt;div&gt;Fabric 2 是其最新的大版本，跟早前的 Fabric 1 有挺大的不同，更加好用了，但是没填上的坑也挺多的……&lt;/div&gt;
&lt;div&gt;本文继续来聊聊 Fabric，不过我不想再面面俱到了，而是专注于这一个话题：&lt;strong&gt;它是如何实现对批量服务器的串行/并发管理的？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;（友情提示：为了有更好的阅读体验，如果你还不了解 Fabric 的基础用法，建议先阅读前面的教程。）&lt;/div&gt;
&lt;div&gt;Fabric 通过 Group 来组合多台服务器。区别在于由 fabric.group.Group 基类（父类）派生出的两个子类：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;SerialGroup(*hosts, **kwargs)：按串行方式执行操作&lt;/li&gt;
&lt;li&gt;ThreadingGroup(*hosts, **kwargs)：按并发方式执行操作&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;下面先看看这个基类：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;我把一些没用的信息折叠了，比较值得注意的内容有：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Group 继承了 list，所以能够 extend() ，对传入的服务器分别建立 connection&lt;/li&gt;
&lt;li&gt;核心的 run() 方法没有写实现，用意是留给子类再实现&lt;/li&gt;
&lt;li&gt;最后的 __enter__() 和 __exit__() 实现了上下文管理器&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;有了这个基类，接下来就要看 SerialGroup 和 ThreadingGroup 的具体实现了。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;SerialGroup 类很简单，只实现了一个 run() 方法。因为类在初始化时为所有 host 建立了连接而且存了起来，所以这里只需用 for 循环依次取出，再执行 Connection 的 run() 方法。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;这里可以看到一种非常实用的开发技巧：&lt;/strong&gt; 创建类时，让它继承内置的数据结构（如 list、dict）， 这样可以直接使用  self.append()、self.extend()、self.update() 等方法把关键的信息存到“自身”，再到取出时则“for xxx in self”，这样就免了创建临时的 list 或 dict，也免得要在参数中传来传去。&lt;/div&gt;
&lt;div&gt;GroupResult 和 GroupException 是对执行结果和异常的处理，不是我们关注的重点，这里略过。&lt;/div&gt;
&lt;div&gt;接下来看看 ThreadingGroup，它也只有一个 run() 方法：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;ExceptionHandlingThread 是一个继承了 threading.Thread 的类，这是一种创建多线程的方式。每个线程执行的方法主要做两件事：执行 connection 的 run() 方法，以及将执行成功的结果存入队列中。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;接下来再分别把执行成功的结果与出异常的结果都存入到 results 中。&lt;/div&gt;
&lt;div&gt;所以，Fabric 是使用了 threading 多线程的方式来实现并发。网络请求是 IO 密集型的，使用多线程是不错的方式。&lt;/div&gt;
&lt;div&gt;至此，对于我们在开头提的问题，就有了一个初步的答案：Fabric 封装了两种 Group 来批量管理服务器，其中串行方式就是用了简单的 for 循环，而并发方式使用了 threading 多线程方式。&lt;/div&gt;
&lt;div&gt;但是，通过分析这两种 Group 的实现代码（以及使用的实践），我们也可以发现 Fabric 的缺陷：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Group 只实现了 run() 方法，但是 Connection 的 put()、get()、sudo() 等方法都没有，这意味着用这种方式管理服务器集群时，只能在上面执行 shell 命令……&lt;/li&gt;
&lt;li&gt;每次调用 run() 方法时，它要等所有主机都执行完，才会返回结果，这意味着先执行完的主机会被阻塞。更为致命的是，如果其中一台主机执行时出了异常，整个 run() 方法就抛异常，这意味着每次使用 run() 方法时，都需要作异常捕获&lt;/li&gt;
&lt;li&gt;run() 方法支持执行单条 shell 命令，但是命令的状态不会传递。假设先在一个 run() 方法中运行 cd 命令切到 A 目录（非根目录），再在下一个 run() 方法创建一个文件，最终结果是该文件并不在 A 目录，而是在默认目录。解决办法是用“&amp;amp;&amp;amp;”连接起多条命令，略显麻烦&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;这几个问题在 Fabric 的 Github issue 中，被不同的人反复提出，但是还没有得到很好的回应……&lt;/div&gt;
&lt;div&gt;言归正传，本文主要分析了 Fabric 在批量管理服务器时的实现方案，阅读其源码，可以了解到串行/并发典型场景的用法，以及类定义、类继承、多线程、异常处理等内容，最后，我们还揭示出了它的几个特性缺陷。&lt;/div&gt;
&lt;div&gt;感谢阅读。最后，附上 Fabric 教程：&lt;a href=&quot;https://mp.weixin.qq.com/s/UHtPaxO2ojql5ps4hTn3Vg&quot;&gt;https://mp.weixin.qq.com/s/UHtPaxO2ojql5ps4hTn3Vg&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 在计算内存时应该注意的问题？</title>
            <link>https://pythoncat.top/posts/2020-03-02-size/</link>
            <guid>https://pythoncat.top/posts/2020-03-02-size/</guid>
            <pubDate>Mon, 02 Mar 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;我之前的&lt;a href=&quot;https://mp.weixin.qq.com/s/8f259oIGCQtY6KFSx4KW6Q&quot;&gt;一篇文章&lt;/a&gt;，带大家揭晓了 Python 在给内置对象分配内存时的 5 个奇怪而有趣的小秘密。文中使用了&lt;code&gt;sys.getsizeof()&lt;/code&gt;来计算内存，但是用这个方法计算时，可能会出现意料不到的问题。&lt;/div&gt;
&lt;div&gt;文档中关于这个方法的介绍有两层意思：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;该方法用于获取一个对象的字节大小（bytes）&lt;/li&gt;
&lt;li&gt;它只计算直接占用的内存，而不计算对象内所引用对象的内存&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;也就是说，getsizeof() 并不是计算实际对象的字节大小，而是计算“占位对象”的大小。如果你想计算所有属性以及属性的属性的大小，getsizeof() 只会停留在第一层，这对于存在引用的对象，计算时就不准确。&lt;/div&gt;
&lt;div&gt;例如列表 [1,2]，getsizeof() 不会把列表内两个元素的实际大小算上，而只是计算了对它们的引用。&lt;/div&gt;
&lt;div&gt;举一个形象的例子，我们把列表想象成一个箱子，把它存储的对象想象成一个个球，现在箱子里有两张纸条，写上了球 1 和球 2 的地址（球不在箱子里），getsizeof() 只是把整个箱子称重（含纸条），而没有根据纸条上地址，找到两个球一起称重。&lt;/div&gt;
&lt;h2&gt;1、计算的是什么？&lt;/h2&gt;
&lt;div&gt;我们先来看看列表对象的情况：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;如图所示，单独计算 a 和 b 列表的结果是 36 和 48，然后把它们作为 c 列表的子元素时，该列表的计算结果却仅仅才 36。（PS：我用的是 32 位解释器）&lt;/div&gt;
&lt;div&gt;如果不使用引用方式，而是直接把子列表写进去，例如 “d = [[1,2],[1,2,3,4,5]]”，这样计算 d 列表的结果也还是 36，因为子列表是独立的对象，在 d 列表中存储的是它们的 id。&lt;/div&gt;
&lt;div&gt;也就是说：getsizeof() 方法在计算列表大小时，其结果跟元素个数相关，但跟元素本身的大小无关。&lt;/div&gt;
&lt;div&gt;下面再看看字典的例子：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;明显可以看出，三个字典实际占用的全部内存不可能相等，但是 getsizeof() 方法给出的结果却相同，这意味着它只关心键的数量，而不关心实际的键值对是什么内容，情况跟列表相似。&lt;/div&gt;
&lt;h2&gt;2、“浅计算”与其它问题&lt;/h2&gt;
&lt;div&gt;有个概念叫“浅拷贝”，指的是 copy() 方法只拷贝引用对象的内存地址，而非实际的引用对象。类比于这个概念，我们可以认为 getsizeof() 是一种“浅计算”。&lt;/div&gt;
&lt;div&gt;“浅计算”不关心真实的对象，所以其计算结果只是一个假象。这是一个值得注意的问题，但是注意到这点还不够，我们还可以发散地思考如下的问题：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;“浅计算”方法的底层实现是怎样的？&lt;/li&gt;
&lt;li&gt;为什么 getsizeof() 会采用“浅计算”的方法？&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;关于第一个问题，getsizeof(x) 方法实际会调用 x 对象的&lt;code&gt;__sizeof__()&lt;/code&gt; 魔术方法，对于内置对象来说，这个方法是通过 CPython 解释器实现的。&lt;/div&gt;
&lt;div&gt;我查到这篇文章《&lt;a href=&quot;https://www.dongwm.com/post/python-memory-usage-1/&quot;&gt;Python中对象的内存使用(一)&lt;/a&gt;》，它分析了 CPython 源码，最终定位到的核心代码是这一段：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;/*longobject.c*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; Py_ssize_t
&lt;span&gt;int___sizeof___impl&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;PyObject &lt;span&gt;*&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;
    Py_ssize_t res&lt;span&gt;;&lt;/span&gt;

    res &lt;span&gt;=&lt;/span&gt; &lt;span&gt;offsetof&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;PyLongObject&lt;span&gt;,&lt;/span&gt; ob_digit&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;Py_ABS&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Py_SIZE&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;digit&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; res&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我看不懂这段代码，但是可以知道的是，它在计算 Python 对象的大小时，只跟该对象的结构体的属性相关，而没有进一步作“深度计算”。&lt;/div&gt;
&lt;div&gt;对于 CPython 的这种实现，我们可以注意到两个层面上的区别：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;字节增大：int 类型在 C 语言中只占到 4 个字节，但是在 Python 中，int 其实是被封装成了一个对象，所以在计算其大小时，会包含对象结构体的大小。在 32 位解释器中，getsizeof(1) 的结果是 14 个字节，比数字本身的 4 字节增大了。&lt;/li&gt;
&lt;li&gt;字节减少：对于相对复杂的对象，例如列表和字典，这套计算机制由于没有累加内部元素的占用量，就会出现比真实占用内存小的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;由此，我有一个不成熟的猜测：基于“一切皆是对象”的设计原则，int 及其它基础的 C 数据类型在 Python 中被套上了一层“壳”，所以需要一个方法来计算它们的大小，也即是 getsizeof()。&lt;/div&gt;
&lt;div&gt;官方文档中说“&lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.getsizeof&quot;&gt;All built-in objects will return correct results&lt;/a&gt;” [1]，指的应该是数字、字符串和布尔值之类的简单对象。但是不包括列表、元组和字典等在内部存在引用关系的类型。&lt;/div&gt;
&lt;div&gt;为什么不推广到所有内置类型上呢？我未查到这方面的解释，若有知情的同学，烦请告知。&lt;/div&gt;
&lt;h2&gt;3、“深计算”与其它问题&lt;/h2&gt;
&lt;div&gt;与“浅计算”相对应，我们可以定义出一种“深计算”。对于前面的两个例子，“深计算”应该遍历每个内部元素以及可能的子元素，累加计算它们的字节，最后算出总的内存大小。&lt;/div&gt;
&lt;div&gt;那么，我们应该注意的问题有：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;是否存在“深计算”的方法/实现方案？&lt;/li&gt;
&lt;li&gt;实现“深计算”时应该注意什么？&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;Stackoverflow 网站上有个年代久远的问题“How do I determine the size of an object in Python?” [2]，实际上问的就是如何实现“深计算”的问题。&lt;/div&gt;
&lt;div&gt;有不同的开发者贡献了两个项目：&lt;code&gt;pympler&lt;/code&gt; 和 &lt;code&gt;pysize&lt;/code&gt; ：第一个项目已发布在 Pypi 上，可以“pip install pympler”安装；第二个项目烂尾了，作者也没发布到 Pypi 上（注：Pypi 上已有个 pysize 库，是用来做格式转化的，不要混淆），但是可以在 Github 上获取到其源码。&lt;/div&gt;
&lt;div&gt;对于前面的两个例子，我们可以拿这两个项目分别测试一下：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;单看数值的话，pympler 似乎确实比 getsizeof() 合理多了。&lt;/div&gt;
&lt;div&gt;再看看 pysize，直接看测试结果是（获取其源码过程略）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;64&lt;/span&gt;
&lt;span&gt;118&lt;/span&gt;
&lt;span&gt;190&lt;/span&gt;
&lt;span&gt;206&lt;/span&gt;
&lt;span&gt;300281&lt;/span&gt;
&lt;span&gt;30281&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;可以看出，它比 pympler 计算的结果略小。就两个项目的完整度、使用量与社区贡献者规模来看，pympler 的结果似乎更为可信。&lt;/div&gt;
&lt;div&gt;那么，它们分别是怎么实现的呢？那微小的差异是怎么导致的？从它们的实现方案中，我们可以学习到什么呢？&lt;/div&gt;
&lt;div&gt;pysize 项目很简单，只有一个核心方法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;get_size&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;,&lt;/span&gt; seen&lt;span&gt;=&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;Recursively finds size of objects in bytes&quot;&quot;&quot;&lt;/span&gt;
    size &lt;span&gt;=&lt;/span&gt; sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; seen &lt;span&gt;is&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        seen &lt;span&gt;=&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    obj_id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; obj_id &lt;span&gt;in&lt;/span&gt; seen&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;# Important mark as seen *before* entering recursion to gracefully handle&lt;/span&gt;
    &lt;span&gt;# self-referential objects&lt;/span&gt;
    seen&lt;span&gt;.&lt;/span&gt;add&lt;span&gt;(&lt;/span&gt;obj_id&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;hasattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__dict__&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; cls &lt;span&gt;in&lt;/span&gt; obj&lt;span&gt;.&lt;/span&gt;__class__&lt;span&gt;.&lt;/span&gt;__mro__&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;&apos;__dict__&apos;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; cls&lt;span&gt;.&lt;/span&gt;__dict__&lt;span&gt;:&lt;/span&gt;
                d &lt;span&gt;=&lt;/span&gt; cls&lt;span&gt;.&lt;/span&gt;__dict__&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;__dict__&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; inspect&lt;span&gt;.&lt;/span&gt;isgetsetdescriptor&lt;span&gt;(&lt;/span&gt;d&lt;span&gt;)&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; inspect&lt;span&gt;.&lt;/span&gt;ismemberdescriptor&lt;span&gt;(&lt;/span&gt;d&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    size &lt;span&gt;+=&lt;/span&gt; get_size&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;.&lt;/span&gt;__dict__&lt;span&gt;,&lt;/span&gt; seen&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;,&lt;/span&gt; &lt;span&gt;dict&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        size &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;get_size&lt;span&gt;(&lt;/span&gt;v&lt;span&gt;,&lt;/span&gt; seen&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; v &lt;span&gt;in&lt;/span&gt; obj&lt;span&gt;.&lt;/span&gt;values&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        size &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;get_size&lt;span&gt;(&lt;/span&gt;k&lt;span&gt;,&lt;/span&gt; seen&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt; obj&lt;span&gt;.&lt;/span&gt;keys&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;elif&lt;/span&gt; &lt;span&gt;hasattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__iter__&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;bytes&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;bytearray&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        size &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;get_size&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt; seen&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; obj&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;hasattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;__slots__&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;# can have __slots__ with __dict__&lt;/span&gt;
        size &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;get_size&lt;span&gt;(&lt;/span&gt;&lt;span&gt;getattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;,&lt;/span&gt; s&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; seen&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; s &lt;span&gt;in&lt;/span&gt; obj&lt;span&gt;.&lt;/span&gt;__slots__ &lt;span&gt;if&lt;/span&gt; &lt;span&gt;hasattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;,&lt;/span&gt; s&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        
    &lt;span&gt;return&lt;/span&gt; size&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;除去判断&lt;code&gt;__dict__&lt;/code&gt; 和 &lt;code&gt;__slots__&lt;/code&gt; 属性的部分（针对类对象），它主要是对字典类型及可迭代对象（除字符串、bytes、bytearray）作递归的计算，逻辑并不复杂。&lt;/div&gt;
&lt;div&gt;以 [1,2] 这个列表为例，它先用 sys.getsizeof() 算出 36 字节，再计算内部的两个元素得 14*2=28 字节，最后相加得到 64 字节。&lt;/div&gt;
&lt;div&gt;相比之下，pympler 所考虑的内容要多很多，入口在这：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;asizeof&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;objs&lt;span&gt;,&lt;/span&gt; &lt;span&gt;**&lt;/span&gt;opts&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;&apos;&apos;&apos;Return the combined size of the given objects
           (with modified options, see method **set**).
        &apos;&apos;&apos;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; opts&lt;span&gt;:&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;**&lt;/span&gt;opts&lt;span&gt;)&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;exclude_refs&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;objs&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# skip refs to objs&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;_sizer&lt;span&gt;(&lt;/span&gt;o&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; o &lt;span&gt;in&lt;/span&gt; objs&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;它可以接受多个参数，再用 sum() 方法合并。所以核心的计算方法其实是 _sizer()。但代码很复杂，绕来绕去像一座迷宫：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;_sizer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; obj&lt;span&gt;,&lt;/span&gt; pid&lt;span&gt;,&lt;/span&gt; deep&lt;span&gt;,&lt;/span&gt; sized&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;  &lt;span&gt;# MCCABE 19&lt;/span&gt;
        &lt;span&gt;&apos;&apos;&apos;Size an object, recursively.
        &apos;&apos;&apos;&lt;/span&gt;
        s&lt;span&gt;,&lt;/span&gt; f&lt;span&gt;,&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; i &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;_seen&lt;span&gt;:&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;_seen&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; deep &lt;span&gt;or&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;_seen&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;# skip obj if seen before&lt;/span&gt;
            &lt;span&gt;# or if ref of a given obj&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;_seen&lt;span&gt;.&lt;/span&gt;again&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; sized&lt;span&gt;:&lt;/span&gt;
                s &lt;span&gt;=&lt;/span&gt; sized&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;,&lt;/span&gt; f&lt;span&gt;,&lt;/span&gt; name&lt;span&gt;=&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;_nameof&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                self&lt;span&gt;.&lt;/span&gt;exclude_objs&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; s  &lt;span&gt;# zero&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;  &lt;span&gt;# deep == seen[i] == 0&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;_seen&lt;span&gt;.&lt;/span&gt;again&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            k&lt;span&gt;,&lt;/span&gt; rs &lt;span&gt;=&lt;/span&gt; _objkey&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;_excl_d&lt;span&gt;:&lt;/span&gt;
                self&lt;span&gt;.&lt;/span&gt;_excl_d&lt;span&gt;[&lt;/span&gt;k&lt;span&gt;]&lt;/span&gt; &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                v &lt;span&gt;=&lt;/span&gt; _typedefs&lt;span&gt;.&lt;/span&gt;get&lt;span&gt;(&lt;/span&gt;k&lt;span&gt;,&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; v&lt;span&gt;:&lt;/span&gt;  &lt;span&gt;# new typedef&lt;/span&gt;
                    _typedefs&lt;span&gt;[&lt;/span&gt;k&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; v &lt;span&gt;=&lt;/span&gt; _typedef&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;,&lt;/span&gt; derive&lt;span&gt;=&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;_derive_&lt;span&gt;,&lt;/span&gt;
                                                     frames&lt;span&gt;=&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;_frames_&lt;span&gt;,&lt;/span&gt;
                                                      infer&lt;span&gt;=&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;_infer_&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;v&lt;span&gt;.&lt;/span&gt;both &lt;span&gt;or&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;_code_&lt;span&gt;)&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; v&lt;span&gt;.&lt;/span&gt;kind &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;_ign_d&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;# 猫注：这里计算 flat size&lt;/span&gt;
                    s &lt;span&gt;=&lt;/span&gt; f &lt;span&gt;=&lt;/span&gt; v&lt;span&gt;.&lt;/span&gt;flat&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;,&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;_mask&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# flat size&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;_profile&lt;span&gt;:&lt;/span&gt;
                        &lt;span&gt;# profile based on *flat* size&lt;/span&gt;
                        self&lt;span&gt;.&lt;/span&gt;_prof&lt;span&gt;(&lt;/span&gt;k&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;update&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;,&lt;/span&gt; s&lt;span&gt;)&lt;/span&gt;
                    &lt;span&gt;# recurse, but not for nested modules&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; v&lt;span&gt;.&lt;/span&gt;refs &lt;span&gt;and&lt;/span&gt; deep &lt;span&gt;&amp;lt;&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;_limit_ \
                              &lt;span&gt;and&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;deep &lt;span&gt;and&lt;/span&gt; ismodule&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                        &lt;span&gt;# add sizes of referents&lt;/span&gt;
                        z&lt;span&gt;,&lt;/span&gt; d &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;_sizer&lt;span&gt;,&lt;/span&gt; deep &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; sized &lt;span&gt;and&lt;/span&gt; deep &lt;span&gt;&amp;lt;&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;_detail_&lt;span&gt;:&lt;/span&gt;
                            &lt;span&gt;# use named referents&lt;/span&gt;
                            self&lt;span&gt;.&lt;/span&gt;exclude_objs&lt;span&gt;(&lt;/span&gt;rs&lt;span&gt;)&lt;/span&gt;
                            &lt;span&gt;for&lt;/span&gt; o &lt;span&gt;in&lt;/span&gt; v&lt;span&gt;.&lt;/span&gt;refs&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;,&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;o&lt;span&gt;,&lt;/span&gt; _NamedRef&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                                    r &lt;span&gt;=&lt;/span&gt; z&lt;span&gt;(&lt;/span&gt;o&lt;span&gt;.&lt;/span&gt;ref&lt;span&gt;,&lt;/span&gt; i&lt;span&gt;,&lt;/span&gt; d&lt;span&gt;,&lt;/span&gt; sized&lt;span&gt;)&lt;/span&gt;
                                    r&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; o&lt;span&gt;.&lt;/span&gt;name
                                &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                                    r &lt;span&gt;=&lt;/span&gt; z&lt;span&gt;(&lt;/span&gt;o&lt;span&gt;,&lt;/span&gt; i&lt;span&gt;,&lt;/span&gt; d&lt;span&gt;,&lt;/span&gt; sized&lt;span&gt;)&lt;/span&gt;
                                    r&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;_nameof&lt;span&gt;(&lt;/span&gt;o&lt;span&gt;)&lt;/span&gt;
                                rs&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;r&lt;span&gt;)&lt;/span&gt;
                                s &lt;span&gt;+=&lt;/span&gt; r&lt;span&gt;.&lt;/span&gt;size
                        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;  &lt;span&gt;# just size and accumulate&lt;/span&gt;
                            &lt;span&gt;for&lt;/span&gt; o &lt;span&gt;in&lt;/span&gt; v&lt;span&gt;.&lt;/span&gt;refs&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;,&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                                &lt;span&gt;# 猫注：这里递归计算 item size&lt;/span&gt;
                                s &lt;span&gt;+=&lt;/span&gt; z&lt;span&gt;(&lt;/span&gt;o&lt;span&gt;,&lt;/span&gt; i&lt;span&gt;,&lt;/span&gt; d&lt;span&gt;,&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                        &lt;span&gt;# deepest recursion reached&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;_depth &lt;span&gt;&amp;lt;&lt;/span&gt; d&lt;span&gt;:&lt;/span&gt;
                            self&lt;span&gt;.&lt;/span&gt;_depth &lt;span&gt;=&lt;/span&gt; d
                &lt;span&gt;if&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;_stats_ &lt;span&gt;and&lt;/span&gt; s &lt;span&gt;&amp;gt;&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;_above_ &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;# rank based on *total* size&lt;/span&gt;
                    self&lt;span&gt;.&lt;/span&gt;_rank&lt;span&gt;(&lt;/span&gt;k&lt;span&gt;,&lt;/span&gt; obj&lt;span&gt;,&lt;/span&gt; s&lt;span&gt;,&lt;/span&gt; deep&lt;span&gt;,&lt;/span&gt; pid&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt; RuntimeError&lt;span&gt;:&lt;/span&gt;  &lt;span&gt;# XXX RecursionLimitExceeded:&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;_missed &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; deep&lt;span&gt;:&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;_total &lt;span&gt;+=&lt;/span&gt; s  &lt;span&gt;# accumulate&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; sized&lt;span&gt;:&lt;/span&gt;
            s &lt;span&gt;=&lt;/span&gt; sized&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;,&lt;/span&gt; f&lt;span&gt;,&lt;/span&gt; name&lt;span&gt;=&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;_nameof&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; refs&lt;span&gt;=&lt;/span&gt;rs&lt;span&gt;)&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;exclude_objs&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; s&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;它的核心逻辑是把每个对象的 size 分为两部分：flat size 和 item size。&lt;/div&gt;
&lt;div&gt;计算 flat size 的逻辑在：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;flat&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; obj&lt;span&gt;,&lt;/span&gt; mask&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;&apos;&apos;&apos;Return the aligned flat size.
        &apos;&apos;&apos;&lt;/span&gt;
        s &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;base
        &lt;span&gt;if&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;leng &lt;span&gt;and&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;item &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;  &lt;span&gt;# include items&lt;/span&gt;
            s &lt;span&gt;+=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;leng&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;)&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;item
        &lt;span&gt;# workaround sys.getsizeof (and numpy?) bug ... some&lt;/span&gt;
        &lt;span&gt;# types are incorrectly sized in some Python versions&lt;/span&gt;
        &lt;span&gt;# (note, isinstance(obj, ()) == False)&lt;/span&gt;
        &lt;span&gt;# 猫注：不可 sys.getsizeof 的，则用上面逻辑，可以的，则用下面逻辑&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;,&lt;/span&gt; _getsizeof_excls&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            s &lt;span&gt;=&lt;/span&gt; _getsizeof&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;,&lt;/span&gt; s&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; mask&lt;span&gt;:&lt;/span&gt;  &lt;span&gt;# align&lt;/span&gt;
            s &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;s &lt;span&gt;+&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;~&lt;/span&gt;mask
        &lt;span&gt;return&lt;/span&gt; s&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这里出现的 mask 是为了作字节对齐，默认值是 7，该计算公式表示按 8 个字节对齐。对于 [1,2] 列表，会算出 (36+7)&amp;amp;~7=40 字节。同理，对于单个的 item，比如列表中的数字 1，sys.getsizeof(1) 等于 14，而 pympler 会算成对齐的数值 16，所以汇总起来是 40+16+16=72 字节。这就解释了为什么 pympler 算的结果比 pysize 大。&lt;/div&gt;
&lt;div&gt;字节对齐一般由具体的编译器实现，而且不同的编译器还会有不同的策略，理论上 Python 不应关心这么底层的细节，内置的 getsizeof() 方法就没有考虑字节对齐。&lt;/div&gt;
&lt;div&gt;在不考虑其它 edge cases 的情况下，可以认为 pympler 是在 getsizeof() 的基础上，既考虑了遍历取引用对象的 size，又考虑到了实际存储时的字节对齐问题，所以它会显得更加贴近现实。&lt;/div&gt;
&lt;h2&gt;4、小结&lt;/h2&gt;
&lt;div&gt;getsizeof() 方法的问题是显而易见的，我创造了一个“浅计算”概念给它。这个概念借鉴自 copy() 方法的“浅拷贝”，同时对应于 deepcopy() “深拷贝”，我们还能推理出一个“深计算”。&lt;/div&gt;
&lt;div&gt;前面展示了两个试图实现“深计算”的项目（pysize+pympler），两者在浅计算的基础上，深入地求解引用对象的大小。pympler 项目的完整度较高，代码中有很多细节上的设计，比如字节对齐。&lt;/div&gt;
&lt;div&gt;Python 官方团队当然也知道 getsizeof() 方法的局限性，他们甚至在文档中加了一个&lt;a href=&quot;https://code.activestate.com/recipes/577504&quot;&gt;链接&lt;/a&gt; [3]，指向了一份实现深计算的示例代码。那份代码比 pysize 还要简单（没有考虑类对象的情况）。&lt;/div&gt;
&lt;div&gt;未来 Python 中是否会出现深计算的方法，假设命名为 getdeepsizeof() 呢？这不得而知了。&lt;/div&gt;
&lt;div&gt;本文的目的是加深对 getsizeof() 方法的理解，区分浅计算与深计算，分析两个深计算项目的实现思路，指出几个值得注意的问题。&lt;/div&gt;
&lt;div&gt;读完这里，希望你也能有所收获。若有什么想法，欢迎一起交流。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>如何高效地远程部署？自动化运维利器 Fabric 教程</title>
            <link>https://pythoncat.top/posts/2020-02-18-fabric/</link>
            <guid>https://pythoncat.top/posts/2020-02-18-fabric/</guid>
            <pubDate>Tue, 18 Feb 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;关于 Python 自动化的话题，在&lt;a href=&quot;https://mp.weixin.qq.com/s/up8lxuRhJQAXRzxkirF3nA&quot;&gt;上一篇文章&lt;/a&gt;中，我介绍了 Invoke 库，它是 Fabric 的最重要组件之一。Fabric 也是一个被广泛应用的自动化工具库，是不得不提的自动化运维利器，所以，本文将来介绍一下它。&lt;/div&gt;
&lt;div&gt;Fabric 主要用在应用部署与系统管理等任务的自动化，简单轻量级，提供有丰富的 SSH 扩展接口。在 Fabric 1.x 版本中，它混杂了本地及远程两类功能；但自 Fabric 2.x 版本起，它分离出了独立的 Invoke 库，来处理本地的自动化任务，而 Fabric 则聚焦于远程与网络层面的任务。&lt;/div&gt;
&lt;div&gt;为了做到这点，Fabric 主要依赖另一大核心组件 Paramiko，它是基于 SSH 协议的远程控制模块，Fabric 在其基础上封装出了更加友好的接口，可以远程执行 Shell 命令、传输文件、批量操作服务器、身份认证、多种配置与设置代理，等等。&lt;/div&gt;
&lt;h2&gt;一、Fabric 的版本区分&lt;/h2&gt;
&lt;div&gt;Python 2 版本已经被官宣在今年元旦“退休”了，未来只会是 Python 3 的舞台。为了适应 Python 版本的非兼容性迁移，很多项目也必须推出自己的新版本（兼容或只支持 Python 3），其中就包括本文的主角 Fabric。&lt;/div&gt;
&lt;div&gt;Fabric 自身存在着 2 个大版本：Fabric 1 和 Fabric 2，而在这个库的基础上，还有两个很容易混淆的相关库：Fabric2 和 Fabric3（注意这里的数字是库名的一部分）。&lt;/div&gt;
&lt;div&gt;它们的区分如下：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Fabric 1.x：支持 Python 2.5-2.7，但不支持 Python 3&lt;/li&gt;
&lt;li&gt;Fabric 2.x：支持 Python 2.7 与 3.4+，但不兼容 Fabric 1.x 的 fabfile&lt;/li&gt;
&lt;li&gt;Fabric2：等同于 Fabric 2.x，为了使不同版本共存（装一个 1.x 旧版本，再装它作为新版本）&lt;/li&gt;
&lt;li&gt;Fabric3：一个基于 Fabric 1.x 的 fork（非官方），兼容 Python 2&amp;amp;3，兼容 Fabric1.x 的 fabfile&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;综上可见，我们推荐使用官方的 Fabric 2.x 系列版本，但同时要注意，某些过时的教程可能是基于早期版本的（或非官方的 Fabric3，也是基于 Fabric 1.x），需要注意识别。&lt;/div&gt;
&lt;div&gt;例如，在 Fabric 1.x 系列中这么写导入：from fabric.api import run；在新版本中将报错：“ImportError: No module named api”（PS：可根据是否有 fabric.api 来判断 Fabric 的版本，就像在 Python 中根据 print 语句或 print 函数来判断版本一样）。同时，由于新版本不支持老版本的 fabfile，在使用时就可能报错：“No idea what ‘xxx’ is!”&lt;/div&gt;
&lt;div&gt;Fabric 2 是非兼容性版本，相比于前个版本，它主要改进的点有：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;支持 Python 2.7 与 3.4+&lt;/li&gt;
&lt;li&gt;线程安全，取消了多进程的并发实现&lt;/li&gt;
&lt;li&gt;API 围绕 fabric.connection.Connection 进行了重组&lt;/li&gt;
&lt;li&gt;全面修改了命令行解析器，允许在每个任务的基础上使用规则的 GNU/POSIX  风格的标志和选项（不再需要 fab mytask:weird = custom,arg = format）&lt;/li&gt;
&lt;li&gt;可以声明前置任务与后置任务&lt;/li&gt;
&lt;li&gt;……（官方列了&lt;a href=&quot;http://www.fabfile.org/upgrading.html#upgrading&quot;&gt;10几条&lt;/a&gt; [1]，本文不一一罗列）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;之前介绍过的 invoke，就是在开发 Fabric 2 时被分离出来的，具体的原因可参见&lt;a href=&quot;http://www.pyinvoke.org/faq.html#invoke-split-from-fabric&quot;&gt;这个回答&lt;/a&gt; [2]。总而言之，在使用 Fabric 时，应该注意版本差异的问题。&lt;/div&gt;
&lt;h2&gt;二、Fabric 的基本用法&lt;/h2&gt;
&lt;h3&gt;1、安装&lt;/h3&gt;
&lt;div&gt;首先是安装：&lt;code&gt;pip intall fabric&lt;/code&gt; ，安装后，可在命令行窗口查看版本信息：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; fab &lt;span&gt;-&lt;/span&gt;V
Fabric &lt;span&gt;2.5&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;
Paramiko &lt;span&gt;2.7&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;
Invoke &lt;span&gt;1.4&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;执行“fab -V”，以上结果可看出我安装的是 Fabric 2.5.0 版本，同时可看到它的两个核心依赖库 Paramiko 及 Invoke 的版本信息。&lt;/div&gt;
&lt;h3&gt;2、一个简单的例子&lt;/h3&gt;
&lt;div&gt;Fabric 主要用于远程任务，即要对远程服务器进行操作，下面是一个简单的例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 可使用任意的文件名&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; fabric &lt;span&gt;import&lt;/span&gt; Connection

host_ip &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;47.xx.xx.xx&apos;&lt;/span&gt;  &lt;span&gt;# 服务器地址&lt;/span&gt;
user_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;root&apos;&lt;/span&gt; &lt;span&gt;# 服务器用户名&lt;/span&gt;
password &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;****&apos;&lt;/span&gt;  &lt;span&gt;# 服务器密码&lt;/span&gt;
cmd &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;date&apos;&lt;/span&gt;  &lt;span&gt;# shell 命令，查询服务器上的时间&lt;/span&gt;

con &lt;span&gt;=&lt;/span&gt; Connection&lt;span&gt;(&lt;/span&gt;host_ip&lt;span&gt;,&lt;/span&gt; user_name&lt;span&gt;,&lt;/span&gt; connect_kwargs&lt;span&gt;=&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;password&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; password&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
result &lt;span&gt;=&lt;/span&gt; con&lt;span&gt;.&lt;/span&gt;run&lt;span&gt;(&lt;/span&gt;cmd&lt;span&gt;,&lt;/span&gt; hide&lt;span&gt;=&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;result&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;以上代码，通过账号+密码登录到远程服务器，然后执行&lt;code&gt;date&lt;/code&gt;命令，查看服务器的时间，执行结果：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;Command exited &lt;span&gt;with&lt;/span&gt; status &lt;span&gt;0.&lt;/span&gt;
&lt;span&gt;==&lt;/span&gt;&lt;span&gt;=&lt;/span&gt; stdout &lt;span&gt;==&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;
Fri Feb &lt;span&gt;14&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;05&lt;/span&gt; CST &lt;span&gt;2020&lt;/span&gt;

&lt;span&gt;(&lt;/span&gt;no stderr&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;现在打印的结果中，除了服务器时间，还有一些无关的信息。这是因为它打印的“result”是一个”fabric.runners.Result”类，我们可以把其中的信息解析出来：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;result&lt;span&gt;.&lt;/span&gt;stdout&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# Fri Feb 14 15:33:05 CST 2020&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;result&lt;span&gt;.&lt;/span&gt;exited&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 0&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;result&lt;span&gt;.&lt;/span&gt;ok&lt;span&gt;)&lt;/span&gt;      &lt;span&gt;# True&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;result&lt;span&gt;.&lt;/span&gt;failed&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# False&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;result&lt;span&gt;.&lt;/span&gt;command&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# date&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;result&lt;span&gt;.&lt;/span&gt;connection&lt;span&gt;.&lt;/span&gt;host&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 47.xx.xx.xx&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上述代码使用了 Connection 类及其 run() 方法，可在连接的服务器上运行 shell 命令。如果需要用管理员权限，则需替换成 sudo() 方法。如果要在本地执行 shell 命令，则需替换成 local() 方法。&lt;/div&gt;
&lt;div&gt;除此之外，还有 get()、put() 等方法，详见下文介绍。&lt;/div&gt;
&lt;h3&gt;3、命令行用法&lt;/h3&gt;
&lt;div&gt;上例代码可写在任意的 .py 脚本中，然后运行该脚本，或者稍微封装下再导入到其它脚本中使用。&lt;/div&gt;
&lt;div&gt;另外，Fabric 还是个命令行工具，可以通过&lt;code&gt;fab&lt;/code&gt;命令来执行任务。我们稍微改造一下上例的代码：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 文件名：fabfile.py&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; fabric &lt;span&gt;import&lt;/span&gt; Connection
&lt;span&gt;from&lt;/span&gt; fabric &lt;span&gt;import&lt;/span&gt; task

host_ip &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;47.xx.xx.xx&apos;&lt;/span&gt;  &lt;span&gt;# 服务器地址&lt;/span&gt;
user_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;root&apos;&lt;/span&gt; &lt;span&gt;# 服务器用户名&lt;/span&gt;
password &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;****&apos;&lt;/span&gt;  &lt;span&gt;# 服务器密码&lt;/span&gt;
cmd &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;date&apos;&lt;/span&gt;  &lt;span&gt;# shell 命令，查询服务器上的时间&lt;/span&gt;

&lt;span&gt;@task&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;
    Get date from remote host.
    &quot;&quot;&quot;&lt;/span&gt;
    con &lt;span&gt;=&lt;/span&gt; Connection&lt;span&gt;(&lt;/span&gt;host_ip&lt;span&gt;,&lt;/span&gt; user_name&lt;span&gt;,&lt;/span&gt; connect_kwargs&lt;span&gt;=&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;password&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; password&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    result &lt;span&gt;=&lt;/span&gt; con&lt;span&gt;.&lt;/span&gt;run&lt;span&gt;(&lt;/span&gt;cmd&lt;span&gt;,&lt;/span&gt; hide&lt;span&gt;=&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;result&lt;span&gt;.&lt;/span&gt;stdout&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 只打印时间&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;解释一下，主要的改动点有：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;fabfile.py 文件名：入口代码的脚本名必须用这个名字&lt;/li&gt;
&lt;li&gt;@task 装饰器：需要从 fabric 中引入这个装饰器，它是对 invoke 的 @task 装饰器的封装，实际用法跟 invoke 一样（注意：它也需要有上下文参数“c”，但实际上它并没有在代码块中使用，而是用了 Connection 类的实例）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;然后，在该脚本同级目录的命令行窗口中，可以查看和执行相应的任务：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; fab &lt;span&gt;-&lt;/span&gt;l
Available tasks&lt;span&gt;:&lt;/span&gt;
  test   Get date &lt;span&gt;from&lt;/span&gt; remote host&lt;span&gt;.&lt;/span&gt;

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; fab test
Fri Feb &lt;span&gt;14&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; CST &lt;span&gt;2020&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;fab 是 Invoke 的扩展实现，继承了很多原有功能，所以执行“fab —help”，与之前介绍的“inv —help”相比，你会发现它们的很多参数与解释都是一模一样的。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;fab 针对远程服务的场景，添加了几个命令行选项（已标蓝），其中：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;—prompt-for-login-password：令程序在命令行中输入 SSH 登录密码（上例在代码中指定了 connect_kwargs.password 参数，若用此选项，可要求在执行时再手工输入密码）&lt;/li&gt;
&lt;li&gt;—prompt-for-passphrase：令程序在命令行中输入 SSH 私钥加密文件的路径&lt;/li&gt;
&lt;li&gt;-H 或 —hosts：指定要连接的 host 名&lt;/li&gt;
&lt;li&gt;-i 或 —identity：指定 SSH 连接所用的私钥文件&lt;/li&gt;
&lt;li&gt;-S 或 —ssh-config：指定运行时要加载的 SSH 配置文件&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;关于 Fabric 的命令行接口，更多内容可查看&lt;a href=&quot;http://docs.fabfile.org/en/2.5/cli.html&quot;&gt;文档&lt;/a&gt; [3]。&lt;/div&gt;
&lt;h3&gt;4、交互式操作&lt;/h3&gt;
&lt;div&gt;远程服务器上若有交互式提示，要求输入密码或“yes”之类的信息，这就要求 Fabric 能够监听并作出回应。&lt;/div&gt;
&lt;div&gt;以下是一个简单示例。引入 invoke 的 Responder，初始化内容是一个正则字符串和回应信息，最后赋值给 watchers 参数：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; invoke &lt;span&gt;import&lt;/span&gt; Responder
&lt;span&gt;from&lt;/span&gt; fabric &lt;span&gt;import&lt;/span&gt; Connection
c &lt;span&gt;=&lt;/span&gt; Connection&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;host&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
sudopass &lt;span&gt;=&lt;/span&gt; Responder&lt;span&gt;(&lt;/span&gt;
     pattern&lt;span&gt;=&lt;/span&gt;&lt;span&gt;r&apos;\[sudo\] password:&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
     response&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;mypassword\n&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
c&lt;span&gt;.&lt;/span&gt;run&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;sudo whoami&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; pty&lt;span&gt;=&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; watchers&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;sudopass&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;5、传输文件&lt;/h3&gt;
&lt;div&gt;本地与服务器间的文件传输是常见用法。Fabric 在这方面做了很好的封装，Connection 类中有以下两个方法可用：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;get(*args, **kwargs)：拉取远端文件到本地文件系统或类文件（file-like）对象&lt;/li&gt;
&lt;li&gt;put(*args, **kwargs)：推送本地文件或类文件对象到远端文件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;在已建立连接的情况下，示例：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# (略)&lt;/span&gt;
con&lt;span&gt;.&lt;/span&gt;get&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;/opt/123.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;123.txt&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
con&lt;span&gt;.&lt;/span&gt;put&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;/opt/test.txt&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;第一个参数指的是要传输的源文件，第二个参数是要传输的目的地，可以指定成文件名或者文件夹（为空或 None 时，使用默认路径）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# (略)&lt;/span&gt;
con&lt;span&gt;.&lt;/span&gt;get&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;/opt/123.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 为空时，使用默认路径&lt;/span&gt;
con&lt;span&gt;.&lt;/span&gt;put&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;/opt/&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 指定路径 /opt/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;get() 方法的默认存储路径是&lt;code&gt;os.getcwd&lt;/code&gt; ，而 put() 方法的默认存储路径是 home 目录。&lt;/div&gt;
&lt;h3&gt;6、服务器批量操作&lt;/h3&gt;
&lt;div&gt;对于服务器集群的批量操作，最简单的实现方法是用 for 循环，然后逐一建立 connection 和执行操作，类似这样：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; host &lt;span&gt;in&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;web1&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;web2&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;mac1&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
	result &lt;span&gt;=&lt;/span&gt; Connection&lt;span&gt;(&lt;/span&gt;host&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;run&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;uname -s&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;但有时候，这样的方案会存在问题：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;如果存在多组不同的服务器集群，需要执行不同操作，那么需要写很多 for 循环&lt;/li&gt;
&lt;li&gt;如果想把每组操作的结果聚合起来（例如字典形式，key-主机，value-结果），还得在 for 循环之外添加额外的操作&lt;/li&gt;
&lt;li&gt;for 循环是顺序同步执行的，效率太低，而且缺乏异常处理机制（若中间出现异常，会导致跳出后续操作）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;对于这些问题，Fabric 提出了 Group 的概念，可将一组主机定义成一个 Group，它的 API 方法跟 Connection 一样，即一个 Group 可简化地视为一个 Connection。&lt;/div&gt;
&lt;div&gt;然后，开发者只需要简单地操作这个 Group，最后得到一个结果集即可，减少了自己在异常处理及执行顺序上的工作。&lt;/div&gt;
&lt;div&gt;Fabric 提供了一个 fabric.group.Group 基类，并由其派生出两个子类，区别是：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;SerialGroup(*hosts, **kwargs)：按串行方式执行操作&lt;/li&gt;
&lt;li&gt;ThreadingGroup(*hosts, **kwargs)：按并发方式执行操作&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;Group 的类型决定了主机集群的操作方式，我们只需要做出选择即可。然后，它们的执行结果是一个&lt;code&gt;fabric.group.GroupResult&lt;/code&gt;类，它是 dict 的子类，存储了每个主机 connection 及其执行结果的对应关系。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; fabric &lt;span&gt;import&lt;/span&gt; SerialGroup
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; results &lt;span&gt;=&lt;/span&gt; SerialGroup&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;web1&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;web2&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;mac1&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;run&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;uname -s&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;results&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;GroupResult&lt;span&gt;:&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;Connection &lt;span&gt;&apos;web1&apos;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;CommandResult &lt;span&gt;&apos;uname -s&apos;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;Connection &lt;span&gt;&apos;web2&apos;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;CommandResult &lt;span&gt;&apos;uname -s&apos;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;Connection &lt;span&gt;&apos;mac1&apos;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;CommandResult &lt;span&gt;&apos;uname -s&apos;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;另外，GroupResult 还提供了 failed 与 succeeded 两个属性，可以取出失败/成功的子集。由此，也可以方便地批量进行二次操作。 &lt;a href=&quot;https://mp.weixin.qq.com/s/UHtPaxO2ojql5ps4hTn3Vg&quot;&gt;原文&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;三、Fabric 的进阶用法&lt;/h2&gt;
&lt;h3&gt;1、身份认证&lt;/h3&gt;
&lt;div&gt;Fabric 使用 SSH 协议来建立远程会话，它是一种相对安全的基于应用层的加密传输协议。&lt;/div&gt;
&lt;div&gt;基本来说，它有两种级别的安全认证方式：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;基于口令的身份认证：使用账号与密码来登录远程主机，安全性较低，容易受到“中间人”攻击&lt;/li&gt;
&lt;li&gt;基于密钥的身份认证：使用密钥对方式（公钥放服务端，私钥放客户端），不会受到“中间人”攻击，但登录耗时较长&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;前文在举例时，我们用了第一种方式，即通过指定 connect_kwargs.password 参数，使用口令来登录。&lt;/div&gt;
&lt;div&gt;Fabric 当然也支持采用第二种方式，有三种方法来指定私钥文件的路径，优先级如下：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;优先查找 connect_kwargs.key_filename 参数，找到则用作私钥&lt;/li&gt;
&lt;li&gt;其次查找命令行用法的 —identify 选项&lt;/li&gt;
&lt;li&gt;最后默认使用操作系统的 ssh_config 文件中的&lt;code&gt;IdentityFile&lt;/code&gt; 的值&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;如果私钥文件本身还被加密过，则需要使用 connect_kwargs.passphrase 参数。&lt;/div&gt;
&lt;h3&gt;2、配置文件&lt;/h3&gt;
&lt;div&gt;Fabric 支持把一些参数项与业务代码分离，即通过配置文件来管理它们，例如前面提到的密码和私钥文件，可写在配置文件中，避免与代码耦合。&lt;/div&gt;
&lt;div&gt;Fabric 基本沿用了 Invoke 的配置文件体系（官方文档中列出了 9 层），同时增加了一些跟 SSH 相关的配置项。支持的文件格式有 .yaml、.yml、.json 与 .py（按此次序排优先级），推荐使用 yaml 格式（后缀可简写成 yml）。&lt;/div&gt;
&lt;div&gt;其中，比较常用的配置文件有：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;系统级的配置文件：/etc/fabric.yml&lt;/li&gt;
&lt;li&gt;用户级的配置文件：~/.fabric.yml（Windows 在 C:\Users\xxx 下）&lt;/li&gt;
&lt;li&gt;项目级的配置文件：/myproject/fabric.yml&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;以上文件的优先级递减，由于我本机是 Windows，为了方便，我在用户目录建一个”.fabric.yml”文件，内容如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# filename:.fabric.yml&lt;/span&gt;

user&lt;span&gt;:&lt;/span&gt; root
connect_kwargs&lt;span&gt;:&lt;/span&gt;
  password&lt;span&gt;:&lt;/span&gt; xxxx
&lt;span&gt;# 若用密钥，则如下&lt;/span&gt;
&lt;span&gt;#  key_filename:&lt;/span&gt;
&lt;span&gt;#    - your_key_file&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我们把用户名和密码抽离出来了，所以 fabfile 中就可以删掉这些内容：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 文件名：fabfile.py&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; fabric &lt;span&gt;import&lt;/span&gt; Connection
&lt;span&gt;from&lt;/span&gt; fabric &lt;span&gt;import&lt;/span&gt; task

host_ip &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;47.xx.xx.xx&apos;&lt;/span&gt;  &lt;span&gt;# 服务器地址&lt;/span&gt;
cmd &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;date&apos;&lt;/span&gt;  &lt;span&gt;# shell 命令，查询服务器上的时间&lt;/span&gt;

&lt;span&gt;@task&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;
    Get date from remote host.
    &quot;&quot;&quot;&lt;/span&gt;
    con &lt;span&gt;=&lt;/span&gt; Connection&lt;span&gt;(&lt;/span&gt;host_ip&lt;span&gt;)&lt;/span&gt;
    result &lt;span&gt;=&lt;/span&gt; con&lt;span&gt;.&lt;/span&gt;run&lt;span&gt;(&lt;/span&gt;cmd&lt;span&gt;,&lt;/span&gt; hide&lt;span&gt;=&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;result&lt;span&gt;.&lt;/span&gt;stdout&lt;span&gt;)&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;然后，在命令行中执行：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; fab test
Tue Feb &lt;span&gt;18&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; CST &lt;span&gt;2020&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;配置文件中还可以设置很多参数，详细可查看&lt;a href=&quot;http://docs.fabfile.org/en/2.5/concepts/configuration.html&quot;&gt;文档&lt;/a&gt; [4]。&lt;/div&gt;
&lt;h3&gt;3、网络网关&lt;/h3&gt;
&lt;div&gt;如果远程服务是网络隔离的，无法直接被访问到（处在不同局域网），这时候需要有网关/代理/隧道，这个中间层的机器通常被称为跳板机或堡垒机。&lt;/div&gt;
&lt;div&gt;Fabric 中有两种网关解决方案，对应到 OpenSSH 客户端的两种选项：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;ProxyJump：简单，开销少，可嵌套&lt;/li&gt;
&lt;li&gt;ProxyCommand：开销大，不可嵌套，更灵活&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;在创建 Fabric 的 Connection 对象时，可通过指定 gateway 参数来应用这两种方案：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;ProxyJump 方式就是在一个 Connection 中嵌套一个 Connection  作为前者的网关，后者使用 SSH 协议的&lt;code&gt;direct-tcpip&lt;/code&gt; 为前者打开与实际远程主机的连接，而且后者还可以继续嵌套使用自己的网关。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; fabric &lt;span&gt;import&lt;/span&gt; Connection

c &lt;span&gt;=&lt;/span&gt; Connection&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;internalhost&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; gateway&lt;span&gt;=&lt;/span&gt;Connection&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;gatewayhost&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;ProxyCommand 方式是客户端在本地用 ssh 命令（类似“ssh -W %h:%p gatewayhost”），创建一个子进程，该子进程与服务端进行通信，同时它能读取标准输入和输出。&lt;/div&gt;
&lt;div&gt;这部分的实现细节分别在&lt;code&gt;paramiko.channel.Channel&lt;/code&gt; 和 &lt;code&gt;paramiko.proxy.ProxyCommand&lt;/code&gt;，除了在参数中指定，也可以在 Fabric 支持的配置文件中定义。更多细节，请查阅&lt;a href=&quot;http://docs.fabfile.org/en/2.5/concepts/networking.html&quot;&gt;文档&lt;/a&gt; [5]。&lt;/div&gt;
&lt;h2&gt;四、小结&lt;/h2&gt;
&lt;div&gt;Fabric 的非兼容版本造成了一定程度的社区分裂，这无疑跟 Python 3 的推行脱不开关系，但是我们有理由相信，新版本优胜于老版本。&lt;/div&gt;
&lt;div&gt;网上关于 Fabric 的文章，很多已过时了。本文针对最新的官方文档，梳理出了较为全面的知识点，可以带大家很好地入门 Fabric。&lt;/div&gt;
&lt;div&gt;读完本文，相信读者们只需要几分钟就能轻松上手使用。如若有所疑问，欢迎通过以下方式联系我。&lt;/div&gt;
&lt;div&gt;--------------&lt;/div&gt;
&lt;div&gt;公众号：Python猫&lt;/div&gt;
&lt;div&gt;头条号：Python猫&lt;/div&gt;
&lt;div&gt;知乎：豌豆花下猫&lt;/div&gt;
&lt;div&gt;掘金：豌豆花下猫&lt;/div&gt;
&lt;div&gt;--------------&lt;/div&gt;
&lt;h3&gt;相关链接：&lt;/h3&gt;
&lt;div&gt;Invoke教程：&lt;a href=&quot;https://mp.weixin.qq.com/s/up8lxuRhJQAXRzxkirF3nA&quot;&gt;https://mp.weixin.qq.com/s/up8lxuRhJQAXRzxkirF3nA&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;1、&lt;a href=&quot;http://www.fabfile.org/upgrading.html#upgrading&quot;&gt;http://www.fabfile.org/upgrading.html#upgrading&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;http://www.pyinvoke.org/faq.html#invoke-split-from-fabric&quot;&gt;http://www.pyinvoke.org/faq.html#invoke-split-from-fabric&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;http://docs.fabfile.org/en/2.5/cli.html&quot;&gt;http://docs.fabfile.org/en/2.5/cli.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;http://docs.fabfile.org/en/2.5/concepts/configuration.html&quot;&gt;http://docs.fabfile.org/en/2.5/concepts/configuration.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;http://docs.fabfile.org/en/2.5/concepts/networking.html&quot;&gt;http://docs.fabfile.org/en/2.5/concepts/networking.html&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>强大的 Python 任务自动化工具！invoke 十分钟入门指南</title>
            <link>https://pythoncat.top/posts/2020-02-05-invoke/</link>
            <guid>https://pythoncat.top/posts/2020-02-05-invoke/</guid>
            <pubDate>Wed, 05 Feb 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;接着前面的《&lt;a href=&quot;https://mp.weixin.qq.com/s/4kN2cu_SwjzubLHWmJ7D7Q&quot;&gt;tox 教程&lt;/a&gt;》，以及刚翻译好的《&lt;a href=&quot;https://mp.weixin.qq.com/s/pZR8VQblbaedtBhPUFoznQ&quot;&gt;nox文档&lt;/a&gt;》，我们继续聊聊 Python 任务自动化的话题。&lt;/div&gt;
&lt;div&gt;nox 的作者在去年的 Pycon US 上，做了一场题为《&lt;a href=&quot;https://www.youtube.com/watch?v=-BHverY7IwU&quot;&gt;Break the Cycle: Three excellent Python tools to automate repetitive tasks&lt;/a&gt;》的分享（B站观看地址：&lt;a href=&quot;https://b23.tv/av86640235%EF%BC%89%EF%BC%8C%E5%A5%B9%E4%BB%8B%E7%BB%8D%E4%BA%86%E4%B8%89%E4%B8%AA%E4%BB%BB%E5%8A%A1%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7%EF%BC%9Atox%E3%80%81nox&quot;&gt;https://b23.tv/av86640235），她介绍了三个任务自动化工具：tox、nox&lt;/a&gt; 和 invoke，本文的话题正好就是最后的 invoke。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;1、invoke 可以做什么？&lt;/h2&gt;
&lt;div&gt;invoke 是从著名的远程部署工具 Fabric 中分离出来的，它与 paramiko 一起是 Fabric 的两大最核心的基础组件。&lt;/div&gt;
&lt;div&gt;除了作为命令行工具，它专注于“任务执行”（task execution），可以标注和组织任务，并通过 CLI（command-line interface，即命令行界面） 和 shell 命令来执行任务。&lt;/div&gt;
&lt;div&gt;同样是任务自动化工具，invoke 与我们之前介绍过的 tox/nox 在侧重点上有所不同：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;tox/nox 主要是在打包、测试、持续集成等方面的自动化（当然它们能做的还不止于此）&lt;/li&gt;
&lt;li&gt;invoke 则更具普遍性，可以用在任何需要“执行任务”的场景，可以是无相关性的任务组，也可以是有顺序依赖的分步骤的工作流&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;invoke 在 Github 上有 2.7K star，十分受欢迎，接下来我们看看它如何使用？&lt;/div&gt;
&lt;h2&gt;2、怎么使用 invoke？&lt;/h2&gt;
&lt;div&gt;首先，安装很简单：&lt;code&gt;pip install invoke&lt;/code&gt;。&lt;/div&gt;
&lt;div&gt;其次，简单使用时有以下要素：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;任务文件。创建一个 tasks.py 文件。&lt;/li&gt;
&lt;li&gt;@task 装饰器。在一个函数上添加 @task 装饰器，即可将该函数标记为一个任务，接受 invoke 的调度管理。&lt;/li&gt;
&lt;li&gt;上下文参数。给被装饰的函数添加一个上下文参数（context argument），注意它必须作为第一个参数，而命名按约定可以是&lt;code&gt;c&lt;/code&gt; 或&lt;code&gt;ctx&lt;/code&gt; 或&lt;code&gt;context&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;命令行执行。在命令行中执行&lt;code&gt;invoke --list&lt;/code&gt; 来查看所有任务，运行&lt;code&gt;invoke xxx&lt;/code&gt; 来执行名为 xxx 的任务。命令行中的“invoke”可以简写成“inv”。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;以下是一个简单的示例：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 文件名：tasks.py&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; invoke &lt;span&gt;import&lt;/span&gt; task

&lt;span&gt;@task&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;hello&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Hello world!&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;@task&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;greet&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;,&lt;/span&gt; name&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    c&lt;span&gt;.&lt;/span&gt;run&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;echo &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;name&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;加油!&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在上述代码中，我们定义了两个任务：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;”hello“任务调用了 Python 内置的 print 函数，会打印一个字符串“Hello world!”&lt;/li&gt;
&lt;li&gt;“greet”任务调用了上下文参数的 run() 方法，可以执行 shell 命令，同时本例中还可以接收一个参数。在 shell 命令中，echo 可理解成打印，所以这也是一个打印任务，会打印出“xxx加油！”（xxx 是我们传的参数）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;以上代码写在 tasks.py 文件中，首先导入装饰器 &lt;code&gt;from invoke import task&lt;/code&gt;，@task 装饰器可以不带参数，也可以带参数（参见下一节），被它装饰了的函数就是一个任务。&lt;/div&gt;
&lt;div&gt;上下文参数（即上例的“c”）必须要显式地指明，如果缺少这个参数，执行时会抛出异常：“TypeError: Tasks must have an initial Context argument!”&lt;/div&gt;
&lt;div&gt;然后在 tasks.py 文件的同级目录中，打开命令行窗口，执行命令。如果执行的位置找不到这个任务文件，则会报错：“Can’t find any collection named ‘tasks’!”&lt;/div&gt;
&lt;div&gt;正常情况下，通过执行&lt;code&gt;inv --list&lt;/code&gt; 或者&lt;code&gt;inv -l&lt;/code&gt; ，可以看到所有任务的列表（按字母表顺序排序）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; inv &lt;span&gt;-&lt;/span&gt;l
Available tasks&lt;span&gt;:&lt;/span&gt;

  greet
  hello&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我们依次执行这两个任务，其中传参时可以默认按位置参数传参，也可以指定关键字传参。结果是：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; inv hello
Hello world!
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; inv greet 武汉
武汉加油!
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; inv greet &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;武汉&quot;&lt;/span&gt;
武汉加油！&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;缺少传参时，报错：‘greet’ did not receive required positional arguments: ‘name’；多余传参时，报错：No idea what ’???’ is!&lt;/div&gt;
&lt;h2&gt;3、 如何用好 invoke？&lt;/h2&gt;
&lt;div&gt;介绍完 invoke 的简单用法，我们知道了它所需的几项要素，也大致知道了它的使用步骤，接下来是它的其它用法。&lt;/div&gt;
&lt;h3&gt;3.1 添加帮助信息&lt;/h3&gt;
&lt;div&gt;在上例中，“inv -l”只能看到任务名称，缺少必要的辅助信息，为了加强可读性，我们可以这样写：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;@task&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;help&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;A param for test&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;greet&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;,&lt;/span&gt; name&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;
    A test for shell command.
    Second line.
    &quot;&quot;&quot;&lt;/span&gt;
    c&lt;span&gt;.&lt;/span&gt;run&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;echo &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;name&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;加油!&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;其中，文档字符串的第一行内容会作为摘录，在“inv -l”的查询结果中展示，而且完整的内容与 @task 的 help 内容，会对应在“inv —help”中展示：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; inv &lt;span&gt;-&lt;/span&gt;l
Available tasks&lt;span&gt;:&lt;/span&gt;

  greet   A test &lt;span&gt;for&lt;/span&gt; shell command&lt;span&gt;.&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; inv &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;help&lt;/span&gt; greet
Usage&lt;span&gt;:&lt;/span&gt; inv&lt;span&gt;[&lt;/span&gt;oke&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;core&lt;span&gt;-&lt;/span&gt;opts&lt;span&gt;]&lt;/span&gt; greet &lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;options&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;other tasks here &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

Docstring&lt;span&gt;:&lt;/span&gt;
  A test &lt;span&gt;for&lt;/span&gt; shell command&lt;span&gt;.&lt;/span&gt;
  Second line&lt;span&gt;.&lt;/span&gt;

Options&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;-&lt;/span&gt;n STRING&lt;span&gt;,&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;name&lt;span&gt;=&lt;/span&gt;STRING   A param &lt;span&gt;for&lt;/span&gt; test&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;3.2 任务的分解与组合&lt;/h3&gt;
&lt;div&gt;通常一个大任务可以被分解成一组小任务，反过来，一系列的小任务也可能被串连成一个大任务。在对任务作分解、抽象与组合时，这里有两种思路：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;对内分解，对外统一：只定义一个 @task 的任务，作为总体的任务入口，实际的处理逻辑可以抽象成多个方法，但是外部不感知到它们&lt;/li&gt;
&lt;li&gt;多点呈现，单点汇总：定义多个 @task 的任务，外部可以感知并分别调用它们，同时将有关联的任务组合起来，调用某个任务时，也执行其它相关联的任务&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;第一种思路很容易理解，实现与使用都很简单，但是其缺点是缺少灵活性，难于单独执行其中的某个/些子任务。适用于相对独立的单个任务，通常也不需要 invoke 就能做到（使用 invoke 的好处是，拥有命令行的支持）。&lt;/div&gt;
&lt;div&gt;第二种思路更加灵活，既方便单一任务的执行，也方便多任务的组合执行。实际上，这种场景才是 invoke 发挥最大价值的场景。&lt;/div&gt;
&lt;div&gt;那么，invoke 如何实现分步任务的组合呢？可以在 @task 装饰器的“pre”与“post”参数中指定，分别表示前置任务与后置任务：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;@task&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;clean&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    c&lt;span&gt;.&lt;/span&gt;run&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;echo clean&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;@task&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;message&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    c&lt;span&gt;.&lt;/span&gt;run&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;echo message&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;@task&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;pre&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;clean&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; post&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;message&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;build&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    c&lt;span&gt;.&lt;/span&gt;run&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;echo build&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;clean 与 message 任务作为子任务，可以单独调用，也可以作为 build 任务的前置与后置任务而组合使用：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; inv clean
clean
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; inv message
message
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; inv build
clean
build
message&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这两个参数是列表类型，即可设置多个任务。另外，在默认情况下，@task 装饰器的位置参数会被视为前置任务，接着上述代码，我们写一个：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;@task&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;clean&lt;span&gt;,&lt;/span&gt; message&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    c&lt;span&gt;.&lt;/span&gt;run&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;echo test&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;然后执行，会发现两个参数都被视为了前置任务：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; inv test
clean
message
test&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;3.3 模块的拆分与整合&lt;/h3&gt;
&lt;div&gt;如果要管理很多相对独立的大型任务，或者需要多个团队分别维护各自的任务，那么，就有必要对 tasks.py 作拆分与整合。&lt;/div&gt;
&lt;div&gt;例如，现在有多份 tasks.py，彼此是相对完整而独立的任务模块，不方便把所有内容都放在一个文件中，那么，如何有效地把它们整合起来管理呢？&lt;/div&gt;
&lt;div&gt;invoke 提供了这方面的支持。首先，只能保留一份名为“tasks.py”的文件，其次，在该文件中导入其它改名后的任务文件，最后，使用 invoke 的 Collection 类把它们关联起来。&lt;/div&gt;
&lt;div&gt;我们把本文中第一个示例文件改名为 task1.py，并新建一个 tasks.py 文件，内容如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 文件名：tasks.py&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; invoke &lt;span&gt;import&lt;/span&gt; Collection&lt;span&gt;,&lt;/span&gt; task
&lt;span&gt;import&lt;/span&gt; task1

&lt;span&gt;@task&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;deploy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    c&lt;span&gt;.&lt;/span&gt;run&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;echo deploy&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

namespace &lt;span&gt;=&lt;/span&gt; Collection&lt;span&gt;(&lt;/span&gt;task1&lt;span&gt;,&lt;/span&gt; deploy&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;每个 py 文件拥有独立的命名空间，而在此处，我们用 Collection 可以创建出一个新的命名空间，从而实现对所有任务的统一管理。效果如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; inv &lt;span&gt;-&lt;/span&gt;l
Available tasks&lt;span&gt;:&lt;/span&gt;

  deploy
  task1&lt;span&gt;.&lt;/span&gt;greet
  task1&lt;span&gt;.&lt;/span&gt;hello
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; inv deploy
deploy
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; inv task1&lt;span&gt;.&lt;/span&gt;hello
Hello world!
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; inv task1&lt;span&gt;.&lt;/span&gt;greet 武汉
武汉加油!&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;关于不同任务模块的导入、嵌套、混合、起别名等内容，还有不少细节，请查阅&lt;a href=&quot;http://docs.pyinvoke.org/en/stable/concepts/namespaces.html&quot;&gt;官方文档&lt;/a&gt;了解。&lt;/div&gt;
&lt;h3&gt;3.4 交互式操作&lt;/h3&gt;
&lt;div&gt;某些任务可能需要交互式的输入，例如要求输入“y”，按回车键后才会继续执行。如果在任务执行期间需要人工参与，那自动化任务的能力将大打折扣。&lt;/div&gt;
&lt;div&gt;invoke 提供了在程序运行期的监控能力，可以监听&lt;code&gt;stdout&lt;/code&gt; 和&lt;code&gt;stderr&lt;/code&gt; ，并支持在&lt;code&gt;stdin&lt;/code&gt; 中输入必要的信息。&lt;/div&gt;
&lt;div&gt;例如，假设某个任务（excitable-program）在执行时会提示“Are you ready? [y/n]”，只有输入了“y”并按下回车键，才会执行后续的操作。&lt;/div&gt;
&lt;div&gt;那么，在代码中指定 responses 参数的内容，只要监听到匹配信息，程序会自动执行相应的操作：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;responses &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;r&quot;Are you ready? \[y/n\] &quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;y\n&quot;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
ctx&lt;span&gt;.&lt;/span&gt;run&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;excitable-program&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; responses&lt;span&gt;=&lt;/span&gt;responses&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;responses 是字典类型，键值对分别为监听内容及其回应内容。需注意，键值会被视为正则表达式，所以像本例中的方括号就要先转义。&lt;/div&gt;
&lt;h3&gt;3.5 作为命令行工具库&lt;/h3&gt;
&lt;div&gt;Python 中有不少好用的命令行工具库，比如标准库中的&lt;code&gt;argparse&lt;/code&gt;、Flask 作者开源的&lt;code&gt;click&lt;/code&gt; 与谷歌开源的&lt;code&gt;fire&lt;/code&gt; 等等，而 invoke 也可以作为命令行工具库使用。&lt;/div&gt;
&lt;div&gt;（PS：有位 Prodesire 同学写了“Python 命令行之旅”的系列文章，详细介绍了其它几个命令行工具库的用法，我在公众号“Python猫”里转载过大部分，感兴趣的同学可查看历史文章。）&lt;/div&gt;
&lt;div&gt;事实上，Fabric 项目最初把 invoke 分离成独立的库，就是想让它承担解析命令行与执行子命令的任务。所以，除了作为自动化任务管理工具，invoke 也可以被用于开发命令行工具。&lt;/div&gt;
&lt;div&gt;官方文档中给出了一个示例，我们可以了解到它的基本用法。&lt;/div&gt;
&lt;div&gt;假设我们要开发一个 tester 工具，让用户&lt;code&gt;pip install tester&lt;/code&gt; 安装，而此工具提供两个执行命令：&lt;code&gt;tester unit&lt;/code&gt; 和&lt;code&gt;tester intergration&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;这两个子命令需要在 tasks.py 文件中定义：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# tasks.py&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; invoke &lt;span&gt;import&lt;/span&gt; task

&lt;span&gt;@task&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;unit&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Running unit tests!&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;@task&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;integration&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Running integration tests!&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;然后在程序入口文件中引入它：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# main.py&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; invoke &lt;span&gt;import&lt;/span&gt; Collection&lt;span&gt;,&lt;/span&gt; Program
&lt;span&gt;from&lt;/span&gt; tester &lt;span&gt;import&lt;/span&gt; tasks

program &lt;span&gt;=&lt;/span&gt; Program&lt;span&gt;(&lt;/span&gt;namespace&lt;span&gt;=&lt;/span&gt;Collection&lt;span&gt;.&lt;/span&gt;from_module&lt;span&gt;(&lt;/span&gt;tasks&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; version&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;0.1.0&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;最后在打包文件中声明入口函数：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# setup.py&lt;/span&gt;
setup&lt;span&gt;(&lt;/span&gt;
    name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;tester&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    version&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;0.1.0&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    packages&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;tester&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    install_requires&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;invoke&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    entry_points&lt;span&gt;=&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;&apos;console_scripts&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;tester = tester.main:program.run&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;如此打包发行的库，就是一个功能齐全的命令行工具了：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;$ tester &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;version
Tester &lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;
$ tester &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;help&lt;/span&gt;
Usage&lt;span&gt;:&lt;/span&gt; tester &lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;core&lt;span&gt;-&lt;/span&gt;opts&lt;span&gt;]&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;subcommand&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;subcommand&lt;span&gt;-&lt;/span&gt;opts&lt;span&gt;]&lt;/span&gt; &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

Core options&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt; core options here&lt;span&gt;,&lt;/span&gt; minus task&lt;span&gt;-&lt;/span&gt;related ones &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

Subcommands&lt;span&gt;:&lt;/span&gt;
  unit
  integration

$ tester &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;
No idea what &lt;span&gt;&apos;--list&apos;&lt;/span&gt; &lt;span&gt;is&lt;/span&gt;!
$ tester unit
Running unit tests!&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上手容易，开箱即用，invoke 不失为一款可以考虑的命令行工具库。更多详细用法，请查阅&lt;a href=&quot;http://docs.pyinvoke.org/en/stable/concepts/library.html&quot;&gt;文档&lt;/a&gt; 。&lt;/div&gt;
&lt;h2&gt;4、小结&lt;/h2&gt;
&lt;div&gt;invoke 作为从 Fabric 项目中分离出来的独立项目，它自身具备一些完整而强大的功能，除了可用于开发命令行工具，它还是著名的任务自动化工具。&lt;/div&gt;
&lt;div&gt;本文介绍了它的基础用法与 5 个方面的中级内容，相信读者们会对它产生一定的了解。invoke 的官方文档十分详尽，限于篇幅，本文不再详细展开，若感兴趣，请自行&lt;a href=&quot;http://docs.pyinvoke.org/en/stable/index.html&quot;&gt;查阅文档&lt;/a&gt;哦。&lt;/div&gt;
&lt;div&gt;--------------&lt;/div&gt;
&lt;div&gt;公众号：Python猫（ID: python_cat）&lt;/div&gt;
&lt;div&gt;头条号：Python猫&lt;/div&gt;
&lt;div&gt;知乎：豌豆花下猫&lt;/div&gt;
&lt;div&gt;掘金：豌豆花下猫&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>你可能不知道的 Python 技巧</title>
            <link>https://pythoncat.top/posts/2020-01-28-tips/</link>
            <guid>https://pythoncat.top/posts/2020-01-28-tips/</guid>
            <pubDate>Tue, 28 Jan 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;英文&lt;/strong&gt; | &lt;a href=&quot;https://martinheinz.dev/blog/1&quot;&gt;Python Tips and Trick, You Haven’t Already Seen&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;原作&lt;/strong&gt; | Martin Heinz (&lt;a href=&quot;https://martinheinz.dev&quot;&gt;https://martinheinz.dev&lt;/a&gt;)&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; | 豌豆花下猫&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;声明&lt;/strong&gt; ：本文获得原作者授权翻译，转载请保留原文出处，请勿用于商业或非法用途。&lt;/div&gt;
&lt;div&gt;有许许多多文章写了 Python 中的许多很酷的特性，例如变量解包、偏函数、枚举可迭代对象，但是关于 Python 还有很多要讨论的话题，因此在本文中，我将尝试展示一些我知道的和在使用的，但很少在其它文章提到过的特性。那就开始吧。&lt;/div&gt;
&lt;h2&gt;1、对输入的字符串“消毒”&lt;/h2&gt;
&lt;div&gt;对用户输入的内容“消毒”，这问题几乎适用于你编写的所有程序。通常将字符转换为小写或大写就足够了，有时你还可以使用正则表达式来完成工作，但是对于复杂的情况，还有更好的方法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;user_input &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;This\nstring has\tsome whitespaces...\r\n&quot;&lt;/span&gt;

character_map &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
 &lt;span&gt;ord&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;\n&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos; &apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
 &lt;span&gt;ord&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;\t&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos; &apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
 &lt;span&gt;ord&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;\r&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
user_input&lt;span&gt;.&lt;/span&gt;translate&lt;span&gt;(&lt;/span&gt;character_map&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# This string has some whitespaces... &quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在此示例中，你可以看到空格字符“ \n”和“ \t”被单个空格替换了，而“ \r”则被完全删除。这是一个简单的示例，但是我们可以更进一步，使用&lt;code&gt;unicodedata&lt;/code&gt; 库及其 combining() 函数，来生成更大的重映射表（remapping table），并用它来删除字符串中所有的重音。&lt;/div&gt;
&lt;h2&gt;2、对迭代器切片&lt;/h2&gt;
&lt;div&gt;如果你尝试直接对迭代器切片，则会得到 TypeError ，提示说该对象不可取下标（not subscriptable），但是有一个简单的解决方案：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; itertools

s &lt;span&gt;=&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;islice&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# &amp;lt;itertools.islice object at 0x7f70fab88138&amp;gt;&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; val &lt;span&gt;in&lt;/span&gt; s&lt;span&gt;:&lt;/span&gt;
 &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;使用&lt;code&gt;itertools.islice&lt;/code&gt;，我们可以创建一个 islice 对象，该对象是一个迭代器，可以生成我们所需的内容。但是这有个重要的提醒，即它会消耗掉切片前以及切片对象 islice 中的所有元素。&lt;/div&gt;
&lt;div&gt;（译注：更多关于迭代器切片的内容，可阅读 &lt;a href=&quot;https://mp.weixin.qq.com/s/DIhwoJE3o0kKw3kzZKysag&quot;&gt;Python进阶：迭代器与迭代器切片&lt;/a&gt;）&lt;/div&gt;
&lt;h2&gt;3、跳过可迭代对象的开始&lt;/h2&gt;
&lt;div&gt;有时候你必须处理某些文件，它们以可变数量的不需要的行（例如注释）为开头。 itertools 再次提供了简单的解决方案：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;string_from_file &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;
// Author: ...
// License: ...
//
// Date: ...

Actual content...
&quot;&quot;&quot;&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt; itertools

&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;dropwhile&lt;span&gt;(&lt;/span&gt;&lt;span&gt;lambda&lt;/span&gt; line&lt;span&gt;:&lt;/span&gt;line&lt;span&gt;.&lt;/span&gt;startswith&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;//&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; string_from_file&lt;span&gt;.&lt;/span&gt;split&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;\n&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;line&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这段代码仅会打印在初始的注释部分之后的内容。如果我们只想丢弃迭代器的开头部分（在此例中是注释），并且不知道有多少内容，那么此方法很有用。&lt;/div&gt;
&lt;h2&gt;4、仅支持关键字参数（kwargs）的函数&lt;/h2&gt;
&lt;div&gt;当需要函数提供（强制）更清晰的参数时，创建仅支持关键字参数的函数，可能会挺有用：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; a&lt;span&gt;,&lt;/span&gt; b&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
 &lt;span&gt;pass&lt;/span&gt;

test&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;value for a&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;value for b&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# TypeError: test() takes 0 positional arguments...&lt;/span&gt;
test&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;value&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; b&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;value 2&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# Works...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;如你所见，可以在关键字参数之前，放置单个 * 参数来轻松解决此问题。如果我们将位置参数放在 * 参数之前，则显然也可以有位置参数。&lt;/div&gt;
&lt;h2&gt;5、创建支持 with 语句的对象&lt;/h2&gt;
&lt;div&gt;我们都知道如何使用 with 语句，例如打开文件或者是获取锁，但是我们可以实现自己的么？是的，我们可以使用__enter__ 和__exit__ 方法来实现上下文管理器协议：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
 &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;

 &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__enter__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;# Initialize connection...&lt;/span&gt;

 &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__exit__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; traceback&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;# Close connection...&lt;/span&gt;

&lt;span&gt;with&lt;/span&gt; Connection&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; c&lt;span&gt;:&lt;/span&gt;
 &lt;span&gt;# __enter__() executes&lt;/span&gt;
 &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
 &lt;span&gt;# conn.__exit__() executes&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这是在 Python 中实现上下文管理的最常见方法，但是还有一种更简单的方法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; contextlib &lt;span&gt;import&lt;/span&gt; contextmanager

&lt;span&gt;@contextmanager&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;tag&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
 &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;&amp;lt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;name&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
 &lt;span&gt;yield&lt;/span&gt;
 &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;&amp;lt;/&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;name&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;with&lt;/span&gt; tag&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;h1&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
 &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;This is Title.&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上面的代码段使用 contextmanager 装饰器实现了内容管理协议。tag 函数的第一部分（yield 之前）会在进入 with 语句时执行，然后执行 with 的代码块，最后会执行 tag 函数的剩余部分。&lt;/div&gt;
&lt;h2&gt;5、用__slots__节省内存&lt;/h2&gt;
&lt;div&gt;如果你曾经编写过一个程序，该程序创建了某个类的大量实例，那么你可能已经注意到你的程序突然就需要大量内存。那是因为 Python 使用字典来表示类实例的属性，这能使其速度变快，但内存不是很高效。通常这不是个问题，但是，如果你的程序遇到了问题，你可以尝试使用__slots__ ：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    __slots__ &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;first_name&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;last_name&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;phone&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; first_name&lt;span&gt;,&lt;/span&gt; last_name&lt;span&gt;,&lt;/span&gt; phone&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    self&lt;span&gt;.&lt;/span&gt;first_name &lt;span&gt;=&lt;/span&gt; first_name
    self&lt;span&gt;.&lt;/span&gt;last_name &lt;span&gt;=&lt;/span&gt; last_name
    self&lt;span&gt;.&lt;/span&gt;phone &lt;span&gt;=&lt;/span&gt; phone&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这里发生的是，当我们定义__slots__属性时，Python 使用固定大小的小型数组，而不是字典，这大大减少了每个实例所需的内存。使用__slots__还有一些缺点——我们无法声明任何新的属性，并且只能使用在__slots__中的属性。同样，带有__slots__的类不能使用多重继承。&lt;/div&gt;
&lt;h2&gt;6、限制CPU和内存使用量&lt;/h2&gt;
&lt;div&gt;如果不是想优化程序内存或 CPU 使用率，而是想直接将其限制为某个固定数字，那么 Python 也有一个库能做到：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; signal
&lt;span&gt;import&lt;/span&gt; resource
&lt;span&gt;import&lt;/span&gt; os

&lt;span&gt;# To Limit CPU time&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;time_exceeded&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;signo&lt;span&gt;,&lt;/span&gt; frame&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
 &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;CPU exceeded...&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
 &lt;span&gt;raise&lt;/span&gt; SystemExit&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;set_max_runtime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;seconds&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
 &lt;span&gt;# Install the signal handler and set a resource limit&lt;/span&gt;
 soft&lt;span&gt;,&lt;/span&gt; hard &lt;span&gt;=&lt;/span&gt; resource&lt;span&gt;.&lt;/span&gt;getrlimit&lt;span&gt;(&lt;/span&gt;resource&lt;span&gt;.&lt;/span&gt;RLIMIT_CPU&lt;span&gt;)&lt;/span&gt;
 resource&lt;span&gt;.&lt;/span&gt;setrlimit&lt;span&gt;(&lt;/span&gt;resource&lt;span&gt;.&lt;/span&gt;RLIMIT_CPU&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;seconds&lt;span&gt;,&lt;/span&gt; hard&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
 signal&lt;span&gt;.&lt;/span&gt;signal&lt;span&gt;(&lt;/span&gt;signal&lt;span&gt;.&lt;/span&gt;SIGXCPU&lt;span&gt;,&lt;/span&gt; time_exceeded&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# To limit memory usage&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;set_max_memory&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;size&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
 soft&lt;span&gt;,&lt;/span&gt; hard &lt;span&gt;=&lt;/span&gt; resource&lt;span&gt;.&lt;/span&gt;getrlimit&lt;span&gt;(&lt;/span&gt;resource&lt;span&gt;.&lt;/span&gt;RLIMIT_AS&lt;span&gt;)&lt;/span&gt;
 resource&lt;span&gt;.&lt;/span&gt;setrlimit&lt;span&gt;(&lt;/span&gt;resource&lt;span&gt;.&lt;/span&gt;RLIMIT_AS&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;size&lt;span&gt;,&lt;/span&gt; hard&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在这里，我们可以看到两个选项，可设置最大 CPU 运行时间和内存使用上限。对于 CPU 限制，我们首先获取该特定资源（RLIMIT_CPU）的软限制和硬限制，然后通过参数指定的秒数和先前获取的硬限制来设置它。最后，如果超过 CPU 时间，我们将注册令系统退出的信号。至于内存，我们再次获取软限制和硬限制，并使用带有 size 参数的&lt;code&gt;setrlimit&lt;/code&gt; 和获取的硬限制对其进行设置。&lt;/div&gt;
&lt;h2&gt;8、控制可以import的内容&lt;/h2&gt;
&lt;div&gt;某些语言具有非常明显的用于导出成员（变量、方法、接口）的机制，例如Golang，它仅导出以大写字母开头的成员。另一方面，在 Python 中，所有内容都会被导出，除非我们使用__all__ ：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;foo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
 &lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;bar&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
 &lt;span&gt;pass&lt;/span&gt;

__all__ &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;bar&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;使用上面的代码段，我们可以限制&lt;code&gt;from some_module import *&lt;/code&gt; 在使用时可以导入的内容。对于以上示例，通配导入时只会导入 bar。此外，我们可以将__all__ 设为空，令其无法导出任何东西，并且在使用通配符方式从此模块中导入时，将引发 AttributeError。&lt;/div&gt;
&lt;h2&gt;9、比较运算符的简便方法&lt;/h2&gt;
&lt;div&gt;为一个类实现所有比较运算符可能会很烦人，因为有很多的比较运算符——__lt__、__le__、__gt__ 或__ge__。但是，如果有更简单的方法呢？&lt;code&gt;functools.total_ordering&lt;/code&gt; 可救场：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt; total_ordering

&lt;span&gt;@total_ordering&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Number&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
 &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  self&lt;span&gt;.&lt;/span&gt;value &lt;span&gt;=&lt;/span&gt; value

 &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__lt__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; other&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;value &lt;span&gt;&amp;lt;&lt;/span&gt; other&lt;span&gt;.&lt;/span&gt;value

 &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__eq__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; other&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;value &lt;span&gt;==&lt;/span&gt; other&lt;span&gt;.&lt;/span&gt;value

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Number&lt;span&gt;(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; Number&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Number&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt; Number&lt;span&gt;(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Number&lt;span&gt;(&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;=&lt;/span&gt; Number&lt;span&gt;(&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Number&lt;span&gt;(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;=&lt;/span&gt; Number&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这到底如何起作用的？total_ordering 装饰器用于简化为我们的类实例实现排序的过程。只需要定义__lt__ 和__eq__，这是最低的要求，装饰器将映射剩余的操作——它为我们填补了空白。&lt;/div&gt;
&lt;div&gt;（ &lt;strong&gt;译注：&lt;/strong&gt; 原作者的文章分为两篇，为了方便读者们阅读，我特将它们整合在一起，以下便是第二篇的内容。）&lt;/div&gt;
&lt;h2&gt;10、使用slice函数命名切片&lt;/h2&gt;
&lt;div&gt;使用大量硬编码的索引值会很快搞乱维护性和可读性。一种做法是对所有索引值使用常量，但是我们可以做得更好：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# ID   First Name   Last Name&lt;/span&gt;
line_record &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;2        John         Smith&quot;&lt;/span&gt;

ID &lt;span&gt;=&lt;/span&gt; &lt;span&gt;slice&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;8&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
FIRST_NAME &lt;span&gt;=&lt;/span&gt; &lt;span&gt;slice&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
LAST_NAME &lt;span&gt;=&lt;/span&gt; &lt;span&gt;slice&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;27&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&lt;span&gt;f&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;line_record&lt;span&gt;[&lt;/span&gt;FIRST_NAME&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;strip&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;line_record&lt;span&gt;[&lt;/span&gt;LAST_NAME&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;strip&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;# name == &quot;John Smith&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在此例中，我们可以避免神秘的索引，方法是先使用 slice 函数命名它们，然后再使用它们。你还可以通过 .start、.stop和 .stop 属性，来了解 slice 对象的更多信息。&lt;/div&gt;
&lt;h2&gt;11、在运行时提示用户输入密码&lt;/h2&gt;
&lt;div&gt;许多命令行工具或脚本需要用户名和密码才能操作。因此，如果你碰巧写了这样的程序，你可能会发现 getpass 模块很有用：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; getpass

user &lt;span&gt;=&lt;/span&gt; getpass&lt;span&gt;.&lt;/span&gt;getuser&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
password &lt;span&gt;=&lt;/span&gt; getpass&lt;span&gt;.&lt;/span&gt;getpass&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# Do Stuff...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这个非常简单的包通过提取当前用户的登录名，可以提示用户输入密码。但是须注意，并非每个系统都支持隐藏密码。Python 会尝试警告你，因此切记在命令行中阅读警告信息。&lt;/div&gt;
&lt;h2&gt;12、查找单词/字符串的相近匹配&lt;/h2&gt;
&lt;div&gt;现在，关于 Python 标准库中一些晦涩难懂的特性。如果你发现自己需要使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Levenshtein_distance&quot;&gt;Levenshtein distance&lt;/a&gt; 【2】之类的东西，来查找某些输入字符串的相似单词，那么 Python 的 difflib 会为你提供支持。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; difflib
difflib&lt;span&gt;.&lt;/span&gt;get_close_matches&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;appel&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;ape&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;apple&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;peach&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;puppy&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; n&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# returns [&apos;apple&apos;, &apos;ape&apos;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;difflib.get_close_matches 会查找最佳的“足够好”的匹配。在这里，第一个参数与第二个参数匹配。我们还可以提供可选参数 n ，该参数指定要返回的最多匹配结果。另一个可选的关键字参数 cutoff （默认值为 0.6），可以设置字符串匹配得分的阈值。&lt;/div&gt;
&lt;h2&gt;13、使用IP地址&lt;/h2&gt;
&lt;div&gt;如果你必须使用 Python 做网络开发，你可能会发现 ipaddress 模块非常有用。一种场景是从 CIDR（无类别域间路由 Classless Inter-Domain Routing）生成一系列 IP 地址：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; ipaddress
net &lt;span&gt;=&lt;/span&gt; ipaddress&lt;span&gt;.&lt;/span&gt;ip_network&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;74.125.227.0/29&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# Works for IPv6 too&lt;/span&gt;
&lt;span&gt;# IPv4Network(&apos;74.125.227.0/29&apos;)&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; addr &lt;span&gt;in&lt;/span&gt; net&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;addr&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 74.125.227.0&lt;/span&gt;
&lt;span&gt;# 74.125.227.1&lt;/span&gt;
&lt;span&gt;# 74.125.227.2&lt;/span&gt;
&lt;span&gt;# 74.125.227.3&lt;/span&gt;
&lt;span&gt;# ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;另一个不错的功能是检查 IP 地址的网络成员资格：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;ip &lt;span&gt;=&lt;/span&gt; ipaddress&lt;span&gt;.&lt;/span&gt;ip_address&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;74.125.227.3&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

ip &lt;span&gt;in&lt;/span&gt; net
&lt;span&gt;# True&lt;/span&gt;

ip &lt;span&gt;=&lt;/span&gt; ipaddress&lt;span&gt;.&lt;/span&gt;ip_address&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;74.125.227.12&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
ip &lt;span&gt;in&lt;/span&gt; net
&lt;span&gt;# False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;还有很多有趣的功能，&lt;a href=&quot;https://docs.python.org/3/howto/ipaddress.html&quot;&gt;在这里&lt;/a&gt;【3】可以找到，我不再赘述。但是请注意，ipaddress 模块和其它与网络相关的模块之间只有有限的互通性。例如，你不能将 IPv4Network 实例当成地址字符串——需要先使用 str 转换它们。&lt;/div&gt;
&lt;h2&gt;14、在Shell中调试程序崩溃&lt;/h2&gt;
&lt;div&gt;如果你是一个拒绝使用 IDE，并在 Vim 或 Emacs 中进行编码的人，那么你可能会遇到这样的情况：拥有在 IDE 中那样的调试器会很有用。&lt;/div&gt;
&lt;div&gt;你知道吗？你有一个——只要用&lt;code&gt;python3.8 -i&lt;/code&gt; 运行你的程序——一旦你的程序终止了， -i 会启动交互式 shell，在那你可以查看所有的变量和调用函数。整洁，但是使用实际的调试器（pdb ）会如何呢？让我们用以下程序（script.py ）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;def func():
    return 0 / 0

func()&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;并使用&lt;code&gt;python3.8 -i script.py&lt;/code&gt;运行脚本：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# Script crashes...&lt;/span&gt;
Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  File &lt;span&gt;&quot;script.py&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; line &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;module&lt;span&gt;&amp;gt;&lt;/span&gt;
    func&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  File &lt;span&gt;&quot;script.py&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; line &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; func
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
ZeroDivisionError&lt;span&gt;:&lt;/span&gt; division by zero
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; pdb
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; pdb&lt;span&gt;.&lt;/span&gt;pm&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# Post-mortem debugger&lt;/span&gt;
&lt;span&gt;&amp;gt;&lt;/span&gt; script&lt;span&gt;.&lt;/span&gt;py&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;func&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;(&lt;/span&gt;Pdb&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我们看到了崩溃的地方，现在让我们设置一个断点：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    breakpoint&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# import pdb; pdb.set_trace()&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;

func&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;现在再次运行它：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;script&lt;span&gt;.&lt;/span&gt;py&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;func&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;(&lt;/span&gt;Pdb&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# we start here&lt;/span&gt;
&lt;span&gt;(&lt;/span&gt;Pdb&lt;span&gt;)&lt;/span&gt; step
ZeroDivisionError&lt;span&gt;:&lt;/span&gt; division by zero
&lt;span&gt;&amp;gt;&lt;/span&gt; script&lt;span&gt;.&lt;/span&gt;py&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;func&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;(&lt;/span&gt;Pdb&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;大多数时候，打印语句和错误信息就足以进行调试，但是有时候，你需要四处摸索，以了解程序内部正在发生的事情。在这些情况下，你可以设置断点，然后程序执行时将在断点处停下，你可以检查程序，例如列出函数参数、表达式求值、列出变量、或如上所示仅作单步执行。&lt;/div&gt;
&lt;div&gt;pdb 是功能齐全的 Python shell，理论上你可以执行任何东西，但是你还需要一些调试命令，可在&lt;a href=&quot;https://docs.python.org/3/library/pdb.html%23debugger-commands#debugger-commands&quot;&gt;此处&lt;/a&gt;【4】找到。&lt;/div&gt;
&lt;h2&gt;15、在一个类中定义多个构造函数&lt;/h2&gt;
&lt;div&gt;函数重载是编程语言（不含 Python）中非常常见的功能。即使你不能重载正常的函数，你仍然可以使用类方法重载构造函数：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; datetime

&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; year&lt;span&gt;,&lt;/span&gt; month&lt;span&gt;,&lt;/span&gt; day&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;year &lt;span&gt;=&lt;/span&gt; year
        self&lt;span&gt;.&lt;/span&gt;month &lt;span&gt;=&lt;/span&gt; month
        self&lt;span&gt;.&lt;/span&gt;day &lt;span&gt;=&lt;/span&gt; day

    &lt;span&gt;@classmethod&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;today&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;cls&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        t &lt;span&gt;=&lt;/span&gt; datetime&lt;span&gt;.&lt;/span&gt;datetime&lt;span&gt;.&lt;/span&gt;now&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; cls&lt;span&gt;(&lt;/span&gt;t&lt;span&gt;.&lt;/span&gt;year&lt;span&gt;,&lt;/span&gt; t&lt;span&gt;.&lt;/span&gt;month&lt;span&gt;,&lt;/span&gt; t&lt;span&gt;.&lt;/span&gt;day&lt;span&gt;)&lt;/span&gt;

d &lt;span&gt;=&lt;/span&gt; Date&lt;span&gt;.&lt;/span&gt;today&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;d&lt;span&gt;.&lt;/span&gt;day&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;d&lt;span&gt;.&lt;/span&gt;month&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;d&lt;span&gt;.&lt;/span&gt;year&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# 14/9/2019&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;你可能倾向于将替代构造函数的所有逻辑放入__init__，并使用&lt;code&gt;*args&lt;/code&gt; 、&lt;code&gt;**kwargs&lt;/code&gt; 和一堆 if 语句，而不是使用类方法来解决。那可能行得通，但是却变得难以阅读和维护。&lt;/div&gt;
&lt;div&gt;因此，我建议将很少的逻辑放入__init__，并在单独的方法/构造函数中执行所有操作。这样，对于类的维护者和用户而言，得到的都是干净的代码。&lt;/div&gt;
&lt;h2&gt;16、使用装饰器缓存函数调用&lt;/h2&gt;
&lt;div&gt;你是否曾经编写过一种函数，它执行昂贵的 I/O 操作或一些相当慢的递归，而且该函数可能会受益于对其结果进行缓存（存储）？如果你有，那么有简单的解决方案，即使用 functools 的&lt;code&gt;lru_cache&lt;/code&gt; :&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt; lru_cache
&lt;span&gt;import&lt;/span&gt; requests

&lt;span&gt;@lru_cache&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;maxsize&lt;span&gt;=&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;get_with_cache&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;url&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        r &lt;span&gt;=&lt;/span&gt; requests&lt;span&gt;.&lt;/span&gt;get&lt;span&gt;(&lt;/span&gt;url&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; r&lt;span&gt;.&lt;/span&gt;text
    &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Not Found&quot;&lt;/span&gt;


&lt;span&gt;for&lt;/span&gt; url &lt;span&gt;in&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;https://google.com/&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
            &lt;span&gt;&quot;https://martinheinz.dev/&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
            &lt;span&gt;&quot;https://reddit.com/&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
            &lt;span&gt;&quot;https://google.com/&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
            &lt;span&gt;&quot;https://dev.to/martinheinz&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
            &lt;span&gt;&quot;https://google.com/&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    get_with_cache&lt;span&gt;(&lt;/span&gt;url&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;get_with_cache&lt;span&gt;.&lt;/span&gt;cache_info&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# CacheInfo(hits=2, misses=4, maxsize=32, currsize=4)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在此例中，我们用了可缓存的 GET 请求（最多 32 个缓存结果）。你还可以看到，我们可以使用 cache_info 方法检查函数的缓存信息。装饰器还提供了 clear_cache 方法，用于使缓存结果无效。&lt;/div&gt;
&lt;div&gt;我还想指出，此函数不应与具有副作用的函数一起使用，或与每次调用都创建可变对象的函数一起使用。&lt;/div&gt;
&lt;h2&gt;17、在可迭代对象中查找最频繁出现的元素&lt;/h2&gt;
&lt;div&gt;在列表中查找最常见的元素是非常常见的任务，你可以使用 for 循环和字典（map），但是这没必要，因为 collections 模块中有 Counter 类：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt; Counter

cheese &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;gouda&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;brie&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;feta&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;cream cheese&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;feta&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;cheddar&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
          &lt;span&gt;&quot;parmesan&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;parmesan&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;cheddar&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;mozzarella&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;cheddar&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;gouda&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
          &lt;span&gt;&quot;parmesan&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;camembert&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;emmental&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;camembert&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;parmesan&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

cheese_count &lt;span&gt;=&lt;/span&gt; Counter&lt;span&gt;(&lt;/span&gt;cheese&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;cheese_count&lt;span&gt;.&lt;/span&gt;most_common&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# Prints: [(&apos;parmesan&apos;, 4), (&apos;cheddar&apos;, 3), (&apos;gouda&apos;, 2)]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;实际上，Counter 只是一个字典，将元素与出现次数映射起来，因此你可以将其用作普通字典：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;cheese_count&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;mozzarella&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# Prints: 1&lt;/span&gt;

cheese_count&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;mozzarella&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;cheese_count&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;mozzarella&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# Prints: 2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;除此之外，你还可以使用 update(more_words) 方法轻松添加更多元素。Counter 的另一个很酷的特性是你可以使用数学运算（加法和减法）来组合和减去 Counter 的实例。&lt;/div&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;div&gt;在日常 Python 编程中，并非所有这些特性都是必不可少的和有用的，但是其中一些特性可能会时不时派上用场，并且它们也可能简化任务，而这本来可能很冗长且令人讨厌。&lt;/div&gt;
&lt;div&gt;我还要指出的是，所有这些特性都是 Python 标准库的一部分，虽然在我看来，其中一些特性非常像是标准库中的非标准内容。因此，每当你要在 Python 中实现某些功能时，首先可在标准库查看，如果找不到，那你可能看得还不够仔细（如果它确实不存在，那么肯定在某些三方库中）。&lt;/div&gt;
&lt;div&gt;如果你使用 Python，那么我认为在这里分享的大多数技巧几乎每天都会有用，因此我希望它们会派上用场。另外，如果你对这些 Python 技巧和骚操作有任何想法，或者如果你知道解决上述问题的更好方法，请告诉我！🙂&lt;/div&gt;
&lt;h3&gt;相关链接&lt;/h3&gt;
&lt;div&gt;[1] 原文地址: &lt;a href=&quot;https://martinheinz.dev/blog/1&quot;&gt;https://martinheinz.dev/blog/1&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;译文原文：&lt;a href=&quot;https://mp.weixin.qq.com/s/vaFL75hm1lx3mvURY4V6_A&quot;&gt;https://mp.weixin.qq.com/s/vaFL75hm1lx3mvURY4V6_A&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[2] Levenshtein distance: &lt;a href=&quot;https://en.wikipedia.org/wiki/Levenshtein_distance&quot;&gt;https://en.wikipedia.org/wiki/Levenshtein_distance&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[3] 在这里: &lt;a href=&quot;https://docs.python.org/3/howto/ipaddress.html&quot;&gt;https://docs.python.org/3/howto/ipaddress.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[4] 此处: &lt;a href=&quot;https://docs.python.org/3/library/pdb.html%23debugger-commands#debugger-commands&quot;&gt;https://docs.python.org/3/library/pdb.html%23debugger-commands#debugger-commands&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Flask 作者 Armin Ronacher：我不觉得有 async 压力</title>
            <link>https://pythoncat.top/posts/2020-01-11-flask/</link>
            <guid>https://pythoncat.top/posts/2020-01-11-flask/</guid>
            <pubDate>Sat, 11 Jan 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;英文&lt;/strong&gt; | &lt;a href=&quot;https://lucumr.pocoo.org/2020/1/1/async-pressure/&quot;&gt;I’m not feeling the async pressure&lt;/a&gt;【1】&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;原作&lt;/strong&gt; | Armin Ronacher，2020.01.01&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; | 豌豆花下猫@Python猫&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;声明&lt;/strong&gt; ：本翻译基于&lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt;【2】授权协议，内容略有改动，转载请保留原文出处，请勿用于商业或非法用途。&lt;/div&gt;
&lt;div&gt;异步（async）正风靡一时。异步Python、异步Rust、go、node、.NET，任选一个你最爱的语言生态，它都在使用着一些异步。异步这东西有多好，这在很大程度上取决于语言的生态及其运行时间，但总体而言，它有一些不错的好处。它使得这种事情变得非常简单：等待可能需要一些时间才能完成的操作。&lt;/div&gt;
&lt;div&gt;它是如此简单，以至于创造了无数新的方法来坑人（blow ones foot off）。我想讨论的一种情况是，直到系统出现超载，你才意识到自己踩到了脚的那一种，这就是背压（back pressure）管理的主题。在协议设计中有一个相关术语是流量控制（flow control）。&lt;/div&gt;
&lt;h2&gt;什么是背压&lt;/h2&gt;
&lt;div&gt;关于背压的解释有很多，我推荐阅读的一个很好的解释是：&lt;a href=&quot;https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7&quot;&gt;Backpressure explained — the resisted flow of data through software&lt;/a&gt;【3】。因此，与其详细介绍什么是背压，我只想对其做一个非常简短的定义和解释：背压是阻碍数据在系统中流通的阻力。背压听起来很负面——谁都会想象浴缸因管道堵塞而溢出——但这是为了节省你的时间。&lt;/div&gt;
&lt;div&gt;（译注：back pressure，除了背压，还有人译为“回压”、“反压”）&lt;/div&gt;
&lt;div&gt;在这里，我们要处理的东西在所有情况下或多或少都是相同的：我们有一个系统将不同组件组合成一个管道，而该管道需要接收一定数量的传入消息。&lt;/div&gt;
&lt;div&gt;你可以想象这就像在机场模拟行李运送一样。行李到达，经过分类，装入飞机，最后卸下。在这过程中，一件行李要跟其它行李一起，被扔进集装箱进行运输。当一个集装箱装满后，需要将其运走。当没有剩余的集装箱时，这就是背压的自然示例。现在，放行李者不能放了，因为没有集装箱。&lt;/div&gt;
&lt;div&gt;此时必须做出决定。一种选择是等待：这通常被称为排队（queueing ）或缓冲（buffering）。另一种选择是扔掉一些行李，直到有一个集装箱到达为止——这被称为丢弃（dropping）。这听起来很糟糕，但是稍后我们将探讨为什么有时很重要。&lt;/div&gt;
&lt;div&gt;但是，这里还有另一件事。想象一下，负责将行李放入集装箱的人在较长的时间内（例如一周）都没等到集装箱。最终，如果他们没有丢弃行李，那么他们周围将有数量庞大的行李。最终，他们被迫要整理的行李数量太多，用光了存储行李的物理空间。到那时，他们最好是告诉机场，在解决好集装箱问题之前，不能再接收新的行李了。这通常被称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Flow_control_(data)&quot;&gt;流量控制&lt;/a&gt;【4】，是一个至关重要的网络概念。&lt;/div&gt;
&lt;div&gt;通常这些处理管道在每段时间内只能容纳一定数量的消息（如本例中的行李箱）。如果数量超过了它，或者更糟糕的是管道停滞，则可能发生可怕的事情。现实世界中的一个例子是伦敦希思罗机场 5 号航站楼开放，由于其 IT 基础架构无法正常运行，在 10 天内未能完成运送 42,000 件行李。他们不得不取消 500 多个航班，并且有一段时间，航空公司决定只允许随身携带行李。&lt;/div&gt;
&lt;h2&gt;背压很重要&lt;/h2&gt;
&lt;div&gt;我们从希思罗灾难中学到的是，能够交流背压至关重要。在现实生活中以及在计算中，时间总是有限的。最终人们会放弃等待某些事情。特别是即使某些事物在内部可以永远等待，但在外部却不能。&lt;/div&gt;
&lt;div&gt;举一个现实的例子：如果你的行李需通过伦敦希思罗机场到达目的地巴黎，但是你只能在那呆 7 天，那么如果行李延迟成 10 天到达，这就毫无意义了。实际上，你希望将行李重新路由（re-routed）回你的家乡机场。&lt;/div&gt;
&lt;div&gt;实际上，承认失败（你超负载了）比假装可运作并持续保持缓冲状态要好，因为到了某个时候，它只会令情况变得更糟。&lt;/div&gt;
&lt;div&gt;那么，为什么在我们编写了多年的基于线程的软件时，背压都没有被提出，现在却突然成为讨论的话题呢？有诸多因素的结合，其中一些因素很容易使人陷入困境。&lt;/div&gt;
&lt;h2&gt;糟糕的默认方式&lt;/h2&gt;
&lt;div&gt;为了理解为什么背压在异步代码中很重要，我想为你提供一段看似简单的 Python asyncio 代码，它展示了一些我们不慎忘记了背压的情况：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; asyncio &lt;span&gt;import&lt;/span&gt; start_server&lt;span&gt;,&lt;/span&gt; run

&lt;span&gt;async&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; &lt;span&gt;on_client_connected&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;reader&lt;span&gt;,&lt;/span&gt; writer&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        data &lt;span&gt;=&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; reader&lt;span&gt;.&lt;/span&gt;readline&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; data&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;
        writer&lt;span&gt;.&lt;/span&gt;write&lt;span&gt;(&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;async&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; &lt;span&gt;server&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    srv &lt;span&gt;=&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; start_server&lt;span&gt;(&lt;/span&gt;on_client_connected&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;127.0.0.1&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;8888&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;async&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; srv&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;await&lt;/span&gt; srv&lt;span&gt;.&lt;/span&gt;serve_forever&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

run&lt;span&gt;(&lt;/span&gt;server&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;如果你刚接触 async/await 概念，请想象一下在调用 await 的时候，函数会挂起，直到表达式解析完毕。在这里，Python 的 asyncio 库提供的 start_server 函数会运行一个隐藏的 accept 循环。它侦听套接字，并为每个连接的套接字生成一个独立的任务运行着 on_client_connected 函数。&lt;/div&gt;
&lt;div&gt;现在，这看起来非常简单明了。你可以删除所有的 await 和 async 关键字，最终的代码看起来与使用线程方式编写的代码非常相似。&lt;/div&gt;
&lt;div&gt;但是，它隐藏了一个非常关键的问题，这是我们所有问题的根源：在某些函数调用的前面没有 await。在线程代码中，任何函数都可以 yield。在异步代码中，只有异步函数可以。在本例中，这意味着 writer.write 方法无法阻塞。那么它是如何工作的呢？它将尝试将数据直接写入到操作系统的无阻塞套接字缓冲区中。&lt;/div&gt;
&lt;div&gt;但是，如果缓冲区已满并且套接字会阻塞，会发生什么？在用线程的情况下，我们可以在此处将其阻塞，这很理想，因为这意味着我们正在施加一些背压。然而，因为这里没有线程，所以我们不能这样做。因此，我们只能在此处进行缓冲或者删除数据。因为删除数据是非常糟糕的，所以 Python 选择了缓冲。&lt;/div&gt;
&lt;div&gt;现在，如果有人向其中发送了很多数据却没有读取，会发生什么？好了在那种情况下，缓冲区会增大，增大，再增大。这个 API 缺陷就是为什么 Python 的文档中说，不要只是单独使用 write，还要接着写 drain（译注：消耗、排水）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;writer&lt;span&gt;.&lt;/span&gt;write&lt;span&gt;(&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;await&lt;/span&gt; writer&lt;span&gt;.&lt;/span&gt;drain&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;drain 会排出缓冲区上多余的东西。它不会排空整个缓冲区，只会做到令事情不致失控的程度。那么为什么 write 不做隐式 drain 呢？好吧，这会是一个大规模的 API 监控，我不确定该如何做到。&lt;/div&gt;
&lt;div&gt;这里非常重要的是大多数套接字都基于 TCP，而 TCP 具有内置的流量控制。writer 只会按照 reader 可接受的速度写入（给予或占用一些缓冲空间）。这对开发者完全是隐藏的，因为甚至 BSD 套接字库都没有公开这种隐式的流量控制操作。&lt;/div&gt;
&lt;div&gt;那我们在这里解决背压问题了吗？好吧，让我们看一看在线程世界中会是怎样。在线程世界中，我们的代码很可能会运行固定数量的线程，而 accept 循环会一直等待，直到线程变得可用再接管请求。&lt;/div&gt;
&lt;div&gt;然而，在我们的异步示例中，有无数的连接要处理。这就意味着我们可能收到大量连接，即使这意味着系统可能会过载。在这个非常简单的示例中，可能不成问题，但请想象一下，如果我们做的是数据库访问，会发生什么。&lt;/div&gt;
&lt;div&gt;想象一个数据库连接池，它最多提供 50 个连接。当大多数连接会在连接池处阻塞时，接受 10000 个连接又有什么用？&lt;/div&gt;
&lt;h2&gt;等待与等待着等待&lt;/h2&gt;
&lt;div&gt;好啦，终于回到了我最初想讨论的地方。在大多数异步系统中，特别是我在 Python 中遇到的大多数情况中，即使你修复了所有套接字层的缓冲行为，也最终会陷入一个将一堆异步函数链接在一起，而不考虑背压的世界。&lt;/div&gt;
&lt;div&gt;如果我们以数据库连接池为例，假设只有 50 个可用连接。这意味着我们的代码最多可以有 50 个并发的数据库会话。假设我们希望处理 4 倍多的请求，因为我们期望应用程序执行的许多操作是独立于数据库的。一种解决方法是制作一个带有 200 个令牌的信号量（semaphore），并在开始时获取一个。如果我们用完了令牌，就需等待信号量发放令牌。&lt;/div&gt;
&lt;div&gt;但是等一下。现在我们又变成了排队！我们只是在更前面排。如果令系统严重超负荷，那么我们会从一开始就一直在排队。因此，现在每个人都将等待他们愿意等待的最大时间，然后放弃。更糟糕的是：服务器可能仍会花一段时间处理这些请求，直到它意识到客户端已消失，而且不再对响应感兴趣。&lt;/div&gt;
&lt;div&gt;因此，与其一直等待下去，我们更希望立即获得反馈。想象你在一个邮局，并且正在从机器上取票，票上会说什么时候轮到你。这张票很好地表明了你需要等待多长时间。如果等待时间太长，你会决定弃票走人，以后再来。请注意，你在邮局里的排队等待时间，与实际处理你的请求的时间无关（例如，因为有人需要提取包裹，检查文件并采集签名）。&lt;/div&gt;
&lt;div&gt;因此，这是天真的版本，我们只知道自己在等待：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; asyncio&lt;span&gt;.&lt;/span&gt;sync &lt;span&gt;import&lt;/span&gt; Semaphore

semaphore &lt;span&gt;=&lt;/span&gt; Semaphore&lt;span&gt;(&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;async&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; &lt;span&gt;handle_request&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;request&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;await&lt;/span&gt; semaphore&lt;span&gt;.&lt;/span&gt;acquire&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; generate_response&lt;span&gt;(&lt;/span&gt;request&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        semaphore&lt;span&gt;.&lt;/span&gt;release&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;对于 handle_request 异步函数的调用者，我们只能看到我们正在等待并且什么都没有发生。我们看不到是因为过载而在等待，还是因为生成响应需花费很长时间而在等待。基本上，我们一直在这里缓冲，直到服务器最终耗尽内存并崩溃。&lt;/div&gt;
&lt;div&gt;这是因为我们没有关于背压的沟通渠道。那么我们将如何解决呢？一种选择是添加一个中间层。现在不幸的是，这里的 asyncio 信号量没有用，因为它只会让我们等待。但是假设我们可以询问信号量还剩下多少个令牌，那么我们可以执行类似这样的操作：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; hypothetical_asyncio&lt;span&gt;.&lt;/span&gt;sync &lt;span&gt;import&lt;/span&gt; Semaphore&lt;span&gt;,&lt;/span&gt; Service

semaphore &lt;span&gt;=&lt;/span&gt; Semaphore&lt;span&gt;(&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RequestHandlerService&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Service&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;async&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; &lt;span&gt;handle&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; request&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;await&lt;/span&gt; semaphore&lt;span&gt;.&lt;/span&gt;acquire&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; generate_response&lt;span&gt;(&lt;/span&gt;request&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            semaphore&lt;span&gt;.&lt;/span&gt;release&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

    &lt;span&gt;@property&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;is_ready&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; semaphore&lt;span&gt;.&lt;/span&gt;tokens_available&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;现在，我们对系统做了一些更改。现在，我们有一个 RequestHandlerService，其中包含了更多信息。特别是它具有了准备就绪的概念。该服务可以被询问是否准备就绪。该操作在本质上是无阻塞的，并且是最佳估量。&lt;/div&gt;
&lt;div&gt;现在，调用者会将这个：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;response &lt;span&gt;=&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; handle_request&lt;span&gt;(&lt;/span&gt;request&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;变成这个：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;request_handler &lt;span&gt;=&lt;/span&gt; RequestHandlerService&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; request_handler&lt;span&gt;.&lt;/span&gt;is_ready&lt;span&gt;:&lt;/span&gt;
    response &lt;span&gt;=&lt;/span&gt; Response&lt;span&gt;(&lt;/span&gt;status_code&lt;span&gt;=&lt;/span&gt;&lt;span&gt;503&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    response &lt;span&gt;=&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; request_handler&lt;span&gt;.&lt;/span&gt;handle&lt;span&gt;(&lt;/span&gt;request&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;有多种方法可以完成，但是思想是一样的。在我们真正着手做某件事之前，我们有一种方法来弄清楚成功的可能性，如果我们超负荷了，我们将向上沟通。&lt;/div&gt;
&lt;div&gt;现在，我没有想到如何给这种服务下定义。其设计来自 Rust 的&lt;a href=&quot;https://github.com/tower-rs/tower&quot;&gt;tower&lt;/a&gt;【5】和 Rust 的&lt;a href=&quot;https://docs.rs/actix-service/&quot;&gt;actix-service&lt;/a&gt;【6】。两者对服务特征的定义都跟它非常相似。&lt;/div&gt;
&lt;div&gt;现在，由于它是如此的 racy，因此仍有可能堆积信号量。现在，你可以冒这种风险，或者还是在 handle 被调用时就抛出失败。&lt;/div&gt;
&lt;div&gt;一个比 asyncio 更好地解决此问题的库是 trio，它会在信号量上暴露内部计数器，并提供一个 CapacityLimiter，它是对容量限制做了优化的信号量，可以防止一些常见的陷阱。&lt;/div&gt;
&lt;h2&gt;数据流和协议&lt;/h2&gt;
&lt;div&gt;现在，上面的示例为我们解决了 RPC 样式的情况。对于每次调用，如果系统过载了，我们会尽早得知。许多协议都有非常直接的方式来传达“服务器正在加载”的信息。例如，在 HTTP 中，你可以发出 503，并在 header 中携带一个 retry-after 字段，它会告知客户端何时可以重试。在下次重试时会添加一个重新评估的自然点，判断是否要使用相同的请求重试，或者更改某些内容。例如，如果你无法在 15 秒内重试，那么最好向用户显示这种无能，而不是显示一个无休止的加载图标。&lt;/div&gt;
&lt;div&gt;但是，请求/响应（request/response）式的协议并不是唯一的协议。许多协议都打开了持久连接，让你传输大量的数据。在传统上，这些协议中有很多是基于 TCP 的，如前所述，它具有内置的流量控制。但是，此流量控制并没有真正通过套接字库公开，这就是为什么高级协议通常需要向其添加自己的流量控制的原因。例如，在 HTTP2 中，就存在一个自定义流量控制协议，因为 HTTP2 在单个 TCP 连接上，多路复用多个独立的数据流（streams）。&lt;/div&gt;
&lt;div&gt;因为 TCP 在后台对流量控制进行静默式管理，这可能会使开发人员陷入一条危险的道路，他们只知从套接字中读取字节，并误以为这是所有该知道的信息。但是，TCP API 具有误导性，因为从 API 角度来看，流量控制对用户完全是隐藏的。当你设计自己的基于数据流的协议时，你需要绝对确保存在双向通信通道，即发送方不仅要发送，还要读取，以查看是否允许它们继续发。&lt;/div&gt;
&lt;div&gt;对于数据流，关注点通常是不同的。许多数据流只是字节或数据帧的流，你不能仅在它们之间丢弃数据包。更糟糕的是：发送方通常不容易察觉到它们是否应该放慢速度。在 HTTP2 中，你需要在用户级别上不断交错地读写。你必然要在那里处理流量控制。当你在写并且被允许写入时，服务器将向你发送 WINDOW_UPDATE 帧。&lt;/div&gt;
&lt;div&gt;这意味着数据流代码变得更为复杂，因为你首先需要编写一个可以对传入流量作控制的框架。例如，&lt;a href=&quot;https://github.com/python-hyper/hyper-h2&quot;&gt;hyper-h2&lt;/a&gt;【7】Python 库具有令人惊讶的复杂的&lt;a href=&quot;https://python-hyper.org/projects/h2/en/stable/curio-example.html&quot;&gt;文件上传服务器示例，&lt;/a&gt;【8】该示例基于 curio 的流量控制，但是还未完成。&lt;/div&gt;
&lt;h2&gt;新步枪&lt;/h2&gt;
&lt;div&gt;async/await 很棒，但是它所鼓励编写的内容在过载时会导致灾难。一方面是因为它如此容易就排队，但同时因为在使函数变异步后，会造成 API 损坏。我只能假设这就是为什么 Python 在数据流 writer 上仍然使用不可等待的 write 函数。&lt;/div&gt;
&lt;div&gt;不过，最大的原因是 async/await 使你可以编写许多人最初无法用线程编写的代码。我认为这是一件好事，因为它降低了实际编写大型系统的障碍。其缺点是，这也意味着许多以前对分布式系统缺乏经验的开发人员现在即使只编写一个程序，也遇到了分布式系统的许多问题。由于多路复用的性质，HTTP2 是一种非常复杂的协议，唯一合理的实现方法是基于 async/await 的例子。&lt;/div&gt;
&lt;div&gt;遇到这些问题的不仅是 async/await 代码。例如，&lt;a href=&quot;https://dask.org/&quot;&gt;Dask&lt;/a&gt;【9】是数据科学程序员使用的 Python 并行库，尽管没有使用 async/await，但由于缺乏&lt;a href=&quot;https://github.com/dask/distributed/issues/2602&quot;&gt;背压，&lt;/a&gt;【10】仍有一些 bug 报告提示系统内存不足。但是这些问题是相当根本的。&lt;/div&gt;
&lt;div&gt;然而，背压的缺失是一种具有火箭筒大小的步枪。如果你太晚意识到自己构建了个怪物，那么在不对代码库进行重大更改的情况下，几乎不可能修复它，因为你可能忘了在某些本应使用异步的函数上使用异步。&lt;/div&gt;
&lt;div&gt;其它的编程环境对此也无济于事。人们在所有编程环境中都遇到了同样的问题，包括最新版本的 go 和 Rust。即使在长期开源的非常受欢迎的项目中，找到有关“处理流程控制”或“处理背压”的开放问题（open issue）也并非罕见，因为事实证明，事后添加这一点确实很困难。例如，go 从 2014 年起就存在一个开放问题，&lt;a href=&quot;https://github.com/golang/go/issues/7903&quot;&gt;关于给所有文件系统IO添加信号量，&lt;/a&gt;【11】因为它可能会使主机超载。aiohttp &lt;a href=&quot;https://github.com/aio-libs/aiohttp/issues/1368&quot;&gt;有一个问题可追溯到2016年，&lt;/a&gt;【12】关于客户端由于背压不足而导致破坏服务器。还有很多很多的例子。&lt;/div&gt;
&lt;div&gt;如果你查看 Python 的 hyper-h2文档，将会看到大量令人震惊的示例，其中包含类似“不处理流量控制”、“它不遵守 HTTP/2 流量控制，这是一个缺陷，但在其它方面是没问题的“，等等。在流量控制一出现的时候，我就认为它非常复杂。很容易假装这不是个问题，这就是为什么我们会处于这种混乱状态的根本原因。流量控制还会增加大量开销，并且在基准测试中效果不佳。&lt;/div&gt;
&lt;div&gt;那么，对于你们这些异步库开发人员，这里给你们一个新年的解决方案：在文档和 API 中，赋予背压和流量控制其应得的重视。&lt;/div&gt;
&lt;h3&gt;相关链接&lt;/h3&gt;
&lt;div&gt;[1] I’m not feeling the async pressure: &lt;a href=&quot;https://lucumr.pocoo.org/2020/1/1/async-pressure/&quot;&gt;https://lucumr.pocoo.org/2020/1/1/async-pressure/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[2] CC BY-NC-SA 4.0: &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;https://creativecommons.org/licenses/by-nc-sa/4.0/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[3] Backpressure explained — the resisted flow of data through software: &lt;a href=&quot;https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7&quot;&gt;https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[4] 流量控制: &lt;a href=&quot;https://en.wikipedia.org/wiki/Flow_control_(data)&quot;&gt;https://en.wikipedia.org/wiki/Flow_control_(data)&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[5] tower: &lt;a href=&quot;https://github.com/tower-rs/tower&quot;&gt;https://github.com/tower-rs/tower&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[6] actix-service: &lt;a href=&quot;https://docs.rs/actix-service/&quot;&gt;https://docs.rs/actix-service/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[7] hyper-h2: &lt;a href=&quot;https://github.com/python-hyper/hyper-h2&quot;&gt;https://github.com/python-hyper/hyper-h2&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[8] 文件上传服务器示例: &lt;a href=&quot;https://python-hyper.org/projects/h2/en/stable/curio-example.html&quot;&gt;https://python-hyper.org/projects/h2/en/stable/curio-example.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[9] Dask: &lt;a href=&quot;https://dask.org/&quot;&gt;https://dask.org/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[10] 背压: &lt;a href=&quot;https://github.com/dask/distributed/issues/2602&quot;&gt;https://github.com/dask/distributed/issues/2602&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[11] 关于给所有文件系统IO添加信号量: &lt;a href=&quot;https://github.com/golang/go/issues/7903&quot;&gt;https://github.com/golang/go/issues/7903&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[12] 有一个问题可追溯到2016年，: &lt;a href=&quot;https://github.com/aio-libs/aiohttp/issues/1368&quot;&gt;https://github.com/aio-libs/aiohttp/issues/1368&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>11 个最佳的 Python 编译器和解释器</title>
            <link>https://pythoncat.top/posts/2020-01-10-REPL/</link>
            <guid>https://pythoncat.top/posts/2020-01-10-REPL/</guid>
            <pubDate>Fri, 10 Jan 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;原作：Archie Mistry&lt;/div&gt;
&lt;div&gt;翻译：豌豆花下猫@Python猫&lt;/div&gt;
&lt;div&gt;原文：&lt;a href=&quot;https://morioh.com/p/765b19f066a4&quot;&gt;https://morioh.com/p/765b19f066a4&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 是一门对初学者友好的编程语言，是一种多用途的、解释性的和面向对象的高级语言。&lt;/div&gt;
&lt;div&gt;它拥有非常小的程序集，非常易于学习、阅读和维护。其解释器可在Windows、Linux 和 Mac OS 等多种操作系统上使用。它的可移植性和可伸缩性等特性使得它更加容易被运用。&lt;/div&gt;
&lt;div&gt;Python 库可用于以下用途：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Web 开发&lt;/li&gt;
&lt;li&gt;数据科学&lt;/li&gt;
&lt;li&gt;机器学习&lt;/li&gt;
&lt;li&gt;多媒体&lt;/li&gt;
&lt;li&gt;软件开发&lt;/li&gt;
&lt;li&gt;像 Django 这样的 Web 框架&lt;/li&gt;
&lt;li&gt;GUI 应用&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;大多数极客认为 Python 是解释性语言，但它也存在编译过程。&lt;/div&gt;
&lt;div&gt;编译部分在代码执行时完成，并被删除。然后编译内容被转换为字节码。通过机器和操作系统进一步扩展到 Python 虚拟机。&lt;/div&gt;
&lt;div&gt;本文重点介绍了适用于 Python 程序员的 11 种最佳的 Python 编译器和解释器。&lt;/div&gt;
&lt;h2&gt;最好的 Python 编译器和解释器&lt;/h2&gt;
&lt;h3&gt;1.Brython&lt;/h3&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Brython 是一种流行的 Python 编译器，可将 Python 转换为 Javascript 代码。它提供对所有 Web 浏览器（包括一种手机 Web 浏览器）的支持。&lt;/div&gt;
&lt;div&gt;它还支持最新的 Html5/CSS3 规范，可以使用流行的 CSS 框架，如 BootStrap3 和 LESS。&lt;/div&gt;
&lt;div&gt;网址：&lt;a href=&quot;https://on.morioh.net/b0a3f595aa%3Fr%3Dhttps://brython.info/&quot;&gt;https://brython.info&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;2. Pyjs&lt;/h3&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Pyjs 是一个丰富的 Internet 应用程序框架，也是一种轻量级的 Python 编译器，可以从  Web 浏览器直接执行 Python 脚本，可以从浏览器的 JS 控制台执行程序。&lt;/div&gt;
&lt;div&gt;它是从 Python 到 Javascript 的编译器，可以使代码在 Web 浏览器上运行。它带有 Ajax 框架和 Widget Set API。&lt;/div&gt;
&lt;div&gt;网站：&lt;a href=&quot;https://on.morioh.net/b0a3f595aa%3Fr%3Dhttp://pyjs.org/&quot;&gt;http://pyjs.org/&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;3. WinPython&lt;/h3&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;它是为 Windows 操作系统设计的。它有一些 CPython 的特性。它预装了一些针对数据科学和机器学习的流行库，例如 Numpy、Pandas 和 Scipy。&lt;/div&gt;
&lt;div&gt;它带有 C/C++ 编译器，大多数时候不会用到。除此之外，它只有 Python 编译器，没有其它包。&lt;/div&gt;
&lt;div&gt;网址：&lt;a href=&quot;https://on.morioh.net/b0a3f595aa%3Fr%3Dhttps://winpython.github.io/&quot;&gt;https://winpython.github.io/&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;4.Skulpt&lt;/h3&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Skulpt 是 Python 的浏览器版实现，可以被添加到 HTML 代码中。&lt;/div&gt;
&lt;div&gt;此 Python 编译器使用 Javascript 编写，在客户端运行代码，无需其它插件、加工或服务器支持。&lt;/div&gt;
&lt;div&gt;Skulpt 解释器通过导入方式，来执行保存在网站上的 .py 文件中的代码。&lt;/div&gt;
&lt;div&gt;网站：&lt;a href=&quot;https://on.morioh.net/b0a3f595aa%3Fr%3Dhttps://skulpt.org/&quot;&gt;https://skulpt.org&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;5.Shed Skin&lt;/h3&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;该编译器将 Python 标准库模块编译为 C++，它将静态类型的 Python 程序转换为很受限的优化的 C++ 代码。&lt;/div&gt;
&lt;div&gt;通过将其内置的 Python 数据类型再次实现为自己的类集（可以用 C++ 高效实现），可以提高性能。&lt;/div&gt;
&lt;div&gt;网站：&lt;a href=&quot;https://on.morioh.net/b0a3f595aa%3Fr%3Dhttps://en.wikipedia.org/wiki/Shed_Skin&quot;&gt;https://en.wikipedia.org/wiki/Shed_Skin&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;6.Active Python&lt;/h3&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这是用于 Windows、Linux 和 Mac Os 的 Python 发行版，有免费的社区版。&lt;/div&gt;
&lt;div&gt;它支持在许多平台安装，某些不被 Python-like 的 AIX 支持的平台，它也支持。它提供了比 Python 更多的兼容性。&lt;/div&gt;
&lt;div&gt;网站：&lt;a href=&quot;https://on.morioh.net/b0a3f595aa%3Fr%3Dhttps://www.activestate.com/products/activepython/&quot;&gt;https://www.activestate.com/products/activepython/&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;7.Transcrypt&lt;/h3&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;它是一种流行的将 Python 代码编译为简单易读的 Java 代码的编译器。它是一个轻量级的 Python 编译器，支持对矩阵和向量运算进行切片。&lt;/div&gt;
&lt;div&gt;Transcrypt 也可以在 Node.js 上运行。分层模块、多重继承和本地类给其添加了很多功能。&lt;/div&gt;
&lt;div&gt;网站：&lt;a href=&quot;http://www.transcrypt.org/&quot;&gt;http://www.transcrypt.org/&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;8. Nutika&lt;/h3&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这是一种源码到源码的 Python 编译器，可以将 Python 源代码转换为 C/C++ 可执行代码。它会使用到许多 Python 库和扩展模块。&lt;/div&gt;
&lt;div&gt;它自带 Anaconda，可用于创建数据科学和机器学习项目。&lt;/div&gt;
&lt;div&gt;网站：&lt;a href=&quot;http://nuitka.net/&quot;&gt;http://nuitka.net/&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;9. Jython&lt;/h3&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;它用 Java 编写，可以在运行 JVM 的任何平台上执行。Jython 将 Python代码编译为 Java 字节码，从而做到跨平台。&lt;/div&gt;
&lt;div&gt;它可用于创建 Servelets、Swing、SWT 和 AWT 软件包的解决方案。Jython 使用 CPython 之类的全局解释器锁（GIL） 。&lt;/div&gt;
&lt;div&gt;另外，你可以将 Java 类扩展到 Python 代码。&lt;/div&gt;
&lt;div&gt;网址：&lt;a href=&quot;https://on.morioh.net/b0a3f595aa%3Fr%3Dhttps://www.jython.org/&quot;&gt;https://www.jython.org&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;10. CPython&lt;/h3&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;CPython 是默认的且使用最广泛的 Python 编译器。它是用 C 语言编写的，并使用 GIL（全局解释器锁），这使得并发 CPython 进程之间的通信很困难。&lt;/div&gt;
&lt;div&gt;CPython 中的编译步骤包括：解码、令牌化、解析、抽象语法树和编译。&lt;/div&gt;
&lt;div&gt;网站：&lt;a href=&quot;https://on.morioh.net/b0a3f595aa%3Fr%3Dhttps://compilers.pydata.org/&quot;&gt;https://compilers.pydata.org/&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;11. IronPython&lt;/h3&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;此版本的 Python 编译器是在微软的 .Net 框架和 Mono 上实现的。&lt;/div&gt;
&lt;div&gt;它还提供了动态编译和交互式控制台。它使得安装非常容易，并且具有跨平台兼容性。&lt;/div&gt;
&lt;div&gt;它还具有标准库和不同的模块，主要用于实现 .Net 框架的用户界面库。&lt;/div&gt;
&lt;div&gt;网址：&lt;a href=&quot;https://on.morioh.net/b0a3f595aa%3Fr%3Dhttps://ironpython.net/&quot;&gt;https://ironpython.net/&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;div&gt;Python 是一种为许多实现提供了可能的开发语言，例如 Python 到 Java，Python 到 Javascript 或其它。&lt;/div&gt;
&lt;div&gt;Python 的这些编译器有助于我们理解它是多么的全能。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>2019 年 stackoverflow 网站最好的 20 个 Python 问题</title>
            <link>https://pythoncat.top/posts/2020-01-09-stackoverflow/</link>
            <guid>https://pythoncat.top/posts/2020-01-09-stackoverflow/</guid>
            <pubDate>Fri, 10 Jan 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在最新一期的“Python开发者周刊”（Pycoder’s weekly）里，我看到一则有意思的分享，故转出来分享给大家。&lt;/div&gt;
&lt;div&gt;该分享来自是一份”python weekly reports“，统计了 2019 年里 stackoverflow  网站上支持数最高的 20 个问题。问题列表如下（方括号中的两个数字是其支持数与回答数）：&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/56227419&quot;&gt;Why does Python’s hash of infinity have the digits of π?&lt;/a&gt; - [&lt;strong&gt;236&lt;/strong&gt;/3]&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/58435645&quot;&gt;Is there a more elegant way to express ((x == a and y == b) or (x == b and y == a))?&lt;/a&gt; - [&lt;strong&gt;105&lt;/strong&gt;/10]&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/55644201&quot;&gt;Why can I use a list index as an indexing variable in a for loop?&lt;/a&gt; - [&lt;strong&gt;92&lt;/strong&gt;/6]&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/58031966&quot;&gt;Why does (inf + 0j)*1 evaluate to inf + nanj?&lt;/a&gt; - [&lt;strong&gt;93&lt;/strong&gt;/4]&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/59359911&quot;&gt;Why is f’{{{74}}}’ the same as f’{{74}}’ with f-Strings?&lt;/a&gt; - [&lt;strong&gt;88&lt;/strong&gt;/1]&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/58259682&quot;&gt;Why does b+=(4,) work and b = b + (4,) doesn’t work when b is a list?&lt;/a&gt; - [&lt;strong&gt;75&lt;/strong&gt;/7]&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/55684960&quot;&gt;Why does Python start at index -1 (as opposed to 0) when indexing a list from the end?&lt;/a&gt; - [&lt;strong&gt;79&lt;/strong&gt;/7]&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/58441514&quot;&gt;Why is TensorFlow 2 much slower than TensorFlow 1?&lt;/a&gt; - [&lt;strong&gt;104&lt;/strong&gt;/2]&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/55934019&quot;&gt;Randomness of Python’s random&lt;/a&gt; - [&lt;strong&gt;70&lt;/strong&gt;/4]&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/54613753&quot;&gt;Why does Python allow out-of-range slice indexes for sequences?&lt;/a&gt; - [&lt;strong&gt;72&lt;/strong&gt;/2]&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/54245618&quot;&gt;Unexpected behaviour with Python generator&lt;/a&gt; - [&lt;strong&gt;57&lt;/strong&gt;/8]&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/58339040&quot;&gt;What exactly is meant by “partial function” in functional programming?&lt;/a&gt; - [&lt;strong&gt;55&lt;/strong&gt;/3]&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/55922302&quot;&gt;What does a yield inside a yield do?&lt;/a&gt; - [&lt;strong&gt;56&lt;/strong&gt;/4]&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/57049191&quot;&gt;Issues implementing the “Wave Collapse Function” algorithm in Python 2.7&lt;/a&gt; - [&lt;strong&gt;52&lt;/strong&gt;/2]&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/54782033&quot;&gt;Should linear read-shuffled write always be faster than shuffled read-linear write? (Was: Why is fancy assignment slower than fancy lookup?)&lt;/a&gt; - [&lt;strong&gt;53&lt;/strong&gt;/5]&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/58378549&quot;&gt;How to write 2**n - 1 as a recursive function?&lt;/a&gt; - [&lt;strong&gt;49&lt;/strong&gt;/7]&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/56288015&quot;&gt;Why is a &lt;code&gt;for&lt;/code&gt; loop so much faster to count True values?&lt;/a&gt; - [&lt;strong&gt;53&lt;/strong&gt;/5]&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/57351363&quot;&gt;Is there a difference between &lt;code&gt;board[x, y\]&lt;/code&gt; and &lt;code&gt;board[x][y]&lt;/code&gt; in Python?&lt;/a&gt; - [&lt;strong&gt;47&lt;/strong&gt;/6]&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/56782148&quot;&gt;Why was p[:] designed to work differently in these two situations?&lt;/a&gt;- [&lt;strong&gt;51&lt;/strong&gt;/6]&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/54963043&quot;&gt;Jupyter notebook: No connection to server because websocket connection fails&lt;/a&gt; - [&lt;strong&gt;46&lt;/strong&gt;/4]&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;不用怀疑，这些内容的支持数和回答数就是那么少。不过也需注意，它统计的是问题本身的支持数，而不是回答的支持数（尽管回答的支持数也很少）。&lt;/div&gt;
&lt;div&gt;还有一点需注意，这份报告并非 stackoverflow 网站的官方报告，而且文中也未说明统计口径与筛选标准，所以我们姑且一看。&lt;/div&gt;
&lt;div&gt;有些问题可能挺怪的，或者平时不大可能考虑到，比如关于列表的两个问题：&lt;strong&gt;为什么从列表末尾查找时是从 -1 开始？为什么列表的切片允许越界？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;不少回答都挺有专业精神，往往会带来新的视角和知识信息。比如，关于列表的 -1 索引问题，高票回答中提到了“~”运算符，有这样的用法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;arr &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;a&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;b&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;c&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;d&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;arr&lt;span&gt;[&lt;/span&gt;&lt;span&gt;~&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# d&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;arr&lt;span&gt;[&lt;/span&gt;&lt;span&gt;~&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# c&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;让人眼前一亮！&lt;/div&gt;
&lt;div&gt;还有一个问题是：如何优雅地计算 &lt;code&gt;((x == a and y == b) or (x == b and y == a))&lt;/code&gt; 这个形式的结果？&lt;/div&gt;
&lt;div&gt;高票回答是这样：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;初一看，就像看人变戏法一样……&lt;/div&gt;
&lt;div&gt;其它问题和回答就不一一说明了，建议感兴趣的同学按图索骥，按部就班，顺藤摸瓜，顺手牵羊……&lt;/div&gt;
&lt;h3&gt;链接清单：&lt;/h3&gt;
&lt;div&gt;&lt;a href=&quot;https://python-weekly.blogspot.com/2020/01/20-best-python-questions-at.html?m=1&quot;&gt;https://python-weekly.blogspot.com/2020/01/20-best-python-questions-at.html?m=1&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[1] &lt;a href=&quot;http://stackoverflow.com/questions/56227419&quot;&gt;http://stackoverflow.com/questions/56227419&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[2] &lt;a href=&quot;http://stackoverflow.com/questions/58435645&quot;&gt;http://stackoverflow.com/questions/58435645&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[3] &lt;a href=&quot;http://stackoverflow.com/questions/55644201&quot;&gt;http://stackoverflow.com/questions/55644201&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[4] &lt;a href=&quot;http://stackoverflow.com/questions/58031966&quot;&gt;http://stackoverflow.com/questions/58031966&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[5] &lt;a href=&quot;http://stackoverflow.com/questions/59359911&quot;&gt;http://stackoverflow.com/questions/59359911&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[6] &lt;a href=&quot;http://stackoverflow.com/questions/58259682&quot;&gt;http://stackoverflow.com/questions/58259682&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[7] &lt;a href=&quot;http://stackoverflow.com/questions/55684960&quot;&gt;http://stackoverflow.com/questions/55684960&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[8] &lt;a href=&quot;http://stackoverflow.com/questions/58441514&quot;&gt;http://stackoverflow.com/questions/58441514&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[9] &lt;a href=&quot;http://stackoverflow.com/questions/55934019&quot;&gt;http://stackoverflow.com/questions/55934019&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[10] &lt;a href=&quot;http://stackoverflow.com/questions/54613753&quot;&gt;http://stackoverflow.com/questions/54613753&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[11] &lt;a href=&quot;http://stackoverflow.com/questions/54245618&quot;&gt;http://stackoverflow.com/questions/54245618&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[12] &lt;a href=&quot;http://stackoverflow.com/questions/58339040&quot;&gt;http://stackoverflow.com/questions/58339040&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[13] &lt;a href=&quot;http://stackoverflow.com/questions/55922302&quot;&gt;http://stackoverflow.com/questions/55922302&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[14] &lt;a href=&quot;http://stackoverflow.com/questions/57049191&quot;&gt;http://stackoverflow.com/questions/57049191&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[15] &lt;a href=&quot;http://stackoverflow.com/questions/54782033&quot;&gt;http://stackoverflow.com/questions/54782033&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[16] &lt;a href=&quot;http://stackoverflow.com/questions/58378549&quot;&gt;http://stackoverflow.com/questions/58378549&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[17] &lt;a href=&quot;http://stackoverflow.com/questions/56288015&quot;&gt;http://stackoverflow.com/questions/56288015&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[18] &lt;a href=&quot;http://stackoverflow.com/questions/57351363&quot;&gt;http://stackoverflow.com/questions/57351363&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[19] &lt;a href=&quot;http://stackoverflow.com/questions/56782148&quot;&gt;http://stackoverflow.com/questions/56782148&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[20] &lt;a href=&quot;http://stackoverflow.com/questions/54963043&quot;&gt;http://stackoverflow.com/questions/54963043&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 任务自动化工具 tox 教程</title>
            <link>https://pythoncat.top/posts/2020-01-06-tox/</link>
            <guid>https://pythoncat.top/posts/2020-01-06-tox/</guid>
            <pubDate>Mon, 06 Jan 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在我刚翻译完的 Python 打包&lt;a href=&quot;https://mp.weixin.qq.com/s/Kmqhr9szPdvBI0KQPm9JsA&quot;&gt;系列文章&lt;/a&gt;中，作者提到了一个神奇的测试工具 tox，而且他本人就是 tox 的维护者之一。趁着话题的相关性，本文将对它做简单的介绍，说不定大家在开发项目时能够用得上。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Command line driven CI frontend and development task automation tool&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;命令行驱动的 CI 前端和开发任务自动化工具&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;tox 的项目地址是：&lt;a href=&quot;https://github.com/tox-dev/tox&quot;&gt;https://github.com/tox-dev/tox&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;其核心作用是支持创建隔离的 Python 环境，在里面可以安装不同版本的 Python 解释器与各种依赖库，以此方便开发者做自动化测试、打包、持续集成等事情。&lt;/div&gt;
&lt;div&gt;简单来说，&lt;strong&gt;tox 是一个管理测试虚拟环境的命令行工具。&lt;/strong&gt; 它已存在多年且广被开发者们使用，例如，著名的云计算平台 OpenStack 也采用了它，作为最基础的测试工具之一。&lt;/div&gt;
&lt;h2&gt;1、tox 能做什么？&lt;/h2&gt;
&lt;div&gt;细分的用途包括：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;创建开发环境&lt;/li&gt;
&lt;li&gt;运行静态代码分析与测试工具&lt;/li&gt;
&lt;li&gt;自动化构建包&lt;/li&gt;
&lt;li&gt;针对 tox 构建的软件包运行测试&lt;/li&gt;
&lt;li&gt;检查软件包是否能在不同的 Python 版本/解释器中顺利安装&lt;/li&gt;
&lt;li&gt;统一持续集成（CI）和基于命令行的测试&lt;/li&gt;
&lt;li&gt;创建和部署项目文档&lt;/li&gt;
&lt;li&gt;将软件包发布到 PyPI 或任何其它平台&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;tox 官方文档中列出了 40 余种使用场景的示例，详细的列表可查看：&lt;a href=&quot;https://tox.readthedocs.io/en/latest/examples.html&quot;&gt;https://tox.readthedocs.io/en/latest/examples.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;2、tox 怎么配置？&lt;/h2&gt;
&lt;div&gt;关于它的用法：使用&lt;code&gt;pip install tox&lt;/code&gt; 安装，使用&lt;code&gt;tox&lt;/code&gt; 运行全部测试环境，和&lt;code&gt;tox -e envname&lt;/code&gt; 运行指定的环境。还有不少的命令行参数，通过&lt;code&gt;tox -h&lt;/code&gt; 查看。&lt;/div&gt;
&lt;div&gt;tox 的行为由其配置文件控制，当前它支持 3 种配置文件：&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;pyproject.toml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tox.ini&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setup.cfg&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;以 tox 项目自己的 tox.ini 配置内容为例，可以看到它是这样配置的（&lt;a href=&quot;https://github.com/tox-dev/tox/blob/master/tox.ini&quot;&gt;https://github.com/tox-dev/tox/blob/master/tox.ini&lt;/a&gt;）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;每个[xxx]及其下方内容组成一个章节（section），每个章节间使用空行作间隔。&lt;/div&gt;
&lt;div&gt;[tox]下面是全局性的配置项，envlist 字段定义了 tox 去操作的环境。[xxx]下面是 xxx 虚拟环境的配置项，[xxx:yyy]继承 xxx 的配置，同时其自身配置项的优先级更高。&lt;/div&gt;
&lt;div&gt;对于每个虚拟环境，可用的配置项很多，例如常用的有：description（描述信息）、basepython（Python解释器版本）、deps（环境依赖项）、commands（命令语句）等等。&lt;/div&gt;
&lt;div&gt;tox 还支持作变量替换，它提供了一些内置的基础变量（全局的或对于虚拟环境的）：{toxinidir}、{homedir}、{envname}、{envdir}等等。&lt;/div&gt;
&lt;div&gt;除了基础性的变量替换，它还支持这些高级用法：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;取操作系统的环境变量：{env:KEY}，效果等同于&lt;code&gt;os.environ[&apos;KEY&apos;]&lt;/code&gt; 。可以变化成：{env:KEY:DEFAULTVALUE}，在取不到环境变量时则使用默认值；{env:KEY:{env:DEFAULT_OF_KEY}}，达到 if-else 的取值效果&lt;/li&gt;
&lt;li&gt;传递命令行参数：{posargs:DEFAULTS}，当没有命令行参数时，使用 DEFAULTS 值。使用方式：&lt;code&gt;tox arg1 arg2&lt;/code&gt; 传两个参，或者&lt;code&gt;tox -- --opt1 arg1&lt;/code&gt; 将“— opt1 arg1”作为整体传入。&lt;/li&gt;
&lt;li&gt;章节间传值：{[sectionname]valuename}，不同章节的内容可以传递使用。&lt;/li&gt;
&lt;li&gt;交互式控制台注入：{tty:ON_VALUE:OFF_VALUE}，当交互式 shell 控制台开启时，使用第一个值，否则使用第二个。pytest 在使用“—pdb”时，是这样的例子。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;花括号“{}”除了可以做变量替换使用，它还可以作为“或关系”判断的取值。直接看下面的例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;[&lt;/span&gt;tox&lt;span&gt;]&lt;/span&gt;
envlist &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;py27&lt;span&gt;,&lt;/span&gt;py36&lt;span&gt;}&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;django&lt;span&gt;{&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;{py27,py36}-django{15,16} 的 2 组花括号内各有 2 个值，它们实际可以组合成 4 个环境：py27-django15、py27-django16、py36-django15、py36-django16。&lt;/div&gt;
&lt;div&gt;关于 tox 有哪些配置项、使用条件、什么含义、高级用法等等内容，可在官方文档中查看：&lt;a href=&quot;https://tox.readthedocs.io/en/latest/config.html&quot;&gt;https://tox.readthedocs.io/en/latest/config.html&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;3、tox 的插件化&lt;/h2&gt;
&lt;div&gt;除了自身强大的可配置性，tox 还具有很强的可扩展性，它是可插拔的（pluggable），围绕它产生了一个极为丰富的插件生态。&lt;/div&gt;
&lt;div&gt;使用&lt;code&gt;pip search tox&lt;/code&gt; ，可以看到数量众多的“tox-”开头的库，它们都是 tox 的插件包。其中不乏 setuptools、pipenv、conda、travis、pytest、docker 等被大家熟知的名字。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;tox 开放了挺多的 &lt;a href=&quot;https://tox.readthedocs.io/en/latest/plugins.html&quot;&gt;API 接口&lt;/a&gt;，方便其他人定制开发插件。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;4、tox 的工作流程&lt;/h2&gt;
&lt;div&gt;接下来看看 tox 是怎么运作的：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;其工作流程中主要的环节有：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;配置（从figuration）：加载配置文件（如 tox.ini），解析命令行参数，读取系统环境变量等&lt;/li&gt;
&lt;li&gt;打包（packaging）：可选的，对于带有 setup.py 文件的项目，可以在这步去生成它的源发行版&lt;/li&gt;
&lt;li&gt;创建虚拟环境：默认使用 virtualenv 来创建虚拟环境，并根据配置项中的“deps”安装所需的依赖项，然后执行配置好的命令（commands）&lt;/li&gt;
&lt;li&gt;报告（report）：汇总所有虚拟环境的运行结果并罗列出来&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;5、小结&lt;/h2&gt;
&lt;div&gt;tox 本身定位是一个测试工具，它试图令 Pytho 测试工作变得自动化、标准化与流程化。但跟 unittest 和 pytest 这些测试框架不同，它作用的是代码层面之外的事情，是一种项目级的工具。因此，它需要跟这些测试框架相结合，或者同时处理多种自动化任务（如跑 pep8、测代码覆盖率、生成文档等等），这样才能更好地发挥它的价值。&lt;/div&gt;
&lt;div&gt;它的一大特色在于创建/管理虚拟环境，但这只是为了方便测试而使用的手段，因此相比其它可管理虚拟环境的工具，如 Virtualenvwrapper、conda、pipenv、poetry，它在某些方面就存在着不足。&lt;/div&gt;
&lt;div&gt;tox 还有强大的可配置性与丰富的插件支持，这使得它在运用上具有很大的可能性与自由度。因此，不少忠实开发者仍在持续地在使用它，比如，我刚翻译好的&lt;a href=&quot;https://mp.weixin.qq.com/s/Kmqhr9szPdvBI0KQPm9JsA&quot;&gt;系列文章&lt;/a&gt;的作者就是它的维护者之一。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;最后还需补充一点，tox 使用配置文件作驱动，但配置文件还是挺繁琐的，因此有人开发了一个跟 tox 相似的&lt;code&gt;nox&lt;/code&gt;，使用 Python 文件来做配置。这个项目也很受欢迎，吸引了很多项目投入其门下，例如 pipx、urllib3、Salt 等等。对该项目感兴趣的话，请查看：&lt;a href=&quot;https://nox.thea.codes/en/stable/&quot;&gt;https://nox.thea.codes/en/stable/&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 官方团队在打包项目中踩过的坑</title>
            <link>https://pythoncat.top/posts/2020-01-05-packaging/</link>
            <guid>https://pythoncat.top/posts/2020-01-05-packaging/</guid>
            <pubDate>Sun, 05 Jan 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;花下猫语：这是 packaging 系列的第三篇译文，该系列是全网关于此话题的最详尽（水平也很高）的一个系列。原作者是 Python 官方打包团队成员，是 virtualenv 和 tox 项目的维护者，及 setuptools 和 pip 项目的贡献者。&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;&lt;strong&gt;英文&lt;/strong&gt; | &lt;a href=&quot;https://www.bernat.tech/growing-pain/&quot;&gt;Python packaging - Growing Pains&lt;/a&gt;【1】&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;原作&lt;/strong&gt; | BERNAT GABOR&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; | 豌豆花下猫&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;声明&lt;/strong&gt; ：本文获得原作者授权翻译，转载请保留原文出处，请勿用于商业或非法用途。&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;在前两篇文章中，我介绍了&lt;a href=&quot;https://mp.weixin.qq.com/s/-zwZWV3MaFeat96_AoVJCg&quot;&gt;Python 具有的包类型&lt;/a&gt;以及&lt;a href=&quot;https://mp.weixin.qq.com/s/aq_u0i5TJUnovXRf6NuGFw&quot;&gt;包的构建方式&lt;/a&gt;，尤其介绍了 PEP-517/518。尽管这些更改主要是为了使打包变得更健壮，但是在实施和发布时，我们却遇到了一些问题。这篇文章将介绍一部分，希望可以为大家提供经验教训，并提出一些有趣的问题以待将来解决。&lt;/div&gt;
&lt;div&gt;查看 PEP-517 和 PEP-518 的改动，可以认为构建后端（亦即 setuptools、flit）几乎没有做什么，只是通过 Python 模块提供了功能接口。大部分繁重的工作都在构建前端上，它需要生成隔离的 Python，然后以新的方式调用构建后端。如今当我们谈论构建前端时，我们的选项主要是 pip 或 poetry（和开发者的 tox）。&lt;/div&gt;
&lt;div&gt;这些项目由社区维护，由少数活跃的开发者在空闲时间维护。他们并没有因此获得报酬，而且需要谨慎考虑这些工具被使用的多种方式。考虑到这一点，在 PEP 被接受之后，还花了几乎两年时间才首次实施就不足为奇了。计划、测试和实施已经在背后进行了一年多。&lt;/div&gt;
&lt;div&gt;但是，尽管做了所有准备工作，不可避免的是，第一版确实破坏了一些软件包，在大多数情况下，人们做的某些操作使维护人员感到惊讶。让我们试着了解其中一些例子，以及它们是如何被解决的。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Mink Mingle摄/Unsplash—准备好出发！&lt;/div&gt;
&lt;h2&gt;PEP-518&lt;/h2&gt;
&lt;div&gt;此 PEP 引入了&lt;a href=&quot;https://github.com/toml-lang/toml&quot;&gt;TOML文件格式。&lt;/a&gt; 【2】一种专门为了易于读/写配置而创建的格式。尽管在&lt;code&gt;build-system&lt;/code&gt;部分下介绍了打包配置，但其它工具可以自由地将其配置放在&lt;code&gt;tool:name&lt;/code&gt;部分下，因为它们拥有 PyPi 命名空间中的名字。各种工具立即开始利用这一点（例如&lt;a href=&quot;https://pypi.org/project/towncrier/&quot;&gt;Towncrier&lt;/a&gt;【3】、 &lt;a href=&quot;https://pypi.org/project/black/&quot;&gt;black&lt;/a&gt;【4】等）。&lt;/div&gt;
&lt;div&gt;当&lt;a href=&quot;https://pip.pypa.io/en/stable/news/%23id61#id61&quot;&gt;pip 18.0（于2018年7月22日发布）&lt;/a&gt; 【5】添加对 PEP-518 包的支持时，使用 pyproject.toml 最早出问题，因为 PEP-518 要求所有带 pyproject.toml 的软件包必须指定 build-backend 部分。但是，软件包事先仅将其用于其它项目的配置文件，由于它们没有事先指定它，当 pip 碰到这些文件时，就会引发错误，提示 pyproject.toml 文件无效。&lt;/div&gt;
&lt;h2&gt;PEP-517&lt;/h2&gt;
&lt;h3&gt;pip wheel 缓存问题&lt;/h3&gt;
&lt;div&gt;pip 在 PEP-517 世界中的安装方式是首先生成一个 wheel，然后将其提取。要进入 PEP-517 世界，必须指定 build-backend 键，否则每条声明都需要退回到使用 setup.py 命令。&lt;/div&gt;
&lt;div&gt;当 pip 构建 wheel 时，默认情况下会通过缓存系统完成。这是一种提速机制，为了在多个虚拟环境需要同一个 wheel 时，我们不用对其进行重建，而是重复使用它。PEP-517 wheel 的构建操作也利用了这一机制。&lt;/div&gt;
&lt;div&gt;但是，当你禁用缓存时，这就变得很麻烦。因为没有目标文件夹可用于构建 wheel。所以构建过程将失败，&lt;a href=&quot;https://github.com/pypa/pip/issues/6158&quot;&gt;请参阅附录的问题。&lt;/a&gt;【6】这个问题虽然很早就显现出来了，但由于大多数 CI 系统都在启用该选项的情况下运行。仅在一天后，pip 19.0.1 修复了该问题。&lt;/div&gt;
&lt;h3&gt;pyproject.toml 没有加入 setuptools 中&lt;/h3&gt;
&lt;div&gt;事实证明，构建后端实际上要做的工作不仅仅是 PEP-517 中描述的公开其 API。后端还需要确保 pyproject.toml 被附加到已构建的源码包中，否则用户计算机上的构建后端将无法使用它。&lt;a href=&quot;https://github.com/pypa/setuptools/pull/1650&quot;&gt;setuptools 1650&lt;/a&gt;【7】将为&lt;a href=&quot;https://github.com/pypa/setuptools/pull/1650&quot;&gt;setuptools&lt;/a&gt;【8】修复此问题，在早期版本中，只需在 MANIFEST.in 中指定 pyproject.toml 即可。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Jorge Zapata摄/Unsplash—什么？！那永远不会发生&lt;/div&gt;
&lt;h3&gt;从 setup.py 中导入构建的包&lt;/h3&gt;
&lt;div&gt;另一个意外问题是从 setup.py 内导入软件包时。按照约定，软件包的版本既作为软件包的元数据公开（setup.py 中的 setuptools，setup 函数的 version 参数），也在软件包根目录的__version__ 变量公开。可以在两个地方都指定变量的内容，但是要使其保持同步就很麻烦。&lt;/div&gt;
&lt;div&gt;一种解决方法：许多程序包将其放在根目录的 version.py 中，然后同时从 setup.py 和程序包根目录导入它，像这样&lt;code&gt;from mypy.version import __version__ as version&lt;/code&gt;。这能起作用，因为当有人调用 Python 脚本时，当前的工作目录会自动被添加到 sys.path 中（因此你可以导入公开在其下的内容）。&lt;/div&gt;
&lt;div&gt;但是，这种添加当前工作目录的行为从来不是强制的，更多的是通过&lt;code&gt;python setup.py sdist&lt;/code&gt; 调用构建时，产生的副作用。由于这种行为是副作用（并非保证），因此从 setup.py 导入的所有项目都应在构建开始时，将脚本文件夹显式地添加到 sys 路径。&lt;/div&gt;
&lt;div&gt;是否该在打包期间（当尚未构建/分发时）导入已编译的软件包，这尚有争议（尽管 Python 打包组倾向于这样做）。然而，实际上当 setuptools 通过 setuptools.build_meta 暴露其接口时，它选择不把当前工作目录添加到系统路径。&lt;/div&gt;
&lt;div&gt;PEP 从未要求后端做此添加，因为大多数构建后端（本质上是声明式的）根本不需要它。因此，此类功能被认为是前端的责任。setuptools 认为，如果用户需要此功能，则应在 setup.py 中明确指出，并提前手动在 sys.path 中添加相应的路径。&lt;/div&gt;
&lt;div&gt;为了简化 pip 代码库，pip 决定加入 PEP-517，让所有人在 setuptools 后端加上 pyproject.toml。现在因为这个问题，即使没有选择加入 PEP-517 的程序包也出现崩溃。为了解决这个问题，setuptools 添加了一个新的构建后端（setuptools.build_meta:__ legacy__），当未指定构建后端时，前端可将其用作默认值；当项目添加 build-backend 键时，它们还必须更改其 setup.py，要么将源码根目录添加到 sys.path，要么避免从源码根目录导入。&lt;/div&gt;
&lt;h3&gt;自举的后端&lt;/h3&gt;
&lt;div&gt;还出现了另一个有趣的问题，该问题的用户群更加紧密，但是却暴露了一个有趣的问题。如果我们不想使用 wheel，我们只能通过源发行版进行设置；我们应该如何解决”如何提供构建后端的构建后端的问题“？例如，setuptools 通过setuptools 打包自身。也即当 setuptools 通过 PEP-517 指定了这一点时，构建前端将被放入无限循环内。&lt;/div&gt;
&lt;div&gt;要安装 pugs 库，它首先会尝试创建一个隔离的环境。这个环境需要 setuptools ，因此构建前端就需要构建一个 wheel 来满足它。wheel 构建本身将触发隔离环境的创建，该环境又依赖于 setuptools。&lt;/div&gt;
&lt;div&gt;如何打破这个循环？要求所有构建后端必须暴露为 wheel？允许后端构建自身？这些自建后端是否应该负担依赖项？漫长的各种观点间争论，利与弊，所以如果你有兴趣，请进入&lt;a href=&quot;https://discuss.python.org/t/pep-517-backend-bootstrapping&quot;&gt;python Discourse board&lt;/a&gt;【9】，发表你的意见。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Sneaky Elbow摄/Unsplash—我们是一伙的&lt;/div&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;div&gt;打包是很难的。在业余时间完善打包系统，使用户可以在打包期间编写和运行任意代码，但还不引起任何破坏，这几乎是不可能的。&lt;/div&gt;
&lt;div&gt;现在有了 PEP-518，构建时依赖项是明确的，并且构建环境易于创建。有了 PEP-517，我们可以使用更具声明性的打包命名空间，这减少了用户犯错的可能，当错误不可避免时，也能提供更好的消息。&lt;/div&gt;
&lt;div&gt;诚然，在进行这些更改时，某些程序包可能会损坏，并且我们可能令曾经有效的方法失效。但是，我们（PyPa 的维护者）并不是出于恶意而这样做的，因此，当出现错误时，请务必填写详细的错误报告，例如什么错误、你的使用方法，以及你的用例。&lt;/div&gt;
&lt;div&gt;我们努力在真诚地改善打包生态系统，为此我们创建了&lt;a href=&quot;https://github.com/pypa/integration-test&quot;&gt;集成测试&lt;/a&gt;【10】存储库，以确保将来至少可以捕获到其中的一些边缘用例，免得它们落入到你的机器中。如果你对打包有任何建议或诉求，请随时在“ &lt;a href=&quot;https://discuss.python.org/c/packaging&quot;&gt;讨论Python论坛&lt;/a&gt;【11】”的打包部分进行讨论，或者为相关工具提一个 issue。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Milan Popovic摄/ Unsplash—结束了&lt;/div&gt;
&lt;div&gt;先到此为止了，谢谢阅读完！我要感谢&lt;a href=&quot;https://twitter.com/pganssle&quot;&gt;Paul Ganssle&lt;/a&gt;【12】审阅了打包系列文章，并要感谢&lt;a href=&quot;https://twitter.com/techatbloomberg&quot;&gt;Tech At Bloomberg&lt;/a&gt;【13】允许我在工作期间作开源贡献。&lt;/div&gt;
&lt;h3&gt;相关链接&lt;/h3&gt;
&lt;div&gt;[1] Python packaging - Growing Pains: &lt;a href=&quot;https://www.bernat.tech/growing-pain/&quot;&gt;https://www.bernat.tech/growing-pain/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[2] TOML文件格式。: &lt;a href=&quot;https://github.com/toml-lang/toml&quot;&gt;https://github.com/toml-lang/toml&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[3] Towncrier: &lt;a href=&quot;https://pypi.org/project/towncrier/&quot;&gt;https://pypi.org/project/towncrier/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[4] black: &lt;a href=&quot;https://pypi.org/project/black/&quot;&gt;https://pypi.org/project/black/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[5] pip 18.0（于2018年7月22日发布）: &lt;a href=&quot;https://pip.pypa.io/en/stable/news/%23id61#id61&quot;&gt;https://pip.pypa.io/en/stable/news/%23id61#id61&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[6] 请参阅附录的问题。: &lt;a href=&quot;https://github.com/pypa/pip/issues/6158&quot;&gt;https://github.com/pypa/pip/issues/6158&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[7] setuptools 1650: &lt;a href=&quot;https://github.com/pypa/setuptools/pull/1650&quot;&gt;https://github.com/pypa/setuptools/pull/1650&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[8] setuptools: &lt;a href=&quot;https://github.com/pypa/setuptools/pull/1650&quot;&gt;https://github.com/pypa/setuptools/pull/1650&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[9] python Discourse board: &lt;a href=&quot;https://discuss.python.org/t/pep-517-backend-bootstrapping&quot;&gt;https://discuss.python.org/t/pep-517-backend-bootstrapping&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[10] 集成测试: &lt;a href=&quot;https://github.com/pypa/integration-test&quot;&gt;https://github.com/pypa/integration-test&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[11] 讨论Python论坛: &lt;a href=&quot;https://discuss.python.org/c/packaging&quot;&gt;https://discuss.python.org/c/packaging&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[12] Paul Ganssle: &lt;a href=&quot;https://twitter.com/pganssle&quot;&gt;https://twitter.com/pganssle&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[13] Tech At Bloomberg: &lt;a href=&quot;https://twitter.com/techatbloomberg&quot;&gt;https://twitter.com/techatbloomberg&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 打包——过去、现在与未来</title>
            <link>https://pythoncat.top/posts/2020-01-04-packaging/</link>
            <guid>https://pythoncat.top/posts/2020-01-04-packaging/</guid>
            <pubDate>Sat, 04 Jan 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;英文&lt;/strong&gt; | &lt;a href=&quot;https://www.bernat.tech/pep-517-518/&quot;&gt;Python packaging - Past, Present, Future&lt;/a&gt;【1】&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;原作&lt;/strong&gt; | BERNAT GABOR&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; | 豌豆花下猫&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;声明&lt;/strong&gt; ：本文获得原作者授权翻译，转载请保留原文出处，请勿用于商业或非法用途。&lt;/div&gt;
&lt;div&gt;你是否想过在运行 pip install 时究竟发生了什么？这篇文章将给你一个关于过去所涉及的步骤的详细综述，以及它是如何随着 PEP-517 和 PEP-518 的采用而改变的。&lt;/div&gt;
&lt;div&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s/-zwZWV3MaFeat96_AoVJCg&quot;&gt;前一篇文章&lt;/a&gt;中，我描述了如何做到安装三种类型的内容：源码树（source tree）、源发行版（source distribution）和 wheel。只有最后两种类型会被上传到 PyPi 中央存储仓，但你也可以获得源码树（例如，通过为 pip 加入 git 协议）。与其它类型相比，wheel 的优点是不需要在用户机器上进行任何构建操作；只需要下载和提取。&lt;/div&gt;
&lt;h2&gt;构建 Python 包&lt;/h2&gt;
&lt;div&gt;现在可以独立出构建的环境（用户或开发者的机器），但你仍然需要构建包（sdist 或 wheel）。为了做到这一点，你需要一些适当的构建器。在过去，对第三方包的需求很早就表现出来了。&lt;/div&gt;
&lt;div&gt;遵循内置电池的原则，在 2000 年的 Python 1.6 中，&lt;a href=&quot;https://packaging.python.org/key_projects/#distutils&quot;&gt;distutils&lt;/a&gt;【2】包被添加进 Python 标准库中。它引入了包含构建逻辑的&lt;code&gt;setup.py&lt;/code&gt; 文件的概念，并通过&lt;code&gt;python setup.py&lt;/code&gt; 命令触发。&lt;/div&gt;
&lt;div&gt;它允许用户将代码打包成库，但没有声明（declaration）及自动安装依赖库等功能。而且，它的升级周期直接与核心解释器的发布周期绑定。&lt;/div&gt;
&lt;div&gt;setuptools 于 2004 年创建，它构建在 distutils 之上，并扩展了其它优秀的特性。它很快变得非常流行，以至于大多数 Python 安装包开始将其与核心解释器一起提供。&lt;/div&gt;
&lt;div&gt;在那个时候，所有的包都是源发行版。wheel 分发方式出现得很晚，是在 2014 年。distutils 是在只有少数非常精通打包的人的时候创建的。因此它是非常灵活和命令式的（imperative），你写一个 Python 脚本，可以修改包生成过程中的每一步。&lt;/div&gt;
&lt;div&gt;但这样做的缺点是，它一点也不容易学习和理解。随着 Python 的流行，这开始成为一个越来越严重的问题，因为有越来越多的用户对 Python 内部的工作原理不是很精通。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;￼Charles PH 摄/Unsplash—ehhh&lt;/div&gt;
&lt;h2&gt;构建依赖项&lt;/h2&gt;
&lt;div&gt;关于安装一个源发行版，pip 主要做了以下工作:&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;找到这个包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载源发行版并提取它&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在提取的文件夹上运行&lt;code&gt;python setup.py install&lt;/code&gt;（进行构建+安装）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;开发者运行&lt;code&gt;python setup.py sdist&lt;/code&gt; 生成分发包，运行&lt;code&gt;python setup.py upload&lt;/code&gt; 上传到中央存储仓（上传命令在 2013 年被弃用了，因为有 &lt;a href=&quot;https://pypi.org/project/twine/&quot;&gt;twine&lt;/a&gt;【3】工具，更主要是因为 upload 使用了不安全的 HTTP 连接，而且上传命令会做一次新的构建，也就不允许最终用户在实际上传之前检测（inspect）生成的包）。&lt;/div&gt;
&lt;div&gt;当 pip 运行&lt;code&gt;python setup.py install&lt;/code&gt;时，它使用 Python 解释器来安装包。因此，构建操作可以访问该解释器中已经存在的所有三方包。最值得注意的是，它完全使用了安装在主机 Python 解释器上的 setuptools 版本。如果一个包使用了 setuptools 的新版本特性，那么完成安装的唯一方法就是首先更新已安装的 setuptools。&lt;/div&gt;
&lt;div&gt;如果新版本包含了能破坏其它包的 bug，就会导致出问题。在用户无法更改已安装包的系统上，这尤其麻烦。当构建器（例如 setuptools）希望使用其它辅助包（例如 cython）时，这也是个问题。&lt;/div&gt;
&lt;div&gt;如果缺少构建器的辅助，通常会抛出导包失败的错误：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;File &lt;span&gt;&quot;setup_build.py&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; line &lt;span&gt;99&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; run
    &lt;span&gt;from&lt;/span&gt; Cython&lt;span&gt;.&lt;/span&gt;Build &lt;span&gt;import&lt;/span&gt; cythonize
ImportError&lt;span&gt;:&lt;/span&gt; No module named Cython&lt;span&gt;.&lt;/span&gt;Build&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在开发者们这边，没办法提供此类构建依赖项。而对于用户这边，则需要预先安装所有的包构建依赖，即使他们不会在运行时使用到。为了解决这个问题， &lt;a href=&quot;https://www.python.org/dev/peps/pep-0518/&quot;&gt;PEP-518&lt;/a&gt;【4】被创建了。&lt;/div&gt;
&lt;div&gt;其思想是，与其将主机的 Python 与其当前安装的构建包一起使用，不如给软件包提供一种能力，令其清楚地说明其构建操作所需的内容。另外，与其在主机 Python 上提供此功能，我们是创建了一个独立的 Python（类似某种虚拟环境）来运行打包。&lt;/div&gt;
&lt;div&gt;&lt;code&gt;python setup.py install&lt;/code&gt; 现在可以：&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建一个临时文件夹&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个隔离的（从三方库的 site packages 中）Python 环境 &lt;code&gt;python -m virtualenv our_build_env&lt;/code&gt;，让我们将这个 Python 可执行文件称为&lt;code&gt;python_isolated&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装构建的依赖项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;code&gt;python_isolated setup.py bdist_wheel&lt;/code&gt;，生成一个用于安装的 wheel&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提取 wheel 到 Python 的 site packages 文件夹&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;有了这个，我们可以安装依赖于&lt;code&gt;cython&lt;/code&gt; 的包，但不必在运行的 Python 环境中实际安装&lt;code&gt;cython&lt;/code&gt;。指定构建依赖项的文件与方法的是&lt;code&gt;pyproject.toml&lt;/code&gt;元数据文件:&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;[&lt;/span&gt;build&lt;span&gt;-&lt;/span&gt;system&lt;span&gt;]&lt;/span&gt;
requires &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;
    &lt;span&gt;&quot;setuptools &amp;gt;= 40.8.0&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    &lt;span&gt;&quot;wheel &amp;gt;= 0.30.0&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    &lt;span&gt;&quot;cython &amp;gt;= 0.29.4&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;此外，它还允许打包者指定他们需要的最小版本，而借助用户机器上的 pip，可以轻易地找出这些版本。&lt;/div&gt;
&lt;div&gt;当在开发者的机器上生成源发行版或 wheel 时，也可以使用相同的机制。当一个人调用&lt;code&gt;pip wheel . --no-deps&lt;/code&gt;命令时，该命令会自动在后台创建一个包含构建依赖项的独立 Python，然后在该环境中调用&lt;code&gt;python setup.py bdist_wheel&lt;/code&gt;或&lt;code&gt;python setup.py sdist&lt;/code&gt; 命令。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Bruce Galpin摄/Unsplash—yay!&lt;/div&gt;
&lt;h2&gt;多样的打包工具&lt;/h2&gt;
&lt;div&gt;但这里还有一个问题。请注意，所有这些操作仍然须通过 20 年前引入的机制，即执行&lt;code&gt;setup.py&lt;/code&gt;。整个生态系统仍然构建在 distutils 和 setuptools 的接口基础之上，由于试图保持向后兼容性，没法作太大的变更。&lt;/div&gt;
&lt;div&gt;此外，在打包过程中执行用户端 Python 代码是危险的，这可能会导致经验较少的用户难以调试的细微错误。命令式的（imperative）构建系统在 20 年前对于灵活性来说非常重要，当时我们还不知道所有的情况，但是现在我们已经认识清楚了，很可能可以为不同的情况创建出非常健壮和简单的包构建器。&lt;/div&gt;
&lt;div&gt;引用&lt;a href=&quot;https://twitter.com/pganssle&quot;&gt; Paul Ganssle&lt;/a&gt;【5】（setuptools 与 dateutil 的维护者）的话:&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;理想情况下，默认选项应该是一个声明式的（declarative）构建配置，适用于 99% 的情况，再提供一个退回到命令式系统的选项，供真正需要灵活性时使用。在这情况下，如果你发现还需要选择用命令式的构建，那么我们可以认为出现了坏味道代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;setup.py&lt;/code&gt; 的最大的问题是大多数人是声明式地使用它，所以当他们用命令式时，往往会将 bug 引入到构建系统。一个这样的例子：如果你有一个 Python2.7 的依赖项，你可能会试图有条件地在 setup.py 中指定 sys.version，但 sys.version 仅指的是执行构建的解释器；相反，你应该对需求项使用声明式的环境标记…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;在 2015 年的引入的&lt;a href=&quot;https://pypi.org/project/flit/&quot;&gt;flit&lt;/a&gt;【6】已经证明了这一假设的正确性。它已经成为许多 Python 新手最喜欢的打包工具，因为它可以确保新用户避免很多这样的麻烦。然而，要达到这个目的，flit 必须再次构建在 distutils/setuptools 之上，这使得它的实现非常关键，并且代码仓出现相当多的垫片层（例如，它仍然为源发行版生成 setup.py 文件）。&lt;/div&gt;
&lt;div&gt;现在是时候把它从这些束缚中解放出来了，同时也鼓励其他人构建自己的打包工具来简化打包，是时候让 setup.py 成为例外而不是默认的了。setuptools &lt;a href=&quot;https://github.com/pypa/setuptools/pull/1675&quot;&gt;计划提供&lt;/a&gt;【7】一个用户专用的&lt;code&gt;setup.cfg&lt;/code&gt; 接口来起带头作用，当一个 PEP-517 系统就位时，在大多数情况下，你应该选择它而不是使用 setup.py。&lt;/div&gt;
&lt;div&gt;为了不把所有东西都绑定到 setuptools 和 distutils 上，并使后端的构建变得便利， &lt;a href=&quot;https://www.python.org/dev/peps/pep-0517/&quot;&gt;PEP-517&lt;/a&gt;【8】被创建了。它将构建器分成后端和前端。前端提供了一个隔离的 Python 环境，满足所有声明的构建依赖项；后端提供了钩子，被前端从其隔离环境中调用，以生成源发行版或者 wheel。&lt;/div&gt;
&lt;div&gt;此外，我们不再通过 setup.py 文件或命令与后端通信，而是使用了 Python 模块和函数。所有后端的打包必须提供一个 Python 对象 API，至少实现 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0517/#build-wheel&quot;&gt;build_wheel&lt;/a&gt;【9】和 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0517/#id9&quot;&gt;build_sdist&lt;/a&gt;【10】两个方法。该 API 对象是通过 pyproject.toml 文件指定的，使用&lt;code&gt;build-backend&lt;/code&gt; 键值：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;[&lt;/span&gt;build&lt;span&gt;-&lt;/span&gt;system&lt;span&gt;]&lt;/span&gt;
requires &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;flit&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
build&lt;span&gt;-&lt;/span&gt;backend &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;flit.api:main&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上述代码对于前端意味着，你可以通过在隔离的 Python 环境中运行它来控制后端：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; flit&lt;span&gt;.&lt;/span&gt;api
backend &lt;span&gt;=&lt;/span&gt; flit&lt;span&gt;.&lt;/span&gt;api&lt;span&gt;.&lt;/span&gt;main

&lt;span&gt;# build wheel via &lt;/span&gt;
backend&lt;span&gt;.&lt;/span&gt;build_wheel&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# build source distribution via&lt;/span&gt;
backend&lt;span&gt;.&lt;/span&gt;build_sdist&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;由后端决定要在哪里和怎样公开自己的官方 API：&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://flit.readthedocs.io/en/latest/&quot;&gt;flit&lt;/a&gt;【11】通过&lt;code&gt;flit.buildapi&lt;/code&gt;实现&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://setuptools.readthedocs.io/en/latest/history.html#v40-8-0&quot;&gt;setuptools&lt;/a&gt;【12】提供了两种变体：&lt;code&gt;setuptools.build_meta&lt;/code&gt;（后面会解释原因）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://poetry.eustace.io/docs/pyproject/#poetry-and-pep-517&quot;&gt;poetry&lt;/a&gt;【13】通过&lt;code&gt;poetry.masonry.api&lt;/code&gt;实现&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;因为这些，我们就拥有了不再受 distutils 遗留决策约束的打包工具。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;￼Sarthak Dubey摄/Unsplash—更多 yay!&lt;/div&gt;
&lt;h2&gt;tox 和打包&lt;/h2&gt;
&lt;div&gt;tox 是一个&lt;a href=&quot;https://tox.readthedocs.io/en/latest/&quot;&gt;测试工具&lt;/a&gt;【14】，大多数项目使用它来确保某个包在多个 Python 解释器上的版本兼容性。它还可以轻松地创建 Python 环境，在里面安装被监测的包，从而更快地复现问题。&lt;/div&gt;
&lt;div&gt;为了能够测试一个包，它首先需要构建一个源发行版。虽然 PEP-518 和 PEP-517 都带有好的意图，但是在某些情况下，启用它们可能会破坏打包过程。因此，当 tox 在 3.3.0 版本中添加隔离构建时，决定暂时不默认启用它。你需要手动启用它（可能会在今年晚些时候——2019 年的版本 4 中默认启用）。&lt;/div&gt;
&lt;div&gt;一旦你指定了一个&lt;code&gt;pyproject.toml&lt;/code&gt; ，写了适当的&lt;code&gt;requires&lt;/code&gt; 和&lt;code&gt;build-backend&lt;/code&gt;，你需要启用&lt;code&gt;tox.ini&lt;/code&gt; 中的&lt;code&gt;isolated_build&lt;/code&gt;标志：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;[&lt;/span&gt;tox&lt;span&gt;]&lt;/span&gt;
isolated_build &lt;span&gt;=&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在此之后，在&lt;a href=&quot;https://tox.readthedocs.io/en/latest/#system-overview&quot;&gt;打包过程中&lt;/a&gt;【15】，tox 将在独立的 Python 环境中为每个 PEP-518 提供构建依赖项，来构建源发行版，并调用 PEP-517 所述的构建后端。&lt;/div&gt;
&lt;div&gt;若不启用该功能，tox 将使用老方法构建源发行版，也就是使用安装了 tox 的解释器来调用&lt;code&gt;python setup.py sdist&lt;/code&gt;命令。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Matthew Henry摄/Unsplash—这里没有免费的午餐呢!&lt;/div&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;div&gt;Python 打包官方希望所有这些都是有意义的，并因此拥有一个更用户友好的、防错的（error proof ）和健壮的构建。这些标准的规范是在 2015 年至 2017 年的长期主题中写作并争论出来的。这两个提案（PEP-517/518）被认为是足够好的，可以获得最大的收益，但是一些不太主流的场景可能会被忽略。&lt;/div&gt;
&lt;div&gt;如果你的情况是被忽略的，不要担心，如果我们认为必要的话，PEP 在任何时候都是拥抱改进意见的。在本系列的&lt;a href=&quot;https://www.bernat.tech/growing-pain/&quot;&gt;下一篇文章中&lt;/a&gt;【16】，我将讨论社区在发布这两个 PEP 时碰撞到的一些痛点。这些都是我们应该吸取的教训，并且表明着我们仍有一些工作要做。还不是一切都完美，但我们正在变得更好。如果你可以帮帮忙，就加入打包社区吧，让我们一起把事情做得更好!&lt;/div&gt;
&lt;h3&gt;附1：勘误&lt;/h3&gt;
&lt;div&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s/-zwZWV3MaFeat96_AoVJCg&quot;&gt;前一篇文章&lt;/a&gt;中，source distribution 被译成“源码分发”，但它还有一个更被人采用的译法是“源发行版”，为了便于接受，所以本文已作修改。翻译匆忙，如有错误，欢迎读者指正！万分感谢！PS：后续若有修正，会在知乎专栏修改，请关注“Python进阶之旅”：&lt;a href=&quot;https://zhuanlan.zhihu.com/pythonCat&quot;&gt;https://zhuanlan.zhihu.com/pythonCat&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;附2：相关链接&lt;/h3&gt;
&lt;div&gt;[1] Python packaging - Past, Present, Future: &lt;a href=&quot;https://www.bernat.tech/pep-517-518/&quot;&gt;https://www.bernat.tech/pep-517-518/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[2] distutils: &lt;a href=&quot;https://packaging.python.org/key_projects/#distutils&quot;&gt;https://packaging.python.org/key_projects/#distutils&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[3] twine: &lt;a href=&quot;https://pypi.org/project/twine/&quot;&gt;https://pypi.org/project/twine/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[4] PEP-518 : &lt;a href=&quot;https://www.python.org/dev/peps/pep-0518/&quot;&gt;https://www.python.org/dev/peps/pep-0518/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[5] Paul Ganssle: &lt;a href=&quot;https://twitter.com/pganssle&quot;&gt;https://twitter.com/pganssle&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[6] flit: &lt;a href=&quot;https://pypi.org/project/flit/&quot;&gt;https://pypi.org/project/flit/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[7] 计划提供: &lt;a href=&quot;https://github.com/pypa/setuptools/pull/1675&quot;&gt;https://github.com/pypa/setuptools/pull/1675&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[8] PEP-517: &lt;a href=&quot;https://www.python.org/dev/peps/pep-0517/&quot;&gt;https://www.python.org/dev/peps/pep-0517/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[9] build_wheel: &lt;a href=&quot;https://www.python.org/dev/peps/pep-0517/#build-wheel&quot;&gt;https://www.python.org/dev/peps/pep-0517/#build-wheel&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[10] build_sdist: &lt;a href=&quot;https://www.python.org/dev/peps/pep-0517/#id9&quot;&gt;https://www.python.org/dev/peps/pep-0517/#id9&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[11] flit: &lt;a href=&quot;https://flit.readthedocs.io/en/latest/&quot;&gt;https://flit.readthedocs.io/en/latest/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[12] setuptools: &lt;a href=&quot;https://setuptools.readthedocs.io/en/latest/history.html#v40-8-0&quot;&gt;https://setuptools.readthedocs.io/en/latest/history.html#v40-8-0&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[13] poetry: &lt;a href=&quot;https://poetry.eustace.io/docs/pyproject/#poetry-and-pep-517&quot;&gt;https://poetry.eustace.io/docs/pyproject/#poetry-and-pep-517&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[14] 测试工具: &lt;a href=&quot;https://tox.readthedocs.io/en/latest/&quot;&gt;https://tox.readthedocs.io/en/latest/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[15] 打包过程中: &lt;a href=&quot;https://tox.readthedocs.io/en/latest/#system-overview&quot;&gt;https://tox.readthedocs.io/en/latest/#system-overview&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[16] 下一篇文章中: &lt;a href=&quot;https://www.bernat.tech/growing-pain/&quot;&gt;https://www.bernat.tech/growing-pain/&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 打包的现状：包的三种类型</title>
            <link>https://pythoncat.top/posts/2020-01-03-packaging/</link>
            <guid>https://pythoncat.top/posts/2020-01-03-packaging/</guid>
            <pubDate>Fri, 03 Jan 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;英文&lt;/strong&gt;  | &lt;a href=&quot;https://www.bernat.tech/pep-517-and-python-packaging/&quot;&gt;The state of Python Packaging&lt;/a&gt;【1】&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;原作&lt;/strong&gt;  | BERNAT GABOR&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt;  | 豌豆花下猫&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;声明&lt;/strong&gt; ：本文获得原作者授权翻译，转载请保留原文出处，请勿用于商业或非法用途。&lt;/div&gt;
&lt;div&gt;&lt;code&gt;pip&lt;/code&gt; 19.0 已经于 2019 年 1 月 22 日发布。在其功能列表中，最值得注意的是它现在支持 PEP-517，默认情况下是支持的，如果项目的根目录中有一个 pyproject.toml。该 PEP 于 2015 年创建，并于 2017 年被接受。尽管 pip 花了一段时间才实现它，但该版本及其后续问题却表明，很多人根本不熟悉它。&lt;/div&gt;
&lt;div&gt;如果你想了解 Python 打包（packaging）生态的现状及将来如何演变，请继续阅读。我们希望，即使上述提到的 Python 增强提案（译注：即 PEP，关于 PEP 的介绍，请阅读&lt;a href=&quot;https://mp.weixin.qq.com/s/oRoBxZ2-IyuPOf_MWyKZyw&quot;&gt;这篇文章&lt;/a&gt;），如今可能会引起一些不愉快，但从长远来看，我们将从中受益。&lt;/div&gt;
&lt;div&gt;我大约在三年前加入了 Python 开源社区（尽管使用它已有 8 年之久）。从早期开始，我就听说 Python 打包有一点黑匣子的名声。它有很多未知的内容，人们通常只复制其它项目的构建配置文件，就使用上了。&lt;/div&gt;
&lt;div&gt;在尝试更好地理解这个黑匣子，并对其进行改进的过程中，我已经成为了 virtualenv 和 tox 项目的维护者，偶尔也为 setuptools 和 pip 做些贡献。&lt;/div&gt;
&lt;div&gt;我希望对这个主题进行详尽的（并希望是一个较高水平的）论述，并决定将其分为三个部分。在这第一篇文章中，我将对 Python 打包的工作方式及其所具有的打包类型进行大概介绍。在第二篇文章中，我将详细地介绍软件包的安装方式，以及 PEP-517/518 是如何尝试对其进行改进的。最后，我再专门写另一篇文章，以介绍在引入这些改进时，我们吸取的一些痛苦的教训。&lt;/div&gt;
&lt;div&gt;事先声明，我将主要关注 Python 官方的打包系统（即 pip、setuptools，因此没有 conda 或特定于操作系统的打包程序）。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Marcus Cramer 摄/Unsplash—人们第一次凝视 Python 打包时的脸&lt;/div&gt;
&lt;h2&gt;一个示例项目&lt;/h2&gt;
&lt;div&gt;为了讲这个故事，我需要先讲讲如何分发 Python 软件包的故事；更具体地说，包的安装在过去是如何运作的，以及我们希望它在将来如何运作。&lt;/div&gt;
&lt;div&gt;为了有一个具体的示例，让我介绍一下我的很棒的示例库：&lt;code&gt;pugs&lt;/code&gt; 。这个库相当简单：它只生成一个名为 pugs 的包，仅包含一个名为 logic 的模块。关于 pugs，你猜对了，logic 被用于生成随机的引号。这是一个展现为源码树（source tree）的简单示例结构（可以在&lt;a href=&quot;https://github.com/gaborbernat/pugs&quot;&gt;gaborbernat / pugs&lt;/a&gt; 【2】里获得）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;pugs&lt;span&gt;-&lt;/span&gt;project
├── README&lt;span&gt;.&lt;/span&gt;rst
├── setup&lt;span&gt;.&lt;/span&gt;cfg
├── setup&lt;span&gt;.&lt;/span&gt;py
├── LICENSE&lt;span&gt;.&lt;/span&gt;txt
├── src
│   └── pugs
│       ├── __init__&lt;span&gt;.&lt;/span&gt;py
│       └── logic&lt;span&gt;.&lt;/span&gt;py
├── tests
│   ├── test_init&lt;span&gt;.&lt;/span&gt;py
│   └── test_logic&lt;span&gt;.&lt;/span&gt;py
├── tox&lt;span&gt;.&lt;/span&gt;ini
└── azure&lt;span&gt;-&lt;/span&gt;pipelines&lt;span&gt;.&lt;/span&gt;yml&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这里有四类独特的内容：&lt;/div&gt;
&lt;div&gt;我们的&lt;code&gt;pugs&lt;/code&gt; 包在用户机器的解释器上能用，意味着什么？在理想情况下，一旦启动解释器，用户应该能够 import 它，并调用其中的函数：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;业务逻辑代码（src 文件夹中的内容）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试代码（tests 文件夹和 tox.ini）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;包代码和元数据（setup.py、setup.cfg、LICENSE.txt、README.rst—请注意，我们如今使用的是事实上的标准打包工具&lt;a href=&quot;https://pypi.org/project/setuptools&quot;&gt;setuptools&lt;/a&gt;【3】）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有助于项目管理和维护的文件：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;持续集成（azure-pipelines.yml）&lt;/li&gt;
&lt;li&gt;版本控制（.git）&lt;/li&gt;
&lt;li&gt;项目管理（例如潜在的 .github 文件夹）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;Python &lt;span&gt;3.7&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;v3&lt;span&gt;.&lt;/span&gt;&lt;span&gt;7.2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;9a3ffc0492&lt;span&gt;,&lt;/span&gt; Dec &lt;span&gt;24&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;[&lt;/span&gt;Clang &lt;span&gt;6.0&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;clang&lt;span&gt;-&lt;/span&gt;&lt;span&gt;600.0&lt;/span&gt;&lt;span&gt;.57&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; on darwin
Type &lt;span&gt;&quot;help&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;copyright&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;credits&quot;&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; &lt;span&gt;&quot;license&quot;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; more information&lt;span&gt;.&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; pugs
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; pugs&lt;span&gt;.&lt;/span&gt;do_tell&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&quot;An enlightened pug knows how to make the best of whatever he has to work with - A Pug&apos;s Guide to Dating -  Gemma Correll&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Ryan Antooa 摄/Unsplash—让我们开始吧，兴奋！&lt;/div&gt;
&lt;h2&gt;Python 包的可用性&lt;/h2&gt;
&lt;div&gt;Python 怎么知道什么可用或不可用？简短的答案是，它不知道。至少不在前期知道。相反，它将尝试加载，并动态地检查是否可用。&lt;/div&gt;
&lt;div&gt;它从哪里加载？有许多可能的位置，但是在大多数情况下，我们说的是从文件系统的文件夹中加载。这个文件夹在哪里呢？对于给定的模块，可以打印该模块的表示（representation）来找出：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; pugs
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; pugs
&lt;span&gt;&amp;lt;&lt;/span&gt;module &lt;span&gt;&apos;pugs&apos;&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&apos;/Users/bernat/Library/Python/3.7/lib/python/site-packages/pugs/__init__.py&apos;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;你会发现文件夹的位置取决于：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;软件包的类型（三方库或者标准库的内置/aka部分）&lt;/li&gt;
&lt;li&gt;它是全局的或仅限于当前的用户（请参阅&lt;a href=&quot;https://www.python.org/dev/peps/pep-0370/&quot;&gt;PEP-370&lt;/a&gt;【4】）&lt;/li&gt;
&lt;li&gt;以及它是系统 Python 还是一个虚拟环境&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;但是一般来说，对于给定的 Python 解释器，可以通过打印出 sys.path 变量的内容，来找到可能的目录列表，例如在我的 MacOS 上：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; sys
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;\n&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;join&lt;span&gt;(&lt;/span&gt;sys&lt;span&gt;.&lt;/span&gt;path&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;/&lt;/span&gt;Library&lt;span&gt;/&lt;/span&gt;Frameworks&lt;span&gt;/&lt;/span&gt;Python&lt;span&gt;.&lt;/span&gt;framework&lt;span&gt;/&lt;/span&gt;Versions&lt;span&gt;/&lt;/span&gt;&lt;span&gt;3.7&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;lib&lt;span&gt;/&lt;/span&gt;python37&lt;span&gt;.&lt;/span&gt;&lt;span&gt;zip&lt;/span&gt;
&lt;span&gt;/&lt;/span&gt;Library&lt;span&gt;/&lt;/span&gt;Frameworks&lt;span&gt;/&lt;/span&gt;Python&lt;span&gt;.&lt;/span&gt;framework&lt;span&gt;/&lt;/span&gt;Versions&lt;span&gt;/&lt;/span&gt;&lt;span&gt;3.7&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;lib&lt;span&gt;/&lt;/span&gt;python3&lt;span&gt;.&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;
&lt;span&gt;/&lt;/span&gt;Library&lt;span&gt;/&lt;/span&gt;Frameworks&lt;span&gt;/&lt;/span&gt;Python&lt;span&gt;.&lt;/span&gt;framework&lt;span&gt;/&lt;/span&gt;Versions&lt;span&gt;/&lt;/span&gt;&lt;span&gt;3.7&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;lib&lt;span&gt;/&lt;/span&gt;python3&lt;span&gt;.&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;lib&lt;span&gt;-&lt;/span&gt;dynload
&lt;span&gt;/&lt;/span&gt;Users&lt;span&gt;/&lt;/span&gt;bernat&lt;span&gt;/&lt;/span&gt;Library&lt;span&gt;/&lt;/span&gt;Python&lt;span&gt;/&lt;/span&gt;&lt;span&gt;3.7&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;lib&lt;span&gt;/&lt;/span&gt;python&lt;span&gt;/&lt;/span&gt;site&lt;span&gt;-&lt;/span&gt;packages
&lt;span&gt;/&lt;/span&gt;Library&lt;span&gt;/&lt;/span&gt;Frameworks&lt;span&gt;/&lt;/span&gt;Python&lt;span&gt;.&lt;/span&gt;framework&lt;span&gt;/&lt;/span&gt;Versions&lt;span&gt;/&lt;/span&gt;&lt;span&gt;3.7&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;lib&lt;span&gt;/&lt;/span&gt;python3&lt;span&gt;.&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;site&lt;span&gt;-&lt;/span&gt;packages&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;对于第三方软件包，会是一些 site-packages 文件夹。在以上示例中，请注意哪些是在整个系统范围内，哪些仅属于一个特定的用户。这些包是如何被放在此文件夹中的？它一定是由某些安装程序放在那里的。&lt;/div&gt;
&lt;div&gt;下图展示了大多数的运行情况：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;开发者在文件夹（称为源码树）内编写一些 Python 代码。&lt;/li&gt;
&lt;li&gt;然后，某些工具（例如 setuptools）将源码树打包以进行重新分发。&lt;/li&gt;
&lt;li&gt;生成的软件包通过另一个工具（twine），上传到可以被终端用户计算机访问的中央存储仓（通常为&lt;a href=&quot;https://pypi.org/&quot;&gt;https://pypi.org&lt;/a&gt;【5】）。&lt;/li&gt;
&lt;li&gt;终端用户计算机使用一些安装程序来查找、下载和安装相关软件包。安装操作最终是在 site-packages 文件夹内，创建正确的目录结构和元数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Pinho/摄—在探索新鲜事物&lt;/div&gt;
&lt;h2&gt;Python 包的类型&lt;/h2&gt;
&lt;div&gt;在安装时，软件包必须生成至少两种类型的内容，以放入 site-packages 中：有关软件包内容的元数据文件夹，其中包含 {package}-{version} .dist-info 和业务逻辑文件。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;/&lt;/span&gt;Users&lt;span&gt;/&lt;/span&gt;bgabor8&lt;span&gt;/&lt;/span&gt;Library&lt;span&gt;/&lt;/span&gt;Python&lt;span&gt;/&lt;/span&gt;&lt;span&gt;3.7&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;lib&lt;span&gt;/&lt;/span&gt;python&lt;span&gt;/&lt;/span&gt;site&lt;span&gt;-&lt;/span&gt;packages&lt;span&gt;/&lt;/span&gt;pugs
├── __init__&lt;span&gt;.&lt;/span&gt;py
├── __pycache__
│   ├── __init__&lt;span&gt;.&lt;/span&gt;cpython&lt;span&gt;-&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;pyc
│   └── logic&lt;span&gt;.&lt;/span&gt;cpython&lt;span&gt;-&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;pyc
└── logic&lt;span&gt;.&lt;/span&gt;py

&lt;span&gt;/&lt;/span&gt;Users&lt;span&gt;/&lt;/span&gt;bgabor8&lt;span&gt;/&lt;/span&gt;Library&lt;span&gt;/&lt;/span&gt;Python&lt;span&gt;/&lt;/span&gt;&lt;span&gt;3.7&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;lib&lt;span&gt;/&lt;/span&gt;python&lt;span&gt;/&lt;/span&gt;site&lt;span&gt;-&lt;/span&gt;packages&lt;span&gt;/&lt;/span&gt;pugs&lt;span&gt;-&lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;dist&lt;span&gt;-&lt;/span&gt;info
├── INSTALLER
├── LICENSE&lt;span&gt;.&lt;/span&gt;txt
├── METADATA
├── RECORD
├── WHEEL
├── top_level&lt;span&gt;.&lt;/span&gt;txt
└── &lt;span&gt;zip&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;safe&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;发行信息（dist-info）文件夹描述了该软件包：用于安装该软件包的安装程序、该软件包所附的许可证、在安装过程中创建的文件、顶层 Python 软件包是什么、该软件包暴露的入口等等。在&lt;a href=&quot;https://www.python.org/dev/peps/pep-0427/%23id14#id14&quot;&gt;PEP-427&lt;/a&gt;【6】 中可以找到每个文件的详细说明。&lt;/div&gt;
&lt;div&gt;我们如何从源码树中获得这两种类型的内容呢？我们面前有两条截然不同的路径：&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;从我们的源码树生成此目录结构和元数据，将其压缩为单个文件，然后将其发布到中央软件包存储仓。在这种情况下，安装程序必须下载软件包并将其解压到 site-packages 文件夹中。我们将这种类型的包称为 &lt;code&gt;wheel&lt;/code&gt; 包。&lt;/li&gt;
&lt;li&gt;或者，你可以创建一个包含软件包源码的归档文件，构建所需的脚本和元数据，以生成可安装的（installable）目录结构，然后将其上传到中央存储仓。这称为源码分发或 sdist。在这种情况下，安装程序还有很多工作要做，它需要解压归档文件，运行构建器，然后再将其复制。&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;这两个方法的区别主要在于包的编译/构建操作发生在哪里：在开发者的计算机上还是在终端用户的计算机上。如果它发生在开发者的一边（例如在 wheel 的情况下），则安装过程非常轻巧。一切都已经在开发机器上完成了。用户机器的操作仅是简单的下载和解压。&lt;/div&gt;
&lt;div&gt;在本例中，我们使用 setuptools 作为构建器（从源码树生成要放入 site-packages 文件夹中的内容）。因此，为了在用户机器上执行构建操作，我们需要确保在用户机器上有合适版本的 setuptools （如果你使用的是 40.6.0 版的功能，则必须确保用户具有该版本或大于该版本）。&lt;/div&gt;
&lt;div&gt;要考虑的另一种情况是 Python 提供了从其内部访问 C/C++ 库的能力（在需要的地方获得额外的性能）。这样的软件包被称为 C 扩展包（C-extension packages），因为它们利用了 CPython 提供的 C 扩展 API。&lt;/div&gt;
&lt;div&gt;此类扩展需要编译 C/C++ 功能，才能适用与其交互的 C/C++ 库和当前 Python 解释器的 C-API 库。在这些情况下，构建操作实际上涉及到调用一个二进制编译器，而不仅仅是像纯 Python 包（例如我们的 pugs 库）那样，生成元数据和文件夹结构。&lt;/div&gt;
&lt;div&gt;如果在用户计算机上进行构建，则需要确保在构建时，有可用的正确的库和编译器。现在这是一项相对困难的工作，因为有些特定于平台的二进制文件，也是通过平台打包工具分发的。这些库的缺失或版本不匹配通常会在构建时触发隐秘的错误，使用户感到沮丧和困惑。&lt;/div&gt;
&lt;div&gt;因此，如果可能的话，始终选择将 package 打包成 wheel。这将完全避免用户缺少正确的构建依赖项的问题（纯 Python 类型如 setuptools 或二进制类型的 C/C++ 编译器）。即使这些构建依赖项易于配置（例如，使用纯 Python 构建器—例如 setuptools），你完全可以避免此步骤，来节省安装的时间。&lt;/div&gt;
&lt;div&gt;话虽如此，仍然有两种需要提供源码分发的情况（即使在你提供 wheel 的情况下）：&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;C 扩展的源码分发往往更易于审核，因为人们可以阅读源代码，从而在其内容上有更高的透明度：许多大型公司的环境出于此单一原因，更倾向于使用 wheel（它们通常会将此扩展到纯 Python wheel，主要是为了避免对哪些是纯 Python 和什么不是做分类）。&lt;/li&gt;
&lt;li&gt;你可能无法为每个可能的平台都提供一个 wheel（在使用 C 扩展包的情况下，尤其如此），在这种情况下，源码分发可以让这些平台自行生成 wheel。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;div&gt;源码树（source tree）、源码分发（source distribution）和 wheel 之间的区别：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;源码树——包含在开发者的机器/存储仓上可用的所有项目文件（业务逻辑、测试、打包数据、CI 文件、IDE 文件、SVC 等），例如，请参见上面的示例项目。&lt;/li&gt;
&lt;li&gt;源码分发——包含构建 wheel 所需的代码文件（业务逻辑+打包数据+通常还包括单元测试文件，用于校验构建；但是不包含开发者环境的内容，例如 CI/IDE/版本控制文件），格式：pugs-0.0 .1.tar.gz 。&lt;/li&gt;
&lt;li&gt;wheel——包含包的元数据和源码文件，被放到 site packages 文件夹，格式：pugs-0.0.1-py2.py3-NONE-any.whl 。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Charles PH 摄/Unsplash—hmmm&lt;/div&gt;
&lt;div&gt;可在此阅读本系列的&lt;a href=&quot;https://www.bernat.tech/pep-517-518/&quot;&gt;下一篇文章&lt;/a&gt;【7】，了解在安装软件包时会发生什么。谢谢阅读！&lt;/div&gt;
&lt;h4&gt;相关链接&lt;/h4&gt;
&lt;div&gt;[1] The state of Python Packaging: &lt;a href=&quot;https://www.bernat.tech/pep-517-and-python-packaging/&quot;&gt;https://www.bernat.tech/pep-517-and-python-packaging/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[2] gaborbernat / pugs: &lt;a href=&quot;https://github.com/gaborbernat/pugs&quot;&gt;https://github.com/gaborbernat/pugs&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[3] setuptools: &lt;a href=&quot;https://pypi.org/project/setuptools&quot;&gt;https://pypi.org/project/setuptools&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[4] PEP-370: &lt;a href=&quot;https://www.python.org/dev/peps/pep-0370/&quot;&gt;https://www.python.org/dev/peps/pep-0370/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[5] &lt;a href=&quot;https://pypi.org:%C2%A0https://pypi.org/&quot;&gt;https://pypi.org: https://pypi.org/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[6] PEP-427: &lt;a href=&quot;https://www.python.org/dev/peps/pep-0427/%23id14#id14&quot;&gt;https://www.python.org/dev/peps/pep-0427/%23id14#id14&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[7] 下一篇文章: &lt;a href=&quot;https://www.bernat.tech/pep-517-518/&quot;&gt;https://www.bernat.tech/pep-517-518/&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>开发者请注意：Python2 的最后版本将于 4 月发布，但它确实是在 1 月 1 日就寿命终止了！</title>
            <link>https://pythoncat.top/posts/2020-01-02-Python2/</link>
            <guid>https://pythoncat.top/posts/2020-01-02-Python2/</guid>
            <pubDate>Thu, 02 Jan 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;2020 年 1 月 1 日是 Python2 的寿命终止日，这个日期在两年前经”Python之父” Guido van Rossum 宣布，此后一直成为开发者社区翘首以盼的一天。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;昨天就是这个大快人心的日子，各种变了花样的喜庆报道不绝于目。调侃的玩笑也不少，比如这个：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;还有这个（别信！）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;然而，我今天偶然看到一位大佬的疑问，大意如下：官网发布的 Python2 退休日期说是 4 月，那个倒计时网站是不是冒充的官方消息？&lt;/div&gt;
&lt;div&gt;他所说的官网消息是这篇——&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;怎么回事呢？传了那么久的元旦退休消息，竟然会不准确？那么多人在热热闹闹地庆祝着，竟然是在庆祝一个假消息么？&lt;/div&gt;
&lt;div&gt;我搜索那篇文章，仔细读了一遍，然后才注意到发布日期是 2019 年 12 月 20 日，也就是两周前。文中没有提到 1 月 1 日，也没提 4 月的具体日子。&lt;/div&gt;
&lt;div&gt;文章属实，但日期明显矛盾，这是怎么回事呢？官方应该会有所解释吧？带着疑问，我去翻看官方和几个核心开发者的推特。&lt;/div&gt;
&lt;div&gt;经过一番资料查阅，我终于搞清楚了怎么回事，也找到了所谓的”官方解释”。&lt;/div&gt;
&lt;div&gt;简单说明结论：&lt;strong&gt;2020-01-01 是板上钉钉的 Python2 的 EOL (end of life，寿命终止)日子，但是在这个日子前的版本发布周期还在进行，最后一个版本按计划是在今年 4 月的 Pycon US 大会上发布。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;Python2.7 在 2019 年的最后一个版本是 10 月 19 日发布的 2.7.17 版本，在它之后直到2020-01-01 之间产生的所有问题，开发者们是接受的，而计划合入的版本将是 4 月 17 日的 2.7.18 版本。&lt;/div&gt;
&lt;div&gt;以篮球比赛中的压哨球来类比，你就明白怎么回事了：球离手在空中飞了三分之一路程，这时终止的哨声吹响，最后这球中袋了当然还是有效的。&lt;/div&gt;
&lt;div&gt;进行了三分之一的 2.7.18 版本，就像离手之球，离弦之箭，泼出之水，负责任的 Python 官方还是要认可它的。&lt;/div&gt;
&lt;div&gt;其实，这个决定并不是最近确定的，早在 2019 年 9 月，Python2 的版本经理 Benjamin Peterson 就公布了这个计划，这里是当时的邮件组截图：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;有不少开发者表示了疑义：为什么不能把 4 月的发布计划提前呢？如果是 4 月发布最后版本，为什么不说 4 月才是 EOL 呢？为什么容许出现两个不一致的日期？&lt;/div&gt;
&lt;div&gt;根据我对讨论内容的理解，主要有如下原因：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;12 月末不是一个方便的“工作”时间（因为感恩节放假！）&lt;/li&gt;
&lt;li&gt;4 月有一年一度的社区大会，届时大家可以集体宣泄&lt;/li&gt;
&lt;li&gt;Python 1 的最后版本（1.6.1）已经有此先例&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;有不少开发者也表示附议，认可这个安排。&lt;/div&gt;
&lt;div&gt;如果 PSF 在发布那篇“4 月退休”的文章时，对此安排作出解释，也许大家就不会有那么多困惑了，更不至于怀疑自己在传播假消息……&lt;/div&gt;
&lt;div&gt;看到这，你也应该理解了来龙去脉吧？不过，我相信还是有读者有疑问：既然早就知道会有这个尾巴要处理，为什么不能加快进度，多投精力，争取一分不差地在 2019-12-31 发布最后一个版本呢？&lt;/div&gt;
&lt;div&gt;追进度、赶 deadline、加班加点，这种事情在国内互联网领域是司空见惯了。然而，Python 核心开发者们几乎都是志愿者，花的是业余兴趣时间，他们的主业可能都不至于 996，怎么能指望在副业上 996 呢？！不要强人所难！&lt;/div&gt;
&lt;div&gt;最后，不管怎么说，Python2 确实是在 2020-01-01 就 EOL 了，此后自生自灭。&lt;/div&gt;
&lt;div&gt;它的最后一个版本会在 4 月份发布（只包含 1 月 1 日前的问题），我们不用着急，就让这只球飞一会吧，等到球落袋的时候，我们再一起，举杯相庆！&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>我的 2019 年 Python 文章榜单</title>
            <link>https://pythoncat.top/posts/2020-01-01-writing/</link>
            <guid>https://pythoncat.top/posts/2020-01-01-writing/</guid>
            <pubDate>Wed, 01 Jan 2020 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;现在是 2020 年的第一天，我相信从昨天开始，各位的信息流里肯定充斥了各式各样的年度盘点/回顾/总结/记录之类的内容。虽然来得稍晚了，但我还是想给诸位送上这一篇文章。&lt;/div&gt;
&lt;div&gt;我将在本文中列出自己于 2019 年度里最喜爱的 10 篇 Python 文章。我的选择标准是极为个性化的，甚至会有点任性，因为我的第一条标准是：&lt;strong&gt;文章必须是我原创或者翻译的。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;如标题所言，这就是“我的”文章榜单。同时，为了丰富本文内容，我在榜单之后，还会附上其他人所盘点的文章榜单，给大家呈上更多的精彩内容。&lt;/div&gt;
&lt;h3&gt;我的年度十佳文章&lt;/h3&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/co_OAaVQ49rPfgoAh6Pejw&quot;&gt;Python 中 -m 的典型用法、原理解析与发展演变&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/8f259oIGCQtY6KFSx4KW6Q&quot;&gt;Python 内存分配时的小秘密&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/IRAjR-KHZBPEEkdiofseGQ&quot;&gt;Python进阶：全面解读高级特性之切片！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/pKQT5wvyaSNFvnJexiCC8w&quot;&gt;len(x) 击败 x.len()，从内置函数看 Python 的设计思想&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/OypPwnJ2vX2vJtZRkVa-Ug&quot;&gt;编程语言之问：何时该借用，何时该创造？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ovIiw7ZmXJM4qUSTGDk7kQ&quot;&gt;Python 之父撰文回忆：为什么要创造 pgen 解析器？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/nfCFwFSLoaVLM2Q4mPqpSw&quot;&gt;Python 进阶之源码分析：如何将一个类方法变为多个方法？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/e9B_jpyeSMkmEpuRQqqk4g&quot;&gt;遇见一只黑猫，她说Python是个怪物&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/jLrcS5c5lLOU-k2B0Y31QQ&quot;&gt;[译] PEP 318—函数和方法的装饰器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/XzCqoCvcpFJt4A-E4WMqaA&quot;&gt;聊聊 Python 的内置电池&lt;/a&gt; / &lt;a href=&quot;https://mp.weixin.qq.com/s/NuzfuH_zCZzcrmSFR04NHw&quot;&gt;聊聊 print 的前世今生&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;附录三份榜单：&lt;/h3&gt;
&lt;h4&gt;1、爱湃森年度 Python 榜单&lt;/h4&gt;
&lt;div&gt;&lt;a href=&quot;https://blogs.dropbox.com/tech/2019/09/our-journey-to-type-checking-4-million-lines-of-python&quot;&gt;Our journey to type checking 4 million lines of Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.dataquest.io/blog/advanced-jupyter-notebooks-tutorial&quot;&gt;Tutorial: Advanced Jupyter Notebooks&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://realpython.com/cpython-source-code-guide&quot;&gt;Your Guide to the CPython Source Code&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://blogs.dropbox.com/tech/2019/02/incrementally-migrating-over-one-million-lines-of-code-from-python-2-to-python-3&quot;&gt;Incrementally migrating over one million lines of code from Python 2 to Python 3&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://snarky.ca/why-you-should-use-python-m-pip&quot;&gt;Why you should use python -m pip&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.bernat.tech/pep-517-and-python-packaging&quot;&gt;The state of Python Packaging&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://sourcery.ai/blog/python-best-practices&quot;&gt;How to set up a perfect Python project&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://doughellmann.com/blog/2019/06/29/dependencies-between-python-standard-library-modules&quot;&gt;Dependencies between Python Standard Library modules&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://skerritt.blog/timsort-the-fastest-sorting-algorithm-youve-never-heard-of&quot;&gt;Timsort — the fastest sorting algorithm you’ve never heard of&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.daolf.com/posts/web-scraping-101-python&quot;&gt;Web Scraping 101 with Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;----出处：&lt;a href=&quot;https://annual2019.pycourses.com/&quot;&gt;爱湃森 2019 年度 Python 榜单&lt;/a&gt;&lt;/div&gt;
&lt;h4&gt;2、RealPython 年度 Python 榜单&lt;/h4&gt;
&lt;div&gt;&lt;a href=&quot;https://realpython.com/run-python-scripts/&quot;&gt;How to Run Your Python Scripts&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://realpython.com/intermediate-python-project-ideas/&quot;&gt;13 Project Ideas for Intermediate Python Developers&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://realpython.com/storing-images-in-python/&quot;&gt;3 Ways of Storing and Accessing Lots of Images&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://realpython.com/python-concurrency/&quot;&gt;Speed Up Your Python Program With Concurrency&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://realpython.com/build-recommendation-engine-collaborative-filtering/&quot;&gt;Build a Recommendation Engine&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://realpython.com/python-print/&quot;&gt;Your Guide to the Python Print Function&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://realpython.com/python-pep8/&quot;&gt;How to Write Beautiful Python Code With PEP 8&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://realpython.com/python-lambda/&quot;&gt;How to Use Python Lambda Functions&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://realpython.com/python-coding-interview-tips/&quot;&gt;How to Stand Out in a Python Interview&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://realpython.com/inheritance-composition-python/&quot;&gt;Inheritance and Composition: A Python OOP Guide&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;----出处：&lt;a href=&quot;https://talkpython.fm/episodes/show/244/top-10-real-python-articles-of-2019&quot;&gt;TalkPython 播客&lt;/a&gt;&lt;/div&gt;
&lt;h4&gt;3、Opensource 年度 Python 榜单&lt;/h4&gt;
&lt;div&gt;&lt;a href=&quot;https://opensource.com/article/19/10/python-programming-paradigms&quot;&gt;Perceiving Python programming paradigms&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://opensource.com/article/19/7/get-modular-python-classes&quot;&gt;Learn object-oriented programming with Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://opensource.com/article/19/10/why-love-python&quot;&gt;5 reasons why I love Python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://opensource.com/article/19/3/python-image-manipulation-tools&quot;&gt;10 Python image manipulation tools&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://opensource.com/article/19/5/python-3-default-mac&quot;&gt;The right and wrong way to set Python 3 as default on a Mac&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://opensource.com/article/19/5/graphically-programming-pythonic&quot;&gt;Graphically program in Python with Pythonic&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://opensource.com/article/19/5/jupyterlab-python-developers-magic&quot;&gt;JupyterLab teaches Python developers magic&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://opensource.com/article/19/4/managing-python-packages&quot;&gt;Managing Python packages the right way&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://opensource.com/article/19/5/python-black&quot;&gt;Format Python however you like with Black&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://opensource.com/article/19/5/python-tox&quot;&gt;Automate your Python code tests with tox&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;----出处：&lt;a href=&quot;https://opensource.com/article/19/12/learn-python&quot;&gt;Opensource的盘点&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 进阶之源码分析：如何将一个类方法变为多个方法？</title>
            <link>https://pythoncat.top/posts/2019-12-22-function/</link>
            <guid>https://pythoncat.top/posts/2019-12-22-function/</guid>
            <pubDate>Sun, 22 Dec 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;前一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s/lF-ba4RvINoodWYd5qKEOQ&quot;&gt;Python 中如何实现参数化测试？&lt;/a&gt;》中，我提到了在 Python 中实现参数化测试的几个库，并留下一个问题：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;它们是如何做到把一个方法变成多个方法，并且将每个方法与相应的参数绑定起来的呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;我们再提炼一下，原问题等于是：&lt;strong&gt;在一个类中，如何使用装饰器把一个类方法变成多个类方法（或者产生类似的效果）？&lt;/strong&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 带有一个方法的测试类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestClass&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;test_func&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;# 使用装饰器，生成多个类方法&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestClass&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;test_func1&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;test_func2&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;test_func3&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 中装饰器的本质就是移花接木，用一个新的方法来替代被装饰的方法。在实现参数化的过程中，我们介绍过的几个库到底用了什么手段/秘密武器呢？&lt;/div&gt;
&lt;h2&gt;1、ddt 如何实现参数化？&lt;/h2&gt;
&lt;div&gt;先回顾一下上篇文章中 ddt 库的写法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; unittest
&lt;span&gt;from&lt;/span&gt; ddt &lt;span&gt;import&lt;/span&gt; ddt&lt;span&gt;,&lt;/span&gt;data&lt;span&gt;,&lt;/span&gt;unpack
&lt;span&gt;@ddt&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyTest&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;unittest&lt;span&gt;.&lt;/span&gt;TestCase&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;@data&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;1.2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;@unpack&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; first&lt;span&gt;,&lt;/span&gt; second&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;ddt 可提供 4 个装饰器：1 个加在类上的 @ddt，还有 3 个加在类方法上的 @data、@unpack 和 @file_data（前文未提及）。&lt;/div&gt;
&lt;div&gt;先看看加在类方法上的三个装饰器的作用：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# ddt 版本（win）：1.2.1&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;data&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;values&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;global&lt;/span&gt; index_len
    index_len &lt;span&gt;=&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;values&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; idata&lt;span&gt;(&lt;/span&gt;values&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;idata&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;iterable&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;wrapper&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;func&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;setattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;func&lt;span&gt;,&lt;/span&gt; DATA_ATTR&lt;span&gt;,&lt;/span&gt; iterable&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; func
    &lt;span&gt;return&lt;/span&gt; wrapper

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;unpack&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;func&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;setattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;func&lt;span&gt;,&lt;/span&gt; UNPACK_ATTR&lt;span&gt;,&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; func

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;file_data&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;wrapper&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;func&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;setattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;func&lt;span&gt;,&lt;/span&gt; FILE_ATTR&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; func
    &lt;span&gt;return&lt;/span&gt; wrapper&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;它们的共同作用是在类方法上 setattr() 添加属性。至于这些属性在什么时候使用？下面看看加在类上的 @ddt 装饰器源码：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;第一层 for 循环遍历了所有的类方法，然后是 if/elif 两条分支，分别对应 DATA_ATTR/FILE_ATTR，即对应参数的两种来源：数据（@data）和文件（@file_data）。&lt;/div&gt;
&lt;div&gt;elif 分支有解析文件的逻辑，之后跟处理数据相似，所以我们把它略过，主要看前面的 if 分支。这部分的逻辑很清晰，主要完成的任务如下：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;遍历类方法的参数键值对&lt;/li&gt;
&lt;li&gt;根据原方法及参数对，创建新的方法名&lt;/li&gt;
&lt;li&gt;获取原方法的文档字符串&lt;/li&gt;
&lt;li&gt;对元组和列表类型的参数作解包&lt;/li&gt;
&lt;li&gt;在测试类上添加新的测试方法，并绑定参数与文档字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;分析源码，可以看出，@data、@unpack 和 @file_data 这三个装饰器主要是设置属性并传参，而 @ddt 装饰器才是核心的处理逻辑。&lt;/div&gt;
&lt;div&gt;这种将装饰器分散（分别加在类与类方法上），再组合使用的方案，很不优雅。为什么就不能统一起来使用呢？后面我们会分析它的难言之隐，先按下不表，看看其它的实现方案是怎样的？&lt;/div&gt;
&lt;h2&gt;2、parameterized 如何实现参数化？&lt;/h2&gt;
&lt;div&gt;先回顾一下上篇文章中 parameterized 库的写法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; unittest
&lt;span&gt;from&lt;/span&gt; parameterized &lt;span&gt;import&lt;/span&gt; parameterized
&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyTest&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;unittest&lt;span&gt;.&lt;/span&gt;TestCase&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;@parameterized&lt;span&gt;.&lt;/span&gt;expand&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;1.5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;test_values&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; first&lt;span&gt;,&lt;/span&gt; second&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;assertTrue&lt;span&gt;(&lt;/span&gt;first &lt;span&gt;&amp;gt;&lt;/span&gt; second&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;它提供了一个装饰器类 @parameterized，源码如下（版本 0.7.1），主要做了一些初始的校验和参数解析，并非我们关注的重点，略过。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;我们主要关注这个装饰器类的 expand() 方法，它的文档注释中写到：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;A “brute force” method of parameterizing test cases. Creates new test cases and injects them into the namespace that the wrapped function is being defined in. Useful for parameterizing tests in subclasses of ‘UnitTest’, where Nose test generators don’t work.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;关键的两个动作是：“creates new test cases（创建新的测试单元）”和“inject them into the namespace…（注入到原方法的命名空间）”。&lt;/div&gt;
&lt;div&gt;关于第一点，它跟 ddt 是相似的，只是一些命名风格上的差异，以及参数的解析及绑定不同，不值得太关注。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;最不同的则是，怎么令新的测试方法生效？&lt;/div&gt;
&lt;div&gt;parameterized 使用的是一种“注入”的方式：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;inspect&lt;/code&gt; 是个功能强大的标准库，在此用于获取程序调用栈的信息。前三句代码的目的是取出 f_locals，它的含义是“local namespace seen by this frame”，此处 f_locals 指的就是类的局部命名空间。&lt;/div&gt;
&lt;div&gt;说到局部命名空间，你可能会想到 locals()，但是，我们之前有文章提到过“locals() 与 globals() 的读写问题”，locals() 是可读不可写的，所以这段代码才用了 f_locals。&lt;/div&gt;
&lt;h2&gt;3、pytest 如何实现参数化？&lt;/h2&gt;
&lt;div&gt;按惯例先看看上篇文章中的写法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; pytest
&lt;span&gt;@pytest&lt;span&gt;.&lt;/span&gt;mark&lt;span&gt;.&lt;/span&gt;parametrize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;first,second&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;1.5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;test_values&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;first&lt;span&gt;,&lt;/span&gt; second&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;assert&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;first &lt;span&gt;&amp;gt;&lt;/span&gt; second&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;首先看到“mark”，pytest 里内置了一些标签，例如 parametrize、timeout、skipif、xfail、tryfirst、trylast 等，还支持用户自定义的标签，可以设置执行条件、分组筛选执行，以及修改原测试行为等等。&lt;/div&gt;
&lt;div&gt;用法也是非常简单的，然而，其源码可复杂多了。我们这里只关注 parametrize，先看看核心的一段代码：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;根据传入的参数对，它复制了原测试方法的调用信息，存入待调用的列表里。跟前面分析的两个库不同，它并没有在此创建新的测试方法，而是复用了已有的方法。在 parametrize() 所属的 Metafunc 类往上查找，可以追踪到 _calls 列表的使用位置：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;最终是在 Function 类中执行：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;好玩的是，在这里我们可以看到几行神注释……&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;阅读（粗浅涉猎） pytest 的源码，真的是自讨苦吃……不过，依稀大致可以看出，它在实现参数化时，使用的是生成器的方案，遍历一个参数则调用一次测试方法，而前面的 ddt 和 parameterized 则是一次性把所有参数解析完，生成 n 个新的测试方法，再交给测试框架去调度。&lt;/div&gt;
&lt;div&gt;对比一下，前两个库的思路很清晰，而且由于其设计单纯是为了实现参数化，不像 pytest 有什么标记和过多的抽象设计，所以更易读易懂。前两个库发挥了 Python 的动态特性，设置类属性或者注入局部命名空间，而 pytest 倒像是从什么静态语言中借鉴的思路，略显笨拙。&lt;/div&gt;
&lt;h2&gt;4、最后小结&lt;/h2&gt;
&lt;div&gt;回到标题中的问题“如何将一个方法变为多个方法？”除了在参数化测试中，不知还有哪些场景会有此诉求？欢迎留言讨论。&lt;/div&gt;
&lt;div&gt;本文分析了三个测试库的装饰器实现思路，通过阅读源码，我们可以发现它们各有千秋，这个发现本身还挺有意思。在使用装饰器时，表面看它们差异不大，但是真功夫的细节都隐藏在底下。&lt;/div&gt;
&lt;div&gt;源码分析的意义在于探究其所以然，在这次探究之旅中，读者们可有什么收获啊？一起来聊聊吧！（PS：在“Python猫”公众号后台发送“学习群”，获取加群暗号。）&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 中如何实现参数化测试？</title>
            <link>https://pythoncat.top/posts/2019-12-09-test/</link>
            <guid>https://pythoncat.top/posts/2019-12-09-test/</guid>
            <description>聊聊关于测试的话题，并尝试将几个测试框架串联起来，做一个横向的比对</description>
            <pubDate>Mon, 09 Dec 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;之前，我曾转过一个单元测试框架系列的文章，里面介绍了 unittest、nose/nose2 与 pytest 这三个最受人欢迎的 Python 测试框架。&lt;/div&gt;
&lt;div&gt;本文想针对测试中一种很常见的测试场景，即参数化测试，继续聊聊关于测试的话题，并尝试将这几个测试框架串联起来，做一个横向的比对，加深理解。&lt;/div&gt;
&lt;h2&gt;1、什么是参数化测试？&lt;/h2&gt;
&lt;div&gt;对于普通测试来说，一个测试方法只需要运行一遍，而参数化测试对于一个测试方法，可能需要传入一系列参数，然后进行多次测试。&lt;/div&gt;
&lt;div&gt;比如，我们要测试某个系统的登录功能，就可能要分别传入不同的用户名与密码，进行测试：使用包含非法字符的用户名、使用未注册的用户名、使用超长的用户名、使用错误的密码、使用合理的数据等等。&lt;/div&gt;
&lt;div&gt;参数化测试是一种“数据驱动测试”（Data-Driven Test），在同一个方法上测试不同的参数，以覆盖所有可能的预期分支的结果。它的测试数据可以与测试行为分离，被放入文件、数据库或者外部介质中，再由测试程序读取。&lt;/div&gt;
&lt;h2&gt;2、参数化测试的实现思路？&lt;/h2&gt;
&lt;div&gt;通常而言，一个测试方法就是一个最小的测试单元，其功能应该尽量地原子化和单一化。&lt;/div&gt;
&lt;div&gt;先来看看两种实现参数化测试的思路：一种是写一个测试方法，在其内部对所有测试参数进行遍历；另一种是在测试方法之外写遍历参数的逻辑，然后依次调用该测试方法。&lt;/div&gt;
&lt;div&gt;这两种思路都能达到测试目的，在简单业务中，没有毛病。然而，实际上它们都只有一个测试单元，在统计测试用例数情况，或者生成测试报告的时候，并不乐观。可扩展性也是个问题。&lt;/div&gt;
&lt;div&gt;那么，现有的测试框架是如何解决这个问题的呢？&lt;/div&gt;
&lt;div&gt;它们都借助了装饰器，主要的思路是：&lt;strong&gt;利用原测试方法（例如 test()），来生成多个新的测试方法（例如 test1()、test2()……），并将参数依次赋值给它们。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;由于测试框架们通常把一个测试单元统计为一个“test”，所以这种“由一生多”的思路相比前面的两种思路，在统计测试结果时，就具有很大的优势。&lt;/div&gt;
&lt;h2&gt;3、参数化测试的使用方法？&lt;/h2&gt;
&lt;div&gt;Python 标准库中的&lt;code&gt;unittest&lt;/code&gt; 自身不支持参数化测试，为了解决这个问题，有人专门开发了两个库：一个是&lt;code&gt;ddt&lt;/code&gt; ，一个是&lt;code&gt;parameterized&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;ddt 正好是“Data-Driven Tests”（数据驱动测试）的缩写。典型用法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; unittest
&lt;span&gt;from&lt;/span&gt; ddt &lt;span&gt;import&lt;/span&gt; ddt&lt;span&gt;,&lt;/span&gt;data&lt;span&gt;,&lt;/span&gt;unpack

&lt;span&gt;@ddt&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyTest&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;unittest&lt;span&gt;.&lt;/span&gt;TestCase&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;@data&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;1.2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;@unpack&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;test_values&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; first&lt;span&gt;,&lt;/span&gt; second&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;assertTrue&lt;span&gt;(&lt;/span&gt;first &lt;span&gt;&amp;gt;&lt;/span&gt; second&lt;span&gt;)&lt;/span&gt;

unittest&lt;span&gt;.&lt;/span&gt;main&lt;span&gt;(&lt;/span&gt;verbosity&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;运行的结果如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;test_values_1__3__1_ &lt;span&gt;(&lt;/span&gt;__main__&lt;span&gt;.&lt;/span&gt;MyTest&lt;span&gt;)&lt;/span&gt; &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt; ok
test_values_2___1__0_ &lt;span&gt;(&lt;/span&gt;__main__&lt;span&gt;.&lt;/span&gt;MyTest&lt;span&gt;)&lt;/span&gt; &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt; FAIL
test_values_3__1_2__1_0_ &lt;span&gt;(&lt;/span&gt;__main__&lt;span&gt;.&lt;/span&gt;MyTest&lt;span&gt;)&lt;/span&gt; &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt; ok

&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;
FAIL&lt;span&gt;:&lt;/span&gt; test_values_2___1__0_ &lt;span&gt;(&lt;/span&gt;__main__&lt;span&gt;.&lt;/span&gt;MyTest&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;
Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  File &lt;span&gt;&quot;C:\Python36\lib\site-packages\ddt.py&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; line &lt;span&gt;145&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; wrapper
    &lt;span&gt;return&lt;/span&gt; func&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;args&lt;span&gt;,&lt;/span&gt; &lt;span&gt;**&lt;/span&gt;kwargs&lt;span&gt;)&lt;/span&gt;
  File &lt;span&gt;&quot;C:/Users/pythoncat/PycharmProjects/study/testparam.py&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; line &lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; test_values
    self&lt;span&gt;.&lt;/span&gt;assertTrue&lt;span&gt;(&lt;/span&gt;first &lt;span&gt;&amp;gt;&lt;/span&gt; second&lt;span&gt;)&lt;/span&gt;
AssertionError&lt;span&gt;:&lt;/span&gt; &lt;span&gt;False&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; true

&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;
Ran &lt;span&gt;3&lt;/span&gt; tests &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;001s

FAILED &lt;span&gt;(&lt;/span&gt;failures&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;结果显示有 3 个 tests，并详细展示了运行状态以及断言失败的信息。&lt;/div&gt;
&lt;div&gt;需要注意的是，这 3 个 test 分别有一个名字，名字中还携带了其参数的信息，而原来的 test_values 方法则不见了，已经被一拆为三。&lt;/div&gt;
&lt;div&gt;在上述例子中，ddt 库使用了三个装饰器（@ddt、@data、@unpack），实在是很丑陋。下面看看相对更好用的 parameterized 库：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; unittest
&lt;span&gt;from&lt;/span&gt; parameterized &lt;span&gt;import&lt;/span&gt; parameterized

&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyTest&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;unittest&lt;span&gt;.&lt;/span&gt;TestCase&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;@parameterized&lt;span&gt;.&lt;/span&gt;expand&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;1.5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;test_values&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; first&lt;span&gt;,&lt;/span&gt; second&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;assertTrue&lt;span&gt;(&lt;/span&gt;first &lt;span&gt;&amp;gt;&lt;/span&gt; second&lt;span&gt;)&lt;/span&gt;

unittest&lt;span&gt;.&lt;/span&gt;main&lt;span&gt;(&lt;/span&gt;verbosity&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;测试结果如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;test_values_0 &lt;span&gt;(&lt;/span&gt;__main__&lt;span&gt;.&lt;/span&gt;MyTest&lt;span&gt;)&lt;/span&gt; &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt; ok
test_values_1 &lt;span&gt;(&lt;/span&gt;__main__&lt;span&gt;.&lt;/span&gt;MyTest&lt;span&gt;)&lt;/span&gt; &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt; FAIL
test_values_2 &lt;span&gt;(&lt;/span&gt;__main__&lt;span&gt;.&lt;/span&gt;MyTest&lt;span&gt;)&lt;/span&gt; &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt; ok

&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;
FAIL&lt;span&gt;:&lt;/span&gt; test_values_1 &lt;span&gt;(&lt;/span&gt;__main__&lt;span&gt;.&lt;/span&gt;MyTest&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;
Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
  File &lt;span&gt;&quot;C:\Python36\lib\site-packages\parameterized\parameterized.py&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; line &lt;span&gt;518&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; standalone_func
    &lt;span&gt;return&lt;/span&gt; func&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a &lt;span&gt;+&lt;/span&gt; p&lt;span&gt;.&lt;/span&gt;args&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;**&lt;/span&gt;p&lt;span&gt;.&lt;/span&gt;kwargs&lt;span&gt;)&lt;/span&gt;
  File &lt;span&gt;&quot;C:/Users/pythoncat/PycharmProjects/study/testparam.py&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; line &lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; test_values
    self&lt;span&gt;.&lt;/span&gt;assertTrue&lt;span&gt;(&lt;/span&gt;first &lt;span&gt;&amp;gt;&lt;/span&gt; second&lt;span&gt;)&lt;/span&gt;
AssertionError&lt;span&gt;:&lt;/span&gt; &lt;span&gt;False&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; true

&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;
Ran &lt;span&gt;3&lt;/span&gt; tests &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;000s

FAILED &lt;span&gt;(&lt;/span&gt;failures&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这个库只用了一个装饰器 @parameterized.expand，写法上可就清爽多了。&lt;/div&gt;
&lt;div&gt;同样提醒下，原来的测试方法已经消失了，取而代之的是三个新的测试方法，只是新方法的命名规则与 ddt 的例子不同罢了。&lt;/div&gt;
&lt;div&gt;介绍完 unittest，接着看已经死翘翘了的&lt;code&gt;nose&lt;/code&gt; 以及新生的&lt;code&gt;nose2&lt;/code&gt; 。nose 系框架是带了插件（plugins）的 unittest，以上的用法是相通的。&lt;/div&gt;
&lt;div&gt;另外，nose2 中还提供了自带的参数化实现：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; unittest
&lt;span&gt;from&lt;/span&gt; nose2&lt;span&gt;.&lt;/span&gt;tools &lt;span&gt;import&lt;/span&gt; params

&lt;span&gt;@params&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;test_nums&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;num&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;assert&lt;/span&gt; num &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;unittest&lt;span&gt;.&lt;/span&gt;TestCase&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;@params&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;test_less_than&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; a&lt;span&gt;,&lt;/span&gt; b&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;assert&lt;/span&gt; a &lt;span&gt;&amp;lt;&lt;/span&gt; b&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;最后，再来看下 pytest 框架，它这样实现参数化测试：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; pytest

&lt;span&gt;@pytest&lt;span&gt;.&lt;/span&gt;mark&lt;span&gt;.&lt;/span&gt;parametrize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;first,second&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;1.5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;test_values&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;first&lt;span&gt;,&lt;/span&gt; second&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;assert&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;first &lt;span&gt;&amp;gt;&lt;/span&gt; second&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;测试结果如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt; test session starts &lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;
platform win32 &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; Python &lt;span&gt;3.6&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; pytest&lt;span&gt;-&lt;/span&gt;&lt;span&gt;5.3&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; py&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1.8&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; pluggy&lt;span&gt;-&lt;/span&gt;&lt;span&gt;0.13&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;
rootdir&lt;span&gt;:&lt;/span&gt; C&lt;span&gt;:&lt;/span&gt;\Users\pythoncat\PycharmProjects\study collected &lt;span&gt;3&lt;/span&gt; items

testparam&lt;span&gt;.&lt;/span&gt;py &lt;span&gt;.&lt;/span&gt;F
testparam&lt;span&gt;.&lt;/span&gt;py&lt;span&gt;:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;test_values&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
first &lt;span&gt;=&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; second &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;

    &lt;span&gt;@pytest&lt;span&gt;.&lt;/span&gt;mark&lt;span&gt;.&lt;/span&gt;parametrize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;first,second&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;1.5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;test_values&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;first&lt;span&gt;,&lt;/span&gt; second&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
&lt;span&gt;&amp;gt;&lt;/span&gt;       &lt;span&gt;assert&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;first &lt;span&gt;&amp;gt;&lt;/span&gt; second&lt;span&gt;)&lt;/span&gt;
E       &lt;span&gt;assert&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;

testparam&lt;span&gt;.&lt;/span&gt;py&lt;span&gt;:&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; AssertionError
&lt;span&gt;.&lt;/span&gt;                                                         &lt;span&gt;[&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;=&lt;/span&gt; FAILURES &lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;
_________________________ test_values&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; _________________________

first &lt;span&gt;=&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; second &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;

    &lt;span&gt;@pytest&lt;span&gt;.&lt;/span&gt;mark&lt;span&gt;.&lt;/span&gt;parametrize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;first,second&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;1.5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;test_values&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;first&lt;span&gt;,&lt;/span&gt; second&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
&lt;span&gt;&amp;gt;&lt;/span&gt;       &lt;span&gt;assert&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;first &lt;span&gt;&amp;gt;&lt;/span&gt; second&lt;span&gt;)&lt;/span&gt;
E       &lt;span&gt;assert&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;

testparam&lt;span&gt;.&lt;/span&gt;py&lt;span&gt;:&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; AssertionError
&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; failed&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; passed &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;08s &lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;
Process finished &lt;span&gt;with&lt;/span&gt; exit code &lt;span&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;依然要提醒大伙注意，pytest 也做到了由一变三，然而我们却看不到有新命名的方法的信息。这是否意味着它并没有产生新的测试方法呢？或者仅仅是把新方法的信息隐藏起来了？&lt;/div&gt;
&lt;h2&gt;4、最后小结&lt;/h2&gt;
&lt;div&gt;上文中介绍了参数化测试的概念、实现思路，以及在三个主流的 Python 测试框架中的使用方法。我只用了最简单的例子，为的是快速科普（言多必失）。&lt;/div&gt;
&lt;div&gt;但是，这个话题其实还没有结束。对于我们提到的几个能实现参数化的库，抛去写法上大同小异的区别，它们在具体代码层面上，又会有什么样的差异呢？&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;具体来说，它们是如何做到把一个方法变成多个方法，并且将每个方法与相应的参数绑定起来的呢？在实现中，需要解决哪些棘手的问题？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;在分析一些源码的时候，我发现这个话题还挺有意思，所以准备另外写一篇文章。那么，本文就到此为止了，谢谢阅读。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 中 -m 的典型用法、原理解析与发展演变</title>
            <link>https://pythoncat.top/posts/2019-11-10-m/</link>
            <guid>https://pythoncat.top/posts/2019-11-10-m/</guid>
            <description>推荐一读的文章！</description>
            <pubDate>Sun, 10 Nov 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在命令行中使用 Python 时，它可以接收大约 20 个选项（option），语法格式如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;python &lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;bBdEhiIOqsSuvVWx?&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;c command &lt;span&gt;|&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;m module&lt;span&gt;-&lt;/span&gt;name &lt;span&gt;|&lt;/span&gt; script &lt;span&gt;|&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;args&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;本文想要聊聊比较特殊的“-m”选项：&lt;strong&gt;关于它的典型用法、原理解析与发展演变的过程。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;首先，让我们用“—help”来看看它的解释：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;-m  mod run library module as a script (terminates option list)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;“mod”是“module”的缩写，即“-m”选项后面的内容是 module（模块），其作用是把模块当成脚本来运行。&lt;/div&gt;
&lt;div&gt;“terminates option list”意味着“-m”之后的其它选项不起作用，在这点上它跟“-c”是一样的，都是“终极选项”。官方把它们定义为“接口选项”（Interface options），需要区别于其它的普通选项或通用选项。&lt;/div&gt;
&lt;h2&gt;-m 选项的五个典型用法&lt;/h2&gt;
&lt;div&gt;Python 中有很多使用 -m 选项的场景，相信大家可能会用到或者看见过，我在这里想分享 5 个。&lt;/div&gt;
&lt;div&gt;在 Python3 中，只需一行命令就能实现一个简单的 HTTP 服务：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;python &lt;span&gt;-&lt;/span&gt;m http&lt;span&gt;.&lt;/span&gt;server &lt;span&gt;8000&lt;/span&gt;

&lt;span&gt;# 注:在 Python2 中是这样&lt;/span&gt;
python &lt;span&gt;-&lt;/span&gt;m SimpleHTTPServer &lt;span&gt;8000&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;
&lt;div&gt;执行后，在本机打开“&lt;a href=&quot;http://localhost:8000/&quot;&gt;http://localhost:8000&lt;/a&gt;”，或者在局域网内的其它机器上打开“&lt;a href=&quot;http://%E6%9C%AC%E6%9C%BAip:8000%E2%80%9D%EF%BC%8C%E5%B0%B1%E8%83%BD%E8%AE%BF%E9%97%AE%E5%88%B0%E6%89%A7%E8%A1%8C%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E4%BE%8B%E5%A6%82%E4%B8%8B%E5%9B%BE%E5%B0%B1%E6%98%AF%E6%88%91%E6%9C%AC%E6%9C%BA%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%9A&quot;&gt;http://本机ip:8000”，就能访问到执行目录下的内容，例如下图就是我本机的内容：&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;与此类似，我们只需要一行命令“python -m pydoc -p xxx”，就能生成 HTML 格式的官方帮助文档，可以在浏览器中访问。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;上面的命令执行了 pydoc 模块，会在 9000 端口启动一个 http 服务，在浏览器中打开，我的结果如下：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;它的第三个常见用法是执行 pdb 的调试命令“python -m pdb xxx.py”，以调试模式来执行“xxx.py”脚本：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;第四个同样挺有用的场景是用 timeit 在命令行中测试一小段代码的运行时间。以下的 3 段代码，用不同的方式拼接 “0-1-2-……-99” 数字串。可以直观地看出它们的效率差异：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;最后，还有一种常常被人忽略的场景：“python -m pip install xxx”。我们可能会习惯性地使用“pip install xxx”，或者做了版本区分时用“pip3 install xxx”，总之不在前面用“python -m”做指定。但这种写法可能会出问题。&lt;/div&gt;
&lt;div&gt;很巧合的是，在本月初（2019.11.01），Python 的核心开发者、&lt;a href=&quot;https://mp.weixin.qq.com/s/hjcVFaGgI_Ww--Ktv7XP9Q&quot;&gt;第一届指导委员会&lt;/a&gt; 五人成员之一的 Brett Cannon 专门写了一篇博客《&lt;a href=&quot;https://snarky.ca/why-you-should-use-python-m-pip&quot;&gt;Why you should use “python -m pip” &lt;/a&gt; 》，提出应该使用“python -m pip”的方式，并做了详细的解释。&lt;/div&gt;
&lt;div&gt;他的主要观点是：在存在多个 Python 版本的环境中，这种写法可以精确地控制三方库的安装位置。例如用“python3.8 -m pip”，可以明确指定给 3.8 版本安装，而不会混淆成其它的版本。&lt;/div&gt;
&lt;div&gt;（延伸阅读：关于 Brett 的文章，这有一篇简短的归纳《&lt;a href=&quot;https://mp.weixin.qq.com/s/_LcztvEsz-fipjhlVnic8w&quot;&gt;原来我一直安装 Python 库的姿势都不对呀！&lt;/a&gt;》）&lt;/div&gt;
&lt;h2&gt;-m 选项的两种原理解析&lt;/h2&gt;
&lt;div&gt;看了前面的几种典型用法，你是否开始好奇：&lt;strong&gt;“-m”是怎么运作的？它是怎么实现的？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;对于“python -m name”，一句话解释：&lt;strong&gt;Python 会检索&lt;code&gt;sys.path&lt;/code&gt; ，查找名字为“name”的模块或者包（含命名空间包），并将其内容当成“__main__”模块来执行。&lt;/strong&gt;&lt;/div&gt;
&lt;h3&gt;1、对于普通模块&lt;/h3&gt;
&lt;div&gt;以“.py”为后缀的文件就是一个模块，在“-m”之后使用时，只需要使用模块名，不需要写出后缀，但前提是该模块名是有效的，且不能是用 C 语言写成的模块。&lt;/div&gt;
&lt;div&gt;在“-m”之后，如果是一个无效的模块名，则会报错“No module named xxx”。&lt;/div&gt;
&lt;div&gt;如果是一个带后缀的模块，则首先会导入该模块，然后可能报错：Error while finding module specification for ‘xxx.py’ (AttributeError: module ‘xxx’ has no attribute ‘__path__‘。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;对于一个普通模块，有时候这两种写法表面看起来是等效的：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;两种写法都会把定位到的模块脚本当成主程序入口来执行，即在执行时，该脚本的&lt;code&gt;__name__&lt;/code&gt; 都是”__main__“，跟 import 导入方式是不同的。&lt;/div&gt;
&lt;div&gt;但它的前提是：在执行目录中存在着“test.py”，且只有唯一的“test”模块。对于本例，如果换一个目录执行的话，“python test.py”当然会报找不到文件的错误，然而，“python -m test”却不会报错，因为解释器在遍历&lt;code&gt;sys.path&lt;/code&gt; 时可以找到同名的“test”模块，并且执行：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;由此差异，我们其实可以总结出“-m”的用法：&lt;strong&gt;已知一个模块的名字，但不知道它的文件路径，那么使用“-m”就意味着交给解释器自行查找，若找到，则当成脚本执行。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;以前文的“python -m http.server 8000”为例，我们也可以找到“server”模块的绝对路径，然后执行，尽管这样会变得很麻烦。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;那么，“-m”方式与直接运行脚本相比，在实现上有什么不同呢？&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;直接运行脚本时，相当于给出了脚本的完整路径（不管是绝对路径还是相对路径），解释器根据&lt;strong&gt;文件系统的查找机制，&lt;/strong&gt; 定位到该脚本，然后执行&lt;/li&gt;
&lt;li&gt;使用“-m”方式时，解释器需要在不 import 的情况下，在&lt;strong&gt;所有模块命名空间&lt;/strong&gt; 中查找，定位到脚本的路径，然后执行。为了实现这个过程，解释器会借助两个模块：&lt;code&gt;pkgutil&lt;/code&gt; 和 &lt;code&gt;runpy&lt;/code&gt; ，前者用来获取所有的模块列表，后者根据模块名来定位并执行脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2、对于包内模块&lt;/h3&gt;
&lt;div&gt;如果“-m”之后要执行的是一个包，那么解释器经过前面提到的查找过程，先定位到该包，然后会去执行它的“__main__”子模块，也就是说，在包目录下需要实现一个“__main__.py”文件。&lt;/div&gt;
&lt;div&gt;换句话说，假设有个包的名称是“pname”，那么，&lt;strong&gt;“python -m pname”，其实就等效于“python -m pname.__main__”。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;仍以前文创建 HTTP 服务为例，“http”是 Python 内置的一个包，它没有“__main__.py”文件，所以使用“-m”方式执行时，就会报错：No module named http.__main__; ‘http’ is a package and cannot be directly executed。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;作为对比，我们可以看看前文提到的 pip，它也是一个包，为什么“python -m pip”的方式可以使用呢？当然是因为它有“__main__.py”文件：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;“python -m pip”实际上执行的就是这个“__main__.py”文件，它主要作为一个调用入口，调用了核心的”pip._internal.main”。&lt;/div&gt;
&lt;div&gt;http 包因为没有一个统一的入口模块，所以采用了“python -m 包.模块”的方式，而 pip 包因为有统一的入口模块，所以加了一个“__main__.py”文件，最后只需要写“python -m 包”，简明直观。&lt;/div&gt;
&lt;h2&gt;-m 选项的十年演变过程&lt;/h2&gt;
&lt;div&gt;最早引入 -m 选项的是 Python 2.4 版本（2004年），当时功能还挺受限，只能作用于普通的内置模块（如 pdb 和 profile）。&lt;/div&gt;
&lt;div&gt;随后，知名开发者 Nick Coghlan 提出的《&lt;a href=&quot;https://www.python.org/dev/peps/pep-0338/&quot;&gt;PEP 338 — Executing modules as scripts&lt;/a&gt;》把它的功能提升了一个台阶。这个 PEP 在 2004 年提出，最终实现在 2006 年的 2.5 版本。&lt;/div&gt;
&lt;div&gt;（插个题外话：Nick Coghlan 是核心开发者中的核心之一，也是第一届指导委员会的五人成员之一。记得当初看材料，他是在 2005 年被选为核心开发者的，这时间与 PEP-338 的时间紧密贴合）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这个 PEP 的几个核心点是：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结合了 PEP-302 的新探针机制（new import hooks），提升了解释器查找包内模块的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结合了其它的导入机制（例如&lt;code&gt;zipimport&lt;/code&gt; 和冻结模块(frozen modules)），拓展了解释器查找模块的范围与精度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开发了新的&lt;code&gt;runpy.run_module(modulename)&lt;/code&gt; 来实现本功能，而不用修改 CPython 解释器，如此可方便移植到其它解释器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;至此，-m 选项使得 Python 可以在所有的命名空间内定位到命令行中给定的模块。&lt;/div&gt;
&lt;div&gt;2009 年，在 Python 3.1 版本中，只需给定包的名称，就能定位和运行它的“__main__”子模块。2014 年，-m 扩展到支持命名空间包。&lt;/div&gt;
&lt;div&gt;至此，经过十年的发展演变，-m 选项变得功能齐全，羽翼丰满。&lt;/div&gt;
&lt;div&gt;最后，我们来个 ending 吧：-m 选项可能看似不起眼，但它绝对是最特别的选项之一，它使得在命令行中，使用内置模块、标准包与三方库时变得更轻松便利。有机会就多用一下吧，体会它带来的愉悦体验。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;参考材料&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://docs.python.org/3.7/using/cmdline.html#cmdoption-m&quot;&gt;https://docs.python.org/3.7/using/cmdline.html#cmdoption-m&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://snarky.ca/why-you-should-use-python-m-pip&quot;&gt;https://snarky.ca/why-you-should-use-python-m-pip&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-0338/&quot;&gt;https://www.python.org/dev/peps/pep-0338/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://blog.csdn.net/jian3x/article/details/89556592&quot;&gt;https://blog.csdn.net/jian3x/article/details/89556592&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 依赖库管理哪家强？pip、pipreqs、pigar、pip-tools、pipdeptree 任君挑选</title>
            <link>https://pythoncat.top/posts/2019-11-02-pip/</link>
            <guid>https://pythoncat.top/posts/2019-11-02-pip/</guid>
            <pubDate>Sat, 02 Nov 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在 Python 的项目中，如何管理所用的全部依赖库呢？最主流的做法是维护一份“requirements.txt”，记录下依赖库的名字及其版本号。&lt;/div&gt;
&lt;div&gt;那么，如何来生成这份文件呢？在上篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s/kvipFZ81dtt04loPTt3ryQ&quot;&gt;由浅入深：Python 中如何实现自动导入缺失的库？&lt;/a&gt;》中，我提到了一种常规的方法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;pip freeze &lt;span&gt;&amp;gt;&lt;/span&gt; requirements&lt;span&gt;.&lt;/span&gt;txt&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这种方法用起来方便，但有几点不足：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;它搜索依赖库的范围是全局环境，因此会把项目之外的库加入进来，造成冗余（一般是在虚拟环境中使用，但还是可能包含无关的依赖库）&lt;/li&gt;
&lt;li&gt;它只会记录以“pip install”方式安装的库&lt;/li&gt;
&lt;li&gt;它对依赖库之间的依赖关系不做区分&lt;/li&gt;
&lt;li&gt;它无法判断版本差异及循环依赖等情况&lt;/li&gt;
&lt;li&gt;…………&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;可用于项目依赖管理的工具有很多，本文主要围绕与 requirements.txt 文件相关的、比较相似却又各具特色的 4 个三方库，简要介绍它们的使用方法，罗列一些显著的功能点。至于哪个是最好的管理方案呢？卖个关子，请往下看……&lt;/div&gt;
&lt;h2&gt;pipreqs&lt;/h2&gt;
&lt;div&gt;这是个很受欢迎的用于管理项目中依赖库的工具，可以用“pip install pipreqs”命令来安装。它的主要特点有：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;搜索依赖库的范围是基于目录的方式，很有针对性&lt;/li&gt;
&lt;li&gt;搜索的依据是脚本中所 import 的内容&lt;/li&gt;
&lt;li&gt;可以在未安装依赖库的环境上生成依赖文件&lt;/li&gt;
&lt;li&gt;查找软件包信息时，可以指定查询方式（只在本地查询、在 PyPi 查询、或者在自定义的 PyPi 服务）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;基本的命令选项如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;Usage&lt;span&gt;:&lt;/span&gt;
    pipreqs &lt;span&gt;[&lt;/span&gt;options&lt;span&gt;]&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;path&lt;span&gt;&amp;gt;&lt;/span&gt;

Options&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;use&lt;span&gt;-&lt;/span&gt;local           Use ONLY local package info instead of querying PyPI
    &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;pypi&lt;span&gt;-&lt;/span&gt;server &lt;span&gt;&amp;lt;&lt;/span&gt;url&lt;span&gt;&amp;gt;&lt;/span&gt;   Use custom PyPi server
    &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;proxy &lt;span&gt;&amp;lt;&lt;/span&gt;url&lt;span&gt;&amp;gt;&lt;/span&gt;         Use Proxy&lt;span&gt;,&lt;/span&gt; parameter will be passed to requests library&lt;span&gt;.&lt;/span&gt; You can also just &lt;span&gt;set&lt;/span&gt; the
                          environments parameter &lt;span&gt;in&lt;/span&gt; your terminal&lt;span&gt;:&lt;/span&gt;
                          $ export HTTP_PROXY&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;http://10.10.1.10:3128&quot;&lt;/span&gt;
                          $ export HTTPS_PROXY&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;https://10.10.1.10:1080&quot;&lt;/span&gt;
    &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;debug               Print debug information
    &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;ignore &lt;span&gt;&amp;lt;&lt;/span&gt;dirs&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;    Ignore extra directories
    &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;encoding &lt;span&gt;&amp;lt;&lt;/span&gt;charset&lt;span&gt;&amp;gt;&lt;/span&gt;  Use encoding parameter &lt;span&gt;for&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;
    &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;savepath &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;     Save the &lt;span&gt;list&lt;/span&gt; of requirements &lt;span&gt;in&lt;/span&gt; the given &lt;span&gt;file&lt;/span&gt;
    &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;               Output the &lt;span&gt;list&lt;/span&gt; of requirements &lt;span&gt;in&lt;/span&gt; the standard output
    &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;force               Overwrite existing requirements&lt;span&gt;.&lt;/span&gt;txt
    &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;diff &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;         Compare modules &lt;span&gt;in&lt;/span&gt; requirements&lt;span&gt;.&lt;/span&gt;txt to project imports&lt;span&gt;.&lt;/span&gt;
    &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;clean &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        Clean up requirements&lt;span&gt;.&lt;/span&gt;txt by removing modules that are &lt;span&gt;not&lt;/span&gt; imported &lt;span&gt;in&lt;/span&gt; project&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;其中需注意，很可能遇到编码错误：&lt;code&gt;UnicodeDecodeError: &apos;gbk&apos; codec can&apos;t decode byte 0xae in&lt;/code&gt; 。需要指定编码格式“—encoding=utf8”。&lt;/div&gt;
&lt;div&gt;在已生成依赖文件“requirements.txt”的情况下，它可以强行覆盖、比对差异以及清除不再使用的依赖项。&lt;/div&gt;
&lt;h2&gt;pigar&lt;/h2&gt;
&lt;div&gt;pigar 同样可以根据项目路径来生成依赖文件，而且会列出依赖库在文件中哪些位置使用到了。这个功能充分利用了 requirements.txt 文件中的注释，可以提供很丰富的信息。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;pigar 对于查询真实的导入源很有帮助，例如&lt;code&gt;bs4&lt;/code&gt; 模块来自&lt;code&gt;beautifulsoup4&lt;/code&gt; 库，&lt;code&gt;MySQLdb&lt;/code&gt; 则来自于&lt;code&gt;MySQL_Python&lt;/code&gt; 库。可以通过“-s”参数，查找真实的依赖库。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;$ pigar &lt;span&gt;-&lt;/span&gt;s bs4 MySQLdb&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;它使用解析 AST 的方式，而非正则表达式的方式，可以很方便地从 exec/eval 的参数、文档字符串的文档测试中提取出依赖库。&lt;/div&gt;
&lt;div&gt;另外，它对于不同 Python 版本的差异可以很好地支持。例如，&lt;code&gt;concurrent.futures&lt;/code&gt; 是 Python 3.2+ 的标准库，而在之前早期版本中，需要安装三方库&lt;code&gt;futures&lt;/code&gt; ，才能使用它。pigar 做到了有效地识别区分。（PS：pipreqs 也支持这个识别，详见这个合入：&lt;a href=&quot;https://github.com/bndr/pipreqs/pull/80&quot;&gt;https://github.com/bndr/pipreqs/pull/80&lt;/a&gt;）&lt;/div&gt;
&lt;h2&gt;pip-tools&lt;/h2&gt;
&lt;div&gt;pip-tools 包含一组管理项目依赖的工具：pip-compile 与 pip-sync，可以使用命令“pip install pip-tools”统一安装。它最大的优势是可以精准地控制项目的依赖库。&lt;/div&gt;
&lt;div&gt;两个工具的用途及关系图如下：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;pip-compile 命令主要用于生成依赖文件和升级依赖库，另外它可以支持 pip 的“&lt;em&gt;Hash-Checking Mode&lt;/em&gt; ”，并支持在一个依赖文件中嵌套其它的依赖文件（例如，在 requirements.in 文件内，可以用“-c requirements.txt”方式，引入一个依赖文件）。&lt;/div&gt;
&lt;div&gt;它可以根据 setup.py 文件来生成 requirements.txt，假如一个 Flask 项目的 setup.py 文件中写了“install_requires=[‘Flask’]”，那么可以用命令来生成它的所有依赖：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;$ pip&lt;span&gt;-&lt;/span&gt;&lt;span&gt;compile&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;
&lt;span&gt;# This file is autogenerated by pip-compile&lt;/span&gt;
&lt;span&gt;# To update, run:&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;
&lt;span&gt;#    pip-compile --output-file requirements.txt setup.py&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;
click&lt;span&gt;==&lt;/span&gt;&lt;span&gt;6.7&lt;/span&gt;                &lt;span&gt;# via flask&lt;/span&gt;
flask&lt;span&gt;==&lt;/span&gt;&lt;span&gt;0.12&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;
itsdangerous&lt;span&gt;==&lt;/span&gt;&lt;span&gt;0.24&lt;/span&gt;        &lt;span&gt;# via flask&lt;/span&gt;
jinja2&lt;span&gt;==&lt;/span&gt;&lt;span&gt;2.9&lt;/span&gt;&lt;span&gt;.6&lt;/span&gt;             &lt;span&gt;# via flask&lt;/span&gt;
markupsafe&lt;span&gt;==&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;           &lt;span&gt;# via jinja2&lt;/span&gt;
werkzeug&lt;span&gt;==&lt;/span&gt;&lt;span&gt;0.12&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;          &lt;span&gt;# via flask&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在不使用 setup.py 文件的情况下，可以创建“requirements.in”，在里面写入“Flask”，再执行“pip-compile requirements.in”，可以达到跟前面一样的效果。&lt;/div&gt;
&lt;div&gt;pip-sync 命令可以根据 requirements.txt 文件，来对虚拟环境中进行安装、升级或卸载依赖库（注意：除了 setuptools、pip 和 pip-tools 之外）。这样可以有针对性且按需精简地管理虚拟环境中的依赖库。&lt;/div&gt;
&lt;div&gt;另外，该命令可以将多个“*.txt”依赖文件归并成一个：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;$ pip&lt;span&gt;-&lt;/span&gt;sync dev&lt;span&gt;-&lt;/span&gt;requirements&lt;span&gt;.&lt;/span&gt;txt requirements&lt;span&gt;.&lt;/span&gt;txt&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;pipdeptree&lt;/h2&gt;
&lt;div&gt;它的主要用途是展示 Python 项目的依赖树，通过有层次的缩进格式，显示它们的依赖关系，不像前面那些工具只会生成扁平的并列关系。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;除此之外，它还可以：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;生成普遍适用的 requirements.txt 文件&lt;/li&gt;
&lt;li&gt;逆向查找某个依赖库是怎么引入进来的&lt;/li&gt;
&lt;li&gt;提示出相互冲突的依赖库&lt;/li&gt;
&lt;li&gt;可以发现循环依赖，进行告警&lt;/li&gt;
&lt;li&gt;生成多种格式的依赖树文件（json、graph、pdf、png等等）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;它也有缺点，比如无法穿透虚拟环境。如果要在虚拟环境中工作，必须在该虚拟环境中安装 pipdeptree。因为跨虚拟环境会出现重复或冲突等情况，因此需要限定虚拟环境。但是每个虚拟环境都安装一个 pipdeptree，还是挺让人难受的。&lt;/div&gt;
&lt;div&gt;好啦，4 种库介绍完毕，它们的核心功能都是分析依赖库，生成 requirements.txt 文件，同时，它们又具有一些差异，补齐了传统的 pip 的某些不足。&lt;/div&gt;
&lt;div&gt;本文不对它们作全面的测评，只是选取了一些主要特性进行介绍，好在它们安装方便（pip install xxx），使用也简单，感兴趣的同学不妨一试。&lt;/div&gt;
&lt;div&gt;更多丰富的细节，请查阅官方文档：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/bndr/pipreqs&quot;&gt;https://github.com/bndr/pipreqs&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/damnever/pigar&quot;&gt;https://github.com/damnever/pigar&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/jazzband/pip-tools&quot;&gt;https://github.com/jazzband/pip-tools&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/naiquevin/pipdeptree&quot;&gt;https://github.com/naiquevin/pipdeptree&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>由浅入深：Python 中如何实现自动导入缺失的库？</title>
            <link>https://pythoncat.top/posts/2019-10-28-import/</link>
            <guid>https://pythoncat.top/posts/2019-10-28-import/</guid>
            <pubDate>Mon, 28 Oct 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在写 Python 项目的时候，我们可能经常会遇到导入模块失败的错误：&lt;code&gt;ImportError: No module named &apos;xxx&apos;&lt;/code&gt; 或者 &lt;code&gt;ModuleNotFoundError: No module named &apos;xxx&apos;&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;导入失败问题，通常分为两种：一种是导入自己写的模块（即以 .py 为后缀的文件），另一种是导入三方库。本文主要讨论第二种情况，今后有机会，我们再详细讨论其它的相关话题。&lt;/div&gt;
&lt;div&gt;解决导入 Python 库失败的问题，其实关键是在运行环境中装上缺失的库（注意是否是虚拟环境），或者使用恰当的替代方案。这个问题又分为三种情况：&lt;/div&gt;
&lt;h2&gt;一、单个模块中缺失的库&lt;/h2&gt;
&lt;div&gt;在编写代码的时候，如果我们需要使用某个三方库（如 requests），但不确定实际运行的环境是否装了它，那么可以这样写：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;import&lt;/span&gt; requests
&lt;span&gt;except&lt;/span&gt; ImportError&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;import&lt;/span&gt; os
    os&lt;span&gt;.&lt;/span&gt;system&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;pip install requests&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;import&lt;/span&gt; requests&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这样写的效果是，如果找不到 requests 库，就先安装，再导入。&lt;/div&gt;
&lt;div&gt;在某些开源项目中，我们可能还会看到如下的写法（以 json 为例）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;import&lt;/span&gt; simplejson &lt;span&gt;as&lt;/span&gt; json
&lt;span&gt;except&lt;/span&gt; ImportError&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;import&lt;/span&gt; json&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这样写的效果是，优先导入三方库 simplejson，如果找不到，那就使用内置的标准库 json。&lt;/div&gt;
&lt;div&gt;这种写法的好处是不需要导入额外的库，但它有个缺点，即需要保证那两个库在使用上是兼容的，如果在标准库中找不到替代的库，那就不可行了。&lt;/div&gt;
&lt;div&gt;如果真找不到兼容的标准库，也可以自己写一个模块（如 my_json.py），实现想要的东西，然后在 except 语句中再导入它。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;import&lt;/span&gt; simplejson &lt;span&gt;as&lt;/span&gt; json
&lt;span&gt;except&lt;/span&gt; ImportError&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;import&lt;/span&gt; my_json &lt;span&gt;as&lt;/span&gt; json&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;二、整个项目中缺失的库&lt;/h2&gt;
&lt;div&gt;以上的思路是针对开发中的项目，但是它有几个不足：1、在代码中对每个可能缺失的三方库都 pip install，并不可取；2、某个三方库无法被标准库或自己手写的库替代，该怎么办？3、已成型的项目，不允许做这些修改怎么办？&lt;/div&gt;
&lt;div&gt;所以这里的问题是：&lt;strong&gt;有一个项目，想要部署到新的机器上，它涉及很多三方库，但是机器上都没有预装，该怎么办？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;对于一个合规的项目，按照约定，通常它会包含一个“&lt;strong&gt;requirements.txt&lt;/strong&gt; ”文件，记录了该项目的所有依赖库及其所需的版本号。这是在项目发布前，使用命令&lt;code&gt;pip freeze &amp;gt; requirements.txt&lt;/code&gt; 生成的。&lt;/div&gt;
&lt;div&gt;使用命令&lt;code&gt;pip install -r requirements.txt&lt;/code&gt; （在该文件所在目录执行，或在命令中写全文件的路径），就能自动把所有的依赖库给装上。&lt;/div&gt;
&lt;div&gt;但是，如果项目不合规，或者由于其它倒霉的原因，我们没有这样的文件，又该如何是好？&lt;/div&gt;
&lt;div&gt;一个笨方法就是，把项目跑起来，等它出错，遇到一个导库失败，就手动装一个，然后再跑一遍项目，遇到导库失败就装一下，如此循环……（此处省略 1 万句脏话）……&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;三、自动导入任意缺失的库&lt;/h2&gt;
&lt;div&gt;&lt;strong&gt;有没有一种更好的可以自动导入缺失的库的方法呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;在不修改原有的代码的情况下，在不需要“requirements.txt”文件的情况下，有没有办法自动导入所需要的库呢？&lt;/div&gt;
&lt;div&gt;当然有！先看看效果：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;我们以 tornado 为例，第一步操作可看出，我们没有装过 tornado，经过第二步操作后，再次导入 tornado 时，程序会帮我们自动下载并安装好 tornado，所以不再报错。&lt;/div&gt;
&lt;div&gt;autoinstall 是我们手写的模块，代码如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 以下代码在 python 3.6.1 版本验证通过&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; sys
&lt;span&gt;import&lt;/span&gt; os
&lt;span&gt;from&lt;/span&gt; importlib &lt;span&gt;import&lt;/span&gt; import_module


&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AutoInstall&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    _loaded &lt;span&gt;=&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

    &lt;span&gt;@classmethod&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;find_spec&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;cls&lt;span&gt;,&lt;/span&gt; name&lt;span&gt;,&lt;/span&gt; path&lt;span&gt;,&lt;/span&gt; target&lt;span&gt;=&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; path &lt;span&gt;is&lt;/span&gt; &lt;span&gt;None&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; name &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; cls&lt;span&gt;.&lt;/span&gt;_loaded&lt;span&gt;:&lt;/span&gt;
                cls&lt;span&gt;.&lt;/span&gt;_loaded&lt;span&gt;.&lt;/span&gt;add&lt;span&gt;(&lt;/span&gt;name&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Installing&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; name&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    result &lt;span&gt;=&lt;/span&gt; os&lt;span&gt;.&lt;/span&gt;system&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;pip install {}&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; result &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt; import_module&lt;span&gt;(&lt;/span&gt;name&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;except&lt;/span&gt; Exception &lt;span&gt;as&lt;/span&gt; e&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Failed&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;

sys&lt;span&gt;.&lt;/span&gt;meta_path&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;AutoInstall&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这段代码中使用了&lt;code&gt;sys.meta_path&lt;/code&gt; ，我们先打印一下，看看它是个什么东西？&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Python 3 的 import 机制在查找过程中，大致顺序如下：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;在 sys.modules 中查找，它缓存了所有已导入的模块&lt;/li&gt;
&lt;li&gt;在 sys.meta_path 中查找，它支持自定义的加载器&lt;/li&gt;
&lt;li&gt;在 sys.path 中查找，它记录了一些库所在的目录名&lt;/li&gt;
&lt;li&gt;若未找到，则抛出 &lt;code&gt;ImportError&lt;/code&gt; 异常&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;其中要注意，sys.meta_path 在不同的 Python 版本中有所差异，比如它在 Python 2 与 Python 3 中差异很大；在较新的 Python 3 版本（3.4+）中，自定义的加载器需要实现&lt;code&gt;find_spec&lt;/code&gt; 方法，而早期的版本用的则是&lt;code&gt;find_module&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;以上代码是一个自定义的类库加载器 AutoInstall，可以实现自动导入三方库的目的。需要说明一下，这种方法会“劫持”所有新导入的库，破坏原有的导入方式，因此也可能出现一些奇奇怪怪的问题，敬请留意。&lt;/div&gt;
&lt;div&gt;sys.meta_path 属于 Python 探针的一种运用。探针，即&lt;code&gt;import hook&lt;/code&gt;，是 Python 几乎不受人关注的机制，但它可以做很多事，例如加载网络上的库、在导入模块时对模块进行修改、自动安装缺失库、上传审计信息、延迟加载等等。&lt;/div&gt;
&lt;div&gt;限于篇幅，我们不再详细展开了。最后小结一下：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;可以用 try…except 方式，实现简单的三方库导入或者替换&lt;/li&gt;
&lt;li&gt;已知全部缺失的依赖库时（如 requirements.txt），可以手动安装&lt;/li&gt;
&lt;li&gt;利用 sys.meta_path，可以自动导入任意的缺失库&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/liuchang0812/slides/tree/master/pycon2015cn&quot;&gt;https://github.com/liuchang0812/slides/tree/master/pycon2015cn&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://blog.konghy.cn/2016/10/25/python-import-hook/&quot;&gt;http://blog.konghy.cn/2016/10/25/python-import-hook/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.meta_path&quot;&gt;https://docs.python.org/3/library/sys.html#sys.meta_path&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>[译]PEP 3099--Python 3 中不会改变的事情</title>
            <link>https://pythoncat.top/posts/2019-10-24-PEP/</link>
            <guid>https://pythoncat.top/posts/2019-10-24-PEP/</guid>
            <pubDate>Thu, 24 Oct 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;导语：&lt;/strong&gt; Python 3.8 已经发布了，引进了不少变更点。关于 3.9 预计引入的修改，也披露了一些。我们之前还关注过 &lt;a href=&quot;https://mp.weixin.qq.com/s/8KvQemz0SWq2hw-2aBPv2Q&quot;&gt;GIL 的移除计划&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/chinesehuazhou/guido_blog_translation&quot;&gt;Guido 正在开发的新解析器&lt;/a&gt; 等话题，这意味 Python 很有活力，仍在健康地发展着。&lt;/div&gt;
&lt;div&gt;Python 3 是比较大胆激进的，抛弃了前一版本的很多陈旧的包袱，但同时，它也是相对克制的（一直如此），社区里提出的很多提议都被否决了。前不久，我分享的&lt;a href=&quot;https://mp.weixin.qq.com/s/zabIvt4dfu_rf7SmGZXqXg&quot;&gt;Python 设计和历史的 27 个问题&lt;/a&gt; 提到了一些沉淀下来的设计问题，今天这篇译文则聚焦于官方明确否决掉的 24 个设计问题。&lt;/div&gt;
&lt;div&gt;大部分问题都是细枝末节（例如大小写、括号、反引号、行宽等等），但细究起来的话，也会挺有意思，欢迎留言讨论。&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;&lt;strong&gt;PEP原文：&lt;/strong&gt; &lt;a href=&quot;https://www.python.org/dev/peps/pep-0399&quot;&gt;https://www.python.org/dev/peps/pep-0399&lt;/a&gt;
&lt;strong&gt;PEP标题：&lt;/strong&gt; Things that will Not Change in Python 3000
&lt;strong&gt;PEP作者：&lt;/strong&gt; Georg Brandl
&lt;strong&gt;创建日期：&lt;/strong&gt; 2006-04-04
&lt;strong&gt;译者&lt;/strong&gt;：&lt;a href=&quot;https://zhuanlan.zhihu.com/pythonCat&quot;&gt;豌豆花下猫&lt;/a&gt;（&lt;strong&gt;Python猫&lt;/strong&gt; 公众号作者）
&lt;strong&gt;翻译计划&lt;/strong&gt;：&lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;https://github.com/chinesehuazhou/peps-cn&lt;/a&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;概要&lt;/li&gt;
&lt;li&gt;语言核心&lt;/li&gt;
&lt;li&gt;内置对象&lt;/li&gt;
&lt;li&gt;标准类型&lt;/li&gt;
&lt;li&gt;编码风格&lt;/li&gt;
&lt;li&gt;交互式解释器&lt;/li&gt;
&lt;li&gt;版权&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;概要&lt;/h2&gt;
&lt;div&gt;有些想法很糟糕。尽管关于 Python 演化的某些想法具有建设性，但不少想法却与 Python 的基本原则背道而驰，就像是让人围着圈跑步：哪也去不了，即使 Python  3000 允许提出特别的建议，也不管用。&lt;/div&gt;
&lt;div&gt;此 PEP 尝试列出 Python 3000 上所有的 BDFL 决断，涉及那些不会发生更改的内容，以及不会引入的新功能，按主题排序，附加简短的说明或者 python-3000 邮件列表的相关线索。&lt;/div&gt;
&lt;div&gt;如果你认为应该实现下面所列举的提议，那你最好立即离开计算机，出门去，尽情娱乐。去户外活动，在草地上打盹，都比提出一个“殴打一匹死马”的想法来得有建设性。这算是对你的警告（译注：下面的主意是不会实现的，不要试图改变这些已经是板上钉钉的决断）。&lt;/div&gt;
&lt;h2&gt;语言核心&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Python 3000 不会区分大小写。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python 3000 不会从头开始重写。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;不会使用 C++ 或其它不同于 C 的语言作为实现语言。但是，代码库将逐渐迁移。Joel Spolsky 有一篇出色的文章解释了原因：&lt;a href=&quot;http://www.joelonsoftware.com/articles/fog0000000069.html&quot;&gt;http://www.joelonsoftware.com/articles/fog0000000069.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;self 不会变成隐式的。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用显式的 self 是一个好事。消除解析变量时的歧义，可以使得代码更清晰。这还使得函数和方法之间的差异变小。&lt;/p&gt;
&lt;p&gt;邮件：“提议草案：Python 3.0 使用隐式的 self” &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2006-January/059468.html&quot;&gt;https://mail.python.org/pipermail/python-dev/2006-January/059468.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;lambda 不会被改名。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;曾经有过提议，在 Python 3000 中移除 lambda。然而，没人能够提出更好的提供匿名函数的方法。所以 lambda 保留了下来。&lt;/p&gt;
&lt;p&gt;但只是说要保持原样。（有人提议）增加它对语句的支持，但这不是一个好想法。因为它需要允许多行 lambda 表达式，这意味着多行表达式可能突然出现，例如，将会允许对函数调用使用多行参数。那真是丑陋。&lt;/p&gt;
&lt;p&gt;邮件：“genexp 语法/lambda”，&lt;a href=&quot;https://mail.python.org/pipermail/python-3000/2006-April/001042.html&quot;&gt;https://mail.python.org/pipermail/python-3000/2006-April/001042.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Python 不会添加可编程的语法。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;邮件：“是一个声明！是一个函数！两者皆是！”
&lt;a href=&quot;https://mail.python.org/pipermail/python-3000/2006-April/000286.html&quot;&gt;https://mail.python.org/pipermail/python-3000/2006-April/000286.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不会有类似 zip() 的并行迭代语法。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;邮件：“并行迭代语法”，&lt;a href=&quot;https://mail.python.org/pipermail/python-3000/2006-March/000210.html&quot;&gt;https://mail.python.org/pipermail/python-3000/2006-March/000210.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;字符串将保持可迭代。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;邮件：“使字符串不可迭代”，&lt;a href=&quot;https://mail.python.org/pipermail/python-3000/2006-April/000759.html&quot;&gt;https://mail.python.org/pipermail/python-3000/2006-April/000759.html &lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不会有对生成器表达式或列表推导式的结果进行排序的语法。sorted() 将涵盖所有的使用情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;邮件：“为生成器表达式添加排序”，&lt;a href=&quot;https://mail.python.org/pipermail/python-3000/2006-April/001295.html&quot;&gt;https://mail.python.org/pipermail/python-3000/2006-April/001295.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;切片和扩展型切片不会取消（即使__getslice__和__setslice__ API 可能被替换），它们也不会返回标准对象类型的视图。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;邮件：切片的未来&lt;a href=&quot;https://mail.python.org/pipermail/python-3000/2006-May/001563.html&quot;&gt;https://mail.python.org/pipermail/python-3000/2006-May/001563.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不会禁止在循环结构内重用循环变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;邮件：消除迭代变量的作用域出血(scope bleeding)&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2006-May/064761.html&quot;&gt;https://mail.python.org/pipermail/python-dev/2006-May/064761.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;解析器不会比 LL(1) 更复杂。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;简单胜于复杂。这个想法适用于解析器。将 Python 的语法限制为 LL(1) 解析器是一种好处，而不是诅咒。它使我们带上手铐，不至于发展过度，不至于最终得到些时髦的语法规则，像一些走向无名的动态语言那样，例如 Perl。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不会有括号。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这太明显了，以至于不需要引用邮件列表。使用&lt;code&gt;from __future__ import braces&lt;/code&gt; ，你就会得到关于这个问题的明确答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不会再有反引号。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;反引号（`）将不再用作 repr 的简写——但这并不意味着它们可用于其它用途。即使忽略向后兼容性的混乱，这字符本身也会引起太多问题（在某些字体、某些键盘上、在排版书籍时，等等）。&lt;/p&gt;
&lt;p&gt;邮件：“使用反引号作为新运算符”，&lt;a href=&quot;https://mail.python.org/pipermail/python-ideas/2007-January/000054.html&quot;&gt;https://mail.python.org/pipermail/python-ideas/2007-January/000054.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;引用全局变量名 foo 不会被拼写为 globals.foo。global 语句会保留&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;邮件：“用全局内置对象替换 globals() 和 global 语句”，&lt;a href=&quot;https://mail.python.org/pipermail/python-3000/2006-July/002485.html&quot;&gt;https://mail.python.org/pipermail/python-3000/2006-July/002485.html&lt;/a&gt; ，“显式词法作用域（pre-PEP?） ”，&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2006-July/067111.html&quot;&gt;https://mail.python.org/pipermail/python-dev/2006-July/067111.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不会有替代的绑定操作符，例如 := 。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;邮件：“显式词法作用域（pre-PEP?）”，&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2006-July/066995.html&quot;&gt;https://mail.python.org/pipermail/python-dev/2006-July/066995.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;我们不会删除容器字面量。也就是说，{expr:expr, …}，[expr, …] 和(expr, …)将保留。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;邮件：“去除容器字面量”，&lt;a href=&quot;https://mail.python.org/pipermail/python-3000/2006-July/002550.html&quot;&gt;https://mail.python.org/pipermail/python-3000/2006-July/002550.html&lt;/a&gt;：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;while 和 for 循环中的 else 子句不会更改语义，也不会被删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;邮件：“ for/except/else 语法” &lt;a href=&quot;https://mail.python.org/pipermail/python-ideas/2009-October/006083.html&quot;&gt;https://mail.python.org/pipermail/python-ideas/2009-October/006083.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;内置对象&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;zip() 不会增加关键字参数或其它机制来防止它在最短序列的末尾停止。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;邮件：“对于不同长度的序列，令 zip() 引发异常”，&lt;a href=&quot;https://mail.python.org/pipermail/python-3000/2006-August/003338.html&quot;&gt;https://mail.python.org/pipermail/python-3000/2006-August/003338.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;hash() 不会成为属性，因为属性应该是易于计算的，但哈希并不一定是这种情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;邮件：“哈希作为属性/特性”，&lt;a href=&quot;https://mail.python.org/pipermail/python-3000/2006-April/000362.html&quot;&gt;https://mail.python.org/pipermail/python-3000/2006-April/000362.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;标准类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;遍历字典将继续返回 key。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;邮件：“遍历字典”，&lt;a href=&quot;https://mail.python.org/pipermail/python-3000/2006-April/000283.html&quot;&gt;https://mail.python.org/pipermail/python-3000/2006-April/000283.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;邮件：让 iter(mapping) 生成 (key, value) 对&lt;a href=&quot;https://mail.python.org/pipermail/python-3000/2006-June/002368.html&quot;&gt;https://mail.python.org/pipermail/python-3000/2006-June/002368.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不会有 &lt;code&gt;frozenlist&lt;/code&gt; 类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;邮件：“不可变的列表”，&lt;a href=&quot;https://mail.python.org/pipermail/python-3000/2006-May/002219.html&quot;&gt;https://mail.python.org/pipermail/python-3000/2006-May/002219.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;int 不会支持下标来生成 range。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;邮件：“ xrange vs.int .__ getslice__”，&lt;a href=&quot;https://mail.python.org/pipermail/python-3000/2006-June/002450.html&quot;&gt;https://mail.python.org/pipermail/python-3000/2006-June/002450.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;编码风格&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对于 C 和 Python 代码，（推荐的）最大行宽将保持 80 个字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;邮件：“ C 风格指南”，&lt;a href=&quot;https://mail.python.org/pipermail/python-3000/2006-March/000131.html&quot;&gt;https://mail.python.org/pipermail/python-3000/2006-March/000131.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;交互式解释器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;解释器提示（&amp;gt;&amp;gt;&amp;gt;）不会改变。它给 Guido 带来温暖的模糊感觉。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;邮件：“低垂的果实：更改解释器的提示？”，&lt;a href=&quot;https://mail.python.org/pipermail/python-3000/2006-November/004891.html&quot;&gt;https://mail.python.org/pipermail/python-3000/2006-November/004891.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;版权&lt;/h2&gt;
&lt;div&gt;本文档已放置在公共领域。源文档：
&lt;a href=&quot;https://github.com/python/peps/blob/master/pep-3099.txt&quot;&gt;https://github.com/python/peps/blob/master/pep-3099.txt&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;译者注&lt;/h2&gt;
&lt;div&gt;文中出现的“邮件”，原文是“thread”，英文解释应该是：a series of connected messages on a message board on the Internet which have been sent by different people。实际指的是“邮件列表中的议题”，为简洁起见，省译为“邮件”。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>硬币</title>
            <link>https://pythoncat.top/posts/2019-10-14-coin/</link>
            <guid>https://pythoncat.top/posts/2019-10-14-coin/</guid>
            <description>人生之中的某些时候，我会拥有对异化之物的感受</description>
            <pubDate>Mon, 14 Oct 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;人生之中的某些时候，我会拥有对异化之物的感受：理念的含义不再附着于实际之物，认为某物应该是什么功用，但是在现实生活中，它是别的功用，或者就没有用。&lt;/div&gt;
&lt;div&gt;我不记得是何时学得一个词叫作“硬币”，但几乎肯定是在课本或者影视作品里，也就是说，不在日常生活里。&lt;/div&gt;
&lt;div&gt;在我家乡那边，也有硬币，但是我们的方言称它为“银子”（并不是古代的银子），不叫“硬币”。&lt;/div&gt;
&lt;div&gt;方言里也没有“纸币”或者“钞票”的叫法，而是直接把它们称为“钱”，所以在很长一段时间里，我所知道的“钱”就是那一张张的壹角、贰角、伍角或壹元之类的纸币，纸币与“钱”划上了充分的等号。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这两个名称的差异延迟了我加入一个更大的语境，后来才知道“银子”和“钱”一样都是钱。也就是说，直到获取了生活之外的知识，我才知道“银子”也属于钱，并不是只有纸“钱”才是钱。&lt;/div&gt;
&lt;div&gt;一般而言，人们是在生活中首次接触，并理解那些理论上的名称概念，而不在书本或类似的知识库。关于“硬币”这个概念，我的情况恰好相反。它成为了一种“异化之物”。&lt;/div&gt;
&lt;div&gt;在我家乡那边，“银子”并不在日常买卖行为中流通（至今仍如此），“店子”（即杂货铺、乡间便利店）和其它商贩不接受“银子”。所以，我小时候缺少把它认知为一种钱的环境。&lt;/div&gt;
&lt;div&gt;为什么硬币不作为货币而流通使用？原因我不得而知，只能认为这是当地的习俗。&lt;/div&gt;
&lt;div&gt;习俗是这样的：很多人家都收藏有一袋“银子”，不分年代，不分新旧，以壹分和壹角的居多，不用于交易，但用途却不少。&lt;/div&gt;
&lt;div&gt;我曾在衣橱的衣服堆下面发现过它，在储物柜顶发现过它，好奇问起，答复说有所谓镇宅辟邪的用途；我也曾在新居进宅或婚礼丧事的场合见到过它；很偶然的一两次，还在新年的红包里拆出过它。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;在大部分场景中，它的使用量都不大，通常会与红绳或者红纸结合出现，起到一种似乎是点缀装饰，又似乎是必不可缺的作用。&lt;/div&gt;
&lt;div&gt;这些做法的起源难以考溯，或许上一两辈的人们从他们的先辈那里继承而来，作为日渐少见的铜钱的替代品。年少时我斥之为迷信。&lt;/div&gt;
&lt;div&gt;我依稀记得，似乎是奶奶说过，用“银子”轻轻地刮受伤后结的痂，这样伤口会好得快。这种做法没什么坏处，轻刮血痂还可能有止痒的效果。但我还听说过，有些什么癣之类的病，需要用“银子”去刮，还有些怪病的偏方里，要用它一起熬药。&lt;/div&gt;
&lt;div&gt;它的用途不可谓不多，脱离了经济学上经典的用途，就这么进入到了神秘学的领域。&lt;/div&gt;
&lt;div&gt;除此之外，它还有一种更重要的用途，对童年的我和玩伴们来说，意味着很多乐趣，甚至还起到了一定的教育作用：它被遗失在荒宅破屋的角落里，被埋没在清浅小溪的泥沙中，或在稻田与菜地里扎根，或在放养山牛的野坡上流浪；当我们在拾荒或探险时意外地遇到它，便觉得自己是被眷顾的，便自信地快活起来；我们把它按印在手臂上，或者覆在教科书页下用铅笔涂描出圆圆的图纹，似乎捕捉到了什么了不得的信息，乐此不疲……&lt;/div&gt;
&lt;div&gt;总体而言，“银子”在成为“硬币”之前，以它多变的形象在我的记忆中留下了多样的色彩，在那个物质匮乏的年代，设法在我的世界观中安插了一枚微小的种子。&lt;/div&gt;
&lt;div&gt;等到知识概念覆盖了日常经验，“硬币”取代了“银子”，经济学打败了神秘学，那多变的身份突然就只凸显成了一个：硬币是一种钱，不是一种吉祥物。&lt;/div&gt;
&lt;div&gt;在小乡村、城镇乃至县城里，硬币始终不作为一种交易工具，不过它作为一种财物，就此稳固地成为了我的一部分认知。&lt;/div&gt;
&lt;div&gt;后来，我去到了大城市，先是九省通衢的武汉，再到东方水都苏州，硬币终于派上了它理所当然的用场：用它坐公交，用它在超市、商场和其它地方购物，用它“打赏”路边的艺人或者乞丐。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;它的功能开始变得单一（商品经济的支付手段），使用量依然不多，但在很多时候却是随身携带的不可或缺品。由于语言习惯的变化，“银子”的叫法不再出现，连同记忆里那些故事也开始变得陌生。&lt;/div&gt;
&lt;div&gt;它依然是短暂地出现在手里，短暂地被我们所拥有，再转移到别人的手里，但它的存在感以及可能带来的乐趣，却几乎不再有了。&lt;/div&gt;
&lt;div&gt;最近两三年里，我突然开始变得有些怀旧，尽管我正入而立之年，在享青春。关于蝉啊、鸟啊、路啊和一些老物件的记忆，不能释怀。当然还有“银子”和硬币。&lt;/div&gt;
&lt;div&gt;硬币已经有很长时间没有见到过了，事实上，随着在线支付手段的日渐普及，我们需要随身携带零钱的时候也日渐减少：在市内乘坐公交或地铁时，使用手机自带 NFC 的公交卡；出行到其它城市时（甚至是回家乡那个落后的小镇），则用支付宝或微信支付；其它需要使用钱的情况就更不用说了，连那些街头艺人和乞丐都打出了招牌，支持“扫码支付”。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;我已经忘了有多久，不再携带硬币或纸币。它们都是物理空间中的真实物品，有形状、有重量、有味道、有温度、有作用也有麻烦。&lt;/div&gt;
&lt;div&gt;我们处于这个充满变化的时代，正在见证这一场注定不可逆的趋势：电子钱包与在线支付成为潮流，虚拟空间中的数据正在淘汰实物，并将抹去后者所携带的种种附加物。&lt;/div&gt;
&lt;div&gt;换句话说，今后我们的日常生活将更多的是“数据化生存”，对于“钱”来说，“身外之物”将逐渐变为“身外数据”。&lt;/div&gt;
&lt;div&gt;最近流传着一则新闻，大众熟知的一首经典儿歌《一分钱》，与时俱进地改为了《一元钱》：我在马路边，捡到一元钱，交到警察叔叔手里……&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;我不记得是否曾经接触过一分钱的纸币，但是距离最后一次接触一分钱的硬币，则已经过去了将近二十年。“捡到一分钱”这样的事，早已失去了其现实意义。&lt;/div&gt;
&lt;div&gt;也许再过五年，或者十年，“捡到一元钱”这种事，乃至于“在马路边捡到钱”，都将会成为历史。&lt;/div&gt;
&lt;div&gt;多年以后，当我给孙辈们讲起关于钱币的故事时，他们可能会感觉到陌生。当我再用夸张的方式，讲起关于“银子”的那些记忆时，他们很可能会觉得不可思议。&lt;/div&gt;
&lt;div&gt;不过，也许就像当初我听到祖辈讲什么粮票、油票和布票时一样，他们可能会不在意地说：那都过去了，时代总是在进步的嘛……&lt;/div&gt;
&lt;div&gt;注：本文图片来源于网络&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>婚礼</title>
            <link>https://pythoncat.top/posts/2019-10-11-wedding/</link>
            <guid>https://pythoncat.top/posts/2019-10-11-wedding/</guid>
            <description>国庆假期里，我跟豌豆从苏州去江西丰城参加了一场婚礼。</description>
            <pubDate>Fri, 11 Oct 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;国庆假期里，我跟豌豆从苏州去江西丰城参加了一场婚礼。&lt;/div&gt;
&lt;div&gt;新娘 Y 是豌豆的闺蜜、大学室友，她们自开学第一天起相识，至今已有 11 年。本科毕业后，她去了上海，而豌豆读研毕业后来了苏州，两地不远，我们常有联络。&lt;/div&gt;
&lt;div&gt;她们共同的大学闺蜜 C 同学携了男友，也从江苏连云港前去赴约。饭桌席间，Y 同学的哥哥对 C 同学说起当年的一件往事，感慨地说，“你们毕业都已经 7 年了，7 年过得好快啊！”大家问知我们都是从江苏而来，又都语带感慨的说“江苏好远啊”。&lt;/div&gt;
&lt;div&gt;两座城市相距有 700 多公里，向来缺乏距离感的我，对此发不起感慨，然而说到这几年的时间，像是睡了一觉醒来时朦胧而把握不住地消失了，我就自己严肃了起来。&lt;/div&gt;
&lt;div&gt;得益于那些年的文字涂鸦，我有一笔财富可以去巡视，每次读到自己写的带有时间标记的、带有年岁模样的文字，我就又感触到时间的力量，知道记忆和文字的力量。&lt;/div&gt;
&lt;div&gt;所以，“7 年时间过去了”这个话题（除了“毕业”之外，“7 年”还有别的含义），被我反复强化它的重要性，现在促使自己苦坐，要以这种方式把某些东西留下来。这会是写给未来的我们看的，当某一天我们需要一种支撑，需要一个慰藉，需要一份安定，需要一份快乐的时候，也许它可以释放出这些东西来。&lt;/div&gt;
&lt;div&gt;一场完整的中国小镇婚礼或许可以找出一个比较早的起点，比如订婚、领证、计算良辰吉日、布置婚房，或者是新娘在吉日的凌晨 4 点多起床梳妆打扮。这些时间和事件是一场婚礼的序曲。&lt;/div&gt;
&lt;div&gt;我听她们说起了“睡不着”的话题，Y 同学还说半夜有狗在楼下叫，她下楼去看。也许，一场婚礼真正的开端，应该是新人在失眠时确认“今天是我的婚礼”的时候。那个时候才是“那个时候”了。&lt;/div&gt;
&lt;div&gt;我跟豌豆的情况比较特殊，我们在“那个时候”是睡在一起的，彼此依靠，所以睡得还算安稳。我们也起得很早，但我已忘了具体时间。&lt;/div&gt;
&lt;div&gt;然后，他们的婚礼进入热闹的抢亲环节。新娘的房门紧锁，新郎和随行亲友被一系列的小游戏“刁难”：回答问题、给红包、做各种小游戏、说些肉麻的话。&lt;/div&gt;
&lt;div&gt;这个环节是婚礼中的前奏，热热闹闹的，又恰到好处地把婚礼的意义包含其中：她们设置的难关稍加努力就能克服，或者花点钱就能收买考官；这是在众人注目下的一场游戏，选手和观众各自看到自己想看到的东西；一半是娱乐，一半是真情。&lt;/div&gt;
&lt;div&gt;为什么会有“抢亲”的习俗？我不禁产生过这个疑问，但是没有继续空想着推理，我不否认它可能会带来的好处，但落到自己身上时，我跟豌豆的婚礼省掉了这个环节。现实条件也不允许，豌豆远嫁于我，那时女方出席的就两位长辈，连伴娘都只是临时找的。&lt;/div&gt;
&lt;div&gt;我们以及这对新人的结亲过程都挺顺利，不需要用“抢”的强力来跨越阻力，而且女方在两性关系中都略占优势，事实上不需要用“抢”的仪式来凸显她们的地位。&lt;/div&gt;
&lt;div&gt;总体而言，这个环节是有意义的，那些游戏场景很容易进入长久记忆中，也就是说，可以给这一天赋予特殊的光环。&lt;/div&gt;
&lt;div&gt;我印象最深的是随后的婚礼仪式。&lt;/div&gt;
&lt;div&gt;首先要说的是它的场地，那是在农村公路边的一块空地，两侧临近着将要收获的金黄色水稻；婚庆公司布置了必要的道具，两块背景板（其中一块上面写着“高三（19）班”以及这对新人的名字）、音响设备、撒满玫瑰型花瓣的简易地毯、几十张椅子、很多系在彩带上的气球、到处都是透明的水泡泡……&lt;/div&gt;
&lt;div&gt;时日已进深秋，但那天的气温出奇的热，阳光烈烈地亮在晴空下，烘烤着熙熙攘攘的人群。人们搬来了两架大伞棚，遮蔽住现场的椅子，场上座无虚席，侧边站立的观众密密麻麻。&lt;/div&gt;
&lt;div&gt;这块露天的开放场地吸引了极多的观众，新郎的邻居们不请自来，中老年妇女和小孩居多，在新鲜而喜庆的聚会中无所顾忌地大声谈笑、挤坐椅子、拍照和争领礼物。&lt;/div&gt;
&lt;div&gt;所有人都被婚礼的两位主角的开场舞蹈所惊艳，是的，除了说“惊艳”我想不到别的更合适的词。一方是飘飘的红裙子和跃跃的倩影，一方是小心翼翼的脚步和关怀切切的眼神。&lt;/div&gt;
&lt;div&gt;豌豆说她想起了《傲慢与偏见》那种英剧中的舞蹈，而我想到了一个词“翩翩起舞”，觉得它的含义在那个情景中才是最贴切的，而且也想到了一部电影《闻香识女人》——我印象最深的一场双人舞蹈。这种联想不是因为什么形式的相似，而全是因为它们的触动力量，因为那种不遮掩的美感。&lt;/div&gt;
&lt;div&gt;不知道是不是因为相熟的关系，或者因为坐在很贴近的前排，观礼的我们很投入。我曾经在天马行空的假想里，编排与豌豆的婚礼仪式，其中就曾有过双人舞，尽管我们都不会跳。&lt;/div&gt;
&lt;div&gt;想到它时是自然显现，牵手、搂腰、贴腮、环抱、舞动、节奏、对视，这种种要素的组合，赋予了它在潜意识中出场的合理性。&lt;/div&gt;
&lt;div&gt;舞蹈是 Y 同学的喜好，促就了这一场创意。其它环节在婚庆主持人的安排下，多少显得有些刻意：相识过程的讲述、新人们的发言、家长的出场和致辞、亲友的祝福……&lt;/div&gt;
&lt;div&gt;我们参加过一些婚礼，大概知道了这一套流程。可是这一次，又很不同，当 Y 同学说出她那一番话的时候，我和豌豆的眼泪就止不住了。豌豆是那种受到轻微触动就泪如泉涌的林黛玉体质，她的表现完全是在意料之中，而我本来是守持坚稳的，在那时却也完全无法自制。&lt;/div&gt;
&lt;div&gt;我和豌豆的婚礼在各自的老家都办了，形式和流程很简单，既没有前面的抢亲环节，也没有请婚庆公司操办活动。我其实不敢想象，如果我们也策划了这些事会怎样，因为我很忐忑，羞耻于在众目睽睽之下表达爱意、宣誓、讲述自己的故事。由于内心的自卑和胆怯，我生出了一种躲避的心理，刻意对这种盛大形式背后可能富含的信息传递和情感联结视而不见。&lt;/div&gt;
&lt;div&gt;对于两个发愿相伴一生的人来说，婚礼的一天或一段时间，所占的分量能有多少呢？我有时候甚至觉得它会是一件坏事：日常生活总是平淡时居多，总是自然演化的居多，总是相扶持而没有旁人时居多，所以这一种热闹的、编排的、被见证的日子，就显得有些违和了。&lt;/div&gt;
&lt;div&gt;这不是一种绝对性的断言。婚礼的意义对于参与者来说是意味深长。但是须记住，它也会像任意一个普通的日子般流逝掉，婚礼办得好、办得有遗憾、或者不及办，都应该好好地经营其它的日子。&lt;/div&gt;
&lt;div&gt;在那场仪式之后，婚礼还有一个很长的环节——筵席。一人又一人，一桌又一桌，一盘又一盘，一杯又一杯，一碗又一碗，一筷又一筷。我没注意大家吃了多久。&lt;/div&gt;
&lt;div&gt;我们从江苏来的四人坐在楼梯口的一桌上，再加上新娘歇脚式的短暂相陪。我们讨论了某种食物的吃法，评论了某道菜的味道，说起了其它的事。在那个时候，我突然浮现了一种微弱但是奇怪的情绪：一种对“娘家人”身份的认同，以及“送亲人出嫁”的感觉。似乎是想到了千里迢迢而来，想到可能今生都不会再踏足这片陌生的土地，而催生的情绪。&lt;/div&gt;
&lt;div&gt;其实，Y 同学是当地人，并不是“远嫁他乡”。&lt;/div&gt;
&lt;div&gt;她和他是高中同班同学，在校时基本不曾说过话，在毕业和工作多年后，经其他同学牵线，异地恋爱，最后相携走入婚姻殿堂。这个过程很奇妙。&lt;/div&gt;
&lt;div&gt;中学时在一起而多年后分手的情况，我见过；像他们这种相反的分合情况，我仅见此例。这就是缘分么？&lt;/div&gt;
&lt;div&gt;什么是缘分？缘分就是令两个人产生更紧密的交集，令他们交换信物，令他们同甘共苦，令他们自我完善的一种神秘的巧合。&lt;/div&gt;
&lt;div&gt;在此意义上，婚礼发挥出了传道的价值，告知那些愿意相信的人，有一种美好事物值得期待，有一种幸福生活值得奋斗，有一些高光时刻值得珍惜。&lt;/div&gt;
&lt;div&gt;那天的婚礼之后，宾客散尽，桌椅清洁。我们一行六人在午后出门，穿过田间小径，走进破旧老宅，去楼上看鸽子，去园子里摘柚子，回来在天井旁，吃吃柚子，吃吃甘蔗，聊聊天，看两只狗子在一地茭白的叶子上打闹嬉戏……&lt;/div&gt;
&lt;div&gt;秋天的夜幕来得早，光暗风起，宣示着到了启程分别的时候。&lt;/div&gt;
&lt;div&gt;大巴开往南昌，我望着窗外绵绵不绝又一闪而过的风景，没有困意。每一帧画面都不相同，大自然与人类的居所相交错，跟南方别处的景色一样普通无奇。&lt;/div&gt;
&lt;div&gt;不过，观察得久了，还是有几处地方吸引了我：一个池子里散养了成片的鸭子、一处圈地里养了一群羊、一片平坡上排列着太阳能电池板方阵、一条铁路在宽阔的没有防护带的地方穿过……&lt;/div&gt;
&lt;div&gt;平凡而雷同的风景，容易忘怀，尽管那一路上它们如影随形。算不上太奇特，可是却显得突出的风景呢，则像一场婚礼像一场旅行，留下了抹不掉的痕迹。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 为什么要保留显式的 self？</title>
            <link>https://pythoncat.top/posts/2019-09-28-self/</link>
            <guid>https://pythoncat.top/posts/2019-09-28-self/</guid>
            <pubDate>Sat, 28 Sep 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;前两天，我偶然在一个知识星球（刘欣老师的“码农翻身”）里看到一篇主题，刘老师表示 Python 的类方法非要带个 self，而不像其它语言那样隐藏起来，这让人很不爽。我对此也有同感。在经过群聊讨论后，我获知 Guido 曾经专门撰文解释过这个问题。这篇文章并不好懂，我抽空先翻译出来了，看看能收到什么回应。如果可能的话，后续再另写文章分析。&lt;/div&gt;
&lt;div&gt;--------------以下为译文---------------&lt;/div&gt;
&lt;div&gt;布鲁斯·埃克尔（Bruce Eckel）&lt;a href=&quot;http://www.artima.com/weblogs/viewpost.jsp?thread=239003&quot;&gt;发了篇博文&lt;/a&gt; ，提议从类方法的形参列表中删除“self”。我将解释为什么这个提议不能通过。（译注：Bruce 是《Thinking in Java》、《Thinking in C++》等多本书籍的作者，也是个 Python 开发者。他的文章总结了当年在巴西 Pycon 上的一次讨论，主要观点是在定义类方法时，形参中的“self”是多余的，而且由它引发的报错信息具有一定的误导性。）&lt;/div&gt;
&lt;h2&gt;Bruce 的提议&lt;/h2&gt;
&lt;div&gt;Bruce 知道，我们需要一种方法来区分对实例变量的引用和对其它变量的引用，因此他建议将“self”设为关键字。&lt;/div&gt;
&lt;div&gt;考虑一种典型的类，它有一个方法，例如：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;C&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
   &lt;span&gt;def&lt;/span&gt; &lt;span&gt;meth&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; arg&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
      self&lt;span&gt;.&lt;/span&gt;val &lt;span&gt;=&lt;/span&gt; arg
      &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;val&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;跟据 Bruce 的提议，这将变为：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;C&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
   &lt;span&gt;def&lt;/span&gt; &lt;span&gt;meth&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;arg&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;  &lt;span&gt;# Look ma, no self!&lt;/span&gt;
      self&lt;span&gt;.&lt;/span&gt;val &lt;span&gt;=&lt;/span&gt; arg
      &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;val&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这样每个方法会节省 6 个字符。但我不觉得 Bruce 提出这个建议是为了减少打字。&lt;/div&gt;
&lt;div&gt;我认为他真正关心的是程序员（可能来自其它语言）所浪费的时间，有时候似乎不需要指定“self”参数，而且他们偶尔忘记了要加（即使他们十分清楚——习惯是一种强大的力量）。确实，与忘记在实例变量或方法引用之前键入“self.”相比，从参数列表中省略“self”，往往会导致很模糊的错误消息。&lt;/div&gt;
&lt;div&gt;也许更糟糕的是（如 Bruce 所述），当正确地声明了方法，但是在调用时的参数数量不对，这时收到的错误消息。如 Bruce 给出的以下示例：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
File &lt;span&gt;&quot;classes.py&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; line &lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;
   obj&lt;span&gt;.&lt;/span&gt;m2&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
TypeError&lt;span&gt;:&lt;/span&gt; m2&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; takes exactly &lt;span&gt;3&lt;/span&gt; arguments &lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; given&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我赞同它是令人困惑的，但是我宁愿去解决此错误消息，而不是修改语言。&lt;/div&gt;
&lt;h2&gt;为什么 Bruce 的提议不可行&lt;/h2&gt;
&lt;div&gt;首先，让我提出一些与 Bruce 的提议相反的典型论点。&lt;/div&gt;
&lt;div&gt;这有一个很好的论据可以证明，在参数列表中使用显式的“self”，可以增强以下两种调用方法在理论上的等效性。假设“ foo”是“C”的一个实例：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;foo&lt;span&gt;.&lt;/span&gt;meth&lt;span&gt;(&lt;/span&gt;arg&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; C&lt;span&gt;.&lt;/span&gt;meth&lt;span&gt;(&lt;/span&gt;foo&lt;span&gt;,&lt;/span&gt; arg&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;（译注：说实话，我没有理解这个例子的意思。以下仅是个人看法。在类的内部定义方法时，可能会产生几种不同的方法：&lt;strong&gt;实例方法&lt;/strong&gt; 、&lt;strong&gt;类方法&lt;/strong&gt; 和 &lt;strong&gt;静态方法&lt;/strong&gt; 。它们的作用和行为是不同的，那么在定义和调用时怎么做区分呢？Python 约定了一种方式，即在定义时用第一个参数作区分：self 表示实例方法、cls或其它符号 表示类方法……三种方法都可以被类的实例调用，而且看起来一模一样，如上例的等号左侧那样。这时候就要靠定义时赋予的参数来区分了，像上例等号右侧，第一个参数是实例对象，表明此处是个实例方法。）&lt;/div&gt;
&lt;div&gt;另一个论据是，在参数列表中使用显式的“self”，将一个函数插入一个类，获得动态地修改一个类的能力，创建出相应的一个类方法。&lt;/div&gt;
&lt;div&gt;例如，我们可以创建一个与上面的“C”完全等效的类，如下所示：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# Define an empty class:&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; &lt;span&gt;C&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
   &lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;# Define a global function:&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;meth&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;myself&lt;span&gt;,&lt;/span&gt; arg&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
   myself&lt;span&gt;.&lt;/span&gt;val &lt;span&gt;=&lt;/span&gt; arg
   &lt;span&gt;return&lt;/span&gt; myself&lt;span&gt;.&lt;/span&gt;val

&lt;span&gt;# Poke the method into the class:&lt;/span&gt;
C&lt;span&gt;.&lt;/span&gt;meth &lt;span&gt;=&lt;/span&gt; meth&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;请注意，我将“self”参数重命名为“myself”，以强调（在语法上）我们不是在此处定义一个方法（译注：类外部的是&lt;strong&gt;函数&lt;/strong&gt; ，即 function，类内部的是&lt;strong&gt;方法&lt;/strong&gt; ，即 method）。&lt;/div&gt;
&lt;div&gt;这样之后，C 的实例就具有了一个“meth”方法，该方法有一个参数，且功能跟之前的完全一样。对于在把方法插入类之前就创建的那些 C 的实例，它甚至也适用。&lt;/div&gt;
&lt;div&gt;我想 Bruce 并不特别在意前述的等效性。我同意这只是理论上的重要。我能想到的唯一例外是旧式的调用超级方法的习语（idiom）。但是，这个习语很容易出错（正是由于需要显式地传递”self”的原因），这就是为什么在 Python 3000 中，我建议在所有情况下都使用”super()“的原因。&lt;/div&gt;
&lt;div&gt;Bruce 可能会想到一种使第二个等效例子起作用的方法——在某些情况下，这种等效性真的很重要。我不知道 Bruce 花了多少时间思考如何实现他的提议，但是我想他正在考虑将一个名为“self”的额外形参自动地添加到直接地在类内部定义的所有方法的思路（我必须说是“直接地”，以便那些嵌套在方法内部的函数，能免于这种自动操作）。这样，可以使第一个等效例子保持等效。&lt;/div&gt;
&lt;div&gt;但是，有一种情况我认为 Bruce 不能在不向编译器中添加某种 ESP 的情况下解决：&lt;strong&gt;装饰器。&lt;/strong&gt; 我相信这是 Bruce 的提议的最终败笔。&lt;/div&gt;
&lt;div&gt;当装饰一个方法时，我们不知道是否要自动地给它加一个“self”参数：装饰器可以将函数变成一个静态方法（没有“self”）或一个类方法（有一个有趣的 self，它指向一个类而不是一个实例），或者可以做一些完全不同的事情（用纯 Python 实现“ @classmethod”或“ @staticmethod”的装饰器是繁琐的）。除非知道装饰器的用途，否则没有其它办法来确定是否要赋予正在定义的方法一个隐式的“self”参数。&lt;/div&gt;
&lt;div&gt;我拒绝诸如特殊包装的“ @classmethod”和“ @staticmethod”之类的黑科技。我也认为除了自检外，自动地确定某个方法是类方法（class method）、实例方法（instance method）还是静态方法（static method），这不是一个好主意（就像在 Bruce 的文章的评论中，有人建议的那样）：这使得很难仅仅根据方法前的“def”，来决定应该怎样调用该方法。&lt;/div&gt;
&lt;div&gt;（译注：对于一个方法，在当前的添加了相应参数的情况下，可以简单地加装饰器，区分它是哪种方法，调用时也容易区分调用；但是，如果没有加参数，即使可以用神奇的自动机制来区分出它是哪种方法，但在调用时，你不好确定该怎么调用）。&lt;/div&gt;
&lt;div&gt;在评论中，我看到了一些非常极端的对 Bruce 的提议的附和，但通常的代价是使得规则难以遵循，或者要求对语言进行更深层的修改，这令我们极其难以接受它，特别是合入 Python 3.1。顺便说一句，对于 3.1，再次声明我们的规则，新特性只有在保持向后兼容的情况下才是可接受的。&lt;/div&gt;
&lt;div&gt;有一个似乎可行的建议（可以使它向后兼容）是把类中的&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;foo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; arg&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;改成这样的语法糖：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;foo&lt;span&gt;(&lt;/span&gt;arg&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;但我不认同它把“self”变为保留字（reserved word），或者要求前缀必须是“self”。如果这样做了，那对于类方法，很容易也出现这种情况：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;@classmethod&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; cls&lt;span&gt;.&lt;/span&gt;foo&lt;span&gt;(&lt;/span&gt;arg&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;好了，相比于现状，我并没有更喜欢这个。但是相比于 Bruce 的提议或在他的博客评论区中提出的更极端的说法，我认为这个要好得多，而且它具有向后兼容的巨大优势，并且不需要很费力，就可以写成带有参考实现的 PEP。（我想 Bruce 应该会发现自己提案中的缺陷，如果他真的付出努力尝试编写可靠的 PEP 或者尝试实现它。）&lt;/div&gt;
&lt;div&gt;我可以继续聊很多，但这是一个阳光明媚的周日早晨，而我还有其它的计划… :-)&lt;/div&gt;
&lt;div&gt;作者：Guido van Rossum，写于：2008.10.26&lt;/div&gt;
&lt;div&gt;英文： &lt;a href=&quot;https://neopythonic.blogspot.com/2008/10/why-explicit-self-has-to-stay.html&quot;&gt;https://neopythonic.blogspot.com/2008/10/why-explicit-self-has-to-stay.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;作者简介：&lt;/strong&gt; Guido van Rossum，Python 的创造者，一直是“终身仁慈独裁者”，直到 2018 年 7 月 12 日退位。目前，他是新的最高决策层的五位成员之一，依然活跃在社区中。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者简介：&lt;/strong&gt; 豌豆花下猫，生于广东毕业于武大，现为苏漂程序员，有一些极客思维，也有一些人文情怀，有一些温度，还有一些态度。公众号：「Python猫」（python_cat）。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 之父的解析器系列之七：PEG 解析器的元语法</title>
            <link>https://pythoncat.top/posts/2019-09-27-PEG/</link>
            <guid>https://pythoncat.top/posts/2019-09-27-PEG/</guid>
            <pubDate>Fri, 27 Sep 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;原题&lt;/strong&gt; | &lt;a href=&quot;https://medium.com/@gvanrossum_83706/a-meta-grammar-for-peg-parsers-3d3d502ea332&quot;&gt;A Meta-Grammar for PEG Parsers&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;作者&lt;/strong&gt; | Guido van Rossum（Python之父）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; | 豌豆花下猫（“Python猫”公众号作者）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;声明&lt;/strong&gt; | 本翻译是出于交流学习的目的，基于 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt; 授权协议。为便于阅读，内容略有改动。本系列的译文已在 Github 开源，项目地址：&lt;a href=&quot;https://github.com/chinesehuazhou/guido_blog_translation&quot;&gt;https://github.com/chinesehuazhou/guido_blog_translation&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;本周我们使解析器生成器完成“自托管”（self-hosted），也就是让它自己生成解析器。&lt;/div&gt;
&lt;div&gt;首先我们有了一个解析器生成器，其中一部分是语法解析器。我们可以称之为元解析器（meta-parser）。该元解析器与要生成的解析器类似：&lt;code&gt;GrammarParser&lt;/code&gt; 继承自&lt;code&gt;Parser&lt;/code&gt; ，它使用相同的 mark()/reset()/expect() 机制。然而，它是手写的。但是，只能是手写么？&lt;/div&gt;
&lt;div&gt;在编译器设计中有一个传统，即编译器使用它要编译的语言编写。我深切地记得在我初学编程时，当时用的 Pascal 编译器是用 Pascal 本身编写的，GCC 是用 C 编写的，Rust 编译器当然是用 Rust 编写的。&lt;/div&gt;
&lt;div&gt;这是怎么做到的呢？有一个辅助过程（bootstrap，引导程序，通常译作“自举”）：对于一种语言的子集或早期版本，它的编译器是用其它的语言编写的。（我记得最初的 Pascal 编译器是用 FORTRAN 编写的！）然后用编译后的语言编写一个新的编译器，并用辅助的编译器来编译它。一旦新的编译器运行得足够好，辅助的编译器就会被废弃，并且该语言或新编译器的每个新版本，都会受到先前版本的编译器的编译能力的约束。&lt;/div&gt;
&lt;div&gt;让我们的元解析器如法炮制。我们将为语法编写一个语法（元语法），然后我们将从中生成一个新的元解析器。幸运的是我从一开始就计划了，所以这是一个非常简单的练习。我们在上一篇文章中添加的动作是必不可少的因素，因为我们不希望被迫去更改生成器——因此我们需要能够生成一个可兼容的数据结构。&lt;/div&gt;
&lt;div&gt;这是一个不加动作的元语法的简化版：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;start: rules ENDMARKER
rules: rule rules | rule
rule: NAME &quot;:&quot; alts NEWLINE
alts: alt &quot;|&quot; alts | alt
alt: items
items: item items | item
item: NAME | STRING&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我将自下而上地展示如何添加动作。参照第 3 篇，我们有了一些带 name 和 alts 属性的 Rule 对象。最初，alts 只是一个包含字符串列表的列表（外层列表代表备选项，内层列表代表备选项的条目），但为了添加动作，我更改了一些内容，备选项由具有 items 和 action 属性的 Alt 对象来表示。条目仍然由纯字符串表示。对于 item 规则，我们有：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;item: NAME { name.string } | STRING { string.string }&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这需要一些解释：当解析器处理一个标识符时，它返回一个 TokenInfo 对象，该对象具有 type、string 及其它属性。我们不希望生成器来处理 TokenInfo 对象，因此这里加了动作，它会从标识符中提取出字符串。请注意，对于像 NAME 这样的全大写标识符，生成的解析器会使用小写版本（此处为 name ）作为变量名。&lt;/div&gt;
&lt;div&gt;接下来是 items 规则，它必须返回一个字符串列表：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;items: item items { [item] + items } | item { [item] }&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我在这里使用右递归规则，所以我们不依赖于第 5 篇中添加的左递归处理。（为什么不呢？保持事情尽可能简单总是一个好主意，这个语法使用左递归的话，不是很清晰。）请注意，单个的 item 已被分层，但递归的 items 没有，因为它已经是一个列表。&lt;/div&gt;
&lt;div&gt;alt 规则用于构建 Alt 对象：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;alt: items { Alt(items) }&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我就不介绍 rules 和 start 规则了，因为它们遵循相同的模式。&lt;/div&gt;
&lt;div&gt;但是，有两个未解决的问题。首先，生成的代码如何知道去哪里找到 Rule 和 Alt 类呢？为了实现这个目的，我们需要为生成的代码添加一些 import 语句。最简单的方法是给生成器传递一个标志，该标志表示“这是元语法”，然后让生成器在生成的程序顶部引入额外的 import 语句。但是既然我们已经有了动作，许多其它解析器也会想要自定义它们的导入，所以为什么我们不试试看，能否添加一个更通用的功能呢。&lt;/div&gt;
&lt;div&gt;有很多方法可以剥了这只猫的皮（译注：skin this cat，解决这个难题）。一个简单而通用的机制是在语法的顶部添加一部分“变量定义”，并让生成器使用这些变量，来控制生成的代码的各个方面。我选择使用 @ 字符来开始一个变量定义，在它之后是变量名（一个 NAME）和值（一个 STRING）。例如，我们可以将以下内容放在元语法的顶部：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;@subheader &quot;from grammar import Rule, Alt&quot;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;标准的导入总是会打印（例如，去导入 memoize），在那之后，解析器生成器会打印 &lt;code&gt;subheader&lt;/code&gt; 变量的值。如果需要多个 import，可以在变量声明中使用三引号字符串，例如：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;@subheader &quot;&quot;&quot;
from token import OP
from grammar import Rule, Alt
&quot;&quot;&quot;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这很容易添加到元语法中，我们用这个替换 start 规则：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;start: metas rules ENDMARKER | rules ENDMARKER
metas: meta metas | meta
meta: &quot;@&quot; NAME STRING NEWLINE&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;（我不记得为什么我会称它们为“metas”，但这是我在编写代码时选择的名称，我会坚持这样叫。:-)&lt;/div&gt;
&lt;div&gt;我们还必须将它添加到辅助的元解析器中。既然语法不仅仅是一系列的规则，那么让我们添加一个 Grammar  对象，其中包含属性 &lt;code&gt;metas&lt;/code&gt; 和 &lt;code&gt;rules&lt;/code&gt;。我们可以放入如下的动作：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;start: metas rules ENDMARKER { Grammar(rules, metas) }
     | rules ENDMARKER { Grammar(rules, []) }
metas: meta metas { [meta] + metas }
     | meta { [meta] }
meta: &quot;@&quot; NAME STRING { (name.string, eval(string.string)) }&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;（注意 meta 返回一个元组，并注意它使用 eval() 来处理字符串引号。）&lt;/div&gt;
&lt;div&gt;说到动作，我漏讲了 alt 规则的动作！原因是这里面有些混乱。但我不能再无视它了，上代码吧：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;alt: items action { Alt(items, action) }
   | items { Alt(items, None) }
action: &quot;{&quot; stuffs &quot;}&quot; { stuffs }
stuffs: stuff stuffs { stuff + &quot; &quot; + stuffs }
      | stuff { stuff }
stuff: &quot;{&quot; stuffs &quot;}&quot; { &quot;{&quot; + stuffs + &quot;}&quot; }
     | NAME { name.string }
     | NUMBER { number.string }
     | STRING { string.string }
     | OP { None if op.string in (&quot;{&quot;, &quot;}&quot;) else op.string }&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这个混乱是由于我希望在描绘动作的花括号之间允许任意 Python 代码，以及允许配对的大括号嵌套在其中。为此，我们使用了特殊标识符 OP，标记生成器用它生成可被 Python 识别的所有标点符号（返回一个类型为 OP 标识符，用于多字符运算符，如 &amp;lt;= 或 ** ）。在 Python 表达式中可以合法地出现的唯一其它标识符是名称、数字和字符串。因此，在动作的最外侧花括号之间的“东西”似乎是一组循环的 NAME | NUMBER | STRING | OP 。&lt;/div&gt;
&lt;div&gt;呜呼，这没用，因为 OP 也匹配花括号，但由于 PEG 解析器是贪婪的，它会吞掉结束括号，我们就永远看不到动作的结束。因此，我们要对生成的解析器添加一些调整，允许动作通过返回 None 来使备选项失效。我不知道这是否是其它 PEG 解析器的标准配置——当我考虑如何解决右括号（甚至嵌套的符号）的识别问题时，立马就想到了这个方法。它似乎运作良好，我认为这符合 PEG 解析的一般哲学。它可以被视为一种特殊形式的前瞻（我将在下面介绍）。&lt;/div&gt;
&lt;div&gt;使用这个小调整，当出现花括号时，我们可以使 OP 上的匹配失效，它可以通过 stuff 和 action 进行匹配。&lt;/div&gt;
&lt;div&gt;有了这些东西，元语法可以由辅助的元解析器解析，并且生成器可以将它转换为新的元解析器，由此解析自己。更重要的是，新的元解析器仍然可以解析相同的元语法。如果我们使用新的元编译器编译元语法，则输出是相同的：这证明生成的元解析器正常工作。&lt;/div&gt;
&lt;div&gt;这是带有动作的完整元语法。只要你把解析过程串起来，它就可以解析自己：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;@subheader &quot;&quot;&quot;
from grammar import Grammar, Rule, Alt
from token import OP
&quot;&quot;&quot;
start: metas rules ENDMARKER { Grammar(rules, metas) }
     | rules ENDMARKER { Grammar(rules, []) }
metas: meta metas { [meta] + metas }
     | meta { [meta] }
meta: &quot;@&quot; NAME STRING NEWLINE { (name.string, eval(string.string)) }
rules: rule rules { [rule] + rules }
     | rule { [rule] }
rule: NAME &quot;:&quot; alts NEWLINE { Rule(name.string, alts) }
alts: alt &quot;|&quot; alts { [alt] + alts }
    | alt { [alt] }
alt: items action { Alt(items, action) }
   | items { Alt(items, None) }
items: item items { [item] + items }
     | item { [item] }
item: NAME { name.string }
    | STRING { string.string }
action: &quot;{&quot; stuffs &quot;}&quot; { stuffs }
stuffs: stuff stuffs { stuff + &quot; &quot; + stuffs }
      | stuff { stuff }
stuff: &quot;{&quot; stuffs &quot;}&quot; { &quot;{&quot; + stuffs + &quot;}&quot; }
     | NAME { name.string }
     | NUMBER { number.string }
     | STRING { string.string }
     | OP { None if op.string in (&quot;{&quot;, &quot;}&quot;) else op.string }&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;现在我们已经有了一个能工作的元语法，可以准备做一些改进了。&lt;/div&gt;
&lt;div&gt;但首先，还有一个小麻烦要处理：空行！事实证明，标准库的 tokenize 会生成额外的标识符来跟踪非重要的换行符和注释。对于前者，它生成一个 NL 标识符，对于后者，则是一个 COMMENT 标识符。以其将它们吸收进语法中（我已经尝试过，但并不容易！），我们可以在 tokenizer 类中添加一段非常简单的代码，来过滤掉这些标识符。这是改进的 peek_token 方法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;peek_token&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;pos &lt;span&gt;==&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;tokens&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                token &lt;span&gt;=&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;tokengen&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; token&lt;span&gt;.&lt;/span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;NL&lt;span&gt;,&lt;/span&gt; COMMENT&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;continue&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;tokens&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;token&lt;span&gt;)&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;report&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;tokens&lt;span&gt;[&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;pos&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这样就完全过滤掉了 NL 和 COMMENT 标识符，因此在语法中不再需要担心它们。&lt;/div&gt;
&lt;div&gt;最后让我们对元语法进行改进！我想做的事情纯粹是美容性的：我不喜欢被迫将所有备选项放在同一行上。我上面展示的元语法实际上并没有解析自己，因为有这样的情况：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;start: metas rules ENDMARKER { Grammar(rules, metas) }
     | rules ENDMARKER { Grammar(rules, []) }&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这是因为标识符生成器（tokenizer）在第一行的末尾产生了一个 NEWLINE 标识符，此时元解析器会认为这是该规则的结束。此外，NEWLINE 之后会出现一个 INDENT 标识符，因为下一行是缩进的。在下一个规则开始之前，还会有一个 DEDENT 标识符。&lt;/div&gt;
&lt;div&gt;下面是解决办法。为了理解 tokenize 模块的行为，我们可以将 tokenize 模块作为脚本运行，并为其提供一些文本，以此来查看对于缩进块，会生成什么样的标识符序列：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;$ python &lt;span&gt;-&lt;/span&gt;m tokenize
foo bar
    baz
    dah
dum
&lt;span&gt;^&lt;/span&gt;D&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我们发现它会产生以下的标识符序列（我已经简化了上面运行的输出）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;NAME     &lt;span&gt;&apos;foo&apos;&lt;/span&gt;
NAME     &lt;span&gt;&apos;bar&apos;&lt;/span&gt;
NEWLINE
INDENT
NAME     &lt;span&gt;&apos;baz&apos;&lt;/span&gt;
NEWLINE
NAME     &lt;span&gt;&apos;dah&apos;&lt;/span&gt;
NEWLINE
DEDENT
NAME     &lt;span&gt;&apos;dum&apos;&lt;/span&gt;
NEWLINE&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这意味着一组缩进的代码行会被 INDENT 和 DEDENT 标记符所描绘。现在，我们可以重新编写元语法规则的 rule 如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;rule: NAME &quot;:&quot; alts NEWLINE INDENT more_alts DEDENT {
        Rule(name.string, alts + more_alts) }
    | NAME &quot;:&quot; alts NEWLINE { Rule(name.string, alts) }
    | NAME &quot;:&quot; NEWLINE INDENT more_alts DEDENT {
        Rule(name.string, more_alts) }
more_alts: &quot;|&quot; alts NEWLINE more_alts { alts + more_alts }
         | &quot;|&quot; alts NEWLINE { alts }&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;（我跨行地拆分了动作，以便它们适应 Medium 网站的窄页——这是可行的，因为标识符生成器会忽略已配对的括号内的换行符。）&lt;/div&gt;
&lt;div&gt;这样做的好处是我们甚至不需要更改生成器：这种改进的元语法生成的数据结构跟以前相同。同样注意 rule 的第三个备选项，对此让我们写：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;start:
    | metas rules ENDMARKER { Grammar(rules, metas) }
    | rules ENDMARKER { Grammar(rules, []) }&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;有些人会觉得这比我之前展示的版本更干净。很容易允许两种形式共存，所以我们不必争论风格。&lt;/div&gt;
&lt;div&gt;在下一篇文章中，我将展示如何实现各种 PEG 功能，如可选条目、重复和前瞻。（说句公道话，我本打算把那放在这篇里，但是这篇已写太长了，所以我要把它分成两部分。）&lt;/div&gt;
&lt;div&gt;本文内容与示例代码的授权协议：&lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 浮点数的冷知识</title>
            <link>https://pythoncat.top/posts/2019-09-21-float/</link>
            <guid>https://pythoncat.top/posts/2019-09-21-float/</guid>
            <pubDate>Sat, 21 Sep 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;本周的&lt;code&gt;PyCoder&apos;s Weekly&lt;/code&gt; 上分享了一篇小文章，它里面提到的冷知识很有意思，我稍作补充，分享给大家。&lt;/div&gt;
&lt;div&gt;它提到的部分问题，读者们可以先思考下：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;若两个元组相等，即 a==b 且 a is b，那么相同索引的元素（如 a[0] 、b[0]）是否必然相等呢？&lt;/li&gt;
&lt;li&gt;若两个对象的 hash 结果相等，即 hash(a) == hash(b)，那么它们是否必然相等呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;答案当然都为否（不然就不叫冷知识了），大家可以先尝试回答一下，然后再往下看。&lt;/div&gt;
&lt;div&gt;-----思考分割线-----&lt;/div&gt;
&lt;div&gt;好了，先来看看第一个问题。两个相同的元组 a、b，它们有如下的关系：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;nan&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; b &lt;span&gt;=&lt;/span&gt; a
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; a   &lt;span&gt;# (nan,)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; b   &lt;span&gt;# (nan,)&lt;/span&gt;

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;&apos;tuple&apos;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;&apos;tuple&apos;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; a &lt;span&gt;==&lt;/span&gt; b
&lt;span&gt;True&lt;/span&gt;

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; a &lt;span&gt;is&lt;/span&gt; b  &lt;span&gt;# 即 id(a) == id(b)&lt;/span&gt;
&lt;span&gt;True&lt;/span&gt;

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; a&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; b&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;以上代码表明：a 等于 b（类型、值与 id 都相等），但是它们的对位元素却不相等。&lt;/div&gt;
&lt;div&gt;两个元组都只有一个元素（逗号后面没有别的元素，这是单元素的元组的表示方法，即 len(a)==1 ）。float() 是个内置函数，可以将入参构造成一个浮点数。&lt;/div&gt;
&lt;div&gt;为什么会这样呢？先查阅一下文档，这个内置函数的解析规则是：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;sign           &lt;span&gt;:&lt;/span&gt;&lt;span&gt;:=&lt;/span&gt;  &lt;span&gt;&quot;+&quot;&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;&quot;-&quot;&lt;/span&gt;
infinity       &lt;span&gt;:&lt;/span&gt;&lt;span&gt;:=&lt;/span&gt;  &lt;span&gt;&quot;Infinity&quot;&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;&quot;inf&quot;&lt;/span&gt;
nan            &lt;span&gt;:&lt;/span&gt;&lt;span&gt;:=&lt;/span&gt;  &lt;span&gt;&quot;nan&quot;&lt;/span&gt;
numeric_value  &lt;span&gt;:&lt;/span&gt;&lt;span&gt;:=&lt;/span&gt;  floatnumber &lt;span&gt;|&lt;/span&gt; infinity &lt;span&gt;|&lt;/span&gt; nan
numeric_string &lt;span&gt;:&lt;/span&gt;&lt;span&gt;:=&lt;/span&gt;  &lt;span&gt;[&lt;/span&gt;sign&lt;span&gt;]&lt;/span&gt; numeric_value&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;它在解析时，可以解析前后的空格、前缀的加减号（+/-）、浮点数，除此之外，还可以解析两类字符串（不区分大小写）：“Infinity”或”inf”，表示无穷大数；“nan”，表示不是数（not-a-number），确切地说，指的是除了数以外的所有东西。&lt;/div&gt;
&lt;div&gt;前面分享的第一个冷知识就跟“nan”有关，作为整体，两个元组相等，但是它们唯一的元素却不相等。之所以会这样，因为“nan”表示除了数以外的东西，它是一个范围，所以不可比较。&lt;/div&gt;
&lt;div&gt;作为对比，我们来看看两个“无穷大的浮点数”是什么结果：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;inf&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; b &lt;span&gt;=&lt;/span&gt; a
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; a   &lt;span&gt;# (inf,)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; b   &lt;span&gt;# (inf,)&lt;/span&gt;

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; a &lt;span&gt;==&lt;/span&gt; b  &lt;span&gt;# True&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; a &lt;span&gt;is&lt;/span&gt; b  &lt;span&gt;# True&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; a&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; b&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;  &lt;span&gt;# True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;注意最后一次比较，它跟前面的两个元组恰好相反，由此，我们可以得出结论：&lt;strong&gt;两个无穷大的浮点数，数值相等，而两个“不是数的东西”，数值不相等。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;化简一下，可以这样看：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;inf&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;inf&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; c &lt;span&gt;=&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;nan&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; d &lt;span&gt;=&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;nan&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; a &lt;span&gt;==&lt;/span&gt; b  &lt;span&gt;# True&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; c &lt;span&gt;==&lt;/span&gt; d  &lt;span&gt;# False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;以上就是第一个冷知识的揭秘。接着看第二个：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;nan&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;nan&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;前面刚说了两个“不是数的东西”不相等，这里却显示它们的哈希结果相等，这挺违背常理的。&lt;/div&gt;
&lt;div&gt;我们可以推理出一条简单的结论：&lt;strong&gt;不相等的两个对象，其哈希结果可能相等。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;原因在于，hash(float(‘nan’)) 的结果等于 0，它是个固定值，作比较时当然就相等了。&lt;/div&gt;
&lt;div&gt;其实，关于 hash() 函数，还埋了一个彩蛋：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;inf&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 314159&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;-inf&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# -314159&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;有没有觉得这个数值很熟悉啊？它正是圆周率的前五位 3.14159，去除小数点后的结果。在早期的 Python 版本中，负无穷大数的哈希结果其实是 -271828，正是取自于自然对数 e。这两个数都是硬编码在 Python 解释器中的，算是某种致敬吧。&lt;/div&gt;
&lt;div&gt;由于 float(‘nan’) 的哈希值相等，这通常意味着它们不可以作为字典的不同键值，但是事实却出人意料：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;nan&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;nan&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; a
&lt;span&gt;{&lt;/span&gt;nan&lt;span&gt;:&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; nan&lt;span&gt;:&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;# 作为对比：&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;inf&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;inf&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; b
&lt;span&gt;{&lt;/span&gt;inf&lt;span&gt;:&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;如上所示，两个 nan 键值在表示上一模一样（注意，它们没有用引号括起来），它们可以共存，而 inf 却只能归并成一个，再次展示出了 nan 的神奇。&lt;/div&gt;
&lt;div&gt;好了，两个很冷的小知识分享完毕，背后的原因都在于 float() 取浮点数时，Python 允许了 nan（不是数）的存在，它表示不确切的存在，所以导致了这些奇怪的结果。&lt;/div&gt;
&lt;div&gt;最后，我们作下小结：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;包含 float(‘nan’) 的两个元组，当做整体作比较时，结果相等；两个相等的元组，其对位的元素可能不相等&lt;/li&gt;
&lt;li&gt;float(‘nan’) 表示一个“不是数”的东西，它本身不是确定值，两个对象作比较时不相等，但是其哈希结果是固定值，作比较时相等；可用作字典的键值，而且是不冲突的键值&lt;/li&gt;
&lt;li&gt;float(‘inf’) 表示一个无穷大的浮点数，可看作确定的值，两个对象做比较时相等，其哈希结果也相等；可用作字典的键值，但是会产生冲突&lt;/li&gt;
&lt;li&gt;float(‘nan’) 的哈希结果为 0，float(‘inf’) 的哈希结果为 314159&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;参考资料：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;https://docs.python.org/3/library/functions.html#float&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.pythondoeswhat.com/2019/09/welcome-to-float-zone.html&quot;&gt;https://www.pythondoeswhat.com/2019/09/welcome-to-float-zone.html&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 为了提升性能，竟运用了共享经济</title>
            <link>https://pythoncat.top/posts/2019-09-13-object/</link>
            <guid>https://pythoncat.top/posts/2019-09-13-object/</guid>
            <pubDate>Fri, 13 Sep 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;大家或许知道，Python 为了提高内存的利用效率，采用了一套共用对象内存的分配策略。&lt;/div&gt;
&lt;div&gt;例如，对于那些数值较小的数字对象（[-5, 256]）、布尔值对象、None 对象、较短的字符串对象（&lt;strong&gt;通常&lt;/strong&gt; 是 20）等等，字面量相等的对象实际上是同一个对象。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 共用内存地址的例子&lt;/span&gt;
a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;
b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;
s &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;python_cat&quot;&lt;/span&gt;
t &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;python_cat&quot;&lt;/span&gt;

&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 结果：True&lt;/span&gt;
&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;t&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 结果：True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我很早的时候曾写过一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/vCs6QvJU2J6L0rIWDKQPUQ&quot;&gt;Python中的“特权种族”是什么？&lt;/a&gt;》，把这些对象统称为“特权种族”，它们是 Python 在内存管理机制上使用的优化技巧。&lt;/div&gt;
&lt;div&gt;前不久，我还写了一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/8f259oIGCQtY6KFSx4KW6Q&quot;&gt;Python 内存分配时的小秘密&lt;/a&gt;》，也是介绍内存管理的技巧。&lt;/div&gt;
&lt;div&gt;这两篇文章有所区别：&lt;strong&gt;旧文主要涉及了内存共用与对象驻留的机制，而新文介绍的是内存分配、动态扩容以及内存回收的相关机制。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;它们令我不由自主地想到两个词：&lt;strong&gt;共享经济与供需平衡。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;如果你没有读过那两篇文章，我强烈建议你先回看一下，然后再看看我的联想是否有道理：那几类特权种族对象其实是在共享内存，表面上的不同对象，其实是在循环利用；至于供需平衡也好理解，创建某些对象时，按照预期的诉求去分配内存，在扩容时则灵活调节，达到了供需之间的平衡。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;透过现象看本质，Python 可以很有趣。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;但是，Python 的有趣之处还不止于此，本文要继续分享另一种内存管理机制，在某种程度上，它实现了共享经济与供需平衡的融合，我们从中可揭开 Python 的另一重身份……&lt;/div&gt;
&lt;h2&gt;1、不可变对象的共享经济&lt;/h2&gt;
&lt;div&gt;上面列出的”特权种族”都是不可变对象（而“供需平衡”主要出现于可变对象），对于这些不变的对象，当出现多处使用时，共用一个对象似乎是种不错的优化方法。&lt;/div&gt;
&lt;div&gt;我曾有一种猜想：&lt;strong&gt;Python 的不可变对象都可能是特权种族。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;我没有试图去完全证实它，本文只想考察其中一种不可变对象：元组。它是不可变对象，那么，是否有共用对象的机制呢？&lt;/div&gt;
&lt;div&gt;下面把它跟列表作一下对比：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 空对象的差别&lt;/span&gt;
a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
c &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
d &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 结果：False&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;)&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;d&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 结果：True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;由此可见，两个空列表是不同的对象，而两个空元组其实是同一个对象。这至少说明了，空元组在内存中只有一个，它属于已提到的特权种族。&lt;/div&gt;
&lt;div&gt;将实验延伸到集合与字典，它们是可变对象，你会发现结果跟列表一样，存在多个副本，即不是特权种族。我就不举例了。&lt;/div&gt;
&lt;div&gt;由上述的实验结果，还能引出两个问题，但是它们偏离了本文主题，我不打算深入辨析，简单列一下：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;除了空元组，还有什么样的元组是“特权种族”？（PS：从元素的数量、类型、元素自身的大小考虑，就我小范围试验，还没发现。所以，空元组是独特的唯一？）&lt;/li&gt;
&lt;li&gt;编译期与运行期有所区别，这在之前写字符串的 intern 机制时（《&lt;a href=&quot;https://mp.weixin.qq.com/s/M2uHVqaHe_nyO5jT60V_6Q&quot;&gt;Intern机制的软肋&lt;/a&gt;》）也分析过。（PS：print(id([]) == id([]))，结果为 True，与上例先赋值再比较不同。）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2、可变对象的共享经济&lt;/h2&gt;
&lt;div&gt;空元组体现了共享经济，但由于它是不可变对象，所以不存在动态扩容，就只体现了极少的供需平衡。&lt;/div&gt;
&lt;div&gt;作为对照，列表等可变对象充分表现了供需平衡，却似乎没办法体现共享经济。&lt;/div&gt;
&lt;div&gt;比如说，我们把一个列表想象成一个可自增的杯子（毕竟它是某种容器），再把它的元素想象成不同种类的液体（水、可乐、酒……）。&lt;/div&gt;
&lt;div&gt;那么，我们的问题是：两杯东西是否可以共享为一个对象呢？或者说，有没有可能共享那只杯子呢？这样就可以节省内存（在那篇讲小秘密的文章中展示过：“空杯子”占用的内存可不少），提升效率啦。&lt;/div&gt;
&lt;div&gt;对于第一个问题，答案为否，验证过程略。对于第二个问题，在上一节中，我们已验证过两个空杯子（即空列表），答案也为否。&lt;/div&gt;
&lt;div&gt;但是，第二个问题还有其它的可能！下面让我们换一种实验方法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 实验版本：Python 3.6.1&lt;/span&gt;
a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&apos;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;i&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt; -- &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&apos;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;# a[i] = 1 # PS：可去除注释，再执行一次，结果的顺序有差别&lt;/span&gt;

&lt;span&gt;del&lt;/span&gt; a
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;after del&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&apos;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;i&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt; -- &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&apos;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;以上代码在不同环境中，执行结果可能有所差异。我执行的一次结果如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;2012909395656&lt;/span&gt;
&lt;span&gt;0&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;2012909395272&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;2012909406472&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;2012909395208&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;2012909395144&lt;/span&gt;
after &lt;span&gt;del&lt;/span&gt;
&lt;span&gt;2012909395656&lt;/span&gt;
&lt;span&gt;0&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;2012909395272&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;2012909406472&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;2012909395208&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt; &lt;span&gt;2012909395144&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;分析结果可知：列表对象在被回收之后，并不会彻底消除，它的内存地址会传递给新创建的列表，也就是说，新创建的列表其实共享了旧列表的内存地址！&lt;/div&gt;
&lt;div&gt;再结合前面的例子，我们可以说，先后静态创建的两个列表会分配不同的内存地址，但是，经过动态回收之后，先后创建的列表可能是同一个内存地址！（注意：这里说的是“可能”，因为在新列表创建前，若有其它地方也在创建列表，那后者可能夺去先机。）&lt;/div&gt;
&lt;div&gt;延伸到其它基本的可变对象，例如集合与字典，也有同样的共享策略，其目的显而易见：&lt;strong&gt;循环利用这些对象的“残躯”，可以避免内存碎片，提高执行性能。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;共享一只杯子，总比重新创造一只杯子，要更高效便捷，对吧？&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Python 解释器在实现这个机制时，使用了一个叫做&lt;code&gt;free_list&lt;/code&gt; 的全局变量，其工作原理是：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;当创建新的对象时，则检查 free_list 内是否有可用对象，有则取出使用，没有则创建&lt;/li&gt;
&lt;li&gt;当这些对象被析构时，则检查 free_list 是否有剩余空间，有则存入其中&lt;/li&gt;
&lt;li&gt;某类对象存入 free_list 时，只保留“躯壳”，而清空其内部所有的元素（即只共享杯子，不共享杯中物）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;好了，现在我们可以说，列表、集合与字典这些可变对象，它们都不是前文所说的特权种族，但是，在它们背后都藏着循环使用的共享思想，这一点却是相通的。&lt;/div&gt;
&lt;div&gt;Python 解释器在内存管理上真是煞费苦心啊，在那些司空见惯的基本对象上，它施加了诸多的小魔法，在我们毫不觉察的时候，它们有条不紊地运作，而当我们终于见识清楚后，就不得不感叹它的精妙了。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Python 算得上是一个精打细算的“经济学家”了。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;回顾全文，最后作一个小结：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;较小的数字、较短的字符串、布尔值与空元组等不可变对象，它们存在着“共享经济”的机制，提升了内存的使用效率&lt;/li&gt;
&lt;li&gt;列表、集合与字典等可变对象，它们存在着预分配及超额分配等“供需平衡”的机制，提升了内存的分配效率&lt;/li&gt;
&lt;li&gt;列表等对象还存在着共享“容器外壳”的机制，循环利用空闲资源，综合提升程序性能&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;PS：本文写作过半时，我觉得应该把它写入“喵星来客”系列，但思前想后，最终作罢了（主要是懒）。它们的思辨力及洞察力是一脉相承的，若你喜欢本文的话，我推荐阅读“喵星来客”系列（其中两篇）：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/YQbk0smMTCexsi3Ytd2AzA&quot;&gt;Python对象的身份迷思：从全体公民到万物皆数&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/q0QvAqXcZzURH3aZ5gZm8A&quot;&gt;Python对象的空间边界：独善其身与开放包容&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 之父的解析器系列之六：给 PEG 语法添加动作</title>
            <link>https://pythoncat.top/posts/2019-09-12-PEG/</link>
            <guid>https://pythoncat.top/posts/2019-09-12-PEG/</guid>
            <pubDate>Thu, 12 Sep 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;原题&lt;/strong&gt; | &lt;a href=&quot;https://medium.com/@gvanrossum_83706/adding-actions-to-a-peg-grammar-d5e00fa1092f&quot;&gt;Adding Actions to a PEG Grammar&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;作者&lt;/strong&gt; | Guido van Rossum（Python之父）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; | 豌豆花下猫（“Python猫”公众号作者）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;声明&lt;/strong&gt; | 本翻译是出于交流学习的目的，基于 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt; 授权协议。为便于阅读，内容略有改动。&lt;/div&gt;
&lt;div&gt;如果你在语法规则中还可以添加（某些）语义，那么语法就会更好。特别是对于我正在构建的 Python 解析器，我需要控制每个备选项返回的 AST 节点，因为 AST 的格式已经规定好。&lt;/div&gt;
&lt;div&gt;【这是我的 PEG 系列的第 6 部分。其余部分请参阅&lt;a href=&quot;https://medium.com/@gvanrossum_83706/peg-parsing-series-de5d41b2ed60?sk=0a7ce9003b13aae8126a4a23812eb035&quot;&gt;系列概述&lt;/a&gt; 】（译注：本系列的译文已在 Github 开源，项目地址：&lt;a href=&quot;https://github.com/chinesehuazhou/guido_blog_translation&quot;&gt;https://github.com/chinesehuazhou/guido_blog_translation&lt;/a&gt;）&lt;/div&gt;
&lt;div&gt;许多语法都有支持给规则添加动作的约定，通常是 { 花括号 } 内的一段代码块。更确切地说，行动与备选项相关联。动作块中的代码通常与编写编译器的语言相同，如 C 语言，增加一些工具，用于引用备选项中的条目。在 Python 原始的 pgen 中，我没有添加此功能，但对于这个新项目，我希望使用它。&lt;/div&gt;
&lt;div&gt;对于在这一系列博客文章中开发的简化版解析器生成器，下面是我们采用的做法。&lt;/div&gt;
&lt;div&gt;一般而言，动作的语法如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;rule: item item item { action 1 } | item item { action 2 }&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;因为它会使语法变得冗长，所以解析器生成器通常支持跨行分割规则，例如：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;rule: item item item { action 1 }
    | item item { action 2}&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;它会使语法分析器变得复杂，但可读性更重要，所以我会使用这种方式。&lt;/div&gt;
&lt;div&gt;一个永恒的问题是何时执行动作块。在 Yacc / Bison 中，因为没有回溯，一旦规则被解析器识别到，就会执行动作块。每个动作会立即执行，这意味着即使操作具有全局副作用，还是会顺利执行（例如更新符号表或其它编译器数据结构）。&lt;/div&gt;
&lt;div&gt;在 PEG 解析器中，因为有无限回溯，我们有其它的选择：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;延迟所有动作，直到解析完所有内容。这对我的目的没有用，因为我想在解析期间构造一个 AST。&lt;/li&gt;
&lt;li&gt;只要识别出动作所对应的备选项就执行之，但要求操作代码是幂等的（即无论执行多少次，都具有相同的效果）。这意味着可以执行某个动作，但其结果最终会被丢弃。&lt;/li&gt;
&lt;li&gt;缓存动作的结果，因此只有第一次在给定位置识别到备选项时，对应的动作才执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;我要采用第三个选项——正好我们用 packrat 算法缓存东西，所以我们也可以缓存动作的结果。&lt;/div&gt;
&lt;div&gt;关于 {花括号} 里面的内容，传统上是使用 C 语言，它约定用 &lt;code&gt;$&lt;/code&gt; 符号来引用已识别的备选项（例如，&lt;code&gt;$1&lt;/code&gt; 引用第一个条目），并赋值给 &lt;code&gt;$$&lt;/code&gt; 以指示动作的结果。&lt;/div&gt;
&lt;div&gt;在我看来这太老古董了（我记得曾在 Algol-60 中使用对函数名的赋值，来指定返回值），所以我会用一些更 Pythonic 的方式：在括号内，你需要放置一个单一的表达式，它的值是动作的值，而条目的引用则是一些简单的名称，给出着条目的文本。&lt;/div&gt;
&lt;div&gt;举个例子，这是一个简单的计算器，可以作加减法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;start: expr NEWLINE { expr }
expr: expr &apos;+&apos; term { expr + term }
    | expr &apos;-&apos; term { expr - term }
    | term { term }
term: NUMBER { float(number.string) }&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;当我们运行时，给定输入 &lt;code&gt;100+50-38-70&lt;/code&gt; ，它会识别出各部分并计算答案，计算成&lt;code&gt;((100+50)-38)-70&lt;/code&gt; ，当然得出结果为 42。&lt;/div&gt;
&lt;div&gt;一个小细节：在&lt;code&gt;term&lt;/code&gt; 的动作中，变量&lt;code&gt;number&lt;/code&gt; 保存了一个&lt;code&gt;TokenInfo&lt;/code&gt; 对象，因此该动作必须使用其&lt;code&gt;.string&lt;/code&gt; 属性来获取字符串形式的标识符。&lt;/div&gt;
&lt;div&gt;当一个备选项中多次出现相同的规则名称时，我们该怎么办？对同一备选项中出现的规则，解析器生成器会给出唯一的名称，即在随后出现的规则上添加 1、2 等等。例如：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;factor: atom &apos;**&apos; atom { atom ** atom1 }
      | atom { atom }&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;它的实现很无聊，所以我请你们 check out &lt;a href=&quot;https://github.com/gvanrossum/pegen/tree/master/story5&quot;&gt;代码&lt;/a&gt; ，自己看看。试试这个：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;python3.8 -m story5.driver story5/calc.txt -g story5.calc.CalcParser&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;可视化功能现在支持使用左右箭头键来回移动！&lt;/div&gt;
&lt;div&gt;本文内容与示例代码的授权协议：&lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 的整数与 Numpy 的数据溢出</title>
            <link>https://pythoncat.top/posts/2019-09-10-number/</link>
            <guid>https://pythoncat.top/posts/2019-09-10-number/</guid>
            <pubDate>Tue, 10 Sep 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;某位 A 同学发了我一张截图，问为何结果中出现了负数？&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;看了图，我第一感觉就是数据溢出了。数据超出能表示的最大值，就会出现奇奇怪怪的结果。&lt;/div&gt;
&lt;div&gt;然后，他继续发了张图，内容是 print(100000*208378)，就是直接打印上图的 E[0]*G[0]，结果是 20837800000，这是个正确的结果。&lt;/div&gt;
&lt;div&gt;所以新的问题是：如果说上图的数据溢出了，为何直接相乘的数却没有溢出？&lt;/div&gt;
&lt;div&gt;由于我一直忽视数据的表示规则（整型的上限是多少？），而且对 Numpy 了解不多，还错看了图中结果，误以为每一个数据都是错误的，所以就解答不出来。&lt;/div&gt;
&lt;div&gt;最后，经过学习群里的一番讨论，我才终于明白是怎么回事，所以本文把相关知识点做个梳理。&lt;/div&gt;
&lt;div&gt;在正式开始之前，先总结一下上图会引出的话题：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Python 3 中整数的上限是多少？Python 2 呢？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Numpy 中整数的上限是多少？出现整数溢出该怎么办？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;关于第一个问题，先看看 Python 2，它有两种整数：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;一种是短整数，也即常说的整数，用 int 表示，有个内置函数 int()。其大小有限，可通过&lt;code&gt;sys.maxint()&lt;/code&gt; 查看（取决于平台是 32 位还是 64 位）&lt;/li&gt;
&lt;li&gt;一种是长整数，即大小无限的整数，用 long 表示，有个内置函数 long()。写法上是在数字后面加大写字母 L 或小写的 l，如 1000L&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;当一个整数超出短整数范围时，它会自动采用长整数表示。举例，打印 &lt;code&gt;2**100&lt;/code&gt; ，结果会在末尾加字母 L 表示它是长整数。&lt;/div&gt;
&lt;div&gt;但是到了 Python 3，情况就不同了：它仅有一种内置的整数，表示为 int，形式上是 Python 2 的短整数，但实际上它能表示的范围无限，行为上更像是长整数。无论多大的数，结尾都不需要字母 L 来作区分。&lt;/div&gt;
&lt;div&gt;也就是说，Python 3 整合了两种整数表示法，用户不再需要自行区分，全交给底层按需处理。&lt;/div&gt;
&lt;div&gt;理论上，Python 3 中的整数没有上限（只要不超出内存空间）。这就解释了前文中直接打印两数相乘，为什么结果会正确了。&lt;/div&gt;
&lt;div&gt;PEP-237（Unifying Long Integers and Integers）中对这个转变作了说明。它解释这样做的 目的：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;这会给新的 Python 程序员（无论他们是否是编程新手）减少一项上手前要学的功课。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;Python 在语言运用层屏蔽了很多琐碎的活，比如内存分配，所以，我们在使用字符串、列表或字典等对象时，根本不用操心。整数类型的转变，也是出于这样的便利目的。（坏处是牺牲了一些效率，在此就不谈了）&lt;/div&gt;
&lt;div&gt;回到前面的第二个话题：Numpy 中整数的上限是多少？&lt;/div&gt;
&lt;div&gt;由于它是 C 语言实现，在整数表示上，用的是 C 语言的规则，也就是会区分整数和长整数。&lt;/div&gt;
&lt;div&gt;有一种方式可查看：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; numpy &lt;span&gt;as&lt;/span&gt; np

a &lt;span&gt;=&lt;/span&gt; np&lt;span&gt;.&lt;/span&gt;arange&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 结果：numpy.int32&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;也就是说它默认的整数 int 是 32 位，表示范围在 -2147483648 ~ 2147483647。&lt;/div&gt;
&lt;div&gt;对照前文的截图，里面只有两组数字相乘时没有溢出：100007*4549、100012*13264，其它数据组都溢出了，所以出现奇怪的负数结果。&lt;/div&gt;
&lt;div&gt;Numpy 支持的数据类型要比 Python 的多，相互间的区分界限很多样：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;截图来源：&lt;a href=&quot;https://www.runoob.com/numpy/numpy-dtype.html&quot;&gt;https://www.runoob.com/numpy/numpy-dtype.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;要解决整数溢出问题，可以通过指定 dtype 的方式：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; numpy &lt;span&gt;as&lt;/span&gt; np

q &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;100000&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
w &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;500000&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;# 一个溢出的例子：&lt;/span&gt;
a &lt;span&gt;=&lt;/span&gt; np&lt;span&gt;.&lt;/span&gt;array&lt;span&gt;(&lt;/span&gt;q&lt;span&gt;)&lt;/span&gt;
b &lt;span&gt;=&lt;/span&gt; np&lt;span&gt;.&lt;/span&gt;array&lt;span&gt;(&lt;/span&gt;w&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;*&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 产生溢出，结果是个奇怪的数值&lt;/span&gt;

&lt;span&gt;# 一个解决的例子：&lt;/span&gt;
c &lt;span&gt;=&lt;/span&gt; np&lt;span&gt;.&lt;/span&gt;array&lt;span&gt;(&lt;/span&gt;q&lt;span&gt;,&lt;/span&gt; dtype&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;int64&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
d &lt;span&gt;=&lt;/span&gt; np&lt;span&gt;.&lt;/span&gt;array&lt;span&gt;(&lt;/span&gt;w&lt;span&gt;,&lt;/span&gt; dtype&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;int64&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;*&lt;/span&gt;d&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 没有溢出：[50000000000]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;好了，前面提出的问题就回答完了。来作个结尾吧：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Python 3 极大地简化了整数的表示，效果可表述为：整数就只有一种整数（int），没有其它类型的整数（long、int8、int64 之类的）&lt;/li&gt;
&lt;li&gt;Numpy 中的整数类型对应于 C 语言的数据类型，每种“整数”有自己的区间，要解决数据溢出问题，需要指定更大的数据类型（dtype）&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>为什么要翻译？值得坚持下去么？</title>
            <link>https://pythoncat.top/posts/2019-09-07-translation/</link>
            <guid>https://pythoncat.top/posts/2019-09-07-translation/</guid>
            <description>自从去年 12 月翻译了第一篇文章以来，我累计翻译了 14 篇文章</description>
            <pubDate>Sat, 07 Sep 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;自从去年 12 月翻译了第一篇文章以来，我累计翻译了 14 篇文章。&lt;/div&gt;
&lt;div&gt;这个数字说多不多，说少也不少，本来没有什么特殊意义，但是在阶段性回顾时，却显得耐人寻味——勉强可以凑出这个数字：1.55555 篇/月。&lt;/div&gt;
&lt;div&gt;主要是翻译了两个系列：一个是 Python 之父的解析器系列，6 篇；还一个是 PEP（Python 增强提案）系列，4 篇。&lt;/div&gt;
&lt;div&gt;我都集结起来，传到 Github 上了：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# Guido 的解析器系列&lt;/span&gt;
https&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;github&lt;span&gt;.&lt;/span&gt;com&lt;span&gt;/&lt;/span&gt;chinesehuazhou&lt;span&gt;/&lt;/span&gt;guido_blog_translation

&lt;span&gt;# PEP 系列（加上别人翻译的，共有 16 篇）&lt;/span&gt;
https&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;github&lt;span&gt;.&lt;/span&gt;com&lt;span&gt;/&lt;/span&gt;chinesehuazhou&lt;span&gt;/&lt;/span&gt;peps&lt;span&gt;-&lt;/span&gt;cn&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;围绕翻译的文章，有一些故事，我都另外写过文章（本篇也算在内），如此一看，没想到【翻译】话题竟成为了我们公众号里分量很重的一块了。&lt;/div&gt;
&lt;div&gt;闲来无事，我想跟大家聊聊：&lt;strong&gt;为什么我会开始翻译文章？过程中，有些什么感悟？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;我很早就明白一点：相比其它职业，英语对于程序员来说显得极为重要（这应该不用多解释吧？）所以，当我在考虑如何给公众号填入更多有价值的内容时，就想着去转载一些外文博客。&lt;/div&gt;
&lt;div&gt;早期时，我尝试转载了一些，但是后来没有坚持，反而倾向于自己翻译（或者转载别人翻译好的）。出现这个转变的主要原因是：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;英语文章在公众号里排版太难搞，阅读体验太差了&lt;/li&gt;
&lt;li&gt;缺少比较好的辅助工具，阅读门槛较高&lt;/li&gt;
&lt;li&gt;阅读量与互动的情况不容乐观，受众比较少&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;第一点是最大的排斥力，因为我对公众号的排版有些微的强迫症（曾经想转一篇文章，因调整排版，前后花了半个小时，效果还不理想，最后放弃），此外，自己去翻译，还有一些好处：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;翻译过程可以加深对内容的理解&lt;/li&gt;
&lt;li&gt;翻译有助于提升阅读理解力、文字转述力&lt;/li&gt;
&lt;li&gt;翻译是一个积极的劳动过程，带来成就感&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;我认为它值得被翻译，却还没人去翻，那我就试试看吧&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;一斥一拉，我就选择自己去翻译了。&lt;/div&gt;
&lt;div&gt;在翻译过程中，我主要借助的工具是谷歌翻译和有道词典，它们帮了很大的忙。&lt;/div&gt;
&lt;div&gt;很多时候，我觉得机翻得不错，就不加调整，但更多时候，某些长句或跨频用法使我们都很为难。&lt;/div&gt;
&lt;div&gt;如果要追求十分完美的话，我大概是一篇文章都翻不完的。所以，每次点击发布的时候，我都带着对自己能力不足的认知，怀着层积改进的希望，纵容着“&lt;strong&gt;先做成一件事再说，万丈高楼平地起&lt;/strong&gt; ”的乐观心态。&lt;/div&gt;
&lt;div&gt;这不是自谦，就在最近翻译解析器系列的时候，为了赶进度，我完全都没有细看代码，很多译处完全是模棱两可，大有不负责任的苗头。（自责一分钟……）&lt;/div&gt;
&lt;div&gt;不管怎么说，翻译这些文章，我觉得有其价值，自己收获良多（希望因此受益的同学也足够多），会一直坚持下去。&lt;/div&gt;
&lt;div&gt;闲聊结束。&lt;/div&gt;
&lt;div&gt;顺道呼吁一下（好啦，我承认这才是本文的真实目的），如果你也有参与翻译的想法，欢迎一起翻译解析器系列或 PEP 系列，前文有项目地址。给个 &lt;strong&gt;star&lt;/strong&gt; 也够，提出 issue 和建议最好！&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;敢于相信有美好的事物在等待&lt;/strong&gt;。&lt;/div&gt;
&lt;div&gt;关于翻译，我还聊过：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247484118&amp;amp;idx=1&amp;amp;sn=b8c0db910e4df762e5579e36f77e46a0&amp;amp;chksm=fa584553cd2fcc454a31cd4085ad03fa27396ebb1a928440c90ebb6d76e742d87c4edcb5b04c&amp;amp;scene=21#wechat_redirect&quot;&gt;别开心太早，Python 文档的翻译差远了&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247483788&amp;amp;idx=1&amp;amp;sn=761211f8e4095a6d71c39dd37c412dff&amp;amp;chksm=fa584609cd2fcf1fecd6ddd2cc22ada29d5ddce04216167c835cca6ef08f3dff0de2da57efbc&amp;amp;scene=21#wechat_redirect&quot;&gt;再聊聊Python中文社区的翻译&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247484523&amp;amp;idx=1&amp;amp;sn=024d5fef2a67f9386d73af7ce09db06f&amp;amp;chksm=fa5843eecd2fcaf8c2fbb9e5b2563d7f10b03b80123524b87bc4befeb9d3c106ee9473a0dab8&amp;amp;scene=21#wechat_redirect&quot;&gt;从 Python 之父的对话聊起，关于知识产权、知识共享与文章翻译&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 之父的解析器系列之五：左递归 PEG 语法</title>
            <link>https://pythoncat.top/posts/2019-09-06-PEG/</link>
            <guid>https://pythoncat.top/posts/2019-09-06-PEG/</guid>
            <pubDate>Fri, 06 Sep 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;原题&lt;/strong&gt; | Left-recursive PEG grammars&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;作者&lt;/strong&gt; | Guido van Rossum（Python之父）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; | 豌豆花下猫（“Python猫”公众号作者）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;声明&lt;/strong&gt; | 本翻译是出于交流学习的目的，基于 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt; 授权协议。为便于阅读，内容略有改动。&lt;/div&gt;
&lt;div&gt;我曾几次提及左递归是一块绊脚石，是时候去解决它了。基本的问题在于：使用递归下降解析器时，左递归会因堆栈溢出而导致程序终止。&lt;/div&gt;
&lt;div&gt;【这是我的 PEG 系列的第 5 部分。其它文章参见&lt;a href=&quot;https://medium.com/@gvanrossum_83706/peg-parsing-series-de5d41b2ed60&quot;&gt;这个目录&lt;/a&gt;】&lt;/div&gt;
&lt;div&gt;假设有如下的语法规则：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;expr: expr &apos;+&apos; term | term&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;如果我们天真地将它翻译成递归下降解析器的片段，会得到如下内容：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;expr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; expr&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; expect&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;+&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; term&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; term&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;也就是&lt;code&gt;expr()&lt;/code&gt; 以调用&lt;code&gt;expr()&lt;/code&gt; 开始，后者也以调用&lt;code&gt;expr()&lt;/code&gt; 开始，以此类推……这只能以堆栈溢出而结束，抛出异常&lt;code&gt;RecursionError&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;传统的补救措施是重写语法。在之前的文章中，我已经这样做了。事实上，上面的语法也能识别出来，如果我们重写成这样：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;expr: term &apos;+&apos; expr | term&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;但是，如果我们用它生成一个解析树，那么解析树的形状会有所不同，这会导致破坏性的后果，比如当我们在语法中添加一个&lt;code&gt;&apos;-&apos;&lt;/code&gt; 运算符时（因为&lt;code&gt;a - (b - c)&lt;/code&gt; 与&lt;code&gt;(a - b) - c&lt;/code&gt; 不一样）。&lt;/div&gt;
&lt;div&gt;这通常可以使用更强大的 PEG 特性来解决，例如分组和迭代，我们可以将上述规则重写为：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;expr: term (&apos;+&apos; term)*&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;实际上，这正是 Python 当前语法在 pgen 解析器生成器上的写法（pgen 与左递归规则具有同样的问题）。&lt;/div&gt;
&lt;div&gt;但是这仍然存在一些问题：因为像&lt;code&gt;&apos;+&apos;&lt;/code&gt; 和&lt;code&gt;&apos;-&apos;&lt;/code&gt; 这样的运算符，基本上是二进制的（在 Python 中），当我们解析像&lt;code&gt;a + b + c&lt;/code&gt; 这样的东西时，我们必须遍历解析的结果（基本上是列表[‘a’，’+’，‘b’，’+’，‘c’] ），以构造一个左递归的解析树（类似于 [[‘a’，’+’，‘b’] ，’+’，‘c’] ）。&lt;/div&gt;
&lt;div&gt;原始的左递归语法已经表诉了所需的关联性，因此，如果我们可以直接以该形式生成解析器，那将会很好。我们可以！一位粉丝向我指出了一个很好的技巧，还附带了一个数学证明，很容易实现。我会试着在这里解释一下。&lt;/div&gt;
&lt;div&gt;让我们考虑输入&lt;code&gt;foo + bar + baz&lt;/code&gt; 作为示例。我们想要解析出的解析树对应于&lt;code&gt;(foo + bar)+ baz&lt;/code&gt; 。这需要对&lt;code&gt;expr()&lt;/code&gt; 进行三次左递归调用：一次对应于顶级的“+” 运算符（即第二个）; 一次对应于内部的“+”运算符（即第一个）; 还有一次是选择第二个备选项（即&lt;code&gt;term&lt;/code&gt; ）。&lt;/div&gt;
&lt;div&gt;由于我不善于使用计算机绘制实际的图表，因此我将在此使用 ASCII 技巧作演示：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;expr------------+------+
  |              \      \
expr--+------+   &apos;+&apos;   term
  |    \      \          |
expr   &apos;+&apos;   term        |
  |            |         |
term           |         |
  |            |         |
&apos;foo&apos;        &apos;bar&apos;     &apos;baz&apos;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我们的想法是希望在 expr() 函数中有一个“oracle”（译注：预言、神谕，后面就不译了），它要么告诉我们采用第一个备选项（即递归调用 expr()），要么是第二个（即调用 term()）。在第一次调用 expr() 时，“oracle”应该返回 true; 在第二次（递归）调用时，它也应该返回 true，但在第三次调用时，它应该返回 false，以便我们可以调用 term()。&lt;/div&gt;
&lt;div&gt;在代码中，应该是这样：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;expr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; oracle&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; expr&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; expect&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;+&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; term&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; term&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我们该怎么写这样的“oracle”呢？试试看吧…我们可以尝试记录在调用堆栈上的 expr() 的（左递归）调用次数，并将其与下面表达式中“+” 运算符的数量进行比较。如果调用堆栈的深度大于运算符的数量，则应该返回 false。&lt;/div&gt;
&lt;div&gt;我几乎想用&lt;code&gt;sys._getframe()&lt;/code&gt; 来实现它，但有更好的方法：让我们反转调用的堆栈！&lt;/div&gt;
&lt;div&gt;这里的想法是我们从 oracle 返回 false 处调用，并保存结果。这就有了&lt;code&gt;expr()-&amp;gt;term()-&amp;gt;&apos;foo&apos;&lt;/code&gt; 。（它应该返回初始的&lt;code&gt;term&lt;/code&gt; 的解析树，即&lt;code&gt;&apos;foo&apos;&lt;/code&gt; 。上面的代码仅返回 True，但在本系列第二篇文章中，我已经演示了如何返回一个解析树。）很容易编写一个 oracle 来实现，它应该在首次调用时就返回 false——不需要检查堆栈或向前回看。&lt;/div&gt;
&lt;div&gt;然后我们再次调用&lt;code&gt;expr()&lt;/code&gt; ，这时 oracle 会返回 true，但是我们不对 expr() 进行左递归调用，而是用前一次调用时保存的结果来替换。瞧呐，预期的&lt;code&gt;&apos;+&apos;&lt;/code&gt; 运算符及随后的&lt;code&gt;term&lt;/code&gt; 也出现了，所以我们将会得到&lt;code&gt;foo + bar&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;我们重复这个过程，然后事情看起来又很清晰了：这次我们会得到完整表达式的解析树，并且它是正确的左递归（（foo + bar）+ baz ）。&lt;/div&gt;
&lt;div&gt;然后我们再次重复该过程，这一次，oracle 返回 true，并且前一次调用时保存的结果可用，没有下一步的’+’ 运算符，并且第一个备选项失效。所以我们尝试第二个备选项，它会成功，正好找到了初始的 term（‘foo’）。与之前的调用相比，这是一个糟糕的结果，所以在这里我们停止并留下最长的解析（即（foo + bar）+ baz ）。&lt;/div&gt;
&lt;div&gt;为了将其转换为实际的工作代码，我首先要稍微重写代码，以将 oracle() 的调用与左递归的 expr() 调用相结合。我们称之为&lt;code&gt;oracle_expr()&lt;/code&gt; 。代码：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;expr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; oracle_expr&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; expect&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;+&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; term&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; term&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;接着，我们将编写一个实现上述逻辑的装饰器。它使用了一个全局变量（不用担心，我稍后会改掉它）。&lt;code&gt;oracle_expr()&lt;/code&gt; 函数将读取该全局变量，而装饰器操纵着它：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;saved_result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;oracle_expr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; saved_result &lt;span&gt;is&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; saved_result
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;expr_wrapper&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;global&lt;/span&gt; saved_result
    saved_result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;
    parsed_length &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        new_result &lt;span&gt;=&lt;/span&gt; expr&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; new_result&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;
        new_parsed_length &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;calculate size of new_result&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; new_parsed_length &lt;span&gt;&amp;lt;=&lt;/span&gt; parsed_length&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;
        saved_result &lt;span&gt;=&lt;/span&gt; new_result
        parsed_length &lt;span&gt;=&lt;/span&gt; new_parsed_length
    &lt;span&gt;return&lt;/span&gt; saved_result&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这过程当然是可悲的，但它展示了代码的要点，所以让我们尝试一下，将它发展成我们可以引以为傲的东西。&lt;/div&gt;
&lt;div&gt;决定性的洞察（这是我自己的，虽然我可能不是第一个想到的）是我们可以使用记忆缓存而不是全局变量，将一次调用的结果保存到下一次，然后我们不需要额外的&lt;code&gt;oracle_expr()&lt;/code&gt; 函数——我们可以生成对 expr() 的标准调用，无论它是否处于左递归的位置。&lt;/div&gt;
&lt;div&gt;为了做到这点，我们需要一个单独的 @memoize_left_rec 装饰器，它只用于左递归规则。它通过将保存的值从记忆缓存中取出，充当了 oracle_expr() 函数的角色，并且它包含着一个循环调用，只要每个新结果所覆盖的部分比前一个长，就反复地调用 expr()。&lt;/div&gt;
&lt;div&gt;当然，因为记忆缓存分别按输入位置和每个解析方法来处理缓存，所以它不受回溯或多个递归规则的影响（例如，在玩具语法中，我一直使用 expr 和 term 都是左递归的）。&lt;/div&gt;
&lt;div&gt;我在第 3 篇文章中创建的基础结构的另一个不错的属性是它更容易检查新结果是否长于旧结果：mark() 方法将索引返回到输入的标记符数组中，因此我们可以使用它，而非上面的parsed_length 。&lt;/div&gt;
&lt;div&gt;我没有证明为什么这个算法总是有效的，不管这个语法有多疯狂。那是因为我实际上没有读过那个证明。我看到它适用于玩具语法中的 expr 等简单情况，也适用于更复杂的情况（例如，涉及一个备选项里可选条目背后藏着的左递归，或涉及多个规则之间的相互递归），但在 Python 的语法中，我能想到的最复杂的情况仍然相当温和，所以我可以信任于定理和证明它的人。&lt;/div&gt;
&lt;div&gt;所以让我们坚持干，并展示一些真实的代码。&lt;/div&gt;
&lt;div&gt;首先，解析器生成器必须检测哪些规则是左递归的。这是图论中一个已解决的问题。我不会在这里展示算法，事实上我将进一步简化工作，并假设语法中唯一的左递归规则就是直接左递归的，就像我们的玩具语法中的 expr 一样。然后检查左递归只需要查找以当前规则名称开头的备选项。我们可以这样写：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;is_left_recursive&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;rule&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; alt &lt;span&gt;in&lt;/span&gt; rule&lt;span&gt;.&lt;/span&gt;alts&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; alt&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; rule&lt;span&gt;.&lt;/span&gt;name&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;现在我们修改解析器生成器，以便对于左递归规则，它能生成一个不同的装饰器。回想一下，在第 3 篇文章中，我们使用 @memoize 修饰了所有的解析方法。我们现在对生成器进行一个小小的修改，对于左递归规则，我们替换成 @memoize_left_rec ，然后我们在memoize_left_rec 装饰器中变魔术。生成器的其余部分和支持代码无需更改！（然而我不得不在可视化代码中捣鼓一下。）&lt;/div&gt;
&lt;div&gt;作为参考，这里是原始的 @memoize 装饰器，从第 3 篇中复制而来。请注意，self 是一个Parser 实例，它具有 memo 属性（用空字典初始化）、mark() 和 reset() 方法，用于获取和设置 tokenizer 的当前位置：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;memoize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;func&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;memoize_wrapper&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;args&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        pos &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;mark&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        memo &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;memos&lt;span&gt;.&lt;/span&gt;get&lt;span&gt;(&lt;/span&gt;pos&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; memo &lt;span&gt;is&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            memo &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;memos&lt;span&gt;[&lt;/span&gt;pos&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
        
        key &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;func&lt;span&gt;,&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt; memo&lt;span&gt;:&lt;/span&gt;
            res&lt;span&gt;,&lt;/span&gt; endpos &lt;span&gt;=&lt;/span&gt; memo&lt;span&gt;[&lt;/span&gt;key&lt;span&gt;]&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;reset&lt;span&gt;(&lt;/span&gt;endpos&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            res &lt;span&gt;=&lt;/span&gt; func&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;args&lt;span&gt;)&lt;/span&gt;
            endpos &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;mark&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
            memo&lt;span&gt;[&lt;/span&gt;key&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; res&lt;span&gt;,&lt;/span&gt; endpos
        &lt;span&gt;return&lt;/span&gt; res
    &lt;span&gt;return&lt;/span&gt; memoize_wrapper&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;@memoize 装饰器在每个输入位置记住了前一调用——在输入标记符的（惰性）数组的每个位置，有一个单独的&lt;code&gt;memo&lt;/code&gt; 字典。memoize_wrapper 函数的前四行与获取正确的&lt;code&gt;memo&lt;/code&gt; 字典有关。&lt;/div&gt;
&lt;div&gt;这是 @memoize_left_rec 。只有 else 分支与上面的 @memoize 不同：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;memoize_left_rec&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;func&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;memoize_left_rec_wrapper&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;args&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        pos &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;mark&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        memo &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;memos&lt;span&gt;.&lt;/span&gt;get&lt;span&gt;(&lt;/span&gt;pos&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; memo &lt;span&gt;is&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            memo &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;memos&lt;span&gt;[&lt;/span&gt;pos&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
        key &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;func&lt;span&gt;,&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt; memo&lt;span&gt;:&lt;/span&gt;
            res&lt;span&gt;,&lt;/span&gt; endpos &lt;span&gt;=&lt;/span&gt; memo&lt;span&gt;[&lt;/span&gt;key&lt;span&gt;]&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;reset&lt;span&gt;(&lt;/span&gt;endpos&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;# Prime the cache with a failure.&lt;/span&gt;
            memo&lt;span&gt;[&lt;/span&gt;key&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; lastres&lt;span&gt;,&lt;/span&gt; lastpos &lt;span&gt;=&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; pos
            &lt;span&gt;# Loop until no longer parse is obtained.&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                self&lt;span&gt;.&lt;/span&gt;reset&lt;span&gt;(&lt;/span&gt;pos&lt;span&gt;)&lt;/span&gt;
                res &lt;span&gt;=&lt;/span&gt; func&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;args&lt;span&gt;)&lt;/span&gt;
                endpos &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;mark&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; endpos &lt;span&gt;&amp;lt;=&lt;/span&gt; lastpos&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;break&lt;/span&gt;
                memo&lt;span&gt;[&lt;/span&gt;key&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; lastres&lt;span&gt;,&lt;/span&gt; lastpos &lt;span&gt;=&lt;/span&gt; res&lt;span&gt;,&lt;/span&gt; endpos
            res &lt;span&gt;=&lt;/span&gt; lastres
            self&lt;span&gt;.&lt;/span&gt;reset&lt;span&gt;(&lt;/span&gt;lastpos&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; res
    &lt;span&gt;return&lt;/span&gt; memoize_left_rec_wrapper&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;它很可能有助于显示生成的 expr() 方法，因此我们可以跟踪装饰器和装饰方法之间的流程：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;    &lt;span&gt;@memoize_left_rec&lt;/span&gt; 
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;expr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        pos &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;mark&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;expr &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expr&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;and&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;expect&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;+&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;and&lt;/span&gt;
            &lt;span&gt;(&lt;/span&gt;term &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;term&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; Node&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;expr&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;expr&lt;span&gt;,&lt;/span&gt; term&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;reset&lt;span&gt;(&lt;/span&gt;pos&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; term &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;term&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; Node&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;term&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;term&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;reset&lt;span&gt;(&lt;/span&gt;pos&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;让我们试着解析 &lt;code&gt;foo + bar + baz&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;每当你调用被装饰的 expr() 函数时，装饰器就会“拦截”调用，它会在当前位置查找前一个调用。在第一个调用处，它会进入 else 分支，在那里它重复地调用未装饰的函数。当未装饰的函数调用 expr() 时，这当然指向了被装饰的版本，因此这个递归调用会再次被截获。递归在这里停止，因为现在 memo 缓存有了命中。&lt;/div&gt;
&lt;div&gt;接下来呢？初始的缓存值来自这行：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;            # Prime the cache with a failure.
            memo[key] = lastres, lastpos = None, pos&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这使得被装饰的 expr() 返回 None，在那 expr() 里的第一个 if 会失败（在&lt;code&gt;expr := self.expr()&lt;/code&gt; ）。所以我们继续到第二个 if，它成功识别了一个 term（在我们的例子中是 ‘foo’），expr 返回一个 Node 实例。它返回到了哪里？到了装饰器里的 while 循环。这新的结果会更新 memo 缓存（那个 node 实例），然后开始下一个迭代。&lt;/div&gt;
&lt;div&gt;再次调用未装饰的 expr()，这次截获的递归调用返回新缓存的 Node 实例（一个 term）。这是成功的，调用继续到 expect(’+’)。这再次成功，然后我们现在处于第一个“+” 操作符。在此之后，我们要查找一个 term，也成功了（找到 ‘bar’）。&lt;/div&gt;
&lt;div&gt;所以对于空的 expr()，目前已识别出 &lt;code&gt;foo + bar&lt;/code&gt; ，回到 while 循环，还会经历相同的过程：用新的（更长的）结果来更新 memo 缓存，并开启下一轮迭代。&lt;/div&gt;
&lt;div&gt;游戏再次上演。被截获的递归 expr() 调用再次从缓存中检索新的结果（这次是 foo + bar），我们期望并找到另一个 ‘+’（第二个）和另一个 term（‘baz’）。我们构造一个 Node 表示 &lt;code&gt;(foo + bar) + baz&lt;/code&gt; ，并返回给 while 循环，后者将它填充进 memo 缓存，并再次迭代。&lt;/div&gt;
&lt;div&gt;但下一次事情会有所不同。有了新的结果，我们查找另一个 ’+’ ，但没有找到！所以这个expr() 调用会回到它的第二个备选项，并返回一个可怜的 term。当走到 while 循环时，它失望地发现这个结果比最后一个短，就中断了，将更长的结果（（foo + bar）+ baz ）返回给原始调用，就是初始化了外部 expr() 调用的地方（例如，一个 statement() 调用——此处未展示）。&lt;/div&gt;
&lt;div&gt;到此，今天的故事结束了：我们已经成功地在 PEG（-ish）解析器中驯服了左递归。至于下周，我打算论述在语法中添加“动作”（actions），这样我们就可以为一个给定的备选项的解析方法，自定义它返回的结果（而不是总要返回一个 Node 实例）。&lt;/div&gt;
&lt;div&gt;如果你想使用代码，请参阅&lt;a href=&quot;https://github.com/gvanrossum/pegen/tree/master/story4&quot;&gt;GitHub仓库&lt;/a&gt;。（我还为左递归添加了可视化代码，但我并不特别满意，所以不打算在这里给出链接。）&lt;/div&gt;
&lt;div&gt;本文内容与示例代码的授权协议：&lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者简介： Guido van Rossum，Python 的创造者，一直是“终身仁慈独裁者”，直到 2018 年 7 月 12 日退位。目前，他是新的最高决策层的五位成员之一，依然活跃在社区中。本文出自他在 Medium 开博客所写的解析器系列，该系列仍在连载中，每周日更新。&lt;/div&gt;
&lt;div&gt;译者简介： 豌豆花下猫，生于广东毕业于武大，现为苏漂程序员，有一些极客思维，也有一些人文情怀，有一些温度，还有一些态度。公众号：「Python猫」（python_cat）。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 内存分配时的小秘密</title>
            <link>https://pythoncat.top/posts/2019-08-31-size/</link>
            <guid>https://pythoncat.top/posts/2019-08-31-size/</guid>
            <description>一些很有意思的小发现</description>
            <pubDate>Sat, 31 Aug 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 中的&lt;code&gt;sys&lt;/code&gt; 模块极为基础而重要，它主要提供了一些给解释器使用（或由它维护）的变量，以及一些与解释器强交互的函数。&lt;/div&gt;
&lt;div&gt;本文将会频繁地使用该模块的&lt;code&gt;getsizeof()&lt;/code&gt; 方法，因此，我先简要介绍一下：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;该方法用于获取一个对象的字节大小（bytes）&lt;/li&gt;
&lt;li&gt;它只计算直接占用的内存，而不计算对象内所引用对象的内存&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;这里有个直观的例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; sys

a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; a&lt;span&gt;]&lt;/span&gt;  &lt;span&gt;# 即 [[1, 2], [1, 2]]&lt;/span&gt;

&lt;span&gt;# a、b 都只有两个元素，所以直接占用的大小相等&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 结果：80&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 结果：80&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上例说明了一件事：一个静态创建的列表，如果只包含两个元素，那它自身占用的内存就是 80 字节，不管其元素所指向的对象是什么。&lt;/div&gt;
&lt;div&gt;好了，拥有这把测量工具，我们就来探究一下 Python 的内置对象都藏了哪些小秘密吧。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;1、空对象不是“空”的！&lt;/h2&gt;
&lt;div&gt;对于我们熟知的一些空对象，例如空字符串、空列表、空字典等等，不知道大家是否曾好奇过，是否曾思考过这些问题：&lt;strong&gt;空的对象是不是不占用内存呢？如果占内存，那占用多少呢？为什么是这样分配的呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;直接上代码吧，一起来看看几类基本数据结构的空对象的大小：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; sys
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;      &lt;span&gt;# 49&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;      &lt;span&gt;# 64&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;      &lt;span&gt;# 48&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# 224&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;&lt;span&gt;dict&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 240&lt;/span&gt;

&lt;span&gt;# 作为参照：&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;       &lt;span&gt;# 28&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;    &lt;span&gt;# 28&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;可见，虽然都是空对象，但是这些对象在内存分配上并不为“空”，而且分配得还挺大（记住这几个数字哦，后面会考）。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;排一下序：基础数字&amp;lt;空元组 &amp;lt; 空字符串 &amp;lt; 空列表 &amp;lt; 空集合 &amp;lt; 空字典。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;这个小秘密该怎么解释呢？&lt;/div&gt;
&lt;div&gt;因为这些空对象都是容器，我们可以抽象地理解：它们的一部分内存用于创建容器的骨架、记录容器的信息（如引用计数、使用量信息等等）、还有一部分内存则是预分配的。&lt;/div&gt;
&lt;h2&gt;2、内存扩充不是均匀的！&lt;/h2&gt;
&lt;div&gt;空对象并不为空，一部分原因是 Python 解释器为它们预分配了一些初始空间。在不超出初始内存的情况下，每次新增元素，就使用已有内存，因而避免了再去申请新的内存。&lt;/div&gt;
&lt;div&gt;那么，如果初始内存被分配完之后，新的内存是怎么分配的呢？&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; sys
letters &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;abcdefghijklmnopqrstuvwxyz&quot;&lt;/span&gt;

a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; letters&lt;span&gt;:&lt;/span&gt;
    a&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&apos;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;, sys.getsizeof(a) = &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&apos;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    
b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; letters&lt;span&gt;:&lt;/span&gt;
    b&lt;span&gt;.&lt;/span&gt;add&lt;span&gt;(&lt;/span&gt;j&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&apos;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;, sys.getsizeof(b) = &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&apos;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

c &lt;span&gt;=&lt;/span&gt; &lt;span&gt;dict&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt; letters&lt;span&gt;:&lt;/span&gt;
    c&lt;span&gt;[&lt;/span&gt;k&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; k
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&apos;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;)&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;, sys.getsizeof(c) = &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;)&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&apos;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;分别给三类可变对象添加 26 个元素，看看结果如何：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;由此能看出可变对象在扩充时的秘密：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;超额分配机制：&lt;/strong&gt; 申请新内存时并不是按需分配的，而是多分配一些，因此当再添加少量元素时，不需要马上去申请新内存&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非均匀分配机制：&lt;/strong&gt; 三类对象申请新内存的频率是不同的，而同一类对象每次超额分配的内存并不是均匀的，而是逐渐扩大的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3、列表不等于列表！&lt;/h2&gt;
&lt;div&gt;以上的可变对象在扩充时，有相似的分配机制，在动态扩容时可明显看出效果。&lt;/div&gt;
&lt;div&gt;那么，静态创建的对象是否也有这样的分配机制呢？它跟动态扩容比，是否有所区别呢？&lt;/div&gt;
&lt;div&gt;先看看集合与字典：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 静态创建对象&lt;/span&gt;
set_1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
set_2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
dict_1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;b&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;c&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;d&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;e&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
dict_2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;b&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;c&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;d&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;e&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;f&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;set_1&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 224&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;set_2&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 736&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;dict_1&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 240&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;dict_2&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 368&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;看到这个结果，再对比上一节的截图，可以看出：&lt;strong&gt;在元素个数相等时，静态创建的集合/字典所占的内存跟动态扩容时完全一样。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;这个结论是否适用于列表对象呢？一起看看：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;list_1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;b&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
list_2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;b&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;c&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
list_3 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;b&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;c&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;d&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
list_4 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;b&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;c&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;d&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;e&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;list_1&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 80&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;list_2&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 88&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;list_3&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 96&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;list_4&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 104&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上一节的截图显示，列表在前 4 个元素时都占 96 字节，在 5 个元素时占 128 字节，与这里明显矛盾。&lt;/div&gt;
&lt;div&gt;所以，这个秘密昭然若揭：&lt;strong&gt;在元素个数相等时，静态创建的列表所占的内存有可能小于动态扩容时的内存！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;也就是说，这两种列表看似相同，实际却不同！列表不等于列表！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;4、消减元素并不会释放内存！&lt;/h2&gt;
&lt;div&gt;前面提到了，扩充可变对象时，可能会申请新的内存。&lt;/div&gt;
&lt;div&gt;那么，如果反过来缩减可变对象，减掉一些元素后，新申请的内存是否会自动回收掉呢？&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; sys
a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 初始值：96&lt;/span&gt;
a&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;      &lt;span&gt;# 扩充后：[1, 2, 3, 4, 5]&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 扩充后：128&lt;/span&gt;
a&lt;span&gt;.&lt;/span&gt;pop&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;          &lt;span&gt;# 缩减后：[1, 2, 3, 4]&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 缩减后：128&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;如代码所示，列表在一扩一缩后，虽然回到了原样，但是所占用的内存空间可没有自动释放啊。其它的可变对象同理。&lt;/div&gt;
&lt;div&gt;这就是 Python 的小秘密了，&lt;strong&gt;“胖子无法减重原理”&lt;/strong&gt; ：瘦子变胖容易，缩减身型也容易，但是体重减不掉，哈哈~~~&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;5、空字典不等于空字典！&lt;/h2&gt;
&lt;div&gt;使用 pop() 方法，只会缩减可变对象中的元素，但并不会释放已申请的内存空间。&lt;/div&gt;
&lt;div&gt;还有个 clear() 方法，它会清空可变对象的所有元素，让我们试试看吧：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; sys
a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
c &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;b&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;c&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 88&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 224&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 240&lt;/span&gt;

a&lt;span&gt;.&lt;/span&gt;clear&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;        &lt;span&gt;# 清空后：[]&lt;/span&gt;
b&lt;span&gt;.&lt;/span&gt;clear&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;        &lt;span&gt;# 清空后：set()&lt;/span&gt;
c&lt;span&gt;.&lt;/span&gt;clear&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;        &lt;span&gt;# 清空后：{}，也即 dict()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;调用 clear() 方法，我们就获得了几个空对象。&lt;/div&gt;
&lt;div&gt;在第一小节里，它们的内存大小已经被查验过了。（前面说过会考的，请默写 回看下）&lt;/div&gt;
&lt;div&gt;但是，如果这时再去查验的话，你会惊讶地发现，这些空对象的大小跟前面查的并不完全一样！&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 承接前面的清空操作：&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 64&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 224&lt;/span&gt;
sys&lt;span&gt;.&lt;/span&gt;getsizeof&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 72&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;空列表与空元组的大小不变，然而空字典（72）竟然比前面的空字典（240）要小很多！&lt;/div&gt;
&lt;div&gt;也就是说，列表与元组在清空元素后，回到起点不变初心，然而，字典这家伙却是“赔了夫人又折兵”，不仅把“吃”进去的全吐出来了，还把自己的老本给亏掉了！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;字典的这个秘密藏得挺深的，说实话我也是刚刚获知，百思不得其解……&lt;/div&gt;
&lt;div&gt;以上就是 Python 在分配内存时的几个小秘密啦，看完之后，你是否觉得涨见识了呢？&lt;/div&gt;
&lt;div&gt;你想明白了几个呢，又产生了多少新的谜团呢？欢迎留言一起交流哦~&lt;/div&gt;
&lt;div&gt;对于那些没有充分解释的小秘密，今后我们再慢慢揭秘……&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 之父的解析器系列之四：可视化 PEG 解析</title>
            <link>https://pythoncat.top/posts/2019-08-27-PEG/</link>
            <guid>https://pythoncat.top/posts/2019-08-27-PEG/</guid>
            <pubDate>Tue, 27 Aug 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;原题&lt;/strong&gt; | Visualizing PEG Parsing&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;作者&lt;/strong&gt; | Guido van Rossum（Python之父）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; | 豌豆花下猫（“Python猫”公众号作者）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;声明&lt;/strong&gt; | 本翻译是出于交流学习的目的，基于 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt; 授权协议。为便于阅读，内容略有改动。&lt;/div&gt;
&lt;div&gt;上周我展示了一个简单的 PEG 解析器生成器。本周我将展示生成的解析器在解析程序时实际执行的操作。我深入研究了 ASCII 艺术的复古世界，特别是一个名为“curses”的库，它可以在 Linux 和 Mac 的 Python 标准库中找到，也可以作为 Windows 的附加组件。&lt;/div&gt;
&lt;div&gt;【这是我的 PEG 系列的第 4 部分。见&lt;a href=&quot;https://medium.com/@gvanrossum_83706/peg-parsers-7ed72462f97c&quot;&gt;第1部分&lt;/a&gt;，&lt;a href=&quot;https://medium.com/@gvanrossum_83706/building-a-peg-parser-d4869b5958fb&quot;&gt;第2部分&lt;/a&gt;，&lt;a href=&quot;https://medium.com/@gvanrossum_83706/generating-a-peg-parser-520057d642a9&quot;&gt;第3部分&lt;/a&gt;，&lt;a href=&quot;https://medium.com/@gvanrossum_83706/left-recursive-peg-grammars-65dab3c580e1&quot;&gt;第5部分&lt;/a&gt; 】（译注：对应的译文，&lt;a href=&quot;https://mp.weixin.qq.com/s/yqVVaZVn8RRanllaXMFD9A&quot;&gt;第1篇&lt;/a&gt;、&lt;a href=&quot;https://mp.weixin.qq.com/s/yUQPeqc_uSRGe5lUi50kVQ&quot;&gt;第2篇&lt;/a&gt;、&lt;a href=&quot;https://mp.weixin.qq.com/s/ojSq6u9FC0xlBDncuoKczw&quot;&gt;第3篇&lt;/a&gt;、第5篇待译 ）&lt;/div&gt;
&lt;div&gt;让我们来看看可视化已取得的进展。截图里的屏幕被分隔为三个部分，分别是简单的 ASCII 字符，以及用连字符划出的线：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;上部分显示了解析器的调用堆栈，你可能还记得它是一个具有无限回溯的递归下降解析器。我将在下面解释如何阅读它。&lt;/li&gt;
&lt;li&gt;中间的单行部分展示了标记符缓冲区的内容，光标指向下一个要解析的标记符。&lt;/li&gt;
&lt;li&gt;在底部，我们呈现 packrat 解析算法使用的记忆缓存。它的条目类似于一些解析器堆栈条目（具有结果的条目）。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;阅读此图表时，要注意的主要事项是：顶部和底部部分的缩进线与标记符缓冲区相对应。（译注：最好看一下后面的 gif 动图，再往下看这部分内容。）&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;前两行（以&lt;code&gt;statement&lt;/code&gt; 和&lt;code&gt;assignment&lt;/code&gt; 开头）表示尚未返回的解析方法调用，并且当标记位置处在第一个标记符（‘aap’ ）之前时调用。&lt;/li&gt;
&lt;li&gt;接下来的两行（以&lt;code&gt;expr&lt;/code&gt; 和&lt;code&gt;term&lt;/code&gt; 开头）与标记符&lt;code&gt;&apos;cat&apos;&lt;/code&gt; 的开头垂直对齐，后者是调用相应解析方法的地方。&lt;/li&gt;
&lt;li&gt;堆栈部分所显示的第五行暨最后一行是一个&lt;code&gt;expect(&apos;/&apos;)&lt;/code&gt; 调用，它返回 None 。它是在标记符&lt;code&gt;&apos;+&apos;&lt;/code&gt; 处被调用的。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;缓存部分的条目的缩进也对应着标记符缓冲区的位置。例如，在底部，我们看到有负数缓存条目（negative cache entries）在标记符缓冲区的开头查找标记符&lt;code&gt;&apos;if&apos;&lt;/code&gt; 以及规则&lt;code&gt;if_statement&lt;/code&gt; 。我们还发现标记符&lt;code&gt;&apos;=&apos;&lt;/code&gt; 和&lt;code&gt;NAME&lt;/code&gt; （特别是&lt;code&gt;&apos;cat&apos;&lt;/code&gt; ）所成功缓存的条目，它们与将来的输入位置相对应。&lt;/div&gt;
&lt;div&gt;在显示出来的解析器堆栈和缓存中，已返回的调用被显示成&lt;code&gt;function(args) -&amp;gt; result&lt;/code&gt; 。有时解析器堆栈也会显示几个已返回的方法——我这样做是为了减少显示时的“跳跃性”。&lt;/div&gt;
&lt;div&gt;（说到“跳跃”，顶部显示的解析器堆栈会在一个调用被添加到堆栈时，向上移动，而当从堆栈中弹出一个调用时，它则向下移动。似乎我们的眼睛跟随这样的动作不会有太大问题——至少我没有。这很可能因为我们大脑中有一块区域是用于跟踪移动的物体。:-)&lt;/div&gt;
&lt;div&gt;缓存被可视化为一种 LRU 缓存，最近使用过的缓存条目位于顶部，较少使用的项目则向屏幕底部掉落。（我在之前的帖子中展示的 packrat 解析器原型不使用 LRU，但它可能是改善其内存使用的好策略。）&lt;/div&gt;
&lt;div&gt;让我们看一下解析堆栈在显示时的更多一些细节。前四个条目对应于尚未返回的解析方法，每一行显示了语法中的一行。带下划线的条目会引起下一次调用。&lt;/div&gt;
&lt;div&gt;在这种情况下，我们看到我们处于 statement 的第二种选择，也即 assignment，并且在该规则中我们处于第三项，即 expr。在 expr 规则中，我们只是在第一个可选项的第一个条目（&lt;code&gt;term &apos;+&apos; expr&lt;/code&gt; ）；而在 term 规则中，我们处在最后的选项（&lt;code&gt;atom&lt;/code&gt;）。&lt;/div&gt;
&lt;div&gt;在那之后，我们看到导致第二个选项（&lt;code&gt;atom &apos;/&apos; term&lt;/code&gt; ）失败的结果：&lt;code&gt;expect（&apos;/&apos;） - &amp;gt; None&lt;/code&gt; 用 ’+’ 标记符缩进。当我们将可视化向前移动时，我们会看到它沉入缓存中。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;但当然了，你肯定宁愿自己看动画！我已经录制了&lt;a href=&quot;https://raw.githubusercontent.com/gvanrossum/pegen/master/story3/tty.gif&quot;&gt;示例程序的完整解析&lt;/a&gt;。你也可以自己玩&lt;a href=&quot;https://github.com/gvanrossum/pegen/tree/master/story3&quot;&gt;代码&lt;/a&gt;，但请注意，这只是一个临时的黑科技。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;gif图：&lt;a href=&quot;https://raw.githubusercontent.com/gvanrossum/pegen/master/story3/tty.gif&quot;&gt;https://raw.githubusercontent.com/gvanrossum/pegen/master/story3/tty.gif&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;示例代码：&lt;a href=&quot;https://github.com/gvanrossum/pegen/tree/master/story3&quot;&gt;https://github.com/gvanrossum/pegen/tree/master/story3&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;当你在观看&lt;a href=&quot;https://raw.githubusercontent.com/gvanrossum/pegen/master/story3/tty.gif&quot;&gt;录制的GIF时&lt;/a&gt;，可能会感到有些迷惑，有时下一个标记符还未显示（例如，在最开始时，堆栈在标记符&lt;code&gt;&apos;aap&apos;&lt;/code&gt; 被显示之前，就增长了几个条目）。&lt;/div&gt;
&lt;div&gt;这正是解析器所看到的：标记符缓冲区被延迟地填充，并且在解析器通过调用 expect() 来请求它们之前，并不会扫描标记符。一旦标记符出现在缓冲区中，它就会保留在那里，即便在解析器回溯时也如此。&lt;/div&gt;
&lt;div&gt;标记符缓冲区中的光标向左跳跃，显示了回溯过程；该动图中有很多次出现这种现象。你还可以在 gif 中观察到缓存填充，解析器在那不会进行额外的递归调用。（发现这种情况时，我应该加以强调，但我没时间了。）&lt;/div&gt;
&lt;div&gt;下周我将进一步开发解析器，很可能会添加我对左递归语法规则的实现。（它们很棒！）&lt;/div&gt;
&lt;div&gt;致谢：录制时所用的&lt;code&gt;ttygif&lt;/code&gt; （Ilia Choly 开发） 和 &lt;code&gt;ttyrec&lt;/code&gt; （Matthew Jording 开发）。&lt;/div&gt;
&lt;div&gt;本文内容、示例代码和图片的授权协议：&lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;英文原文：&lt;a href=&quot;https://medium.com/@gvanrossum_83706/visualizing-peg-parsing-93a36f259423&quot;&gt;https://medium.com/@gvanrossum_83706/visualizing-peg-parsing-93a36f259423&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;作者简介：&lt;/strong&gt; Guido van Rossum，Python 的创造者，一直是“终身仁慈独裁者”，直到 2018 年 7 月 12 日退位。目前，他是新的最高决策层的五位成员之一，依然活跃在社区中。本文出自他在 Medium 开博客所写的解析器系列，该系列仍在连载中，每周日更新。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者简介：&lt;/strong&gt; 豌豆花下猫，生于广东毕业于武大，现为苏漂程序员，有一些极客思维，也有一些人文情怀，有一些温度，还有一些态度。公众号：「Python猫」（python_cat）。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>如何美观地打印 Python 对象？这个标准库可以简单实现</title>
            <link>https://pythoncat.top/posts/2019-08-25-pprint/</link>
            <guid>https://pythoncat.top/posts/2019-08-25-pprint/</guid>
            <pubDate>Sun, 25 Aug 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;前不久，我写了一篇文章回顾 Python 中 &lt;a href=&quot;https://mp.weixin.qq.com/s/NuzfuH_zCZzcrmSFR04NHw&quot;&gt;print 的发展历史&lt;/a&gt; ，提到了两条发展线索：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;明线：早期的 print 语句带有 C 和 Shell 的影子，是个应用程序级的 statement，在最初十几年里，经历过 PEP-214 和 PEP-259 的改进；再到 2009 年的大版本 3.0，由语句改成了 print() 函数，还在 3.3 版本，做过一次功能增强，最终上升成为一等的内置函数。&lt;/li&gt;
&lt;li&gt;暗线：介绍了 print 的竞争对手们，像传统的日志模块 logging、调试模块 pdb、主流 IDE 的调试功能，以及后起之秀 PySnooper，它们瞄准着 print 的位置，摩拳擦掌，虎视眈眈。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;本文依然跟 print 相关，想介绍的是标准库中的 &lt;code&gt;pprint&lt;/code&gt; 模块。&lt;/div&gt;
&lt;div&gt;pprint 是“pretty printer”的简写，“pretty”的含义是“漂亮的、美观的”，还有表示“相当地”的程度语气，因此它的含义便是：（相当）美观的打印。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;这是个相当简单却有用的模块，主要用于打印复杂的数据结构对象，例如多层嵌套的列表、元组和字典等。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;先看看 print() 打印的一个例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;mylist &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;Beautiful is better than ugly.&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;Explicit is better than implicit.&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;Simple is better than complex.&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;Complex is better than complicated.&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mylist&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 结果如下：&lt;/span&gt;
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;Beautiful is better than ugly.&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;Explicit is better than implicit.&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;Simple is better than complex.&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;Complex is better than complicated.&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这是一个简单的例子，全部打印在一行里。&lt;/div&gt;
&lt;div&gt;想象一下，如果对象中的元素是多层嵌套的内容（例如复杂的 Json 数据），或者有超多的元素（例如在列表中存了很多 URL 链接），再打印出来会是怎样？&lt;/div&gt;
&lt;div&gt;那肯定是一团糟的，不好阅读。&lt;/div&gt;
&lt;div&gt;使用 pprint 模块的 pprint() 替代 print()，可以解决如下痛点：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;设置合适的行宽度，作适当的换行&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设置打印的缩进、层级，进行格式化打印&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;判断对象中是否出现无限循环，并优化打印内容&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;1、简单使用&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;语法：pprint(object, stream=None, indent=1, width=80, depth=None, *,compact=False)&lt;/div&gt;
&lt;div&gt;默认的行宽度参数为 80，当打印的字符（character）小于 80 时，pprint() 基本上等同于内置函数 print()，当字符超出时，它会作美化，进行格式化输出：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; pprint

&lt;span&gt;# 打印上例的 mylist&lt;/span&gt;
pprint&lt;span&gt;.&lt;/span&gt;pprint&lt;span&gt;(&lt;/span&gt;mylist&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 打印的元素是换行的（因为超出80字符）：&lt;/span&gt;
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;Beautiful is better than ugly.&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
 &lt;span&gt;&apos;Explicit is better than implicit.&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
 &lt;span&gt;&apos;Simple is better than complex.&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
 &lt;span&gt;&apos;Complex is better than complicated.&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;2、设置缩进为 4 个空格（默认为1）&lt;/strong&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;pprint&lt;span&gt;.&lt;/span&gt;pprint&lt;span&gt;(&lt;/span&gt;mylist&lt;span&gt;,&lt;/span&gt; indent&lt;span&gt;=&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;[&lt;/span&gt;   &lt;span&gt;&apos;Beautiful is better than ugly.&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    &lt;span&gt;&apos;Explicit is better than implicit.&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    &lt;span&gt;&apos;Simple is better than complex.&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    &lt;span&gt;&apos;Complex is better than complicated.&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;3、设置打印的行宽&lt;/strong&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;mydict &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;students&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&apos;Tom&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;age&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&apos;Jerry&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;age&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

pprint&lt;span&gt;.&lt;/span&gt;pprint&lt;span&gt;(&lt;/span&gt;mydict&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 未超长：&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;students&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;age&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;Tom&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;age&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;Jerry&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

pprint&lt;span&gt;.&lt;/span&gt;pprint&lt;span&gt;(&lt;/span&gt;mydict&lt;span&gt;,&lt;/span&gt; width&lt;span&gt;=&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 超长1：&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;students&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;age&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
               &lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;Tom&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
              &lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;age&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
               &lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;Jerry&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

pprint&lt;span&gt;.&lt;/span&gt;pprint&lt;span&gt;(&lt;/span&gt;mydict&lt;span&gt;,&lt;/span&gt; width&lt;span&gt;=&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 超长2：&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;students&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;age&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;Tom&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
              &lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;age&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;Jerry&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;4、设置打印的层级（默认全打印）&lt;/strong&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;newlist &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

pprint&lt;span&gt;.&lt;/span&gt;pprint&lt;span&gt;(&lt;/span&gt;newlist&lt;span&gt;,&lt;/span&gt; depth&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 超出的层级会用...表示&lt;/span&gt;
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;5、优化循环结构的打印&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;当列表或其它数据结构中出现循环引用时，要完整打印出所有内容是不可能的。&lt;/div&gt;
&lt;div&gt;所以 print 作了简化处理，就像上例一样，只打印外层的壳，而不打印内层循环的东西。&lt;/div&gt;
&lt;div&gt;这种处理方式是简化了，但没有指出是谁导致了循环，还容易看漏。&lt;/div&gt;
&lt;div&gt;pprint() 方法作了改进，遇到无限循环结构时，会表示成&lt;code&gt;&amp;lt;Recursion on typename with id=number&amp;gt;&lt;/code&gt; 的格式。&lt;/div&gt;
&lt;div&gt;还有个 saferepr() 方法，也是这样优化，而且返回的是个字符串：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;newlist &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
newlist&lt;span&gt;.&lt;/span&gt;insert&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; newlist&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 列表元素指向列表自身，造成循环引用&lt;/span&gt;
&lt;span&gt;# 直接 print 的结果是：[[...], 1, 2]&lt;/span&gt;

pprint&lt;span&gt;.&lt;/span&gt;pprint&lt;span&gt;(&lt;/span&gt;newlist&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# [&amp;lt;Recursion on list with id=1741283656456&amp;gt;, 1, 2]&lt;/span&gt;

pprint&lt;span&gt;.&lt;/span&gt;saferepr&lt;span&gt;(&lt;/span&gt;newlist&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# &apos;[&amp;lt;Recursion on list with id=1741283656456&amp;gt;, 1, 2]&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;6、判断是否出现循环结构&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;有两个方法可以判断一个对象中是否出现无限循环：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;pprint&lt;span&gt;.&lt;/span&gt;isrecursive&lt;span&gt;(&lt;/span&gt;newlist&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# True&lt;/span&gt;

pprint&lt;span&gt;.&lt;/span&gt;isreadable&lt;span&gt;(&lt;/span&gt;newlist&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;isreadable() 除了能像 isrecursive() 一样判断循环，还能判断该格式化内容是否可被 eval() 重构。&lt;/div&gt;
&lt;div&gt;以上就是 pprint 模块的快捷入门介绍，除此之外，还有 pformat() 方法、PrettyPrinter 类，以及某些参数的使用等内容，我觉得没有大用，就不多说了。&lt;/div&gt;
&lt;div&gt;如若感兴趣，你可查阅：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;官方介绍：&lt;a href=&quot;https://docs.python.org/zh-cn/3/library/pprint.html&quot;&gt;https://docs.python.org/zh-cn/3/library/pprint.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;源码地址：&lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Lib/pprint.py&quot;&gt;https://github.com/python/cpython/blob/3.7/Lib/pprint.py&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;最后，还有两个小小的点：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;1、用 pprint() 替换 print() 的技巧&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;在不考虑 print() 函数本身的参数的情况下，可以在引入 pprint 模块后，写上 “print = pprint.pprint”，令 print() 起到改头换面的效果：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; pprint
&lt;span&gt;print&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; pprint&lt;span&gt;.&lt;/span&gt;pprint

mylist &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;Beautiful is better than ugly.&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;Explicit is better than implicit.&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;Simple is better than complex.&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;Complex is better than complicated.&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mylist&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 可对比本文开头的例子&lt;/span&gt;
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;Beautiful is better than ugly.&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
 &lt;span&gt;&apos;Explicit is better than implicit.&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
 &lt;span&gt;&apos;Simple is better than complex.&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
 &lt;span&gt;&apos;Complex is better than complicated.&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;2、国人开发的 beeprint&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;国内某位 pan 同学在 Github 开源了个&lt;code&gt;beeprint&lt;/code&gt;，明显是对标 &lt;code&gt;pprint&lt;/code&gt; 的。&lt;/div&gt;
&lt;div&gt;项目地址：&lt;a href=&quot;https://github.com/panyanyany/beeprint&quot;&gt;https://github.com/panyanyany/beeprint&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;它优化了字典对象的打印，对于从其它语言转过来的同学而言（例如 Java），这是个福音：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;它还优化了长文本的打印，支持自定义对象的打印，看起来不错。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;但是，其它功能不够齐全，而且作者停止维护两年了，荒废已久……&lt;/div&gt;
&lt;div&gt;总体而言，pprint 算是 print() 的轻量级替代，简单实用，极其方便（毕竟是标准库），文档丰富而有保障。&lt;/div&gt;
&lt;div&gt;所以，若想要打印美观易读的数据，这个 pprint 标准库，不妨一试哦。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>从 Python 之父的对话聊起，关于知识产权、知识共享与文章翻译</title>
            <link>https://pythoncat.top/posts/2019-08-22-Guido/</link>
            <guid>https://pythoncat.top/posts/2019-08-22-Guido/</guid>
            <description>给 Guido 留言，从一个小误会说起</description>
            <pubDate>Thu, 22 Aug 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;h2&gt;一、缘起&lt;/h2&gt;
&lt;div&gt;前不久，我在翻译 Guido van Rossum（Python之父）的文章时，给他留言，申请非商业用途的翻译授权。&lt;/div&gt;
&lt;div&gt;过程中起了点小误会，略去不表，最终的结果是：他的文章以&lt;code&gt;CC BY-NC-SA 4.0&lt;/code&gt; 许可协议进行授权。部分对话如下：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;CC 协议是一种授权许可协议，我曾看到过几次，但了解不多，所以便查阅了相关的内容。&lt;/div&gt;
&lt;div&gt;本文主要是作个记录，既是加深自己的理解，也给有需要的同学一个参考。&lt;/div&gt;
&lt;h2&gt;二、著作权、著佐权与自由版权&lt;/h2&gt;
&lt;div&gt;对于知识产权，通常有如下几种说法：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;All Rights Reserved（保留所有权利）&lt;/li&gt;
&lt;li&gt;Some Rights Reserved（保留部分权利）&lt;/li&gt;
&lt;li&gt;All Rights Reversed（撤销所有权利）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;注意最后一条的“Reversed”，它长得很像“Reserved”，但意思截然相反。&lt;/div&gt;
&lt;div&gt;它们对权利的诉求由强转弱，从一个极端走向另一个极端。&lt;/div&gt;
&lt;div&gt;有几个与此相关的概念：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;copyright，即版权、著作权&lt;/li&gt;
&lt;li&gt;copyleft，即著作传、著佐权&lt;/li&gt;
&lt;li&gt;copywrong，即反版权、自由版权&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;版权制度起源于十五世纪中期，那时西方发明了铅活字印刷术（古登堡，现代印刷术之父），出现了大量盗版，为了保护出版商的利益，政府出台了版权法。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;此后版权法在世界各地普及，演化出了很多门类，它们普遍限定了一个有效期限，在此期限内，版权方受到垄断保护（即 All Rights &lt;strong&gt;Reserved&lt;/strong&gt; ）。超出期限后，知识作品才会进入公共领域（public domain），才变成自由版权。&lt;/div&gt;
&lt;div&gt;copyright 是一种限制性协议，有利于保护版权方的个体权益，但是也阻碍了知识作品的传播，不利于社会的公共利益。&lt;/div&gt;
&lt;div&gt;我们经常会听到一个词“专利流氓”，说的就是版权被过度使用而造成的社会问题。举个例子，某家商业公司竟然曾“拥有”国旗国徽的版权。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;copyleft 则是一种较为宽松的协议，对应的思想是 Some Rights Reserved（保留部分权利），使用者只要遵守少数的列明条款即可。&lt;/div&gt;
&lt;div&gt;copyleft 之所以会译作“著作&lt;strong&gt;传&lt;/strong&gt; ”，因为有“&lt;strong&gt;减少屏蔽，自由流传&lt;/strong&gt; ”之义。&lt;/div&gt;
&lt;div&gt;另外还翻译为“著&lt;strong&gt;佐&lt;/strong&gt;权”，也是一字之差，跟英文原词神似，非常有趣。&lt;/div&gt;
&lt;div&gt;最后还有一个 copywrong（还有类似的“copyfree”、“copycenter”叫法），它属于另一个极端，无视版权，无拘无束。&lt;/div&gt;
&lt;div&gt;copyleft 与 copywrong 都是对 copyright 的某种矫正，只是矫正的力度不同，总体而言，它们的目的都是促进知识作品的传播，增进整体的社会利益。&lt;/div&gt;
&lt;div&gt;在互联网时代，它们随处可见（可能不直接用这些叫法），极大地促进了自由软件与开源社区的发展。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;上图中的 6 种主流的开源许可证，你应该有所耳闻吧，在我们免费使用的各种软件或代码库中，很可能就藏着它们的身影。&lt;/div&gt;
&lt;div&gt;右侧的 3 种（BSD、MIT、Apache）属于宽松式许可证（permissive license），对使用者几乎没有限制，接近于极端的 All Rights Reversed（撤销所有权利）。&lt;/div&gt;
&lt;div&gt;左侧的 3 种（LGPL、Mozilla、GPL）则属于 copyleft 许可证，仅保留了少数关键的权利，此外不予限制。&lt;/div&gt;
&lt;h2&gt;三、知识共享许可协议&lt;/h2&gt;
&lt;div&gt;经过一段简要的铺垫，几个概念算是讲清楚了，接着看 Python 之父在本文开头所提到的那种许可协议吧。&lt;/div&gt;
&lt;div&gt;CC 也是 copyleft 的一种，全称为 &lt;code&gt;Creative Commons license&lt;/code&gt; ，译作&lt;strong&gt;知识共享许可协议&lt;/strong&gt; ，发布于 2002.12.16，目前已发展到 4.0 版本。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;官网地址：&lt;a href=&quot;https://creativecommons.org/licenses/&quot;&gt;https://creativecommons.org/licenses&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;CC 协议是一个统称，它有不同的实指，区别在于所保留的权利不同。&lt;/div&gt;
&lt;div&gt;它声明的基本权利有 4 种：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;署名（Attribution，简写 BY）：注明原作者&lt;/li&gt;
&lt;li&gt;相同方式共享（ShareAlike，简写 SA）：允许演绎，但需以相同许可协议发布&lt;/li&gt;
&lt;li&gt;非商业性使用（Noncommercial，简写 NC）：不得用于商业目的&lt;/li&gt;
&lt;li&gt;禁止演绎（No Derivative Works，简写 ND）：不得演绎，也作“非衍生”&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;（注：还有一些基本要求，例如，使用者不可添加法律条款或技术手段来限制别人的合理使用。限于篇幅，这些内容就不多介绍了，详见官网。）&lt;/div&gt;
&lt;div&gt;按照是否保留某项权利，它们可以排出 16 种组合，其中 4 种因为同时包含“SA”与“ND”，互斥而无效，还有 5 种不要求署名，基本没人使用。&lt;/div&gt;
&lt;div&gt;所以，只有 7 种常用的 CC 协议：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;上图只列出了 6 种，还有 1 种特殊的是 CC0 协议，它不要求任何权利，是“No Rights Reserved”，无版权要求，属于自由版权。&lt;/div&gt;
&lt;div&gt;这些协议被广泛用于各类互联网产品中（主要是网站、视频、图片或文章），例如：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;CC0：Pexels图片、Unsplash图片、SoundCloud音乐&lt;/li&gt;
&lt;li&gt;CC BY-SA：维基百科内容、Stack Overflow内容&lt;/li&gt;
&lt;li&gt;CC BY-NC-ND：TED 演讲视频&lt;/li&gt;
&lt;li&gt;CC BY-NC-SA：可汗学院视频、斯坦福公开课视频&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;很多个人网站或文章，基本采用了”CC BY-NC-ND”或者”CC BY-NC-SA”之一。Guido 最初给我回复的是 ND 这种，后来才澄清为 SA。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这几种权利中，BY（署名）是不言而喻的，也就是我们常见的“转载时请注明作者和出处”，体现了对于原作者的最起码的尊重。&lt;/div&gt;
&lt;div&gt;另外的 3 种权利，值得再细细地辨析一下：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;SA/ND，是否允许演绎。演绎包括“再混合、转换或基于该作品创作”，基本可概括为不允许改动原作品，而且不允许翻译（这点很关键）&lt;/li&gt;
&lt;li&gt;NC，非商业用途。什么算是商业用途呢？官方笼统地概括为“出于商业利益或金融补偿”的用途，还说这取决于具体情况和使用者的意图&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;四、关于翻译的几个问题&lt;/h2&gt;
&lt;div&gt;本文缘起于翻译，快结束了，我再补充几个跟翻译相关的问题吧，并附上我的理解。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h3&gt;1、翻译别人的文章会导致侵权么？&lt;/h3&gt;
&lt;div&gt;翻译权是著作财产权的一种，属于著作人所有，它的基本含义是：著作权人享有自行翻译其作品和允许他人翻译其作品的权利。所以，未经作者授权或者许可的作品，就不要翻译了，翻译了也不应发布，否则就侵权了。&lt;/div&gt;
&lt;h3&gt;2、CC 协议下的作品可自由翻译么？&lt;/h3&gt;
&lt;div&gt;如果作者许可的是 ND，即禁止演绎，那么，该作品是不允许被翻译的；如果许可的是 SA，即是允许翻译，但注意需“以相同方式共享”，即翻译后的作品需支持他人继续作出演绎；其它情况，对翻译行为不作约束。&lt;/div&gt;
&lt;h3&gt;3、译者对翻译的作品拥有版权么？&lt;/h3&gt;
&lt;div&gt;根据我国《著作权法》第十二条所述：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;改编、翻译、注释、整理已有作品而产生的作品，其著作权由改编、翻译、注释、整理人享有，但行使著作权时不得侵犯原作品的著作权。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;即在不侵犯原作版权的前提下，翻译作品的版权归译者所有。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h3&gt;4、翻译的作品算是原创么？&lt;/h3&gt;
&lt;div&gt;从狭义的概念上看，翻译属于二次创作、属于衍生、其“灵魂”是由原作品所赋予的，所以不能算是原创。原创应指独立创作、全新发明，所以在此含义上看，翻译不算是原创。&lt;/div&gt;
&lt;div&gt;但是，还有一种具体的情境，例如在公众号发文时标注的“原创”，此原创并非是要作概念上的区分，而是要保护作者的版权，防止文章被人侵权转载（甚至是被抢去标注原创），在此情境下，我认为可以标“原创”（有“翻译”标记就更好了）。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;所以，综合来看，翻译作品不是原创，但在特殊情况下，又可以是“原创”。&lt;/strong&gt;&lt;/div&gt;
&lt;h3&gt;5、如何理解非商业用途呢？&lt;/h3&gt;
&lt;div&gt;维基百科对于商业行为概括有 4 个要点：（1）以营利为目的（2）发生交易行为（3）出于双方自愿（4）符合法律规范&lt;/div&gt;
&lt;div&gt;CC 协议所约定的 NC 条款，应参照如上解释。所以，基于 NC 条款许可的翻译作品，不应用于知识付费，也不应用于其它买卖交易，此外，&lt;strong&gt;一般而言，&lt;/strong&gt; 捐助或者赞赏等行为都不算是商业用途，则不受此限制。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>蝉</title>
            <link>https://pythoncat.top/posts/2019-08-15-chan/</link>
            <guid>https://pythoncat.top/posts/2019-08-15-chan/</guid>
            <description>每年夏天，当蝉声响起，我就会想起……</description>
            <pubDate>Thu, 15 Aug 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;（一）&lt;/div&gt;
&lt;div&gt;夏季的晴天里，蝉群在远远的地方发着声。&lt;/div&gt;
&lt;div&gt;声音就是我们知道的蝉的声音，具有辨识度，不会搞错。&lt;/div&gt;
&lt;div&gt;可是，我有时候也会产生怀疑：到底是不是蝉呢？毕竟我没有亲眼看到它们啊。&lt;/div&gt;
&lt;div&gt;姑且说服自己吧，那肯定是蝉。&lt;/div&gt;
&lt;div&gt;但是，新的好奇又被激发了：那些蝉长得什么样子呢？&lt;/div&gt;
&lt;div&gt;大概十几年了，我没有亲眼看见过一只蝉。&lt;/div&gt;
&lt;div&gt;从一座城市到另一座城市，从一个季节到下一个季节。&lt;/div&gt;
&lt;div&gt;似乎有太多的事物需要分散注意力了，所以每年当这种小小的昆虫短暂现身时，我们从未打过照面。&lt;/div&gt;
&lt;div&gt;我总是被它们的鸣叫声吸引，也常常想要亲近它们，然而每次在树底下仰望时，却从没有什么收获。&lt;/div&gt;
&lt;div&gt;更多时候，人还远远没接近呢，树冠中机敏的蝉就静默了，仿佛所有试图接近的人影和声源，都被它们检测出了危险的讯息。&lt;/div&gt;
&lt;div&gt;这些蝉真谨慎啊！&lt;/div&gt;
&lt;div&gt;也许跟生活区域有关吧。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;来苏州已有近五年了，我们住在不同的小区里，但不靠山也不近林，或许小区里稀少的天然绿化就是造成蝉种单一、蝉性谨慎的原因。&lt;/div&gt;
&lt;div&gt;小区内虽然有不少绿植，但极少有蝉踪。小区外的街道旁有成片的树木，那些地方才是蝉类的主要活动场所。&lt;/div&gt;
&lt;div&gt;生活区附近的大部分树木都像是移植的，未经水泥或砖块覆盖的地表并不多，没有多少地方适宜蝉发育和繁衍。&lt;/div&gt;
&lt;div&gt;我怀疑现在听到的大部分蝉，都是移民来的吧。&lt;/div&gt;
&lt;div&gt;它们从某一处故乡上路，顺着路边的绿化带，向东飞，向北飞，飞到这一带时飞倦了，就停下翅，呼朋引伴，打起了成家生育后代的主意。&lt;/div&gt;
&lt;div&gt;（二）&lt;/div&gt;
&lt;div&gt;前不久的某个傍晚时分，我偶然在公司楼下的一棵树上，发现了几个干枯的蝉壳，爬在低矮的树干上，干黄显著。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;童年时与蝉打交道的一幕幕记忆突然变得活跃起来，那时候，我不仅经常能看到蝉，而且还在捕蝉中体会过无穷的乐趣。&lt;/div&gt;
&lt;div&gt;傍晚时分出门，带着一把可能与我同龄的旧式手电筒，来到屋侧的领居家门前的树下，一圈一圈地照着，一棵一棵树地留意着。&lt;/div&gt;
&lt;div&gt;蝉的幼虫总是趁着夜幕偷偷钻出土，爬到一人或两人高的树干上，再脱壳变身。这种时候就是捉（准确地说是捡）它们的极好时机。&lt;/div&gt;
&lt;div&gt;蝉的一生很奇特，幼虫生活在土壤里，可能会花上几年才长成型。&lt;/div&gt;
&lt;div&gt;等软弱的蛹虫长出坚硬的外壳，就破土上树，脱壳蜕变，最后成虫只能活上半个月左右，便全部死亡（某些品种可能会长或短些）。&lt;/div&gt;
&lt;div&gt;它的破壳仪式是那般神圣，连接起漫长的蛰伏期与短暂的活动期，见证着陆地的爬虫变成天空的飞虫。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;童年时的我本能地对这产生了兴趣。&lt;/div&gt;
&lt;div&gt;我和弟弟们把捡回来的蝉虫放在摆电视的桌子上，一边看电视，一边看它们，等待着破壳的时刻。&lt;/div&gt;
&lt;div&gt;我记得看见了蝉壳拱起的背部上裂了一道缝，再等好久，那道缝几乎没有变化，等到夜深电视剧播完了，等到自己太困先去睡了。没有一次成功地目睹过它的蜕变。&lt;/div&gt;
&lt;div&gt;我们把蝉虫钩在白白的蚊帐上，在光滑的竹席上满怀憧憬地睡着了。&lt;/div&gt;
&lt;div&gt;可是第二天基本上都是坏消息：僵死的蝉虫没有成功脱壳，仍挂在蚊帐上或者掉落在床脚下；好像有一只活着可是没抓住，它扑腾着沿着床边掉出蚊帐外，最后飞出门口不见了踪影；有幸抓住了活的，一看却是只哑巴（雌性，不会叫）。&lt;/div&gt;
&lt;div&gt;想要观察破壳的兴趣似乎并不持久，我们更多的乐趣在于捕捉那些树上的蝉。&lt;/div&gt;
&lt;div&gt;怎么捉呢？我们会制作工具。&lt;/div&gt;
&lt;div&gt;我们去找了一根两三米长的细竹竿，再找一段合适的竹篾，围成巴掌大的气球圆插在竹竿的末端上。那时候好像总是不缺竹竿和竹篾，也不记得是什么缘故，所以这两样东西准备得并不难。&lt;/div&gt;
&lt;div&gt;最后还有一样东西是最关键的。记得最早的时候，不知道是谁告诉的方法，我们会带着竹竿去找好多蜘蛛网，然后用竹竿上的竹篾去卷它们，弄出来两面黏黏的网。&lt;/div&gt;
&lt;div&gt;这样造出来的工具，捕蝉时很好用，悄悄贴近蝉的时候，它们基本不会反应过来，一旦拍上了，就能把蝉的翅膀粘上。&lt;/div&gt;
&lt;div&gt;不过也有例外，碰上有的蝉折腾太厉害，蜘蛛网就会被挣破。或者使用得久了粘了树干上的脏东西，它也就不好用了。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;后来，我们才懂得，可以在竹篾上套塑料袋，这样就没有破网或者黏性失效的问题了。&lt;/div&gt;
&lt;div&gt;而使用塑料袋也有学问——最好找浅色的塑料袋，这样不易被觉察，最好找口袋深一点的，这样当蝉落袋时不容易飞跑，但又不能过于臃肿，免得被卡在树杈上。&lt;/div&gt;
&lt;div&gt;有了竹竿的辅助，我们还很难够得着蝉，所以爬树常常是必需的。&lt;/div&gt;
&lt;div&gt;我会爬到树上，循着声音搜索那披着伪装色的蝉，而弟弟就守在树底下，拿着个扎了透气孔的矿泉水瓶，等着装猎物。&lt;/div&gt;
&lt;div&gt;蝉那长长的羽翼，从侧面看是透明的薄纱，闪着阳光，跟灰褐色的树皮反差很大，因此并不难找。&lt;/div&gt;
&lt;div&gt;有的蝉叫得忘乎所以，一抓一个准，还有的则十分狡猾，看似毫无防备，可在网兜快贴近的时候，它倏忽收声，扑索一下，就飞逃走了——还有更可恶的，它会在逃走的时候，射出一泡尿来，令人猝不及防。&lt;/div&gt;
&lt;div&gt;在住宅附近的蝉，身上有浅浅的白色条纹，雄的约有一根大拇指般大小，身下装备着两扇叶绿色的共振片，雌的要小一圈，翘着尖尖的屁股。&lt;/div&gt;
&lt;div&gt;雌蝉尾部可以伸出一种长长的东西，仿佛某些蝴蝶吸取花蜜时探出的舌头。&lt;/div&gt;
&lt;div&gt;年少的我们根据经验区别蝉的性别，总把它们当作公的。然而后来的知识却说，它们是母的。&lt;/div&gt;
&lt;div&gt;蝉是一种昆虫，生长在泥土里，活动在树梢间，鸣叫、进食、交配、死亡，恰好与我们空间交叠，然而我们却对它知之甚少。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;它们孕生在黑暗下，却能适应光亮的世界。&lt;/div&gt;
&lt;div&gt;它们在黑夜的光明里，竟会迷失自己——村里某户人家的门口曾有棵很大的荔枝树，夜里可能有十来只蝉落在上面歌唱，邻居小孩们突然去摇晃那树，总有几只蝉会朝门前大灯上扑。&lt;/div&gt;
&lt;div&gt;自由的蝉只闻其声，不见其影。&lt;/div&gt;
&lt;div&gt;当它们出现在由枝叶搭起的楼宇里的时候，你知道其存在，而当它们更替了，或者彻底不在了的时候，我们却无法确察。&lt;/div&gt;
&lt;div&gt;记得小时候，很多人家养了鸡，散放在外面的树/竹底或草垛下。&lt;/div&gt;
&lt;div&gt;它们是勤劳的清理工，东啄西刨，挖蚯蚓追杀蜈蚣，争抢突然掉到地上的蝉。&lt;/div&gt;
&lt;div&gt;所以，大部分蝉都死得很干脆很干净。&lt;/div&gt;
&lt;div&gt;只有在某个不经意的时刻，我才突然在草垛顶看见过尸体，看见过经受了风雨快要完全被抹去的生命痕迹。&lt;/div&gt;
&lt;div&gt;（三）&lt;/div&gt;
&lt;div&gt;村子附近的蝉似乎只有一种，却带给了我很多有趣味的记忆。&lt;/div&gt;
&lt;div&gt;后来，环境慢慢展开，我走进了一个更加丰富多样的世界。&lt;/div&gt;
&lt;div&gt;我家的门口是一座山，山的后面有更多的山。&lt;/div&gt;
&lt;div&gt;我曾在那些地方扫墓、放牛、砍柴、摘荔枝、采药，以及游玩。&lt;/div&gt;
&lt;div&gt;我在山里见到的第一种蝉很奇特：它仅有半截小拇指大小，细长细长的，长着黑色的翅膀和红色的肚子，就像优雅的绅士的燕尾服包裹着我们吃过的一种软糖。（据查，它的学名就叫“黑翅红蝉”）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;它喜欢待在灌木的新枝嫩叶上，像是在吸取天地精华，像是在瞭望着什么，像是在等待着什么。&lt;/div&gt;
&lt;div&gt;但它的视力和反应能力实在迟钝——只要你够得着，基本就能伸手把它拈来；被抓之后，它也不会剧烈挣扎，反而可能耍起“诈死”的把戏，一动不动，也不知道是装的，还是吓破了胆。&lt;/div&gt;
&lt;div&gt;这种蝉不会叫，似乎没有发声器官，又或者发声器退化了不易观察，我已记不清了。&lt;/div&gt;
&lt;div&gt;还有一种蝉也生活在低矮的灌木丛里，它全身加一起，才有普通人的大拇指的指甲一样大。（由于未查到它的资料，我暂且称之为“小黑叶蝉”）&lt;/div&gt;
&lt;div&gt;与同样生活在灌木丛的黑翅红蝉相比，它的习性恰好相反：红蝉生活在山脚附近，在光秃秃的山路旁也经常能看到，鉴于它的惊艳长相，我想说那是赤裸裸的挑逗；小黑叶蝉则躲在山腰里，在那有高木遮掩、有山厥和野草拦阻的地方，活得像是一群怕被惊扰的隐士。&lt;/div&gt;
&lt;div&gt;这小叶蝉的叫声特别响，与那娇小的身躯完全不匹配，而且它的机敏性也极强，我们弯着腰，悄悄地挪近，借着大叶子的视线掩护，才能提高捕捉的成功率。&lt;/div&gt;
&lt;div&gt;它们喜欢停在绿色的叶片上，但却长着黑褐色的翅膀（肚子也是），跟红蝉一样没有伪装色。&lt;/div&gt;
&lt;div&gt;它们不像红蝉那样软弱，但是却十分脆弱：尽管我们小心地用东西把它们装起来，还摘了树叶“盖房子”，但在回去的路上，它们就死掉了。&lt;/div&gt;
&lt;div&gt;上面的两种蝉都属于飘逸派，一个在形如一个在行，仿佛是侥幸躲过了生存挑战的不谙世事的遗民，正像它们喜欢栖息的新发的嫩叶。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;我在山上还看见过其它几种蝉，在它们身上却有着显著的物竞天择的生物性。&lt;/div&gt;
&lt;div&gt;首先是一种全身绿色的小蝉，跟小黑叶蝉差不多大小，叫声同样嘹响。它们喜欢待在枝干上，不管是高枝还是低枝，而且喜欢群体活动。&lt;/div&gt;
&lt;div&gt;记得有一次，我们在一棵半枯的苦楝树上发现了很多小绿蝉，足足约 20 只，在喧叫、飞舞、交配。我们投掷石子和枯树枝，逮住了好几只掉落而不及逃飞的。&lt;/div&gt;
&lt;div&gt;还有一种绿色的蝉，大拇指大小，背部的少数部位有褐色的斑块，腹部是或多或少的亮白色。它的伪装很成功，在竹林中遇见时，如果不是因为亮耳的叫声出卖，你绝对察觉不到它。&lt;/div&gt;
&lt;div&gt;它没有固定的活动领域，比较少见，可是一旦偶然得见，你一定会被它完美的形象所打动，心痒痒的就只想捉住一只作为玩物——是那种可远观而不可亵渎的赏玩。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;更为难得的是，这种绿蝉中会出现颜色变异——那是一种比较淡的黄橙色，隐约透着点红，我有幸才见过两三次，每次都心生狂喜，燃起少年在异性面前的那种动情。&lt;/div&gt;
&lt;div&gt;绿色无疑是成功的伪装色，而我还见过两种伪装大师，它们另辟蹊径，走的却是暗黑系的路线——因为它们生活在灰褐色的枝干上。&lt;/div&gt;
&lt;div&gt;一种较小的，约是小黑叶蝉的两倍，肚子短小而扁，伏贴在树干上，黑斑背，灰纹翅，总是叫着“giilili~lii”，飞的速度既不快也不慢，恰好能被你欣赏到它飞翔的美。&lt;/div&gt;
&lt;div&gt;另一种蝉比大绿蝉略小，除了翅膀外全身都是深深的黑色，叫声中有一丝嘶哑，却无比响亮，抵得上别的种类的好多只。&lt;/div&gt;
&lt;div&gt;一只黑蝉的独唱，就是一个合唱团，既有着多声叠加的响，还有着多音差的层次感。&lt;/div&gt;
&lt;div&gt;这种蝉是我见过的所有蝉里最谨慎的。&lt;/div&gt;
&lt;div&gt;一般而言，别的蝉在察觉到有异却没有真正危险的时候，都是停下声音缩紧身子，而它一旦觉察有异，基本会毫不犹豫地飞走。&lt;/div&gt;
&lt;div&gt;即使是没有什么扰动，它也是狡兔三窟——在一棵树上叫着一阵，突然飞遁而去，在别处再续前音，仿佛就是一个流动的高音喇叭。&lt;/div&gt;
&lt;div&gt;它的适应性也是最强的，足迹在深山里有、在山脚下有、在老家住宅附近有、在苏州的小区里也有——我没有抓到过它，但是种种迹象表明，它们就是它。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;以上的六种蝉，很具有代表性，不管是形态，还是习性，都丰富多样，尽显出自然造化的神奇。&lt;/div&gt;
&lt;div&gt;非常巧合的是，它们两两之间可以极密切地联系起来，因为具有某种共同的底色，而全部联系起来，则似乎能组成某种和谐的平衡的六边形。&lt;/div&gt;
&lt;div&gt;进入山的世界后，尽管我的捕蝉活动变得单调了，分在每一种蝉上的记忆也浅淡了，但是眼界却因天然物种的丰富，而极大地开阔了，对于自然事物的体悟也更强烈了。&lt;/div&gt;
&lt;div&gt;（四）&lt;/div&gt;
&lt;div&gt;以上所有的蝉，都是直观可辨的蝉，它们的样貌与叫声最符合我对于“蝉”这一概念的理解。&lt;/div&gt;
&lt;div&gt;可是蝉的世界并未到此而止境。&lt;/div&gt;
&lt;div&gt;且不论那些我从未见过的蝉吧，就我的所见，还有几类蝉曾经超越了我的认知，我至今仍不能完全认可它们的身份。&lt;/div&gt;
&lt;div&gt;比如，有几种微小的叶蝉，像是小飞蛾，或像小瓢虫，或像小蚱蜢，不起眼，又不会鸣叫，但它们也是实实在在的蝉科；还有一种沫蝉，只会吐出一团团的白色泡沫；还有竹蝉，只发育到蠕动的蝉蛹形态，躲在嫩竹笋里，排出一坨坨的废渣与粪便。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;我在情感上并不想把它们称作是“蝉”，不管在知识上的物种分类是如何。&lt;/div&gt;
&lt;div&gt;这一群渺小的、发育不全的、形貌可怖的东西，它们挑战了我已成型的认知。&lt;/div&gt;
&lt;div&gt;想要改变一个人的认知，很难，想要改变一个被六边形印章认证过的认知，更难。&lt;/div&gt;
&lt;div&gt;不过，我现在已经不像当初那样纠结了，我承认了它们的身份，还给了自己两个理由。&lt;/div&gt;
&lt;div&gt;理由之一，蝉不是一种狭隘的、僵化的、简单的存在物，既然知道了它的蛰伏、蜕变与短暂飞翔的传奇故事，不妨再接受它所演变出的其它可能性。&lt;/div&gt;
&lt;div&gt;还有一个理由则很现实，它们分享了“蝉”这一名称又如何，它们的故事是否动人又如何，我依然可以爱那最初的所爱、品忆那些纯粹的乐趣，这是无法被剥夺的，也才是真正重要的。&lt;/div&gt;
&lt;div&gt;现在，我长大了客居它乡，已不大可能去做捕蝉这种自然探险的事了，更不需要用它来拓宽自己的自然观了。&lt;/div&gt;
&lt;div&gt;立秋刚过，苏州受到强台风影响，刚下过了大雨，气候渐渐地便要凉快起来了吧。&lt;/div&gt;
&lt;div&gt;也许不须几天，那树上的蝉儿就会没了声影，不知去向，不知这一生的使命完成得如何？&lt;/div&gt;
&lt;div&gt;（注：除蝉壳照片外，文中图片来源于网络）&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 之父的解析器系列之三：生成一个 PEG 解析器</title>
            <link>https://pythoncat.top/posts/2019-08-10-PEG/</link>
            <guid>https://pythoncat.top/posts/2019-08-10-PEG/</guid>
            <pubDate>Sat, 10 Aug 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;原题&lt;/strong&gt; | Generating a PEG Parser&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;作者&lt;/strong&gt; | Guido van Rossum（Python之父）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; | 豌豆花下猫（“Python猫”公众号作者）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;声明&lt;/strong&gt; | 本翻译是出于交流学习的目的，基于 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt; 授权协议。为便于阅读，内容略有改动。&lt;/div&gt;
&lt;div&gt;我已经在&lt;a href=&quot;https://mp.weixin.qq.com/s/yUQPeqc_uSRGe5lUi50kVQ&quot;&gt;本系列第二篇文章&lt;/a&gt;中简述了解析器的基础结构，并展示了一个简单的手写解析器，根据承诺，我们将转向从语法中生成解析器。我还将展示如何使用&lt;code&gt;@memoize&lt;/code&gt;装饰器，以实现packrat 解析。&lt;/div&gt;
&lt;div&gt;【这是 PEG 系列第 3 篇。参见&lt;a href=&quot;https://mp.weixin.qq.com/s/yqVVaZVn8RRanllaXMFD9A&quot;&gt;第1篇&lt;/a&gt;、&lt;a href=&quot;https://mp.weixin.qq.com/s/yUQPeqc_uSRGe5lUi50kVQ&quot;&gt;第2篇&lt;/a&gt; 】&lt;/div&gt;
&lt;div&gt;上篇文章我们以一个手写的解析器结束。给语法加上一些限制的话，我们很容易从语法中自动生成这样的解析器。（我们稍后会解除那些限制。）&lt;/div&gt;
&lt;div&gt;我们需要两个东西：一个东西读取语法，并构造一个表现语法规则的数据结构；还有一个东西则用该数据结构来生成解析器。我们还需要无聊的胶水，我就不提啦。&lt;/div&gt;
&lt;div&gt;所以我们在这创造的是一个简单的编译器编译器（compiler-compiler）。我将语法符号简化了一些，仅保留规则与备选项；这其实对于我在本系列的前面所用的玩具语法来说，已经足够了。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;statement: assignment | expr | if_statement
expr: expr &apos;+&apos; term | expr &apos;-&apos; term | term
term: term &apos;*&apos; atom | term &apos;/&apos; atom | atom
atom: NAME | NUMBER | &apos;(&apos; expr &apos;)&apos;
assignment: target &apos;=&apos; expr
target: NAME
if_statement: &apos;if&apos; expr &apos;:&apos; statement&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;使用完整的符号，我们可以为语法文件写出语法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;grammar: rule+ ENDMARKER
rule: NAME &apos;:&apos; alternative (&apos;|&apos; alternative)* NEWLINE
alternative: item+
item: NAME | STRING&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;用个花哨的叫法，这是我们的第一个元语法（语法的语法），而我们的解析器生成器将是一个元编译器（&lt;strong&gt;编译器是一个程序，将其它程序从一种语言转译为另一种语言；元编译器是一种编译器，其输入是一套语法，而输出是一个解析器&lt;/strong&gt; ）。&lt;/div&gt;
&lt;div&gt;有个简单地表示元语法的方法，主要是使用内置的数据类型：一条规则的右侧只是由一系列的条目组成的列表，且这些条目只能是字符串。（Hack：通过检查第一个字符是否为引号，我们可以区分出&lt;code&gt;NAME&lt;/code&gt;和&lt;code&gt;STRING&lt;/code&gt;）&lt;/div&gt;
&lt;div&gt;至于规则，我用了一个简单的 Rule 类，所以整个语法就是一些 Rule 对象。&lt;/div&gt;
&lt;div&gt;这就是 Rule 类，省略了 &lt;code&gt;__repr__&lt;/code&gt; 与&lt;code&gt;__eq__&lt;/code&gt; ：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Rule&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; name&lt;span&gt;,&lt;/span&gt; alts&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; name
        self&lt;span&gt;.&lt;/span&gt;alts &lt;span&gt;=&lt;/span&gt; alts&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;调用它的是这个&lt;code&gt;GrammarParser&lt;/code&gt;类（关于基类&lt;code&gt;Parser&lt;/code&gt; ，请参阅我之前的帖子）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GrammarParser&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Parser&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;grammar&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        pos &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;mark&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; rule &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;rule&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            rules &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;rule&lt;span&gt;]&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; rule &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;rule&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                rules&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;rule&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expect&lt;span&gt;(&lt;/span&gt;ENDMARKER&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; rules    &lt;span&gt;# &amp;lt;------------- final result&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;reset&lt;span&gt;(&lt;/span&gt;pos&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;rule&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        pos &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;mark&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; name &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expect&lt;span&gt;(&lt;/span&gt;NAME&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expect&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;:&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; alt &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;alternative&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    alts &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;alt&lt;span&gt;]&lt;/span&gt;
                    apos &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;mark&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                    &lt;span&gt;while&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;expect&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;|&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                           &lt;span&gt;and&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;alt &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;alternative&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                        alts&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;alt&lt;span&gt;)&lt;/span&gt;
                        apos &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;mark&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                    self&lt;span&gt;.&lt;/span&gt;reset&lt;span&gt;(&lt;/span&gt;apos&lt;span&gt;)&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expect&lt;span&gt;(&lt;/span&gt;NEWLINE&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt; Rule&lt;span&gt;(&lt;/span&gt;name&lt;span&gt;.&lt;/span&gt;string&lt;span&gt;,&lt;/span&gt; alts&lt;span&gt;)&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;reset&lt;span&gt;(&lt;/span&gt;pos&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;alternative&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        items &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; item &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;item&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            items&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;item&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; items
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;item&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; name &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expect&lt;span&gt;(&lt;/span&gt;NAME&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; name&lt;span&gt;.&lt;/span&gt;string
        &lt;span&gt;if&lt;/span&gt; string &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expect&lt;span&gt;(&lt;/span&gt;STRING&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; string&lt;span&gt;.&lt;/span&gt;string
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;注意 &lt;code&gt;ENDMARKER&lt;/code&gt; ，它用来确保在最后一条规则后没有遗漏任何东西（如果语法中出现拼写错误，可能会导致这种情况）。&lt;/div&gt;
&lt;div&gt;我放了一个简单的箭头，指向了 grammar() 方法的返回值位置，返回结果是一个存储 Rule 的列表。&lt;/div&gt;
&lt;div&gt;其余部分跟上篇文章中的 &lt;code&gt;ToyParser&lt;/code&gt; 类很相似，所以我不作解释。&lt;/div&gt;
&lt;div&gt;只需留意，item() 返回一个字符串，alternative() 返回一个字符串列表，而 rule() 中的 alts 变量，则是一个由字符串列表组成的列表。&lt;/div&gt;
&lt;div&gt;然后，rule() 方法将规则名称（一个字符串）与 alts 结合，放入 Rule 对象。&lt;/div&gt;
&lt;div&gt;如果把这份代码用到包含了我们的玩具语法的文件上，则 grammar() 方法会返回以下的由 Rule 对象组成的列表：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;[&lt;/span&gt;
  Rule&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;statement&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;assignment&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;expr&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;if_statement&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
  Rule&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;expr&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;term&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;&apos;+&apos;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;expr&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
                &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;term&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;&apos;-&apos;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;term&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
                &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;term&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
  Rule&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;term&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;atom&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;&apos;*&apos;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;term&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
                &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;atom&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;&apos;/&apos;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;atom&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
                &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;atom&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
  Rule&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;atom&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;NAME&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;NUMBER&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;&apos;(&apos;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;expr&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;&apos;)&apos;&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
  Rule&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;assignment&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;target&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;&apos;=&apos;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;expr&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
  Rule&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;target&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;NAME&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
  Rule&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;if_statement&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;&apos;if&apos;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;expr&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;&apos;:&apos;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;statement&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;既然我们已经有了元编译器的解析部分，那就创建代码生成器吧。&lt;/div&gt;
&lt;div&gt;把这些聚合起来，就形成了一个基本的元编译器：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;generate_parser_class&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;rules&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;class ToyParser(Parser):&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; rule &lt;span&gt;in&lt;/span&gt; rules&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;    @memoize&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;    def &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;rule&lt;span&gt;.&lt;/span&gt;name&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(self):&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;        pos = self.mark()&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; alt &lt;span&gt;in&lt;/span&gt; rule&lt;span&gt;.&lt;/span&gt;alts&lt;span&gt;:&lt;/span&gt;
            items &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;        if (True&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; alt&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; item&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;&quot;&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;&apos;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;            and self.expect(&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;item&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    var &lt;span&gt;=&lt;/span&gt; item&lt;span&gt;.&lt;/span&gt;lower&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; var &lt;span&gt;in&lt;/span&gt; items&lt;span&gt;:&lt;/span&gt;
                        var &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;items&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                    items&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;var&lt;span&gt;)&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; item&lt;span&gt;.&lt;/span&gt;isupper&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;            &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;
                              &lt;span&gt;&lt;span&gt;f&quot;and (&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;var&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt; := self.expect(&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;item&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;))&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;            &quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;
                              &lt;span&gt;&lt;span&gt;f&quot;and (&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;var&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt; := self.&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;item&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;())&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;        ):&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;            &quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;
              &lt;span&gt;&lt;span&gt;f&quot;return Node(&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;rule&lt;span&gt;.&lt;/span&gt;name&lt;span&gt;!r&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;, [&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;, &apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;join&lt;span&gt;(&lt;/span&gt;items&lt;span&gt;)&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;])&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;        self.reset(pos)&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;        return None&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这段代码非常难看，但它管用（某种程度上），不管怎样，我打算将来重写它。&lt;/div&gt;
&lt;div&gt;在”for alt in rule.alts”循环中，有些代码细节可能需要作出解释：对于备选项中的每个条目，我们有三种选择的可能：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;如果该条目是字符串字面量，例如&lt;code&gt;&apos;+&apos;&lt;/code&gt; ，我们生成&lt;code&gt;self.expect(&apos;+&apos;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果该条目全部是大写，例如&lt;code&gt;NAME&lt;/code&gt; ，我们生成&lt;code&gt;(name := self.expect(NAME))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其它情况，例如该条目是&lt;code&gt;expr&lt;/code&gt;，我们生成 &lt;code&gt;(expr := self.expr())&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;如果在单个备选项中出现多个相同名称的条目（例如&lt;code&gt;term &apos;-&apos; term&lt;/code&gt;），我们会在第二个条目后附加一个数字。这里还有个小小的 bug，我会在以后的内容中修复。&lt;/div&gt;
&lt;div&gt;这只是它的一部分输出（完整的类非常无聊）。不用担心那些零散的、冗长的 &lt;code&gt;if (True and … )&lt;/code&gt; 语句，我使用它们，以便每个生成的条件都能够以&lt;code&gt;and&lt;/code&gt; 开头。Python 的字节码编译器会优化它。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ToyParser&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Parser&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;@memoize&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;statement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        pos &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;mark&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
            &lt;span&gt;and&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;assignment &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;assignment&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; Node&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;statement&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;assignment&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;reset&lt;span&gt;(&lt;/span&gt;pos&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
            &lt;span&gt;and&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;expr &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expr&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; Node&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;statement&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;expr&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;reset&lt;span&gt;(&lt;/span&gt;pos&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
            &lt;span&gt;and&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;if_statement &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;if_statement&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; Node&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;statement&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;if_statement&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;reset&lt;span&gt;(&lt;/span&gt;pos&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;注意&lt;code&gt;@memoize&lt;/code&gt; 装饰器：我“偷运”（smuggle）它进来，以便转向另一个主题：使用记忆法（memoization）来加速生成的解析器。&lt;/div&gt;
&lt;div&gt;这是实现该装饰器的 memoize() 函数：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;memoize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;func&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;memoize_wrapper&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;args&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        pos &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;mark&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        memo &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;memos&lt;span&gt;.&lt;/span&gt;get&lt;span&gt;(&lt;/span&gt;pos&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; memo &lt;span&gt;is&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            memo &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;memos&lt;span&gt;[&lt;/span&gt;pos&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
        key &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;func&lt;span&gt;,&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt; memo&lt;span&gt;:&lt;/span&gt;
            res&lt;span&gt;,&lt;/span&gt; endpos &lt;span&gt;=&lt;/span&gt; memo&lt;span&gt;[&lt;/span&gt;key&lt;span&gt;]&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;reset&lt;span&gt;(&lt;/span&gt;endpos&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            res &lt;span&gt;=&lt;/span&gt; func&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;args&lt;span&gt;)&lt;/span&gt;
            endpos &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;mark&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
            memo&lt;span&gt;[&lt;/span&gt;key&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; res&lt;span&gt;,&lt;/span&gt; endpos
        &lt;span&gt;return&lt;/span&gt; res
&lt;span&gt;return&lt;/span&gt; memoize_wrapper&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;对于典型的装饰器来说，它的嵌套函数（nested function）会替换（或包装）被装饰的函数（decorated function），例如 memoize_wrapper() 会包装 ToyParser 类的 statement() 方法。&lt;/div&gt;
&lt;div&gt;因为被包装的函数（wrapped function）是一个方法，所以包装器实际上也是一个方法：它的第一个参数是 &lt;code&gt;self&lt;/code&gt; ，指向 ToyParser 实例，后者会调用被装饰的函数。&lt;/div&gt;
&lt;div&gt;包装器会缓存每次调用解析方法后的结果——这就是为什么它会被称为“口袋老鼠解析”（packrat parsing）！&lt;/div&gt;
&lt;div&gt;这缓存是一个字典，元素是存储在 Parser 实例上的那些字典。&lt;/div&gt;
&lt;div&gt;外部字典的 key 是输入的位置；我将 &lt;code&gt;self.memos = {}&lt;/code&gt; 添加到 &lt;code&gt;Parser.__init__()&lt;/code&gt; ，以初始化它。&lt;/div&gt;
&lt;div&gt;内部字典按需添加，它们的 key 由方法及其参数组成。（在当前的设计中没有参数，但我们应该记得 expect()，它恰好有一个参数，而且给它新增通用性，几乎不需要成本。 ）&lt;/div&gt;
&lt;div&gt;一个解析方法的结果被表示成一个元组，因为它正好有两个结果：一个显式的返回值（对于我们生成的解析器，它是一个 Node，表示所匹配的规则），以及我们从 &lt;code&gt;self.mark()&lt;/code&gt; 中获得的一个新的输入位置。&lt;/div&gt;
&lt;div&gt;在调用解析方法后，我们会在内部的记忆字典中同时存储它的返回值（res）以及新的输入位置（endpos）。&lt;/div&gt;
&lt;div&gt;再次调用相同的解析方法时（在相同的位置，使用相同的参数），我们会从缓存中取出那两个结果，并用 &lt;code&gt;self.reset()&lt;/code&gt; 来向前移动输入位置，最后返回那缓存中的返回值。&lt;/div&gt;
&lt;div&gt;缓存负数的结果也很重要——实际上大多数对解析方法的调用都是负数的结果。在此情况下，返回值为 None，而输入位置不会变。你可以加一个&lt;code&gt;assert&lt;/code&gt; 断言来检查它。&lt;/div&gt;
&lt;div&gt;注意：Python 中常用的记忆法是在 memoize() 函数中将缓存定义成一个局部变量。但我们不这么做：因为我在一个最后时刻的调试会话中发现，每个 Parser 实例都必须拥有自己的缓存。然而，你可以用&lt;code&gt;(pos, func, args)&lt;/code&gt; 作为 key，以摆脱嵌套字典的设计。&lt;/div&gt;
&lt;div&gt;下周我将统览代码，演示在解析示例程序时，所有这些模块实际是如何配合工作的。&lt;/div&gt;
&lt;div&gt;我仍然在抓头发中（译注：极度发愁），如何以最佳的方式将协同工作的标记生成器缓冲、解析器和记忆缓存作出可视化。或许我会设法生成动画的 ASCII 作品，而不仅仅是跟踪日志的输出。（译注：感觉他像是在开玩笑，但很难译出这句话的原味。建议阅读原文。）&lt;/div&gt;
&lt;div&gt;本文及示例代码的授权协议： &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;英文原文：&lt;/strong&gt; &lt;a href=&quot;https://medium.com/@gvanrossum_83706/generating-a-peg-parser-520057d642a9&quot;&gt;https://medium.com/@gvanrossum_83706/generating-a-peg-parser-520057d642a9&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;作者简介：&lt;/strong&gt; Guido van Rossum，是 Python 的创造者，一直是“终身仁慈独裁者”，直到2018年7月12日退位。目前，他是新的最高决策层的五位成员之一，依然活跃在社区中。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者简介：&lt;/strong&gt; 豌豆花下猫，生于广东毕业于武大，现为苏漂程序员，有一些极客思维，也有一些人文情怀，有一些温度，还有一些态度。公众号：「Python猫」（python_cat）。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;公众号【&lt;strong&gt;Python猫&lt;/strong&gt;】， 本号连载优质的系列文章，有喵星哲学猫系列、Python进阶系列、好书推荐系列、技术写作、优质英文推荐与翻译等等，欢迎关注哦。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 之父再发文：构建一个 PEG 解析器</title>
            <link>https://pythoncat.top/posts/2019-08-03-PEG/</link>
            <guid>https://pythoncat.top/posts/2019-08-03-PEG/</guid>
            <pubDate>Sat, 03 Aug 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 之父在 Medium 上开了博客，现在写了两篇文章，本文是第二篇的译文。前一篇的译文 &lt;a href=&quot;https://mp.weixin.qq.com/s/yqVVaZVn8RRanllaXMFD9A&quot;&gt;在此&lt;/a&gt; ，宣布了将要用 PEG 解析器来替换当前的 pgen 解析器。&lt;/div&gt;
&lt;div&gt;本文主要介绍了构建一个 PEG 解析器的大体思路，并介绍了一些基本的语法规则。根据 Python 之父的描述，这个 PEG 解析器还是一个很笼统的实验品，而他也预告了，将会在以后的系列文章中丰富这个解析器。&lt;/div&gt;
&lt;div&gt;阅读这篇文章就像在读一篇教程，虽然很难看懂，但是感觉很奇妙：我们竟然可以见证 Python 之父如何考虑问题、如何作设计、如何一点一点地丰富功能、并且传授出来。这种机会非常难得啊！&lt;/div&gt;
&lt;div&gt;我会持续跟进后续文章的翻译，由于能力有限，可能翻译中有不到位之处，恳请读者们批评指正。&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;&lt;strong&gt;原题&lt;/strong&gt; | Building a PEG Parser&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;作者&lt;/strong&gt; | Guido van Rossum（Python之父）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; | 豌豆花下猫（“Python猫”公众号作者）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;原文&lt;/strong&gt; | &lt;a href=&quot;https://medium.com/@gvanrossum_83706/building-a-peg-parser-d4869b5958fb&quot;&gt;https://medium.com/@gvanrossum_83706/building-a-peg-parser-d4869b5958fb&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;声明&lt;/strong&gt; | 翻译是出于交流学习的目的，欢迎转载，但请保留本文出处，请勿用于商业或非法用途。&lt;/div&gt;
&lt;div&gt;仅仅理解了 PEG 解析器的小部分，我就受到了启发，决定自己构建一个。结果可能不是一个很棒的通用型的 PEG 解析器生成器——这类生成器已经有很多了（例如 TatSu，写于 Python，生成 Python 代码）——但这是一个学习 PEG 的好办法，推进了我的目标，即用由 PEG 语法构建的解析器替换 CPython 的解析器。&lt;/div&gt;
&lt;div&gt;在本文中，&lt;strong&gt;通过展示一个简单的手写解析器，我为如何理解解析器的工作原理奠定了基础。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;（顺便说一句，作为一个实验，我不会在文中到处放参考链接。如果你有什么不明白的东西，请 Google 之 :-）&lt;/div&gt;
&lt;div&gt;最常见的 PEG 解析方式是使用可以无限回溯的递归下降解析器。&lt;/div&gt;
&lt;div&gt;以上周文章中的玩具语言为例：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;statement: assignment | expr | if_statement
expr: expr &apos;+&apos; term | expr &apos;-&apos; term | term
term: term &apos;*&apos; atom | term &apos;/&apos; atom | atom
atom: NAME | NUMBER | &apos;(&apos; expr &apos;)&apos;
assignment: target &apos;=&apos; expr
target: NAME
if_statement: &apos;if&apos; expr &apos;:&apos; statement&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这种语言中超级抽象的递归下降解析器将为每个符号定义一个函数，该函数会尝试调用与备选项相对应的函数。&lt;/div&gt;
&lt;div&gt;例如，对于&lt;code&gt;statement&lt;/code&gt;，我们有如下函数：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;statement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; assignment&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
   &lt;span&gt;if&lt;/span&gt; expr&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; if_statement&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;当然这是极其简化的版本：没有考虑解析器中必要的输入及输出。&lt;/div&gt;
&lt;div&gt;我们就从输入端开始讲吧。&lt;/div&gt;
&lt;div&gt;经典解析器使用单独的标记生成器，来将输入（文本文件或字符串）分解成一系列的标记，例如关键字、标识符（名称）、数字与运算符。&lt;/div&gt;
&lt;div&gt;（译注：标记生成器，即 tokenizer，用于生成标记 token。以下简称为“标记器”）&lt;/div&gt;
&lt;div&gt;PEG 解析器（像其它现代解析器，如 ANTLR）通常会把标记与解析过程统一。但是对于我的项目，我选择保留单独的标记器。&lt;/div&gt;
&lt;div&gt;对 Python 做标记太复杂了，我不想拘泥于 PEG 的形式来重新实现。&lt;/div&gt;
&lt;div&gt;例如，你必须得记录缩进（这需要在标记器内使用堆栈），而且在 Python 中处理换行很有趣（它们很重要，除了在匹配的括号内）。字符串的多种引号也会增加复杂性。&lt;/div&gt;
&lt;div&gt;简而言之，我不抱怨 Python 现有的标记器，所以我想保留它。（CPython 有两个标记器，一个是解析器在内部使用的，写于 C，另一个在标准库中，用纯 Python 重写。它对我的项目很有帮助。）&lt;/div&gt;
&lt;div&gt;经典的标记器通常具有一个简单的接口，供你作函数调用，例如 &lt;code&gt;get_token()&lt;/code&gt; ，它返回输入内容中的下一个标记，每次消费掉几个字符。&lt;/div&gt;
&lt;div&gt;&lt;code&gt;tokenize&lt;/code&gt; 模块对它作了进一步简化：它的基础 API 是一个生成器，每次生成（yield）一个标记。&lt;/div&gt;
&lt;div&gt;每个标记都是一个 &lt;code&gt;TypeInfo&lt;/code&gt; 对象，它有几个字段，其中最重要之一表示的是标记的类型（例如 &lt;code&gt;NAME&lt;/code&gt; 、&lt;code&gt;NUMBER&lt;/code&gt; 、&lt;code&gt;STRING&lt;/code&gt;），还有一个很重要的是字符串值，表示该标记所包含的字符（例如 &lt;code&gt;abc&lt;/code&gt; 、&lt;code&gt;42&lt;/code&gt; 或者 &lt;code&gt;&quot;hello world&quot;&lt;/code&gt;）。还有的字段会指明每个标记出现在输入文件中的坐标，这对于报告错误很有用。&lt;/div&gt;
&lt;div&gt;有一个特殊的标记类型是 &lt;code&gt;ENDMARKER&lt;/code&gt; ，它表示的是抵达了输入文件的末尾。如果你忽略它，并尝试获取下一个标记，则生成器会终结。&lt;/div&gt;
&lt;div&gt;离题了，回归正题。&lt;strong&gt;我们如何实现无限回溯呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;回溯要求你能记住源码中的位置，并且能够从该处重新解析。标记器的 API 不允许我们重置它的输入指针，但相对容易的是，将标记流装入一个数组中，并在那里做指针重置，所以我们就这样做。（你同样可以使用 &lt;code&gt;itertools.tee()&lt;/code&gt; 来做，但是根据文档中的警告，在我们这种情况下，效率可能较低。）&lt;/div&gt;
&lt;div&gt;我猜你可能会先将整个输入内容标记到一个 Python 列表里，将其作为解析器的输入，但这意味着如果在文件末尾处存在着无效的标记（例如一个字符串缺少结束的引号），而在文件前面还有语法错误，那你首先会收到的是关于标记错误的信息。&lt;/div&gt;
&lt;div&gt;我觉得这是种糟糕的用户体验，因为这个语法错误有可能是导致字符串残缺的根本原因。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;所以我的设计是按需标记，所用的列表是惰性列表。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;基础 API 非常简单。&lt;code&gt;Tokenizer&lt;/code&gt; 对象封装了一个数组，存放标记及其位置信息。&lt;/div&gt;
&lt;div&gt;它有三个基本方法：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;get_token()&lt;/code&gt; 返回下一个标记，并推进数组的索引（如果到了数组末尾，则从源码中读取另一个标记）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mark()&lt;/code&gt; 返回数组的当前索引&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reset(pos)&lt;/code&gt; 设置数组的索引（参数必须从 mark() 方法中得到）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;我们再补充一个便利方法 &lt;code&gt;peek_token()&lt;/code&gt; ，它返回下一个标记且不推进索引。&lt;/div&gt;
&lt;div&gt;然后，这就成了 Tokenizer 类的核心代码：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Tokenizer&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; tokengen&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;&quot;&quot;&quot;Call with tokenize.generate_tokens(...).&quot;&quot;&quot;&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;tokengen &lt;span&gt;=&lt;/span&gt; tokengen
        self&lt;span&gt;.&lt;/span&gt;tokens &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;pos &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;mark&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;pos
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;reset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; pos&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;pos &lt;span&gt;=&lt;/span&gt; pos
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;get_token&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        token &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;peek_token&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;pos &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; token
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;peek_token&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;pos &lt;span&gt;==&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;tokens&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;tokens&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;tokengen&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;tokens&lt;span&gt;[&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;pos&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;现在，仍然缺失着很多东西（而且方法和实例变量的名称应该以下划线开头），但这作为 Tokenizer API 的初稿已经够了。&lt;/div&gt;
&lt;div&gt;解析器也需要变成一个类，以便可以拥有 statement()、expr() 和其它方法。&lt;/div&gt;
&lt;div&gt;标记器则变成一个实例变量，不过我们不希望解析方法（parsing methods）直接调用 get_token()——相反，我们给 &lt;code&gt;Parser&lt;/code&gt; 类一个 &lt;code&gt;expect()&lt;/code&gt; 方法，它可以像解析类方法一样，表示执行成功或失败。&lt;/div&gt;
&lt;div&gt;&lt;code&gt;expect()&lt;/code&gt; 的参数是一个预期的标记——一个字符串（像“+”）或者一个标记类型（像&lt;code&gt;NAME&lt;/code&gt;）。&lt;/div&gt;
&lt;div&gt;讨论完了解析器的输出，我继续讲返回类型（return type）。&lt;/div&gt;
&lt;div&gt;在我初稿的解析器中，解析函数只返回 True 或 False。那对于理论计算机科学来说是好的（解析器要解答的那类问题是“语言中的这个是否是有效的字符串？”），但是对于构建解析器却不是——相反，我们希望用解析器来创建一个 AST。&lt;/div&gt;
&lt;div&gt;所以我们就这么办，即让每个解析方法在成功时返回 &lt;code&gt;Node&lt;/code&gt; 对象，在失败时返回 &lt;code&gt;None&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;该 &lt;code&gt;Node&lt;/code&gt; 类可以超级简单：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; children&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;children &lt;span&gt;=&lt;/span&gt; children&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在这里，type 表示了该 AST 节点是什么类型（例如是个“add”节点或者“if”节点），children 表示了一些节点和标记（TokenInfo 类的实例）。&lt;/div&gt;
&lt;div&gt;尽管将来我可能会改变表示 AST 的方式，但这足以让编译器生成代码或对其作分析了，例如 linting （译注：不懂）或者是静态类型检查。&lt;/div&gt;
&lt;div&gt;为了适应这个方案，expect() 方法在成功时会返回一个 TokenInfo 对象，在失败时返回 None。为了支持回溯，我还封装了标记器的 mark() 和 reset() 方法（不改变 API）。&lt;/div&gt;
&lt;div&gt;这是 Parser 类的基础结构：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Parser&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; tokenizer&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;tokenizer &lt;span&gt;=&lt;/span&gt; tokenizer
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;mark&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;tokenizer&lt;span&gt;.&lt;/span&gt;mark&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;reset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; pos&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;tokenizer&lt;span&gt;.&lt;/span&gt;reset&lt;span&gt;(&lt;/span&gt;pos&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;expect&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; arg&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        token &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;tokenizer&lt;span&gt;.&lt;/span&gt;peek_token&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; token&lt;span&gt;.&lt;/span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; arg &lt;span&gt;or&lt;/span&gt; token&lt;span&gt;.&lt;/span&gt;string &lt;span&gt;==&lt;/span&gt; arg&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;tokenizer&lt;span&gt;.&lt;/span&gt;get_token&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;同样地，我放弃了某些细节，但它可以工作。&lt;/div&gt;
&lt;div&gt;在这里，我有必要介绍解析方法的一个重要的需求：一个解析方法要么返回一个 Node，并将标记器定位到它能识别的语法规则的最后一个标记之后；要么返回 None，然后保持标记器的位置不变。&lt;/div&gt;
&lt;div&gt;如果解析方法在读取了多个标记之后失败了，则它必须重置标记器的位置。这就是 mark() 与 reset() 的用途。请注意，expect() 也遵循此规则。&lt;/div&gt;
&lt;div&gt;所以解析器的实际草稿如下。请注意，我使用了 Python 3.8 的海象运算符（:=）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ToyParser&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Parser&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;statement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; a &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;assignment&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; a
        &lt;span&gt;if&lt;/span&gt; e &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expr&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; e
        &lt;span&gt;if&lt;/span&gt; i &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;if_statement&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; i
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;expr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; t &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;term&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            pos &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;mark&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; op &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expect&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;+&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; e &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expr&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; Node&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;add&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;t&lt;span&gt;,&lt;/span&gt; e&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;reset&lt;span&gt;(&lt;/span&gt;pos&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; op &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expect&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;-&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; e &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expr&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; Node&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;sub&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;t&lt;span&gt;,&lt;/span&gt; e&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;reset&lt;span&gt;(&lt;/span&gt;pos&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; t
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;term&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;# Very similar...&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;atom&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; token &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expect&lt;span&gt;(&lt;/span&gt;NAME&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; token
        &lt;span&gt;if&lt;/span&gt; token &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expect&lt;span&gt;(&lt;/span&gt;NUMBER&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; token
        pos &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;mark&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expect&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;(&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; e &lt;span&gt;:=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expr&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expect&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;)&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; e
        self&lt;span&gt;.&lt;/span&gt;reset&lt;span&gt;(&lt;/span&gt;pos&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我给读者们留了一些解析方法作为练习（这实际上不仅仅是为了介绍解析器长什么样子），最终我们将像这样从语法中自动地生成代码。&lt;/div&gt;
&lt;div&gt;NAME 和 NUMBER 等常量可从标准库的 &lt;code&gt;token&lt;/code&gt; 库中导入。（这能令我们快速地进入 Python 的标记过程；但如果想要构建一个更加通用的 PEG 解析器，则应该探索一些其它方法。）&lt;/div&gt;
&lt;div&gt;我还作了个小弊：&lt;code&gt;expr&lt;/code&gt; 是左递归的，但我的解析器用了右递归，因为递归下降解析器不适用于左递归的语法规则。&lt;/div&gt;
&lt;div&gt;有一个解决方案，但它还只是一些学术研究上的课题，我想以后单独介绍它。你们只需知道，修复的版本与这个玩具语法并非 100% 相符。&lt;/div&gt;
&lt;div&gt;**我希望你们得到的关键信息是： **&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;语法规则相当于解析器方法，当一条语法规则引用另一条语法规则时，它的解析方法会调用另一条规则的解析方法&lt;/li&gt;
&lt;li&gt;当多个条目构成备选项时，解析方法会一个接一个地调用相应的方法&lt;/li&gt;
&lt;li&gt;当一条语法规则引用一个标记时，其解析方法会调用 expect()&lt;/li&gt;
&lt;li&gt;当一个解析方法在给定的输入位置成功地识别了它的语法规则时，它返回相应的 AST 节点；当识别失败时，它返回 None&lt;/li&gt;
&lt;li&gt;一个解析方法在消费（consum）一个或多个标记（直接或间接地，通过调用另一个成功的解析方法）后放弃解析时，必须显式地重置标记器的位置。这适用于放弃一个备选项而尝试下一个，也适用于完全地放弃解析&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;如果所有的解析方法都遵守这些规则，则不必在单个解析方法中使用 mark() 和 reset()。你可以用归纳法证明这一点。&lt;/div&gt;
&lt;div&gt;顺便提醒，虽然使用上下文管理器和 with 语句来替代显式地调用 mark() 与 reset() 很有诱惑力，但这不管用：在成功时不应调用 reset()！&lt;/div&gt;
&lt;div&gt;为了修复它，你可以在控制流中使用异常，这样上下文管理器就知道是否该重置标记器（我认为 TatSu 做了类似的东西）。&lt;/div&gt;
&lt;div&gt;举例，你可以这样做：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;statement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;with&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;alt&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;assignment&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;with&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;alt&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expr&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;with&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;alt&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;if_statement&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;raise&lt;/span&gt; ParsingFailure&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;特别地，&lt;code&gt;atom()&lt;/code&gt; 中用来识别带括号的表达式的 if-语句，可以变成：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;        &lt;span&gt;with&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;alt&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;expect&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;(&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
            e &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;expr&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;expect&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;)&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; e&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;但我发现这太“神奇”了——在阅读这些代码时，你必须清醒地意识到每个解析方法（以及 expect()）都可能会引发异常，而这个异常会被 with 语句的上下文管理器捕获并忽略掉。&lt;/div&gt;
&lt;div&gt;这相当不寻常，尽管肯定会支持（通过从 __exit__ 返回 true）。&lt;/div&gt;
&lt;div&gt;还有，我的最终目标是生成 C，不是 Python，而在 C 里，没有 with 语句来改变控制流。&lt;/div&gt;
&lt;div&gt;不管怎样，下面是未来的一些主题：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;根据语法生成解析代码&lt;/li&gt;
&lt;li&gt;packrat 解析（记忆法）&lt;/li&gt;
&lt;li&gt;EBNF 的特性，如(x | y)、[x y …]、x* 、x+&lt;/li&gt;
&lt;li&gt;tracing （用于调试解析器或语法）&lt;/li&gt;
&lt;li&gt;PEG 特性，如前瞻和“切割”&lt;/li&gt;
&lt;li&gt;如何处理左递归规则&lt;/li&gt;
&lt;li&gt;生成 C 代码&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;1、&lt;a href=&quot;https://mp.weixin.qq.com/s/yqVVaZVn8RRanllaXMFD9A&quot;&gt;PEG解析器（考虑替换现有解析器）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://mp.weixin.qq.com/s/ovIiw7ZmXJM4qUSTGDk7kQ&quot;&gt;pgen解析器（现有解析器的由来）&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 之父撰文回忆：为什么要创造 pgen 解析器？</title>
            <link>https://pythoncat.top/posts/2019-07-29-pgen/</link>
            <guid>https://pythoncat.top/posts/2019-07-29-pgen/</guid>
            <pubDate>Mon, 29 Jul 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;近日，Python 之父在 Medium 上开通了博客，并发布了一篇关于 PEG 解析器的文章（参见我翻的 &lt;a href=&quot;https://mp.weixin.qq.com/s/yqVVaZVn8RRanllaXMFD9A&quot;&gt;全文译文&lt;/a&gt;）。据我所知，他有自己的博客，为什么还会跑去 Medium 上写文呢？好奇之下，我就打开了他的老博客。&lt;/div&gt;
&lt;div&gt;最后一篇文章写于 2018 年 5 月，好巧不巧，写的竟是 pgen 解析器，正是他在新文中无情地吐槽的、说将要替换掉的 pgen 。在这篇旧文里，Guido 回忆了他创造 pgen 时的一些考量，在当时看来，创造一个新的解析器无疑是明智的，只不过时过境迁，现在有了更好的选择罢了。&lt;/div&gt;
&lt;div&gt;前不久，我们聊过 Python 中 &lt;a href=&quot;https://mp.weixin.qq.com/s/8KvQemz0SWq2hw-2aBPv2Q&quot;&gt;GIL 的移除计划&lt;/a&gt;、&lt;a href=&quot;https://mp.weixin.qq.com/s/XzCqoCvcpFJt4A-E4WMqaA&quot;&gt;内置电池的“手术”计划&lt;/a&gt; 以及 &lt;a href=&quot;https://mp.weixin.qq.com/s/NuzfuH_zCZzcrmSFR04NHw&quot;&gt;print 的演变故事&lt;/a&gt;，如今，它的解析器也要迎来改造了。Python 这门语言快 30 岁了，还难得地保持着活力四射。就让我们一起祝福它吧，愿未来更加美好。&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;&lt;strong&gt;作者&lt;/strong&gt; | Guido van Rossum（Python之父）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; | 豌豆花下猫（“Python猫”公众号作者）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;原文&lt;/strong&gt; | &lt;a href=&quot;https://python-history.blogspot.com/2018/05/the-origins-of-pgen.html&quot;&gt;The origins of pgen&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;声明&lt;/strong&gt; | 翻译是出于交流学习的目的，欢迎转载，但请保留本文出处，请勿用于商业或非法用途。&lt;/div&gt;
&lt;div&gt;David Beazley 在 US PyCon 2018 上的演讲，关于语法分析生成器（parser generators），提醒了我应该写一下关于它的历史。这是一个简短的脑转储（也许我今后会解释它）。&lt;/div&gt;
&lt;div&gt;（译注：我大胆揣测一下“脑转储”吧，应该说的是，把个人的记忆以及 Python 的历史细节，转化成文字，这是个存储固化的过程，方便传承。而我做的翻译工作，就是把这份文档财富，普及给更多的 Python 爱好者。）&lt;/div&gt;
&lt;div&gt;实际上，&lt;strong&gt;有两个 pgen，一个是最初的，用 C 语言写的，还有一个则是用 Python 重写的，在 lib2to3/pgen2 下面。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;两个都是我写的。最早那个实际上是我为 Python 编写的第一份代码。尽管从技术上讲，我必须首先编写词法分析程序（lexer）（pgen 和 Python 共用词法分析程序，但 pgen 对大多数标记符不起作用）。&lt;/div&gt;
&lt;div&gt;之所以我要写自己的语法分析生成器，原因是当时这玩意（我熟悉的）相当稀少——基本上就是用 Yacc（有个 GNU 的重写版，叫作 Bison（译注：美洲野牛），但我不确定那时的自己是否知道）；或者是自己手写一个（这是大多数人所做的）。&lt;/div&gt;
&lt;div&gt;我曾在大学里用过 Yacc，从“龙书”中熟悉了它的工作原理，但是出于某些原因，我并不喜欢它；IIRC 关于 LALR(1) 语法的局限性，我很难解释清楚。&lt;/div&gt;
&lt;div&gt;（译注：1、龙书，原文是 Dragon book，指代《Compilers: Principles, Techniques, and Tools》，这是一本讲编译原理的书，属于编译原理界的殿堂级存在。另外还有两本经典著作，称号分别是“虎书”、“鲸书”，三者常常一起出现。2、IIRC，If I Remember Correctly，如果我没记错。）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;我也熟悉 LL(1) 解析器，并已认真地编写过一些递归下降的 LL(1) 解析器——我很喜欢它，而且还熟悉 LL(1) 解析器的生成技术（同样是因为龙书），所以我有了一个改进念头想要试验下：使用正则表达式（某种程度的）而不是标准的 BNF 格式。&lt;/div&gt;
&lt;div&gt;龙书还教会了我如何将正则表达式转换成 DFA，所以我把所有这些东西一结合，pgen 就诞生了。【更新：请参阅下文，对于这个理由，有个略微不同的版本。】&lt;/div&gt;
&lt;div&gt;我曾不熟悉更高级的技术，或者曾认为它们效率太低。（在当时，我觉得工作在解析器上的大多数人都是这样。）&lt;/div&gt;
&lt;div&gt;至于词法分析器（lexer），我决定不使用生成器——我对 Lex 的评价要比 Yacc 低得多，因为在尝试扫描超过 255 个字节的标记符时，我所熟悉的 Lex 版本会发生段错误（真实的！）。此外，我认为缩进格式很难教给词法分析器生成器。&lt;/div&gt;
&lt;div&gt;（译注：1、这里的生成器并不是 Python 语法中的生成器，而是指用来生成分析器的工具。Lex 是“LEXical compiler”的简称，用来生成词法分析器；Yacc 是“Yet another compiler compiler”的简称，用来生成语法分析器。2、段错误，原文是 segfault，全称是 segmentation fault，指的是因为越界访问内存空间而导致的报错。）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;pgen2 的故事则完全不同。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;我曾受雇于 San Mateo 的一家创业公司（即 Elemental Security，倒闭于 2007，之后我离开并加入了 Google），在那我有一项设计定制语言的任务（目标是作关于系统配置的安全性判定），并拥有相当大的自主权。&lt;/div&gt;
&lt;div&gt;我决定设计一些稍微像 Python 的东西，用 Python 来实现，并且决定要重用 pgen，但是后端要基于 Python，使用 tokenize.py 作为词法分析器。所以我用 Python 重写了 pgen 里的那些算法，然后继续构建了剩余的部分。&lt;/div&gt;
&lt;div&gt;管理层觉得把工具开源是有意义的，因此他们很快就批准了，而在不久之后（我当时很可能已经转移到 Google 了？），这工具对于 2to3 也是有意义的。（因为输入格式跟原始的 pgen 相同，用它来生成一个 Python 解析器很容易——我只需将语法文件喂给工具。:-)&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;更新：创建 pgen 的原因，还有更多故事&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;我不完全记得为什么要这样做了，但我刚刚偷看了&lt;a href=&quot;https://en.wikipedia.org/wiki/LL_parser#Conflicts%EF%BC%8C%E6%88%91%E5%8F%AF%E8%83%BD%E8%A7%89%E5%BE%97%E8%BF%99%E6%98%AF%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84%EF%BC%88%E5%AF%B9%E6%88%91%E8%80%8C%E8%A8%80%EF%BC%89%E4%B8%8D%E9%80%9A%E8%BF%87%E6%B7%BB%E5%8A%A0%E5%B8%AE%E5%8A%A9%E6%80%A7%E7%9A%84%E8%A7%84%E5%88%99%E8%80%8C%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E5%BC%8F%E3%80%82&quot;&gt;https://en.wikipedia.org/wiki/LL_parser#Conflicts，我可能觉得这是一种新的（对我而言）不通过添加帮助性的规则而解决冲突的方式。&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;例如，该网页所称的的左分解（将 A -&amp;gt; X | X Y Z 替换成 A -&amp;gt; X B; B -&amp;gt; Y Z | &amp;lt;empty&amp;gt;），我会重写成 A -&amp;gt; X [Y Z]。&lt;/div&gt;
&lt;div&gt;如果我没记错，通过“正则表达式 -&amp;gt; NFA -&amp;gt; DFA”的转换过程，解析引擎（该网页中前面的 syntacticAnalysis 函数）依然可以工作在由这些规则所派生的解析表上；我认为这里需要有不出现空白产物的诉求。（译注：“空白产物”，原文是 empty productions，对应的是前文的 &amp;lt;empty&amp;gt;，指的是不必要出现 empty。）&lt;/div&gt;
&lt;div&gt;我还想起一点，由解析引擎生成的解析树节点可能有很多子节点，例如，对于上面的规则 A -&amp;gt; X [Y Z]，节点 A 可能有 1 个子节点（X）或者 3 个（X Y Z）。代码生成器中就需要有一个简单的检查，来确定它遇到的是哪一种可能的情况。（这已经被证明是一把双刃剑，后来我们添加了一个由单独的生成器所驱动的“解析树 -&amp;gt; AST”步骤，以简化字节码生成器。）&lt;/div&gt;
&lt;div&gt;所以我使用正则表达式的原因，很可能是为了使语法更易于阅读：在使用了必要的重写以解决冲突之后，我发现语法不是那么可读（此处应插入《Python 之禅》的说法 :-) ，而正则表达式则更符合我对于经典语言的语法的看法（除了起着奇怪名字的帮助规则、[optional] 部分以及 * 号重复的部分）。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;正则表达式没有提高 LL(1) 的能力，更没有降低它的能力。当然了，所谓“正则表达式”，我想说的其实是 EBNF ——我不确定 “EBNF” 在当时是否是一个被明确定义了的符号，它可能就指对 BNF 的任意扩展。&lt;/div&gt;
&lt;div&gt;假如将 EBNF 转换为 BNF，再去使用它，将会导致尴尬的多解析树节点问题，所以我不认为这会是一种改进。&lt;/div&gt;
&lt;div&gt;如果让我重做一遍，我可能会选择一个更强大的解析引擎，可能是 LALR(1) 的某个版本（例如 Yacc/Bison）。LALR(1) 的某些地方要比 LL(1) 更给力，也更加有用，例如，关键字参数。&lt;/div&gt;
&lt;div&gt;在 LL(1) 中，规则 “arg: [NAME =] expr” 无效，因为 NAME 出现在了表达式的第一组里（FIRST-set），而 LL(1) 算法没法处理这样的写法。&lt;/div&gt;
&lt;div&gt;如果我没记错，LALR(1) 则可以处理它。但是，在我写完 pgen 的第一个版本的好些年之后，关键字参数写法才出现，那时候我已不想重做解析器了。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;2019 年 3 月更新：&lt;/strong&gt; Python 3.8 将删除 pgen 的 C 版本，转而使用重写的 pgen2 版本。请参阅 &lt;a href=&quot;https://github.com/python/cpython/pull/11814&quot;&gt;https://github.com/python/cpython/pull/11814&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;（译注：感觉可以帮 Guido 再加一条“更新”了，目前他正在研究 PEG 解析器，将会作为 pgen 的替代。详情请看《&lt;a href=&quot;https://mp.weixin.qq.com/s/yqVVaZVn8RRanllaXMFD9A&quot;&gt;Python之父新发文，将替换现有解析器&lt;/a&gt;》）&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 之父新发文，将替换现有解析器</title>
            <link>https://pythoncat.top/posts/2019-07-27-Guido/</link>
            <guid>https://pythoncat.top/posts/2019-07-27-Guido/</guid>
            <description>分析了当前的 pgen 解析器的诸多缺陷，并介绍了 PEG 解析器的优点</description>
            <pubDate>Sat, 27 Jul 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;Guido van Rossum 是 Python 的创造者，虽然他现在放弃了“终身仁慈独裁者”的职位，但却成为了指导委员会的五位成员之一，其一举一动依然备受瞩目。近日，他开通了 Medium 账号，并发表了第一篇文章，透露出要替换 Python 的核心部件（解析器）的想法。这篇文章分析了当前的 pgen 解析器的诸多缺陷，并介绍了 PEG 解析器的优点，令人振奋。这项改造工作仍在进行中，Guido 说他还会写更多相关的文章，我们就拭目以待吧。&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;&lt;strong&gt;原题&lt;/strong&gt; | &lt;a href=&quot;https://medium.com/@gvanrossum_83706/peg-parsers-7ed72462f97c&quot;&gt;PEG Parsers&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;作者&lt;/strong&gt; | Guido van Rossum（Python之父）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; | 豌豆花下猫（“Python猫”公众号作者）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;声明&lt;/strong&gt; | 翻译是出于交流学习的目的，欢迎转载，但请保留本文出处，请勿用于商业或非法用途。&lt;/div&gt;
&lt;div&gt;几年前，有人问 Python 是否会转换用 PEG 解析器（或者是 PEG 语法，我不记得确切内容、谁说的、什么时候说的）。我稍微看过这个主题，但没有头绪，就放弃了。&lt;/div&gt;
&lt;div&gt;最近，我学了很多关于 PEG（Parsing Expression Grammars）的知识，如今我认为它是个有趣的替代品，正好替换掉我在 30 年前刚开始创造 Python 时自制的（home-grown）语法分析生成器（parser generator）（那个语法分析生成器，被称为“pgen”，是我为 Python 写下的第一段代码）。&lt;/div&gt;
&lt;div&gt;我现在感兴趣于 PEG，原因是对 pgen 的局限性感到有些恼火了。&lt;/div&gt;
&lt;div&gt;它使用了我自己写的 LL(1) 解析的变种——我不喜欢可以产生空字符串的语法规则，所以我禁用了它，进而稍微地简化了生成解析表的算法。&lt;/div&gt;
&lt;div&gt;同时，我还发明了一套类似 EBNF 的语法符号（译注：Extended Backus-Naur Form，BNF 的扩展，是一种形式化符号，用于描述给定语言中的语法），至今仍非常喜欢。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;以下是 pgen 令我感到烦恼的一些问题。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;LL(1) 名字中的 “1” 表明它只使用单一的前向标记符（a single token lookahead），而这限制了我们编写漂亮的语法规则的能力。例如，一个 Python 语句（statement）既可以是表达式（expression），又可以是赋值（assignment）（或者是其它东西，但那些都以 if 或 def 这类专用的关键字开头）。&lt;/div&gt;
&lt;div&gt;我们希望使用 pgen 表示法来编写如下的语法。（请注意，这个示例描述了一种玩具语言（toy language），它是 Python 的一个微小的子集，就像传统中的语言设计一样。）&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;statement: assignment | expr | if_statement
expr: expr &apos;+&apos; term | expr &apos;-&apos; term | term
term: term &apos;*&apos; atom | term &apos;/&apos; atom | atom
atom: NAME | NUMBER | &apos;(&apos; expr &apos;)&apos;
assignment: target &apos;=&apos; expr
target: NAME
if_statement: &apos;if&apos; expr &apos;:&apos; statement&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;关于这些符号，解释几句：&lt;code&gt;NAME&lt;/code&gt; 和 &lt;code&gt;NUMBER&lt;/code&gt; 是标记符（token），预定义在语法之外。引号中的字符串如 ’+’ 或 ‘if’ 也是标记符。（我以后会讲讲标记符。）语法规则以其名称开头，跟在后面的是 &lt;code&gt;:&lt;/code&gt; 号，再后面则是一个或多个以 &lt;code&gt;|&lt;/code&gt; 符号分隔的可选内容（alternatives）。&lt;/div&gt;
&lt;div&gt;但问题是，如果你这样写语法，解析器不会起作用，pgen 将会罢工。&lt;/div&gt;
&lt;div&gt;其中一个原因是某些规则（如 &lt;code&gt;expr&lt;/code&gt; 和 &lt;code&gt;term&lt;/code&gt;）是左递归的，而 pgen 还不足以聪明地解析。这通常需要通过重写规则来解决，例如（在保持其它规则不变的情况下）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;expr: term (&apos;+&apos; term | &apos;-&apos; term)*
term: atom (&apos;*&apos; atom | &apos;/&apos; atom)*&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这就揭示了 pgen 的一部分 EBNF 能力：你可以在括号内嵌套可选内容，并且可以在括号后放 &lt;code&gt;*&lt;/code&gt; 来创建重复，所以这里的 &lt;code&gt;expr&lt;/code&gt; 规则就意味着：它是一个术语（term），跟着零个或多个语句块，语句块内是加号跟术语，或者是减号跟术语。&lt;/div&gt;
&lt;div&gt;这个语法兼容了第一个版本的语言，但它并没有反映出语言设计者的本意——尤其是它并没有表明运算符是左绑定的，而这在你尝试生成代码时非常重要。&lt;/div&gt;
&lt;div&gt;但是在这种玩具语言（以及在 Python）中，&lt;strong&gt;还有另一个烦人的问题。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;由于前向的单一标记符，解析器无法确定它查看的是一个表达式的开头，还是一个赋值。在一个语句的开头，解析器需要根据它看到的第一个标记符，来决定它要查看的 &lt;code&gt;statement&lt;/code&gt; 的可选内容。（为什么呢？pgen 的自动解析器就是这样工作的。）&lt;/div&gt;
&lt;div&gt;假设我们的程序是这样的：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;answer = 42&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这句程序会被解析成三个标记符：&lt;code&gt;NAME&lt;/code&gt; （值是 &lt;code&gt;answer&lt;/code&gt;），‘=’ 和 &lt;code&gt;NUMBER&lt;/code&gt; （值为 42）。在程序开始时，我们拥有的唯一的前向标记符是 &lt;code&gt;NAME&lt;/code&gt; 。此时，我们试图满足的规则是 &lt;code&gt;statement&lt;/code&gt; （这个语法的起始标志）。此规则有三个可选内容：&lt;code&gt;expr&lt;/code&gt; 、&lt;code&gt;assignment&lt;/code&gt; 以及 &lt;code&gt;if_statement&lt;/code&gt; 。我们可以排除&lt;code&gt;if_statement&lt;/code&gt; ，因为前向标记符不是 “if”。&lt;/div&gt;
&lt;div&gt;但是 &lt;code&gt;expr&lt;/code&gt; 与 &lt;code&gt;assignment&lt;/code&gt; 都能以 &lt;code&gt;NAME&lt;/code&gt; 标记符开头，因此就会引起歧义（ambiguous），pgen 会拒绝我们的语法。&lt;/div&gt;
&lt;div&gt;（这也不完全正确，因为语法在技术上并不会导致歧义；但我们先不管它，因为我想不到更好的词来表达。那么 pgen 是如何做决定的呢？它会为每条语法规则计算出一个叫做 &lt;code&gt;FIRST&lt;/code&gt; 组的东西，如果在给定的点上，FIRST 组出现了重叠选项，它就会抱怨）（译注：抱怨？应该指的是解析不下去，前文译作了罢工）。&lt;/div&gt;
&lt;div&gt;那么，&lt;strong&gt;我们能否为解析器提供一个更大的前向缓冲区，来解决这个烦恼呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;对于我们的玩具语言，第二个前向标记符就足够了，因为在这个语法中，assignment  的第二个标记符必须是 “=”。&lt;/div&gt;
&lt;div&gt;但是在 Python 这种更现实的语言中，你可能需要一个无限的前向缓冲，因为在 “=” 标记符左侧的东西可能极其复杂，例如：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;table[index + 1].name.first = &apos;Steven&apos;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在 “=” 标记符之前，它已经用了 10 个标记符，如果想挑战的话，我还可以举出任意长的例子。为了在 pgen 中解决它，我们的方法是修改语法，并增加一个额外的检查，令它能接收一些非法的程序，但如果检查到对左侧的赋值是无效的，则会抛出一个 &lt;code&gt;SyntaxError&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;对于我们的玩具语言，这可归结成如下写法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;statement: assignment_or_expr | if_statement
assignment_or_expr: expr [&apos;=&apos; expr]&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;（方括号表示了一个可选部分。）然后在随后的编译过程中（比如，在生成字节码时），我们会检查是否存在 “=”，如果存在，我们再检查左侧是否有 &lt;code&gt;target&lt;/code&gt; 语法。&lt;/div&gt;
&lt;div&gt;在调用函数时，关键字参数也有类似的麻烦。我们想要写成这样（同样，这是 Python 的调用语法的简化版本）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;call: atom &apos;(&apos; arguments &apos;)&apos;
arguments: arg (&apos;,&apos; arg)*
arg: posarg | kwarg
posarg: expr
kwarg: NAME &apos;=&apos; expr&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;但是前向的单一标记符无法告诉解析器，一个参数的开头中的 &lt;code&gt;NAME&lt;/code&gt; 到底是 &lt;code&gt;posarg&lt;/code&gt; 的开头（因为 &lt;code&gt;expr&lt;/code&gt; 可能以 &lt;code&gt;NAME&lt;/code&gt; 开头）还是 &lt;code&gt;kwarg&lt;/code&gt; 的开头。&lt;/div&gt;
&lt;div&gt;同样地，Python 当前的解析器在解决这个问题时，是通过特别声明：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;arg: expr [&apos;=&apos; expr]&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;然后在后续的编译过程中再解决问题。（我们甚至出了点小错，允许了像 &lt;code&gt;foo((a)=1)&lt;/code&gt; 这样的东西，给了它跟 &lt;code&gt;foo(a=1)&lt;/code&gt; 相同的含义，直到 Python 3.8 时才修复掉。）&lt;/div&gt;
&lt;div&gt;那么，&lt;strong&gt;PEG 解析器是如何解决这些烦恼的呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;通过使用无限的前向缓冲！PEG 解析器的经典实现中使用了一个叫作“packrat parsing”（译注：PackRat，口袋老鼠）的东西，它不仅会在解析之前将整个程序加载到内存中，而且还能允许解析器任意地回溯。&lt;/div&gt;
&lt;div&gt;虽然 PEG 这个术语主要指的是语法符号，但是以 PEG 语法生成的解析器是可以无限回溯的递归下降（recursive-descent）解析器，“packrat parsing”通过记忆每个位置所匹配的规则，来使之生效。&lt;/div&gt;
&lt;div&gt;这使一切变得简单，然而当然也有成本：内存。&lt;/div&gt;
&lt;div&gt;三十年前，我有充分的理由来使用单一前向标记符的解析技术：内存很昂贵。LL(1) 解析（以及其它技术像 LALR(1)，因 YACC 而著名）使用状态机和堆栈（一种“下推自动机”）来有效地构造解析树。&lt;/div&gt;
&lt;div&gt;幸运的是，运行 CPython 的计算机比 30 年前有了更多的内存，将整个文件存在内存中确实已不再是一个负担。例如，我能在标准库中找到的最大的非测试文件是 &lt;code&gt;_pydecimal.py&lt;/code&gt; ，它大约有 223 千字节（译注：kilobytes，即 KB）。在一个 GB 级的世界里，这基本不算什么。&lt;/div&gt;
&lt;div&gt;这就是令我再次研究解析技术的原因。&lt;/div&gt;
&lt;div&gt;但是，&lt;strong&gt;当前 CPython 中的解析器还有另一个 bug 我的东西。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;编译器都是复杂的，CPython 也不例外：虽然 pgen-驱动的解析器输出的是一个解析树，但是这个解析树并不直接用作代码生成器的输入：它首先会被转换成抽象语法树（AST），然后再被编译成字节码。（还有更多细节，但在这我不关注。）&lt;/div&gt;
&lt;div&gt;为什么不直接从解析树编译呢？这其实正是它最早的工作方式，但是大约在 15 年前，我们发现编译器因为解析树的结构而变得复杂了，所以我们引入了一个单独的 AST，还引入了一个将解析树翻译成 AST 的环节。随着 Python 的发展，AST 比解析树更稳定，这减少了编译器出错的可能。&lt;/div&gt;
&lt;div&gt;AST 对于那些想要检查（inspect）Python 代码的第三方代码，也更加容易，它还通过被大众欢迎的 &lt;code&gt;ast&lt;/code&gt; 模块而公开。这个模块还允许你从头构建 AST 节点，或是修改现有的 AST 节点，然后你可以将新的节点编译成字节码。&lt;/div&gt;
&lt;div&gt;后一项能力支撑起了一整个为 Python 语言添加扩展的家庭手工业（译注：ast 模块为 Python 的三方扩展提供了便利）。（借助 &lt;code&gt;parser&lt;/code&gt; 模块，解析树同样能面向 Python 的用户开放，但它使用起来太麻烦了，因此相比于 &lt;code&gt;ast&lt;/code&gt; 模块，它就过时了。）&lt;/div&gt;
&lt;div&gt;综上所述，&lt;strong&gt;我现在的想法是看看能否为 CPython 创造一个新的解析器，在解析时，使用 PEG 与 packrat parsing 来直接构建 AST，从而跳过中间解析树结构，并尽可能地节省内存，尽管它会使用无限的前向缓冲。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;我还没进展到这个地步，但已经有了一个原型，可以将一个 Python 的子集编译成一个 AST，其速度与当前 CPython 的解析器大致相当。只不过，它占用的内存更多，所以我预计在将它扩展到整个语言时，将会降低 PEG 解析器的速度。&lt;/div&gt;
&lt;div&gt;但是，我还没去优化它，所以还是挺有希望的。&lt;/div&gt;
&lt;div&gt;转换成 PEG 的最后一个好处是它为语言的未来演化提供了更大的灵活性。&lt;/div&gt;
&lt;div&gt;过去有人曾说，pgen 的 LL(1) 缺陷帮助了 Python 保持语法的简单。这很有道理，但我们还有很多适当的流程，可以防止语言不受控制地膨胀（主要是 PEP 流程，在非常严格的向后兼容性要求以及新的治理结构的帮助下）。所以我并不担心。&lt;/div&gt;
&lt;div&gt;我还有很多内容要写，关于 PEG 解析以及我的具体实现，但是要等我整理好代码后，在后续的文章中再去写了。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>小型的编程项目有哪些值得推荐？这本神书写了 22 个，个个了不得</title>
            <link>https://pythoncat.top/posts/2019-07-15-book8/</link>
            <guid>https://pythoncat.top/posts/2019-07-15-book8/</guid>
            <description>推荐一本非常著名的开源书籍：《500 Lines or Less》</description>
            <pubDate>Mon, 15 Jul 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;今天，猫哥要推荐一本非常著名的开源书籍：《500 Lines or Less》。&lt;/div&gt;
&lt;div&gt;在开始正题之前，先介绍一下它所属的系列。该系列叫 AOSA，是“The Architecture of Open Source Applications”的简称，即“开源程序的体系结构”，目前有四本书，本期主角是最近的一本（发布于 2016.7.12）。&lt;/div&gt;
&lt;div&gt;这个系列最初的目的是：&lt;strong&gt;研究那些优秀的开源项目，从中吸取精华的实践经验。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;在前三本书中，研究对象已多达 50 几个，其中不乏名头响亮者，例如 Eclipse、Selenium、Git、matplotlib、nginx、Puppet、Pypy、SQLAlchemy 与 Twisted 等等。&lt;/div&gt;
&lt;div&gt;每个章节的作者都是开源软件的核心参与者，介绍了项目是如何设计的、为什么这样设计、主要的组成部分是什么、各模块间如何互动、开发中的优秀成果有哪些……&lt;/div&gt;
&lt;div&gt;这些书拆解了开源界的明星项目，通过阅读，你能了解到开源作者们的思考方式，了解到各类困难问题的解决方案，学习使用现成的轮子。所谓见多识广，学习吸取经验，有望“站在巨人的肩膀上”。&lt;/div&gt;
&lt;div&gt;但是，这几本书主要偏向于架构和工程方面，项目代码量基本是几千上万行，对于初级程序员来说不够实用，想要吃透，挑战性太大。&lt;/div&gt;
&lt;div&gt;针对这个问题，该系列新出了一本《500 Lines or Less》，专注于 500 行或更少代码的小型项目。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;关注&lt;strong&gt;编写代码时所作出的设计决定与权衡&lt;/strong&gt; ：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;为什么要使用一些接口将应用程序分成不同的模块？&lt;/li&gt;
&lt;li&gt;为什么在这里使用继承，在别处使用封装？&lt;/li&gt;
&lt;li&gt;如何预测程序的扩展，如何让其他程序员轻松实现？&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;简而言之，&lt;strong&gt;这本书聚焦于一些相对较小但又很具代表性的课题，并通过 500 行以内的代码来实现它。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;书中写了 22 个项目，下面逐一简介：&lt;/div&gt;
&lt;div&gt;1、&lt;strong&gt;Blockcode: A visual programming toolkit（可视化编程工具包）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：HTML、CSS、JavaScript&lt;/div&gt;
&lt;div&gt;该项目基于开源的 &lt;code&gt;Waterbear&lt;/code&gt; 工具，提供可视化的操作界面，通过简单而直观的交互方式，实现图形编程。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;2、A Continuous Integration System（持续集成系统）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：Python 2&lt;/div&gt;
&lt;div&gt;CI 是软件开发中重要的持续集成系统，保障新功能的稳定实现。这个项目介绍了 CI 系统的工作原理，并尝试构建自己的 CI 系统，实现监听器、测样例调度器和测试运行器。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;3、Clustering by Consensus（分布式系统）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：Python&lt;/div&gt;
&lt;div&gt;探索如何实现一个网络协议，用于可靠的分布式计算。为了解决共识性问题，使用了 Paxos 算法的衍生 Multi-Paxos。学习这个项目，能接触很多分布式的知识。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;4、Contingent: A Fully Dynamic Build System（动态构建系统）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：Python&lt;/div&gt;
&lt;div&gt;构建系统（build system）用于将源代码生成用户可用的目标（如库、可执行文件、脚本等），常见的有 GNU Make、CMake、Apache Ant 等。Python 中的 PyInstaller 也是构建系统的一种。本项目实现了一个构建系统，且试图对“动态交叉引用”问题提出一个解决方案。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;5、A Web Crawler With asyncio Coroutines（使用协程实现的爬虫）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：Python&lt;/div&gt;
&lt;div&gt;作者之一是 Python 之父（Guido van Rossum），使用标准库 asyncio  实现异步的网页爬虫。（学习爬虫者必看）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;6、Dagoba: an in-memory graph database（内存中的图形数据库）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：JavaScript&lt;/div&gt;
&lt;div&gt;图形数据库是 NoSQL 数据库的一种，使用图形理论来存储实体间的关系。这个项目介绍了图形数据库要解决的几个问题，然后将它实现。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;7、DBDB: Dog Bed Database（狗床数据库）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：Python&lt;/div&gt;
&lt;div&gt;用 Python 实现一个简单的键值对存储数据库(key/value database)，其特点是在电脑崩溃或程序出错时，也能保证数据的安全。学习这个项目，可以掌握关于数据库的一些核心特性，例如原子性(atomicity)、一致性(consistency)、独立性(isolation)和持久性(durability)。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;8、An Event-Driven Web Framework（事件驱动的Web框架）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：Common Lisp&lt;/div&gt;
&lt;div&gt;构建一个以事件驱动的 Web 框架，使用 HTTP 做通信协议。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;9、A Flow Shop Scheduler（流水车间调度器）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：Python 2&lt;/div&gt;
&lt;div&gt;流水车间调度问题是查找最优解问题的一种，本项目基于局部搜索（local search）方法，实现流水车间调度器。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;10、An Archaeology-Inspired Database（受考古学启发的数据库）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：Clojure&lt;/div&gt;
&lt;div&gt;主流的数据库是&lt;strong&gt;面向空间编程&lt;/strong&gt; （place-oriented programming），即在更新数据的时候，新数据会占据老数据的空间。本项目开了个脑洞，用考古学家的视角设计数据库，记录数据的所有变化轨迹，更新数据时并不删除老数据。最终实现代码仅 360 行，作者称这个数据库为&lt;code&gt;CircleDB&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;11、Making Your Own Image Filters（图片滤镜）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：Java&lt;/div&gt;
&lt;div&gt;Processing 是一种用 Java 构建的开发环境，本项目介绍了它的特性与配置，并最终实现自己的滤镜 APP。功能比较简单，但实现过程涉及很多图像处理的内容。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;12、A Python Interpreter Written in Python（Python解释器）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：Python&lt;/div&gt;
&lt;div&gt;它的结构跟 CPython 解释器差不多，作者命其名为 Byterun。 文中详细讲解了解释器的工作原理，跟着学习，将极有帮助。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;13、A 3D Modeller（3D建模）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：Python&lt;/div&gt;
&lt;div&gt;3D 图形化编程，使用到了 OpenGL 来渲染图形。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;14、A Simple Object Model（对象模型）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：Python&lt;/div&gt;
&lt;div&gt;当今最主流的编程范式依然是面向对象编程，而它的核心则是对象模型。编写一些简单的对象模型可以更好地理解现有语言的内部工作原理，并且深入地了解面向对象语言的设计理念。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;15、Optical Character Recognition (OCR，光学字符识别)&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：Python、JavaScript、HTML&lt;/div&gt;
&lt;div&gt;基于人工神经网络（ANNs）实现的简单 OCR 系统，并设计了一个 Web 客户端。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;16、A Pedometer in the Real World（现实计步器）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：Ruby&lt;/div&gt;
&lt;div&gt;计步器的设计依据是什么，如何在现实世界中把它实现呢？该文回答了这个问题，它还设计了一个友好的 Web 界面。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;17、The Same-Origin Policy（同源策略）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：Alloy&lt;/div&gt;
&lt;div&gt;同源策略（SOP）是当今浏览器中安全机制的重要组成部分，用于控制浏览器中脚本间的通信。文中使用 Alloy（一种用于建模与分析软件设计的语言）来构建一个可执行的 SOP 模型。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;18、A Rejection Sampler（采样器）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：Python&lt;/div&gt;
&lt;div&gt;“采样”是指从一些概率分布中生成随机数，文中介绍了如何从非标准的概率分布里进行采样，以及如何计算样本在分布里对应的概率。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;19、Web Spreadsheet（Web 电子表格）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：HTML、CSS、JS&lt;/div&gt;
&lt;div&gt;电子表格是办公软件的必备，我们最熟知的是微软的 Excel。文中用 AngularJS 框架来实现一个简单的 Web 电子表格，所用代码仅 99 行。效果可在这查看：&lt;a href=&quot;https://audreyt.github.io/500lines/spreadsheet/&quot;&gt;https://audreyt.github.io/500lines/spreadsheet&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;20、Static Analysis（静态分析）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：Julia&lt;/div&gt;
&lt;div&gt;“静态分析”指的是在不运行代码的情况下检查代码（类型、格式、编码规范等等），这项工作通常是由各种 IDE 编辑器来完成。本项目使用 Julia，实现了一些基本的静态分析功能。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;21、A Template Engine（模板引擎）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：Python&lt;/div&gt;
&lt;div&gt;“模板引擎”是 Web 开发中很重要的东西，支持将用户界面与实际业务数据分离，通过它可生成标准的 HTML 文档。文中所用的模板引擎语法基于 Django，总代码量仅 262 行。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;22、A Simple Web Server（Web服务器）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;使用语言：Python、HTML&lt;/div&gt;
&lt;div&gt;实现了一个简单的 Web 服务器，主要使用了标准库中的 &lt;code&gt;BaseHTTPServer&lt;/code&gt; 。另外，它还介绍了 CGI（通用网关接口） 协议，给服务器实现了运行外部程序的功能。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;所有项目介绍完毕。可以看出，22 个项目中有 13 个使用了 Python，占60%，难怪网上有些不明真相的同学直呼它是“一本Python神书”。&lt;/div&gt;
&lt;div&gt;有些项目初看的话，你难以想象只需不到 500 行代码就能实现，但是经过必要的问题裁剪，并使用恰当的现成轮子（开源库、工具、框架等），就能取得简单的成果。&lt;/div&gt;
&lt;div&gt;与之相对的，不要以为 500 行以内的项目就很简单。每个项目的作者都大有来头（连 Python 之父都亲自上阵啦），文章中写到的技术背景、实现原理以及设计思路，全都值得仔细研读（很多还不一定能读懂）。&lt;/div&gt;
&lt;div&gt;这本书是开源的，在官网上可以免费阅读。它还配套了 Github 仓库，存放了完整的项目代码，目前已经获得 20000 多颗星星啦。&lt;/div&gt;
&lt;div&gt;Github 上有对它的中文翻译计划，但是翻译者寥寥，只有 10 几篇翻译了出来，翻译质量还不敢恭维。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;不管如何，这么优质而诚意十足的开源书籍，非常值得推荐！作为咱们 Python 猫荐书系列的第八期，也非常合适。&lt;/div&gt;
&lt;div&gt;最后附上该书在开篇中的寄语：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;We hope that the experiences of the authors in this book will help you grow out of your comfort zone in your own programming practice.&lt;/p&gt;
&lt;p&gt;我们希望本书作者的经验能够帮助您在自己的编程实践中成长。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;书籍官网：&lt;a href=&quot;http://aosabook.org/en/index.html&quot;&gt;http://aosabook.org/en/index.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Github英：&lt;a href=&quot;https://github.com/aosabook/500lines&quot;&gt;https://github.com/aosabook/500lines&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Github中：&lt;a href=&quot;https://github.com/HT524/500LineorLess_CN&quot;&gt;https://github.com/HT524/500LineorLess_CN&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>编程语言之问：何时该借用，何时该创造？</title>
            <link>https://pythoncat.top/posts/2019-06-30-language/</link>
            <guid>https://pythoncat.top/posts/2019-06-30-language/</guid>
            <description>从 Guido 的推特说起</description>
            <pubDate>Sun, 30 Jun 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;6 月 22 日，Python 之父 Guido 发了一条推特，说了 Python 的一则历史故事，他说 elif 是从 C 语言中偷过来的：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;elif 是“else if”的简写，用于条件判断。当只有两个分支时，我们会写成“if…else…”，当出现更多分支时，我们会写成如下格式：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; 判断条件&lt;span&gt;1&lt;/span&gt;：
    做事情&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;elif&lt;/span&gt; 判断条件&lt;span&gt;2&lt;/span&gt;：
    做事情&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;：
    做其它事&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;简写而成的 elif 不仅是减少了几个字符，而且由于单一而清晰的用途，它还不会给我们带来理解或使用上的困惑。&lt;/div&gt;
&lt;div&gt;但是，简写法并不是主流，完整写法才是主流，C 语言中就是采用完整的写法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;判断条件&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;
   做事情&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;判断条件&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;
   做事情&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt; 
&lt;span&gt;{&lt;/span&gt;
   做其它事
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;没错，C 语言使用的是全拼写法，但是在它的预处理/预编译语句中，还有一个 elif 指令，Guido 所说的“偷”，就是从这来的：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;常量表达式&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;// 编译1&lt;/span&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; &lt;span&gt;常量表达式&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;// 编译2&lt;/span&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;// 编译3&lt;/span&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 没有预编译，所以所谓的偷，跟预编译没有关系，只是在对比两种写法后，借用了更简洁的写法而已。&lt;/div&gt;
&lt;div&gt;为什么 C 语言不把两种写法统一起来呢？这我不得而知了，而 Guido 在两种写法中，选择了后一种非主流却更好用的写法。我想对他说，你“偷”得好啊！&lt;/div&gt;
&lt;div&gt;实际上，留言区里的人也有同感，纷纷表示：不介意、很 okay、非常喜欢，还有人说“不是偷，而是收获（harvested）”、“不是偷，而是把它提升了一些高度”……&lt;/div&gt;
&lt;div&gt;前不久，我写了一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/NuzfuH_zCZzcrmSFR04NHw&quot;&gt;聊聊 print 的前世今生&lt;/a&gt;》，print 这个词就是从 C 语言中借用来的。除此之外，如果有人仔细比较这两种语言的关键字和习惯命名，肯定会发现不少相同的内容。&lt;/div&gt;
&lt;div&gt;编程语言间有一些共享的元素，这很常见，创造一门语言并不意味着要原创每一个词句，毕竟大部分思想是共通的，作为基础设施的词语更是如此。&lt;/div&gt;
&lt;div&gt;那么，我突然好奇了：&lt;strong&gt;创造一门编程语言时，什么时候该借用，什么时候该创造呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这个问题看起来可能没啥意义，因为终其一生，我们多数人也不大可能会参与创造一门编程语言。&lt;/div&gt;
&lt;div&gt;但我觉得它还是极有意义的，首先，提问精神值得肯定，其次，它还提供了一种溯源、甄别、遴选、创造的体系性视角，我认为这是求知的正确思维方式。&lt;/div&gt;
&lt;div&gt;带着这个疑惑，我特别想要考察的是 Python 的 for 循环。&lt;/div&gt;
&lt;div&gt;如果你有其它语言基础，就知道 “for 循环”通常指的是这样的三段式结构：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt; init&lt;span&gt;;&lt;/span&gt; condition&lt;span&gt;;&lt;/span&gt; increment &lt;span&gt;)&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;statement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// java&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x &lt;span&gt;=&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; x &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; x &lt;span&gt;=&lt;/span&gt; x&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;out&lt;span&gt;.&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;value of x : &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; x &lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;out&lt;span&gt;.&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;\n&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这种 C 风格的写法是很初级的东西，不少语言都借用了。但是，它的写法实在繁琐，为了更方便地遍历集合中的元素，人们在 for 循环之外又引入了升级版的 foreach 循环：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;// java&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;:&lt;/span&gt; a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;out&lt;span&gt;.&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;,&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// C#&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;foreach&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i in a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;System&lt;span&gt;.&lt;/span&gt;Console&lt;span&gt;.&lt;/span&gt;WriteLine&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 中也有 for 循环，但是，它借用有度，在设计上早早就有自己独到的考虑，它直接摒弃了三段式的 for 循环，而是采用类似 foreach 的一种写法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; iterating_var &lt;span&gt;in&lt;/span&gt; sequence&lt;span&gt;:&lt;/span&gt;
   statements&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 例子&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;&quot;hello&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;从表面上看，Python 的 for 循环跟其它语言的 foreach 很相似，但实际上，它的工作原理却很不相同。&lt;/div&gt;
&lt;div&gt;为什么会有不同呢？主要是因为 Python 的 for 语句用于可迭代对象上，而不仅仅是用于集合或者普通的容器（虽然它们也是可迭代对象），而可迭代对象还可再细分出迭代器与生成器，这会造成最终结果的极大差异。&lt;/div&gt;
&lt;div&gt;先看看两个例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 例1，普通可迭代对象&lt;/span&gt;
x &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; x&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; x&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 例2，迭代器或生成器&lt;/span&gt;
y &lt;span&gt;=&lt;/span&gt; &lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# y = (i for i in [1,2,3])&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; y&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; y&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;例 1 中，“1 2 3”会被打印两次，而在例 2 中，则只会打印一次。&lt;/div&gt;
&lt;div&gt;普通可迭代对象只有 __iter__() 魔术方法，而不像迭代器一样拥有 __next__() 魔术方法，这意味着它无法实现 &lt;code&gt;自遍历&lt;/code&gt; 过程，同时在经过 for 循环的 &lt;code&gt;它遍历&lt;/code&gt; 后，也不会破坏原有的结构。（这两个是我创造的概念，详见《&lt;a href=&quot;https://mp.weixin.qq.com/s/DIhwoJE3o0kKw3kzZKysag&quot;&gt;Python进阶：迭代器与迭代器切片&lt;/a&gt;》）。&lt;/div&gt;
&lt;div&gt;但是，迭代器是一种匮乏的设计，具有单向损耗的特性，遍历一次后就会被破坏掉，不能重复利用。（关于迭代器的设计问题，这篇文章值得一看《&lt;a href=&quot;https://mp.weixin.qq.com/s/Be4tHnR0BY-C__xoPPBjhQ&quot;&gt;当谈论迭代器时，我谈些什么？&lt;/a&gt;》）。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这表明了，&lt;strong&gt;Python 中 for 循环的使用场景很广阔，而且它还可能带来非纯结果，即重复执行同样的代码块，会出现不同的结果。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;这是不是跟别的语言很不同了呢？相同的关键字，相似的循环思想与写法，但是，带来的影响却有差别。&lt;/div&gt;
&lt;div&gt;关于 Python 的 for 循环，还有一个很独特的设计，即 for-else 结构：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;x &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; x&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt; end &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;ok&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 输出：1 2 3 ok&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;本文开头提到了 if-else 结构，只有在不满足 if 条件时，才会执行到 else 部分，也就是说，如果 if 语句为真，那执行完它的语句块后，就会跳过 else 部分。&lt;/div&gt;
&lt;div&gt;这是一种&lt;strong&gt;非此即彼的并行关系&lt;/strong&gt; ，直白地说是“如果…就…；否则就…” 。&lt;/div&gt;
&lt;div&gt;但是，对于 for-else 结构，for 语句并不是在做真值判断，它的程序体必然会执行（除非可迭代对象为空），执行后还会继续执行 else 部分。&lt;/div&gt;
&lt;div&gt;所以，它是一种&lt;strong&gt;先此后彼的串行关系&lt;/strong&gt; ，翻译出来则是“对于…就…；然后…”。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这种结构肯定不是从 C 语言中借用来的，至于是否为 Python 所独创，我不确定（大概率是，姑且认为是吧），如果有知情的同学，烦请告知。&lt;/div&gt;
&lt;div&gt;那么，为什么 Python 要加上这种设计呢，它有什么实际的用途么？&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;x &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; x&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; i &lt;span&gt;%&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# match&lt;/span&gt;
        &lt;span&gt;break&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;mismatch&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上例的 for 部分增加了一个判断以及 break，这个 break 不仅会跳出 for 循环本身，还会跳过 else 部分。&lt;/div&gt;
&lt;div&gt;上例的作用是查找偶数，如果找到则打印出来，如果 for 循环遍历完都找不到，则进入到 else 分支，打印“mismatch”的结果。&lt;/div&gt;
&lt;div&gt;所以，其实 else 是 for 循环有没有正常遍历结束的标记，如果在循环后没有达到某种目标而跳出（break、return 或者 raise），就可以在 else 中做必要的补充（记录日志、抛出异常等等）。&lt;/div&gt;
&lt;div&gt;这种设计并不算一个好的设计，因为 else 会带来误解（if-else 那种非此即彼的关系），而且它的最大用途需要结合 break 等跳出循环的操作，但是这层信息却非显而易见的。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;在核心开发者的邮件列表里，就有不少争论点，2009 年的这封邮件梳理了大家的讨论（&lt;a href=&quot;https://mail.python.org/pipermail/python-ideas/2009-October/006155.html&quot;&gt;https://mail.python.org/pipermail/python-ideas/2009-October/006155.html&lt;/a&gt;）。&lt;/div&gt;
&lt;div&gt;其中，有开发者提议：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;移除这个写法&lt;/li&gt;
&lt;li&gt;如果用了却没写 break，就生成告警提示&lt;/li&gt;
&lt;li&gt;替换 else 关键字（如 then、finally、else no break）&lt;/li&gt;
&lt;li&gt;增加其它的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;这封邮件一一列举了这些观点的提出原因及改进想法，然后又一一地反驳了它们，最后的结论是保持 for-else 写法不变，也就是大家现在看到的实现方式。它的完整语义是：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;execute the &lt;span&gt;for&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;loop &lt;span&gt;(&lt;/span&gt;&lt;span&gt;or&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;loop&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; you reach a `&lt;span&gt;break&lt;/span&gt;`&lt;span&gt;,&lt;/span&gt; jump to the end of the `&lt;span&gt;for&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;` block
&lt;span&gt;else&lt;/span&gt; execute the `&lt;span&gt;else&lt;/span&gt;` suite&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;也就是说，else 对标的是“是否执行 break”，如果没有 break，则进入else。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;但是，我并不认可这种做法，因为 break 是隐含条件，在直观上我们只看到了 for-else，很容易产生 if-else 那样的联想。因此，我反而赞同把 else 改为 then，以消除误会。&lt;/div&gt;
&lt;div&gt;这封邮件的反驳意见是，改成 then 会引入新的关键字，因此不好。&lt;/div&gt;
&lt;div&gt;我认为这个说法有些牵强（从使用者的角度），还记得本文开头的内容么，elif 就是新引入的关键字啊，看看它现在是多受欢迎。&lt;/div&gt;
&lt;div&gt;elif 属于那种初看不知何意，但知道后肯定会记住的词，而且也不大可能拼写错误。为了这点简洁易拼写的好处，它就被引入成新的关键字了。&lt;/div&gt;
&lt;div&gt;for-else 中的 else 属于那种初看以为知道含义的词，但实际却表达着不同意思（准确地说是，由于不知道隐含条件，而造成的误解），为了清晰语义的好处，我认为可以引入新的关键词 then 来替代 else。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;不过，我转念一想，现在讨论这个已经没有意义了，毕竟时间已经过去了，那都是 10 年前的讨论了。&lt;/div&gt;
&lt;div&gt;如果在 Python 创造之初，或者在 Python 3 大版本改动之初，这个讨论就被提出，那很可能 for-else 会被设计成 for-then ，then 会像引入 elif 关键词一样被引入。&lt;/div&gt;
&lt;div&gt;如果是那样，说不定 Guido 某天心血来潮说起这则历史小故事，留言区又会出现一大片的赞同之声呢。&lt;/div&gt;
&lt;div&gt;聊到这里，意犹未尽，但主题似乎有点跑偏，我们来稍微总结几个要点吧：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Python 从 C 中借用了 elif，受到赞许&lt;/li&gt;
&lt;li&gt;Python 没有借用 C 传统的三段式 for 循环&lt;/li&gt;
&lt;li&gt;Python 采用类似 foreach 的表达，但应用范围更广&lt;/li&gt;
&lt;li&gt;Python 的 for 循环由于迭代器的设计原因，会造成一些陷阱&lt;/li&gt;
&lt;li&gt;Python 创造了 for-else 结构，它的隐含语义是 for-(if break)-else，曾有讨论是否要创造新的关键词替换 for-else，但是被否决了&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;本文谈到的内容很微小，好像没有什么实际的帮助，不知道 elif 来源、不知道 for 循环的细节、不知道 for-else 的用途与争论，这些统统都不会造成语言使用上的障碍。&lt;/div&gt;
&lt;div&gt;但我还是那个观点：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;阅读 Python 的历史，从中你可以看到设计者们对功能细节的打磨过程，最终你就明白了，Python 是如何一步一步地发展成今天的样子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;这在我看来挺有趣的，更加增进了我对于 Python 的了解，以后在编程到某些用法的时候，脑海里满满都是故事，它顿时也会变得立体生动起来。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>聊聊 print 的前世今生</title>
            <link>https://pythoncat.top/posts/2019-06-23-print/</link>
            <guid>https://pythoncat.top/posts/2019-06-23-print/</guid>
            <description>一个冷门却有点意思的话题</description>
            <pubDate>Sun, 23 Jun 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;（一）&lt;/div&gt;
&lt;div&gt;上周，我翻译了一篇文章，解释了&lt;a href=&quot;https://mp.weixin.qq.com/s/i0cMwVGDnx3MJs8ybGrrMA&quot;&gt;为什么 Python 3 把 print 改为函数？&lt;/a&gt;  概括有如下几点原因：1、print 不适宜作为应用程序级的语句。2、改为一个函数，可以实现更复杂的功能。3、改为一个函数，能方便地进行替换。&lt;/div&gt;
&lt;div&gt;在 Python 2 中，print 是个语句（statement），它的级别就跟 for、if、def 等关键字相同，这是一个古老的设计（毕竟 Python 诞生于 1989 年），改成 print() 函数，意味着它升级了。&lt;/div&gt;
&lt;div&gt;在查阅资料的时候，我发现 print 在历代版本中，一直发展变化，到了今天，它自身已足够完善了，可是外部的挑战一直不断。&lt;/div&gt;
&lt;div&gt;因此，这篇文章再来聊聊它：介绍 print 的现状，追溯它的历史，说说它的挑战者，挖挖那些更加本质的东西。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;（二）&lt;/div&gt;
&lt;div&gt;在 3.0 版本中，print() 函数全新登场，开发者可以自定义打印对象的间隔（默认是空格）、终止方式（默认是换行）、以及输出位置（默认是标准输出 sys.stdout）。&lt;/div&gt;
&lt;div&gt;而到了 3.3 版本，它还添加了一个新的参数，可以决定是否要刷新数据流。&lt;/div&gt;
&lt;div&gt;至此，这个函数的完整格式就变成了 &lt;code&gt;print(*objects, sep=&apos; &apos;, end=&apos;\n&apos;, file=sys.stdout, flush=False)&lt;/code&gt;  ，与升级前的 print 语句是天壤之别啦。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;优点是显而易见的，可定制的参数带来了使用场景的扩充。&lt;/div&gt;
&lt;div&gt;（三）&lt;/div&gt;
&lt;div&gt;其实，在这次大版本的改动之前，早期的 print 语句并非是一成不变的，核心开发者们一直在完善它。&lt;/div&gt;
&lt;div&gt;例如，在 2000 年的 PEP-214 之前，print 语句只能用于标准输出（sys.stdout），只有当提出这个提案后，print 才可以打印内容到类文件对象（file-like object）中。&lt;/div&gt;
&lt;div&gt;（注：PEP 即 Python 改进提案，更多介绍详见旧文《&lt;a href=&quot;https://mp.weixin.qq.com/s/oRoBxZ2-IyuPOf_MWyKZyw&quot;&gt;学习Python，怎能不懂点PEP呢？&lt;/a&gt;》）&lt;/div&gt;
&lt;div&gt;这次调整后，它的写法可以如下（其中，mylogfile 是用于记录打印信息的文件路径）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; mylogfile&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;this message goes to my log file&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在只接触过 Python 3 的同学眼里，这个写法可能很别扭吧，其实它等同于如今的：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;this message goes to my log file&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; mylogfile&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;（四）&lt;/div&gt;
&lt;div&gt;上例是一次成功的改进，但有趣的是，社区内也有一次失败的修改提案。&lt;/div&gt;
&lt;div&gt;与 print() 函数相同，print 语句在打印完一个对象后，默认会换行，因此，当打印的内容自带了换行符的时候，最终的打印结果就会出现一个多余的换行。&lt;/div&gt;
&lt;div&gt;2001 年的时候，有开发者在 PEP-259 中提议，根据打印的最后一个字符的类型，设置几个标志位，以此决定是否要默认换行。校验规则如下：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;-1 ——如果最后一个对象是以换行符结束的字符串&lt;/li&gt;
&lt;li&gt;0  ——如果最后一个对象是以空白字符结尾的字符串，既不是空格也不是换行符&lt;/li&gt;
&lt;li&gt;1  ——在所有其它情况下(包括最后一个对象是空字符串或不是字符串的情况)&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;根据这些规则，print 语句遇到 -1 标志位的时候，就不再做默认的换行了，似乎可以解决多余换行的问题。&lt;/div&gt;
&lt;div&gt;然而，这个提案被否决了。反对的意见主要是：这样可能会破坏掉无数个 CGI 脚本，而且 Python 中已经有太多的“魔法”了。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这一套规则确实太神奇了，幸好没有实施。在当前的版本中，只需调整 end 参数，就可以避免多余换行的问题。&lt;/div&gt;
&lt;div&gt;（五）&lt;/div&gt;
&lt;div&gt;阅读过往的 PEP 文档，就是在阅读 Python 的历史，从中你可以看到设计者们对功能细节的打磨过程，最终你就明白了，Python 是如何一步一步地发展成今天的样子。&lt;/div&gt;
&lt;div&gt;不过，历史中除了能看到精华，也可以看到一些包袱。print() 函数的升级就是在甩掉包袱，前不久我写了《&lt;a href=&quot;https://mp.weixin.qq.com/s/XzCqoCvcpFJt4A-E4WMqaA&quot;&gt;聊聊 Python 的内置电池&lt;/a&gt;》，聊到了 Python 中废弃部分标准库的话题，也是一个很好的观察例子。&lt;/div&gt;
&lt;div&gt;除此之外，“print”的命名本身也算是一种包袱。&lt;/div&gt;
&lt;div&gt;早期的计算机使用纸带作为信息载体，程序的运算结果需要 print 在纸带上，所以顺理成章地，有些编程语言就使用了“print”来表示程序的输出操作。尽管后来不再使用纸带了，一些语言仍然延用这个词，例如 C 语言以及借鉴了 C 语言的 Python。&lt;/div&gt;
&lt;div&gt;Python 的另一个借鉴对象是 Shell，这是一种古老的脚本语言，可它没有“print”的包袱，它用的是 echo。这个词的本意是回声，后来也指雷达的回波，被用于计算机编程中，则又被赋予了“应答、回显”之义，更直白的表述应该是“输出、打印”。&lt;/div&gt;
&lt;div&gt;Python 从 C 中借用了“print”命名，又从 Shell 中借用语句式的表达，形成了自己 print 语句，如今到了新的版本，它去除了语句式的表达，却仍保留着原始命名，可以说这个包袱是永远脱不掉了。&lt;/div&gt;
&lt;div&gt;但是，话说回来，词语在演化过程中会获得新的生命，它的意义全在于如何使用。所以，虽然没有了纸带这个物理载体，print 这个词却“改头换面”地活了下来。&lt;/div&gt;
&lt;div&gt;它还拥有很多的表兄弟姐妹呢，非常热闹（试试你能认出几个？）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;print(&quot;点个赞吧!&quot;)
printf(&quot;点个赞吧!&quot;);
print_r(&apos;点个赞吧！&apos;);
var_dump(&apos;点个赞吧！&apos;);
NSLog(@&quot;点个赞吧！&quot;);
System.out.println(&quot;点个赞吧!&quot;);
console.log(&quot;点个赞吧!&quot;);
cout &amp;lt;&amp;lt; &quot;点个赞吧!&quot; &amp;lt;&amp;lt; endl;
Console.WriteLine(&quot;点个赞吧!&quot;);
writeln(&apos;点个赞吧!&apos;)
fmt.Println(&quot;点个赞吧!&quot;);
Response.Write(&quot;点个赞吧！&quot;);
alert(&quot;点个赞吧！&quot;)
echo &quot;点个赞吧！&quot;
puts &quot;点个赞吧！&quot;
say &quot;点个赞吧!&quot;;  &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;
&lt;div&gt;（六）&lt;/div&gt;
&lt;div&gt;语言内部的发展历史，以及不同语言的相似表述，都表明着一件事，那就是打印操作很重要，而且我们对它的要求还很复杂多样。&lt;/div&gt;
&lt;div&gt;Python 中的 print 语句能发展成今天的 print() 函数，已经非常完善了。&lt;/div&gt;
&lt;div&gt;不过，需求是无止境的，作为最常用的调试手段，print() 还达不到十全十美。它的好处是简单直白、容易上手，但缺点则是功能单一、效率较低，在需要定制格式的频繁使用场景下，不堪大用。&lt;/div&gt;
&lt;div&gt;这在不同编程语言中是通病，因此大家都默契地提供了用于调试的日志模块，例如 Java 的 log4j，C++ 的 log4cxx，当然还有 Python 的 logging。&lt;/div&gt;
&lt;div&gt;日志模块 logging 可以说是对 print() 函数的替代式升级，主要优点是更加灵活高效，例如可以设置不同的日志等级、配置多样的格式化信息、甚至可以输出日志到远程服务器上。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;当然，日志模块只是一种解决方案，也并不是最完美的。&lt;/div&gt;
&lt;div&gt;在 Python 中还有一些模块可以用于调试，例如最主流的 pdb，它可以设置断点、分步调试、查看栈片段、动态调值等，用得好，有奇效。主流的 IDE 工具也都提供了一些调试手段，相比于简单的 print()，它们具有降维打击的优势。&lt;/div&gt;
&lt;div&gt;今年 4 月，Github 上开源了一个专用于调试程序的库，名叫 &lt;strong&gt;PySnooper&lt;/strong&gt; ，短短两个月，它就收获了近 12K 个关注。这个三方库的口号是“Never use print for debugging again”，其目标就是在调试代码时完全替代 print。&lt;/div&gt;
&lt;div&gt;这个库的用法非常简单，只需一行代码，就可以实现对整个函数的监听，做到记录每一行的执行时间、记录每个变量的赋值等等，而且还可以使用“with”语句，监听部分的代码块，或者使用“watch”命令，专门监听特定的变量值。&lt;/div&gt;
&lt;div&gt;这个库强大而惊艳，除了上述作用，它还能监听指定格式开头的代码，能在多线程中监听线程，甚至支持用户自定义的监听规则。难怪它一经面世，就好评如潮，人人奔走相告。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;snoop&lt;/strong&gt; 这个单词很有意思，它指的是嗅探、窥探和监听。首字母大写的 &lt;strong&gt;Snoop&lt;/strong&gt; ，译作史努比，则是一只被很多人喜爱的漫画小狗。所以这个 &lt;strong&gt;PySnooper&lt;/strong&gt; 库就令我不由地产生了一种联想：它是一只嗅觉异常敏锐的小狗，明白无误地为你执行各种监听任务。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;（七）&lt;/div&gt;
&lt;div&gt;最后，我们可以来回顾一下 print 的发展历史了，有两条线索，一条是它自身发展的明线，另一条是它的挑战者们的暗线。&lt;/div&gt;
&lt;div&gt;先看明线吧，早期版本的 print 语句带有 C 和 Shell 的影子，它是个应用程序级的 statement，使用十几年间，有过一些改进的尝试，例如 PEP-214 和 PEP-259；到了 2009 年的大版本 3.0，Python 把 print 语句改成了 print() 函数，使它成为了众多内置函数的一员，随后在 3.3 版本，又对它做了一次功能增强，至此，它完成了自己的华丽蜕变，占据了稳固的一席之地。&lt;/div&gt;
&lt;div&gt;至于暗线，print 的竞争对手们可谓众多，像传统的日志模块 logging、调试模块 pdb、以及主流 IDE 的调试功能，等等，如今还有一位后起之秀 PySnooper，无不瞄准了 print 的位置，摩拳擦掌，虎视眈眈。&lt;/div&gt;
&lt;div&gt;print 一词最早应该跟纸带相关，用途和需求场景都很少，如今的计算机世界已经不可同日而语，所以才促进了 print 自身的发展，也刺激了众多对手们的崛起。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;print 代表了一种诉求/思想：输出计算结果、记录程序过程、监察对象变化，然后用于查看、分析、调试、展示等等。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;明线上的发展，就是继承了它的名字，壮大 print；暗线上的发展，则是继承了它的思想，为了实现目的，各施手段，百花齐放。&lt;/div&gt;
&lt;div&gt;print 当然不是 Python 所特有的，这明暗两线的发展也同理，如果你把视野放到任何一个经得起时间考验的语言上，必然也会看到相似的发展历程与竞争故事。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>闲聊抽烟</title>
            <link>https://pythoncat.top/posts/2019-06-16-smoking/</link>
            <guid>https://pythoncat.top/posts/2019-06-16-smoking/</guid>
            <description>算起来，我的烟龄有两年了，今天来闲聊一下</description>
            <pubDate>Sun, 16 Jun 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;算起来，我的烟龄有两年了，今天来闲聊一下。&lt;/div&gt;
&lt;div&gt;其实，我很讨厌别人在我面前抽烟（现在依旧），一直都不喜欢烟味。那我是怎么开始的呢，为什么要学着抽烟呢？&lt;/div&gt;
&lt;div&gt;一个原因是，每次参加完同事婚礼，带来的礼物里都有一包软中华，有段时间家里好像竟放着三包这样的烟，总觉得有些浪费。&lt;/div&gt;
&lt;div&gt;还有一个原因是，我觉得“人不能无癖”，就是需要一点无伤大雅的小恶习吧。这方面的选择比如说喝酒、玩游戏和抽烟。喝酒于我来说，生不如死，如果不是酒桌礼仪的话，我根本不想碰。游戏的话，太容易沉迷，玩玩丢丢过好几回了。所以，抱着尝试的心态，就是抽烟了。&lt;/div&gt;
&lt;div&gt;最后也有一个隐藏的原因，总是看到某些人物抽烟的故事，烟是这些创作者的灵感捕手，而一人一烟的画面在想象中很带美感，对我产生了吸引力。&lt;/div&gt;
&lt;div&gt;虽然是这么开始了，但我极其克制。&lt;/div&gt;
&lt;div&gt;最多一天只抽过 3 ~ 4 根烟，不过那是很短的一段时间，如今基本上每天只有 1 根烟的配额。所以，买一包烟，就能消磨很长的时间。&lt;/div&gt;
&lt;div&gt;说实话，我极少感受到香烟本身带来的愉悦感，我可能还不“会”抽烟吧。烟进烟出，如此而已，抽到口感不适的烟品，还会产生晕眩感。烟雾在口腔和肺部，就是逛逛。&lt;/div&gt;
&lt;div&gt;我反而比较享受的是抽烟的仪式，像是有时候享受拉一泡尿。&lt;/div&gt;
&lt;div&gt;我不喜欢在别人边上抽烟，不喜欢吐出的烟被别人吸了去，如果别人在我边上抽烟，我会心生抵触。吸烟在我这里是一项个人的独享行为。&lt;/div&gt;
&lt;div&gt;在家里的时候，我有这样的习惯：进到厨房里，关好门，打开窗（冬天不好开窗时就开抽油烟机），没有别人，然后抽烟。&lt;/div&gt;
&lt;div&gt;有时候，豌豆会凑过来，我就支开她——我在抽烟呢，对你身体有害。豌豆曾抽过几口，她总说好香，有大麦茶的味道，可我品不出来。&lt;/div&gt;
&lt;div&gt;“二手烟”有害别人的健康，这难道不是人尽皆知的么？所以，我才觉得抽烟应该在隔离区进行，这样的照顾是仪式的一部分，没有这层顾虑的话，抽烟的意义就降了品格。&lt;/div&gt;
&lt;div&gt;所以，抽烟是讲场合的，不同场合的烟有不同的意义。&lt;/div&gt;
&lt;div&gt;我可以这样要求自己，不适的场合就不抽。场合不适，时机就不适。&lt;/div&gt;
&lt;div&gt;有了这样的仪式，就似乎创造了一个第二时空，在里面的时间是变慢的，对于释放压力效果奇佳——不怕你们笑话，很多时候我抽完烟就想要去上厕所，有促进排便的功效。&lt;/div&gt;
&lt;div&gt;烟是个引子，是过程，不是目的。&lt;/div&gt;
&lt;div&gt;就像这篇随笔也是个引子，不想说明什么，只想说说什么，不想传达什么，只想传出什么。&lt;/div&gt;
&lt;div&gt;闲聊结束。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>[译] PEP-3105：改 print 为函数</title>
            <link>https://pythoncat.top/posts/2019-06-16-print/</link>
            <guid>https://pythoncat.top/posts/2019-06-16-print/</guid>
            <pubDate>Sun, 16 Jun 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;PEP原文 ：&lt;/strong&gt; &lt;a href=&quot;https://www.python.org/dev/peps/pep-3105/&quot;&gt;https://www.python.org/dev/peps/pep-3105/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP标题：&lt;/strong&gt; Make print a function&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP作者：&lt;/strong&gt; Georg Brandl&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;创建日期：&lt;/strong&gt; 2006-11-19&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;合入版本：&lt;/strong&gt; 3.0&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; ：&lt;a href=&quot;https://zhuanlan.zhihu.com/pythonCat&quot;&gt;豌豆花下猫&lt;/a&gt;（&lt;strong&gt;Python猫&lt;/strong&gt; 公众号作者）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP翻译计划&lt;/strong&gt; ：&lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;https://github.com/chinesehuazhou/peps-cn&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;摘要&lt;/h2&gt;
&lt;div&gt;标题已说明了一切——本 PEP 提议使用新的内置函数 print() 来替代 print 语句，并建议给此新函数使用特殊的签名（signature ）。&lt;/div&gt;
&lt;h2&gt;原理阐述&lt;/h2&gt;
&lt;div&gt;&lt;code&gt;print 语句&lt;/code&gt; 早就被列在了不可靠的语言特性列表中，例如 Guido 的“Python 之悔”（Python Regrets）演讲【1】，并计划在 Python 3000 版本移除。因此，本 PEP 的目的并不新鲜，尽管它可能会在 Python 开发人员中引起较大争议。&lt;/div&gt;
&lt;div&gt;以下对 print() 函数的争议是提取自 Guido 本人的 Python-3000 消息【2】：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;print 是唯一的应用程序级功能，并拥有专属的语句。在 Python 的世界里，当某些任务在不通过编译器的帮助就无法完成的情况下，语法（syntax）通常会被用作最后的手段。在这种异常情况下，print 并不合适。&lt;/li&gt;
&lt;li&gt;在开发应用程序的时候，人们经常需要用更复杂的东西来代替 print 输出，例如调用 logging，或者调用其它的 I/O 库。至于 print() 函数，这是个直截了当的字符替换，如今它混搭了所有那些括号，还可能会转换 &amp;gt;&amp;gt;stream 样式的语法。&lt;/li&gt;
&lt;li&gt;为 print 设置特殊的语法只会给进化带来一个更加巨大的屏障，例如这有个猜想，一个新的 printf() 函数不用多久就会出现，跟 print() 函数共存。&lt;/li&gt;
&lt;li&gt;当需要一个不同的分隔符（不是空格，或者没有分隔符）时，没有简单的方法可以将 print 语句转换成另一个调用。同样地，使用其它一些分隔符而非空格时，根本无法方便地打印对象。&lt;/li&gt;
&lt;li&gt;如果 print() 是个函数，就可以非常容易地在一个模块内替换它（仅需 def print(*args):…），甚至可以在整个程序内替换（例如放一个不同的方法进 __builtin__.print）。实际上，要做到这点，还可以写一个带 write() 方法的类，然后定向给 &lt;code&gt;sys.stdout&lt;/code&gt; ，这想法不错，但无疑是一个非常巨大的概念飞跃，而且跟 print 相比，它工作在不同的层级。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;设计规格&lt;/h2&gt;
&lt;div&gt;print() 的书写方式取自各种邮件，最近发布在 python-3000 列表里的是【3】：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;def print(*args, sep=&apos; &apos;, end=&apos;\n&apos;, file=None)&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;调用像：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;print(a, b, c, file=sys.stderr)&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;相当于当前的：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;print &amp;gt;&amp;gt;sys.stderr, a, b, c&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;可选的 sep 与 end 参数相应地指定了每个打印参数之间及之后的内容。&lt;/div&gt;
&lt;div&gt;&lt;code&gt;softspace&lt;/code&gt; 功能（当前在文件上的半秘密属性，用于告诉 print 是否要在第一个条目前插入空格）会被删除。因此，当前版本的以下写法不能被直接转换：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;print &quot;a&quot;,
print&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;它不会在“a”与换行符之间打印一个空格。&lt;/div&gt;
&lt;div&gt;（译注：在 3.3 版本，print() 函数又做了改动，增加了默认参数 flush=False）&lt;/div&gt;
&lt;h2&gt;向后兼容性&lt;/h2&gt;
&lt;div&gt;本 PEP 中提出的改动将致使如今的 print 语句失效。只有那些恰好用括号包围了所有参数的写法才能在 Python 3 版本中生效，至于其它，只有加上了括号的值才能保持原样打印。例如，在 2.x 中：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print (&quot;Hello&quot;)
Hello
&amp;gt;&amp;gt;&amp;gt; print (&quot;Hello&quot;, &quot;world&quot;)
(&apos;Hello&apos;, &apos;world&apos;)&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;而在 3.0 中：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print (&quot;Hello&quot;)
Hello
&amp;gt;&amp;gt;&amp;gt; print (&quot;Hello&quot;, &quot;world&quot;)
Hello world&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;幸运的是，因为 print 是 Python 2 中的一个语句，所以它可以被通过自动化工具而检测到，并可靠而精确地替换掉，因此应该没有重大的移植问题（如果有人来写这个工具的话）。&lt;/div&gt;
&lt;h2&gt;实现&lt;/h2&gt;
&lt;div&gt;更改将在 Python 3000 分支中实现（修订版从 53685 到 53704）。大多数在维库代码（legacy code）已经做转换了，但要抓出发行版本中的每个 print 语句，还需要持续不断地努力。&lt;/div&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;div&gt;[1] &lt;a href=&quot;http://legacy.python.org/doc/essays/ppt/regrets/PythonRegrets.pdf&quot;&gt;http://legacy.python.org/doc/essays/ppt/regrets/PythonRegrets.pdf&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[2]Python 3.0 替换 print（Guido van Rossum）&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056154.html&quot;&gt;https://mail.python.org/pipermail/python-dev/2005-September/056154.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[3] py3k 中 print() 的参数（Guido van Rossum）&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mail.python.org/pipermail/python-3000/2006-November/004485.html&quot;&gt;https://mail.python.org/pipermail/python-3000/2006-November/004485.html&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;版权&lt;/h2&gt;
&lt;div&gt;本文档已经放置在公共领域。源文档：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/python/peps/blob/master/pep-3105.txt&quot;&gt;https://github.com/python/peps/blob/master/pep-3105.txt&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>聊聊 Python 的内置电池</title>
            <link>https://pythoncat.top/posts/2019-06-15-batteries/</link>
            <guid>https://pythoncat.top/posts/2019-06-15-batteries/</guid>
            <pubDate>Sat, 15 Jun 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;（一）&lt;/div&gt;
&lt;div&gt;最近，我突然想到一个问题：&lt;strong&gt;相比其它语言，有哪些概念或习惯叫法是 Python 特有的？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;在朋友圈提出这个问题后，我得到最多的回复是——&lt;strong&gt;Pythonic&lt;/strong&gt; 。这个回复一点都不意外，名字中自带 Python 的，当然是特有的啦，与它相似的，还有 &lt;strong&gt;Pythonista&lt;/strong&gt; 。&lt;/div&gt;
&lt;div&gt;这两个词是啥意思呢？Python 圈内流传着一个说法“人生苦短，我用 Python”，人们相信存在着最佳的实践方式，采用这种方式是最美的、最高效的、最优雅的，也即是 Pythonic ，而这样做的人（或以此为追求的人）则自称是 Pythonista。这个称号是有别于 Pythoner 或者 Pythonist 的，简单地说就是，它更有追求、更有逼格。&lt;/div&gt;
&lt;div&gt;除了以上两个，Python 还有众多独特的叫法，例如终生仁慈独裁者、装饰器、上下文管理器、推导式与生成式、鸭子类型、猴子补丁、魔术方法、GIL、内置电池，等等。它们有的并不是 Python 所原创或独有，但是却因为它才广为人知，它们在 Python 中是代表性的存在物。&lt;/div&gt;
&lt;div&gt;（二）&lt;/div&gt;
&lt;div&gt;这些内容都很有意思，本文唯独想聊聊它——&lt;strong&gt;内置电池&lt;/strong&gt; 。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;code&gt;Batteries Included&lt;/code&gt; 这个叫法是 Python 特有的，它指的是 Python 拥有“内置电池”，也就是自带丰富多样的标准库，开箱即用，动力十足。&lt;/div&gt;
&lt;div&gt;在《PEP 206 — Python Advanced Library》中，它提出了“内置电池的哲学”（Batteries Included Philosophy）：拥有丰富而通用的标准库，无需用户单独下载就能立即使用。还说这使得 Python 领先于很多项目。&lt;/div&gt;
&lt;div&gt;根据官方文档显示，Python 内置了 200 多个标准库，类型丰富多样，包括字符处理、数据类型、数值计算、文件处理、并发执行、网络通信、多媒体服务、图形界面、调试与开发、以及操作系统专有服务等等。&lt;/div&gt;
&lt;div&gt;内置电池为 Python 提供了一种自给自足的能力（self-sufficient），在大多数情况下，用户不需要再去下载和安装单独的软件包，因此也免去一大堆的依赖问题的折磨。&lt;/div&gt;
&lt;div&gt;（三）&lt;/div&gt;
&lt;div&gt;某些编程语言中也有内置电池的概念，例如 Perl、Ruby、PHP等等，还有的语言会强调自己内置了强大的功能，例如 Erlang（一切皆进程）、Go（goroutine 机制）。&lt;/div&gt;
&lt;div&gt;然而，这个叫法在 Python 中被叫得最响，也被推广到了技术生态中的其它项目里，几乎成了 Python 的专有名词。&lt;/div&gt;
&lt;div&gt;在维基百科上搜索“Batteries Included”，该条目有 4 个解释，其中之一表明它是 Python 的 &lt;strong&gt;Motto&lt;/strong&gt; ，这个词的意思是座右铭、格言、箴言，足见分量之重了吧。&lt;/div&gt;
&lt;div&gt;（四）&lt;/div&gt;
&lt;div&gt;内置电池做不到无所不包，因此需要所谓的第三方库，而 Python 也以三方库丰富而闻名。&lt;/div&gt;
&lt;div&gt;&lt;code&gt;PyPI&lt;/code&gt; 是 &lt;strong&gt;Python Package Index&lt;/strong&gt; 的简称，即 Python 库索引，是一个用来管理三方库的项目，根据网站显示，目前有 18 万个三方库，以及它们的 135 万个发行版本。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;就是说，Python 也拥有强大的外置电池，所以其实它是 &lt;strong&gt;双驱动&lt;/strong&gt; 的。&lt;/div&gt;
&lt;div&gt;（五）&lt;/div&gt;
&lt;div&gt;双驱动本来相安无事，互为表里，但是，内置电池却遭到了越来越多的指责。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;在今年 5 月的官方 PyCon 大会上，演讲嘉宾 Amber Brown 做了专门的分享，主要话题就是吐槽这内置电池正在“漏电”（Leaking）：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;应用程序需要的不仅仅是标准库&lt;/li&gt;
&lt;li&gt;质量差，功能落后，代码过时&lt;/li&gt;
&lt;li&gt;标准库模块排挤创新&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;她的想法是移除一些标准库，例如 asyncio 及大多数的新特性，迁移到 PyPI，拥抱社区。这样做的预期效果是：内置电池会变得轻量小型化、高质量，同时三方库的生态系统也能得到进化。&lt;/div&gt;
&lt;div&gt;其他开发人员对这个话题也进行了讨论。&lt;/div&gt;
&lt;div&gt;标准库的维护团队表示，迁移部分模块的工作已经在展开了，但这需要经过仔细的设计，另外，不容忽视的是，迁移库到 PyPI 也要求测试配置的工作量。&lt;/div&gt;
&lt;div&gt;还有人提出反对意见，认为精简标准库可能会破坏下游代码，而且有的企业用户只信任标准库而排斥三方库，这无疑会增加用户的负担。&lt;/div&gt;
&lt;div&gt;（六）&lt;/div&gt;
&lt;div&gt;我们的很多电子设备都是由电池驱动的，虽然它们的形式与材质各种各样，但是不可避免会遇到老化的问题（某种手机甚至会爆炸）。&lt;/div&gt;
&lt;div&gt;Python 的内置电池也不例外，可是，这个电池的修理或替换，却不像物理世界的电池那般容易。&lt;/div&gt;
&lt;div&gt;官方在十几年前提出了 PEP-206 与 PEP-3108，那时核心开发者们就发现有些标准库容易被入侵、设计不佳、有更好的替代库，因此推荐了很多款第三方库，以作为标准库的替代选项。这些年来，很多废弃的库已退出舞台，但更多的新库也加了进来，革命尚未成功。&lt;/div&gt;
&lt;div&gt;今年 5 月，在 PyCon 大会引发的讨论之后，有开发者发起了 PEP-594，提议将“坏死的电池”（dead batteries）移出标准库。&lt;/div&gt;
&lt;div&gt;目前，该 PEP 仍处于草案（Draft）状态，但已基本成为社区共识。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;PEP 中提议移除工作从 Python 3.8 开始，因为它的发布时间刚好在 Python 2.7 停止维护之前，可以平滑地承接大版本迁移的用户。然后，按照有序的清理计划，最终在 Python 3.10 版本完成所有废弃模块的移除。&lt;/div&gt;
&lt;div&gt;也就是说，内置电池的“手术”加速了，未来几年里，这将成为一个常态。&lt;/div&gt;
&lt;div&gt;（七）&lt;/div&gt;
&lt;div&gt;内置电池的哲学助力了 Python 发展壮大，攻城略地，成为最主流的编程语言之一。&lt;/div&gt;
&lt;div&gt;然而它面临的挑战是：功能齐备与轻量可维的矛盾、官方支撑与社区分治的选择，因此，必然会走到今天的局面。&lt;/div&gt;
&lt;div&gt;正如任何大型项目都可能遇到内存泄漏与性能退化的问题一样，Python 这个项目也是。剔除坏死的组织，精兵简政，革故鼎新，跟上时代，这些是 Python 核心团队正在做的事。&lt;/div&gt;
&lt;div&gt;从去年末以来，我持续关注着 Python 最高决策层的选举，而在上个月，我恰好翻译了一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s/8KvQemz0SWq2hw-2aBPv2Q&quot;&gt;GIL 已经被杀死了么？&lt;/a&gt;》介绍了 GIL 的移除计划。&lt;/div&gt;
&lt;div&gt;这些事件都表明着一件事：&lt;strong&gt;Python 充满活力，大蟒蛇蜕皮后，将会迎来新生。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;我们何其幸运，正好作为见证者。其它就不用多说了，重温一下这个伟大的口号吧——人生苦短，我用 Python。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>遇见一只黑猫，她说Python是个怪物</title>
            <link>https://pythoncat.top/posts/2019-06-08-cat5/</link>
            <guid>https://pythoncat.top/posts/2019-06-08-cat5/</guid>
            <description>今天依然是些猫言猫语，请看官们不要嫌弃</description>
            <pubDate>Sat, 08 Jun 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;导读：&lt;/strong&gt; Python猫是一只喵星来客，它爱地球的一切，特别爱优雅而无所不能的 Python。我是它的人类朋友豌豆花下猫，被授权润色与发表它的文章。如果你是第一次看到这个系列文章，那我强烈建议，请先看看它写的前几篇文章（链接见文末），相信你一定会爱上这只神秘的哲学 + 极客猫的。不多说啦，一起来享用今天的“思想盛宴”吧！&lt;/div&gt;
&lt;div&gt;喵喵，读者朋友们好，我是来自喵星的客人，地球登记名为“Python猫”。今天终于能勉强抽出半日闲功夫，继续跟大家唠唠嗑啦。&lt;/div&gt;
&lt;div&gt;上回说到哪来着？时间竟然过去三个多月了，记忆曲线滑下高坡，猫言猫语已记不太清楚了。&lt;/div&gt;
&lt;div&gt;依稀记得是说了些“家国天下”的事，一个外来生物用一知半解的知识碎片，来曲意附和 Python 的几个空间领域，博君一笑。&lt;/div&gt;
&lt;div&gt;今天依然是些猫言猫语，请看官们不要嫌弃。我近来倾诉欲茂盛，急需写写文字打发一下，所以现在就开始吧。&lt;/div&gt;
&lt;div&gt;我正被一个问题困扰着：&lt;strong&gt;为什么她说程序员都是骗子？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;这个问题要从我遇见一只黑猫的时刻说起。&lt;/div&gt;
&lt;div&gt;那是一个星期三（记得清楚），我正在晚风凉凉的湖边散步，草丛中突然蹿出她来，一身纯黑的毛发，一双白玉般的眼睛，脚步像个侠客。&lt;/div&gt;
&lt;div&gt;我当时想，她或许也跟我一样，想要找个能说说话的朋友，毕竟这是猫的习性不是么？&lt;/div&gt;
&lt;div&gt;于是，就哼出了一支小曲，过去跟她搭讪。&lt;/div&gt;
&lt;div&gt;我问她是从哪来的？她说是在湖的那一边。&lt;/div&gt;
&lt;div&gt;我问她来湖的这边干嘛？她说就来看看。&lt;/div&gt;
&lt;div&gt;我问她看到了什么？她说很多草，几只蛐蛐和青蛙，还有一只野猫。&lt;/div&gt;
&lt;div&gt;她说起话来声音真是好听，我还从没听过那般悦耳的音线。&lt;/div&gt;
&lt;div&gt;可是，为什么要说我是“野猫”呢，明明我才是住在附近的那只，而她是从湖的另一边过来的，要说野的话，应该住得远的她是野才对。&lt;/div&gt;
&lt;div&gt;我想说她才是野猫，可是话刚说出口就后悔了，怕有冒犯，于是机智地改变了音调，最后说成：”你是一个 &lt;strong&gt;夜&lt;/strong&gt; 猫么？“&lt;/div&gt;
&lt;div&gt;她说是啊，所有的猫不都是夜猫么？&lt;/div&gt;
&lt;div&gt;我说我就不是啊。自从融入人类社会后，我学习了新的生活方式，现在更喜欢在白天活动。&lt;/div&gt;
&lt;div&gt;她甩出一个鄙夷的小眼神（好可爱），说一看我的眼睛就知道啦——长得像那湖里的水泡泡，黯淡无光。&lt;/div&gt;
&lt;div&gt;潜台词是说我没有兽性，丢掉了自己的本色吧？&lt;/div&gt;
&lt;div&gt;我着急地解释（辩解），说我的眼睛是“最蓝的晴天投照在最蓝的大海上的那抹蓝”、“光华赛过喜马拉雅矿山里最亮的宝石“、”气质与内涵在这个星球上无猫可敌”……&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;胡乱吹嘘，越说越不要脸，最后有点词穷。&lt;/div&gt;
&lt;div&gt;她露出似笑非笑的表情，沉默着，优雅地理了理灵巧的尾毛，一副见过世面不为所动的样子。&lt;/div&gt;
&lt;div&gt;我萎了一下，但还是不服气。&lt;/div&gt;
&lt;div&gt;“我叫 Python猫，敢问姑娘的芳名是？”先试探一下她的来历。&lt;/div&gt;
&lt;div&gt;“Python？！”&lt;/div&gt;
&lt;div&gt;她突然正脸凝视着我，迟疑地往后缩了一下身子，踏出一个警惕的招式。&lt;/div&gt;
&lt;div&gt;我先是一愣，然后立刻了然。嘿嘿，谅你不被我的盛世美颜迷惑，也不被我的巧舌如簧打动，可终究还是有所不知哒（毕竟 Python 是由人类中极优秀的程序员群体所打造的工具），而且终究还是有所畏惧的吧。&lt;/div&gt;
&lt;div&gt;我当时想着，她大概是知道 Python 的本意是&lt;strong&gt;蟒蛇&lt;/strong&gt; ，所以才会本能地防备起来，真是一只敏捷的猎手喵，要是打起架的话，我可能不是她的对手，不能招惹她，要是不小心被利爪刮一下，肯定就破相了……&lt;/div&gt;
&lt;div&gt;可是，做做样子吓吓她应该没事吧，她花容失色的时候是什么样子的呢……&lt;/div&gt;
&lt;div&gt;我正打着坏念头，舔了舔舌头，马上就要演出一副巨蟒飞扑的面貌。&lt;/div&gt;
&lt;div&gt;“你是说 Python，派森？”&lt;/div&gt;
&lt;div&gt;“是啊，怕了吗？” 我趁势造出蟒蛇吐信的“嘶嘶”声（舞了一下爪，但好像不对物，就收了下来）。&lt;/div&gt;
&lt;div&gt;“你是它的信徒吗？” 她更加警觉了。&lt;/div&gt;
&lt;div&gt;信徒？不是啊，我是个无神论者，不信神不信鬼，不拜太阳不拜月亮，不拜龙也不拜蛇，才不是谁谁的信徒呢。&lt;/div&gt;
&lt;div&gt;可是，这不好说破，好难得才博来的注目，当然要多留一会。&lt;/div&gt;
&lt;div&gt;因此我不置对否的看着她，还礼给她一声沉默。&lt;/div&gt;
&lt;div&gt;“我知道它。小时候在奶奶的百宝箱里找到了一本羊皮书，上面记载了很多远古的故事，其中就有这只怪物。”&lt;/div&gt;
&lt;div&gt;百宝箱和羊皮书？这只怪物？小黑猫到底是看了啥哟？&lt;/div&gt;
&lt;div&gt;“哦”，我装作漫不经意的样子，“你真的看过它的故事么？”&lt;/div&gt;
&lt;div&gt;“Python 是大地之母盖娅所生的巨蟒，诞生在远古丛林的尸体堆里，它是黑暗的使者，腐烂的化身，制造人间混乱的怪物。”&lt;/div&gt;
&lt;div&gt;“它是大地之母生的，可是样貌丑陋，没手没脚，就连神力也没有它的哥哥姐姐们那十二泰坦神厉害，因此怀恨在心，到处兴风作浪，涂炭生灵。”&lt;/div&gt;
&lt;div&gt;“这样的破坏神，不是怪物是什么？”&lt;/div&gt;
&lt;div&gt;喵喵了个大乖乖？这不是我认识的 Python，也不是我以为自己知道的蟒蛇啊！&lt;/div&gt;
&lt;div&gt;听起来倒像是一个吓唬小孩的神话故事。&lt;/div&gt;
&lt;div&gt;“喵，是它没错。” 我假意附和着。&lt;/div&gt;
&lt;div&gt;“一个穿黑衣服的女神怀了众神之王宙斯的孩子，宙斯的妻子赫拉嫉妒得怒火爆炸，就派这条巨蟒去追杀那女神。”&lt;/div&gt;
&lt;div&gt;“女神最后逃避到海中的一个荒岛，花了九天九夜，才生下了月亮女神阿尔忒弥斯和太阳神阿波罗。那只怪物差点害死了月亮女神呢。”&lt;/div&gt;
&lt;div&gt;说到这的时候，她眼里亮出一丝柔和的光，脸腮上的须毛也微微地颤了一下。&lt;/div&gt;
&lt;div&gt;我终于听到了熟悉的名字，原来她说的竟然是古希腊神话啊。&lt;/div&gt;
&lt;div&gt;我承认自己是无知的（仅限于对还没听过的事物而言），但对古希腊神话也是有所耳闻的，不就是一群关系乱七八糟、为了七情六欲打打杀杀、装腔作势的所谓天神嘛。&lt;/div&gt;
&lt;div&gt;只是我不知道还有这只巨蟒怪物罢了，Python 最早竟是它的名字啊？&lt;/div&gt;
&lt;div&gt;“后来呢？”神话故事也不错，我继续试探她。&lt;/div&gt;
&lt;div&gt;“后来等阿波罗长大了，就去找巨蟒复仇，经过一番大战，终于用弓箭把它射杀了。”&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;说完，她的眼神在一瞬间又变得非常锐利，看我的时候就像看一只死而复生的怪物。&lt;/div&gt;
&lt;div&gt;我被她盯得有点怕了（她的眼神会杀猫），知道不可能再装了，也不想跟那只远古神话中的怪兽沾上关系。&lt;/div&gt;
&lt;div&gt;于是，我就给她解释 Python 的现代含义，告诉她这是人类的一门编程语言，就是用来指挥计算机做事情的指令。&lt;/div&gt;
&lt;div&gt;然后，还说 Python 可以做这个，可以做那个，一口气说了好多。我不确定她听懂了多少。&lt;/div&gt;
&lt;div&gt;“那你是个程序员么？”她突然发问。&lt;/div&gt;
&lt;div&gt;“不是啦，可我认识很多程序员，而且我……”&lt;/div&gt;
&lt;div&gt;这时候，一阵冷飕飕的阴风吹来，草丛中吵吵闹闹的蛐蛐声和蛙鸣都突然闭了嘴。&lt;/div&gt;
&lt;div&gt;她悠悠地扇了扇耳朵，直了直腰身。&lt;/div&gt;
&lt;div&gt;“不是程序员就好，奶奶说程序员都是骗子”，她边说边转身，小跑两步，矫健地跃入草丛里。&lt;/div&gt;
&lt;div&gt;她的黑色身影飕飕地穿过野草，像一阵看不见的风，仿佛就不曾在我眼前出现过一般。&lt;/div&gt;
&lt;div&gt;可是夜风明确地传递来了她的最后一句话（依然是悦耳舒服的）——奶奶召我回家啦，再见了 Python 猫~~~&lt;/div&gt;
&lt;div&gt;我想要追上她，可是一股寒意压迫，竟然就迈不出脚。&lt;/div&gt;
&lt;div&gt;“喂，你还没有告诉我你的名字呢？”&lt;/div&gt;
&lt;div&gt;我大喊着。&lt;/div&gt;
&lt;div&gt;没有她的回声。&lt;/div&gt;
&lt;div&gt;只有风呼呼草沙沙，湖水荡荡，夜色朦胧，我失魂落魄。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;后来的很多天夜晚，我在湖边寻找她，可是都找不到。&lt;/div&gt;
&lt;div&gt;湖的这边没有，湖的那边也没有，湖东没有，湖西也没有。&lt;/div&gt;
&lt;div&gt;第一天没有，第二天没有，第好多天也没有。&lt;/div&gt;
&lt;div&gt;我想找到她，问问她的名字，还有问问她，为什么要说程序员都是骗子啊？&lt;/div&gt;
&lt;div&gt;我还想跟她说说话，告诉她我来自哪里，想要做些什么，好多话呢……&lt;/div&gt;
&lt;div&gt;喵喵，不知不觉聊了这么久。时间刚刚好，太阳下山啦，我就不跟你们闲话了。&lt;/div&gt;
&lt;div&gt;收拾收拾，打扮打扮，是时候该出门散步去啦。就此搁笔，后会有期哦~~~&lt;/div&gt;
&lt;div&gt;（未完待续……）&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python猫荐书系列之七：Python入门书籍有哪些？</title>
            <link>https://pythoncat.top/posts/2019-05-26-book7/</link>
            <guid>https://pythoncat.top/posts/2019-05-26-book7/</guid>
            <pubDate>Sun, 26 May 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;最近，猫哥的 Python 技术学习群里进来了几位比较特殊的同学：一位初三的以编程为兴趣的女生、一位在大学里刚开始执教 Python 的老师、一位四十多岁仍在编程一线的工程师。&lt;/div&gt;
&lt;div&gt;自从写公众号以来，我就遇到了各色各样的人，比如，一位代替小学生儿子来加群的牙医父亲、一位多年自由职业每天炒股的前黑客、一位来咨询课程的自学编程的听障人士……&lt;/div&gt;
&lt;div&gt;其实，这些人都是极少数的个例，读者里绝大部分应该都是在校学生、程序员或即将转行成为程序员的人，但是，这些身份特殊的少数人群却触动了我。&lt;/div&gt;
&lt;div&gt;一方面，我看到了 Python 的强大吸引力，另一方面，我也看到了 Python 学习群体的多元化。&lt;/div&gt;
&lt;div&gt;近些年，为什么各类培训机构会大行其道呢？也许正是因为这庞大而多元的学习人群，想要挤上通往 Python 引力中心的桥梁啊！&lt;/div&gt;
&lt;div&gt;我以前总是有意无意地忽略了这些读者的存在。前几天，我接了极客时间的一个专栏推广，在跟一些读者的互动中，以及在一些现象的观察中，我加深了对这些非主流人群的认识。&lt;/div&gt;
&lt;div&gt;意识到了这一点后，我想，或许我也能为他们做点什么？至少以后在写文章的时候，应该设法做到兼顾吧。&lt;/div&gt;
&lt;div&gt;正好，最近又有几位不同身份的初学者来咨询，要我推荐几本入门书籍，而我们荐书系列已经停更了两个多月，所以，本期荐书就来推荐一些入门书籍吧。&lt;/div&gt;
&lt;div&gt;为了准备这期荐书，我专门搜集了 40 本 Python 入门书籍，现在全部加入到了一份豆瓣豆列里，方便大家查看。&lt;/div&gt;
&lt;div&gt;先给大家看看完整的书单吧。&lt;/div&gt;
&lt;div&gt;豆列：&lt;a href=&quot;https://www.douban.com/doulist/114507342/&quot;&gt;https://www.douban.com/doulist/114507342/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《“笨办法”学Python》  &lt;a href=&quot;https://book.douban.com/subject/26264642/&quot;&gt;https://book.douban.com/subject/26264642/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《python学习手册（原书第5版）》&lt;a href=&quot;https://book.douban.com/subject/30364619/&quot;&gt;https://book.douban.com/subject/30364619/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Head First Python（中文版）》&lt;a href=&quot;https://book.douban.com/subject/10561367/&quot;&gt;https://book.douban.com/subject/10561367/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python基础教程（第3版）》&lt;a href=&quot;https://book.douban.com/subject/27667375/&quot;&gt;https://book.douban.com/subject/27667375/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python编程无师自通》&lt;a href=&quot;https://book.douban.com/subject/30419778/&quot;&gt;https://book.douban.com/subject/30419778/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《从Python开始学编程》&lt;a href=&quot;https://book.douban.com/subject/26919485/&quot;&gt;https://book.douban.com/subject/26919485/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python编程之美：最佳实践指南》&lt;a href=&quot;https://book.douban.com/subject/30314669/&quot;&gt;https://book.douban.com/subject/30314669/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python语言及其应用》 &lt;a href=&quot;https://book.douban.com/subject/26675127/&quot;&gt;https://book.douban.com/subject/26675127/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python编程：从入门到实践》 &lt;a href=&quot;https://book.douban.com/subject/26829016/&quot;&gt;https://book.douban.com/subject/26829016/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《像计算机科学家一样思考Python (第2版)》&lt;a href=&quot;https://book.douban.com/subject/26870407/&quot;&gt;https://book.douban.com/subject/26870407/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python编程快速上手》 &lt;a href=&quot;https://book.douban.com/subject/26836700/&quot;&gt;https://book.douban.com/subject/26836700/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python游戏编程快速上手》&lt;a href=&quot;https://book.douban.com/subject/26868640/&quot;&gt;https://book.douban.com/subject/26868640/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《爱上Python》&lt;a href=&quot;https://book.douban.com/subject/26807339/&quot;&gt;https://book.douban.com/subject/26807339/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python编程初学者指南》 &lt;a href=&quot;https://book.douban.com/subject/26287445/&quot;&gt;https://book.douban.com/subject/26287445/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python语言程序设计基础（第2版）》&lt;a href=&quot;https://book.douban.com/subject/27021033/&quot;&gt;https://book.douban.com/subject/27021033/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python语言程序设计》&lt;a href=&quot;https://book.douban.com/subject/26643589/&quot;&gt;https://book.douban.com/subject/26643589/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python入门经典》&lt;a href=&quot;https://book.douban.com/subject/11610789/&quot;&gt;https://book.douban.com/subject/11610789/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python入门经典》&lt;a href=&quot;https://book.douban.com/subject/26378143/&quot;&gt;https://book.douban.com/subject/26378143/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python编程导论（第2版）》&lt;a href=&quot;https://book.douban.com/subject/30155590/&quot;&gt;https://book.douban.com/subject/30155590/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《计算机编程导论—Python程序设计》&lt;a href=&quot;https://book.douban.com/subject/25839870/&quot;&gt;https://book.douban.com/subject/25839870/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《趣学Python编程》 &lt;a href=&quot;https://book.douban.com/subject/25837145/&quot;&gt;https://book.douban.com/subject/25837145/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python带我起飞：入门、进阶、商业实战》&lt;a href=&quot;https://book.douban.com/subject/30253254/&quot;&gt;https://book.douban.com/subject/30253254/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python趣味编程入门》&lt;a href=&quot;https://book.douban.com/subject/30310729/&quot;&gt;https://book.douban.com/subject/30310729/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《从问题到程序-用Python学编程和计算》&lt;a href=&quot;https://book.douban.com/subject/27076220/&quot;&gt;https://book.douban.com/subject/27076220/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《跟老齐学Python》&lt;a href=&quot;https://book.douban.com/subject/26987889/&quot;&gt;https://book.douban.com/subject/26987889/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《零基础学Python》&lt;a href=&quot;https://book.douban.com/subject/26414709/&quot;&gt;https://book.douban.com/subject/26414709/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python程序设计入门到实战》&lt;a href=&quot;https://book.douban.com/subject/26958121/&quot;&gt;https://book.douban.com/subject/26958121/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《从零开始学Python网络爬虫》&lt;a href=&quot;https://book.douban.com/subject/27180929/&quot;&gt;https://book.douban.com/subject/27180929/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《零基础学Python图文版》&lt;a href=&quot;https://book.douban.com/subject/26607568/&quot;&gt;https://book.douban.com/subject/26607568/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《教孩子学编程（Python语言版）》&lt;a href=&quot;https://book.douban.com/subject/26773320/&quot;&gt;https://book.douban.com/subject/26773320/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《父与子的编程之旅：与小卡特一起学Python》&lt;a href=&quot;https://book.douban.com/subject/26005639/&quot;&gt;https://book.douban.com/subject/26005639/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《学习Python：做个有编程能力的设计师》&lt;a href=&quot;https://book.douban.com/subject/26590884/&quot;&gt;https://book.douban.com/subject/26590884/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《零基础入门学习Python》&lt;a href=&quot;https://book.douban.com/subject/26966433/&quot;&gt;https://book.douban.com/subject/26966433/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《零压力学Python》&lt;a href=&quot;https://book.douban.com/subject/30234139/&quot;&gt;https://book.douban.com/subject/30234139/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《零基础学编程：树莓派和Python》&lt;a href=&quot;https://book.douban.com/subject/30262045/&quot;&gt;https://book.douban.com/subject/30262045/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python编程入门（第3版）》&lt;a href=&quot;https://book.douban.com/subject/25773122/&quot;&gt;https://book.douban.com/subject/25773122/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python语言入门》&lt;a href=&quot;https://book.douban.com/subject/1239501/&quot;&gt;https://book.douban.com/subject/1239501/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《可爱的Python》&lt;a href=&quot;https://book.douban.com/subject/3884108/&quot;&gt;https://book.douban.com/subject/3884108/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《Python编程入门经典》&lt;a href=&quot;https://book.douban.com/subject/6846632/&quot;&gt;https://book.douban.com/subject/6846632/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;《毫无障碍学Python》&lt;a href=&quot;https://book.douban.com/subject/27196748/&quot;&gt;https://book.douban.com/subject/27196748/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;40 本书，这份书单应该是面向 Python 初学者的最全书单了吧。&lt;/div&gt;
&lt;div&gt;我只翻阅过其中几本，其余的书都没看过，也不建议读者全部去读，之所以要搜集这么多，主要有如下考虑：读者面很广，而书种类不同，因此适宜多推荐。&lt;/div&gt;
&lt;div&gt;有些书适合完全零基础、有些书适合有编程基础；有些书面向高校学生、有些书面向小学生；有些书系统全面兼顾进阶内容、有些书简明基础适合快速上手；大部分书籍是外文翻译，少部分是国内原创；有些书是经典常销，有些书是新鲜热门；有些书偏重理论，有些书偏重实战……&lt;/div&gt;
&lt;div&gt;总之，总有一本适合你。&lt;/div&gt;
&lt;div&gt;需要声明一下，书单中都是已出版的中文书籍，都能在豆瓣上找到条目，除了这些，网上还有很多不错的入门书籍，例如《A Byte of Python》这本书的中文译本《简明Python教程》、Python 之父参与编写的《Python Tutorial》、知乎编辑整理的《编程小白学 Python》等等，无法一一罗列，但都可以作为参考之选。&lt;/div&gt;
&lt;div&gt;另外，以上书名的排序并不代表着推荐度的排序，已附上了豆瓣链接，建议你进入相应条目查看评分与评论，再做选择。&lt;/div&gt;
&lt;div&gt;我的建议是：先查阅相关介绍与评价，然后选择一两本来试读，如果阅读过程不顺畅，就换掉它，如果进展顺利的话，可以考虑再速看几本，交叉阅读，查漏补缺。&lt;/div&gt;
&lt;div&gt;如果你对这份书单有什么意见，例如建议补录某本书、分享对某本书的看法、补充学习资源、提供建立后续书单的建议，等等，欢迎给我留言。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;往期荐书回顾：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;第一期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/JnoYojDsNHYkpibSfF3hOg&quot;&gt;编写高质量代码改善 Python 程序的 91 个建议&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;第二期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/9RonAqwCXo_lganYvLHgVw&quot;&gt;Python最佳实践指南&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;第三期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/6swAZA7baF26BlrKV7zBFg&quot;&gt;黑客与画家&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;第四期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/RcvYm7Ro_nnMx0ZVrJmtyA&quot;&gt;Python源码剖析&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;第五期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/UxPxSJRHk0R6ffhpl8aSpw&quot;&gt;Python高性能编程&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;第六期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/XUL-xr0Nud5cTG2amatoXw&quot;&gt;深度学习&lt;/a&gt;》&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>GIL 已经被杀死了么？</title>
            <link>https://pythoncat.top/posts/2019-05-19-GIL/</link>
            <guid>https://pythoncat.top/posts/2019-05-19-GIL/</guid>
            <pubDate>Sun, 19 May 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 中最广为人诟病的一点，大概就是它的 GIL 了。由于 GIL 的存在，Python 无法实现真正的多线程编程，因此很多人都把这视作 Python 最大的软肋。&lt;/div&gt;
&lt;div&gt;PEP-554 提出后（2017年9月），大伙似乎看到了一线改善的曙光。然而，GIL 真的可以被彻底杀死么，如果可以的话，它会怎么实现呢，为什么等了一年多还没实现，仍需要我们等待多长时间呢？&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;&lt;strong&gt;英文&lt;/strong&gt;  | &lt;a href=&quot;https://hackernoon.com/has-the-python-gil-been-slain-9440d28fa93d&quot;&gt;Has the Python GIL been slain?&lt;/a&gt;【1】&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;作者&lt;/strong&gt;  | Anthony Shaw&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt;  | 豌豆花下猫&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;声明&lt;/strong&gt; ：本文获得原作者授权翻译，转载请保留原文出处，请勿用于商业或非法用途。&lt;/div&gt;
&lt;div&gt;2003 年初，Intel 公司推出了全新的奔腾 4 “HT” 处理器，该处理器的主频（译注：CPU 内核工作的时钟频率）为 3 GHz，采用了“超线程”技术。&lt;/div&gt;
&lt;div&gt;在接下来的几年中，Intel 和 AMD 激烈竞争，通过提高总线速度、L2 缓存大小和减小芯片尺寸以最大限度地减少延迟，努力地实现最佳的台式机性能。3Ghz 的 HT 在 2004 年被“Prescott”的 580 型号取代，该型号的主频高达 4 GHz。&lt;/div&gt;
&lt;div&gt;似乎提升性能的最好方法就是提高处理器的主频，但 CPU 却受到高功耗和散热会影响全球变暖的困扰。&lt;/div&gt;
&lt;div&gt;你电脑上有 4Ghz 的 CPU 吗？不太可能，因为性能的前进方式是更高的总线速度和更多的内核。Intel 酷睿 2 代在 2006 年取代了奔腾 4 ，主频远低于此。&lt;/div&gt;
&lt;div&gt;除了发布消费级的多核 CPU，2006 年还发生了其它事情，Python 2.5 发布了！Python 2.5 带来了人见人爱的 with 语句的 beta 版本 。&lt;/div&gt;
&lt;div&gt;在使用 Intel 的酷睿 2 或 AMD 的 Athlon X2 时，Python 2.5 有一个重要的限制——&lt;strong&gt;GIL&lt;/strong&gt; 。&lt;/div&gt;
&lt;h2&gt;什么是 GIL？&lt;/h2&gt;
&lt;div&gt;GIL 即全局解释器锁（Global Interpreter Lock），是 Python 解释器中的一个布尔值，受到互斥保护。这个锁被 CPython 中的核心字节码用来评估循环，并调节用来执行语句的当前线程。&lt;/div&gt;
&lt;div&gt;CPython 支持在单个解释器中使用多线程，但线程们必须获得 GIL 的使用权才能执行操作码（做低级操作）。这样做的好处是，Python 开发人员在编写异步代码或多线程代码时，完全不必操心如何获取变量上的锁，也不需担心进程因为死锁而崩溃。&lt;/div&gt;
&lt;div&gt;GIL 使 Python 中的多线程编程变得简单。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;GIL 还意味着虽然 CPython 可以是多线程的，但在任何给定的时间里只能执行 1 个线程。这意味着你的四核 CPU 会像上图一样工作 （减去蓝屏，但愿如此）。&lt;/div&gt;
&lt;div&gt;当前版本的 GIL &lt;a href=&quot;https://github.com/python/cpython/commit/074e5ed974be65fbcfe75a4c0529dbc53f13446f&quot;&gt;是在2009年编写的&lt;/a&gt; 【2】，用于支持异步功能，几乎没被改动地存活了下来，即使曾经多次试图删除它或减少对它的依赖。&lt;/div&gt;
&lt;div&gt;所有提议移除 GIL 的诉求是，它不应该降低单线程代码的性能。任何曾在 2003 年启用超线程（Hyper-Threading）的人都会明白为什么 &lt;a href=&quot;https://arstechnica.com/features/2002/10/hyperthreading&quot;&gt;这很重要&lt;/a&gt; 【3】。&lt;/div&gt;
&lt;h2&gt;在 CPython 中避免使用 GIL&lt;/h2&gt;
&lt;div&gt;如果你想在 CPython 中使用真正的并发代码，则必须使用多进程。&lt;/div&gt;
&lt;div&gt;在 CPython 2.6 中，标准库里增加了 &lt;code&gt;multiprocessing&lt;/code&gt; 模块。multiprocessing 是 CPython 大量产生的进程的包装器（每个进程都有自己的GIL）——&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt; Process

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&apos;hello&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; name

&lt;span&gt;if&lt;/span&gt; __name__ &lt;span&gt;==&lt;/span&gt; &lt;span&gt;&apos;__main__&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    p &lt;span&gt;=&lt;/span&gt; Process&lt;span&gt;(&lt;/span&gt;target&lt;span&gt;=&lt;/span&gt;f&lt;span&gt;,&lt;/span&gt; args&lt;span&gt;=&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;bob&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    p&lt;span&gt;.&lt;/span&gt;start&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    p&lt;span&gt;.&lt;/span&gt;join&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;进程可以从主进程中“孵出”，通过编译好的 Python 模块或函数发送命令，然后重新纳入主进程。&lt;/div&gt;
&lt;div&gt;&lt;code&gt;multiprocessing&lt;/code&gt; 模块还支持通过队列或管道共享变量。它有一个 Lock 对象，用于锁定主进程中的对象，以便其它进程能够写入。&lt;/div&gt;
&lt;div&gt;多进程有一个主要的缺陷：它在时间和内存使用方面的开销很大。CPython 的启动时间，即使没有非站点（no-site），也是 100-200ms（参见 &lt;a href=&quot;https://hackernoon.com/which-is-the-fastest-version-of-python-2ae7c61a6b2b&quot;&gt;这个链接 &lt;/a&gt;【4】）。&lt;/div&gt;
&lt;div&gt;因此，你可以在 CPython 中使用并发代码，但是你必须仔细规划那些长时间运行的进程，这些进程之间极少共享对象。&lt;/div&gt;
&lt;div&gt;另一种替代方案是使用像 Twisted 这样的三方库。&lt;/div&gt;
&lt;h2&gt;PEP-554 与 GIL 的死亡？&lt;/h2&gt;
&lt;div&gt;小结一下，CPython 中使用多线程很容易，但它并不是真正的并发，多进程虽然是并发的，但开销却极大。&lt;/div&gt;
&lt;div&gt;有没有更好的方案呢？&lt;/div&gt;
&lt;div&gt;绕过 GIL 的线索就在其名称中，全局 &lt;strong&gt;解释器&lt;/strong&gt; 锁是全局解释器状态的一部分。 CPython 的进程可以有多个解释器，因此可以有多个锁，但是此功能很少使用，因为它只通过 C-API 公开。&lt;/div&gt;
&lt;div&gt;在为 CPython 3.8 提出的特性中有个 PEP-554，提议实现子解释器（sub-interpreter），以及在标准库中提供一个新的带有 API 的 &lt;code&gt;interpreters&lt;/code&gt;  模块。&lt;/div&gt;
&lt;div&gt;这样就可以在 Python 的单个进程中创建出多个解释器。Python 3.8 的另一个改动是解释器都将拥有单独的 GIL ——&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;因为解释器的状态包含内存分配竞技场（memory allocation arena），即所有指向 Python 对象（局地和全局）的指针的集合，所以 PEP-554 中的子解释器无法访问其它解释器的全局变量。&lt;/div&gt;
&lt;div&gt;与多进程类似，在解释器之间共享对象的方法是采用 IPC 的某种形式（网络、磁盘或共享内存）来做序列化。在 Python 中有许多方法可以序列化对象，例如 &lt;code&gt;marshal&lt;/code&gt; 模块、 &lt;code&gt;pickle&lt;/code&gt; 模块、以及像 &lt;code&gt;json&lt;/code&gt; 和 &lt;code&gt;simplexml&lt;/code&gt; 这样更标准化的方法 。这些方法褒贬不一，但无一例外会造成额外的开销。&lt;/div&gt;
&lt;div&gt;最佳方案是开辟一块共享的可变的内存空间，由主进程来控制。这样的话，对象可以从主解释器发送，并由其它解释器接收。这将是 PyObject 指针的内存管理空间，每个解释器都可以访问它，同时由主进程拥有对锁的控制权。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这样的 API 仍在制定中，但它可能如下所示：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; _xxsubinterpreters &lt;span&gt;as&lt;/span&gt; interpreters
&lt;span&gt;import&lt;/span&gt; threading
&lt;span&gt;import&lt;/span&gt; textwrap &lt;span&gt;as&lt;/span&gt; tw
&lt;span&gt;import&lt;/span&gt; marshal

&lt;span&gt;# Create a sub-interpreter&lt;/span&gt;
interpid &lt;span&gt;=&lt;/span&gt; interpreters&lt;span&gt;.&lt;/span&gt;create&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# If you had a function that generated some data&lt;/span&gt;
arry &lt;span&gt;=&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# Create a channel&lt;/span&gt;
channel_id &lt;span&gt;=&lt;/span&gt; interpreters&lt;span&gt;.&lt;/span&gt;channel_create&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# Pre-populate the interpreter with a module&lt;/span&gt;
interpreters&lt;span&gt;.&lt;/span&gt;run_string&lt;span&gt;(&lt;/span&gt;interpid&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;import marshal; import _xxsubinterpreters as interpreters&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# Define a&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;interpid&lt;span&gt;,&lt;/span&gt; channel_id&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    interpreters&lt;span&gt;.&lt;/span&gt;run_string&lt;span&gt;(&lt;/span&gt;interpid&lt;span&gt;,&lt;/span&gt;
                            tw&lt;span&gt;.&lt;/span&gt;dedent&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;
        arry_raw = interpreters.channel_recv(channel_id)
        arry = marshal.loads(arry_raw)
        result = [1,2,3,4,5] # where you would do some calculating
        result_raw = marshal.dumps(result)
        interpreters.channel_send(channel_id, result_raw)
        &quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
               shared&lt;span&gt;=&lt;/span&gt;&lt;span&gt;dict&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;
                   channel_id&lt;span&gt;=&lt;/span&gt;channel_id
               &lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
               &lt;span&gt;)&lt;/span&gt;

inp &lt;span&gt;=&lt;/span&gt; marshal&lt;span&gt;.&lt;/span&gt;dumps&lt;span&gt;(&lt;/span&gt;arry&lt;span&gt;)&lt;/span&gt;
interpreters&lt;span&gt;.&lt;/span&gt;channel_send&lt;span&gt;(&lt;/span&gt;channel_id&lt;span&gt;,&lt;/span&gt; inp&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# Run inside a thread&lt;/span&gt;
t &lt;span&gt;=&lt;/span&gt; threading&lt;span&gt;.&lt;/span&gt;Thread&lt;span&gt;(&lt;/span&gt;target&lt;span&gt;=&lt;/span&gt;run&lt;span&gt;,&lt;/span&gt; args&lt;span&gt;=&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;interpid&lt;span&gt;,&lt;/span&gt; channel_id&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
t&lt;span&gt;.&lt;/span&gt;start&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# Sub interpreter will process. Feel free to do anything else now.&lt;/span&gt;
output &lt;span&gt;=&lt;/span&gt; interpreters&lt;span&gt;.&lt;/span&gt;channel_recv&lt;span&gt;(&lt;/span&gt;channel_id&lt;span&gt;)&lt;/span&gt;
interpreters&lt;span&gt;.&lt;/span&gt;channel_release&lt;span&gt;(&lt;/span&gt;channel_id&lt;span&gt;)&lt;/span&gt;
output_arry &lt;span&gt;=&lt;/span&gt; marshal&lt;span&gt;.&lt;/span&gt;loads&lt;span&gt;(&lt;/span&gt;output&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;output_arry&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;此示例使用了 numpy ，并通过使用 marshal 模块对其进行序列化来在通道上发送 numpy 数组 ，然后由子解释器来处理数据（在单独的 GIL 上），因此这会是一个计算密集型（CPU-bound）的并发问题，适合用子解释器来处理。&lt;/div&gt;
&lt;h2&gt;这看起来效率低下&lt;/h2&gt;
&lt;div&gt;&lt;code&gt;marshal&lt;/code&gt; 模块相当快，但仍不如直接从内存中共享对象那样快。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-0574/&quot;&gt;PEP-574 提出了一种新的 pickle &lt;/a&gt; 【5】协议（v5），它支持将内存缓冲区与 pickle 流的其余部分分开处理。对于大型数据对象，将它们一次性序列化，再由子解释器反序列化，这会增加很多开销。&lt;/div&gt;
&lt;div&gt;新的 API 可以（ 假想 ，并没有合入）像这样提供接口：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; _xxsubinterpreters &lt;span&gt;as&lt;/span&gt; interpreters
&lt;span&gt;import&lt;/span&gt; threading
&lt;span&gt;import&lt;/span&gt; textwrap &lt;span&gt;as&lt;/span&gt; tw
&lt;span&gt;import&lt;/span&gt; pickle

&lt;span&gt;# Create a sub-interpreter&lt;/span&gt;
interpid &lt;span&gt;=&lt;/span&gt; interpreters&lt;span&gt;.&lt;/span&gt;create&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# If you had a function that generated a numpy array&lt;/span&gt;
arry &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;# Create a channel&lt;/span&gt;
channel_id &lt;span&gt;=&lt;/span&gt; interpreters&lt;span&gt;.&lt;/span&gt;channel_create&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# Pre-populate the interpreter with a module&lt;/span&gt;
interpreters&lt;span&gt;.&lt;/span&gt;run_string&lt;span&gt;(&lt;/span&gt;interpid&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;import pickle; import _xxsubinterpreters as interpreters&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

buffers&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;# Define a&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;interpid&lt;span&gt;,&lt;/span&gt; channel_id&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    interpreters&lt;span&gt;.&lt;/span&gt;run_string&lt;span&gt;(&lt;/span&gt;interpid&lt;span&gt;,&lt;/span&gt;
                            tw&lt;span&gt;.&lt;/span&gt;dedent&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;
        arry_raw = interpreters.channel_recv(channel_id)
        arry = pickle.loads(arry_raw)
        print(f&quot;Got: {arry}&quot;)
        result = arry[::-1]
        result_raw = pickle.dumps(result, protocol=5)
        interpreters.channel_send(channel_id, result_raw)
        &quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
                            shared&lt;span&gt;=&lt;/span&gt;&lt;span&gt;dict&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;
                                channel_id&lt;span&gt;=&lt;/span&gt;channel_id&lt;span&gt;,&lt;/span&gt;
                            &lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
                            &lt;span&gt;)&lt;/span&gt;

&lt;span&gt;input&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; pickle&lt;span&gt;.&lt;/span&gt;dumps&lt;span&gt;(&lt;/span&gt;arry&lt;span&gt;,&lt;/span&gt; protocol&lt;span&gt;=&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; buffer_callback&lt;span&gt;=&lt;/span&gt;buffers&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;)&lt;/span&gt;
interpreters&lt;span&gt;.&lt;/span&gt;channel_send&lt;span&gt;(&lt;/span&gt;channel_id&lt;span&gt;,&lt;/span&gt; &lt;span&gt;input&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# Run inside a thread&lt;/span&gt;
t &lt;span&gt;=&lt;/span&gt; threading&lt;span&gt;.&lt;/span&gt;Thread&lt;span&gt;(&lt;/span&gt;target&lt;span&gt;=&lt;/span&gt;run&lt;span&gt;,&lt;/span&gt; args&lt;span&gt;=&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;interpid&lt;span&gt;,&lt;/span&gt; channel_id&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
t&lt;span&gt;.&lt;/span&gt;start&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# Sub interpreter will process. Feel free to do anything else now.&lt;/span&gt;
output &lt;span&gt;=&lt;/span&gt; interpreters&lt;span&gt;.&lt;/span&gt;channel_recv&lt;span&gt;(&lt;/span&gt;channel_id&lt;span&gt;)&lt;/span&gt;
interpreters&lt;span&gt;.&lt;/span&gt;channel_release&lt;span&gt;(&lt;/span&gt;channel_id&lt;span&gt;)&lt;/span&gt;
output_arry &lt;span&gt;=&lt;/span&gt; pickle&lt;span&gt;.&lt;/span&gt;loads&lt;span&gt;(&lt;/span&gt;output&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&lt;span&gt;f&quot;Got back: &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;output_arry&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;这看起来像极了很多样板&lt;/h3&gt;
&lt;div&gt;确实，这个例子使用的是低级的子解释器 API。如果你使用了多进程库，你将会发现一些问题。它不像 &lt;code&gt;threading&lt;/code&gt; 那么简单，你不能想着在不同的解释器中使用同一串输入来运行同一个函数（目前还不行）。&lt;/div&gt;
&lt;div&gt;一旦合入了这个 PEP，我认为 PyPi 中的其它一些 API 也会采用它。&lt;/div&gt;
&lt;h2&gt;子解释器需要多少开销？&lt;/h2&gt;
&lt;div&gt;&lt;strong&gt;简版回答&lt;/strong&gt;  ：大于一个线程，少于一个进程。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;详版回答&lt;/strong&gt; ：解释器有自己的状态，因此虽然 PEP-554 可以使创建子解释器变得方便，但它还需要克隆并初始化以下内容：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;strong&gt;main&lt;/strong&gt; 命名空间与 importlib 中的模块&lt;/li&gt;
&lt;li&gt;sys 字典的内容&lt;/li&gt;
&lt;li&gt;内置的方法（print、assert等等）&lt;/li&gt;
&lt;li&gt;线程&lt;/li&gt;
&lt;li&gt;核心配置&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;核心配置可以很容易地从内存克隆，但导入的模块并不那么简单。在 Python 中导入模块的速度很慢，因此，如果每次创建子解释器都意味着要将模块导入另一个命名空间，那么收益就会减少。&lt;/div&gt;
&lt;h3&gt;那么 asyncio 呢？&lt;/h3&gt;
&lt;div&gt;标准库中 &lt;code&gt;asyncio&lt;/code&gt; 事件循环的当前实现是创建需要求值的帧（frame），但在主解释器中共享状态（因此共享 GIL）。&lt;/div&gt;
&lt;div&gt;在 PEP-554 被合入后，很可能是在 Python 3.9，事件循环的替代实现 &lt;strong&gt;可能&lt;/strong&gt; 是这样（尽管还没有人这样干）：在子解释器内运行 async 方法，因此会是并发的。&lt;/div&gt;
&lt;h2&gt;听起来不错，发货吧！&lt;/h2&gt;
&lt;div&gt;额，还不可以。&lt;/div&gt;
&lt;div&gt;因为 CPython 已经使用单解释器的实现方案很长时间了，所以代码库的许多地方都在使用“运行时状态”（Runtime State）而不是“解释器状态”（Interpreter State），所以假如要将当前的 PEP-554 合入的话，将会导致很多问题。&lt;/div&gt;
&lt;div&gt;例如，垃圾收集器（在 3.7 版本前）的状态就属于运行时。&lt;/div&gt;
&lt;div&gt;在 &lt;strong&gt;PyCon sprint&lt;/strong&gt; 期间（译注：PyCon 是由 Python 社区举办的大型活动，作者指的是官方刚在美国举办的这场，时间是2019年5月1日至5月9日。sprint 是为期 1-4 天的活动，开发者们自愿加入某个项目，进行“冲刺”开发。该词被敏捷开发团队使用较多，含义与形式会略有不同），&lt;a href=&quot;https://github.com/python/cpython/pull/13219&quot;&gt;更改已经开始&lt;/a&gt; 【6】将垃圾收集器的状态转到解释器，因此每个子解释器将拥有它自己的 GC（本该如此）。&lt;/div&gt;
&lt;div&gt;另一个问题是在 CPython 代码库和许多 C 扩展中仍残存着一些“全局”变量。因此，当人们突然开始正确地编写并发代码时，我们可能会遭遇到一些问题。&lt;/div&gt;
&lt;div&gt;还有一个问题是文件句柄属于进程，因此当你在一个解释器中读写一个文件时，子解释器将无法访问该文件（不对 CPython 作进一步更改的话）。&lt;/div&gt;
&lt;div&gt;简而言之，还有许多其它事情需要解决。&lt;/div&gt;
&lt;h2&gt;结论：GIL 死亡了吗？&lt;/h2&gt;
&lt;div&gt;对于单线程的应用程序，GIL 仍然存活。因此，即便是合并了 PEP-554，如果你有单线程的代码，它也不会突然变成并发的。&lt;/div&gt;
&lt;div&gt;如果你想在 Python 3.8 中使用并发代码，那么你就会遇到计算密集型的并发问题，那么这可能是张入场券！&lt;/div&gt;
&lt;h2&gt;什么时候？&lt;/h2&gt;
&lt;div&gt;Pickle v5 和用于多进程的共享内存可能是在 Python 3.8（2019 年 10 月）实现，子解释器将介于 3.8 和 3.9 之间。&lt;/div&gt;
&lt;div&gt;如果你现在想要使用我的示例，我已经构建了一个分支，其中包含所有 &lt;a href=&quot;https://github.com/tonybaloney/cpython/tree/subinterpreters&quot;&gt;必要的代码 &lt;/a&gt;【7】&lt;/div&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;div&gt;[1] Has the Python GIL been slain? &lt;a href=&quot;https://hackernoon.com/has-the-python-gil-been-slain-9440d28fa93d&quot;&gt;https://hackernoon.com/has-the-python-gil-been-slain-9440d28fa93d&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[2] 是在2009年编写的: &lt;a href=&quot;https://github.com/python/cpython/commit/074e5ed974be65fbcfe75a4c0529dbc53f13446f&quot;&gt;https://github.com/python/cpython/commit/074e5ed974be65fbcfe75a4c0529dbc53f13446f&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[3] 这很重要: &lt;a href=&quot;https://arstechnica.com/features/2002/10/hyperthreading&quot;&gt;https://arstechnica.com/features/2002/10/hyperthreading&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[4] 这个链接 : &lt;a href=&quot;https://hackernoon.com/which-is-the-fastest-version-of-python-2ae7c61a6b2b&quot;&gt;https://hackernoon.com/which-is-the-fastest-version-of-python-2ae7c61a6b2b&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[5] PEP-574 提出了一种新的 pickle : &lt;a href=&quot;https://www.python.org/dev/peps/pep-0574/&quot;&gt;https://www.python.org/dev/peps/pep-0574/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[6] 更改已经开始: &lt;a href=&quot;https://github.com/python/cpython/pull/13219&quot;&gt;https://github.com/python/cpython/pull/13219&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[7] 必要的代码 : &lt;a href=&quot;https://github.com/tonybaloney/cpython/tree/subinterpreters&quot;&gt;https://github.com/tonybaloney/cpython/tree/subinterpreters&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>当 Python 中混进一只薛定谔的猫……</title>
            <link>https://pythoncat.top/posts/2019-05-16-cat/</link>
            <guid>https://pythoncat.top/posts/2019-05-16-cat/</guid>
            <pubDate>Thu, 16 May 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 是一门强大的动态语言，那动态体现在哪里，强大又体现在哪里呢？除了好的方面，Python 的动态性是否还藏着一些使用陷阱呢，有没有办法识别与避免呢？&lt;/div&gt;
&lt;div&gt;沿着它的动态特性话题，猫哥有几篇文章依次探及了：动态修改变量、动态定义函数、动态执行代码等内容，然而，当混合了变量赋值、动态赋值、命名空间、作用域、函数的编译原理等等内容时，问题就可能会变得非常棘手。&lt;/div&gt;
&lt;div&gt;因此，这篇文章将前面一些内容融汇起来，再做一次延展的讨论，希望能够理清一些使用的细节，更深入地探索 Python 语言的奥秘。&lt;/div&gt;
&lt;h2&gt;（1）疑惑重重的例子&lt;/h2&gt;
&lt;div&gt;先看看这一个例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# 例0
def foo():
    exec(&apos;y = 1 + 1&apos;)
    z = locals()[&apos;y&apos;]
    print(z)
    
foo()

# 输出：2&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;exec() 函数的代码块中定义了变量 y，这个值可以被随后的 locals() 取到，在赋值后也打印了出来。然而，在这个例子的基础上，只需做出小小的改变，结果就可能大不相同了。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# 例1
def foo():
    exec(&apos;y = 1 + 1&apos;)
    y = locals()[&apos;y&apos;]
    print(y)
    
foo()

# 报错：KeyError: &apos;y&apos;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;把前例的 z 改为 y ，就报错了。其中，&lt;code&gt;KeyError&lt;/code&gt; 指的是在字典中不存在对应的 key 。为什么会这样呢，新赋值的变量是 y 或者 z，为什么对结果有这么不同的影响？&lt;/div&gt;
&lt;div&gt;试试把 exec 去掉，不报错！&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# 例2
def foo():
    y = 1 + 1
    y = locals()[&apos;y&apos;]
    print(y)

foo()

# 2&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;问题：直接对 y 赋值，跟动态地在 exec() 中赋值，会对 locals() 取值产生怎样的影响？&lt;/div&gt;
&lt;div&gt;再试试对例 1 的 locals() 先赋值，还是报错：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# 例3
def foo():
    exec(&apos;y = 1 + 1&apos;)
    boc = locals()
    y = boc[&apos;y&apos;]
    print(y)
 
foo()

# KeyError: &apos;y&apos;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;先做一次赋值，难道没有用么？也不是，如果把赋值的顺序调前，就不报错了：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# 例4
def foo():
    boc = locals()
    exec(&apos;y = 1 + 1&apos;)
    y = boc[&apos;y&apos;]
    print(y)

foo()

# 2&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;也就是说，locals() 的值并不是固定的，它的值与调用时的上下文相关，调用 locals() 的时机至关重要。&lt;/div&gt;
&lt;div&gt;然而，如果想要验证一下，在函数中增加一个 locals() 的打印，这个动作却会影响到最终的执行结果。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# 例5
def foo():
    boc = locals()
    exec(&apos;y = 1 + 1&apos;)
    print(locals())
    y = boc[&apos;y&apos;]
    print(y)

foo()

# {&apos;boc&apos;: {...}}
# KeyError: &apos;y&apos;
&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这到底是怎么回事呢？&lt;/div&gt;
&lt;h2&gt;（2）多元知识的储备&lt;/h2&gt;
&lt;div&gt;以上例子在细微之处有较大的不同，主要由于以下知识点的影响：&lt;/div&gt;
&lt;div&gt;1、变量的声明与赋值&lt;/div&gt;
&lt;div&gt;2、locals() 取值与修改的逻辑&lt;/div&gt;
&lt;div&gt;3、locals() 字典与局部命名空间的关系&lt;/div&gt;
&lt;div&gt;4、函数的编译，抽象语法树的解析&lt;/div&gt;
&lt;div&gt;注意：exec() 函数有两个缺省的参数 globals() 与 locals() （与内置函数同名），起的是限定字符串参数中变量的作用，若添加出来，只会增加以上例子的复杂度，因此，我们都做缺省处理，这里讨论的是 exec() 只有一个参数的情况。&lt;/div&gt;
&lt;div&gt;在某些编程语言中，变量的声明与赋值是可以分开的，例如在声明时写 &lt;code&gt;int a &lt;/code&gt; ，需要赋值时，再写 &lt;code&gt;a = 1&lt;/code&gt; ，当然也可不拆分，则是 &lt;code&gt;int a = 1&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;对应到 Python 中，情况就不同了，这两个动作在书写时是合二为一的。首先它不用指定变量的类型，任何时候都不需要（也不能）在变量前加类型（如 int），其次，声明与赋值过程无法拆分书写，即只能写成 &lt;code&gt;a = 1&lt;/code&gt; 这样。看起来它跟其它语言的赋值写法一样，但实际上，它的效果是 &lt;code&gt;int a = 1&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;这虽然是一种便利，但也隐藏了一个不易察觉的陷阱（划重点）：&lt;strong&gt;当看到 &lt;code&gt;a = 1&lt;/code&gt; 时，你无法确定 a 是初次声明的，还是已被声明过的。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;关于 locals() 的创建过程，在《&lt;a href=&quot;https://mp.weixin.qq.com/s/f9BBe2W1X1p7NcHg665I4A&quot;&gt;Python 动态赋值的陷阱&lt;/a&gt;》文中有所分析，locals() 字典是局部命名空间的代理，它会采集局部作用域的变量，代码运行期若动态修改局部变量，只会影响该字典，并不会影响真正的局部作用域的变量。因此，当再次调用 locals() 时，由于重新采集，则动态修改的内容会被丢弃。&lt;/div&gt;
&lt;div&gt;运行期的局部命名空间不可改变，这意味着 exec() 函数中的变量赋值不会对它产生影响，但 locals() 字典是可变的，会受到 exec() 函数的影响。&lt;/div&gt;
&lt;div&gt;而关于函数的编译，我在《&lt;a href=&quot;https://mp.weixin.qq.com/s/EsWmCbH3RtL_QpafyMryOw&quot;&gt;Python与家国天下&lt;/a&gt;》中写到了对 &lt;strong&gt;抽象语法树&lt;/strong&gt; 的分析，Python 在编译时就确定了局部作用域内合法的变量名，在运行时再与内容绑定。作用域内变量的解析跟它的执行顺序无关，更与是否会被执行无关。&lt;/div&gt;
&lt;h2&gt;（3）薛定谔的猫&lt;/h2&gt;
&lt;div&gt;以上内容是前提，友情提示，如你有理解模糊之处，请先阅读对应的文章。接下来则是基于这些内容而作的分析。&lt;/div&gt;
&lt;div&gt;我不敢保证每个细节都准确无误，但这个分析力求达到深入浅出、面面俱到、逻辑自恰，而且顺便幽默有趣……&lt;/div&gt;
&lt;div&gt;例 0 中，局部作用域内虽然没有 ‘y’，但 exec() 函数动态创建了它，因此动态地写入了 locals() 字典中，所以能查找到而不报错。&lt;/div&gt;
&lt;div&gt;例 1 中，exec() 不影响局部作用域，即此时 y 未在局部作用域内做过声明与赋值，接下来的一句才是&lt;strong&gt;第一次在局部作用域中对 y 作声明与赋值&lt;/strong&gt; ！&lt;/div&gt;
&lt;div&gt;&lt;code&gt;y = locals()[&apos;y&apos;]&lt;/code&gt; ，等号左侧在做声明，只要等号右侧的结果成立，整个声明与赋值的过程就成立。右侧需在 locals() 字典中查找 y 对应的值。&lt;/div&gt;
&lt;div&gt;在创建 locals() 字典时，由于局部作用域内有变量 y 的声明，因此我们首先在其中采集到了 y，而不必在 exec() 函数的动态结果中查找。这就有了字典的一个 key，接着要匹配这个 key 对应的值，也即 y 所绑定的值。&lt;/div&gt;
&lt;div&gt;但是，刚才说了这是 y 的第一次赋值，并未完成呢，因此 y 并无有效的绑定值。&lt;/div&gt;
&lt;div&gt;矛盾出现了，这里有点绕，我们理一下：左侧的 y 等着完成赋值，因此需要右侧的执行结果；而右侧的字典需要使用到 y 的值，因此就依赖着左侧的 y 完成赋值。两边的操作都未完成，但双方都需要依赖对方先完成，这是个无法破解的死局。&lt;/div&gt;
&lt;div&gt;可以说，y 的值是一团混沌，它必然等于 “locals()[‘y’]” ，然而只有解开这团代码才能确切得到结果——只有打开笼子才知道结果，你是否想到了薛定谔的那只猫呢？&lt;/div&gt;
&lt;div&gt;locals() 字典虽然拿到了 y 的名，却拿不到它的实，空欢喜一场，所以报 KeyError。&lt;/div&gt;
&lt;div&gt;例 3 同理，未完成赋值就使用，所以报错。&lt;/div&gt;
&lt;div&gt;例 2 中，y 在二次赋值的过程时，局部命名空间中已经存在着有效的 y 等于 2，因此 locals() 查找到它而用于赋值，所以不报错。&lt;/div&gt;
&lt;div&gt;至于例 4，它跟例 3 只差了一个执行顺序，为什么不会报错呢？还有更奇怪的，在例 4 上再加一个打印（例5），理应不会影响结果，可事实却是又报错了，为什么？&lt;/div&gt;
&lt;div&gt;例 4 中，&lt;code&gt;boc = locals()&lt;/code&gt; 这句同样存在循环引用的问题，因此执行后的字典中没有 y，接着 exec() 这句动态地修改了 locals()，执行后 boc 的结果是 {‘y’ : 2}，因此再下一句的 boc[‘y’] 能查找到结果，而不报错。&lt;/div&gt;
&lt;div&gt;例 4 与例 3 的 ”y = boc[‘y’]“ ，虽然都是第一次在局部作用域中声明与赋值 y，但例 4 的 boc 已被 exec() 修改过，因此它能取到实实在在的值，就不再有循环引用的问题了。&lt;/div&gt;
&lt;div&gt;接着看例 5，第一个 locals() 还是存在循环引用现象，接着 exec() 往字典中写入变量 y，但是，第二个 locals() 又触发了新的创建字典过程，会把 exec() 的执行结果覆盖，因此进入第二轮循环引用，导致报错。&lt;/div&gt;
&lt;div&gt;例 5 与例 4 的不同在于，它是根据局部作用域重新生成的字典，其效果等同于例 3。&lt;/div&gt;
&lt;div&gt;另外，请特别注意打印的结果：&lt;strong&gt;{‘boc’: {…}}&lt;/strong&gt; 。&lt;/div&gt;
&lt;div&gt;这个结果说明，第二个 locals() 是一个字典，而且它只有唯一的 key 是 ’boc‘，而 ’boc‘ 映射的是第一个 locals() 字典，也即是 {…} 。这个写法表示它内部出现了循环引用，直观地证实了前面的所有分析。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;字典内部出现循环引用&lt;/strong&gt; ，这个现象极其罕见！前面虽然做了分析，但看到这里的时候，不知道你是否觉得不可思议？&lt;/div&gt;
&lt;div&gt;之所以第一次的循环引用能被记录下来，原因在于我们没有试图去取出 ’y‘ 的值，而第二个循环引用则由于取值报错而无法记录下来。&lt;/div&gt;
&lt;div&gt;这个例子告诉大家：&lt;strong&gt;薛定谔的猫混入了 Python 的字典中，而且答案是，打开笼子，这只猫就会死亡。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;字典的循环引用现象在几个例子中扮演了极其重要的角色，但是往往被人忽视。之所以难以被人觉察，原因还是前面划重点的内容：&lt;strong&gt;当看到 &lt;code&gt;a = 1&lt;/code&gt; 时，你无法确定 a 是初次声明的，还是已被声明过的。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;在《&lt;a href=&quot;https://mp.weixin.qq.com/s/EsWmCbH3RtL_QpafyMryOw&quot;&gt;Python与家国天下&lt;/a&gt;》文中，猫哥分析了两类经典的报错：name ‘x’ is not defined、local variable ‘x’ referenced before assignment。它们通常也是由于声明与赋值不分，而导致的失察。&lt;/div&gt;
&lt;div&gt;本文中的 KeyError 实际上就是 “local variable ‘y’ referenced before assignment”，y 已 defined 而未 assigned，导致 reference 时报错。&lt;/div&gt;
&lt;div&gt;已赋值还是未赋值，这是个问题。也是一只猫。&lt;/div&gt;
&lt;div&gt;最后，尽管这只猫在暗中捣了大乱，我们还是要感谢它：感谢它串联了其它知识被我们“一锅端”，感谢它为这篇抽象烧脑的文章挠出了几分活泼生动的趣味……（以及，感谢它带来的标题灵感，不知道有多少人是冲着标题而阅读的？）&lt;/div&gt;
&lt;h3&gt;后记&lt;/h3&gt;
&lt;div&gt;本文中的几个例子早在 3 月 24 日就想到了，但我没法给自己一套完全满意的解答。在与群内小伙伴们陆续讨论了一整个下午后，我依然不满足，最终打消了写入《&lt;a href=&quot;https://mp.weixin.qq.com/s/6V8z2Gr94PpLbbUUo1K3AQ&quot;&gt;深度辨析 Python 的 eval() 与 exec()&lt;/a&gt;》这篇文章的念头。两个月来，群内偶尔讨论过几次相关的知识点，感谢好几位同学（特别@樱雨楼）的讨论，我终于觉得时机到了（其实是稿荒啦），把沉睡近两个月的草稿翻出来……如今的分析，我自认为是能说得通，而且关键细节无遗漏的，但仍可能有瑕疵，如果你有什么想交流的，欢迎给我留言。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>5 月 5 日记于合肥</title>
            <link>https://pythoncat.top/posts/2019-05-05-hefei/</link>
            <guid>https://pythoncat.top/posts/2019-05-05-hefei/</guid>
            <pubDate>Sun, 05 May 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;此刻，我坐在安徽合肥的一家“几何书店”里，写下这些文字。&lt;/div&gt;
&lt;div&gt;这趟行程是豌豆在一两个月前就定了下来的，事关她的职业发展规划与调整，终于在她裸辞之后的第一周成行。&lt;/div&gt;
&lt;div&gt;在多次起心动念，又退缩接受的循环后，她下定了决心裸辞，我也坚定地拥护。&lt;/div&gt;
&lt;div&gt;裸辞之后有啥打算呢？不如就好好放松一段时间吧，居家写写稿子。&lt;/div&gt;
&lt;div&gt;这趟合肥之行，也是想给未来找点方向。&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;好巧不巧，非常偶然的时机，她在昨晚得到了一个应聘机会，还挺感兴趣的。&lt;/div&gt;
&lt;div&gt;这个机会来自 X 同学的转发。&lt;/div&gt;
&lt;div&gt;之所以说非常偶然，是因为我们好久没有联系了，直到昨天，他突然说他也来了苏州，准备在这工作定居。&lt;/div&gt;
&lt;div&gt;X 同学是我们在大学的读书会里的好友。好像他最初是学测绘或者水利之类，然后转专业去学的历史，曾在阿里实习过，当产品经理，后来在 TP-Link 工作，上一次有印象他的动态是在东南亚某国出差。&lt;/div&gt;
&lt;div&gt;昨天，他突然说也来了苏州工作。&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;他来这，是因为她的老婆。跟我一样。&lt;/div&gt;
&lt;div&gt;于是，D 夫妇与 X 夫妇就约了一起吃饭。&lt;/div&gt;
&lt;div&gt;X 夫妇都是江西人，前几年都在深圳工作。他们双双裸辞来了苏州，重新找工作，长远打算是在这边定居的。&lt;/div&gt;
&lt;div&gt;X 夫人从小对苏州向往，也是来此定居的主要动因。对话中得知，他们曾去长沙“考察”过，但最终放弃了这个选项。&lt;/div&gt;
&lt;div&gt;他们是家中独生子女，成婚一年，未孕育。来苏州，无亲无故(除了刚联系上我们)。&lt;/div&gt;
&lt;div&gt;我们对他们的这项果敢的行为都很佩服。&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;谈论工作，谈论房价和买房地点，谈论很接近的云南旅游，谈论食物，谈论业余生活。&lt;/div&gt;
&lt;div&gt;豌豆评价说，他们是她近一年里遇到的最有趣/有意思的人。这次交谈很开心。&lt;/div&gt;
&lt;div&gt;他们建议，如果我们还不想生小孩的话，可以考虑去深圳或者广州找工作，换个城市生活。&lt;/div&gt;
&lt;div&gt;我当然没有此打算——除非豌豆想去。&lt;/div&gt;
&lt;div&gt;X 同学说了句，在一家公司工作一年就觉得很长了。但他又说，在某某地方买房，不住就出租，只需要二十年就可以回本。&lt;/div&gt;
&lt;div&gt;这大概就是“时间相对论”吧。时间可长可短。&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;他们都是率性而为的人。&lt;/div&gt;
&lt;div&gt;我们倒显得顾虑重重。&lt;/div&gt;
&lt;div&gt;我很多时候保守得像个七零后，而豌豆跨出了她九零后的一步。&lt;/div&gt;
&lt;div&gt;这趟合肥之行，不知能给我们的工作/事业带来什么影响。&lt;/div&gt;
&lt;div&gt;对水沉默，人生几何。&lt;/div&gt;
&lt;div&gt;在来的路上，我开玩笑说，几何书店的“几何”肯定不是数学上的“几何”，而是对酒当歌人生几何的“几何”。&lt;/div&gt;
&lt;div&gt;几何几何，不知几何？&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;昨天饭桌上，她们都说更喜欢城市，喜欢人多热闹的地方。&lt;/div&gt;
&lt;div&gt;我相反，更喜欢人少的自然风光，像山川河流、原始森林、飞禽走兽。而且喜欢看纪录片，而不是亲身而往。&lt;/div&gt;
&lt;div&gt;这种喜好当然是品性的折射，但很微妙。&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;来了合肥，我观察到几件小事。&lt;/div&gt;
&lt;div&gt;我们坐的 4 路公交车上，竟然有 4 个门，除了常见的右侧两个，它的左侧也有。这意味着这里的车，有时候是靠左侧停的？&lt;/div&gt;
&lt;div&gt;第二件，这里有些车站不是在路边，而是在路中央，公交车行内侧车道，乘客下车后先上天桥，再选择下去的方向。&lt;/div&gt;
&lt;div&gt;第三件，空中白絮纷飞，我快速反应这是柳絮，然而看看路边，一棵柳树都没有，再看看源头，那是一种很像法国梧桐的树，但还无法确认。&lt;/div&gt;
&lt;div&gt;白絮纷纷从树上落下，我想起第一次看到这样的场景是在十几年前的一棵木棉树下。后来，这个图景被替换成了柳树。再如今，它换成了一个新的树种。&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;昨天我们聊到了城市间迁移的话题。&lt;/div&gt;
&lt;div&gt;豌豆开玩笑说，苏州这个地方就像围城，有的人想进来，有的人在想出去。&lt;/div&gt;
&lt;div&gt;最后我们没有深入讨论怎么与围城长久共处的内容。&lt;/div&gt;
&lt;div&gt;现在坐在书店里，我突然发觉，这是关于“走出去与走进来”的问题。&lt;/div&gt;
&lt;div&gt;城市也罢，工作也罢，记忆也罢，习性也罢，爱情也罢，梦境也罢，不都是“走出去与走进来”么？&lt;/div&gt;
&lt;div&gt;需要一个角度审视，需要一个偏离的位置来获得角度，需要一个迁移的行动来进入新的位置。&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;2019.05.05，豆花记录于合肥几何书店。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>听说苏州是互联网的荒漠，真的吗？</title>
            <link>https://pythoncat.top/posts/2019-05-02-suzhou/</link>
            <guid>https://pythoncat.top/posts/2019-05-02-suzhou/</guid>
            <pubDate>Thu, 02 May 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;我国互联网存在着巨大的地域性偏差，除了北上广深杭外，其它省市的互联网都很弱小。去年 8 月，某个公众号发布了一篇《上海不相信互联网》的文章，引起了多方的讨论。CSDN 公众号以此为契机，陆续发布了关于南京、东北、西安、甚至德国等地的互联网发展情况的文章。&lt;/div&gt;
&lt;div&gt;作为一个“苏漂”程序员，我有幸得到了 CSDN 编辑的约稿，因此也给苏州写了一篇。这篇文章并不是专业的行业观察，有些观点缺乏客观的数据支撑，还有一些理应关注的内容因为资料不足而被迫删除，所以整体而言，这篇文章只是&lt;strong&gt;个人之见&lt;/strong&gt; 。它是一个开端吧，今后我会持续关注苏州互联网的发展，再分享我的见闻与思考。&lt;/div&gt;
&lt;div&gt;该文已授权给 CSDN 公众号发布原创，我转载于此，主要是调整了排版。欢迎就文中内容与我交流。如需转载，请联系 CSDN 公众号。&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;本文首发于 CSDN 公众号&lt;/div&gt;
&lt;div&gt;发布标题：《&lt;a href=&quot;https://mp.weixin.qq.com/s/wpUcD5EHdiHz97pnXMKveQ&quot;&gt;苏州到底有没有互联网？&lt;/a&gt;》&lt;/div&gt;
&lt;h2&gt;01 苏州印象&lt;/h2&gt;
&lt;div&gt;说起苏州，你的第一印象是什么？&lt;/div&gt;
&lt;div&gt;是“上有天堂，下有苏杭”、“苏湖熟，天下足”，是烟雨楼台中的江南古城吧？&lt;/div&gt;
&lt;div&gt;是“姑苏城外寒山寺，夜半钟声到客船”，是文人墨客游园林品昆曲哼评弹，是传续历史文化底蕴的代表吧？&lt;/div&gt;
&lt;div&gt;是背靠上海、独占江苏鳌头的现代大都市，是 GDP 排行全国第七名，是非省会或直辖市的城市中的领头羊吧？&lt;/div&gt;
&lt;div&gt;没错，这些都是苏州印象，复古与现代相融合，文化与经济共繁荣。&lt;/div&gt;
&lt;div&gt;它有近 2500 年历史，是中国首批国家历史文化名城之一，它的园林被联合国教科文组织列为世界文化遗产，它的大运河区段也入选了世界遗产名录。&lt;/div&gt;
&lt;div&gt;它的工业总产值居全国第一，进出口总额排全国前三，城市总人口超过 1000 万，是国内第二大的移民城市。&lt;/div&gt;
&lt;div&gt;2018 年 8 月，英国经济学人智库（EIU）发布了年度《全球宜居城市排行榜》，苏州市蝉联成为中国内地最宜居城市，再次超越北上广！&lt;/div&gt;
&lt;div&gt;2018 年 11 月，福布斯中国发布了《创新力最强的30城市》，苏州市排名第 3 ，超越上海和广州！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这就是苏州。苏州就是这样。&lt;/div&gt;
&lt;div&gt;然而，在这一连串的光鲜亮丽背后，苏州也有自己的痛——它从未培育过一家互联网独角兽，甚至不及苏北的宿迁，后者至少养育出了一位互联网巨头“大强子”。&lt;/div&gt;
&lt;div&gt;苏州拥有庞大的经济体量，但它的存在感并不强，互联网的实力与自身并不匹配。坊间传言，苏州是互联网的荒漠，这是真的么？&lt;/div&gt;
&lt;h2&gt;02 互联网荒漠&lt;/h2&gt;
&lt;div&gt;南京是苏州终生的劲敌/兄弟，CSDN 曾发布过一篇《“南京才不相信互联网呢”》，介绍了它的互联网状况。&lt;/div&gt;
&lt;div&gt;该文把南京比作是“互联网沙漠之城”，我完全不认同——说是沙漠就太过分啦，南京远不到贫瘠无力的地步，说得那么苦寒兮兮的，把混得更惨的其它城市置于何地呢？&lt;/div&gt;
&lt;div&gt;如果要把北上广深杭，比作互联网的几片树林的话，南京大概是一圈草地吧，苏州反而才是绿植更加稀疏的荒漠。&lt;/div&gt;
&lt;div&gt;在那篇文章的留言区，有读者这样留言：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;比起南京，苏州更是寸草不生。&lt;/p&gt;
&lt;p&gt;苏州的互联网还是婴儿。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;苏州和南京，千年古城也，一省两强，明争暗斗，不分伯仲。&lt;/div&gt;
&lt;div&gt;而在当今的互联网浪潮中，它们距离第一梯队都太远，终于落后成了一对难兄难弟。&lt;/div&gt;
&lt;div&gt;数一数本地知名的互联网公司吧。南京有苏宁、途牛旅游、西祠胡同，苏州有同程旅游、蜗牛游戏、聚合数据。什么？这里有你不知道的？别抱怨了，再多数几家，你很可能也不认识（而我也数不出来）。&lt;/div&gt;
&lt;div&gt;这就是它们惨淡的互联网环境：没有巨头，小头公司不成气候，有的据说甚至遭到了 BAT 的嫌弃。&lt;/div&gt;
&lt;div&gt;哦，差点忘了。苏州还有一张突然空降来的王牌呢——360 安全公司，就是周鸿祎的那家呢。去年，经过一番眼花缭乱的操作，它竟变成了一家苏州的企业！&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;不过，这就是个空壳罢了，像什么“ 霍尔果斯XXX影视公司 ”一样，资本面具而已。&lt;/div&gt;
&lt;div&gt;当然，有一些互联网巨头是真的入驻了苏州的，例如华为、阿里巴巴、百度、微软、IBM，初来时可能还提出过“打造 xxx，提升 xxx”的响亮口号。&lt;/div&gt;
&lt;div&gt;然而，它们派来的都不是互联网核心的业务，本着精明的商人心计，它们当然是来捞取政策红利与人才储备的，可不是来播撒互联网种子的。&lt;/div&gt;
&lt;div&gt;可话说回来，即便是有大资本来苏州吹出一个风口，它就能站对位置，就能被吹得起来么？&lt;/div&gt;
&lt;div&gt;苏州是否容得下互联网，能否发展好互联网呢？&lt;/div&gt;
&lt;h2&gt;03 一座古城&lt;/h2&gt;
&lt;div&gt;从诸多方面来看，苏州都只是一座慢节奏的古城。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;它对互联网的很多新鲜事物都免疫。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;例如近两三年，共享单车群雄并起，但即便是在它们最激进的攻城略地时期，苏州也始终置身事外，不受战火纷扰。就我所见，只有极稀少的几辆小黄车，我一度怀疑它们是从周边城市偷渡进来的…&lt;/div&gt;
&lt;div&gt;苏州是最早实行“禁车令”的极少数大城市之一，当时我初来乍到，作为一个“苏漂”新人，我给苏州的评价是：&lt;strong&gt;不够开放包容，缺少冒险精神。&lt;/strong&gt; 这恰恰就是“互联网精神”的内核之一。&lt;/div&gt;
&lt;div&gt;但是如今再看，风光褪去的共享单车仿佛一场考验市民公德与揭露资本嘴脸的闹剧。苏州虽然没有感受到新物种的红利，却也躲过了它的反噬。&lt;/div&gt;
&lt;div&gt;实际上，苏州有自己的“公共自行车”系统，自 2010 年启动，有桩停车点覆盖了很多生活小区、交通站点、商业体和其它场所。政府投入了巨大的成本来推动 &lt;strong&gt;有序的&lt;/strong&gt; 绿色出行，成果显著，这大概也是“禁车令”的主要考虑吧。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这座古城自有自己的发展规划，面对热闹的互联网诱惑，她倒是能“守身如玉”。&lt;/div&gt;
&lt;div&gt;共享单车或许还不够“互联网”，但其它的互联网风口也吹不动苏州。&lt;/div&gt;
&lt;div&gt;就看最近几年的大事件吧，在团购网站的“千团大战”、网约车的大战、以及直播与短视频的大战中，牌桌上可有苏州本土的企业呢？好像没有吧！这些可没有碰上“禁 X 令”。&lt;/div&gt;
&lt;div&gt;苏州严重依赖于第二产业，一直是上海制造业的转移地，但同时，金融与科技等第三产业想要在大上海的“黑洞”边发展，就太难了。&lt;/div&gt;
&lt;div&gt;苏州的高等教育严重落后，综合性大学仅有一家苏州大学（211，非985）。在最新发布的《武书连 2019 中国大学排行榜》中，苏州大学取得历史性最好排名 24 名，其它本地高校排名在 300 开外。&lt;/div&gt;
&lt;div&gt;造血能力不足，能少点被上海、南京和杭州吸血，就很不错了。&lt;/div&gt;
&lt;div&gt;苏州本地人喜欢安逸，享受着城市扩张的红利，持有多套房产坐收房租的大有人在。本地年轻人早早婚嫁，靠着啃老支付房贷车贷，拿着一份入不敷出的工资，也活得毫无压力。最后高房价不知吓软了多少外地人的腿。&lt;/div&gt;
&lt;div&gt;在地理空间上，苏州也是相对封闭的。坐拥 8000 多平方公里的土地以及 1000 万人口，它竟然没有建成一个机场。苏州与浙江省之间至今也没有直通的铁路，唯一相通的高速公路还是两车道的，阻碍了高效的跨省域协作。&lt;/div&gt;
&lt;div&gt;苏州就是这样一座古城，养老有余，拼搏不足，家底殷实，环境封闭。&lt;/div&gt;
&lt;div&gt;外地的互联网企业能走进来已然不错，本地互联网企业若想壮大走出去，则举步维艰。&lt;/div&gt;
&lt;div&gt;苏州本地成长起来最大的互联网公司是同程网，它于 2003 年上线，主营在线旅游代理业务，到 2010 年，其综合实力排名全国第三。然而到 2013 年，携程发起猛烈的价格战，同程被迫迎战，一个季度就烧掉了十年的利润，元气大伤。&lt;/div&gt;
&lt;div&gt;此后，BAT 纷纷入局，万达也成立万达旅业想分一杯羹，同程顿时陷入了危机重重的局面。&lt;/div&gt;
&lt;div&gt;最后它被资本招安，与艺龙合并。2018 年 11 月，同程艺龙在港股上市，如今第一大股东是腾讯，第二大股东是携程，公司注册地也变为了北京。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;苏州互联网企业发展之路的艰难，在同程的身上能看到一个缩影。&lt;/div&gt;
&lt;div&gt;苏州是互联网的荒漠，事实不容争辩。那么，它的未来出路在哪呢？&lt;/div&gt;
&lt;h2&gt;04 苏州互联网的未来&lt;/h2&gt;
&lt;div&gt;互联网已经深切地改变了我们的生活，智能手机的普及降低了人们“触网”的门槛。&lt;/div&gt;
&lt;div&gt;对于广大用户来说，互联网没有地域之分，人们根本不关心提供服务的是哪个地方的企业。&lt;/div&gt;
&lt;div&gt;不像购买手机时，有人会选择支持国产，互联网用户更在乎的是服务本身，而不在乎谁是提供者——哪家打车平台折扣大就用哪家、哪家外卖平台做活动就选哪家、哪家短视频更抓眼球就用哪家。平台间的迁移成本几乎为零，用户没有忠诚度可言。&lt;/div&gt;
&lt;div&gt;互联网公司相互比拼谁的市场占有率高，谁构建的护城河高，以规模优势打压和吞并竞争对手。强者更强，剩者为王。&lt;/div&gt;
&lt;div&gt;近年来兴风作浪的资本教育了大众两个词汇：烧钱与割韭菜。&lt;/div&gt;
&lt;div&gt;从这个视角来看，苏州是幸运的。用户要的是优质的互联网服务，至于它是不是由本地企业提供的，又有何区别的？把节省下来的钱用在实业上，不是更有意义么？&lt;/div&gt;
&lt;div&gt;寸有所长，尺有所短，苏州互联网的未来出路应该是：&lt;strong&gt;扬长补短，走出一条特色的苏州互联网道路。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;根据中国互联网络信息中心最新发布的《第43次中国互联网络发展状况统计报告》，网信独角兽企业出现极端的“贫富分化”——北上广浙占去 92.1%，其它省市仅有 7.9%。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这说明了什么？除了这四地，&lt;strong&gt;全国其它地方都是互联网的荒漠啊！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;苏州不是互联网强市，这没啥可否认的，但也不值得妄自菲薄。并不是非要夺得某个领域的互联网头把交椅，才有自尊与荣耀。&lt;/div&gt;
&lt;div&gt;都说现在是“互联网下半场”，人工智能、大数据、物联网、5G是未来的大趋势。怎么把这些技术与现有的工业基础相结合，这才是苏州最迫切的研究课题。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;消费互联网的红利将尽，工业互联网的时代即将来临。&lt;/strong&gt; 苏州的未来不是消费互联网，而是工业互联网。我国为了甩掉低端制造业的身份，逐年加码推动工业互联网的发展，这对苏州来说是极大的利好。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;通过政策引导、资金补贴、规范标准、政府部署等一系列动作，苏州加快了工业互联网的建设。&lt;/div&gt;
&lt;div&gt;2016 年，由工业 4.0 俱乐部、中国工控网等单位主办，苏州召开了第一届“中国工业服务产业互联网大会”。2018 年，苏州成立了苏州市工业互联网产业联盟。&lt;/div&gt;
&lt;div&gt;苏州也开始跑起来了。也许不要几年，它的互联网局面将改善起来，像遍地的小绿车，在这片荒漠上长出一个活力四射的春天。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>sum() 函数性能堪忧，列表降维有何良方？</title>
            <link>https://pythoncat.top/posts/2019-04-26-sum/</link>
            <guid>https://pythoncat.top/posts/2019-04-26-sum/</guid>
            <pubDate>Fri, 26 Apr 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 的内置函数 sum() 可以接收两个参数，当第一个参数是二维列表，第二个参数是一维列表的时候，它可以实现列表降维的效果。&lt;/div&gt;
&lt;div&gt;在上一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/cr_noDx6s1sZ6Xt6PDpDVQ&quot;&gt;如何给列表降维？sum()函数的妙用&lt;/a&gt;》中，我们介绍了这个用法，还对 sum() 函数做了扩展的学习。&lt;/div&gt;
&lt;div&gt;那篇文章发布后，猫哥收到了一些很有价值的反馈，不仅在知识面上获得了扩充，在思维能力上也得到了一些启发，因此，我决定再写一篇文章，继续跟大家聊聊 sum() 函数以及列表降维。若你读后有所启发，欢迎留言与我交流。&lt;/div&gt;
&lt;div&gt;有些同学表示，没想到 sum() 函数竟然可以这么用，涨见识了！猫哥最初在交流群里看到这种用法时，也有同样的想法。整理成文章后，能得到别人的认可，我非常开心。&lt;/div&gt;
&lt;div&gt;学到新东西，进行分享，最后令读者也有所获，这鼓舞了我——应该每日精进，并把所学分享出去。&lt;/div&gt;
&lt;div&gt;也有的同学早已知道 sum() 的这个用法，还指出它的性能并不好，不建议使用。这是我不曾考虑到的问题，但又不得不认真对待。&lt;/div&gt;
&lt;div&gt;是的，sum() 函数做列表降维有奇效，但它性能堪忧，并不是最好的选择。&lt;/div&gt;
&lt;div&gt;因此，本文想继续探讨的话题是：&lt;strong&gt;（1）sum() 函数的性能到底差多少，为什么会差？（2）既然 sum() 不是最好的列表降维方法，那是否有什么替代方案呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;在 &lt;code&gt;stackoverflow&lt;/code&gt; 网站上，有人问了个“&lt;a href=&quot;https://stackoverflow.com/questions/952914/how-to-make-a-flat-list-out-of-list-of-lists&quot;&gt;How to make a flat list out of list of lists&lt;/a&gt;”问题，正是我们在上篇文章中提出的问题。在回答中，有人分析了 7 种方法的时间性能。&lt;/div&gt;
&lt;div&gt;先看看测试代码：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; functools
&lt;span&gt;import&lt;/span&gt; itertools
&lt;span&gt;import&lt;/span&gt; numpy
&lt;span&gt;import&lt;/span&gt; operator
&lt;span&gt;import&lt;/span&gt; perfplot

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;forfor&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;item &lt;span&gt;for&lt;/span&gt; sublist &lt;span&gt;in&lt;/span&gt; a &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; sublist&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;sum_brackets&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;functools_reduce&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; functools&lt;span&gt;.&lt;/span&gt;&lt;span&gt;reduce&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;operator&lt;span&gt;.&lt;/span&gt;concat&lt;span&gt;,&lt;/span&gt; a&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;functools_reduce_iconcat&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; functools&lt;span&gt;.&lt;/span&gt;&lt;span&gt;reduce&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;operator&lt;span&gt;.&lt;/span&gt;iconcat&lt;span&gt;,&lt;/span&gt; a&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;itertools_chain&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;itertools&lt;span&gt;.&lt;/span&gt;chain&lt;span&gt;.&lt;/span&gt;from_iterable&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;numpy_flat&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;numpy&lt;span&gt;.&lt;/span&gt;array&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;flat&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;numpy_concatenate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;numpy&lt;span&gt;.&lt;/span&gt;concatenate&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

perfplot&lt;span&gt;.&lt;/span&gt;show&lt;span&gt;(&lt;/span&gt;
    setup&lt;span&gt;=&lt;/span&gt;&lt;span&gt;lambda&lt;/span&gt; n&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; n&lt;span&gt;,&lt;/span&gt;
    kernels&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;
        forfor&lt;span&gt;,&lt;/span&gt; sum_brackets&lt;span&gt;,&lt;/span&gt; functools_reduce&lt;span&gt;,&lt;/span&gt; functools_reduce_iconcat&lt;span&gt;,&lt;/span&gt;
        itertools_chain&lt;span&gt;,&lt;/span&gt; numpy_flat&lt;span&gt;,&lt;/span&gt; numpy_concatenate
        &lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    n_range&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;**&lt;/span&gt;k &lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    logx&lt;span&gt;=&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    logy&lt;span&gt;=&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    xlabel&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;num lists&apos;&lt;/span&gt;
    &lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;代码囊括了最具代表性的 7 种解法，使用了 &lt;code&gt;perfplot&lt;/code&gt; （注：这是该测试者本人开发的库）作可视化，结果很直观地展示出，随着数据量的增加，这几种方法的效率变化。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;从测试图中可看出，当数据量小于 10 的时候，sum() 函数的效率很高，但是，随着数据量增长，它所花的时间就出现剧增，远远超过了其它方法的损耗。&lt;/div&gt;
&lt;div&gt;值得注意的是，functools_reduce 方法的性能曲线几乎与 sum_brackets 重合。&lt;/div&gt;
&lt;div&gt;在另一个回答中，有人也做了 7 种方法的性能测试（巧合的是，所用的可视化库也是测试者自己开发的），在这几种方法中，functools.reduce 结合 lambda 函数，虽然写法不同，它的时间效率与 sum() 函数也基本重合：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; itertools &lt;span&gt;import&lt;/span&gt; chain
&lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt; &lt;span&gt;reduce&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt; Iterable  &lt;span&gt;# or from collections.abc import Iterable&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; operator
&lt;span&gt;from&lt;/span&gt; iteration_utilities &lt;span&gt;import&lt;/span&gt; deepflatten

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;nested_list_comprehension&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lsts&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;item &lt;span&gt;for&lt;/span&gt; sublist &lt;span&gt;in&lt;/span&gt; lsts &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; sublist&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;itertools_chain_from_iterable&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lsts&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;chain&lt;span&gt;.&lt;/span&gt;from_iterable&lt;span&gt;(&lt;/span&gt;lsts&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;pythons_sum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lsts&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lsts&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;reduce_add&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lsts&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;reduce&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;lambda&lt;/span&gt; x&lt;span&gt;,&lt;/span&gt; y&lt;span&gt;:&lt;/span&gt; x &lt;span&gt;+&lt;/span&gt; y&lt;span&gt;,&lt;/span&gt; lsts&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;pylangs_flatten&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lsts&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;flatten&lt;span&gt;(&lt;/span&gt;lsts&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;flatten&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;items&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;Yield items from any nested iterable; see REF.&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; items&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt; Iterable&lt;span&gt;)&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;bytes&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; flatten&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;yield&lt;/span&gt; x

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;reduce_concat&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lsts&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;reduce&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;operator&lt;span&gt;.&lt;/span&gt;concat&lt;span&gt;,&lt;/span&gt; lsts&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;iteration_utilities_deepflatten&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lsts&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;deepflatten&lt;span&gt;(&lt;/span&gt;lsts&lt;span&gt;,&lt;/span&gt; depth&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;


&lt;span&gt;from&lt;/span&gt; simple_benchmark &lt;span&gt;import&lt;/span&gt; benchmark

b &lt;span&gt;=&lt;/span&gt; benchmark&lt;span&gt;(&lt;/span&gt;
    &lt;span&gt;[&lt;/span&gt;nested_list_comprehension&lt;span&gt;,&lt;/span&gt; itertools_chain_from_iterable&lt;span&gt;,&lt;/span&gt; pythons_sum&lt;span&gt;,&lt;/span&gt; reduce_add&lt;span&gt;,&lt;/span&gt;
     pylangs_flatten&lt;span&gt;,&lt;/span&gt; reduce_concat&lt;span&gt;,&lt;/span&gt; iteration_utilities_deepflatten&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    arguments&lt;span&gt;=&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;**&lt;/span&gt;i&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;**&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    argument_name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;number of inner lists&apos;&lt;/span&gt;
&lt;span&gt;)&lt;/span&gt;

b&lt;span&gt;.&lt;/span&gt;plot&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这就证实了两点：sum() 函数确实性能堪忧；它的执行效果实际是每个子列表逐一相加（concat）。&lt;/div&gt;
&lt;div&gt;那么，问题来了，&lt;strong&gt;拖慢 sum() 函数性能的原因是啥呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;在它的实现源码中，我找到了一段注释：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;/* It&apos;s tempting to use PyNumber_InPlaceAdd instead of
PyNumber_Add here, to avoid quadratic running time
when doing &apos;sum(list_of_lists, [])&apos;.  However, this
would produce a change in behaviour: a snippet like

empty = []
sum([[x] for x in range(10)], empty)

would change the value of empty. */&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;为了不改变 sum() 函数的第二个参数值，CPython 没有采用就地相加的方法（PyNumber_InPlaceAdd），而是采用了较耗性能的普通相加的方法（PyNumber_Add）。这种方法所耗费的时间是二次方程式的（quadratic running time）。&lt;/div&gt;
&lt;div&gt;为什么在这里要牺牲性能呢？我猜想（只是浅薄猜测），可能有两种考虑，一是为了第二个参数（start）的一致性，因为它通常是一个数值，是不可变对象，所以当它是可变对象类型时，最好也不对它做修改；其次，为了确保 sum() 函数是个 &lt;code&gt;纯函数&lt;/code&gt; ，为了多次执行时能返回同样的结果。&lt;/div&gt;
&lt;div&gt;那么，我要继续问：&lt;strong&gt;哪种方法是最优的呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;综合来看，当子列表个数小于 10 时，sum() 函数几乎是最优的，与某几种方法相差不大，但是，当子列表数目增加时，最优的选择是 functools.reduce(operator.iconcat, a, [])，其次是 list(itertools.chain.from_iterable(a)) 。&lt;/div&gt;
&lt;div&gt;事实上，最优方案中的 iconcat(a, b) 等同于 a += b，它是一种就地修改的方法。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;operator.iconcat(a, b)
operator.__iconcat__(a, b)
a = iconcat(a, b) is equivalent to a += b for a and b sequences.&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这正是 sum() 函数出于一致性考虑，而舍弃掉的实现方案。&lt;/div&gt;
&lt;div&gt;至此，前文提出的问题都找到了答案。&lt;/div&gt;
&lt;div&gt;我最后总结一下吧：&lt;strong&gt;sum() 函数采用的是非就地修改的相加方式，用作列表降维时，随着数据量增大，其性能将是二次方程式的剧增，所以说是性能堪忧；而 reduce 结合 iconcat 的方法，才是大数据量时的最佳方案。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;这个结果是否与你所想的一致呢？希望本文的分享，能给你带来新的收获。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;如何给列表降维？sum()函数的妙用 ：&lt;a href=&quot;https://mp.weixin.qq.com/s/cr_noDx6s1sZ6Xt6PDpDVQ&quot;&gt;https://mp.weixin.qq.com/s/cr_noDx6s1sZ6Xt6PDpDVQ&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;stackoverflow 问题：&lt;a href=&quot;https://stackoverflow.com/questions/952914/how-to-make-a-flat-list-out-of-list-of-lists&quot;&gt;https://stackoverflow.com/questions/952914/how-to-make-a-flat-list-out-of-list-of-lists&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 为什么用 len() 函数，不用 x.len() 风格？</title>
            <link>https://pythoncat.top/posts/2019-04-21-len/</link>
            <guid>https://pythoncat.top/posts/2019-04-21-len/</guid>
            <pubDate>Sun, 21 Apr 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;为什么 Python 要用 len 括号 x  这种内置函数的写法，而不像其它的面向对象语言，用 x 点 len 括号 的写法？&lt;/div&gt;
&lt;div&gt;三个主要的原因：&lt;/div&gt;
&lt;div&gt;原因一：将 len 设计成内置函数，直接读取底层的 C 结构体，这样速度会更快。&lt;/div&gt;
&lt;div&gt;这个原因在《流畅的 Python》这本书中有所介绍。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;我在 2013 年问核心开发者 Raymond Hettinger 这个问题时，他用“Python 之禅”里的原话回答了我：“实用胜于纯粹。”在 1.2 节里我提到过，如果 x是一个内置类型的实例，那么 len(x)的速度会非常快。背后的原因是 CPython 会直接从一个 C 结构体里读取对象的长度，完全不会调用任何方法。获取一个集合中元素的数量是一个很常见的操作，在 str、list、memoryview等类型上，这个操作必须高效。&lt;/p&gt;
&lt;p&gt;换句话说，len之所以不是一个普通方法，是为了让 Python 自带的数据结构可以走后门，abs也是同理。但是多亏了它是特殊方法，我们也可以把 len用于自定义数据类型。这种处理方式在保持内置类型的效率和保证语言的一致性之间找到了一个平衡点，也印证了“Python 之禅”中的另外一句话：“不能让特例特殊到开始破坏既定规则。”&lt;/p&gt;
&lt;p&gt;如果把abs和 len都看作一元运算符的话，你也许更能接受它们——虽然看起来像面向对象语言中的函数，但实际上又不是函数。有一门叫作 ABC 的语言是 Python 的直系祖先，它内置了一个 #运算符，当你写出 #s的时候，它的作用跟 len一样。如果写成 x#s这样的中缀运算符的话，那么它的作用是计算 s中 x出现的次数。在 Python 里对应的写法是 s.count(x)。注意这里的 s是一个序列类型。&lt;/p&gt;
&lt;p&gt;——出自该书《1.4　为什么len不是普通方法》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;原因二：前缀符号更可读，简单胜过复杂！&lt;/div&gt;
&lt;div&gt;原因三：见名知意，看见 len 函数就知道它是用来求长度的。但是看见 x.len() 方法，它实际可能并不是求长度，只是恰好叫这个名字！&lt;/div&gt;
&lt;div&gt;后两个原因是我转述了 Python 之父的解释。&lt;/div&gt;
&lt;div&gt;除此之外，我还有自己的观点：我认为这是对世界本质的洞察！求长度是一种共性操作，就像分数 ½ 中的横线，与具体对象无关！所以，就应该设计成一个内置函数！&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;原题：len(x) 击败 x.len()，从内置函数看 Python 的设计思想&lt;/h2&gt;
&lt;div&gt;内置函数是 Python 的一大特色，用极简的语法实现很多常用的操作。&lt;/div&gt;
&lt;div&gt;它们预先定义在内置命名空间中，开箱即用，所见即所得。Python 被公认是一种新手友好型的语言，这种说法能够成立，内置函数在其中起到了极关键的作用。&lt;/div&gt;
&lt;div&gt;举个例子，求字符串 x 的长度，Python 的写法是 len(x) ，而且这种写法对列表、元组和字典等对象也同样适用，只需要传入对应的参数即可。len() 函数是共用的。&lt;/div&gt;
&lt;div&gt;这是一种极简哲学的体现：&lt;strong&gt;Simple is better than complex。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;但是，有些语言并不是这样，例如在 Java 中，字符串类有一个求长度的方法，其它类也有自己的求长度的方法，它们无法共用。每次使用时，通过类或实例来调用。&lt;/div&gt;
&lt;div&gt;同样是求字符串长度，Python 的写法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;saying &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Hello world!&quot;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;saying&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 结果：12&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;而在 Java 中，写法可能如下（简化起见）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;String&lt;/span&gt; saying &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Hello world!&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;out&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;saying&lt;span&gt;.&lt;/span&gt;&lt;span&gt;length&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

&lt;span&gt;// 结果：12&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 采用的是一种&lt;strong&gt;前缀表达式&lt;/strong&gt; ，而 Java 采用的则是&lt;strong&gt;后缀表达式&lt;/strong&gt; 。&lt;/div&gt;
&lt;div&gt;除了求长度，Python 的某些内置函数也能在 Java 中找到对应的表达。例如，数值型字符串 s 转化为整型数字，Python 可以用 &lt;code&gt;int(s)&lt;/code&gt; 函数，而 Java 可以用 &lt;code&gt;Integer.parseInt(s)&lt;/code&gt; ；整型数字转化为字符串，Python 可以用 &lt;code&gt;str(i)&lt;/code&gt; ，而 Java 也有 &lt;code&gt;String.valueOf(i)&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;Python 的内置函数不与特定的类绑定，它们是一级对象。而 Java 的“函数”则无法脱离类而存在，它们只是附属品。&lt;/div&gt;
&lt;div&gt;从直观角度来看，Python 的表达似乎是更优的。但是，它们&lt;strong&gt;并不具有可比性&lt;/strong&gt; ，因为这是两套语言系统，各有独特的范畴背景，并不能轻易地化约。&lt;/div&gt;
&lt;div&gt;就好比是，不能因为拉丁字母笔画简单，就说它优于汉字，因为在表意时，字母（表音文字）是远逊于汉字（表意文字）的。同样的，日本借用了汉字的偏旁部首而造出来的文字，虽然更省笔墨，但是也完全丧失了意蕴。&lt;/div&gt;
&lt;div&gt;以此类比，Python 的内置函数虽有简便之美，但却丢失了某些表意功能。有些人在质疑/抨击 Python 的时候，也喜欢拿这点说事，认为这是 Python 的设计缺陷。&lt;/div&gt;
&lt;div&gt;这就引出本文最想讨论的一个问题来：&lt;strong&gt;为什么 Python 要设计成 len(x) 这种前缀表达，而不是 x.len() 这样的后缀表达呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;事实上，后缀设计也是可行的，以 Python 中列表的两个方法为例：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;mylist &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

mylist&lt;span&gt;.&lt;/span&gt;sort&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mylist&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# [1, 2, 3, 4, 5]&lt;/span&gt;

mylist&lt;span&gt;.&lt;/span&gt;reverse&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mylist&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# [5, 4, 3, 2, 1]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;它们都是通过列表对象来调用，并不是凭空从内置命名空间中拿来的。语义表达得也很清楚，就是对 mylist 做排序和逆转。&lt;/div&gt;
&lt;div&gt;恰恰那么巧，它们还有两个同父异母的兄弟 sorted() 与 reversed()，这俩是前缀表达型。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;mylist &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

sort_list &lt;span&gt;=&lt;/span&gt; &lt;span&gt;sorted&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mylist&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;sort_list&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# [1, 2, 3, 4, 5]&lt;/span&gt;

reverse_list &lt;span&gt;=&lt;/span&gt; &lt;span&gt;reversed&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mylist&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;reverse_list&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# [4, 5, 3, 1, 2]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;不同的写法，都在做同一件事（不考虑它们的副作用）。因此，后缀语法并非不可行，之所以不用，那肯定是刻意的设计。&lt;/div&gt;
&lt;div&gt;回到前面的问题：为什么是 len(x) ，而不是 x.len(x)，这根源于 Python 的什么设计思想呢？&lt;/div&gt;
&lt;div&gt;Python 之父 &lt;strong&gt;Guido van Rossum&lt;/strong&gt; 曾经解释过这个问题（ #TODO: add link），有两个原因：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;对于某些操作，前缀符比后缀更好读——前缀（和中缀）表示法在数学中有着悠久的历史，其视觉效果有助于数学家思考问题。我们可以简单地把公式 &lt;code&gt;x*(a + b)&lt;/code&gt;  重写成 &lt;code&gt;x*a + x*b&lt;/code&gt; ，但同样的事，以原生的面向对象的方式实现，就比较笨拙。&lt;/li&gt;
&lt;li&gt;当读到 len(x) 时，我就 &lt;strong&gt;知道&lt;/strong&gt; 这是在求某对象的长度。它告诉我了两点：返回值是一个整数，参数是某种容器。但当读到 x.len() 时，我必须事先知道某种容器 x，它实现了一个接口，或者继承了一个拥有标准 len() 方法的类。我们经常会目睹到这种混乱：一个类并没有实现映射（mapping）接口，却拥有 get() 或 keys() 方法，或者某些非文件对象，却拥有一个 write() 方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;解释完这两个原因之后，Guido 还总结成一句话说：“I see ‘len’ as a built-in &lt;em&gt;operation&lt;/em&gt; ”。这已经不仅是在说 len() 更可读易懂了，而完全是在拔高 len() 的地位。&lt;/div&gt;
&lt;div&gt;这就好比说，分数 ½ 中的横线是数学中的一个“内置”表达式，并不需要再实现什么接口之类的，它自身已经表明了“&lt;strong&gt;某数除以某数&lt;/strong&gt; ”的意思。不同类型的数（整数、浮点数、有理数、无理数…）共用同一个操作符，不必为每类数据实现一种求分数的操作。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;优雅易懂是 Python 奉行的设计哲学&lt;/strong&gt; ，len() 函数的前缀表达方式是最好的体现。我想起 Guido 对“&lt;strong&gt;为什么索引从 0 开始&lt;/strong&gt; ”的解释。其最重要的原因，也正是 0-based 索引最优雅易懂。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;出自《&lt;a href=&quot;https://python-history.blogspot.com/2013/10/why-python-uses-0-based-indexing.html&quot;&gt;The History of Python: Why Python uses 0-based indexing&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;让我们来先看看切片的用法。可能最常见的用法，就是“取前 n 位元素”或“从第i 位索引起，取后 n 位元素”(前一种用法，实际上是 i == 起始位的特殊用法)。如果这两种用法实现时可以不在表达式中出现难看的 +1 或 -1，那将会非常的优雅。&lt;/p&gt;
&lt;p&gt;使用 0-based 的索引方式、半开区间切片和缺省匹配区间的话（Python最终采用这样的方式），上面两种情形的切片语法就变得非常漂亮：a[:n] 和 a[i:i+n]，前者是 a[0:n] 的缩略写法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;所以，我们能说 len(x) 击败 x.len() ，支撑它的是一种化繁为简、纯粹却深邃的设计思想。&lt;/div&gt;
&lt;div&gt;面向对象的编程语言自发明时起，就想模拟我们生活于其中的现实世界。可是什么类啊、接口啊、对象啊、以及它们的方法啊，这些玩意的毒，有时候蒙蔽了我们去看见世界本质的眼睛。&lt;/div&gt;
&lt;div&gt;桌子类有桌子类的求长度方法，椅子类有椅子类的求长度方法，无穷无尽，可现实真是如此么？求长度的方法就不能是一种独立存在的对象么？它之所以存在，是因为有“对象”存在，而不是因为有某个类才存在啊。&lt;/div&gt;
&lt;div&gt;所以，我想说，len(x) 击败 x.len()，这还体现了 &lt;strong&gt;Python 对世界本质的洞察&lt;/strong&gt; 。&lt;/div&gt;
&lt;div&gt;求某个对象的长度，这种操作独立于对象之外而存在，并不是该对象内部所有的一种属性或功能。从这个角度理解，我们能够明白，&lt;strong&gt;为什么 Python 要设计出内置函数？&lt;/strong&gt; 内置函数其实是对世界本质的一种捕捉。&lt;/div&gt;
&lt;div&gt;这些见微知著的发现，足够使我们爱上这门语言了。人生苦短，我用 Python。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>如何给列表降维？sum()函数的妙用</title>
            <link>https://pythoncat.top/posts/2019-04-17-sum/</link>
            <guid>https://pythoncat.top/posts/2019-04-17-sum/</guid>
            <pubDate>Wed, 17 Apr 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;上个月，学习群里的 S 同学问了个题目，大意可理解为&lt;code&gt;列表降维&lt;/code&gt; ，例子如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;oldlist = [[1, 2, 3], [4, 5]]

# 想得到结果：
newlist = [1, 2, 3, 4, 5]&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;原始数据是一个二维列表，目的是获取该列表中所有元素的具体值。从抽象一点的角度来理解，也可看作是列表解压或者列表降维。&lt;/div&gt;
&lt;div&gt;这个问题并不难，但是，怎么写才比较优雅呢？&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# 方法一，粗暴拼接法：
newlist = oldlist[0] + oldlist[1]&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这种方法简单粗暴，需要拼接什么内容，就取出来直接拼接。然而，如果原列表有很多子列表，则这个方法就会变得繁琐了。&lt;/div&gt;
&lt;div&gt;我们把原问题升级一下：&lt;strong&gt;一个二维列表包含 n 个一维列表元素，如何优雅地把这些子列表拼成一个新的一维列表？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;方法一的做法需要写 n 个对象，以及 n - 1 次拼接操作。当然不可行。下面看看方法二：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# 方法二，列表推导式：
newlist = [i for j in range(len(oldlist)) for i in oldlist[j]]&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这个表达式中出现了两个 for 语句，在第一个 for 语句中，我们先取出原列表的长度，然后构造 range 对象，此时 j 的取值范围是 [0, n-1] 的闭区间。&lt;/div&gt;
&lt;div&gt;在第二个 for 语句中，oldlist[j] 指的正是原列表的第 j 个子列表，&lt;code&gt;for i in oldlist[j]&lt;/code&gt; 则会遍历取出 j 子列表的元素，由于 j 取值的区间正对应于原列表的全部索引值，所以，最终达到解题目的。&lt;/div&gt;
&lt;div&gt;这种方法足够优雅了，而且理解也并不难。&lt;/div&gt;
&lt;div&gt;然而，我们是否就能满足于此了呢？有没有其它奇技淫巧，哦不，是其它高级方法呢？F 同学贡献了一个思路：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# 方法三，巧用sum：
newlist = sum(oldlist,[])&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;说实话，这个方法令我大感意外！sum() 函数不是用于求和的么？怎么竟然有此用法？&lt;/div&gt;
&lt;div&gt;这个写法利用了什么原理呢？由于我开始时不知道 sum() 函数可以接收两个参数，不清楚它们是怎么用于计算的，所以一度很困惑。但是，当我知道 sum() 的完整用法时，我恍然大悟。&lt;/div&gt;
&lt;div&gt;接下来也不卖关子了，直接揭晓吧。&lt;/div&gt;
&lt;div&gt;语法： &lt;code&gt;sum(iterable[, start])&lt;/code&gt; ，sum() 函数的第一个参数是可迭代对象，如列表、元组或集合等，第二个参数是起始值，默认为 0 。其用途是以 start 值为基础，再与可迭代对象的所有元素相“加”。&lt;/div&gt;
&lt;div&gt;在上例中，执行效果是 oldlist 中的子列表逐一与第二个参数相加，而列表的加法相当于 extend 操作，所以最终结果是由 [] 扩充成的列表。&lt;/div&gt;
&lt;div&gt;这里有两个关键点：&lt;strong&gt;sum() 函数允许带两个参数，且第二个参数才是起点。&lt;/strong&gt; 可能 sum() 函数用于数值求和比较多，然而用于作列表的求和，就有奇效。它比列表推导式更加优雅简洁！&lt;/div&gt;
&lt;div&gt;至此，前面的升级版问题就得到了很好的回答。简单回顾一下，s 同学最初的问题可以用三种方法实现，第一种方法中规中矩，第二种方法正道进阶，而第三种方法旁门左道（没有贬义，只是说它出人意料，却效果奇佳）。&lt;/div&gt;
&lt;div&gt;这道并不算难的问题，在众人的讨论与分享后，竟还引出了很有价值的学习内容。前不久，同样是群内的一个问题，也产生了同样的学习效果，详见《&lt;a href=&quot;https://mp.weixin.qq.com/s/4eWQmJ15QZabNViePCDmNw&quot;&gt;Python进阶：如何将字符串常量转为变量？&lt;/a&gt;》。&lt;/div&gt;
&lt;div&gt;我从中得到了一个启示：&lt;strong&gt;应该多角度地思考问题，设法寻求更优解，同时，基础知识应掌握牢固，并灵活贯通起来。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;学无止境，这里我还想再开拓一下思路，看看能发现些什么。&lt;/div&gt;
&lt;div&gt;1、如果原列表的元素除了列表，还有其它类型的元素，怎么把同类的元素归并在一起呢？&lt;/div&gt;
&lt;div&gt;2、如果是一个三维或更高维的列表，怎么更好地把它们压缩成一维列表呢？&lt;/div&gt;
&lt;div&gt;3、sum() 函数还有什么知识要点呢？&lt;/div&gt;
&lt;div&gt;前两个问题增加了复杂度，解决起来似乎没有“灵丹妙药”了，只能用笨方法分别拆解，逐一解压。&lt;/div&gt;
&lt;div&gt;第三个思考题是关于 sum() 函数本身的用法，我们看看官方文档是怎么说的：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;em&gt;iterable&lt;/em&gt;’s items are normally numbers, and the start value is not allowed to be a string.&lt;/p&gt;
&lt;p&gt;For some use cases, there are good alternatives to &lt;a href=&quot;https://docs.python.org/3/library/functions.html#sum&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt;. The preferred, fast way to concatenate a sequence of strings is by calling &lt;code&gt;&apos;&apos;.join(sequence)&lt;/code&gt;. To add floating point values with extended precision, see &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.fsum&quot;&gt;&lt;code&gt;math.fsum()&lt;/code&gt;&lt;/a&gt;. To concatenate a series of iterables, consider using &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.chain&quot;&gt;&lt;code&gt;itertools.chain()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;sum() 的第二个参数不允许是字符串。如果用了，会报错：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;TypeError: sum() can’t sum strings [use ”.join(seq) instead]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;为什么不建议使用 sum() 来拼接字符串呢？哈哈，文档中建议使用 join() 方法，因为它更快。为了不给我们使用慢的方法，它竟特别限定不允许 sum() 的第二个参数是字符串。&lt;/div&gt;
&lt;div&gt;文档还建议，在某些使用场景时，不要用 sum() ，例如当以扩展精度对浮点数求和时，推荐使用 &lt;code&gt;math.fsum()&lt;/code&gt; ；当要拼接一系列的可迭代对象时，应考虑使用 &lt;code&gt;itertools.chain()&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;浮点数的计算是个难题，我曾转载过一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/4Se4j-_N0cXiWvoQSRHp1w&quot;&gt;如何在 Python 里面精确四舍五入？&lt;/a&gt;》，对此有精彩分析。而&lt;code&gt;itertools.chain()&lt;/code&gt; 可以将不同类型的可迭代对象串联成一个更大的迭代器，这在旧文《&lt;a href=&quot;https://mp.weixin.qq.com/s/7MbRCn37fIIN42rLm6ho3g&quot;&gt;Python进阶：设计模式之迭代器模式&lt;/a&gt;》中也有论及。&lt;/div&gt;
&lt;div&gt;不经意间，sum() 函数的注意事项，竟把 Python 其它的进阶内容都联系起来了。小小的函数，竟成为学习之路上的一个枢纽。&lt;/div&gt;
&lt;div&gt;前段时间，我还写过 range() 、locals() 和 eval() 等内置函数，也是通过一个问题点，而关联出多个知识点， 获益良多。这些内置函数/类的魔力可真不小啊。&lt;/div&gt;
&lt;div&gt;本文到此结束，希望对你有所帮助。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>视频当道的时代，这些珍藏的优质 Python 播客值得推荐</title>
            <link>https://pythoncat.top/posts/2019-04-12-podcast/</link>
            <guid>https://pythoncat.top/posts/2019-04-12-podcast/</guid>
            <description>收藏起来慢慢收听</description>
            <pubDate>Fri, 12 Apr 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;我国互联网的发展道路与欧美不同，在内容的形式上，我们似乎实现了跨越式的发展——早早进入了移动互联网时代，直播和短视频等形式的内容成为了潮流，而文字形式的博客（blog）与声音形式的播客（podcast）则（逐渐）成为了小众。智能手机极大地改变了我们的上网习惯。&lt;/div&gt;
&lt;div&gt;诚然，仍有一些受众广泛的聚合类的平台，例如微信公众号、CSDN、掘金、极客时间、喜马拉雅、荔枝FM，为我们提供丰富的博客与播客，但是，不依赖平台的个人博客与个人播客，则鲜有人知。&lt;/div&gt;
&lt;div&gt;依我的使用习惯，我很喜欢听音频节目，也即是播客。中文的播客听了不少，但是，免费的 Python 播客是极其稀少。&lt;/div&gt;
&lt;div&gt;直到发现了 &lt;strong&gt;Full Stack Python&lt;/strong&gt; 网站上的一篇文章，它汇总介绍了一些非常棒的 Python 播客，大部分节目仍在持续更新中。我特翻译出来，分享给大家。&lt;/div&gt;
&lt;div&gt;英文节目对大多数人来说，可能门槛较高，但是&lt;strong&gt;英文是程序员的必修功课&lt;/strong&gt; ，聆听英文节目，正好可以一边学技术，一边练习英语，一举两得。&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;&lt;strong&gt;英文&lt;/strong&gt;  | Best Python Podcasts[0]&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt;  | 豌豆花下猫&lt;/div&gt;
&lt;div&gt;Python 社区里有很多免费或低成本的学习资源，对新手与有经验的开发者来说，是一大福音。这些优秀的资源就包括很多定期更新的 Python 播客节目。&lt;/div&gt;
&lt;div&gt;本文介绍了一些活跃的、与 Python 或软件工程相关的、高质量的播客。&lt;/div&gt;
&lt;h2&gt;Python 相关的播客&lt;/h2&gt;
&lt;div&gt;这些播客的运营者都是 Python 开发者，他们关注的都是我们领域内很重要的话题。每个播客系列都有很长的历史列表，有的节目录于几年前，因此我们有很丰富的材料可以聆听与学习。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Talk Python to Me[1] 专注于 Python 开发者和组织，每期节目会邀请不同的嘉宾来谈论 ta 的工作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Podcast.__init__[2] 提供有关 Python 的故事，以及“与那些让它变得更棒的人们的访谈”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python Bytes[3] 是来自“Talk Python to Me”和“Test and Code Podcast”创作者的新播客&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Test and Code Podcast[4] 侧重于测试与相关主题，如模拟（mock）和代码度量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Philip Guo 教授有一个名为 PG Podcast[5] 的视频播客，基本是关于 Python 主题的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Import This[6] 是 Kenneth Reitz 和 Alex Gaynor 间歇更新的播客，对有影响力的 Python 社区成员进行深度的采访&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;最喜欢的播客节目&lt;/h2&gt;
&lt;div&gt;以下是我从各大播客中收集的最喜欢的一些节目，听听这些内容，你可以感受到其余播客节目的风格。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;SQLAlchemy and data access in Python[7] 让我理解了对象关系映射库 SQLAlchemy 的知识及其演变过程。这期节目采访了 SQLAlchemy 的作者，主持人 Michael Kennedy 根据他对 SQLAlchemy 的深入研究和使用经验提出了很多问题。&lt;/li&gt;
&lt;li&gt;Python past, present, and future with Guido van Rossum[8] 涵盖了 Python 的历史、Guido 创造并持续三十年来发展这门语言的动机。有趣的事实：当播客主持人迈克尔·肯尼迪向我征询话题时，我贡献了一个问题，即 Python 的开源是否是促使它成功的原因？&lt;/li&gt;
&lt;li&gt;Deploying Python Web Applications[9] 剧透预警：这是我在 Talk Python to Me 上的一期节目，介绍了 Python Web 应用程序部署的工作原理。&lt;/li&gt;
&lt;li&gt;Python Bytes 栏目在第 39 集中广泛地讨论了 object-relational mappers (ORMs)[10] ，其中不少讨论是基于 Full Stack Python 上的文章。谢谢大家对我们提出的反馈与建议。&lt;/li&gt;
&lt;li&gt;Python at Netflix[11] 出自 Talk Python to Me ，通过一个非常棒的视角，介绍了 Python 是怎么运用于这家最大的网络流媒体公司，以及如何适应它们的多语言组织。&lt;/li&gt;
&lt;li&gt;另一个很棒的 Talk Python to Me 节目， Python in Finance[12]，介绍了 Python 在金融行业中的广泛用途：股票交易、定量分析和数据分析。如果你想知道像对冲基金这样的不透明的私营企业是如何利用 Python 赚取（大量）钱财的，一定要听听这个。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;通用软件开发的播客&lt;/h2&gt;
&lt;div&gt;这些播客主要探讨的是软件开发相关的主题，但经常也会涉及 Python 的内容。聆听和学习这些播客，你将会成为更加优秀的软件开发者。&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Software Engineering Daily[13] 令人难以置信的是每天邀请不同的开发者嘉宾，谈论话题非常广泛，与开发相关。&lt;/li&gt;
&lt;li&gt;All things Git[14] 教人如何使用、构建及将 Git 用于工作，每两周一更。&lt;/li&gt;
&lt;li&gt;CodeNewbie[15] 采访新入行的开发者，谈论为什么他们要从事编程工作，以及他们的工作内容。该栏目也会采访一些经验丰富的、打造了知名项目的开发者。&lt;/li&gt;
&lt;li&gt;Developer on Fire[16] 采访程序员、架构师和测试人员，讲述他们成功、失败和卓越的故事。&lt;/li&gt;
&lt;li&gt;Command_line Heroes[17] 涵盖操作系统级的主题以及 DevOps。&lt;/li&gt;
&lt;li&gt;Embedded.fm[18] 涵盖嵌入式系统和硬件黑客攻击。&lt;/li&gt;
&lt;li&gt;The Changelog[19] 周更播客，关于常规软件开发的问题。&lt;/li&gt;
&lt;li&gt;Full Stack Radio[20] 虽与 Full Stack Python 无关，但值得关注！&lt;/li&gt;
&lt;li&gt;Exponent[21] 不是一个软件开发的播客，但它以深入的方式揭示了企业的战略和技术，使我能够更好地理解企业在构建和发布软件时所做出的决策。我听了每一集（以 1.5 倍速），非常推荐每周花 45 到 60 分钟，听 Ben Thompson 和 James Allworth 深入讨论一个主题。&lt;/li&gt;
&lt;li&gt;Test Talks[22] 每周考察一个软件测试的主题，通常会特邀一位钻研该领域的嘉宾。&lt;/li&gt;
&lt;li&gt;The Cloudcast[23] 聚焦于云计算和 DevOps 的相关主题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数据科学与数据分析的播客&lt;/h2&gt;
&lt;div&gt;Python 不仅是数据科学社区的核心编程语言，而且几乎在每个使用数据分析的组织中都发挥着重要作用。 以下播客广泛地涵盖数据科学，并经常涉及到 Python 生态系统中的特定的工具。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;DataFramed[24] 是一个数据科学播客，内容涵盖 Python 标准库，以及数据分析者感兴趣的其它内容。&lt;/li&gt;
&lt;li&gt;Data Skeptic[25] 涵盖数据科学、统计、机器学习、人工智能，以及“科学怀疑论”（scientific skepticism）等内容。&lt;/li&gt;
&lt;li&gt;Data stories[26] 是一个关于数据可视化的播客。&lt;/li&gt;
&lt;li&gt;Partially Derivative[27] 是一个关于机器学习、人工智能和数据行业的播客，在 2017 年底已停播，节目列表包含了大量的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;div&gt;[0] Best Python Podcasts: &lt;a href=&quot;https://www.fullstackpython.com/best-python-podcasts.html&quot;&gt;https://www.fullstackpython.com/best-python-podcasts.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[1] Talk Python to Me: &lt;a href=&quot;https://talkpython.fm/&quot;&gt;https://talkpython.fm/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[2] Podcast.__init__: &lt;a href=&quot;http://podcastinit.com/&quot;&gt;http://podcastinit.com/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[3] Python Bytes: &lt;a href=&quot;https://pythonbytes.fm/&quot;&gt;https://pythonbytes.fm/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[4] Test and Code Podcast: &lt;a href=&quot;http://pythontesting.net/test-podcast/&quot;&gt;http://pythontesting.net/test-podcast/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[5] PG Podcast: &lt;a href=&quot;http://pgbovine.net/PG-Podcast.htm&quot;&gt;http://pgbovine.net/PG-Podcast.htm&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[6] Import This: &lt;a href=&quot;https://www.kennethreitz.org/import-this/&quot;&gt;https://www.kennethreitz.org/import-this/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[7] SQLAlchemy and data access in Python: &lt;a href=&quot;https://talkpython.fm/episodes/show/5/sqlalchemy-and-data-access-in-python&quot;&gt;https://talkpython.fm/episodes/show/5/sqlalchemy-and-data-access-in-python&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[8] Python past, present, and future with Guido van Rossum: &lt;a href=&quot;https://talkpython.fm/episodes/show/100/python-past-present-and-future-with-guido-van-rossum&quot;&gt;https://talkpython.fm/episodes/show/100/python-past-present-and-future-with-guido-van-rossum&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[9] Deploying Python Web Applications: &lt;a href=&quot;https://talkpython.fm/episodes/show/26/deploying-python-web-applications-updated&quot;&gt;https://talkpython.fm/episodes/show/26/deploying-python-web-applications-updated&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[10] object-relational mappers (ORMs): &lt;a href=&quot;https://www.fullstackpython.com/object-relational-mappers-orms.html&quot;&gt;https://www.fullstackpython.com/object-relational-mappers-orms.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[11] Python at Netflix: &lt;a href=&quot;https://talkpython.fm/episodes/show/16/python-at-netflix&quot;&gt;https://talkpython.fm/episodes/show/16/python-at-netflix&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[12] Python in Finance: &lt;a href=&quot;https://talkpython.fm/episodes/show/120/python-in-finance&quot;&gt;https://talkpython.fm/episodes/show/120/python-in-finance&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[13] Software Engineering Daily: &lt;a href=&quot;https://softwareengineeringdaily.com/&quot;&gt;https://softwareengineeringdaily.com/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[14] All things Git: &lt;a href=&quot;https://www.allthingsgit.com/&quot;&gt;https://www.allthingsgit.com/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[15] CodeNewbie: &lt;a href=&quot;https://www.codenewbie.org/podcast&quot;&gt;https://www.codenewbie.org/podcast&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[16] Developer on Fire: &lt;a href=&quot;http://developeronfire.com/&quot;&gt;http://developeronfire.com/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[17] Command_line Heroes: &lt;a href=&quot;https://www.redhat.com/en/command-line-heroes&quot;&gt;https://www.redhat.com/en/command-line-heroes&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[18] Embedded.fm: &lt;a href=&quot;http://embedded.fm/&quot;&gt;http://embedded.fm/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[19] The Changelog: &lt;a href=&quot;https://changelog.com/&quot;&gt;https://changelog.com/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[20] Full Stack Radio: &lt;a href=&quot;http://www.fullstackradio.com/&quot;&gt;http://www.fullstackradio.com/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[21] Exponent: &lt;a href=&quot;http://exponent.fm/&quot;&gt;http://exponent.fm/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[22] Test Talks: &lt;a href=&quot;https://joecolantonio.com/testtalks/&quot;&gt;https://joecolantonio.com/testtalks/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[23] The Cloudcast: &lt;a href=&quot;http://www.thecloudcast.net/&quot;&gt;http://www.thecloudcast.net/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[24] DataFramed: &lt;a href=&quot;https://www.datacamp.com/community/podcast&quot;&gt;https://www.datacamp.com/community/podcast&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[25] Data Skeptic: &lt;a href=&quot;https://www.dataskeptic.com/&quot;&gt;https://www.dataskeptic.com/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[26] Data stories: &lt;a href=&quot;http://datastori.es/&quot;&gt;http://datastori.es/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[27] Partially Derivative: &lt;a href=&quot;http://partiallyderivative.com&quot;&gt;http://partiallyderivative.com&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>8 天云南之旅，4 个文字见闻</title>
            <link>https://pythoncat.top/posts/2019-04-08-yunnan/</link>
            <guid>https://pythoncat.top/posts/2019-04-08-yunnan/</guid>
            <description>8 天的云南之旅结束了。我本想细细地写一篇游记的，但开了个头，写下的抱怨性内容太多了，也就打消了念头。这里分享几个与文字相关的见闻。</description>
            <pubDate>Mon, 08 Apr 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;8 天的云南之旅结束了。我本想细细地写一篇游记的，但开了个头，写下的抱怨性内容太多了，也就打消了念头。&lt;/div&gt;
&lt;div&gt;这里分享几个与文字相关的见闻。&lt;/div&gt;
&lt;div&gt;（1）东巴文&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;上图摄于丽江，图中文字是东巴文。&lt;/div&gt;
&lt;div&gt;直接摘录一段维基百科吧：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;东巴文是一种兼备表意和表音成分的图画象形文字。其文字形态十分原始，甚至比甲骨文的形态还要原始，属于文字起源的早期形态，但亦能完整纪录典藏。&lt;/p&gt;
&lt;p&gt;东巴文是居于西藏东部及云南省北部的少数民族纳西族所使用的文字。东巴文源于纳西族的宗教典籍兼百科全书的《东巴经》。由于这种文字由东巴（智者）所掌握，故称东巴文。&lt;/p&gt;
&lt;p&gt;东巴文有2223个单字，词语丰富，能够表达细腻的情感，能记录复杂的事件，亦能写诗作文。东巴文是世界上极少数依旧活着的象形文字，被誉为文字的“活化石”。2003年，东巴古籍被联合国教科文组织列入世界记忆名录，并进行数码记录。&lt;/p&gt;
&lt;p&gt;2005年，丽江市东巴文化研究院开始进行东巴文国际标准化工作，系统整理东巴文的书写、语音和语义等。但在同年贵州省第二次乡村旅游论坛上，清华大学社会学系教授张小军提出“由于过度商业开发，东巴文正面临灭绝境地。”但保护东巴文的工作仍在进行当中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;在丽江古城中，有几家东巴文化书店，店内有售东巴文字典。可惜忘了拍照。&lt;/div&gt;
&lt;div&gt;（2）削价&lt;/div&gt;
&lt;div&gt;通常我们见到的是“降价”、“打折”的叫法，这次在大理的喜洲，我却无意中发现店家用了“削价”这个词。&lt;/div&gt;
&lt;div&gt;削价也有降低价格的意思，尽管是初次见到，但我们应该都能无误地理解它。&lt;/div&gt;
&lt;div&gt;只是在一座古城中，在一家现代化的服装店内，我无意中瞥见了它，突然品出了满满的况味。&lt;/div&gt;
&lt;div&gt;（3）善男子与善女人&lt;/div&gt;
&lt;div&gt;在大理的苍山上有座寺（忘了名字），它的厕所标识如下：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;向来知道“善男信女”一词，指的是信佛的男男女女。&lt;/div&gt;
&lt;div&gt;这“善男子”、“善女人”的叫法略有不同，所指是否大不同呢？&lt;/div&gt;
&lt;div&gt;且不查了，不管何种意思，用它们来指示厕所，实在太怪了。&lt;/div&gt;
&lt;div&gt;“不善”的男子和女人就不配进去上厕所么？或者说，上了这寺里的厕所，出来的就是善男子善女人了？劝人向善，不问何处。&lt;/div&gt;
&lt;div&gt;文字怪，因为没见过这种用途。可是品品，它不落俗套，又颇有妙意。&lt;/div&gt;
&lt;div&gt;一个趣味对比，丽江古城的某处墙角：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;（4）粑粑与饵&lt;/div&gt;
&lt;div&gt;“粑粑”这个词，在云南之旅前，我只知道它的一个意思：粪便。&lt;/div&gt;
&lt;div&gt;在云南，原来它是一种特色小吃，一种炭火烘烤的饼。&lt;/div&gt;
&lt;div&gt;喜洲破酥粑粑，据他们宣传，上过《舌尖上的中国》。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;百度百科显示，作为食物时，它的读音是”巴巴”，即第一声。&lt;/div&gt;
&lt;div&gt;粑字，应该有其古老的起源，只是那种饮食习惯离我（离大多数人）太远了，现代的变异引申意反而“鸠占鹊巢”了。&lt;/div&gt;
&lt;div&gt;在昆明老街，我还吃到了一种小吃：粑肉饵丝。据店里宣传册说，他们复原了大理巍山的古法。这我们无从考证，但相比云南特色的米线、各地的面或粉，它的风味确实别具特色。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;《说文解字》的解释：“饵，粉饼也”。饵丝和饵块，都是云南常见的小吃，在昆明最多。与喜洲的粑粑相比，饵的形式更多样，已经不再是“粉饼”了。&lt;/div&gt;
&lt;div&gt;前面所说的粑肉饵丝，只有饵丝，并没有粑粑，粑似乎在某个时候“转化”成了饵，只在一个古老的食物名字中留下些联系。&lt;/div&gt;
&lt;div&gt;PS：豌豆正在写她的游记，敬请期待。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>别开心太早，Python 官方文档的翻译差远了</title>
            <link>https://pythoncat.top/posts/2019-03-30-translation/</link>
            <guid>https://pythoncat.top/posts/2019-03-30-translation/</guid>
            <pubDate>Sat, 30 Mar 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;近几天，很多公众号发布了 Python 官方文档的消息。然而，一个特别奇怪的现象就发生了，让人啼笑皆非。&lt;/div&gt;
&lt;div&gt;Python 文档的中文翻译工作一直是“默默无闻”，几个月前，我还吐槽过这件事《&lt;a href=&quot;https://mp.weixin.qq.com/s/855ur2uCI1Z1-qpuLGKp0Q&quot;&gt;再聊聊Python中文社区的翻译&lt;/a&gt;》，当时我们的进度是 10.3%，远远落后于日本和法国，甚至落后于巴西！&lt;/div&gt;
&lt;div&gt;这次所谓的中文版，当然是未完成翻译的残品。刚查了下，整体进度是 19.7%。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;有的公众号在发布消息的时候，说明了这不是官宣、不是正式发布版，还指出了中文版的访问地址是隐藏入口。这都是忠于事实的。&lt;/div&gt;
&lt;div&gt;然而，怪异的事情就在于，还有一些公众号在发布时，不知怎么误传，这个消息变成了官方正式发布、全部翻译完成、激动人心期盼已久，至于这个隐藏入口跳转问题、下载的文档为何是英文版的问题，则完全无法解释。这带来了极大的误导。&lt;/div&gt;
&lt;div&gt;由于曾搜集过 PEP 文档的翻译，我无意中也了解到关于翻译官方文档的一些情况。有以下几个现状吧：&lt;/div&gt;
&lt;div&gt;1、人员分散，缺乏核心。就我所见，在V站、华蟒邮件组、简书、知乎，分别有不同的人发起过翻译召集或者咨询，然而应者无几，并没有形成过足够大的核心组织。&lt;/div&gt;
&lt;div&gt;2、官方的翻译？Python 官方在 2017 年的 PEP-545 中推出了一种翻译模式，各国语言的翻译在协作平台&lt;code&gt;Transifex&lt;/code&gt; 上进行。实际上，这才是官方认可的版本，也是最终发布的依据。前文说的进度，就是指在这个平台上的进度。&lt;/div&gt;
&lt;div&gt;3、野生的翻译？所谓野生，这里指的是不在&lt;code&gt;Transifex&lt;/code&gt; 上的翻译。网上能看到有人零星地翻译了一些部分，但成果没有合入到官方平台上。社区内的译者还是挺多的，能力也有，只是太分散了。邮件组里就有位大佬，他说翻译过 40 多个标准库以及 C 模块的文档，但懒得组织。有人尝试组织过，时间久远的不说，就在去年夏天，某位在 PHP 界知名的站长开了个 Python 社区，召集了一批译者。他们译出了 Python 3.7 官方文档的入门教程部分，然而，后续内容的计划，似乎被放弃了。&lt;/div&gt;
&lt;div&gt;关于对待翻译的态度，似乎多数人表示：感兴趣，但是时间少，希望有人牵头组织，可以参与作贡献。我本人也怀着同样的想法。作为参与者、见证者、沾光者就好了，谁愿意花费那么多精力，承担重任，周旋策划，最后可能还讨不到好呢？&lt;/div&gt;
&lt;div&gt;写文章是重口难调，翻译文档更是如此，碰上质疑翻译水平的，还可商榷一下，而遇到下面这种杠精，只能是破坏心情。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;前面提到的那位站长，提出在他的社区维护一份长久维护的版本。事实上，他们真的做出了点实事，除了入门教程，还完成了两本经典书籍的翻译。然而，他们也招到了非议：不当的“官方文档”措辞、不合入官方使用的平台、网站的商业化运营…&lt;/div&gt;
&lt;div&gt;空谈的人总是有他们的理，不对事情做贡献，还无视别人的贡献。诚然，宣称“官方”中文文档，确实不妥，这只是个人/社区的行为，改正就好了；至于合入官方的途径，只需有翻译成果，也不难做到；最后，一个站点接些贴片广告，哪有什么不妥？&lt;/div&gt;
&lt;div&gt;我所了解到的社区翻译情况，大致如上。&lt;/div&gt;
&lt;div&gt;总体上，分裂分散现象严重，随性自由之处跟 Python 这语言倒挺像，而各怀能力各出成绩的现象，也跟为数众多的三方模块神似。&lt;/div&gt;
&lt;div&gt;也有默默在做事的人。从 4 个月前的 10% ，增长到现在的 20%，我们的翻译进度暴涨，这背后不知有几人在持续作出贡献？而他们还不为人知。&lt;/div&gt;
&lt;div&gt;距离官方文档全部译出，还有大步路要走，现实情况得认清。&lt;/div&gt;
&lt;div&gt;我总体上是乐观的。所以，最后聊个题外话。&lt;/div&gt;
&lt;div&gt;这几天，有个热得不行的话题——&lt;code&gt;996.ICU&lt;/code&gt; ，才仅仅一周，Github star 数已经破 10 万，绝对创造纪录了。程序员发起的活动，就是有如此大的力量。&lt;/div&gt;
&lt;div&gt;就在本文写作过程中，Python 之父也给了这个项目 star ，而且发推声援。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;在官方文档的翻译事情上，或许我们是有点脱轨了，不过不要紧，在使用全球最大的同性交友平台上，我们是与国际接轨的。&lt;/div&gt;
&lt;div&gt;还有啊，等过完了愚人节，我们还有个节日也是与国际接轨的——国际劳动节，纪念 1886 年芝加哥工人大罢工，确立每日 8 小时工作制的节日。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;翻译进度：&lt;a href=&quot;https://www.transifex.com/python-doc/python-newest/&quot;&gt;https://www.transifex.com/python-doc/python-newest&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;V站话题：&lt;a href=&quot;https://neue.v2ex.com/t/477400#reply147&quot;&gt;https://neue.v2ex.com/t/477400#reply147&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;邮件列表：&lt;a href=&quot;https://groups.google.com/forum/#!topic/python-cn/8H4qhhI6khw&quot;&gt;https://groups.google.com/forum/#!topic/python-cn/8H4qhhI6khw&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>介绍几款 Python 类型检查工具</title>
            <link>https://pythoncat.top/posts/2019-03-27-type/</link>
            <guid>https://pythoncat.top/posts/2019-03-27-type/</guid>
            <pubDate>Wed, 27 Mar 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;近日，微软在 Github 上开源了一个 Python 静态类型检查工具：&lt;code&gt;pyright&lt;/code&gt; ，引起了社区内的多方关注。&lt;/div&gt;
&lt;div&gt;微软在开源项目上的参与力度是越来越大了，不说收购 Github 这种大的战略野心，只说它家开源的 VS Code 编辑器，在猿界已经割粉无数，连我们 Python 圈的红人 Kenneth Reitz （多个开源项目的作者，包括 requests、requests-html、responder等）都对它赞不绝口。&lt;/div&gt;
&lt;div&gt;如今开源的 Pyright ，口碑还不错，那我们就来看看它有啥本事，顺便再介绍其它几款类型检查工具。&lt;/div&gt;
&lt;div&gt;众所周知，Python 是一门动态类型语言，在运行期才知道变量的实际类型。这本就是动态语言的特色，然而在团队合作或大型项目上，维护的代价也不可避免，俗话说的是：“&lt;strong&gt;动态一时爽，重构火葬场&lt;/strong&gt; ”。&lt;/div&gt;
&lt;div&gt;早在 2006 年的 PEP-3107，Python 就推出了函数注解的功能，最终落在 3.0 版本实现。而到了 3.5 版本，Python 继续引入了静态类型检查的语法（即 PEP-484，type hints）。2014 年的 PEP-483 更是以《The Theory of Type Hints》为题，做出了理论上的归纳。后来，又陆续提出了 PEP-526、PEP-544，类型检查的规范逐渐丰富。&lt;/div&gt;
&lt;div&gt;类型检查的好处是及早检查，提前发现类型的错误，增强代码的一致性与可维护性。（还有防止脱发，喵）&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# 不加检查
def greeting(name):
    return &apos;Hello &apos; + name

# 添加检查
def greeting(name: str) -&amp;gt; str:
    return &apos;Hello &apos; + name&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;如上例所示，增加检查后，可以在编译期就判断入参和返回值是否是字符串类型。&lt;/div&gt;
&lt;div&gt;在微软推出 pyright 之前，主流的静态检查工具有三款：官方的&lt;code&gt;mypy&lt;/code&gt; 、Google 出的&lt;code&gt;pytype&lt;/code&gt; 、Facebook 出的&lt;code&gt;pyre-check&lt;/code&gt; 。三足鼎立的局面要被打破了。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;pyright 的文档宣称它有如下特点：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;速度快。相较于 mypy 及其它用 Python 写的检查工具，它的速度是 5 倍甚至更多。&lt;/li&gt;
&lt;li&gt;不依赖 Python 环境。它用 TypeScript 写成，运行于 node 上，不依赖 Python 环境或第三方包。&lt;/li&gt;
&lt;li&gt;可配置性强。支持自由地配置，支持指定不同的运行环境（PYTHONPATH 设置、Python 版本、平台目标）。&lt;/li&gt;
&lt;li&gt;检查项齐全。支持类型检查及其它语法项的检查（如 PEP-484、PEP-526、PEP-544），以及函数返回值、类变量、全局变量的检查，甚至可以检查条件循环语句&lt;/li&gt;
&lt;li&gt;命令行工具。它包含两个 VS Code 插件：一个命令行工具和一个语言服务器协议（Language Server Protocol）&lt;/li&gt;
&lt;li&gt;内置 Stubs 。使用的是 &lt;code&gt;Typeshed&lt;/code&gt; 的副本。（注：使用静态的 pyi 文件，检查内置模块、标准库和三方件 ）&lt;/li&gt;
&lt;li&gt;语言服务特性。悬停提示信息、符号定义的跳转、实时的编辑反馈&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;就此而言，不可谓不强大。事实上，pyright 是“站在了巨人的肩膀上”，它的各项功能似乎都继承自其它几位前辈。&lt;/div&gt;
&lt;div&gt;接着看官方的 mypy ，它由“Python 之父” Guido van Rossum 亲自参与开发，是最主流的选择，推出得早，用户基数大，文档与社区经验也最丰富。&lt;/div&gt;
&lt;div&gt;在集成 IDE 方面，所有主流的编辑器都支持：PyCharm、Vim、Emacs、Sublime Text、VS Code、Atom…在业界经验上，Instagram 和 Dropbox 的项目从 py2 迁移到 py3 ，就是用的它来做保障。&lt;/div&gt;
&lt;div&gt;接着看谷歌的 pytype ，据文档描述，它可以：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;标记常见错误，如拼写错误、函数调用错误&lt;/li&gt;
&lt;li&gt;加强自定义的类型注解&lt;/li&gt;
&lt;li&gt;支持对 pyi 文件生成类型注解&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;查看文档，我发现它有个功能还挺人性化的，即“&lt;strong&gt;错误降噪&lt;/strong&gt; ”，对于那些不必修改的错误，可以添加注释，来消除类型检查。&lt;/div&gt;
&lt;div&gt;此外，还有一个考虑也不错，为了写类型检查，模块中可能会额外引入其它的模块，对于后者，pytype 有办法隐藏它，只在做类型检查时才加载。&lt;/div&gt;
&lt;div&gt;最后，要介绍的是脸书的 pyre-check，它是去年开源的，也曾收获一片好评（说不定正是因为它，微软才上马了 pyright 项目也说不定）。&lt;/div&gt;
&lt;div&gt;基本的功能点大同小异，不过它也是有亮点的。pyre-check 可集成&lt;code&gt;Watchman&lt;/code&gt; 模块，该“观察者”会监听代码文件，跟踪所做的修改。微软的 pyright 有个 watch 模式，应该是吸收了这点，而且更加好用（因为不需要额外安装 Watchman 和其它依赖）。&lt;/div&gt;
&lt;div&gt;pyre-check 还有个亮点，它有个&lt;code&gt;query&lt;/code&gt; 参数，可以对源码做局部区域性的检查，例如查询某行中一个表达式的类型、查询一个类的全部方法并返回成列表，等等，这样可以避免做全面的检查。&lt;/div&gt;
&lt;div&gt;4 种类型检查工具介绍完毕，下面是一份概要对比：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;至于它们的性能如何，是否真如 pyright 所说，它的速度是其它几个的 5 倍呢？感兴趣的同学们可以去试试。有什么使用体会，欢迎留言与我交流。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;项目地址：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/python/mypy&quot;&gt;https://github.com/python/mypy&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/Microsoft/pyright&quot;&gt;https://github.com/Microsoft/pyright&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/google/pytype&quot;&gt;https://github.com/google/pytype&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/facebook/pyre-check&quot;&gt;https://github.com/facebook/pyre-check&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>深度辨析 Python 的 eval() 与 exec()</title>
            <link>https://pythoncat.top/posts/2019-03-24-eval/</link>
            <guid>https://pythoncat.top/posts/2019-03-24-eval/</guid>
            <pubDate>Sun, 24 Mar 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 提供了很多内置的工具函数（Built-in Functions），在最新的 Python 3 官方文档中，它列出了 69 个。&lt;/div&gt;
&lt;div&gt;大部分函数是我们经常使用的，例如 print()、open() 与 dir()，而有一些函数虽然不常用，但它们在某些场景下，却能发挥出不一般的作用。内置函数们能够被“提拔”出来，这就意味着它们皆有独到之处，有用武之地。&lt;/div&gt;
&lt;div&gt;因此，掌握内置函数的用法，就成了我们应该点亮的技能。&lt;/div&gt;
&lt;div&gt;在《&lt;a href=&quot;https://mp.weixin.qq.com/s/4eWQmJ15QZabNViePCDmNw&quot;&gt;Python进阶：如何将字符串常量转为变量？&lt;/a&gt;》这篇文章中，我提到过 eval() 和 exec() ，但对它们并不太了解。为了弥补这方面知识，我就重新学习了下。这篇文章是一份超级详细的学习记录，系统、全面而深入地辨析了这两大函数。&lt;/div&gt;
&lt;h2&gt;1、eval 的基本用法&lt;/h2&gt;
&lt;div&gt;语法：eval(&lt;em&gt;expression&lt;/em&gt;, &lt;em&gt;globals=None&lt;/em&gt;, &lt;em&gt;locals=None&lt;/em&gt;)&lt;/div&gt;
&lt;div&gt;它有三个参数，其中 expression 是一个字符串类型的表达式或代码对象，用于做运算；globals 与 locals  是可选参数，默认值是 None。&lt;/div&gt;
&lt;div&gt;具体而言，expression 只能是单个表达式，不支持复杂的代码逻辑，例如赋值操作、循环语句等等。（PS：单个表达式并不意味着“简单无害”，参见下文第 4 节）&lt;/div&gt;
&lt;div&gt;globals 用于指定运行时的全局命名空间，类型是字典，缺省时使用的是当前模块的内置命名空间。locals 指定运行时的局部命名空间，类型是字典，缺省时使用 globals 的值。两者都缺省时，则遵循 eval 函数执行时的作用域。值得注意的是，这两者不代表真正的命名空间，只在运算时起作用，运算后则销毁。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;x = 10

def func():
    y = 20
    a = eval(&apos;x + y&apos;)
    print(&apos;a: &apos;, a)
    b = eval(&apos;x + y&apos;, {&apos;x&apos;: 1, &apos;y&apos;: 2})
    print(&apos;x: &apos; + str(x) + &apos; y: &apos; + str(y))
    print(&apos;b: &apos;, b)
    c = eval(&apos;x + y&apos;, {&apos;x&apos;: 1, &apos;y&apos;: 2}, {&apos;y&apos;: 3, &apos;z&apos;: 4})
    print(&apos;x: &apos; + str(x) + &apos; y: &apos; + str(y))
    print(&apos;c: &apos;, c)

func()&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;输出结果：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;a:  30
x: 10 y: 20
b:  3
x: 10 y: 20
c:  4&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;由此可见，当指定了命名空间的时候，变量会在对应命名空间中查找。而且，它们的值不会覆盖实际命名空间中的值。&lt;/div&gt;
&lt;h2&gt;2、exec 的基本用法&lt;/h2&gt;
&lt;div&gt;语法：exec(&lt;em&gt;object&lt;/em&gt;[, &lt;em&gt;globals&lt;/em&gt;[, &lt;em&gt;locals&lt;/em&gt;]])&lt;/div&gt;
&lt;div&gt;在 Python2 中 exec 是个语句，而 Python3 将其改造成一个函数，就像 print 一样。exec() 与 eval() 高度相似，三个参数的意义和作用相近。&lt;/div&gt;
&lt;div&gt;主要的区别是，exec() 的第一个参数不是表达式，而是代码块，这意味着两点：一是它不能做表达式求值并返回出去，二是它可以执行复杂的代码逻辑，相对而言功能更加强大，例如，当代码块中赋值了新的变量时，该变量&lt;strong&gt;可能&lt;/strong&gt; 在函数外的命名空间中存活下来。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; x = 1
&amp;gt;&amp;gt;&amp;gt; y = exec(&apos;x = 1 + 1&apos;)
&amp;gt;&amp;gt;&amp;gt; print(x)
&amp;gt;&amp;gt;&amp;gt; print(y)
2
None&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;可以看出，exec() 内外的命名空间是相通的，变量由此传递出去，而不像 eval() 函数，需要一个变量来接收函数的执行结果。&lt;/div&gt;
&lt;h2&gt;3、一些细节辨析&lt;/h2&gt;
&lt;div&gt;两个函数都很强大，它们将字符串内容当做有效的代码执行。这是一种&lt;strong&gt;字符串驱动的事件&lt;/strong&gt; ，意义重大。然而，在实际使用过程中，存在很多微小的细节，此处就列出我所知道的几点吧。&lt;/div&gt;
&lt;div&gt;常见用途：将字符串转成相应的对象，例如 string 转成 list ，string 转成 dict，string 转 tuple 等等。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot;[[1,2], [3,4], [5,6], [7,8], [9,0]]&quot;
&amp;gt;&amp;gt;&amp;gt; print(eval(a))
[[1, 2], [3, 4], [5, 6], [7, 8], [9, 0]]
&amp;gt;&amp;gt;&amp;gt; a = &quot;{&apos;name&apos;: &apos;Python猫&apos;, &apos;age&apos;: 18}&quot;
&amp;gt;&amp;gt;&amp;gt; print(eval(a))
{&apos;name&apos;: &apos;Python猫&apos;, &apos;age&apos;: 18}

# 与 eval 略有不同
&amp;gt;&amp;gt;&amp;gt; a = &quot;my_dict = {&apos;name&apos;: &apos;Python猫&apos;, &apos;age&apos;: 18}&quot;
&amp;gt;&amp;gt;&amp;gt; exec(a)
&amp;gt;&amp;gt;&amp;gt; print(my_dict)
{&apos;name&apos;: &apos;Python猫&apos;, &apos;age&apos;: 18}&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;eval() 函数的返回值是其 expression 的执行结果，在某些情况下，它会是 None，例如当该表达式是 print() 语句，或者是列表的 append() 操作时，这类操作的结果是 None，因此 eval() 的返回值也会是 None。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; result = eval(&apos;[].append(2)&apos;)
&amp;gt;&amp;gt;&amp;gt; print(result)
None&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;exec() 函数的返回值只会是 None，与执行语句的结果无关，所以，将 exec() 函数赋值出去，就没有任何必要。所执行的语句中，如果包含 return 或 yield ，它们产生的值也无法在 exec 函数的外部起作用。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; result = exec(&apos;1 + 1&apos;)
&amp;gt;&amp;gt;&amp;gt; print(result)
None&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;两个函数中的 globals 和 locals 参数，起到的是白名单的作用，通过限定命名空间的范围，防止作用域内的数据被滥用。&lt;/div&gt;
&lt;div&gt;conpile() 函数编译后的 code 对象，可作为 eval 和 exec 的第一个参数。compile() 也是个神奇的函数，我翻译的上一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s/o-HuE3VxgHedfe8X5fUrMA&quot;&gt;Python骚操作：动态定义函数&lt;/a&gt;》就演示了一个动态定义函数的操作。&lt;/div&gt;
&lt;div&gt;吊诡的局部命名空间：前面讲到了 exec() 函数内的变量是可以改变原有命名空间的，然而也有例外。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;def foo():
    exec(&apos;y = 1 + 1\nprint(y)&apos;)
    print(locals())
    print(y)

foo()&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;按照前面的理解，预期的结果是局部变量中会存入变量 y，因此两次的打印结果都会是 2，然而实际上的结果却是：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;2
{&apos;y&apos;: 2}
Traceback (most recent call last):
...(略去部分报错信息)
    print(y)
NameError: name &apos;y&apos; is not defined&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;明明看到了局部命名空间中有变量 y，为何会报错说它未定义呢？&lt;/div&gt;
&lt;div&gt;原因与 Python 的编译器有关，对于以上代码，编译器会先将 foo 函数解析成一个 ast（抽象语法树），然后将所有变量节点存入栈中，此时 exec() 的参数只是一个字符串，整个就是常量，并没有作为代码执行，因此 y 还不存在。直到解析第二个 print() 时，此时第一次出现变量 y ，但因为没有完整的定义，所以 y 不会被存入局部命名空间。&lt;/div&gt;
&lt;div&gt;在运行期，exec() 函数动态地创建了局部变量 y ，然而由于 Python 的实现机制是“&lt;strong&gt;运行期的局部命名空间不可改变&lt;/strong&gt; ”，也就是说这时的 y 始终无法成为局部命名空间的一员，当执行 print() 时也就报错了。&lt;/div&gt;
&lt;div&gt;至于为什么 locals() 取出的结果有 y，为什么它不能代表真正的局部命名空间？为什么局部命名空间无法被动态修改？可以查看我之前分享的《&lt;a href=&quot;https://mp.weixin.qq.com/s/f9BBe2W1X1p7NcHg665I4A&quot;&gt;Python 动态赋值的陷阱&lt;/a&gt;》，另外，官方的 bug 网站中也有对此问题的讨论，查看地址：&lt;a href=&quot;https://bugs.python.org/issue4831&quot;&gt;https://bugs.python.org/issue4831&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;若想把 exec() 执行后的 y 取出来的话，可以这样：&lt;code&gt;z = locals()[&apos;y&apos;]&lt;/code&gt; ，然而如果不小心写成了下面的代码，则会报错：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;def foo():
    exec(&apos;y = 1 + 1&apos;)
    y = locals()[&apos;y&apos;]
    print(y)
    
foo()

#报错：KeyError: &apos;y&apos;
#把变量 y 改为其它变量则不会报错&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;code&gt;KeyError&lt;/code&gt; 指的是在字典中不存在对应的 key 。本例中 y 作了声明，却因为循环引用而无法完成赋值，即 key 值对应的 value 是个无效值，因此读取不到，就报错了。&lt;/div&gt;
&lt;div&gt;此例还有 4 个变种，我想用一套自恰的说法来解释它们，但尝试了很久，未果。留个后话吧，等我想明白，再单独写一篇文章。&lt;/div&gt;
&lt;h2&gt;4、为什么要慎用 eval() ？&lt;/h2&gt;
&lt;div&gt;很多动态的编程语言中都会有 eval() 函数，作用大同小异，但是，无一例外，人们会告诉你说，避免使用它。&lt;/div&gt;
&lt;div&gt;为什么要慎用 eval() 呢？主要出于安全考虑，对于不可信的数据源，eval 函数很可能会招来代码注入的问题。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; eval(&quot;__import__(&apos;os&apos;).system(&apos;whoami&apos;)&quot;)
desktop-fa4b888\pythoncat
&amp;gt;&amp;gt;&amp;gt; eval(&quot;__import__(&apos;subprocess&apos;).getoutput(&apos;ls ~&apos;)&quot;)
#结果略，内容是当前路径的文件信息&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在以上例子中，我的隐私数据就被暴露了。而更可怕的是，如果将命令改为&lt;code&gt;rm -rf ~&lt;/code&gt; ，那当前目录的所有文件都会被删除干净。&lt;/div&gt;
&lt;div&gt;针对以上例子，有一个限制的办法，即指定 globals 为 &lt;code&gt;{&apos;__builtins__&apos;: None} &lt;/code&gt; 或者 &lt;code&gt;{&apos;__builtins__&apos;: {}}&lt;/code&gt; 。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s = {&apos;__builtins__&apos;: None}
&amp;gt;&amp;gt;&amp;gt; eval(&quot;__import__(&apos;os&apos;).system(&apos;whoami&apos;)&quot;, s)
#报错：TypeError: &apos;NoneType&apos; object is not subscriptable&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;code&gt;__builtins__&lt;/code&gt; 包含了内置命名空间中的名称，在控制台中输入 dir(__builtins__) ，就能发现很多内置函数、异常和其它属性的名称。在默认情况下，eval 函数的 globals 参数会隐式地携带&lt;code&gt;__builtins__&lt;/code&gt; ，即使是令 globals 参数为 {} 也如此，所以如果想要禁用它，就得显式地指定它的值。&lt;/div&gt;
&lt;div&gt;上例将它映射成 None，就意味着限定了 eval 可用的内置命名空间为 None，从而限制了表达式调用内置模块或属性的能力。&lt;/div&gt;
&lt;div&gt;但是，这个办法还不是万无一失的，因为仍有手段可以发起攻击。&lt;/div&gt;
&lt;div&gt;某位漏洞挖掘高手在他的博客中分享了一个思路，令人大开眼界。其核心的代码是下面这句，你可以试试执行，看看输出的是什么内容。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; ().__class__.__bases__[0].__subclasses__()&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;关于这句代码的解释，以及更进一步的利用手段，详见博客。（地址：&lt;a href=&quot;https://www.tuicool.com/articles/jeaqe2n%EF%BC%89&quot;&gt;https://www.tuicool.com/articles/jeaqe2n）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;另外还有一篇博客，不仅提到了上例的手段，还提供了一种新的思路：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;#警告：千万不要执行如下代码，后果自负。
&amp;gt;&amp;gt;&amp;gt; eval(&apos;(lambda fc=(lambda n: [c 1=&quot;c&quot; 2=&quot;in&quot; 3=&quot;().__class__.__bases__[0&quot; language=&quot;for&quot;][/c].__subclasses__() if c.__name__ == n][0]):fc(&quot;function&quot;)(fc(&quot;code&quot;)(0,0,0,0,&quot;KABOOM&quot;,(),(),(),&quot;&quot;,&quot;&quot;,0,&quot;&quot;),{})())()&apos;, {&quot;__builtins__&quot;:None})&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这行代码会导致 Python 直接 crash 掉。具体分析在：&lt;a href=&quot;https://segmentfault.com/a/1190000011532358&quot;&gt;https://segmentfault.com/a/1190000011532358&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;除了黑客的手段，简单的内容也能发起攻击。像下例这样的写法， 将在短时间内耗尽服务器的计算资源。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; eval(&quot;2 ** 888888888&quot;, {&quot;__builtins__&quot;:None}, {})&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;如上所述，我们直观地展示了 eval() 函数的危害性，然而，即使是 Python 高手们小心谨慎地使用，也不能保证不出错。&lt;/div&gt;
&lt;div&gt;在官方的 dumbdbm 模块中，曾经（2014年）发现一个安全漏洞，攻击者通过伪造数据库文件，可以在调用 eval() 时发起攻击。（详情：&lt;a href=&quot;https://bugs.python.org/issue22885%EF%BC%89&quot;&gt;https://bugs.python.org/issue22885）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;无独有偶，在上个月（2019.02），有核心开发者针对 Python 3.8 也提出了一个安全问题，提议不在 logging.config 中使用 eval() 函数，目前该问题还是 open 状态。（详情：&lt;a href=&quot;https://bugs.python.org/issue36022%EF%BC%89&quot;&gt;https://bugs.python.org/issue36022）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;如此种种，足以说明为什么要慎用 eval() 了。同理可证，exec() 函数也得谨慎使用。&lt;/div&gt;
&lt;h2&gt;5、安全的替代用法&lt;/h2&gt;
&lt;div&gt;既然有种种安全隐患，为什么要创造出这两个内置方法呢？为什么要使用它们呢？&lt;/div&gt;
&lt;div&gt;理由很简单，因为 Python 是一门灵活的动态语言。与静态语言不同，动态语言支持动态地产生代码，对于已经部署好的工程，也可以只做很小的局部修改，就实现 bug 修复。&lt;/div&gt;
&lt;div&gt;那有什么办法可以相对安全地使用它们呢？&lt;/div&gt;
&lt;div&gt;ast 模块的 &lt;code&gt;literal()&lt;/code&gt; 是 eval() 的安全替代，与 eval() 不做检查就执行的方式不同，ast.literal() 会先检查表达式内容是否有效合法。它所允许的字面内容如下：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;strings, bytes, numbers, tuples, lists, dicts, sets, booleans, 和 None&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;一旦内容非法，则会报错：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;import ast
ast.literal_eval(&quot;__import__(&apos;os&apos;).system(&apos;whoami&apos;)&quot;)

报错：ValueError: malformed node or string&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;不过，它也有缺点：AST 编译器的栈深（stack depth）有限，解析的字符串内容太多或太复杂时，可能导致程序崩溃。&lt;/div&gt;
&lt;div&gt;至于 exec() ，似乎还没有类似的替代方法，毕竟它本身可支持的内容是更加复杂多样的。&lt;/div&gt;
&lt;div&gt;最后是一个建议：搞清楚它们的区别与运行细节（例如前面的局部命名空间内容），谨慎使用，限制可用的命名空间，对数据源作充分校验。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;关联阅读：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/f9BBe2W1X1p7NcHg665I4A&quot;&gt;Python 动态赋值的陷阱&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/o-HuE3VxgHedfe8X5fUrMA&quot;&gt;Python骚操作：动态定义函数&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/EsWmCbH3RtL_QpafyMryOw&quot;&gt;Python与家国天下&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/4eWQmJ15QZabNViePCDmNw&quot;&gt;Python进阶：如何将字符串常量转为变量？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://docs.python.org/3/library/ast.html#ast.literal_eval&quot;&gt;https://docs.python.org/3/library/ast.html#ast.literal_eval&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 骚操作：动态定义函数</title>
            <link>https://pythoncat.top/posts/2019-03-18-function/</link>
            <guid>https://pythoncat.top/posts/2019-03-18-function/</guid>
            <pubDate>Mon, 18 Mar 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;英文：&lt;a href=&quot;https://philip-trauner.me/blog/post/python-tips-dynamic-function-definition&quot;&gt;Python Tips: Dynamic function definition&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者：Philip Trauner&lt;/div&gt;
&lt;div&gt;译者：豌豆花下猫&lt;/div&gt;
&lt;div&gt;基于 MIT 许可协议&lt;/div&gt;
&lt;div&gt;在 Python 中，没有可以在运行时简化函数定义的语法糖。然而，这并不意味着它就不可能，或者是难以实现。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; types &lt;span&gt;import&lt;/span&gt; FunctionType

foo_code &lt;span&gt;=&lt;/span&gt; &lt;span&gt;compile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;def foo(): return &quot;bar&quot;&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;&amp;lt;string&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;exec&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
foo_func &lt;span&gt;=&lt;/span&gt; FunctionType&lt;span&gt;(&lt;/span&gt;foo_code&lt;span&gt;.&lt;/span&gt;co_consts&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;globals&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;foo&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;foo_func&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;输出：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;bar&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;剖析&lt;/h2&gt;
&lt;div&gt;逐行检视代码，你会发现语言/解释器的屏障是多么脆弱。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from types import FunctionType&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 文档通常不会列出那些非用于手动创建的类的特征（这是完全合理的）。有三种方法可以解决这个问题：help()、inspect（无法查看内置方法）、以及最后的解决方案，即查看 CPython 源代码。&lt;/div&gt;
&lt;div&gt;在本例中，help() 与 inspect 都可以完成工作，但是查看实际的源代码，则会揭示出关于数据类型的更多细节。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from inspect import signature
&amp;gt;&amp;gt;&amp;gt; signature(FunctionType)
&amp;lt;Signature (code, globals, name=None, argdefs=None, closure=None)&amp;gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;1. code&lt;/h3&gt;
&lt;div&gt;内部是一个&lt;code&gt;PyCodeobject&lt;/code&gt; ，作为&lt;code&gt;types.CodeType&lt;/code&gt; 对外开放。非内置方法拥有一个&lt;code&gt;__code__&lt;/code&gt; 属性，该属性保存了相应的代码对象。利用内置的 compile() 方法，可以在运行期创建&lt;code&gt;types.CodeType&lt;/code&gt; 对象。&lt;/div&gt;
&lt;h3&gt;2. globals&lt;/h3&gt;
&lt;div&gt;如果一个函数引用的变量不是在局部定义的，而是作为参数转入、由默认参数值提供、或者通过闭包上下文提供，则它会在 globals 字典中查找。&lt;/div&gt;
&lt;div&gt;内置的 globals() 方法会返回一个对当前模块的全局符号表（global symbol table）的&lt;strong&gt;引用&lt;/strong&gt; ，因此能被用来提供一个总是与当前表的状态相一致的字典。传入任意其它的字典也是可以的（FunctionType((lambda: bar).__code__, {“bar” : “baz”}, “foo”)() == “baz”）。&lt;/div&gt;
&lt;h3&gt;3. name（可选）&lt;/h3&gt;
&lt;div&gt;控制所返回的函数的&lt;code&gt;__name__&lt;/code&gt; 属性。只真正对 lambdas 有用（由于匿名性，它们通常没有名称），并且重命名函数。&lt;/div&gt;
&lt;h3&gt;4. argdefs（可选）&lt;/h3&gt;
&lt;div&gt;通过传入一个包含任意类型的对象的元组，提供了一个方式来供应默认参数值（def foo(bar=“baz”)）。（FunctionType((lambda bar: bar).__code__, {}, “foo”, (10,))() == 10）。&lt;/div&gt;
&lt;h3&gt;5. closure（可选）&lt;/h3&gt;
&lt;div&gt;（如果需要在 CPython（PyPy，Jython，…）以外的其它 Python VM 中执行，可能不应该触及，因为它严重地依赖于实现细节）。&lt;/div&gt;
&lt;div&gt;一个&lt;code&gt;cell&lt;/code&gt; 对象的元组。创建 cell 对象并非完全是直截了当的，因为需要调用 CPython 的内部组件，但有一个库可以令它更加方便：&lt;code&gt;exalt&lt;/code&gt; （无耻的广告）。（译注：这个库是作者开发的。）&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; foo_code = compile(&apos;def foo(): return &quot;bar&quot;&apos;, &quot;&amp;lt;string&amp;gt;&quot;, &quot;exec&quot;)&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;compile() 是一个内置方法，因此同时也是文档丰富的。&lt;/div&gt;
&lt;div&gt;exec 模式被用到，因为定义函数需要用多个语句。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; foo_func = FunctionType(foo_code.co_consts[0], globals(), &quot;foo&quot;)&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;聚合全部内容，并将动态创建的函数指定给一个变量。&lt;/div&gt;
&lt;div&gt;那个被前一句代码编译成的函数，成为了生成的代码对象的第一个常量，因此仅仅指向 foo_code 是不充分的。这是 exec 模式的直接后果，因为生成的代码对象可以包含多个常量。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(foo_func())&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;动态生成的函数可以像其它函数一样被调用。&lt;/div&gt;
&lt;h2&gt;结尾&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;除了做实验，需要用到动态创建函数的场景很少。&lt;/li&gt;
&lt;li&gt;玩耍（Toying around） Python 的内部构件是一种深入学习这门语言的好方法。&lt;/li&gt;
&lt;li&gt;如果需要，可以毫不费力地越过解释器/语言的界线。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;还是一如既往地：&lt;strong&gt;不要滥用语言&lt;/strong&gt; （好吧，一点点也无妨，对吧？）&lt;/div&gt;
&lt;div&gt;--------（译文完）--------&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;花下猫语：&lt;/strong&gt; 在上一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/4eWQmJ15QZabNViePCDmNw&quot;&gt;Python进阶：如何将字符串常量转为变量？&lt;/a&gt;》中，我介绍了两种&lt;strong&gt;动态修改变量&lt;/strong&gt; 的方法（globals() 与 exec()）。写完之后，我偶然发现，在自己列的“计划转载清单”中，有这一篇相关的文章，它介绍了&lt;strong&gt;动态定义函数&lt;/strong&gt; 的方法。因为它的相关度太大，而篇幅又是那么小（核心代码只有三行，文中其它内容都是在解释其背后的原理），我觉得如果翻译出来的话，效果会更好，所以就抓紧时间翻译出来了。建议与前一篇文章配合阅读。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 进阶：如何将字符串常量转化为变量？</title>
            <link>https://pythoncat.top/posts/2019-03-17-local/</link>
            <guid>https://pythoncat.top/posts/2019-03-17-local/</guid>
            <pubDate>Sun, 17 Mar 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;前几天，我们&lt;code&gt;Python猫交流学习群&lt;/code&gt; 里的 M 同学提了个问题。这个问题挺有意思，经初次讨论，我们认为它无解。&lt;/div&gt;
&lt;div&gt;然而，我认为它很有价值，应该继续思考怎么解决，所以就在私密的知识星球上记录了下来。&lt;/div&gt;
&lt;div&gt;万万没想到的是，在第二天，有两位同学接连给出了解决方法！&lt;/div&gt;
&lt;div&gt;由此，群内出现了一轮热烈的技术交流。&lt;/div&gt;
&lt;div&gt;本文将相关的内容要点作了梳理，并由此引申到更进一步的学习话题，希望对你有所帮助。&lt;/div&gt;
&lt;h2&gt;1、如何动态生成变量名？&lt;/h2&gt;
&lt;div&gt;M 同学的问题如下：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;打扰一下大家，请教一个问题，已知 list = [‘A’, ‘B’, ‘C’, ‘D’] , 如何才能得到以 list 中元素命名的新列表 A = [], B = [], C = [], D = [] 呢?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;简单理解，这个问题的意思是，&lt;strong&gt;将字符串内容作为其它对象的变量名。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;list 中的元素是字符串，此处的 ‘A’-‘D’ 是&lt;strong&gt;常量&lt;/strong&gt; ，而在要求的结果中，A-D 是&lt;strong&gt;变量&lt;/strong&gt; 。&lt;/div&gt;
&lt;div&gt;如果强行直接将常量当做变量使用，它会报错：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; &apos;A&apos; = []
...SyntaxError: can&apos;t assign to literal&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;报错中的&lt;code&gt;literal&lt;/code&gt; 指的是&lt;code&gt;字面量&lt;/code&gt; ，这是计算机科学中常见的一个概念，&lt;strong&gt;用于表达源代码中的固定值。&lt;/strong&gt; 例如，整数、浮点数、字符串等基本类型，就是字面量。&lt;/div&gt;
&lt;div&gt;字面量指的就是一个量本身，可以理解为一种原子性的实体，当然不能再被赋值了。&lt;/div&gt;
&lt;div&gt;所以，取出的字符串内容，并不能直接用作变量名，需要另想办法。&lt;/div&gt;
&lt;div&gt;有初学者可能会想，list[0] = [] 行不行？当然不行，因为没有出现 A 。那 A = list[0] ，接着 A = [] 呢？那也不行，因为这里的 A 是你凭空定义出来的，而不是从已有条件中生成的。&lt;/div&gt;
&lt;div&gt;当时，群里只有两三个同学参与了讨论，我们没想到解决办法。但是，我觉得这个题目很有意思，值得玩味。&lt;/div&gt;
&lt;div&gt;因为，如果能解决这个问题，那就意味着可以不作预先定义，而是动态地生成变量名，这不仅能减少给变量取名的麻烦，还实现了自动编码！&lt;/div&gt;
&lt;div&gt;可以设想一下未来，人工智能在编写代码的时候，如果能根据已知条件，动态生成变量名，那编写代码的过程不就顺利多了么？（据说，现在已经有人工智能可以编写代码了，不知它在取变量名时，是用的什么方法？）&lt;/div&gt;
&lt;h2&gt;2、办法总是有的&lt;/h2&gt;
&lt;div&gt;最近，学习群里蒙混进来了几个打广告的，为此，我决定提高审核门槛，例如，用群里的问题来作个考核。&lt;/div&gt;
&lt;div&gt;万万没想到的是，第一个被考核到的 Q 同学，几乎不假思索地就说出了一个解决上述问题的思路。而&lt;strong&gt;偏偏就是那么巧&lt;/strong&gt; ，几乎在同时，群内的 J 同学给出了另外一个解决方法（他没看到群内的讨论，而是看到了知识星球的记录，才知道这个问题的）。&lt;/div&gt;
&lt;div&gt;也就是说，前一晚还以为无解的问题，在第二天竟得到了两种不同的解决方法！&lt;/div&gt;
&lt;div&gt;那么，他们的答案是什么呢？&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# J 同学的解答
&amp;gt;&amp;gt;&amp;gt; list1 = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;]
&amp;gt;&amp;gt;&amp;gt; for i in list1:
&amp;gt;&amp;gt;&amp;gt;     globals()[i] = []
&amp;gt;&amp;gt;&amp;gt; A
[]&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这个方法通过修改全局命名空间，巧妙地“定义”出了新的变量。globals() 方法取出来的是一个字典，字符串 ‘A’ 是其中一个键值（key），而这个键值恰恰是全局命名空间中的一个变量，这就实现了从常量到变量的转化。&lt;/div&gt;
&lt;div&gt;在数据结构层面上，空列表 [] 作为一个值（value）跟它的字符串键值绑定在一起，而在运用层面上，它作为变量内容而跟变量名绑定在一起。&lt;/div&gt;
&lt;div&gt;看到这个回答的时候，我就突然想起来了，上个月转载过一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/f9BBe2W1X1p7NcHg665I4A&quot;&gt;Python 动态赋值的陷阱&lt;/a&gt;》，讲的正是&lt;strong&gt;动态地进行变量赋值&lt;/strong&gt; 的问题啊！我似乎只关注了 globals() 与 locals() 用法的区别，却没有真正地掌握它们的原初用途。&lt;/div&gt;
&lt;div&gt;J 同学说，他正是看了那篇文章，才学得了这个方法。这就有意思了，我分享了一个自己囫囵吞枣的知识，然后它被 J 同学吸收掌握，最后反馈回来解决了我的难题。&lt;/div&gt;
&lt;div&gt;我真切地感受到了知识分享的魅力：&lt;strong&gt;知识在流动中获得生命，在碰撞中锃亮色泽。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;同时，我也真切地明白了一个互助的学习团体的好处：&lt;strong&gt;利人者也利己，互助者共同进步。&lt;/strong&gt;&lt;/div&gt;
&lt;h2&gt;3、动态执行代码的方法&lt;/h2&gt;
&lt;div&gt;新进群的 Q 同学，提供了一个不同的答案：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# Q 同学的解答
&amp;gt;&amp;gt;&amp;gt; list1 = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;]
&amp;gt;&amp;gt;&amp;gt; for i in list1:
&amp;gt;&amp;gt;&amp;gt;     exec(f&quot;{i} = []&quot;)
&amp;gt;&amp;gt;&amp;gt; A
[]&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;他的写法用到了 Python 3.6 才引入的 f-strings 特性，事实上，在较低版本中，也是可以实现的，只需要保证 exec() 方法接收的参数是包含了变量 i 的字符串即可，例如这样写：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# 以下代码可替换上例的第 4 行
exec(i + &quot; = []&quot;)
# 或者：
exec(&quot;{} = []&quot;.format(i))
# 或者：
exec(&apos; &apos;.join([i, &apos;= []&apos;]))&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这几种写法的区别只是字符串拼接法的区别，关于如何拼接字符串，以及不同方法之间的区别，可参看《&lt;a href=&quot;https://mp.weixin.qq.com/s/Whrd6NiD4Y2Z-YSCy4XJ1w&quot;&gt;详解Python拼接字符串的七种方式&lt;/a&gt;》。&lt;/div&gt;
&lt;div&gt;Q 同学这个答案的核心在于 exec() 方法，它是内置的，用途是&lt;strong&gt;执行储存在字符串或文件中的代码段。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;它的基础用法如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; exec(&apos;x = 1 + 2&apos;)
&amp;gt;&amp;gt;&amp;gt; x
3

# 执行代码段
&amp;gt;&amp;gt;&amp;gt; s = &quot;&quot;&quot;
&amp;gt;&amp;gt;&amp;gt; x = 10
&amp;gt;&amp;gt;&amp;gt; y = 20
&amp;gt;&amp;gt;&amp;gt; sum = x + y
&amp;gt;&amp;gt;&amp;gt; print(sum)
&amp;gt;&amp;gt;&amp;gt; &quot;&quot;&quot;
&amp;gt;&amp;gt;&amp;gt; exec(s)
30&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;看完了 exec() 的用法，我们再回来看 Q 同学的答案。for-循环中取出来的 i 是字符串，而拼接后的字符串经过 exec() 的处理，就获得了动态编写代码的效果。&lt;/div&gt;
&lt;div&gt;也就是说，因为字符串常量的内容被当做有效代码而执行了，其中的 ‘A’-‘D’ 元素，就取得了新的身份，变成了最终的 A-D 变量名。&lt;/div&gt;
&lt;div&gt;这个方法看起来很简单啊，可是由于 exec() 方法太生僻了，直到 Q 同学提出，我们才醒悟过来。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：在 Python3 中，exec() 是个内置方法；而在 Python2 中，exec 是个语句（statement），另外有个 execfile() 方法，两者相合并，就成了 Python3 中的 exec() 方法。本文使用的是 Python3。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;4、总结&lt;/h2&gt;
&lt;div&gt;抽象一下最初的问题，它实际问的是“如何将字符串内容作为其它对象的变量名”，更进一步地讲是——“&lt;strong&gt;如何将常量转化为变量&lt;/strong&gt; ”。&lt;/div&gt;
&lt;div&gt;使用直接进行赋值的静态方法，行不通。&lt;/div&gt;
&lt;div&gt;两位同学提出的方法都是间接的动态方法：&lt;strong&gt;一个是动态地进行变量赋值，通过修改命名空间而植入变量；一个是动态地执行代码，可以说是通过“走后门”的方式，安插了变量。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;两种方法殊途同归，不管是白猫还是黑猫，它们都抓到了老鼠。&lt;/div&gt;
&lt;div&gt;这两种方法已经给我们带来了很有价值的启发，同时，因为它们，群内小伙伴们更是发散地讨论一些相关联的话题，例如：S 同学提出了另一种修改命名空间中变量的写法、L 同学提到了 eval() 的意义、eval() 与 exec() 的区别、我查到了为什么要慎用 eval() 、C 与 H 同学提到了 eval() 的安全用法…&lt;/div&gt;
&lt;div&gt;虽然，某些话题无法在群聊中充分展开，但是，这些话题知识的延展联系，大大地丰富了本文开头的问题，这一个微小的问题，牵连出来了两个大的知识体系。&lt;/div&gt;
&lt;div&gt;最后，真得感谢群内的这些爱学习的优秀的同志们！除了文中提及的，还有一些同学也做了积极贡献，大家都很给力！&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;《&lt;a href=&quot;https://mp.weixin.qq.com/s/f9BBe2W1X1p7NcHg665I4A&quot;&gt;Python 动态赋值的陷阱&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;《&lt;a href=&quot;https://mp.weixin.qq.com/s/Whrd6NiD4Y2Z-YSCy4XJ1w&quot;&gt;详解Python拼接字符串的七种方式&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;eval()、exec()及其相关函数：&lt;a href=&quot;https://www.tuicool.com/wx/vEbeumE&quot;&gt;https://www.tuicool.com/wx/vEbeumE&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python猫荐书系列之六：文也深度学习，理也深度学习</title>
            <link>https://pythoncat.top/posts/2019-03-08-book6/</link>
            <guid>https://pythoncat.top/posts/2019-03-08-book6/</guid>
            <pubDate>Fri, 08 Mar 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;最近出了两件大新闻，相信大家可能有所耳闻。&lt;/div&gt;
&lt;div&gt;我来当个播报员，给大家转述一下：&lt;/div&gt;
&lt;div&gt;1、中国队在第 11 界罗马尼亚数学大师赛（RMM）中无缘金牌。该项赛事是三大国际赛事之一，被誉为中学奥数的最高难度。&lt;strong&gt;其中一道题，令中国队全军覆没。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;2、一个出自清华姚班，毕业于斯坦福的女博士，她的毕业论文成了学术圈的“爆款”。这篇论文研究的主题是——&lt;strong&gt;如何让机器学会理解人类语言？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;每天的新闻多如牛毛，唯独这两件引起了我的注意。它们跟本期的荐书栏目也是强关联，下面就给大家说道说道。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;上图标出了中国队成绩最好的三名队员。前两人在其它题目全部满分的情况下，第三题竟然是 0 分！什么样的题目能让我们的顶尖高手都束手无策呢？&lt;/div&gt;
&lt;div&gt;算了，题目我就不放出来了（我看不懂，不自找其辱。总之你们知道它很难就得了）。但是，那道题是图论的问题，关于图论，我们可以说说它跟计算机科学的关系。&lt;/div&gt;
&lt;div&gt;图论是数学的一个分支，它研究的最著名问题有&lt;code&gt;柯尼斯堡七桥问题&lt;/code&gt; 与 &lt;code&gt;四色地图问题&lt;/code&gt; ，相信大家都曾见过，而在计算机领域，它也带来了诸多的研究成果：最小生成树问题、旅行商问题（NP困难）、拓扑排序算法、广度优先算法、深度优先算法，等等。&lt;/div&gt;
&lt;div&gt;奥数就这样跟程序员的职业联系了起来。然而，更值得一提的是第二个新闻：它研究的是人工智能领域最前沿的话题，想构建一个&lt;strong&gt;在深度神经网络之上的阅读理解模型&lt;/strong&gt; 。简单地说是，教会计算机来阅读文本的能力。&lt;/div&gt;
&lt;div&gt;这项研究与大家熟知的数字个人助理不同（如 Alexa、Siri、Google Assistant、Cortana），它的难度超越了简单会话与信息匹配的一般性问题，想克服的是文本级阅读理解，与开放性问答等高度抽象层面的难关。&lt;/div&gt;
&lt;div&gt;它的研究成果将给数字个人助理带来质的提升，而对于人类语言文本的阅读理解能力，也必然带来更广阔的应用前途。这一切，都归功于深度学习。&lt;/div&gt;
&lt;div&gt;深度学习是我很感兴趣的领域。&lt;/div&gt;
&lt;div&gt;我们有幸生在这个时代，见证了 AlphaGo 打败人类的顶尖棋手，正在见证各种 AI 技术的出现，无人驾驶、医疗诊断、AI 翻译、金融科技、深度法律…&lt;/div&gt;
&lt;div&gt;我们的未来将被人工智能深远地影响。&lt;/div&gt;
&lt;div&gt;本期Python 猫荐书栏目（系列之六），就以此为话题，推荐给大家两本书：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;它们都叫《深度学习》，但是内容很不一样。&lt;/div&gt;
&lt;div&gt;第一本从应用数学，到深度学习的各种模型、算法与科研问题，走的是极其专业的路线。&lt;/div&gt;
&lt;div&gt;而另一本讲的是深度学习的 60 年发展史，以及对智能时代的一些前瞻性预测，走的是通俗科普的路线。&lt;/div&gt;
&lt;div&gt;如果要强行划分的话，前一本属理科，主要给相关领域的学生与程序员阅读，而后一本则属文科，面向所有对人工智能的历史与未来感兴趣的人群。&lt;/div&gt;
&lt;div&gt;事实上，第一本书被很多人誉为深度学习的圣经，知名度极高，有一个昵称叫作“花书”。&lt;/div&gt;
&lt;div&gt;简单梳理一下它的内容：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;第一部分是深度学习的基础，包含线性代数与概率论等数学知识，以及梯度优化、拟合、偏差、最大似然估计与监督学习等基础概念；&lt;/li&gt;
&lt;li&gt;第二部分是深度学习的关键部分，涉及深度前馈网络、正则化、模型优化的方法、卷积网络、序列建模、与实践应用内容；&lt;/li&gt;
&lt;li&gt;第三部分是深度学习研究，例如线性因子模型、自编码器、表示学习、结构化概率模型、蒙特卡罗方法、直面配分函数、近似推断、深度生成模型，等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;要知道，本专栏是兴趣大于能力，没办法深入剖析这本书的精华，再讲出些令行家也折服的话，但是，这本书值得推荐之处也很显著：它是一种正统的、学院派的、知识全面的、一丝不苟的、偏重理论的书籍，没错，正像是大学里相关专业的指定参考书。&lt;/div&gt;
&lt;div&gt;这就意味着，如果想进入深度学习领域，这本书将是你最好的老师。（而且不用考试，手动滑稽）&lt;/div&gt;
&lt;div&gt;至于第二本《深度学习》，书的副标题是“&lt;strong&gt;智能时代的核心驱动力量&lt;/strong&gt; ”。其实这只是翻译的结果，原书的英文名是《The Deep Learning Revolution》。&lt;/div&gt;
&lt;div&gt;20 世纪 70 年代到 90 年代是深度学习（神经网络）的寒冬，本书作者既是深度学习的先驱与奠基者，也是打破此寒冬，令深度学习东山再起的大功臣。他名叫&lt;code&gt;特伦斯·谢诺夫斯基&lt;/code&gt; （Terrence Sejnowski）。&lt;/div&gt;
&lt;div&gt;特伦斯是谁呢？世界十大AI科学家之一，美国四大国家学院（国家科学院、国家医学院、国家工程院、国家艺术与科学学院）在世仅3位的“&lt;strong&gt;四院院士&lt;/strong&gt; ”之一，全球AI专业会议NIPS基金会主席。&lt;/div&gt;
&lt;div&gt;深度学习的核心技术&lt;strong&gt;玻尔兹曼机&lt;/strong&gt; ，正是由特伦斯与杰弗里·辛顿共同建立的。&lt;/div&gt;
&lt;div&gt;那书的内容是什么呢？这本书在前言中称：&lt;strong&gt;这是一本关于深度学习的过去、现在和未来的指南。&lt;/strong&gt; 在如此宏观的视角下，它主要讲到了一些重要概念的发展、科研群体研究的内容和传承，以及深度学习对当今社会的影响。&lt;/div&gt;
&lt;div&gt;也就是说，它不再关心微观的原理、底层的细节、繁复的逻辑。与第一本书的调性截然不同。&lt;/div&gt;
&lt;div&gt;这本书以第一人称视角讲述，带入了很多个人的动态：读书经历、研究课题、演讲与会议、人际关系、趣闻、甚至还有八卦（例如差点跟女朋友分手的一次会议。PS：他们在一起了，现在也没分开）。&lt;/div&gt;
&lt;div&gt;因此，第二本书的阅读门槛不高，还饶有趣味。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;往期荐书回顾：&lt;/strong&gt;
第一期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/JnoYojDsNHYkpibSfF3hOg&quot;&gt;编写高质量代码改善 Python 程序的 91 个建议&lt;/a&gt;》
第二期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/9RonAqwCXo_lganYvLHgVw&quot;&gt;Python最佳实践指南&lt;/a&gt;》
第三期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/6swAZA7baF26BlrKV7zBFg&quot;&gt;黑客与画家&lt;/a&gt;》
第四期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/RcvYm7Ro_nnMx0ZVrJmtyA&quot;&gt;Python源码剖析&lt;/a&gt;》
第五期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/UxPxSJRHk0R6ffhpl8aSpw&quot;&gt;Python高性能编程&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;-------------荐书完-------------&lt;/div&gt;
&lt;div&gt;世事无巧不成书。似乎每期荐书都会发生一些巧合，因此我得额外交代几句：&lt;/div&gt;
&lt;div&gt;1、我早知第一本书的大名，也翻看过数学部分的一些内容，但是兴趣就止步于此。有打算纳其入荐书系列，但没想到会这么快。至于第二本书，恰好是在上期荐书发布后，中信出版社的营销人员找我约稿，当时这本书还没上市。我并非深度学习领域的专家，只能写写旁观者的言语，既然无法深入，干脆就将它们凑在一起了。&lt;/div&gt;
&lt;div&gt;2、荐书栏目不是专业书评，无法讲透全书的技术精粹，但我仍大着胆写了（之所以拖了这么久才动笔，就是因为过于担心）。一方面逼使自己阅读和查资料，快速归纳与写作；另一方面也确实是希望通过自己的文笔，能够使一部分读者获知到原先不知的信息，产生阅读的兴趣。&lt;/div&gt;
&lt;div&gt;3、就在前几天（2 月 28 日），一位知名的 Python 博主@Vamei 因抑郁症自杀了。我在看资料的时候，发现他也写了第二本《深度学习》的书评。他发布的时间是 1 月 31 日，而在这个时间，新书还未上市。这意味着他可能跟我一样，都收到了出版社的预读本，我们就是那么巧合地在同样的时间里阅读着同一本还未上市的新书。我想，这本书大概就是在给我传递一个讯息。我有很多次想过放弃邀约（无稿费，赠书一本）、放弃写这一篇荐书，直到前几天才真正开始动笔。这个神秘的讯息就这么巧地传过来了。荐书，见人。写完这篇荐书，我要写写他了。&lt;/div&gt;
&lt;div&gt;4、Vamei 的豆瓣主页写道:&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Vamei 是赤道附近一个台风的名字。按照气象规律，台风不常出现在赤道。所以，Vamei是一个离群的风，无所顾忌地生长，不着边际地游荡。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>记一次牙疼补牙的经历</title>
            <link>https://pythoncat.top/posts/2019-03-02-pain/</link>
            <guid>https://pythoncat.top/posts/2019-03-02-pain/</guid>
            <description>你知道牙痛有多难受么？我以前不知道，但这两天知道了。</description>
            <pubDate>Sat, 02 Mar 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你知道牙痛有多难受么？我以前不知道，但这两天知道了。&lt;/div&gt;
&lt;div&gt;我大概有两年没用过右侧的牙吃东西了，因为会有酸疼感。但是，一直没太上心，就没去就医。上周，由于左侧下方的牙龈长了个小包包，我开始逼自己用右侧牙吃东西。然而，就在我开心地吃着下午茶，磕着瓜子吃着桂圆的时候，右侧牙齿突然一阵剧痛。我当时就冒了眼泪。&lt;/div&gt;
&lt;div&gt;当天晚上，牙齿只是有点不舒服，但是不严重。我自己查了下，感觉是牙髓炎，打算着到周末去医院看看。&lt;/div&gt;
&lt;div&gt;第二天，还是隐痛，一阵一阵。不过明显痛感大了些。于是，在傍晚时，我就吃了止痛药和治疗牙髓炎的药。但是，药效一直没发挥作用，到睡前 1 个多小时，我痛得在床上打滚，眼睛都张不开。那一阵持续了挺久，不知道是不是因为洗澡时刷牙刺激到的。&lt;/div&gt;
&lt;div&gt;我当时感觉是右侧下方的最后一颗牙有毛病，在镜子中确实看到牙齿上有个坑。&lt;/div&gt;
&lt;div&gt;第三天是周五，我们去了医院看牙。可是奇怪的是，当天白天，牙齿与我几乎相安无事，没怎么疼，也不怎么严重。医生看了看，说右侧上方的牙齿也蛀掉了！他建议先不动，等牙再疼的时候，做一下检测，确认到底是哪颗牙的毛病。&lt;/div&gt;
&lt;div&gt;既然不疼了，感觉就不急着做手术了，所以我们就打道回府了。然而，白天的无辜的牙齿，到了夜晚就现出了无比狰狞的面目——它持续不断地折磨了我一整晚，以及一早上！&lt;/div&gt;
&lt;div&gt;这次的痛与第二天晚上不大一样，它没有了刺痛感，但是把我左侧的神经全部牵动了——牙疼、牙龈疼、脸部疼、直到头上也疼。这次摸清楚了，左侧下方牙齿不疼，真正疼的是上方的那颗！这个家伙，真会闹事啊，一点都不含蓄了。&lt;/div&gt;
&lt;div&gt;我疼得完全睡不着，左翻翻右翻翻。在前半夜，我盖了厚厚的被子，却寒意阵阵，冷得发抖，牙关打颤。而到了后半夜，体温大逆转，我热得全身冒汗，一度以为自己发烧了。&lt;/div&gt;
&lt;div&gt;为了保留疼，以便醒来去医院就医，所以我没敢吃药，一直忍受着。我尝试了一些方法来减轻痛感：按揉脸颊、眼眶和太阳穴。开始有用，很快又被痛觉淹没。&lt;/div&gt;
&lt;div&gt;然后就到了今天早上，我们再次去了医院。&lt;/div&gt;
&lt;div&gt;医生分别用冷热测试了那颗坏牙，而我没有感觉到疼。然后，他给我拍了片，指着告诉我们，牙齿已经蛀得很深了，已经贴近了牙髓神经，很有可能已经渗透感染了。给了两个方案：一是先用安慰药敷上，如果不再疼，说明没伤到牙髓，就只补牙；二是直接开牙，把神经捣坏，来个三四次治疗，最后补上。&lt;/div&gt;
&lt;div&gt;我们选了后一种。由于一夜没睡，我头疼发困，等打了麻药，我就只会张大嘴，任人“宰割”了——只感觉他用了好几种不同的器械，激激激地在磨牙或者刮来刮去。我看不到，也没有痛感，但是似乎闻到了牙齿被琢磨出的、类似某种建筑材料的味道。&lt;/div&gt;
&lt;div&gt;这次手术以牙洞被暂时填上告终，而这不是最终结果，我可能还得过去三趟。我要成为医院的常客了。而且，这只是对右侧上方的牙齿的治疗，右侧下方那个蛀洞也得填上呢！&lt;/div&gt;
&lt;div&gt;回家的路上，麻药逐渐失效，牙疼虽然已经减轻了，但一直还提醒着自己的存在。而我的头疼不合时宜地来凑热闹！&lt;/div&gt;
&lt;div&gt;在冷雨飘飘的街上，我感觉很无助。突然想到一个问题：古人是怎么应对牙疼的呢？豌豆开玩笑地说等死。又说可能会敷上什么草药之类的。&lt;/div&gt;
&lt;div&gt;牙疼可不会区分朝代啊，蛀牙对我们是一视同仁——现代的卫生条件好很多，但是病灶的诱因也更多，谁不好好呵护自己的牙齿，他/她就必然会被牙齿反噬。&lt;/div&gt;
&lt;div&gt;我想起了自己的不良习惯——总喜欢吃甜食，从小就没有在睡前刷牙的习惯，而每次刷牙都略显马虎…这几年，我用上了电动牙刷，每天也坚持刷两次牙。但是如今看来，过去的毛病要来讨债了，出来混，总是要还的。&lt;/div&gt;
&lt;div&gt;写完这篇东西，我感觉舒服了很多。真得好好反省一下了，年纪不小了，健康问题不该轻视了，年轻的资本可禁不起随意挥霍啊！&lt;/div&gt;
&lt;div&gt;最后，提醒一下大家：一定要呵护好自己的牙啊，保持口腔健康啊，有毛病要及时就医啊。我的惨痛教训在上，请明鉴。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 与家国天下</title>
            <link>https://pythoncat.top/posts/2019-02-24-cat4/</link>
            <guid>https://pythoncat.top/posts/2019-02-24-cat4/</guid>
            <description>身份真是一个有魔力的话题</description>
            <pubDate>Sun, 24 Feb 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;导读：&lt;/strong&gt; Python猫是一只喵星来客，它爱地球的一切，特别爱优雅而无所不能的 Python。我是它的人类朋友豌豆花下猫，被授权润色与发表它的文章。如果你是第一次看到这个系列文章，那我强烈建议，请先看看它写的前几篇文章（链接见文末）,相信你一定会爱上这只神秘的哲学+极客猫的。不多说啦，一起来享用今天的“思想盛宴”吧！&lt;/div&gt;
&lt;div&gt;喵喵，好久不见啦朋友们。刚吃完一餐美食，我觉得好满足啊。&lt;/div&gt;
&lt;div&gt;自从习惯了地球的食物以后，我的肠胃发生了一些说不清道不明的反应。我能从最近的新陈代谢中感觉出来，自己的母胎习性正在逐渐地褪逝。&lt;/div&gt;
&lt;div&gt;人类的食物在改变着我，或者说是在重塑着我。说不定哪天，我会变成一棵白菜，或者一条鱼呢…呸呸呸。我还是想当猫。&lt;/div&gt;
&lt;div&gt;喵生苦短，得抓紧时间更文才行。&lt;/div&gt;
&lt;div&gt;最近，我看到了两件事，觉得有趣极了，就从这开始说吧。第一件事是，一个小有名气的影视明星因为他不配得到的学术精英的身份而遭到讽刺性的打假制度的口诛笔伐；第二件事是，一个功成名就的企业高管因为从城市回到乡村而戏谑性地获得了猫屎的名号。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;身份真是一个有魔力的话题。&lt;/strong&gt; 看见他们的身份错位，我又总会想起自己的境况。&lt;/div&gt;
&lt;div&gt;我（或许）知道自己在过去时态中是谁，但越来越把握不住在现在时态中的自己，更不清楚在未来时间中会是怎样。&lt;/div&gt;
&lt;div&gt;该怎样在人类世界中自处呢？又该怎样跟你们共处呢？&lt;/div&gt;
&lt;div&gt;思了好久，没有答案。脑壳疼，尾巴疼。还是不要想了啦喵。&lt;/div&gt;
&lt;div&gt;继续跟大家聊聊 Python 吧。上次我们说到了&lt;strong&gt;对象的边界问题&lt;/strong&gt; 。无论是固定边界还是弹性边界，这不外乎就是修身的两种志趣，有的对象呢独善其身其乐也融融，有的对象呢兼容并包其理想之光也莹莹。但是，边界问题还没讲完。&lt;/div&gt;
&lt;div&gt;正如儒家经典所阐述：&lt;strong&gt;修身—齐家—治国—平天下&lt;/strong&gt;。里层的势能推展开，走进更广阔的维度。&lt;/div&gt;
&lt;div&gt;Python 对象的边界也不只在自身。这里有一种巧妙的映射关系：&lt;strong&gt;对象（身）—函数（家）—模块（国）—包（天下）&lt;/strong&gt;。个体被纳入到不同的命名空间，并存活在分层的作用域里。（当然，幸运的是，它们并不会受到道德礼法的森严压迫~__~）&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;1、你的名字&lt;/h2&gt;
&lt;div&gt;我们先来审视一下模块。这是一个合适的尺度，由此展开，可以顺利地连接起函数与包。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;模块是什么？&lt;/strong&gt; 任何以&lt;code&gt;.py&lt;/code&gt; 后缀结尾的文件就是一个模块（module）。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;模块的好处是什么？&lt;/strong&gt; 首先，便于拆分不同功能的代码，单一功能的少量代码更容易维护；其次，便于组装与重复利用，Python 以丰富的第三方模块而闻名；最后，模块创造了私密的命名空间，能有效地管理各类对象的命名。&lt;/div&gt;
&lt;div&gt;可以说，模块是 Python 世界中最小的一种自恰的生态系统——除却直接在控制台中运行命令的情况外，&lt;strong&gt;模块是最小的可执行单位。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;前面，我把模块类比成了国家，这当然是不伦不类的，因为你难以想象在现实世界中，会存在着数千数万的彼此殊然有别的国家（我指的可是在地球上，而喵星不同，以后细说）。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;类比法有助于我们发挥思维的作用&lt;/strong&gt; ，因此，不妨就做此假设。如此一来，想想模块间的相互引用就太有趣了，这不是国家间的战争入侵，而是一种人道主义的援助啊，至于公民们的流动与迁徙，则可能成为一场探险之旅的谈资。&lt;/div&gt;
&lt;div&gt;我还对模块的身份角色感兴趣。恰巧发现，在使用名字的时候，它们耍了一个&lt;strong&gt;双姓人的把戏&lt;/strong&gt; 。&lt;/div&gt;
&lt;div&gt;下面请看表演。先创建两个模块，A.py 与 B.py，它们的内容如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# A 模块的内容：
print(&quot;module A : &quot;, __name__)

# B 模块的内容：
import A
print(&quot;module B : &quot;, __name__)&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;其中，&lt;code&gt;__name__&lt;/code&gt; 指的是当前模块的名字。代码的逻辑是：A 模块会打印本模块的名字，B 模块由于引入了 A 模块，因此会先打印 A 模块的名字，再打印本模块的名字。&lt;/div&gt;
&lt;div&gt;那么，结果是如何的呢？&lt;/div&gt;
&lt;div&gt;执行 A.py 的结果：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;module A :  __main__&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;执行 B.py 的结果：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;module A :  test
module B :  __main__&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;你们看出问题的所在了吧！模块 A 前后竟然出现了两个不同的名字。这两个名字是什么意思，又为什么会有这样的不同呢？&lt;/div&gt;
&lt;div&gt;我想这正体现的是&lt;strong&gt;名字的本质&lt;/strong&gt;吧——对自己来说，我就是我，并不需要一个名字来标记；而对他人来说，ta 是芸芸众生的一个，唯有命名才能区分。&lt;/div&gt;
&lt;div&gt;所以，一个模块自己称呼自己的时候（即执行自身时）是“__main__”，而给他人来称呼的时候（即被引用时），就会是该模块的本名。这真是一个巧妙的设定。&lt;/div&gt;
&lt;div&gt;由于模块的名称二重性，我们可以加个判断，将某个模块不对外的内容隐藏起来。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# A 模块的内容：
print(&quot;module A : &quot;, __name__)

if __name__ == &quot;__main__&quot;:
    print(&quot;private info.&quot;)&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;以上代码中，只有在执行 A 模块本身时，才会打印“private info”，而当它被导入到其它模块中时，则不会执行到该部分的内容。&lt;/div&gt;
&lt;h2&gt;2、名字的时空&lt;/h2&gt;
&lt;div&gt;对于生物来说，我们有各种各样的属性，例如姓名、性别、年龄，等等。&lt;/div&gt;
&lt;div&gt;对于 Python 的对象来说，它们也有各种属性。模块是一种对象，”__name__“就是它的一个属性。除此之外，模块还有如下最基本的属性：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import A
&amp;gt;&amp;gt;&amp;gt; print(dir(A))
[&apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;]&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在一个模块的全局空间里，有些属性是全局起作用的，Python 称之为&lt;strong&gt;全局变量&lt;/strong&gt; ，而其它在局部起作用的属性，会被称为&lt;strong&gt;局部变量&lt;/strong&gt; 。&lt;/div&gt;
&lt;div&gt;一个变量对应的是一个属性的名字，会关联到一个特定的值。通过 &lt;code&gt;globals()&lt;/code&gt; 和 &lt;code&gt;locals()&lt;/code&gt; ，可以将变量的“名值对”打印出来。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;x = 1

def foo():
    y = 2
    print(&quot;全局变量：&quot;, globals())
    print(&quot;局部变量：&quot;, locals())

foo()&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在 IDE 中执行以上代码，结果：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;全局变量： {&apos;__name__&apos;: &apos;__main__&apos;, &apos;__doc__&apos;: None, &apos;__package__&apos;: None, &apos;__loader__&apos;: &amp;lt;_frozen_importlib_external.SourceFileLoader object at 0x000001AC1EB7A400&amp;gt;, &apos;__spec__&apos;: None, &apos;__annotations__&apos;: {}, &apos;__builtins__&apos;: &amp;lt;module &apos;builtins&apos; (built-in)&amp;gt;, &apos;__file__&apos;: &apos;C:/pythoncat/A.py&apos;, &apos;__cached__&apos;: None, &apos;x&apos;: 1, &apos;foo&apos;: &amp;lt;function foo at 0x000001AC1EA73E18&amp;gt;}
局部变量： {&apos;y&apos;: 2}&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;可以看出，x 是一个全局变量，对应的值是 1，而 y 是一个局部变量，对应的值是 2.&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;两种变量的作用域不同&lt;/strong&gt; ：局部变量作用于函数内部，不可直接在外部使用；全局变量作用于全局，但是在函数内部只可访问，不可修改。&lt;/div&gt;
&lt;div&gt;与 Java、C++ 等语言不同，Python 并不屈服于解析的便利，并不使用呆滞的花括号来编排作用域，而是用了轻巧简明的缩进方式。不过，所有编程语言在区分变量类型、区分作用域的意图上都是相似的：&lt;strong&gt;控制访问权限与管理变量命名&lt;/strong&gt;。&lt;/div&gt;
&lt;div&gt;关于控制访问权限，在上述例子中，局部变量 y 的作用域仅限于 foo 方法内，若直接在外部使用，则会报错“NameError: name ‘y’ is not defined”。&lt;/div&gt;
&lt;div&gt;关于管理变量命名，不同的作用域管理着各自的独立的名册，一个作用域内的名字所指称的是唯一的对象，而在不同作用域内的对象则可以重名。修改上述例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;x = 1
y = 1

def foo():
    y = 2
    x = 2
    print(&quot;inside foo : x = &quot; + str(x) + &quot;, y = &quot; + str(y))

foo()
print(&quot;outside foo : x = &quot; + str(x) + &quot;, y = &quot; + str(y))&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在全局作用域与局部作用域中命名了相同的变量，那么，打印的结果是什么呢？&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;inside foo : x = 2, y = 2
outside foo : x = 1, y = 1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;可见，同一个名字可以出现在不同的作用域内，互不干扰。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;那么，如何判断一个变量在哪个作用域内？对于嵌套作用域，以及变量名存在跨域分布的情况，要采用何种查找策略呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;Python 设计了&lt;strong&gt;命名空间（namespace）&lt;/strong&gt; 机制，一个命名空间在本质上是一个字典、一个名册，登记了所有变量的名字以及对应的值。 按照记录内容的不同，可分为四类：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;局部命名空间（local namespace），记录了函数的变量，包括函数的参数和局部定义的变量。可通过内置函数 locals() 查看。在函数被调用时创建，在函数退出时删除。&lt;/li&gt;
&lt;li&gt;全局命名空间（global namespace），记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。可通过内置函数 globals() 查看。在模块加载时创建，一直存在。&lt;/li&gt;
&lt;li&gt;内置命名空间（build-in namespace），记录了所有模块共用的变量，包括一些内置的函数和异常。在解释器启动时创建，一直存在。&lt;/li&gt;
&lt;li&gt;命名空间包（namespace packages），包级别的命名空间，进行跨包的模块分组与管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;命名空间总是存在于具体的作用域内，而作用域存在着优先级，查找变量的顺序是：&lt;strong&gt;局部/本地作用域 —&amp;gt; 全局/模块/包作用域 —&amp;gt; 内置作用域。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;命名空间扮演了变量与作用域之间的桥梁角色，承担了管理命名、记录名值对与检索变量的任务。无怪乎《Python之禅》（The Zen of Python）在最后一句中说：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Namespaces are one honking great idea — let’s do more of those!&lt;/p&gt;
&lt;p&gt;——译：命名空间是个牛bi哄哄的主意，应该多加运用！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;3、看不见的客人&lt;/h2&gt;
&lt;div&gt;名字（变量）是身份问题，空间（作用域）是边界问题，命名空间兼而有之。&lt;/div&gt;
&lt;div&gt;这两个问题恰恰是困扰着所有生灵的最核心的问题之二。它们的特点是：无处不在、层出不断、像一个&lt;strong&gt;超级大的被扯乱了的毛线球。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;Python 是一种人工造物，它继承了人类的这些麻烦（这是不可避免的），所幸的是，这种简化版的麻烦能够得到解决。（现在当然是可解决的啦，但若人工智能高度发展以后呢？我看不一定吧。喵，好像想起了一个痛苦的梦。打住。）&lt;/div&gt;
&lt;div&gt;这里就有几个问题（注：每个例子相互独立）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# 例1：
x = x + 1

# 例2：
x = 1
def foo():
    x = x + 1
foo()

# 例3：
x = 1
def foo():
    print(x)
    x = 2
foo()

# 例4：
def foo():
    if False:
        x = 3
    print(x)
foo()

# 例5：
if False:
    x = 3
print(x)&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;下面给出几个选项，请读者们思考一下，给每个例子选一个答案：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;1、没有报错&lt;/p&gt;
&lt;p&gt;2、报错：name ‘x’ is not defined&lt;/p&gt;
&lt;p&gt;3、报错：local variable ‘x’ referenced before assignment&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;下面公布答案了：&lt;/div&gt;
&lt;div&gt;全部例子都报错，其中例 1 和例 5 是第一类报错，即变量未经定义不可使用，而其它例子都是第二类报错，即已定义却未赋值的变量不可使用。为什么会报错？为什么报错会不同？下面逐一解释。&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;例 1 是一个定义变量的过程，本身未完成定义，而等号右侧就想使用变量 x，因此报变量未定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例 2 和例 3 中，已经定义了全局变量 x，如果只在 foo 函数中引用全局变量 x 或者只是定义新的局部变量 x 的话，都不会报错，但现在既有引用又有重名定义，这引发了一个新的问题。请看下例的解释。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例 4 中，if 语句判断失效，因此不会执行到 “x=3” 这句，照理来说 x 是未被定义。这时候，在 locals() 局部命名空间中也是没有内容的（读者可以试一下）。但是 print 方法却报找到了一个未赋值的变量 x ，这是为什么呢？&lt;/p&gt;
&lt;p&gt;使用 dis 模块查看 foo 函数的字节码：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;LOAD_FAST 这句说明它在局部作用域中找到了变量名 x。既然此时在 locals() 局部命名空间中没有内容，那局部作用域中找到的 x 是来自哪里的呢？（20190513update：有错，修改）&lt;/p&gt;
&lt;p&gt;实际上，Python 虽然是所谓的解释型语言，但它也有&lt;strong&gt;编译的过程&lt;/strong&gt; （跟 Java 等语言的编译过程不同）。在例 2-4 中，编译器先将 foo 方法解析成一个&lt;strong&gt;抽象语法树&lt;/strong&gt;（abstract syntax tree），然后扫描树上的名字（name）节点，接着，所有被扫描出来的变量名，都会&lt;strong&gt;作为局部作用域的变量名存入内存（栈？）中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在编译期之后，局部作用域内的变量名已经确定了，只是没有赋值。在随后的解释期（即代码执行期），如果有赋值过程，则变量名与值才会被存入局部命名空间中，可通过 locals() 查看。只有存入了命名空间，变量才算真正地完成了定义（声明+赋值）。&lt;/p&gt;
&lt;p&gt;而上述 3 个例子之所以会报错，原因就是变量名已经被解析成局部变量，但是却未曾被赋值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以推论：在局部作用域中查找变量，实际上是分查内存与查命名空间两步的。&lt;/strong&gt; 另外，若想在局部作用域内修改全局变量，需要在作用域中写上 “global x”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例 5 是作为例 4 的比对，也是对它的原理的补充。它们的区别是，一个不在函数内，一个在函数内，但是报错完全不同。前面分析了例 4 的背后原理是编译过程和抽象语法树，如果这个原理对例 5 也生效，那两者的报错应该是一样的。现在出现了差异，为什么呢？&lt;/p&gt;
&lt;p&gt;我得承认，这触及了我的知识盲区。我们可以推测，说例 5 的编译过程不同，它没有解析抽象语法树的步骤，但是，继续追问下去，为什么不同，为什么没有解析语法树的步骤呢？如果说是出于对解析函数与解析模块的代价考虑，或者其它考虑，那么新的问题是，编译与解析的底层原理是什么，如果有其它考虑，会是什么？&lt;/p&gt;
&lt;p&gt;这些问题真不可爱，一个都答不上。但是，自己一步一步地思考探寻到这一层，又能怪谁呢？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;回到前面说过的话，命名空间是身份与边界的集成问题，它跟作用域密切相关。如今看来，编译器还会掺和一脚，把这些问题搅拌得更加复杂。&lt;/div&gt;
&lt;div&gt;本来是在探问 Python 中的边界问题，到头来，却触碰到了自己的&lt;strong&gt;知识边界&lt;/strong&gt;。真是反讽啊。（这一趟探知一个人工造物的身份问题之旅，最终是否会像走迷宫一般，进入到自己身份的困境之中？）&lt;/div&gt;
&lt;h2&gt;4、边界内外的边界&lt;/h2&gt;
&lt;div&gt;暂时把那些不可爱的问题抛开吧，继续说修身齐家治国平天下。&lt;/div&gt;
&lt;div&gt;想要把国治理好，就不得不面对更多的国内问题与国际问题。&lt;/div&gt;
&lt;div&gt;先看一个大家与小家的问题：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;def make_averager():
    count = 0
    total = 0
    def averager(new_value):
        nonlocal count, total
        count += 1
        total += new_value
        return total / count
    return averager

averager = make_averager()
print(averager(10))
print(averager(11))

### 输出结果：
10.0
10.5&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这里出现了嵌套函数，即函数内还包含其它函数。外部—内部函数的关系，就类似于模块—外部函数的关系，同样地，它们的作用域关系也相似：外部函数作用域—内部函数作用域，以及模块全局作用域—外部函数作用域。在内层作用域中，可以访问外层作用域的变量，但是不能直接修改，除非使用 nonlocal 作转化。&lt;/div&gt;
&lt;div&gt;Python 3 中引入了 nonlocal 关键字来标识外部函数的作用域，它处于全局作用域与局部作用域之间，即 global—nonlocal—local 。也就是说，国—大家—小家。&lt;/div&gt;
&lt;div&gt;上例中，nonlocal 关键字使得小家（内部函数）可以修改大家（外部函数）的变量，但是该变量并不是创建于小家，当小家函数执行完毕时，它并无权限清理这些变量。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;nonlocal 只带来了修改权限，并不带来回收清理的权限&lt;/strong&gt; ，这导致外部函数的变量突破了原有的生命周期，成为&lt;strong&gt;自由变量&lt;/strong&gt;。上例是一个求平均值的函数，由于自由变量的存在，每次调用时，新传入的参数会跟自由变量一起计算。&lt;/div&gt;
&lt;div&gt;在计算机科学中，引用了&lt;strong&gt;自由变量的函数被称为闭包（Closure）。&lt;/strong&gt; 在本质上，闭包就是一个突破了局部边界，所谓“跳出三界外，不在五行中”的法外之物。每次调用闭包函数时，它可以继续使用上次调用的成果，这不就好比是一个转世轮回的人（按照某种宗教的说法），仍携带着前世的记忆与技能么？&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;打破边界，必然带来新的身份问题，此是明证。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;然而，人类并不打算 fix 它，因为他们发现了这种&lt;strong&gt;身份异化&lt;/strong&gt;的特性可以在很多场合发挥作用，例如装饰器与函数式编程。适应身份异化，并从中获得好处，这可是地球人类的天赋。&lt;/div&gt;
&lt;div&gt;讲完了这个分家的话题，让我们放开视野，看看天下事。&lt;/div&gt;
&lt;div&gt;计算机语言中的包（package）实际是一种目录结构，以文件夹的形式进行封装与组织，内容可涵括各种模块（py 文件）、配置文件、静态资源文件等。&lt;/div&gt;
&lt;div&gt;与包相关的话题可不少，例如内置包、第三方包、包仓库、如何打包、如何用包、虚拟环境，等等。这是可理解的，更大的边界，意味着更多的关系，更大的边界，也意味着更多的知识与未知。&lt;/div&gt;
&lt;div&gt;在这里，我想聊聊 Python 3.3 引入的&lt;code&gt;命名空间包&lt;/code&gt; ，因为它是对前面谈论的所有话题的延续。然而，关于它的背景、实现手段与使用细节，都不重要，我那敏感而发散的思维突然捕捉到了一种&lt;strong&gt;相似结构&lt;/strong&gt;，似乎这才更值得说。&lt;/div&gt;
&lt;div&gt;运用命名空间包的设计，不同包中的相同的命名空间可以联合起来使用，由此，不同目录的代码就被归纳到了一个共同的命名空间。也就是说，多个本来是相对独立的包，借由同名的命名空间，竟然实现了超远距离的瞬间联通，简直奇妙。&lt;/div&gt;
&lt;div&gt;我想到了&lt;strong&gt;空间折叠&lt;/strong&gt;，一种无法深说，但却实实在在地辅助了我从喵星穿越到地球的技术。两个包，两个天下，两个宇宙，它们的距离与边界被穿透的方式何其相似！&lt;/div&gt;
&lt;div&gt;我着迷于这种相似结构。在不同的事物中，相似性的出现意味着一种更高维的法则的存在，而在不同的法则中，新的相似性就意味着更抽象的法则。&lt;/div&gt;
&lt;div&gt;学习了 Python 之后，我想通过对它的考察，来回答关乎自身的相似问题…&lt;/div&gt;
&lt;div&gt;啊喵，不知不觉竟然写了这么久，该死的皮囊又在咕咕叫了——地球上的食物可真抠门，也不知道你们人类是怎么忍受得住这几百万年的驯化过程的…&lt;/div&gt;
&lt;div&gt;就此搁笔，觅食去了。亲爱的读者们，后会有期~~~&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>[译]PEP 380--子生成器的语法</title>
            <link>https://pythoncat.top/posts/2019-02-16-pep/</link>
            <guid>https://pythoncat.top/posts/2019-02-16-pep/</guid>
            <pubDate>Sat, 16 Feb 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;导语：&lt;/strong&gt; PEP（Python增强提案）几乎是 Python 社区中最重要的文档，它们提供了公告信息、指导流程、新功能的设计及使用说明等内容。对于学习者来说，PEP 是非常值得一读的第一手材料，学习中遇到的大部分难题，都能在 PEP 中找到答案或者解决思路。&lt;/div&gt;
&lt;div&gt;我翻译了几篇 PEP，这么做的目的一方面是为了加强学习，另一方面也是为了锻炼自己的英文水平。Python 与 English，都是如此重要。翻译能将两者巧妙地结合起来，真是一举两得。&lt;/div&gt;
&lt;div&gt;本文介绍了子生成器的语法，即 yield from 语法。其它与生成器相关的 PEP 有 3 篇，翻译的结果附在了本文末尾。若有对翻译感兴趣的同学，可在 Github 上关注下我创建的项目 &lt;code&gt;peps-cn&lt;/code&gt;  。&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;&lt;strong&gt;PEP原文 ：&lt;/strong&gt; &lt;a href=&quot;https://www.python.org/dev/peps/pep-0380/&quot;&gt;https://www.python.org/dev/peps/pep-0380/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP标题：&lt;/strong&gt; Syntax for Delegating to a Subgenerator&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP作者：&lt;/strong&gt; Gregory Ewing&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;创建日期：&lt;/strong&gt; 2009-02-13&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;合入版本：&lt;/strong&gt; 3.3&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; ：&lt;a href=&quot;https://zhuanlan.zhihu.com/pythonCat&quot;&gt;豌豆花下猫&lt;/a&gt;（&lt;strong&gt;Python猫&lt;/strong&gt; 公众号作者）&lt;/div&gt;
&lt;h2&gt;目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;摘要&lt;/li&gt;
&lt;li&gt;PEP接受&lt;/li&gt;
&lt;li&gt;动机&lt;/li&gt;
&lt;li&gt;提议
&lt;ul&gt;
&lt;li&gt;StopIteration 的增强&lt;/li&gt;
&lt;li&gt;形式语义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基本原理
&lt;ul&gt;
&lt;li&gt;重构原则&lt;/li&gt;
&lt;li&gt;结束方式&lt;/li&gt;
&lt;li&gt;作为线程的生成器&lt;/li&gt;
&lt;li&gt;语法&lt;/li&gt;
&lt;li&gt;优化&lt;/li&gt;
&lt;li&gt;使用StopIteration来返回值&lt;/li&gt;
&lt;li&gt;被拒绝的建议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;批评&lt;/li&gt;
&lt;li&gt;可选的提案&lt;/li&gt;
&lt;li&gt;附加材料&lt;/li&gt;
&lt;li&gt;参考资料&lt;/li&gt;
&lt;li&gt;版权&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;摘要&lt;/h2&gt;
&lt;div&gt;为生成器提出了一种新的语法，用于将部分的操作委派给其它的生成器。这使得一部分包含“yield”的代码段，可以被分离并放置到其它生成器中。与此同时，子生成器会返回一个值，交给委派生成器（delegating generator）使用。&lt;/div&gt;
&lt;div&gt;当一个生成器再次 yield 被另一个生成器生成的值时，该语法还创造了一些优化的可能。&lt;/div&gt;
&lt;h2&gt;PEP接受&lt;/h2&gt;
&lt;div&gt;Guido 于 2011 年 6 月 26 日正式接受本 PEP。&lt;/div&gt;
&lt;h2&gt;动机&lt;/h2&gt;
&lt;div&gt;Python 的生成器是一种协程，但有一个限制，它只能返回值给直接的调用者。这意味着包含了 yield 的代码段不能像其它代码段一样，被拆分并放入到单独的函数中。如果做了这样的分解，就会导致被调用的函数本身成为一个生成器，并且必须显式地迭代这个生成器，以便重新 yield 它产生的所有值。&lt;/div&gt;
&lt;div&gt;如果只关心生成值的过程，那么可以不费劲地使用如下的循环：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;for v in g:
    yield v&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;但是，如果在调用&lt;code&gt;send()&lt;/code&gt;，&lt;code&gt;throw()&lt;/code&gt;和&lt;code&gt;close()&lt;/code&gt;的情况下，要使子生成器与调用者正确地交互，就相当困难。如后面所说，必要的代码非常复杂，因此想要正确地处理所有特殊情况，将会非常棘手。&lt;/div&gt;
&lt;div&gt;一种新的语法被提出来解决此问题。在最简单的用例中，它等同于上面的 for-循环，并且可以处理生成器的所有的行为，同时还能用简单而直接的方式进行重构。&lt;/div&gt;
&lt;h2&gt;提议&lt;/h2&gt;
&lt;div&gt;以下的新的生成器语法将被允许在生成器的内部使用：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;yield from &amp;lt;expr&amp;gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;其中 &amp;lt;expr&amp;gt; 表达式作用于可迭代对象，从迭代器中提取元素。该迭代器会遍历到耗尽，在此期间，它直接向包含 yield from 表达式的调用者生成器（即“委托生成器”）生成和接收值。&lt;/div&gt;
&lt;div&gt;此外，当该迭代器是一个生成器时，则此生成器可以执行 return 语句返回一个值，而该值将成为 yield from 表达式的值。&lt;/div&gt;
&lt;div&gt;yield from 表达式的完整语义可通过生成器协议来描述如下：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;迭代器返回的任何值都直接传给调用者。&lt;/li&gt;
&lt;li&gt;使用 send() 发送给委托生成器的任何值都直接传给迭代器。如果发送的值是 None，则调用迭代器的 &lt;code&gt;__next__()&lt;/code&gt; 方法。如果发送的值不是 None，则调用迭代器的 send() 方法。如果调用引发了 StopIteration，则恢复委托生成器。任何其它异常都会传递给委托生成器。&lt;/li&gt;
&lt;li&gt;除 GeneratorExit 以外，任何传给委托生成器的异常都会传给迭代器的 throw() 方法。如果调用引发 StopIteration，则恢复委托生成器。任何其它异常都会传递给委托生成器。&lt;/li&gt;
&lt;li&gt;如果传给委托生成器的是 GeneratorExit 异常，或者调用委托生成器的 close() 方法，则迭代器的 close() 方法会被调用（如果有）。如果调用时出现异常，则会传给委托生成器。否则的话，在委托生成器中抛出 GeneratorExit。&lt;/li&gt;
&lt;li&gt;yield from 表达式的值是迭代器终止时引发的 StopIteration 异常的第一个参数。&lt;/li&gt;
&lt;li&gt;生成器里的 return expr 导致从生成器退出时引发 StopIteration(expr)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;StopIteration的增强功能&lt;/h2&gt;
&lt;div&gt;为方便起见，StopIteration 异常被赋予了一个 value 属性，来保存它的第一个参数，若无参数，则为 None。&lt;/div&gt;
&lt;h2&gt;正式的语义&lt;/h2&gt;
&lt;div&gt;本节使用 Python 3语法。&lt;/div&gt;
&lt;div&gt;1、&lt;code&gt;RESULT = yield from EXPR&lt;/code&gt; 语句等同于以下语句：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;_i = iter(EXPR)
try:
    _y = next(_i)
except StopIteration as _e:
    _r = _e.value
else:
    while 1:
        try:
            _s = yield _y
        except GeneratorExit as _e:
            try:
                _m = _i.close
            except AttributeError:
                pass
            else:
                _m()
            raise _e
        except BaseException as _e:
            _x = sys.exc_info()
            try:
                _m = _i.throw
            except AttributeError:
                raise _e
            else:
                try:
                    _y = _m(*_x)
                except StopIteration as _e:
                    _r = _e.value
                    break
        else:
            try:
                if _s is None:
                    _y = next(_i)
                else:
                    _y = _i.send(_s)
            except StopIteration as _e:
                _r = _e.value
                break
RESULT = _r&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;2、在生成器中，&lt;code&gt;return value&lt;/code&gt; 语句在语义上等同于 &lt;code&gt;raise StopIteration(value)&lt;/code&gt; ，除了一点，当前返回的生成器中的 except 子句无法捕获该异常。&lt;/div&gt;
&lt;div&gt;3、 StopIteration 异常的行为就像这样定义：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;class StopIteration(Exception):

    def __init__(self, *args):
        if len(args) &amp;gt; 0:
            self.value = args[0]
        else:
            self.value = None
        Exception.__init__(self, *args)&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;基本原理&lt;/h2&gt;
&lt;h3&gt;重构原则&lt;/h3&gt;
&lt;div&gt;上面提到的大多数语义，其背后的基本原理源于一种对生成器代码进行重构的愿望。即希望可以将包含一个或多个 yield 表达式的代码段，分离进一个单独的函数中（使用常规手段来处理作用域范围内的变量引用，等等），并通过 yield from 表达式来调用该函数。&lt;/div&gt;
&lt;div&gt;在合理可行的情况下，这种复合而成的生成器的行为应该跟原始的非分离的生成器完全相同，包括调用 &lt;code&gt;__next __()&lt;/code&gt; 、send()、throw() 和 close() 。&lt;/div&gt;
&lt;div&gt;子迭代器（而非生成器）的语义被选择成为生成器案例的合理泛化（generalization）。&lt;/div&gt;
&lt;div&gt;所提出的语义在重构方面具有如下限制：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;一个捕获了 GenetatorExit 却不重新抛出的代码块，不能在完全保留相同行为的情况下被分离出去。&lt;/li&gt;
&lt;li&gt;如果将 StopIteration 异常抛进了委托生成器中，则分离的生成器的行为跟原始代码的行为可能会不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;由于这些用例几乎不存在，因此不值得为支持它们而考虑额外的复杂性。&lt;/div&gt;
&lt;h3&gt;结束方式&lt;/h3&gt;
&lt;div&gt;当在 yield from 处挂起时，并且使用 close() 方法显式地终止委托生成器时，关于是否要一并终止子迭代器，存在一些争议。一个反对的论据是，如果在别处存在对子迭代器的引用，这样做会导致过早结束它。&lt;/div&gt;
&lt;div&gt;对非引用计数型的 Python 实现的考虑，导致了应该显式地结束的结论，以便在所有类型的 Python 实现上，显式地结束子迭代器与非重构的迭代器，能具有相同的效果。&lt;/div&gt;
&lt;div&gt;这里做的假设是，在大多数用例中，子迭代器不会被共享。在子迭代器被共享的稀有情况下，可通过一个阻塞调用 throw() 和 close() 的装饰器来实现，或者使用除 yield from 以外的方法来调用子迭代器。&lt;/div&gt;
&lt;h3&gt;作为线程的生成器&lt;/h3&gt;
&lt;div&gt;使生成器能够 return 值的动机，还考虑到使用生成器来实现轻量级的线程。当以这种方式使用生成器时，将轻量级线程的计算扩散到许多函数上就会是合理的。人们希望能够像调用普通函数一样调用子生成器，传递给它参数并接收返回值。&lt;/div&gt;
&lt;div&gt;使用提议的语法，像以下的表达式&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;y = f(x)&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;其中 f 是一个普通的函数，就可以被转化成一个委托调用&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;y = yield from g(x)&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;其中 g 是生成器。通过把 g 想象成一个普通的能被 yield 语句挂起的函数，人们可以推断出结果代码的行为。&lt;/div&gt;
&lt;div&gt;当以这种方式把生成器作为线程使用时，通常人们不会对 yield 所传入或传出的值感兴趣。但是，也有一些例子，线程可以作为 item 的生产者或消费者。yield from 表达式允许线程的逻辑被扩散到所需的尽可能多的函数中，item 的生产与消费发生在任意的子函数中，并且这些 item 会自动路由到/去它们的最终来源/目的地。&lt;/div&gt;
&lt;div&gt;对于 &lt;code&gt;throw()&lt;/code&gt; 与 &lt;code&gt;close()&lt;/code&gt; ，可以合理地预期，如果从外部向线程内抛入了一个异常，那么首先应该在线程挂起处的最内部的生成器中引发，再从那里向外传递；而如果线程是从外部调用 close() 来终结的，那也应该从最内部往外地终止处于活动态的生成器链。&lt;/div&gt;
&lt;h3&gt;语法&lt;/h3&gt;
&lt;div&gt;所提出的特定语法被选中，像它的含义所暗示，并没有引入任何新的关键词，且清晰地突出了它与普通 yield 的不同。&lt;/div&gt;
&lt;h3&gt;优化&lt;/h3&gt;
&lt;div&gt;当存在一长串生成器时，使用专门的语法就为优化提供了可能性。这种生成器链可能存在，例如，当递归遍历树结构时。在链上传递 &lt;code&gt;__next__()&lt;/code&gt; 的调用与 yield 返回值，可能造成 O(n) 开销，最坏情况下会是 O(n**2)。&lt;/div&gt;
&lt;div&gt;可能的策略是向生成器对象添加一个槽（slot）来保存委派给它的生成器。当在生成器上调用 &lt;code&gt;__next__()&lt;/code&gt; 或 send() 时，首先检查该槽，如果非空，则它引用的生成器将会被激活。如果引发了 StopIteration，该槽会被清空，并且主生成器会被激活。&lt;/div&gt;
&lt;div&gt;这将减少一系列 C 函数调用的委托开销，并不涉及 Python 代码的执行。一种可能的增强方法是在循环中遍历整个生成器链，并直接激活最后一个生成器，尽管 StopIteration 的处理会比较复杂。&lt;/div&gt;
&lt;h3&gt;使用StopIteration来返回值&lt;/h3&gt;
&lt;div&gt;有多种方法可以将生成器的返回值传回。也有一些替代的方法，例如将其存储为生成器-迭代器对象的属性，或将其作为子生成器的 close() 方法的调用值返回。然而，本 PEP 提议的机制很有吸引力，有如下理由：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;使用泛化的 StopIteration 异常，可以使其它类型的迭代器轻松地加入协议，而不必增加额外的属性或 close() 方法。&lt;/li&gt;
&lt;li&gt;它简化了实现，因为子生成器的返回值变得可用的点与引发异常的点相同。延迟到任意时间都需要在某处存储返回值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;被拒绝的建议&lt;/h3&gt;
&lt;div&gt;一些想法被讨论并且拒绝了。&lt;/div&gt;
&lt;div&gt;建议：应该有一些方法可以避免对&lt;code&gt;__next__()&lt;/code&gt; 的调用，或者用带有指定值的 send() 调用来替换它，目的是支持对生成器作装饰，以便可以自动地执行初始的 &lt;code&gt;__next__()&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;决议：超出本提案的范围。这种生成器不该与 yield from 一起使用。&lt;/div&gt;
&lt;div&gt;建议：如果关闭一个子迭代器时，引发了带返回值的 StopIteration 异常，则将该值从 close() 调用中返回给委托生成器。&lt;/div&gt;
&lt;div&gt;此功能的动机是为了通过关闭生成器，传信号给传入生成器的最后的值。被关闭的生成器会捕获 GeneratorExit ，完成其计算并返回一个结果，该结果最终成为 close() 调用的返回值。&lt;/div&gt;
&lt;div&gt;决议：close() 与 GeneratorExit 的这种用法，将与当前的退出（bail-out）与清理机制的角色不兼容。这要求在关闭子生成器后、关闭一个委托生成器时，该委托生成器可以被恢复，而不是重新引发 GeneratorExit。但这是不可接受的，因为调用 close() 进行清理的意图，无法保证委托生成器能正确地终止。&lt;/div&gt;
&lt;div&gt;通过其它方式，可以更好地处理向消费者告知（signal）最后的值的问题，例如发送一个哨兵值（sentinel value）或者抛入一个被生产者与消费者都认可的异常。然后，消费者可以检查该哨兵或异常，通过完成其计算并正常地返回，来作响应。这种方案在存在委托的情况下表现正确。&lt;/div&gt;
&lt;div&gt;建议：如果 close() 不返回值，如果出现 StopIteration 中带有非 None 的值，则抛出一个异常。&lt;/div&gt;
&lt;div&gt;决议：没有明确的理由如此做。忽略返回值在 Python 中的任何其它地方，都不会被视为错误。&lt;/div&gt;
&lt;h2&gt;批评&lt;/h2&gt;
&lt;div&gt;根据本提案，yield from 表达式的值将以跟普通 yield 表达式非常不同的方式得出。这意味着其它不包含 yield 表达式的语法可能会更合适，但到目前为止，还没有提出可接受的替代方案。被拒绝的替代品包括 call、delegate 和 gcall。&lt;/div&gt;
&lt;div&gt;有人提议，应该使用子生成器中除 return 以外的某些机制，来处理 yield from 表达式的返回值。但是，这会干扰将子生成器视为可挂起函数的目的，因为它不能像其它函数一样 return 值。&lt;/div&gt;
&lt;div&gt;有人批评，说使用异常来传递返回值是“滥用异常”，却没有任何具体的理由来证明它。无论如何，这只是一种实现的建议；其它机制可以在不丢失本提案的任何关键特性的情况下使用。&lt;/div&gt;
&lt;div&gt;有人建议，使用与 StopIteration 不同的异常来返回值，例如 GeneratorReturn。但是，还没有令人信服的实际理由被提出，并且向 StopIteration 添加 value 属性减轻了从异常（该异常可能存在也可能不存在）中提取返回值的所有困难。此外，使用不同的异常意味着，与普通函数不同，生成器中不带值的 return，将不等同于 &lt;code&gt;return None&lt;/code&gt; 。&lt;/div&gt;
&lt;h2&gt;可选的提案&lt;/h2&gt;
&lt;div&gt;之前已经提到了类似的提议，有些语法使用 yield * 而不是 yield from。虽然 yield * 更简洁，但是有争议的是，它看起来与普通的 yield 太相似了，可能在阅读代码时会忽视了其中的差异。&lt;/div&gt;
&lt;div&gt;据作者所知，之前的提案只关注于 yield 产生值，因此遭受到了批评，即他们所替代的两行 for 循环并没有足够令人厌烦，不足以让人为新的语法辩护。通过处理完整的生成器协议，本提案提供了更多的好处。&lt;/div&gt;
&lt;h2&gt;附加材料&lt;/h2&gt;
&lt;div&gt;本提案的语法的一些用例已经被提供出来，并且基于上面概括的第一个优化的原型也已实现。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://www.cosc.canterbury.ac.nz/greg.ewing/python/yield-from/&quot;&gt;Examples and Implementation&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;可以从跟踪器问题的 &lt;a href=&quot;https://bugs.python.org/issue11682&quot;&gt;issue 11682&lt;/a&gt; 中获得针对 Python 3.3 实现的升级版本。&lt;/div&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;div&gt;[1] &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2011-June/112010.html&quot;&gt;https://mail.python.org/pipermail/python-dev/2011-June/112010.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[2] &lt;a href=&quot;http://www.cosc.canterbury.ac.nz/greg.ewing/python/yield-from/&quot;&gt;http://www.cosc.canterbury.ac.nz/greg.ewing/python/yield-from/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[3] &lt;a href=&quot;http://bugs.python.org/issue11682&quot;&gt;http://bugs.python.org/issue11682&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;版权&lt;/h2&gt;
&lt;div&gt;本文档已经放置在公共领域。源文档：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/python/peps/blob/master/pep-0380.txt&quot;&gt;https://github.com/python/peps/blob/master/pep-0380.txt&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;-------------（译文完）-------------&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP背景知识&lt;/strong&gt; ：&lt;a href=&quot;https://mp.weixin.qq.com/s/oRoBxZ2-IyuPOf_MWyKZyw&quot;&gt;学习Python，怎能不懂点PEP呢？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP翻译计划&lt;/strong&gt; ：&lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;https://github.com/chinesehuazhou/peps-cn&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/vjQLlmH5QV-zAre7tVCxSA&quot;&gt;[译] PEP 255—简单的生成器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/M79svUpskZQz15SxEfIWbQ&quot;&gt;[译] PEP 342—增强型生成器：协程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/fyzFo8btDelxZikMerm7Qg&quot;&gt;[译] PEP 525—异步生成器&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python之父重回决策层，社区未来如何发展？</title>
            <link>https://pythoncat.top/posts/2019-02-14-Guido/</link>
            <guid>https://pythoncat.top/posts/2019-02-14-Guido/</guid>
            <pubDate>Thu, 14 Feb 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;春节假期结束了，大家陆续地重回到原来的生活轨道上。假期是一个很好的休息与调节的机会，同时，春节还有辞旧迎新的本意，它是新的轮回的开端。&lt;/div&gt;
&lt;div&gt;在 Python 社区里，刚发生了一件大事，同样有开启新纪元的意义：在”Python 之父” Guido van Rossum 宣布卸任 BDFL（终身仁慈独裁者）后，Python 核心开发者们历经半年多的时间，终于为新的治理方案选出了第一届的“执政成员”。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;2 月 4 日，经过为期 2 周的投票，Python 社区选出了第一届的指导委员会的 5 名成员：Barry Warsaw、Brett Cannon、Carol Willing、Guido van Rossum、Nick Coghlan。&lt;/div&gt;
&lt;div&gt;前段时间，我曾回顾了 Python 之父的退位风波、翻译了各种治理提案的汇总介绍、也分析了核心开发者的投票意向（PS：可通过文末链接进行查看）。本文是对此事件的跟踪报道，也是一个阶段性的句号。随着第一届指导委员会成员的确定，Python 社区将迎来一个新的安稳的过渡期。本文的意义，就是向各位 Python 开发者/学习者/爱好者宣告这个好消息。&lt;/div&gt;
&lt;div&gt;核心开发者的自治模式迎来如此重大的转变，这本就是一件值得关注的大事。Python 社区的未来走向与此息息相关，而这种治理模式的成败，也会为其它技术社区提供极好的参照系。&lt;/div&gt;
&lt;h2&gt;1、指导委员会是什么？&lt;/h2&gt;
&lt;div&gt;关于指导委员会（Steering Council），它是 7 种治理方案中最晚被提出，但却最被广泛接收的一个，最终经过投票成为了社区里新的治理方案。该治理方案以 5 人组成的指导委员会作为最高决策层，并允许在必要的时候，将决策权委派给其它团队或开发者代表。&lt;/div&gt;
&lt;div&gt;指导委员会拥有至高的权力，但它的行事原则是：boring、simple、comprehensive、flexible and light-weight，具体而言则是，通过设定一系列的基础性的、清晰的、灵活的、轻量的规则及流程，来“指导”社区的治理工作。&lt;/div&gt;
&lt;div&gt;指导委员会可以直接行使某些权力，例如批准或驳回 PEP、更新项目的行为守则、跟软件基金会一同管理项目资产等等，然而，过分行驶权力的方式并不受鼓励。指导委员会与其它治理提案的关键区别就在于，它将扮演规则制定者的角色，指导、引导以及协调社区工作，只有在关键时候，才会行使最终的裁决权。&lt;/div&gt;
&lt;div&gt;指导委员会的职能是：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Maintain the quality and stability of the Python language and CPython interpreter，维护 Python 语言及 CPython 解释器的质量与稳定性&lt;/li&gt;
&lt;li&gt;Make contributing as accessible, inclusive, and sustainable as possible，尽可能使做贡献是便利的、包容的与可持续的&lt;/li&gt;
&lt;li&gt;Formalize and maintain the relationship between the core team and the PSF，巩固核心团队与 Python 软件基金会的关系&lt;/li&gt;
&lt;li&gt;Establish appropriate decision-making processes for PEPs，为 PEP 建立恰当的决策流程&lt;/li&gt;
&lt;li&gt;Seek consensus among contributors and the core team before acting in a formal capacity，为贡献者与核心团队寻求共识&lt;/li&gt;
&lt;li&gt;Act as a “court of final appeal” for decisions where all other methods have failed，当其它所有方法都失败时扮演“最终裁决法庭”的角色&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;这个治理模式是借鉴自 Django 项目，详细内容参见 PEP-13。&lt;/div&gt;
&lt;h2&gt;2、指导委员会的成员？&lt;/h2&gt;
&lt;div&gt;指导委员会的固定成员是 5 人，且最多允许两人来自同一家企业。换届频率是每个 Python 发行版本。成员可连任。支持不信任投票（即弹劾）。&lt;/div&gt;
&lt;div&gt;现在来看看第一届当选的成员：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Barry Warsaw：自1995年起成为核心开发者之一，荣获 2014 年的弗兰克·威利森纪念奖。目前供职于 LinkedIn（已被微软收购，也即供职于微软），业余爱好是音乐和太极。&lt;/li&gt;
&lt;li&gt;Brett Cannon：自2003年起成为核心开发者之一，荣获 2016 年的弗兰克·威利森纪念奖。曾担任 Python 软件基金会的执行副主席。目前供职于微软，负责 VSCode 的 Python 插件项目。&lt;/li&gt;
&lt;li&gt;Carol Willing：Python 核心开发者，Jupyter 核心开发者及 Jupyter 的指导委员会成员。自由职业，兴趣在于科研及教育项目。&lt;/li&gt;
&lt;li&gt;Guido van Rossum：Python 的创始人，被称为“Python 之父”，长期领导 Python 社区的发展，直到此次的退位风波。目前供职于 Dropbox。&lt;/li&gt;
&lt;li&gt;Nick Coghlan：自2005年起成为核心开发者之一。目前供职于 Tritium。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;注：弗兰克·威利森纪念奖，即 Frank Willison Memorial Award，该奖由 O’Reilly 出版集团设立，颁布给为 Python 社区做了突出贡献的个人。设立于2002年，每年颁布一次。&lt;/div&gt;
&lt;div&gt;这些成员都是多年的资深核心开发者，为 Python 发展做出过长足的贡献。最值得一提的当然是 Guido van Rossum，他并没有离开决策层。事实上，Guido 是自荐成为候选人的，并且是 17 名候选人中最早自荐或被提名的几个人之一。&lt;/div&gt;
&lt;div&gt;在当选之后，其他人都在 Twitter 上转发了好消息，而 Guido 不置一词。这留下了一个悬念：Guido 出于什么考虑而决定重回决策层呢，又将会扮演怎样的角色呢？&lt;/div&gt;
&lt;h2&gt;3、开源技术项目的发展？&lt;/h2&gt;
&lt;div&gt;要发起一个开源的技术项目，似乎并不难，然而，要使它推广到广大的技术群体，打造出完整的技术生态，并且持续健康地运作下去，这就太难了。&lt;/div&gt;
&lt;div&gt;今天，看到一则新闻：Bootstrap 5 将彻底移除对 jQuery 的依赖。我不由地想起半年前，Github 也宣布了完全放弃 jQuery。jQuery 是著名的前端开源项目，几年前一统江湖盛极一时，然而随着 MVVM 框架的崛起，目前已到了穷途末路的境地。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这揭示了技术项目发展的第一大难题：保持技术的领先性。近几年，Python 凭借着在人工智能和科学计算领域的赫赫战功，成为了众多开发者追捧的对象，对我等追随者来说，真是喜闻乐见。乐观地想，Python 至少还不会因为技术原因而没落。&lt;/div&gt;
&lt;div&gt;去年，技术社区里还发生了一件大事：Linux 之父 Linus Torvalds 宣布要无限期休假。这个新闻跟 Python 之父的退位相比，所引起的轰动效应可要大得多了。&lt;/div&gt;
&lt;div&gt;这两件事有很大的相似性，引发了我的好奇心：开源技术项目所重度依赖的灵魂人物离开了，它们如何才能继续健康地发展运作？&lt;/div&gt;
&lt;div&gt;这个话题对我等小小的边缘码农而言，实在是超出能力范围而无法回答。所幸的是，他们又回归了。不过对于核心开发者们来说，这个话题迟早要面对，现在的风波就是一个预警。&lt;/div&gt;
&lt;div&gt;Python 社区贡献出来的指导委员会治理方案，会带来什么样的变化，会引领社区走向何方呢？拭目以待。&lt;/div&gt;
&lt;div&gt;相关链接：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://t.cn/EygFM5Q&quot;&gt;这件正在发生的事，关乎所有的Python开发者……&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-0013/&quot;&gt;https://www.python.org/dev/peps/pep-0013/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-8016/&quot;&gt;https://www.python.org/dev/peps/pep-8016/&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>春节回乡随记</title>
            <link>https://pythoncat.top/posts/2019-02-06-chunjie/</link>
            <guid>https://pythoncat.top/posts/2019-02-06-chunjie/</guid>
            <description>大年初一，跟豌豆去县里逛街。在逛完街回家的路上，我无意中注意到路边的横幅，突然兴起来一股念头，要把这几天的见闻以及一些杂乱所思记录下来。随记，随记，随意想，随意记，想到哪里，写哪里罢。</description>
            <pubDate>Wed, 06 Feb 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;大年初一，跟豌豆去县里逛街。在逛完街回家的路上，我无意中注意到路边的横幅，突然兴起来一股念头，要把这几天的见闻以及一些杂乱所思记录下来。随记，随记，随意想，随意记，想到哪里，写哪里罢。&lt;/div&gt;
&lt;div&gt;（1）横幅&lt;/div&gt;
&lt;div&gt;从县里回家，路程大概 60 公里。公共汽车途经某一两个镇的时候，路边隔两三百米就有一条横幅，它们的标语几乎不重样，但表述的却是相同的主题，这就挺有意思了。车经过得快，有些标语我没来得及记下来，大部分关键的信息如下：“打造诚信电白”、“打击诈骗”、“举报电信诈骗”、“诈骗害人害己”、“诈骗钱财可耻”。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;要说电白有啥“特产”，诈骗（曾经？）绝对算一个，这些标语确实事出有因。不过也有一条横幅写道“拒绝陌生来电”云云，看来，施害者之中也有受害者啊。除了这些地方特色的横幅，路边还有很多普世的横幅，如“扫黑除恶”、“交通安全”、“青山绿水”、“欢迎回乡”等等。&lt;/div&gt;
&lt;div&gt;在我们县或乡镇里，我印象中就没看到过刷墙标语（除了特殊年代的字迹已淡化的），反而是这些横幅是无处不在。横幅文化也是这里的“特产”：看横幅，察时情。&lt;/div&gt;
&lt;div&gt;等回到了镇上，我也注意到了我们镇的特色——“枪支弹药”、“上报枪支”…曾经听妈妈讲起一些只言片语，我只当传闻，而如今审视，细思极恐。&lt;/div&gt;
&lt;div&gt;（2）车内标语&lt;/div&gt;
&lt;div&gt;我也注意到公共汽车内的标语，其地方特色程度跟横幅相比，不相上下。因为有图为证，我可以把完整的内容摘录于此：“普及禁毒常识，提高禁毒意识”、“全区动员，扫除毒害”、“毒品一日不绝，禁毒一日不止”。仅仅在去程与回程的车上就出现这三条标语，背后意义不消多言。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;（3）公共汽车&lt;/div&gt;
&lt;div&gt;在很长很长的一段时间里，我们镇没有正式的汽车站，而在镇政府门口前的一小片空地不知怎么地就承担起了这个角色。今年，终于换了个地方建了个挂着牌子的潦潦草草的车站：纯露天、目测最多三个车位。&lt;/div&gt;
&lt;div&gt;硬件设施几乎无改善，而“软件”方面有大进步——微信扫码付款已全面普及，只需注册“乘车码”小程序，即可出示二维码支付。这项技术大概是初普及，因为在去程的车上有提示，说司机收车款属贪污行为，末尾还留了举报电话；去程车上没有售票员，我刚以为无人售票终于普及了，然而回程车上就出现了“撕票员”——她也不敢收钱，仍是要乘客刷二维码或投钱（我们这地方完全不使用硬币），由此看来，她已经不算是“售票员”了，不过，她帮一个乘客找了零钱，还给每个人按车费撕了一张车票，所以，严格来说，不就是“找零兼撕票员”嘛。&lt;/div&gt;
&lt;div&gt;从镇上到县里，单人 14 元，这物价跟前几年相比，好像是一致的。豌豆正在翻看我初中时候的日记，那时候我记下的车费是 9 元，一晃 14 年了，车费追平了时间。车费是分段计算的，我注意到，司机有一个输入价格的小东西，就跟我们在商场购物时输入银行卡密码的输入器相似，由此控制着扫码器的价格，来相应地扣费。&lt;/div&gt;
&lt;div&gt;去程车上有 15 个座，司机一直在数着空位，好像是在防着超载，而刚好满载之后，半途有人招手（可以非站点上下车），他就挥手致意，并不停车揽客。中途某处，竟然有交警设岗，还有武警在场，他们检查了没有超载，而司机还下了车去，似乎测了是否酒驾。对于测酒驾，我能解释它是春节期间的临时项目，而为何不允许超载，我就无法理解了，想来也是临时项目的可能性较大。&lt;/div&gt;
&lt;div&gt;（4）日记本&lt;/div&gt;
&lt;div&gt;豌豆清点了我的藏品，找出来 6 本日记。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;从六年级开始，我努力培养记日记的习惯，这些就是我六年级和初中时期的日记。按照一个学期一本的用度，这四年里，我应该写下了 8 本，现在却只有 6 本。初三第二学期的日记是缺失了，另外缺失的时段还不可知，因为我完全不记得这几本密码本的密码了，有两本得要再暴力破解才行。&lt;/div&gt;
&lt;div&gt;高中时期，我也在记日记，只不过并不是每日都记，加上那个本子较大，所以三年都写在了一起。到了大学的时候，环境大变，我已想不起确切的原因了，记日记的习惯断裂了，所以日记本是完全没用过了。&lt;/div&gt;
&lt;div&gt;（5）遗忘的事&lt;/div&gt;
&lt;div&gt;豌豆读完了我初二（下）与初三（上）的日记。在她看来，很多事情挺有意思，而我呢，反倒因为觉得幼稚而不好意思。&lt;/div&gt;
&lt;div&gt;那段时间，记事内容较多，无非是跟哪些同学聊天或者游戏之类、记录学习的事、记录开支花销的事，等等。有些事，一念完日记，我就想起来了，还有些事，我是完全没印象。流水账日记的细节密度低，没能激活我的记忆库。&lt;/div&gt;
&lt;div&gt;虽然借助日记，我忆起来一些事，可是所记录的还是太少，更多的不曾着墨的事和情全都湮灭了。记录的事可以唤醒一些尘封的记忆，同时也在提醒着，它所忽略掉的事，可能永远会被遗忘。&lt;/div&gt;
&lt;div&gt;（6）交换日记&lt;/div&gt;
&lt;div&gt;在豌豆津津有味地翻读日记，而接入到我的过去（同学关系、心路历程、家庭关系）的时候，我突然想到了一个有意思的素材。&lt;/div&gt;
&lt;div&gt;想象一下，你仔细记录了很多的日记，把年少的自己就这样锚定在那段时光里，然后，你找到了自己的另一半，她也做了同样的事，接着你们交换日记，相互就得以穿越回彼此的过去，你们在一个浪漫的环境里分享那些点点滴滴的喜怒哀愁，这会是多美好的一副图景啊。&lt;/div&gt;
&lt;div&gt;（7）放牛娃&lt;/div&gt;
&lt;div&gt;我多次给豌豆讲起过我童/少年时候的事，比如说上山放牛。前天在去小姑姑家的路上，我们极其偶然地看到了几只黄牛，所以又说起这个事来。&lt;/div&gt;
&lt;div&gt;大概在二年级和往前两三年里，我和二弟跟着村里的三四个人去放牛。我们养的都是山牛（即黄牛），需要真正地上山放牛，有时候还会翻山越岭去到挺远的地方（在那时候看来真的挺远了）。&lt;/div&gt;
&lt;div&gt;仔细想想，我能打捞起不少有趣的事情来。或许今后能专门写一篇文章呢。&lt;/div&gt;
&lt;div&gt;而现在，我只想说说这段经历的意义。这是一段独特的经历，在与我相熟的小学同学里，没有人有过这样的经历。似乎从那时起，我就因自己的独特而在人群中变得独立，变得不走寻常路。在中学的一些日记里能看出，我的想要上进的念想一直在发酵，而早年山野间的种种自然感受也一直在浸染着我。&lt;/div&gt;
&lt;div&gt;当怀着感恩的心回头品味，我发现放牛经历和记日记经历，竟然都是我不可或缺的宝贵财富。经历、记忆、再加内省，这样慢慢才推动了我成为可能成为的人。&lt;/div&gt;
&lt;div&gt;（8）朋友圈与同学圈&lt;/div&gt;
&lt;div&gt;所谓朋友圈，就是一个每逢佳节倍热闹的地方。&lt;/div&gt;
&lt;div&gt;豌豆说起一个“中国折叠”的话题，挺有意思，我得敦促着她写下来。&lt;/div&gt;
&lt;div&gt;由于求学和工作远，我跟中小学的同学圈联系并不紧（大学就更不要说了）。加上其它原因，今年的聚会邀约是去不成了。&lt;/div&gt;
&lt;div&gt;五年前的高中同学聚会上，我们给五年后的自己写了一封信，写下愿望和计划之类的，今年大概会拆旧信写新信吧。我记不清写了两条还是三条，现在第一条完成得挺好，后面的则仍是“革命尚未成功”。就请班长继续保管着信吧，下一个五年的时候，我再来认领。&lt;/div&gt;
&lt;div&gt;（9）亲友圈&lt;/div&gt;
&lt;div&gt;前面说到过几个“地方特产”，这里还要说一个，那就是生育孩子。&lt;/div&gt;
&lt;div&gt;我父亲这边共有兄弟姐妹 5 个，妈妈那边是 4 个，他们以相近的编制数目生育下一代。我得小心数数，才能算清自己有多少表兄弟姐妹。这还不算，我的表姐表哥们的岁数都比我大挺多，他们仍以相差无几的数目生育小孩，所以我完全搞不清楚自己有多少个表外甥。&lt;/div&gt;
&lt;div&gt;今天得知，我有一个外甥刚生完二胎，有两个外甥计划了今年结婚（一个就定在年初十），还有几个已经是待嫁待娶的年纪。嗯，真是一个好大的、正在裂变壮大的亲友圈啊。&lt;/div&gt;
&lt;div&gt;这几天，我没少被问啥时候生小孩。我一致回复：没计划好呢。其实，虽然时间节点还没确定，但是我只会给两个选择：要么一个都不生，要么只生一个（双胞胎除外）。关于这个话题，以后有机会再多写写。&lt;/div&gt;
&lt;div&gt;（10）小孩&lt;/div&gt;
&lt;div&gt;昨天，二堂哥说要给几个小孩拍照。所谓小孩，就是我的两个堂哥和一个堂姐的小孩，共有 7 个。&lt;/div&gt;
&lt;div&gt;二堂哥翻出旧照片，指着说着，这是五个的时候，这是六个的时候，现在是七个的了。我是看着她/他们长大的，抱过也一起玩过，现在她/他们最大的已经念初三了。这几年匆匆见过的几面，完全无法抹去我记忆中她们小小年纪时候的模样。记忆始终停留，是时候告诉自己，得要刷新一下了。&lt;/div&gt;
&lt;div&gt;现在我的身份是给小孩发红包的大人，表面上看，这个转变已经顺遂自然，其实内心里，我跟当初等着大人发红包的小孩，又能相差多少呢？&lt;/div&gt;
&lt;div&gt;我还没有适应那几个小孩已经长大的事实，反讽的是，却发现自己并没有长大的心态。&lt;/div&gt;
&lt;div&gt;我仍很怀念这些小孩最天真美好的年代，观望未来，就隐隐现出一种失控感。&lt;/div&gt;
&lt;div&gt;几个小孩中最小的正在上学前班。我们与她存在着最自然的、纯朴的亲近联系。我们送给她一个小猪佩奇的布偶，她兴奋得意的样子，实在是可爱。&lt;/div&gt;
&lt;div&gt;（11）玩具&lt;/div&gt;
&lt;div&gt;看到侄子跟外甥拿着玩具枪，我就跟豌豆聊起自己的玩具来。&lt;/div&gt;
&lt;div&gt;大概在二三年级之前，我们小孩拿到红包的第一件事就是去买玩具枪。那是一种气枪，通过空气压缩原理发射子弹，子弹是塑料的，枪型从小马哥的手枪到狙击手的带瞄准器的步枪都有。&lt;/div&gt;
&lt;div&gt;我们一个村里的小孩组队枪战，风风火火吵吵闹闹上蹿下跳；又或者三两人对着香蕉叶、对着香蕉树干，比拼枪法和破坏力；又或者是寻觅着果树上的梨椿象和龙眼鸡（学名长鼻蜡蝉。竟然可以搜到它的名字），为民除害行侠仗义。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;现在的玩具已经不是这样的了。&lt;/div&gt;
&lt;div&gt;（12）游玩&lt;/div&gt;
&lt;div&gt;想带豌豆回母校转转，然而校门紧闭，不能如愿。&lt;/div&gt;
&lt;div&gt;去了海边，吹海风、观海浪、踏海沙、踢海水、捡贝壳，也算是如了愿。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;逛街，竟找不到合适的伴手礼。在宣传栏上写到，我们是沉香之乡。说实话，难道这不是最近几年才突然造出来的名头么，而且差不多就仅限在跟我们镇相邻的另一个镇上？另外，所谓“中国第一滩”，好不威风的名字啊，却空有其名。&lt;/div&gt;
&lt;div&gt;（13）火车&lt;/div&gt;
&lt;div&gt;我们镇已通高铁半年了，然而我们是一张票都没抢到。&lt;/div&gt;
&lt;div&gt;交通是个麻烦事。我们的路线是这样的：苏州—&amp;gt;上海—&amp;gt;广州—&amp;gt;马踏镇。这中间三趟车的断裂，造成出行的极大麻烦，出发时间太早不行，到达时间太晚也不理想。这最后一环如果能用高铁衔接上，或者优化减少一环，那就太好了。&lt;/div&gt;
&lt;div&gt;去年没用购票APP的加速包，没有抢到票，今年用了，却没买到最优的组合。明年会怎样？或者说，几年后会怎样？喵，谁知道呢，不过总体上是会越来越好的，对吧？&lt;/div&gt;
&lt;div&gt;——2019.02.06&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>四个月技术写作，我写了些什么？</title>
            <link>https://pythoncat.top/posts/2019-02-03-writing/</link>
            <guid>https://pythoncat.top/posts/2019-02-03-writing/</guid>
            <description>从去年国庆节开始，我连续更新了 4 个月公众号，累计发布原创文章 40 篇</description>
            <pubDate>Sun, 03 Feb 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;从去年国庆节开始，我连续更新了 4 个月公众号，累计发布原创文章 40 篇。&lt;/div&gt;
&lt;div&gt;按照大多数个人订阅号的优良传统，号主应该在跨年的前后作年终总结。然而，一来我反应比较迟钝，没跟上节奏，二来当时我正在写比较重要的系列，没时间分心，所以还是慢了半拍。&lt;/div&gt;
&lt;div&gt;现在，创作出现了空档期，而身体也出现一种魔幻性的跨移——从几千里外的城市回到分别了几百天的农村。这仿佛就在营造一种仪式感，逼使我要把这未完成的任务做个了结。&lt;/div&gt;
&lt;div&gt;因此，现在我就来梳理梳理写出来的东西，说说我的想法吧。&lt;/div&gt;
&lt;h2&gt;1、Python猫的故事&lt;/h2&gt;
&lt;div&gt;这是我的主打系列，故事的主角是一只来自外太星（喵星）的猫。它外貌长什么样，我还没想好，你可以叠加所有猫的形象上去，这就是它的样子。&lt;/div&gt;
&lt;div&gt;然而，它绝不是一种固定形态的物种。编程语言（Python为主）、人类文化（文学+哲学）、人工智能、前沿科学（生物+量子物理）和幻想相交合，这些东西都会是我的灵感，也会是塑造这只猫的原力。&lt;/div&gt;
&lt;div&gt;我们认识周遭世界的过程是一种逐步扩大的过程，从点到线，到理得清的网，再到真正的网。一只作为讲述者的猫，在思考，在探知并试图融入陌生的星球的时候，会发生些什么认知层面上的结果呢？&lt;/div&gt;
&lt;div&gt;我有很多朦胧的念头。想要完全落实它们，简直不可能。有些东西就是说不清。&lt;/div&gt;
&lt;div&gt;不过，有了开端，有了大致的方向，就总是有了提起“笔”写下去的动机。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ch8JkAgcgi2o4HtGAUfZVg&quot;&gt;有了Python，我能叫出所有猫的名字&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/YQbk0smMTCexsi3Ytd2AzA&quot;&gt;Python对象的身份迷思：从全体公民到万物皆数&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/q0QvAqXcZzURH3aZ5gZm8A&quot;&gt;Python对象的空间边界：独善其身与开放包容&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;2、Python进阶之路&lt;/h2&gt;
&lt;div&gt;我接触 Python 的时间并不长，在工作中用到它的时间就更短了。&lt;/div&gt;
&lt;div&gt;因为清楚地意识到自己的基础并不扎实，所以，几个月以来，我花了不少时间系统性地学习了一些内容。&lt;/div&gt;
&lt;div&gt;写作前，搜集资料，查漏补缺；写作中，发散思考，融会贯通；发布后，聆听反馈，修正错误。&lt;/div&gt;
&lt;div&gt;时间过得真快，现在能拿得出手的也就仅仅是字符串系列、切片系列和迭代器系列了。我计划继续花些时间，把重要的知识梳理一遍。&lt;/div&gt;
&lt;div&gt;通过这个系列的写作，我想驱动自己走出一条 Python 进阶之路。然后以它为基础，再进行其它领域（爬虫、数据分析、深度学习、？）的转向。&lt;/div&gt;
&lt;div&gt;在准备生成器系列的时候，我一时起了翻译 PEP 的念头，就开启了翻译 PEP 的系列。现在试水了两篇生成器相关的，年后还会翻译一篇。关于翻译，我有一些想法，今后再细说。&lt;/div&gt;
&lt;div&gt;这个系列的一些内容，其实是在给 Python 猫系列打基础做铺垫。今后，我会避免两个系列的内容重叠，也不让它们失衡，因此会想办法给 Python猫 系列留下足够的写作余地。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/OKf7N3xxrS0tJ_K8Srw-jA&quot;&gt;超强汇总：学习Python列表，只需这篇文章就够了&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/hR2Z_duLXnN0fQ3khDPiPQ&quot;&gt;学习Python操作JSON，网络数据交换不用愁&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Md07VoaULda7qnMO4ob7Ww&quot;&gt;给Python学习者的文件读写指南（含基础与进阶，建议收藏）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/2zGUfwIYY4EVJ0NNyJkNRQ&quot;&gt;再谈文件读写：判断文件的几种方法及其优劣对比&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/vCs6QvJU2J6L0rIWDKQPUQ&quot;&gt;Python中的“特权种族”是什么？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Whrd6NiD4Y2Z-YSCy4XJ1w&quot;&gt;详解Python拼接字符串的七种方式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/z-gSW6XJrAvUE5rS5XrAig&quot;&gt;你真的知道Python的字符串是什么吗？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/M4_38VHlQwp-CDRczh2NIA&quot;&gt;你真的知道Python的字符串怎么用吗？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/PsY8Iec1EeGDKKnTNU5CNw&quot;&gt;Python是否支持复制字符串呢？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/M2uHVqaHe_nyO5jT60V_6Q&quot;&gt;join()方法的神奇用处与Intern机制的软肋&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/fwZnvcQ_u-fYLFeQaYkJLw&quot;&gt;Python进阶：切片的误区与高级用法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/DIhwoJE3o0kKw3kzZKysag&quot;&gt;Python进阶：迭代器与迭代器切片&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/IRAjR-KHZBPEEkdiofseGQ&quot;&gt;Python进阶：全面解读高级特性之切片！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/7MbRCn37fIIN42rLm6ho3g&quot;&gt;Python进阶：设计模式之迭代器模式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/1fZs_yXIUhjzN0mQyujXhQ&quot;&gt;为什么range不是迭代器？range到底是什么类型？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/vjQLlmH5QV-zAre7tVCxSA&quot;&gt;[译] PEP 255—简单的生成器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/M79svUpskZQz15SxEfIWbQ&quot;&gt;[译]PEP 342—增强型生成器：协程&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;3、荐书系列&lt;/h2&gt;
&lt;div&gt;关于荐书系列，我是受到了经常阅读的一些电影公众号的启发。&lt;/div&gt;
&lt;div&gt;如果有一部好电影，大家就会花很长篇幅去推介它，去评论它，去宣传它。对于一些非技术类的书籍，也很可能有此待遇。&lt;/div&gt;
&lt;div&gt;可是，我们却不怎么见到技术类书籍是这样的吧？除去出版社、作者和利益相关机构，你几乎看不到有人为一本技术书籍写书评（写笔记、画思维导图的倒是挺多）。&lt;/div&gt;
&lt;div&gt;于是，我决定来尝试一下。有几篇，我特意提到了豆瓣评分和评论，现在看来模仿的痕迹太重，这类玩意对技术类书籍来说，真不合适。纯探索阶段，希望今后能拿出更好的作品。&lt;/div&gt;
&lt;div&gt;这个系列，主要还有一个考虑：促使我自己去阅读，逼着自己学会总结归纳，多产生一些积累。&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;《&lt;a href=&quot;https://mp.weixin.qq.com/s/JnoYojDsNHYkpibSfF3hOg&quot;&gt;编写高质量代码改善 Python 程序的 91 个建议&lt;/a&gt;》&lt;/li&gt;
&lt;li&gt;《&lt;a href=&quot;https://mp.weixin.qq.com/s/9RonAqwCXo_lganYvLHgVw&quot;&gt;Python最佳实践指南&lt;/a&gt;》&lt;/li&gt;
&lt;li&gt;《&lt;a href=&quot;https://mp.weixin.qq.com/s/6swAZA7baF26BlrKV7zBFg&quot;&gt;黑客与画家&lt;/a&gt;》&lt;/li&gt;
&lt;li&gt;《&lt;a href=&quot;https://mp.weixin.qq.com/s/RcvYm7Ro_nnMx0ZVrJmtyA&quot;&gt;Python源码剖析&lt;/a&gt;》&lt;/li&gt;
&lt;li&gt;《&lt;a href=&quot;https://mp.weixin.qq.com/s/UxPxSJRHk0R6ffhpl8aSpw&quot;&gt;Python高性能编程&lt;/a&gt; 》&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;4、杂七杂八&lt;/h2&gt;
&lt;div&gt;这部分内容也是跟技术息息相关的，例如 Python社区动态、技术写作、编程思想、技术翻译等等。&lt;/div&gt;
&lt;div&gt;其中，关于社区治理模式投票的几篇文章，我最初以为是个热点，但后来意识到，真的没有多少人关心。（我该怀疑自己的关注点呢，还是怀疑别人？）&lt;/div&gt;
&lt;div&gt;值得庆幸的是，有篇文章被两位圈内大佬转载了！我乐了好久。这里就不提名字了，总之他们是我初学 Python 时就很佩服的人，因为看了他们的一些文章，我才动了写技术文章的念头。&lt;/div&gt;
&lt;div&gt;关于技术写作和翻译，我初见门道，今后还会多作总结分享。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/2l_erf55IMvT4Tz0AGWCUQ&quot;&gt;来自Kenneth Reitz大神的建议：避免不必要的面向对象编程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/oRoBxZ2-IyuPOf_MWyKZyw&quot;&gt;学习Python，怎能不懂点PEP呢？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/855ur2uCI1Z1-qpuLGKp0Q&quot;&gt;再聊聊Python中文社区的翻译&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/vyx61e9GiiTnmaVzTYOcmw&quot;&gt;Python之父退位后，最高决策权花落谁家？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/gl8grRlvZ9ylWRdXTWUXow&quot;&gt;这件正在发生的事，关乎所有的Python开发者……&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/aLkfOoqQubjEIhF1YrLgeg&quot;&gt;最新进展|关于Python治理模式的投票&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/c7Jz0L8YBoX0Dfb5cZz9sg&quot;&gt;Python决策权的投票结果诞生了，“指导委员会”模式拔得头筹&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/cCWfbHeptEUKtI19GIxF8A&quot;&gt;聊聊技术写作的个人体会&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/jdS_hkeDxwroRU3k6or_fg&quot;&gt;大名鼎鼎的Requests库用了什么编码风格？&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;5、写在最后&lt;/h2&gt;
&lt;div&gt;我承认自己是一个不擅运营的人，虽然为了提升公众号的订阅数与阅读数，也做过一些运营的尝试，但是，跟圈内的很多号主相比，差得可不止一丝半点。&lt;/div&gt;
&lt;div&gt;四个月以来，我结识了很多技术写作的号主，他们有些人创号不久，但不仅技术扎实，而且抓选题、抓热点和写作风格都极其出色，很快就成为了“当红炸子鸡”；还有的大佬，持续耕耘了几年，坐拥数十万粉丝，立品牌、出书、出课程、开知识付费、开公司，替技术人走出了一条名利双收的榜样之路。&lt;/div&gt;
&lt;div&gt;他们令我羡慕。他们皆有值得我学习取经的优点。不过我也知道，坚持自己的原则、发展自己的特色更为重要。做人也好，写公众号也好，循着自己的本心与节奏，才不至于走歪了路。&lt;/div&gt;
&lt;div&gt;所以，在以上几个系列的写作方向上，我仍会继续坚持，沉下心来学习，思考和分享。这个阶段性的小结，既是一个交代，也是新的开端。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>[译]PEP-342 增强型生成器：协程</title>
            <link>https://pythoncat.top/posts/2019-01-27-yield/</link>
            <guid>https://pythoncat.top/posts/2019-01-27-yield/</guid>
            <pubDate>Sun, 27 Jan 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;PEP原文 ：&lt;/strong&gt; &lt;a href=&quot;https://www.python.org/dev/peps/pep-0342/&quot;&gt;https://www.python.org/dev/peps/pep-0342/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP标题：&lt;/strong&gt; Coroutines via Enhanced Generators&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP作者：&lt;/strong&gt; Guido van Rossum, Phillip J. Eby&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;创建日期：&lt;/strong&gt; 2005-05-10&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;合入版本：&lt;/strong&gt; 2.5&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; ：&lt;a href=&quot;https://zhuanlan.zhihu.com/pythonCat&quot;&gt;豌豆花下猫&lt;/a&gt;（&lt;strong&gt;Python猫&lt;/strong&gt; 公众号作者）&lt;/div&gt;
&lt;h2&gt;目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;简介&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动机&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;规格摘要&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;规格：将值发送到生成器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新的生成器方法：send(value)&lt;/li&gt;
&lt;li&gt;新的语法：yield 表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;规格：异常和清理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新语法：yield 允许在&lt;code&gt;try-finally&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;新的生成器方法：throw（type，value = None，traceback = None）&lt;/li&gt;
&lt;li&gt;新的标准异常：GeneratorExit&lt;/li&gt;
&lt;li&gt;新的生成器方法：close()&lt;/li&gt;
&lt;li&gt;新的生成器方法：&lt;code&gt;__del__()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选的扩展&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;扩展的 continue 表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;未决问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参考实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;致谢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参考文献&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;版权&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;div&gt;这个 PEP 在生成器的 API 和语法方面，提出了一些增强功能，使得它们可以作为简单的协程使用。这基本上是将下述两个 PEP 的想法结合起来，如果它被采纳，那它们就是多余的了：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;PEP-288，关于生成器的属性特征与异常（Attributes and Exceptions）。当前 PEP 沿用了它的下半部分，即生成器的异常（事实上，throw() 的方法名就取自 PEP-288）。PEP-342 用 yield 表达式（这个概念来自 PEP-288 的早期版本）来替换了生成器的属性特征。&lt;/li&gt;
&lt;li&gt;PEP-325，生成器支持释放资源。PEP-342 收紧了 PEP-325 中的一些松散的规范，使其更适用于实际的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;（译注：PEP-288 和 PEP-325 都没有被采纳通过，它们的核心内容被集成到了 PEP-342里。）&lt;/div&gt;
&lt;h2&gt;动机&lt;/h2&gt;
&lt;div&gt;协程是表达许多算法的自然方式，例如模拟/仿真、游戏、异步 I/O、以及其它事件驱动编程或协同的多任务处理。Python 的生成器函数几乎就是协程——但不完全是——因为它们允许暂停来生成值，但又不允许在程序恢复时传入值或异常。它们也不允许在 try-finally 结构的 try 部分作暂停，因此很难令一个异常退出的（aborted）协程来清理自己。&lt;/div&gt;
&lt;div&gt;同样地，当其它函数在执行时，生成器不能提供控制，除非这些函数本身是生成器，并且外部生成器之所以写了去 yield，是要为了响应内部生成器所 yield 的值。这使得即使是相对简单的实现（如异步通信）也变得复杂，因为调用任意函数，要么需要生成器变堵塞（block，即无法提供控制），要么必须在每个要调用的函数的周围，添加一大堆引用循环代码（a lot of boilerplate looping code）。&lt;/div&gt;
&lt;div&gt;但是，如果有可能在生成器挂起的点上传递进来值或者异常，那么，一个简单的协程调度器或蹦床函数（&lt;code&gt;trampoline function&lt;/code&gt;）就能使协程相互调用且不用阻塞——对异步应用程序有巨大好处。这些应用程序可以编写协程来运行非阻塞的 socket I/O，通过给 I/O 调度器提供控制，直到数据被发送或变为可用。同时，执行 I/O 的代码只需像如下方式操作，就能暂停执行，直到 nonblocking_read() 继续产生一个值：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;data = (yield nonblocking_read(my_socket, nbytes))&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;换句话说， 通过给语言和生成器类型增加一些相对较小的增强，Python 不需要为整个程序编写一系列回调，就能支持异步操作，并且对于本该需要数百上千个协作式的多任务伪线程的（co-operatively multitasking pseudothreads）程序，也可以不需要使用资源密集型线程。因此，这些增强功能将给标准 Python 带来 Stackless Python 的许多优点，又无需对 CPython 核心及其 API 进行任何重大的修改。此外，这些增强在任何已经支持生成器的 Python 实现（例如 Jython）上都是可落实的。&lt;/div&gt;
&lt;h2&gt;规格摘要&lt;/h2&gt;
&lt;div&gt;通过给生成器类型增加一些简单的方法，以及两个微小的语法调整，Python 开发者就能够使用生成器函数来实现协程与其它的协作式多任务。这些方法和调整是：&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;重定义 yield 为表达式（expression），而不是语句（statement）。当前的 yield 语句将变成一个 yield 表达式，其值将被丢弃。每当通过正常的 next() 调用来恢复生成器时，yield 表达式的返回值是 None。&lt;/li&gt;
&lt;li&gt;为生成器（generator-iterator）添加一个新的 send() 方法，它会恢复生成器，并且 send 一个值作为当前表达式的结果。send() 方法返回的是生成器产生的 next 值，若生成器没有产生值就退出的话，则抛出 &lt;code&gt;StopIteration&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;为生成器（generator-iterator）添加一个新的 throw() 方法，它在生成器暂停处抛出异常，并返回生成器产生的下一个值，若生成器没有产生值就退出的话，则抛出 &lt;code&gt;StopIteration&lt;/code&gt; （如果生成器没有捕获传入的异常，或者它引发了其它异常，则该异常会传递给调用者。）&lt;/li&gt;
&lt;li&gt;为生成器（generator-iterator）添加一个新的 close() 方法，它在生成器暂停处引发 &lt;code&gt;GeneratorExit&lt;/code&gt; 。如果生成器在之后引发 &lt;code&gt;StopIteration&lt;/code&gt; （通过正常退出，或者已经被关闭）或 &lt;code&gt;GeneratorExit&lt;/code&gt; （通过不捕获异常），则 close() 返回给其调用者。如果生成器产生一个值，则抛出 &lt;code&gt;RuntimeError&lt;/code&gt;。如果生成器引发任何其它异常，也会传递给调用者。如果生成器已经退出（异常退出或正常退出），则 close() 不执行任何操作。&lt;/li&gt;
&lt;li&gt;增加了支持，确保即使在生成器被垃圾回收时，也会调用 close()。&lt;/li&gt;
&lt;li&gt;允许 yield 在 try-finally 块中使用，因为现在允许在 finally 语句中执行垃圾回收或显式地调用 close() 。&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;实现了所有这些变更的原型补丁已经可用了，可作为当前 Python CVS HEAD 的 SourceForge 补丁。# 1223381&lt;/div&gt;
&lt;h2&gt;设计规格：将值发送进生成器&lt;/h2&gt;
&lt;h3&gt;新的生成器方法：send(value)&lt;/h3&gt;
&lt;div&gt;为生成器提出了一种新的方法，即 send() 。它只接收一个参数，并将它发送给生成器。调用 send(None) 完全等同于调用生成器的 next() 方法。使用其它参数调用 send() 也有同样的效果，不同的是，当前生成器表达式产生的值会不一样。&lt;/div&gt;
&lt;div&gt;因为生成器在生成器函数体的头部执行，所以在刚刚创建生成器时不会有 yield 表达式来接收值，因此，当生成器刚启动时，禁止使用非 None 参数来调用 send() ，如果调用了，就会抛出 &lt;code&gt;TypeError&lt;/code&gt; （可能是由于某种逻辑错误）。所以，在与协程通信前，必须先调用 next() 或 send(None) ，来将程序推进到第一个 yield 表达式。&lt;/div&gt;
&lt;div&gt;与 next() 方法一样，send() 方法也返回生成器产生的下一个值，或者抛出 &lt;code&gt;StopIteration&lt;/code&gt;  异常（当生成器正常退出，或早已退出时）。如果生成器出现未捕获的异常，则它会传给调用者。&lt;/div&gt;
&lt;h3&gt;新语法：yield 表达式&lt;/h3&gt;
&lt;div&gt;yield 语句（yield-statement）可以被用在赋值表达式的右侧；在这种情况下，它就是 yield 表达式（yield-expression）。除非使用非 None 参数调用 send() ，否则 yield 表达式的值就是 None。见下文。&lt;/div&gt;
&lt;div&gt;yield 表达式必须始终用括号括起来，除非它是作为顶级表达式而出现在赋值表达式的右侧。所以，下面例子都是合法的：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;x = yield 42
x = yield
x = 12 + (yield 42)
x = 12 + (yield)
foo(yield 42)
foo(yield)&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;而下面的例子则是非法的（举了一些特例的原因是，当前的 &lt;code&gt;yield 12,42&lt;/code&gt; 是合法的）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;x = 12 + yield 42
x = 12 + yield
foo(yield 42, 12)
foo(yield, 12)&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;请注意，如今没有表达式的 yield-语句 和 yield-表达式是合法的。这意味着：当 next() 调用中的信息流被反转时，应该可以在不传递显式的值的情况下 yield （yield 当然就等同于 yield None）。&lt;/div&gt;
&lt;div&gt;当调用 send(value) 时，它恢复的 yield 表达式将返回传入的值。当调用 next() 时，它恢复的 yield 表达式将返回 None。如果 yield-表达式（yield-expression）是一个 yield-语句（yield-statement），其返回值会被忽略，就类似于忽略用作语句的函数的返回值。&lt;/div&gt;
&lt;div&gt;实际上，yield 表达式就像一个反函数调用（inverted function）；它所 yield 的值实际上是当前函数返回（生成）的，而它 return 的值则是通过 send() 传入的参数。&lt;/div&gt;
&lt;div&gt;提示：这样的拓展语法，使得它非常地接近于 Ruby。这是故意的。请注意，Python 在阻塞时，通过使用 send(EXPR) 而不是 return EXPR 来传值给生成器，并且在生成器与阻塞之间传递控制权的底层机制完全不同。Python 中的阻塞不会被编译成 thunk，相反，yield 暂停生成器的执行进度。有一些不是这样的特例，在 Python 中，你不能保存阻塞以供后续调用，并且你无法测试是否存在着阻塞。（XXX - 关于阻塞的这些东西似乎不合适，或许 Guido 会编辑下，做澄清。）&lt;/div&gt;
&lt;h2&gt;设计规格：异常和清理&lt;/h2&gt;
&lt;div&gt;让生成器对象成为通过调用生成器函数而生成的迭代器。本节中的 g 指的都是生成器对象。&lt;/div&gt;
&lt;h3&gt;新语法：yield 允许在 try-finally 里&lt;/h3&gt;
&lt;div&gt;生成器函数的语法被拓展了，允许在 try-finally 语句中使用 yield 语句。&lt;/div&gt;
&lt;h3&gt;新的生成器方法：throw(type，value = None，traceback = None)&lt;/h3&gt;
&lt;div&gt;&lt;code&gt;g.throw(type, value, traceback)&lt;/code&gt; 会使生成器在挂起的点处抛出指定的异常（即在 yield 语句中，或在其函数体的头部、且还未调用 next() 时）。如果生成器捕获了异常，并生成了新的值，则它就是 g.throw() 的返回值。如果生成器没有捕获异常，那 throw() 也会抛出同样的异常（它溜走了）。如果生成器抛出其它异常（包括返回时产生的 StopIteration），那该异常会被 throw() 抛出。总之，throw() 的行为类似于 next() 或 send()，除了它是在挂起点处抛出异常。如果生成器已经处于关闭状态，throw() 只会抛出经过它的异常，而不去执行生成器的任何代码。&lt;/div&gt;
&lt;div&gt;抛出异常的效果完全像它所声明的那样：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;raise type, value, traceback&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;会在暂停点执行。type 参数不能是 None，且 type 与 value 的类型必须得兼容。如果 value 不是 type 的实例（instance），则按照 raise 语句创建异常实例的规则，用 value 来生成新的异常实例。如果提供了 traceback 参数，则它必须是有效的 Python 堆栈（traceback）对象，否则会抛出 TypeError 。&lt;/div&gt;
&lt;div&gt;注释：选择 throw() 这个名称，有几个原因。Raise 是一个关键字，因此不能作为方法的名称。与 raise 不同（它在执行点处即时地抛出异常），throw() 首先恢复生成器，然后才抛出异常。单词 throw 意味着将异常抛在别处，并且跟其它语言相关联。&lt;/div&gt;
&lt;div&gt;考虑了几个替代的方法名：&lt;code&gt;resolve()&lt;/code&gt;, &lt;code&gt;signal()&lt;/code&gt;, &lt;code&gt;genraise()&lt;/code&gt;, &lt;code&gt;raiseinto()&lt;/code&gt; 和 &lt;code&gt;flush()&lt;/code&gt; 。没有一个像 throw() 那般合适。&lt;/div&gt;
&lt;h3&gt;新的标准异常：GeneratorExit&lt;/h3&gt;
&lt;div&gt;定义了一个新的标准异常 GeneratorExit，继承自 Exception。生成器应该继续抛出它（或者就不捕获它），或者通过抛出 StopIteration 来处理这个问题。&lt;/div&gt;
&lt;h3&gt;新的生成器方法：close()&lt;/h3&gt;
&lt;div&gt;g.close() 由以下伪代码定义：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;throw&lt;span&gt;(&lt;/span&gt;GeneratorExit&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;GeneratorExit&lt;span&gt;,&lt;/span&gt; StopIteration&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;raise&lt;/span&gt; RuntimeError&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;generator ignored GeneratorExit&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;# Other exceptions are not caught&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;新的生成器方法：&lt;code&gt;__del__()&lt;/code&gt;&lt;/h3&gt;
&lt;div&gt;&lt;code&gt;g.__ del __()&lt;/code&gt; 是 g.close() 的装饰器。当生成器对象被作垃圾回收时，会调用它（在 CPython 中，则是它的引用计数变为零时）。如果 close() 引发异常， 异常的堆栈信息（traceback）会被打印到 sys.stderr 并被忽略掉；它不会退回到触发垃圾回收的地方。这与类实例在处理 &lt;code&gt;__del__()&lt;/code&gt;的异常时的方法一样。&lt;/div&gt;
&lt;div&gt;如果生成器对象被循环引用，则可能不会调用 &lt;code&gt;g.__del__()&lt;/code&gt; 。这是当前 CPython 的垃圾收集器的表现。做此限制的原因是，GC 代码需要在一个任意点打破循环，以便回收它，在此之后，不允许 Python 代码“看到”形成循环的对象，因为它们可能处于无效的状态。被用于解开（hanging off）循环的对象不受此限制。&lt;/div&gt;
&lt;div&gt;尽管实际上不太可能看到生成器被循环引用。但是，若将生成器对象存储在全局变量中，则会通过生成器框架的 f_globals 指针创建一个循环。另外，若在数据结构中存储对生成器对象的引用，且该数据结构被作为参数传递给生成器，这也会创造一个循环引用（例如，如果一个对象具有一个作为生成器的方法，并持有由该方法创建的运行中的迭代器的引用）。鉴于生成器的典型用法，这些情况都不太可能。&lt;/div&gt;
&lt;div&gt;此外，CPython 在实现当前 PEP 时，每当由于错误或正常退出而终止执行时，会释放被生成器使用的框架对象（frame object）。这保证了那些无法被恢复的生成器不会成为无法回收的循环引用的部分。这就允许了其它代码在 try-finally 或 with 语句中使用 close() （参考 PEP-343），确保了给定的生成器会正确地完结。&lt;/div&gt;
&lt;h2&gt;可选扩展&lt;/h2&gt;
&lt;h3&gt;扩展的 continue 语句&lt;/h3&gt;
&lt;div&gt;本 PEP 的早期草案提出了一种新的 continue EXPR 语法，用于 for 循环（继承自 PEP-340），将 EXPR 的值传给被遍历的迭代器。此功能暂时被撤销了，因为本 PEP 的范围已经缩小，只关注将值传给生成器迭代器（generator-iterator），而非其它类型的迭代器。Python-Dev 邮件列表中的一些人也觉得为这个特定功能添加新语法是为时过早（would be premature at best）。&lt;/div&gt;
&lt;h2&gt;未决问题&lt;/h2&gt;
&lt;div&gt;Python-Dev 邮件的讨论提出了一些未决的问题。我罗列于此，附上我推荐的解决方案与它的动机。目前编写的 PEP 也反映了这种喜好的解决方案。&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当生成器产生另一个值作为对“GeneratorExit”异常的响应时，&lt;code&gt;close()&lt;/code&gt;应该引发什么异常？&lt;/p&gt;
&lt;p&gt;我最初选择了 TypeError ，因为它表示生成器函数发生了严重的错误行为，应该通过修改代码来修复。但是 PEP-343 中的 &lt;code&gt;with_template&lt;/code&gt; 装饰器类使用了 RuntimeError 来进行类似处理。可以说它们都应该使用相同的异常。我宁愿不为此目的引入新的异常类，因为它不是我希望人们捕获的异常：我希望它变成一个 traceback 给程序员看到，然后进行修复。所以我觉得它们都应该抛出 RuntimeError 。有一些先例：在检测到无限递归的情况下，或者检测到未初始化的对象（由于各种各样的原因），核心 Python 代码会抛出该异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Oren Tirosh 建议将 send() 方法重命名为 feed() ，以便能跟 consumer 接口兼容（规范参见：&lt;a href=&quot;http://effbot.org/zone/consumer.htm&quot;&gt;http://effbot.org/zone/consumer.htm&lt;/a&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;然而，仔细观察 consumer 接口，似乎 feed() 所需的语义与 send() 不同，因为后者不能在刚启动的生成器上作有意义的调用。此外，当前定义的 consumer 接口不包含对 StopIteration 的处理。&lt;/div&gt;
&lt;div&gt;因此，创建一个贴合 consumer 接口的简单的装饰器，来装饰生成器函数，似乎会更有用。举个例子，它可以用初始的 next() 调用给生成器预热（warm up），追踪 StopIteration，甚至可以通过重新调用生成器来提供 reset() 用途。&lt;/div&gt;
&lt;h2&gt;示例&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;一个简单的 consumer 装饰器，它使生成器函数在最初调用时，就自动地前进到第一个 yield 点：&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;consumer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;func&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;wrapper&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;args&lt;span&gt;,&lt;/span&gt;&lt;span&gt;**&lt;/span&gt;kw&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        gen &lt;span&gt;=&lt;/span&gt; func&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;args&lt;span&gt;,&lt;/span&gt; &lt;span&gt;**&lt;/span&gt;kw&lt;span&gt;)&lt;/span&gt;
        gen&lt;span&gt;.&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; gen
    wrapper&lt;span&gt;.&lt;/span&gt;__name__ &lt;span&gt;=&lt;/span&gt; func&lt;span&gt;.&lt;/span&gt;__name__
    wrapper&lt;span&gt;.&lt;/span&gt;__dict__ &lt;span&gt;=&lt;/span&gt; func&lt;span&gt;.&lt;/span&gt;__dict__
    wrapper&lt;span&gt;.&lt;/span&gt;__doc__  &lt;span&gt;=&lt;/span&gt; func&lt;span&gt;.&lt;/span&gt;__doc__
    &lt;span&gt;return&lt;/span&gt; wrapper&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;ol&gt;
&lt;li&gt;一个使用 consumer 装饰器创建反向生成器（reverse generator）的示例，该生成器接收图像并创建缩略图，再发送给其它 consumer。像这样的函数可以链接在一起，形成 consumer 间的高效处理流水线，且每个流水线都可以具有复杂的内部状态：&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;@consumer&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;thumbnail_pager&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;pagesize&lt;span&gt;,&lt;/span&gt; thumbsize&lt;span&gt;,&lt;/span&gt; destination&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        page &lt;span&gt;=&lt;/span&gt; new_image&lt;span&gt;(&lt;/span&gt;pagesize&lt;span&gt;)&lt;/span&gt;
        rows&lt;span&gt;,&lt;/span&gt; columns &lt;span&gt;=&lt;/span&gt; pagesize &lt;span&gt;/&lt;/span&gt; thumbsize
        pending &lt;span&gt;=&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;xrange&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;rows&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; column &lt;span&gt;in&lt;/span&gt; &lt;span&gt;xrange&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;columns&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    thumb &lt;span&gt;=&lt;/span&gt; create_thumbnail&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; thumbsize&lt;span&gt;)&lt;/span&gt;
                    page&lt;span&gt;.&lt;/span&gt;write&lt;span&gt;(&lt;/span&gt;
                        thumb&lt;span&gt;,&lt;/span&gt; col&lt;span&gt;*&lt;/span&gt;thumbsize&lt;span&gt;.&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt; row&lt;span&gt;*&lt;/span&gt;thumbsize&lt;span&gt;.&lt;/span&gt;y &lt;span&gt;)&lt;/span&gt;
                    pending &lt;span&gt;=&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt; GeneratorExit&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;# close() was called, so flush any pending output&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; pending&lt;span&gt;:&lt;/span&gt;
                destination&lt;span&gt;.&lt;/span&gt;send&lt;span&gt;(&lt;/span&gt;page&lt;span&gt;)&lt;/span&gt;

            &lt;span&gt;# then close the downstream consumer, and exit&lt;/span&gt;
            destination&lt;span&gt;.&lt;/span&gt;close&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;# we finished a page full of thumbnails, so send it&lt;/span&gt;
            &lt;span&gt;# downstream and keep on looping&lt;/span&gt;
            destination&lt;span&gt;.&lt;/span&gt;send&lt;span&gt;(&lt;/span&gt;page&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;@consumer&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;jpeg_writer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;dirname&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    fileno &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        filename &lt;span&gt;=&lt;/span&gt; os&lt;span&gt;.&lt;/span&gt;path&lt;span&gt;.&lt;/span&gt;join&lt;span&gt;(&lt;/span&gt;dirname&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;page%04d.jpg&quot;&lt;/span&gt; &lt;span&gt;%&lt;/span&gt; fileno&lt;span&gt;)&lt;/span&gt;
        write_jpeg&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; filename&lt;span&gt;)&lt;/span&gt;
        fileno &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;


&lt;span&gt;# Put them together to make a function that makes thumbnail&lt;/span&gt;
&lt;span&gt;# pages from a list of images and other parameters.&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;write_thumbnails&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;pagesize&lt;span&gt;,&lt;/span&gt; thumbsize&lt;span&gt;,&lt;/span&gt; images&lt;span&gt;,&lt;/span&gt; output_dir&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    pipeline &lt;span&gt;=&lt;/span&gt; thumbnail_pager&lt;span&gt;(&lt;/span&gt;
        pagesize&lt;span&gt;,&lt;/span&gt; thumbsize&lt;span&gt;,&lt;/span&gt; jpeg_writer&lt;span&gt;(&lt;/span&gt;output_dir&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;)&lt;/span&gt;

    &lt;span&gt;for&lt;/span&gt; image &lt;span&gt;in&lt;/span&gt; images&lt;span&gt;:&lt;/span&gt;
        pipeline&lt;span&gt;.&lt;/span&gt;send&lt;span&gt;(&lt;/span&gt;image&lt;span&gt;)&lt;/span&gt;

    pipeline&lt;span&gt;.&lt;/span&gt;close&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;ol&gt;
&lt;li&gt;一个简单的协程调度器或蹦床（trampoline），它允许协程通过 yield 其它协程，来调用后者。被调用的协程所产生的非生成器的值，会被返回给调用方的协程。类似地，如果被调用的协程抛出异常，该异常也会传导给调用者。实际上，只要你用 yield 表达式来调用协程（否则会阻塞），这个例子就模拟了 Stackless Python 中使用的简单的子任务（tasklet）。这只是一个非常简单的例子，但也可以使用更复杂的调度程序。（例如，现有的 &lt;a href=&quot;http://www.gnome.org/~gjc/gtasklet/gtasklets.html&quot;&gt;GTasklet 框架&lt;/a&gt; 和 &lt;a href=&quot;http://peak.telecommunity.com/&quot;&gt;peak.events 框架&lt;/a&gt; 已经实现类似的调度功能，但大多数因为无法将值或异常传给生成器，而必须使用很尴尬的解决方法。）&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; collections

&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Trampoline&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;Manage communications between coroutines&quot;&quot;&quot;&lt;/span&gt;

    running &lt;span&gt;=&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;queue &lt;span&gt;=&lt;/span&gt; collections&lt;span&gt;.&lt;/span&gt;deque&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; coroutine&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;&quot;&quot;&quot;Request that a coroutine be executed&quot;&quot;&quot;&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;schedule&lt;span&gt;(&lt;/span&gt;coroutine&lt;span&gt;)&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;running &lt;span&gt;=&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;running &lt;span&gt;and&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;queue&lt;span&gt;:&lt;/span&gt;
               func &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;queue&lt;span&gt;.&lt;/span&gt;popleft&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
               result &lt;span&gt;=&lt;/span&gt; func&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; result
        &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            self&lt;span&gt;.&lt;/span&gt;running &lt;span&gt;=&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;stop&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;running &lt;span&gt;=&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;schedule&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; coroutine&lt;span&gt;,&lt;/span&gt; stack&lt;span&gt;=&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; val&lt;span&gt;=&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;exc&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;def&lt;/span&gt; &lt;span&gt;resume&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            value &lt;span&gt;=&lt;/span&gt; val
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; exc&lt;span&gt;:&lt;/span&gt;
                    value &lt;span&gt;=&lt;/span&gt; coroutine&lt;span&gt;.&lt;/span&gt;throw&lt;span&gt;(&lt;/span&gt;value&lt;span&gt;,&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;exc&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    value &lt;span&gt;=&lt;/span&gt; coroutine&lt;span&gt;.&lt;/span&gt;send&lt;span&gt;(&lt;/span&gt;value&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; stack&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;# send the error back to the &quot;caller&quot;&lt;/span&gt;
                    self&lt;span&gt;.&lt;/span&gt;schedule&lt;span&gt;(&lt;/span&gt;
                        stack&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; stack&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;sys&lt;span&gt;.&lt;/span&gt;exc_info&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                    &lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;# Nothing left in this pseudothread to&lt;/span&gt;
                    &lt;span&gt;# handle it, let it propagate to the&lt;/span&gt;
                    &lt;span&gt;# run loop&lt;/span&gt;
                    &lt;span&gt;raise&lt;/span&gt;

            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;value&lt;span&gt;,&lt;/span&gt; types&lt;span&gt;.&lt;/span&gt;GeneratorType&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;# Yielded to a specific coroutine, push the&lt;/span&gt;
                &lt;span&gt;# current one on the stack, and call the new&lt;/span&gt;
                &lt;span&gt;# one with no args&lt;/span&gt;
                self&lt;span&gt;.&lt;/span&gt;schedule&lt;span&gt;(&lt;/span&gt;value&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;coroutine&lt;span&gt;,&lt;/span&gt;stack&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

            &lt;span&gt;elif&lt;/span&gt; stack&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;# Yielded a result, pop the stack and send the&lt;/span&gt;
                &lt;span&gt;# value to the caller&lt;/span&gt;
                self&lt;span&gt;.&lt;/span&gt;schedule&lt;span&gt;(&lt;/span&gt;stack&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; stack&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt;

            &lt;span&gt;# else: this pseudothread has ended&lt;/span&gt;

        self&lt;span&gt;.&lt;/span&gt;queue&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;resume&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;ol&gt;
&lt;li&gt;一个简单的 echo 服务器以及用蹦床原理实现的运行代码（假设存在 &lt;code&gt;nonblocking_read&lt;/code&gt; 、&lt;code&gt;nonblocking_write&lt;/code&gt;  和其它 I/O 协程，该例子在连接关闭时抛出 &lt;code&gt;ConnectionLost&lt;/code&gt; ）：&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# coroutine function that echos data back on a connected&lt;/span&gt;
&lt;span&gt;# socket&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;echo_handler&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;sock&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            data &lt;span&gt;=&lt;/span&gt; &lt;span&gt;yield&lt;/span&gt; nonblocking_read&lt;span&gt;(&lt;/span&gt;sock&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;yield&lt;/span&gt; nonblocking_write&lt;span&gt;(&lt;/span&gt;sock&lt;span&gt;,&lt;/span&gt; data&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;except&lt;/span&gt; ConnectionLost&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;pass&lt;/span&gt;  &lt;span&gt;# exit normally if connection lost&lt;/span&gt;

&lt;span&gt;# coroutine function that listens for connections on a&lt;/span&gt;
&lt;span&gt;# socket, and then launches a service &quot;handler&quot; coroutine&lt;/span&gt;
&lt;span&gt;# to service the connection&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;listen_on&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;trampoline&lt;span&gt;,&lt;/span&gt; sock&lt;span&gt;,&lt;/span&gt; handler&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;# get the next incoming connection&lt;/span&gt;
        connected_socket &lt;span&gt;=&lt;/span&gt; &lt;span&gt;yield&lt;/span&gt; nonblocking_accept&lt;span&gt;(&lt;/span&gt;sock&lt;span&gt;)&lt;/span&gt;

        &lt;span&gt;# start another coroutine to handle the connection&lt;/span&gt;
        trampoline&lt;span&gt;.&lt;/span&gt;add&lt;span&gt;(&lt;/span&gt; handler&lt;span&gt;(&lt;/span&gt;connected_socket&lt;span&gt;)&lt;/span&gt; &lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# Create a scheduler to manage all our coroutines&lt;/span&gt;
t &lt;span&gt;=&lt;/span&gt; Trampoline&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# Create a coroutine instance to run the echo_handler on&lt;/span&gt;
&lt;span&gt;# incoming connections&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;
server &lt;span&gt;=&lt;/span&gt; listen_on&lt;span&gt;(&lt;/span&gt;
    t&lt;span&gt;,&lt;/span&gt; listening_socket&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;echo&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; echo_handler
&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# Add the coroutine to the scheduler&lt;/span&gt;
t&lt;span&gt;.&lt;/span&gt;add&lt;span&gt;(&lt;/span&gt;server&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# loop forever, accepting connections and servicing them&lt;/span&gt;
&lt;span&gt;# &quot;in parallel&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;
t&lt;span&gt;.&lt;/span&gt;run&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;参考实现&lt;/h2&gt;
&lt;div&gt;实现了本 PEP 中描述的所有功能的原型补丁已经可用，参见 SourceForge &lt;a href=&quot;https://bugs.python.org/issue1223381&quot;&gt;补丁 1223381&lt;/a&gt;。&lt;/div&gt;
&lt;div&gt;该补丁已提交到 CVS，2005年8月 01-02。&lt;/div&gt;
&lt;h2&gt;致谢&lt;/h2&gt;
&lt;div&gt;Raymond Hettinger (&lt;a href=&quot;https://www.python.org/dev/peps/pep-0288&quot;&gt;PEP 288&lt;/a&gt;) 与 Samuele Pedroni (&lt;a href=&quot;https://www.python.org/dev/peps/pep-0325&quot;&gt;PEP 325&lt;/a&gt;) 第一个正式地提出将值或异常传递给生成器的想法，以及关闭生成器的能力。Timothy Delaney 建议了本 PEP 的标题，还有 Steven Bethard 帮忙编辑了早期的版本。另见 PEP-340 的致谢部分。&lt;/div&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;div&gt;TBD.&lt;/div&gt;
&lt;h2&gt;版权&lt;/h2&gt;
&lt;div&gt;本文档已经放置在公共领域。&lt;/div&gt;
&lt;div&gt;源文档：&lt;a href=&quot;https://github.com/python/peps/blob/master/pep-0342.txt&quot;&gt;https://github.com/python/peps/blob/master/pep-0342.txt&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;----------------（译文完）--------------------&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP背景知识&lt;/strong&gt; ：&lt;a href=&quot;https://mp.weixin.qq.com/s/oRoBxZ2-IyuPOf_MWyKZyw&quot;&gt;学习Python，怎能不懂点PEP呢？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;PEP翻译计划&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/vjQLlmH5QV-zAre7tVCxSA&quot;&gt;[译] PEP 255—简单的生成器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/fyzFo8btDelxZikMerm7Qg&quot;&gt;[译]PEP 525—异步生成器&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;花下猫语：&lt;/strong&gt; 唠叨几句吧，年前这几周事情太多了，挤着时间好歹是又翻译出一篇 PEP。与生成器密切相关的 PEP 已经完成 3/4，年后再译最后一篇（PEP-380）。当初翻译第一篇，完全是一时兴起，直觉这是一件有意义的事，现在呢，这个念头开始有点膨胀——我竟然在 Github 上建了个翻译项目。我深知，自己水平实在有限，因此不求得到多少认同吧。但行好事，莫问前程。不过，若有人帮着吆喝一声，也是极好的。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>大名鼎鼎的 Requests 库用了什么编码风格？</title>
            <link>https://pythoncat.top/posts/2019-01-23-requests/</link>
            <guid>https://pythoncat.top/posts/2019-01-23-requests/</guid>
            <pubDate>Wed, 23 Jan 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;作者：Kenneth Reitz&lt;/div&gt;
&lt;div&gt;原题：&lt;a href=&quot;https://www.kennethreitz.org/essays/kenneth-reitzs-code-style&quot;&gt;Kenneth Reitz’s Code Style™&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Requests 的代码库使用 PEP-8 编码风格。&lt;/div&gt;
&lt;div&gt;除了 PEP-8 中列出的标准外，我们还有一些指导原则：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;如果方便的话，行长（Line-length）可超过 79 个字符，达到 100 个字符。&lt;/li&gt;
&lt;li&gt;如果换行会导致严重的不方便，则行长可以超过 100 个字符。&lt;/li&gt;
&lt;li&gt;除非在字符串中出现单引号，否则始终使用单引号字符串（例如，‘#flatearth’）。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;此外，PEP-8 推荐的用于连续行的编码风格毫无一点品味，绝不允许在 Requests 代码库使用：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 与开局定界符对齐&lt;/span&gt;
foo &lt;span&gt;=&lt;/span&gt; long_function_name&lt;span&gt;(&lt;/span&gt;var_one&lt;span&gt;,&lt;/span&gt; var_two&lt;span&gt;,&lt;/span&gt;
                         var_three&lt;span&gt;,&lt;/span&gt; var_four&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;No。千万别。请。&lt;/div&gt;
&lt;div&gt;文档字符串（docstrings）应遵循以下语法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;the_earth_is_flat&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;NASA divided up the seas into thirty-three degrees.&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; &lt;span&gt;fibonacci_spiral_tool&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;&quot;&quot;&quot;With my feet upon the ground I lose myself / between the sounds
    and open wide to suck it in. / I feel it move across my skin. / I&apos;m
    reaching up and reaching out. / I&apos;m reaching for the random or
    whatever will bewilder me. / Whatever will bewilder me. / And
    following our will and wind we may just go where no one&apos;s been. /
    We&apos;ll ride the spiral to the end and may just go where no one&apos;s
    been.

    Spiral out. Keep going...
    &quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;pass&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;所有函数、方法和类都要求包含 docstrings 。除了对象数据模型方法（例如，&lt;code&gt;__repr__&lt;/code&gt;），这些是此规则的例外。&lt;/div&gt;
&lt;div&gt;Thanks for helping to make the world a better place!&lt;/div&gt;
&lt;div&gt;资料来源（译注：即 Requests 的开发者指南）：&lt;a href=&quot;http://t.cn/E5VgNJF&quot;&gt;http://t.cn/E5VgNJF&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;（译文完）&lt;/div&gt;
&lt;div&gt;K 神的这篇文章很短，实际上，这只是摘自 Requests 的开发者指南的一小部分。&lt;/div&gt;
&lt;div&gt;但是，关于灵活设定行长的部分，我举双手双脚赞同。如果你所在的公司有“清白盒”的优良传统（不仅指Python），那你极有可能遇到被迫换行的麻烦，而实际上才仅仅刚刚超出了几个字符。那时候，你就会明白，这 3 条灵活规则的好处了。&lt;/div&gt;
&lt;div&gt;另外，关于连续行的部分，PEP-8 相关内容在：&lt;a href=&quot;http://t.cn/Rq4mxOo&quot;&gt;http://t.cn/Rq4mxOo&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;PEP-8 反对的是如下写法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# Arguments on first line forbidden when not using vertical alignment.&lt;/span&gt;
&lt;span&gt;# 不使用垂直对齐的参数禁止在第一行上&lt;/span&gt;
foo &lt;span&gt;=&lt;/span&gt; long_function_name&lt;span&gt;(&lt;/span&gt;var_one&lt;span&gt;,&lt;/span&gt; var_two&lt;span&gt;,&lt;/span&gt;
    var_three&lt;span&gt;,&lt;/span&gt; var_four&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;PEP-8 推荐的写法是垂直地将换行的参数对齐起始的参数：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 与开局定界符对齐&lt;/span&gt;
foo &lt;span&gt;=&lt;/span&gt; long_function_name&lt;span&gt;(&lt;/span&gt;var_one&lt;span&gt;,&lt;/span&gt; var_two&lt;span&gt;,&lt;/span&gt;
                         var_three&lt;span&gt;,&lt;/span&gt; var_four&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;K 神反对了 PEP-8 推荐的写法。在我看来，任何有品味的人，都会反对以上的两种写法。&lt;/div&gt;
&lt;div&gt;即使一个方法的参数超级多，超出了 100 个字符，我本人也是极不情愿换行的。所以，K 神的说法深得我心。&lt;/div&gt;
&lt;div&gt;关于代码风格，没有绝对完全一致的标准。本文也不想引起争论。不过，我认同 K 神设定的规则，因为一种与主流不同的审美倾向，值得发现它的同类。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>[译] PEP-255：简单的生成器</title>
            <link>https://pythoncat.top/posts/2019-01-19-generator/</link>
            <guid>https://pythoncat.top/posts/2019-01-19-generator/</guid>
            <description>我正打算写写 Python 的生成器，然而查资料时发现，引入生成器的 PEP 没人翻译过，因此就花了点时间翻译出来了</description>
            <pubDate>Mon, 15 Feb 2021 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;PEP原文&lt;/strong&gt;：&lt;a href=&quot;https://www.python.org/dev/peps/pep-0255&quot;&gt;https://www.python.org/dev/peps/pep-0255&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;创建日期&lt;/strong&gt;：2001-05-18&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;合入Python版本&lt;/strong&gt;：2.2&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; ：&lt;a href=&quot;https://zhuanlan.zhihu.com/pythonCat&quot;&gt;豌豆花下猫&lt;/a&gt;（&lt;strong&gt;Python猫&lt;/strong&gt; 公众号作者）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;PEP背景知识&lt;/strong&gt; ：&lt;a href=&quot;https://mp.weixin.qq.com/s/oRoBxZ2-IyuPOf_MWyKZyw&quot;&gt;学习Python，怎能不懂点PEP呢？&lt;/a&gt;&lt;/div&gt;
&lt;h2&gt;摘要&lt;/h2&gt;
&lt;div&gt;这个 PEP 想在 Python 中引入生成器的概念，以及一个新的表达式，即 yield 表达式。&lt;/div&gt;
&lt;h2&gt;动机&lt;/h2&gt;
&lt;div&gt;当一个生产者函数在处理某些艰难的任务时，它可能需要维持住生产完某个值时的状态，大多数编程语言都提供不了既舒服又高效的方案，除了往参数列表中添加回调函数，然后每生产一个值时就去调用一下。&lt;/div&gt;
&lt;div&gt;例如，标准库中的&lt;code&gt;tokenize.py&lt;/code&gt;采用这种方法：调用者必须传一个 tokeneater 函数给 tokenize() ，当 tokenize() 找到下一个 token 时再调用。这使得 tokenize 能以自然的方式编码，但程序调用 tokenize 会变得极其复杂，因为它需要记住每次回调前最后出现的是哪个 token(s)。&lt;code&gt;tabnanny.py&lt;/code&gt;中的 tokeneater 函数是处理得比较好的例子，它在全局变量中维护了一个状态机，用于记录已出现的 token 和预期会出现的 token 。这很难正确地工作，而且也挺难让人理解。不幸的是，它已经是最标准的解决方法了。&lt;/div&gt;
&lt;div&gt;有一个替代方案是一次性生成 Python 程序的全部解析，并存入超大列表中。这样 tokenize 客户端可以用自然的方式，即使用局部变量和局部控制流（例如循环和嵌套的 if 语句），来跟踪其状态。然而这并不实用：程序会变得臃肿，因此不能在实现整个解析所需的内存上放置先验限制；而有些 tokenize 客户端仅仅想要查看某个特定的东西是否曾出现（例如，future 声明，或者像 IDLE 做的那样，只是首个缩进的声明），因此解析整个程序就是严重地浪费时间。&lt;/div&gt;
&lt;div&gt;另一个替代方案是把 tokenize 变为一个迭代器【注释1】，每次调用它的 next() 方法时再传递下一个 token。这对调用者来说很便利，就像前一方案把结果存入大列表一样，同时没有内存与“想要早点退出怎么办”的缺点。然而，这个方案也把 tokenize 的负担转化成记住 next() 的调用状态，读者只要瞄一眼 tokenize.tokenize_loop() ，就会意识到这是一件多么可怕的苦差事。或者想象一下，用递归算法来生成普通树结构的节点：若把它投射成一个迭代器框架实现，就需要手动地移除递归状态并维护遍历的状态。&lt;/div&gt;
&lt;div&gt;第四种选择是在不同的线程中运行生产者和消费者。这允许两者以自然的方式维护其状态，所以都会很舒服。实际上，Python 源代码发行版中的 Demo/threads/Generator.py 就提供了一个可用的同步通信（synchronized-communication）类，来完成一般的任务。但是，这在没有线程的平台上无法运用，而且就算可用也会很慢（与不用线程可取得的成就相比）。&lt;/div&gt;
&lt;div&gt;最后一个选择是使用 Python 的变种 Stackless 【注释2-3】来实现，它支持轻量级的协程。它与前述的线程方案有相同的编程优势，效率还更高。然而，Stackless 在 Python 核心层存在争议，Jython 也可能不会实现相同的语义。这个 PEP 不是讨论这些问题的地方，但完全可以说生成器是 Stackless 相关功能的子集在当前 CPython 中的一种简单实现，而且可以说，其它 Python 实现起来也相对简单。&lt;/div&gt;
&lt;div&gt;以上分析完了已有的方案。其它一些高级语言也提供了不错的解决方案，特别是 Sather 的迭代器，它受到 CLU 的迭代器启发【注释4】；Icon 的生成器，一种新颖的语言，其中每个表达式都是生成器【注释5】。它们虽有差异，但基本的思路是一致的：提供一种函数，它可以返回中间结果（“下一个值”）给它的调用者，同时还保存了函数的局部状态，以便在停止的位置恢复（译注：resum，下文也译作激活）调用。一个非常简单的例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;def fib():
    a, b = 0, 1
    while 1:
       yield b
       a, b = b, a+b&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;当 fib() 首次被调用时，它将 a 设为 0，将 b 设为 1，然后生成 b 给其调用者。调用者得到 1。当 fib 恢复时，从它的角度来看，yield 语句实际上跟 print 语句相同：fib 继续执行，且所有局部状态完好无损。然后，a 和 b 的值变为 1，并且 fib 再次循环到 yield，生成 1 给它的调用者。以此类推。 从 fib 的角度来看，它只是提供一系列结果，就像用了回调一样。但是从调用者的角度来看，fib 的调用就是一个可随时恢复的可迭代对象。跟线程一样，这允许两边以最自然的方式进行编码；但与线程方法不同，这可以在所有平台上高效完成。事实上，恢复生成器应该不比函数调用昂贵。&lt;/div&gt;
&lt;div&gt;同样的方法适用于许多生产者/消费者函数。例如，tokenize.py 可以生成下一个 token 而不是用它作为参数调用回调函数，而且 tokenize 客户端可以以自然的方式迭代 tokens：Python 生成器是一种迭代器，但是特别强大。&lt;/div&gt;
&lt;h2&gt;设计规格：yield&lt;/h2&gt;
&lt;div&gt;引入了一种新的表达式：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;yield_stmt：“yield”expression_list&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;yield 是一个新的关键字，因此需要一个 &lt;code&gt;future&lt;/code&gt; 声明【注释8】来进行引入：在早期版本中，若想使用生成器的模块，必须在接近头部处包含以下行（详见 PEP 236）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;from __future__ import generators&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;没有引入 future 模块就使用 yield 关键字，将会告警。 在后续的版本中，yield 将是一个语言关键字，不再需要 future 语句。&lt;/div&gt;
&lt;div&gt;yield 语句只能在函数内部使用。包含 yield 语句的函数被称为生成器函数。从各方面来看，生成器函数都只是个普通函数，但在它的代码对象的 co_flags 中设置了新的“CO_GENERATOR”标志。&lt;/div&gt;
&lt;div&gt;当调用生成器函数时，实际参数还是绑定到函数的局部变量空间，但不会执行代码。得到的是一个 generator-iterator 对象；这符合迭代器协议【注释6】，因此可用于 for 循环。注意，在上下文无歧义的情况下，非限定名称 “generator” 既可以指生成器函数，又可以指生成器-迭代器（generator-iterator）。&lt;/div&gt;
&lt;div&gt;每次调用 generator-iterator 的 next() 方法时，才会执行 generator-function 体中的代码，直至遇到 yield 或 return 语句（见下文），或者直接迭代到尽头。&lt;/div&gt;
&lt;div&gt;如果执行到 yield 语句，则函数的状态会被冻结，并将 expression_list 的值返回给 next() 的调用者。“冻结”是指挂起所有本地状态，包括局部变量、指令指针和内部堆栈：保存足够的信息，以便在下次调用 next() 时，函数可以继续执行，仿佛 yield 语句只是一次普通的外部调用。&lt;/div&gt;
&lt;div&gt;限制：yield 语句不能用于 try-finally 结构的 try 子句中。困难的是不能保证生成器会被再次激活（resum），因此无法保证 finally 语句块会被执行；这就太违背 finally 的用处了。&lt;/div&gt;
&lt;div&gt;限制：生成器在活跃状态时无法被再次激活：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def g():
...     i = me.next()
...     yield i
&amp;gt;&amp;gt;&amp;gt; me = g()
&amp;gt;&amp;gt;&amp;gt; me.next()
Traceback (most recent call last):
 ...
 File &quot;&amp;lt;string&amp;gt;&quot;, line 2, in g
ValueError: generator already executing&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;设计规格：return&lt;/h2&gt;
&lt;div&gt;生成器函数还可以包含以下形式的return语句：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;return&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;注意，生成器主体中的 return 语句不允许使用 expression_list （然而当然，它们可以嵌套地使用在生成器里的非生成器函数中）。&lt;/div&gt;
&lt;div&gt;当执行到 return 语句时，程序会正常 return，继续执行恰当的 finally 子句（如果存在）。然后引发一个 StopIteration 异常，表明迭代器已经耗尽。如果程序没有显式 return 而执行到生成器的末尾，也会引发 StopIteration 异常。&lt;/div&gt;
&lt;div&gt;请注意，对于生成器函数和非生成器函数，return 意味着“我已经完成，并且没有任何有趣的东西可以返回”。&lt;/div&gt;
&lt;div&gt;注意，return 并不一定会引发 StopIteration ：关键在于如何处理封闭的 try-except 结构。 例如：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def f1():
...     try:
...         return
...     except:
...        yield 1
&amp;gt;&amp;gt;&amp;gt; print list(f1())
[]&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;因为，就像在任何函数中一样，return 只是退出，但是：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def f2():
...     try:
...         raise StopIteration
...     except:
...         yield 42
&amp;gt;&amp;gt;&amp;gt; print list(f2())
[42]&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;因为 StopIteration 被一个简单的 except 捕获，就像任意异常一样。&lt;/div&gt;
&lt;h2&gt;设计规格：生成器和异常传播&lt;/h2&gt;
&lt;div&gt;如果一个未捕获的异常——包括但不限于 StopIteration——由生成器函数引发或传递，则异常会以通常的方式传递给调用者，若试图重新激活生成器函数的话，则会引发 StopIteration 。 换句话说，未捕获的异常终结了生成器的使用寿命。&lt;/div&gt;
&lt;div&gt;示例（不合语言习惯，仅作举例）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def f():
...     return 1/0
&amp;gt;&amp;gt;&amp;gt; def g():
...     yield f()  # the zero division exception propagates
...     yield 42   # and we&apos;ll never get here
&amp;gt;&amp;gt;&amp;gt; k = g()
&amp;gt;&amp;gt;&amp;gt; k.next()
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in ?
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 2, in g
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 2, in f
ZeroDivisionError: integer division or modulo by zero
&amp;gt;&amp;gt;&amp;gt; k.next()  # and the generator cannot be resumed
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in ?
StopIteration
&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;设计规格：Try/Exception/Finally&lt;/h2&gt;
&lt;div&gt;前面提过，yield 语句不能用于 try-finally 结构的 try 子句中。这带来的结果是生成器要非常谨慎地分配关键的资源。但是在其它地方，yield 语句并无限制，例如 finally 子句、except 子句、或者 try-except 结构的 try 子句：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def f():
...     try:
...         yield 1
...         try:
...             yield 2
...             1/0
...             yield 3  # never get here
...         except ZeroDivisionError:
...             yield 4
...             yield 5
...             raise
...         except:
...             yield 6
...         yield 7     # the &quot;raise&quot; above stops this
...     except:
...         yield 8
...     yield 9
...     try:
...         x = 12
...     finally:
...        yield 10
...     yield 11
&amp;gt;&amp;gt;&amp;gt; print list(f())
[1, 2, 4, 5, 8, 9, 10, 11]
&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;示例&lt;/h2&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;# 二叉树类
class Tree:

    def __init__(self, label, left=None, right=None):
        self.label = label
        self.left = left
        self.right = right

    def __repr__(self, level=0, indent=&quot;    &quot;):
        s = level*indent + `self.label`
        if self.left:
            s = s + &quot;\n&quot; + self.left.__repr__(level+1, indent)
        if self.right:
            s = s + &quot;\n&quot; + self.right.__repr__(level+1, indent)
        return s

    def __iter__(self):
        return inorder(self)

# 从列表中创建 Tree
def tree(list):
    n = len(list)
    if n == 0:
        return []
    i = n / 2
    return Tree(list[i], tree(list[:i]), tree(list[i+1:]))

# 递归生成器，按顺序生成树标签
def inorder(t):
    if t:
        for x in inorder(t.left):
            yield x
        yield t.label
        for x in inorder(t.right):
            yield x

# 展示：创建一棵树
t = tree(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;)
# 按顺序打印树的节点
for x in t:
    print x,
print

# 非递归生成器
def inorder(node):
    stack = []
    while node:
        while node.left:
            stack.append(node)
            node = node.left
        yield node.label
        while not node.right:
            try:
                node = stack.pop()
            except IndexError:
                return
            yield node.label
        node = node.right

# 练习非递归生成器
for x in t:
    print x,
print
Both output blocks display:

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;问答&lt;/h2&gt;
&lt;h3&gt;为什么重用 def 而不用新的关键字？&lt;/h3&gt;
&lt;div&gt;请参阅下面的 BDFL 声明部分。&lt;/div&gt;
&lt;h3&gt;为什么用新的关键字yield而非内置函数？&lt;/h3&gt;
&lt;div&gt;Python 中通过关键字能更好地表达控制流，即 yield 是一个控制结构。而且为了 Jython 的高效实现，编译器需要在编译时就确定潜在的挂起点，新的关键字会使这一点变得简单。CPython 的实现也大量利用它来检测哪些函数是生成器函数（尽管一个新的关键字替代 def 就能解决 CPython 的问题，但人们问“为什么要新的关键字”问题时，并不想要新的关键字）。&lt;/div&gt;
&lt;h3&gt;为什么不是其它不带新关键字的特殊语法？&lt;/h3&gt;
&lt;div&gt;例如，为何不用下面用法而用 yield 3：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;return 3 and continue
return and continue 3
return generating 3
continue return 3
return &amp;gt;&amp;gt; , 3
from generator return 3
return &amp;gt;&amp;gt; 3
return &amp;lt;&amp;lt; 3
&amp;gt;&amp;gt; 3
&amp;lt;&amp;lt; 3
* 3&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我没有错过一个“眼色”吧？在数百条消息中，我算了每种替代方案有三条建议，然后总结出上面这些。不需要用新的关键字会很好，但使用 yield 会更好——我个人认为，在一堆无意义的关键字或运算符序列中，yield 更具表现力。尽管如此，如果这引起足够的兴趣，支持者应该发起一个提案，交给 Guido 裁断。&lt;/div&gt;
&lt;h3&gt;为什么允许用return，而不强制用StopIteration？&lt;/h3&gt;
&lt;div&gt;“StopIteration”的机制是底层细节，就像 Python 2.1 中的“IndexError”的机制一样：实现时需要做一些预先定义好的东西，而 Python 为高级用户开放了这些机制。尽管不强制要求每个人都在这个层级工作。 “return”在任何一种函数中都意味着“我已经完成”，这很容易解读和使用。注意，&lt;code&gt;return&lt;/code&gt; 并不总是等同于 try-except 结构中的 &lt;code&gt;raise StopIteration&lt;/code&gt;（参见“设计规格：Return”部分）。&lt;/div&gt;
&lt;h3&gt;那为什么不允许return一个表达式？&lt;/h3&gt;
&lt;div&gt;也许有一天会允许。 在 Icon 中，&lt;code&gt;return expr&lt;/code&gt; 意味着“我已经完成”和“但我还有最后一个有用的值可以返回，这就是它”。 在初始阶段，不强制使用&lt;code&gt;return expr&lt;/code&gt;的情况下，使用 yield 仅仅传递值，这很简单明了。&lt;/div&gt;
&lt;h2&gt;BDFL声明&lt;/h2&gt;
&lt;h3&gt;Issue&lt;/h3&gt;
&lt;div&gt;引入另一个新的关键字（比如，gen 或 generator ）来代替 def ，或以其它方式改变语法，以区分生成器函数和非生成器函数。&lt;/div&gt;
&lt;h3&gt;Con&lt;/h3&gt;
&lt;div&gt;实际上（你如何看待它们），生成器&lt;em&gt;是&lt;/em&gt;函数，但它们具有可恢复性。使它们建立起来的机制是一个相对较小的技术问题，引入新的关键字无助于强调生成器是如何启动的机制（生成器生命中至关重要却很小的部分）。&lt;/div&gt;
&lt;h3&gt;Pro&lt;/h3&gt;
&lt;div&gt;实际上（你如何看待它们），生成器函数实际上是工厂函数，它们就像施了魔法一样地生产生成器-迭代器。 在这方面，它们与非生成器函数完全不同，更像是构造函数而不是函数，因此重用 def 无疑是令人困惑的。藏在内部的 yield 语句不足以警示它们的语义是如此不同。&lt;/div&gt;
&lt;h3&gt;BDFL&lt;/h3&gt;
&lt;div&gt;def 留了下来。任何一方都没有任何争论是完全令人信服的，所以我咨询了我的语言设计师的直觉。它告诉我 PEP 中提出的语法是完全正确的——不是太热，也不是太冷。但是，就像希腊神话中的 Delphi（译注：特尔斐，希腊古都） 的甲骨文一样，它并没有告诉我原因，所以我没有对反对此 PEP 语法的论点进行反驳。 我能想出的最好的（除了已经同意做出的反驳）是“FUD”（译注：缩写自 fear、uncertainty 和 doubt）。 如果这从第一天开始就是语言的一部分，我非常怀疑这早已让安德鲁·库奇林（Andrew Kuchling）的“Python Warts”页面成为可能。（译注：wart 是疣，一种难看的皮肤病。这是一个 wiki 页面，列举了对 Python 吹毛求疵的建议）。&lt;/div&gt;
&lt;h2&gt;参考实现&lt;/h2&gt;
&lt;div&gt;当前的实现（译注：2001年），处于初步状态（没有文档，但经过充分测试，可靠），是Python 的 CVS 开发树【注释9】的一部分。 使用它需要您从源代码中构建 Python。&lt;/div&gt;
&lt;div&gt;这是衍生自 Neil Schemenauer【注释7】的早期补丁。&lt;/div&gt;
&lt;h2&gt;脚注和参考文献&lt;/h2&gt;
&lt;div&gt;[1] PEP-234, Iterators, Yee, Van Rossum&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://www.python.org/dev/peps/pep-0234/&quot;&gt;http://www.python.org/dev/peps/pep-0234/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[2] &lt;a href=&quot;http://www.stackless.com/&quot;&gt;http://www.stackless.com/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[3] PEP-219, Stackless Python, McMillan&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://www.python.org/dev/peps/pep-0219/&quot;&gt;http://www.python.org/dev/peps/pep-0219/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[4] “Iteration Abstraction in Sather” Murer, Omohundro, Stoutamire and Szyperski&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://www.icsi.berkeley.edu/~sather/Publications/toplas.html&quot;&gt;http://www.icsi.berkeley.edu/~sather/Publications/toplas.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[5] &lt;a href=&quot;http://www.cs.arizona.edu/icon/&quot;&gt;http://www.cs.arizona.edu/icon/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[6] The concept of iterators is described in PEP 234. See [1] above.&lt;/div&gt;
&lt;div&gt;[7] &lt;a href=&quot;http://python.ca/nas/python/generator.diff&quot;&gt;http://python.ca/nas/python/generator.diff&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[8] PEP 236, Back to the &lt;strong&gt;future&lt;/strong&gt;, Peters&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://www.python.org/dev/peps/pep-0236/&quot;&gt;http://www.python.org/dev/peps/pep-0236/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;[9] To experiment with this implementation, check out Python from CVS according to the instructions at &lt;a href=&quot;http://sf.net/cvs/?group_id=5470&quot;&gt;http://sf.net/cvs/?group_id=5470&lt;/a&gt; ，Note that the std test Lib/test/test_generators.py contains many examples, including all those in this PEP.&lt;/div&gt;
&lt;h2&gt;版权信息&lt;/h2&gt;
&lt;div&gt;本文档已经放置在公共领域。源文档：&lt;a href=&quot;https://github.com/python/peps/blob/master/pep-0255.txt&quot;&gt;https://github.com/python/peps/blob/master/pep-0255.txt&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;（译文完）&lt;/div&gt;
&lt;div&gt;PS：官方 PEP 有将近500个，然而保守估计，被翻译成中文的不足20个（去重的情况下）。我好奇，感兴趣将一些重要的 PEP 翻译出来的人有多少呢？现抛此问题出来探探路，欢迎留言交流。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python猫荐书系列之五：《Python高性能编程》</title>
            <link>https://pythoncat.top/posts/2019-01-13-book5/</link>
            <guid>https://pythoncat.top/posts/2019-01-13-book5/</guid>
            <pubDate>Sun, 13 Jan 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;稍微关心编程语言的使用趋势的人都知道，最近几年，国内最火的两种语言非 Python 与 Go 莫属，于是，隔三差五就会有人问：这两种语言谁更厉害/好找工作/高工资…&lt;/div&gt;
&lt;div&gt;对于编程语言的争论，就是猿界的生理周期，每个月都要闹上一回。到了年末，各类榜单也是特别抓人眼球，闹得更凶。&lt;/div&gt;
&lt;div&gt;其实，它们各有对方所无法比拟的优势以及用武之地，很多争论都是没有必要的。身为一个正在努力学习 Python 的（准）中年程序员，我觉得吧，先把一门语言精进了再说。没有差劲的语言，只有差劲的程序员，等真的把语言学好了，必定是“山重水复疑无路，柳暗花明又一村”。&lt;/div&gt;
&lt;div&gt;铺垫已了，进入今天的正题，Python 猫荐书系列之五——&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Python高性能编程&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;本书适合已入门 Python、还想要进阶和提高的读者阅读。&lt;/div&gt;
&lt;div&gt;所有计算机语言说到底都是在硬件层面的数据操作，所以高性能编程的一个终极目标可以说是“高性能硬件编程”。然而，Python 是一门高度抽象的计算机语言，它的一大优势是开发团队的高效，不可否认地存在这样或那样的设计缺陷，以及由于开发者的水平而造成的人为的性能缺陷。&lt;/div&gt;
&lt;div&gt;本书的一大目的就是通过介绍各种模块和原理，来促成在快速开发 Python 的同时避免很多性能局限，既减低开发及维护成本，又收获系统的高效。&lt;/div&gt;
&lt;h2&gt;1、性能分析是基础&lt;/h2&gt;
&lt;div&gt;首先的一个关键就是性能分析，借此可以找到性能的瓶颈，使得性能调优做到事半功倍。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;性能调优能够让你的代码能够跑得“足够快”以及“足够瘦”。性能分析能够让你用最小的代价做出最实用的决定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;书中介绍了几种性能分析的工具：&lt;/div&gt;
&lt;div&gt;（1）基本技术如 IPython 的 %timeit 魔法函数、time.time()、以及一个计时修饰器，使用这些技术来了解语句和函数的行为。&lt;/div&gt;
&lt;div&gt;（2）内置工具如 cProfile，了解代码中哪些函数耗时最长，并用 runsnake 进行可视化。&lt;/div&gt;
&lt;div&gt;（3）line_profiler 工具，对选定的函数进行逐行分析，其结果包含每行被调用的次数以及每行花费的时间百分比。&lt;/div&gt;
&lt;div&gt;（4）memory_profiler 工具，以图的形式展示RAM的使用情况随时间的变化，解释为什么某个函数占用了比预期更多的 RAM。&lt;/div&gt;
&lt;div&gt;（5）Guppy 项目的 heapy 工具，查看 Python 堆中对象的数量以及每个对象的大小，这对于消灭奇怪的内存泄漏特别有用。&lt;/div&gt;
&lt;div&gt;（6）dowser 工具，通过Web浏览器界面审查一个持续运行的进程中的实时对象。&lt;/div&gt;
&lt;div&gt;（7）dis 模块，查看 CPython 的字节码，了解基于栈的 Python 虚拟机如何运行。&lt;/div&gt;
&lt;div&gt;（8）单元测试，在性能分析时要避免由优化手段带来的破坏性后果。&lt;/div&gt;
&lt;div&gt;作者强调了性能分析的重要性，同时也对如何确保性能分析的成功提了醒，例如，将测试代码与主体代码分离、避免硬件条件的干扰（如在BIOS上禁用了TurboBoost、禁用了操作系统改写SpeedStep、只使用主电源等）、运行实验时禁用后台工具如备份和Dropbox、多次实验、重启并重跑实验来二次验证结果，等等。&lt;/div&gt;
&lt;div&gt;性能分析对于高性能编程的作用，就好比复杂度分析对于算法的作用，它本身不是高性能编程的一部分，但却是最终有效的一种评判标准。&lt;/div&gt;
&lt;h2&gt;2、数据结构的影响&lt;/h2&gt;
&lt;div&gt;高性能编程最重要的事情是了解数据结构所能提供的性能保证。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;高性能编程的很大一部分是了解你查询数据的方式，并选择一个能够迅速响应这个查询的数据结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;书中主要分析了 4 种数据结构：列表和元组就类似于其它编程语言的数组，主要用于存储具有内在次序的数据；而字典和集合就类似其它编程语言的哈希表/散列集，主要用于存储无序的数据。&lt;/div&gt;
&lt;div&gt;本书在介绍相关内容的时候很克制，所介绍的都是些影响“速度更快、开销更低”的内容，例如：内置的 Tim 排序算法、列表的 resize 操作带来的超额分配的开销、元组的内存滞留（intern机制）带来的资源优化、散列函数与嗅探函数的工作原理、散列碰撞带来的麻烦与应对、Python 命名空间的管理，等等。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;理解了这些内容，就能更加了解在什么情况下使用什么数据结构，以及如何优化这些数据结构的性能。&lt;/div&gt;
&lt;div&gt;另外，关于这 4 种数据结构，书中还得出了一些有趣的结论：对于一个拥有100 000 000个元素的大列表，实际分配的可能是112 500 007个元素；初始化一个列表比初始化一个元组慢5.1 倍；字典或集合默认的最小长度是8（也就是说，即使你只保存3个值，Python仍然会分配 8 个元素）、对于有限大小的字典不存在一个最佳的散列函数。&lt;/div&gt;
&lt;h2&gt;3、矩阵和矢量计算&lt;/h2&gt;
&lt;div&gt;矢量计算是计算机工作原理不可或缺的部分，也是在芯片层次上对程序进行加速所必须了解的部分。&lt;/div&gt;
&lt;div&gt;然而，原生 Python 并不支持矢量操作，因为 Python 列表存储的不是实际的数据，而是对实际数据的引用。在矢量和矩阵操作时，这种存储结构会造成极大的性能下降。比如，&lt;code&gt;grid[5][2]&lt;/code&gt; 中的两个数字其实是索引值，程序需要根据索引值进行两次查找，才能获得实际的数据。&lt;/div&gt;
&lt;div&gt;同时，因为数据被分片存储，我们只能分别对每一片进行传输，而不是一次性传输整个块，因此，内存传输的开销也很大。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;减少瓶颈最好的方法是让代码知道如何分配我们的内存以及如何使用我们的数据进行计算。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;Numpy 能够将数据连续存储在内存中并支持数据的矢量操作，在数据处理方面，它是高性能编程的最佳解决方案之一。&lt;/div&gt;
&lt;div&gt;Numpy 带来性能提升的关键在于，它使用了高度优化且特殊构建的对象，取代了通用的列表结构来处理数组，由此减少了内存碎片；此外，自动矢量化的数学操作使得矩阵计算非常高效。&lt;/div&gt;
&lt;div&gt;Numpy 在矢量操作上的缺陷是一次只能处理一个操作。例如，当我们做 A * B + C 这样的矢量操作时，先要等待 A * B 操作完成，并保存数据在一个临时矢量中，然后再将这个新的矢量和 C 相加。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Numexpr 模块可以将矢量表达式编译成非常高效的代码，可以将缓存失效以及临时变量的数量最小化。另外，它还能利用多核 CPU 以及 Intel 芯片专用的指令集来将速度最大化。&lt;/div&gt;
&lt;div&gt;书中尝试了多种优化方法的组合，通过详细的分析，展示了高性能编程所能带来的性能提升效果。&lt;/div&gt;
&lt;h2&gt;4、编译器&lt;/h2&gt;
&lt;div&gt;书中提出一个观点：&lt;strong&gt;让你的代码运行更快的最简单的办法就是让它做更少的工作。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;编译器把代码编译成机器码，是提高性能的关键组成部分。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;不同的编译器有什么优势呢，它们对于性能提升会带来多少好处呢？书中主要介绍了如下编译工具：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Cython ——这是编译成C最通用的工具，覆盖了Numpy和普通的Python代码（需要一些C语言的知识）。&lt;/li&gt;
&lt;li&gt;Shed Skin —— 一个用于非Numpy代码的，自动把Python转换成C的转换器。&lt;/li&gt;
&lt;li&gt;Numba —— 一个专用于Numpy代码的新编译器。&lt;/li&gt;
&lt;li&gt;Pythran —— 一个用于Numpy和非numpy代码的新编译器。&lt;/li&gt;
&lt;li&gt;PyPy —— 一个用于非Numpy代码的，取代常规Python可执行程序的稳定的即时编译器。&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;书中分析了这几种编译器的工作原理、优化范围、以及适用场景等，是不错的入门介绍。此外，作者还提到了其它的编译工具，如Theano、Parakeet、PyViennaCL、ViennaCL、Nuitka 与 Pyston 等，它们各有取舍，在不同领域提供了支撑之力。&lt;/div&gt;
&lt;h2&gt;5、密集型任务&lt;/h2&gt;
&lt;div&gt;高性能编程的一个改进方向是提高密集型任务的处理效率，而这样的任务无非两大类：I/O 密集型与 CPU 密集型。&lt;/div&gt;
&lt;div&gt;I/O 密集型任务主要是磁盘读写与网络通信任务，占用较多 I/O 时间，而对 CPU 要求较少；CPU 密集型任务恰恰相反，它们要消耗较多的 CPU 时间，进行大量的复杂的计算，例如计算圆周率与解析视频等。&lt;/div&gt;
&lt;div&gt;改善 I/O 密集型任务的技术是&lt;strong&gt;异步编程&lt;/strong&gt; ，它使得程序在 I/O 阻塞时，并发执行其它任务，并通过“事件循环”机制来管理各项任务的运行时机，从而提升程序的执行效率。&lt;/div&gt;
&lt;div&gt;书中介绍了三种异步编程的库：Gevent、Tornado 和 Asyncio，对三种模块的区别做了较多分析。&lt;/div&gt;
&lt;div&gt;改善 CPU 密集型任务的主要方法是利用多核 CPU 进行多进程的运算。&lt;/div&gt;
&lt;div&gt;Multiprocessing 模块使用基于进程和基于线程的并行处理，在队列上共享任务，以及在进程间共享数据，是处理 CPU 密集型任务的重要技术。&lt;/div&gt;
&lt;div&gt;书中没有隐瞒它的局限性：Amdahl 定律揭示的优化限度、适应于单机多核而多机则有其它选择、全局解释锁 GIL 的束缚、以及进程间通信（同步数据和检查共享数据）的开销。针对进程间通信问题，书中还分析了多种解决方案，例如 Less Naïve Pool、Manager、Redis、RawValue、MMap 等。&lt;/div&gt;
&lt;h2&gt;6、集群与现场教训&lt;/h2&gt;
&lt;div&gt;集群是一种多服务器运行相同任务的结构，也就是说，集群中的各节点提供相同的服务，其优点是系统扩展容易、具备容灾恢复能力。&lt;/div&gt;
&lt;div&gt;集群需要克服的挑战有：机器间信息同步的延迟、机器间配置与性能的差异、机器的损耗与维护、其它难以预料的问题。书中列举了两个惨痛的教训：华尔街公司骑士资本由于软件升级引入的错误，损失4.62亿美元；Skype 公司 24 小时全球中断的严重事故。&lt;/div&gt;
&lt;div&gt;书中给我们重点介绍了三个集群化解决方案：Parallel Python、IPython Parallel 和 NSQ。引申也介绍了一些普遍使用的方案，如 Celery、Gearman、PyRes、SQS。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;关于现场教训，它们不仅仅是一些事故或者故事而已，由成功的公司所总结出来的经验更是来之不易的智慧。书中单独用一章内容分享了六篇文章，这些文章出自几个使用 Python 的公司/大型组织，像是Adaptive Lab、RadimRehurek、Smesh、PyPy 与 Lanyrd ，这些国外组织的一线实践经验，应该也能给国内的 Python 社区带来一些启示。&lt;/div&gt;
&lt;h2&gt;7、写在最后&lt;/h2&gt;
&lt;div&gt;众所周知，Python 应用前景大、简单易学、方便开发与部署，然而与其它编程语言相比，它的性能几乎总是落于下风。如何解决这个难题呢？本期荐书的书目就是一种回应。&lt;/div&gt;
&lt;div&gt;《Python高性能编程》全书从微观到宏观对高性能编程的方方面面做了讲解，主要包含以下主题：计算机内部结构的背景知识、列表和元组、字典和集合、迭代器和生成器、矩阵和矢量计算、编译器、并发、集群和工作队列等。这些内容为编写更快的 Python 指明了答案。&lt;/div&gt;
&lt;div&gt;本篇文章主要以梳理书中的内容要点为主，平均而兼顾地理清了全书脉络（PS：介绍得太面面俱到了，但愿不被指责为一篇流水账的读书笔记才好…）。我认为，鉴于书中谈及的这些话题，它就足以成为我们荐书栏目的一员了。除去某些句段的糟糕翻译、成书时间比较早（2014年）而造成的过时外，这本书总体质量不错，可称为是一份优秀的高性能编程的指引手册。&lt;/div&gt;
&lt;div&gt;关于荐书栏目，我最后多说几句。本栏目原计划两周左右出一篇，但由于其它系列文章花费了我不少时间，而要写好一篇荐书/书评也特别费劲，最后生生造成了现在两月一更的尴尬局面…这篇文章是个错误的示范，我不该试图全面通读与概括其内容的。因此，我决定今后选一些易读的书目，在写作上也尽量走短小精悍风，希望能持续地将本栏目运作下去。若你有什么建议（如书目推荐、书评推荐、写作建议、甚至是投稿），我随时欢迎，先行致谢啦。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;往期荐书回顾：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;第一期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/JnoYojDsNHYkpibSfF3hOg&quot;&gt;编写高质量代码改善 Python 程序的 91 个建议&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;第二期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/9RonAqwCXo_lganYvLHgVw&quot;&gt;Python最佳实践指南&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;第三期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/6swAZA7baF26BlrKV7zBFg&quot;&gt;黑客与画家&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;第四期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/RcvYm7Ro_nnMx0ZVrJmtyA&quot;&gt;Python源码剖析&lt;/a&gt;》&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>聊聊技术写作的个人体会</title>
            <link>https://pythoncat.top/posts/2019-01-11-writing/</link>
            <guid>https://pythoncat.top/posts/2019-01-11-writing/</guid>
            <description>是什么原因使我开始写技术公众号，又是什么动力让我坚持写的？</description>
            <pubDate>Fri, 11 Jan 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;有群友问过，是什么原因使我开始写技术公众号，又是什么动力让我坚持写的。&lt;/div&gt;
&lt;div&gt;在我看来，&lt;strong&gt;写作是一件不能敷衍的事&lt;/strong&gt;，通过写作来学习，反而要比单纯地学习的效果要好。为了写成一篇“拿得出手”的文章，我要反复查找资料，阅读与思考，拆解与整合，最终写成的时候，也是知识的拼图成型的时候。&lt;/div&gt;
&lt;div&gt;所以，对我来说，&lt;strong&gt;写作是一种咀嚼信息而后提炼知识，最终拓展成技能与认知的过程。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;虽然这个过程很缓慢，但曾经的急进方式并没有速成的效果啊，不妨就这样一文章一脚印地试试看咯。&lt;/div&gt;
&lt;div&gt;除此之外，还有一个很重要的原因。文章是一种公共对话的媒介，它是一个展示的窗口，也是一个接收反馈的通道。通过写作，我有了跟其它学习者对话的机会。&lt;/div&gt;
&lt;div&gt;看书学习可能只是个人的事情，但是，在写作平台上发布文章，这就超越了个人行为——你得随时准备着被批评、或者被请教、或者被误解、甚至是被无视（这是最常见的结果）。&lt;/div&gt;
&lt;div&gt;我享受写作文章，来跟其他处在相同处境的同学们交流，来向更优秀的大牛们学习取经。&lt;/div&gt;
&lt;div&gt;这就是我目前写技术文章的一些个人体会吧。&lt;/div&gt;
&lt;div&gt;对于上面提到的第二个原因，我最近颇有感触，想要多聊一些。为了更有针对性，本文姑且限定一个话题吧，那就是“写作技术文章，如何看待他人的批评/意见”。&lt;/div&gt;
&lt;h2&gt;1、主观性的意见&lt;/h2&gt;
&lt;div&gt;有些声音其实只是主观看法，我认为可以和而不同。&lt;/div&gt;
&lt;div&gt;主观世界往往没有确切的对错之分，毕竟——&lt;strong&gt;思想无罪&lt;/strong&gt; 。&lt;/div&gt;
&lt;div&gt;面对主观性的意见，我认为要做到有理有据，坚持一点个性，最后会得到别人的尊重。&lt;/div&gt;
&lt;div&gt;比如，在翻译 Python 社区的七种治理模式的时候，有一个提案是“Python Governance Model Lead by Trio of Pythonistas”，我将它翻译成“三巨头治理模式”。有同学就指出，“Trio”应该翻译成“三人组”或者“三重奏”，翻译成“三巨头”是什么意思？&lt;/div&gt;
&lt;div&gt;这种留言，我认为是主观性的意见，应求同存异。&lt;/div&gt;
&lt;div&gt;我之所以这么翻译，一方面考虑，它要替代的是“终身仁慈独裁者”，三巨头对独裁者，意味深长；另一方面，我脑子里总想着一个皇帝死了，然后政权被三个摄政大臣把持，这种政治画面挥之不去，虽然是不着边际，但挺有趣味，所以我不肯放弃这“三巨头”的译法。&lt;/div&gt;
&lt;div&gt;主观性的意见带入了提出者的个人知识背景、思想结构、以及话语习惯等等，我觉得要先尝试交流，相互交换，能融洽兼容则最好啦，不能的话，及时终止。&lt;/div&gt;
&lt;h2&gt;2、客观性的意见&lt;/h2&gt;
&lt;div&gt;客观性的意见有如下几种：笔误（错别字和其它疏忽）、代码规范、知识性错误…&lt;/div&gt;
&lt;div&gt;对于笔误性的错误，这没啥好说的，我自己发现过几处，也被读者指出过几处。有则改之就好。&lt;/div&gt;
&lt;div&gt;对于代码规范，有时候为了举例方便，确实没有按照规范来。尽量避免，求一个兼顾。&lt;/div&gt;
&lt;div&gt;知识性错误是要热烈欢迎的——不是说欢迎错误，而是说欢迎别人来&lt;strong&gt;指出我所未知的错误。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;出现知识性的错误，就意味着没有全面掌握知识，一旦出现，就必然意味着有提升的空间。本来以为知道了什么，如果被指出了错误，那改正后，才是真的知道了什么。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;知道自己不知道并且改正之，并不可耻，不知道自己不知道，这才可怜。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;在写《&lt;a href=&quot;https://mp.weixin.qq.com/s/PsY8Iec1EeGDKKnTNU5CNw&quot;&gt;Python是否支持复制字符串呢？&lt;/a&gt;》的时候，我根据已得的知识，以及查阅到的资料，早早就得出了一个很满意的结论。最后成文前，临时地加了一个未作验证的示例，没想到这会是一个致命的反例，推翻了前面辛辛苦苦建立起来的一切。&lt;/div&gt;
&lt;div&gt;这是一个客观性的错误，一被指出的时候，很快就能验证。因为这个错误，我重新梳理了相关的知识点，组成新的知识面，写成了一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/M2uHVqaHe_nyO5jT60V_6Q&quot;&gt;join()方法的神奇用处与Intern机制的软肋&lt;/a&gt;》。&lt;/div&gt;
&lt;div&gt;还有一个例子，前不久的《&lt;a href=&quot;https://mp.weixin.qq.com/s/QTodsriWW_gESvmJPD1EYg&quot;&gt;Python进阶：自定义对象实现切片功能&lt;/a&gt;》，我在准备素材的时候，竟采用了一个不严谨的例子，而且自作聪明地批判了别人的实际无误的例子。最后，有读者留言了很长的不同观点，我才意识到自己的错误！&lt;/div&gt;
&lt;div&gt;得益于读者的留言，我修正了自己的错误，而且在修正过程中，也加强了对于其它知识的理解，真是塞翁失马焉知非福啊。&lt;/div&gt;
&lt;h2&gt;3、内置函数与内置类&lt;/h2&gt;
&lt;div&gt;这里还有一个客观性错误，藏得特别深，&lt;strong&gt;可能真的有 90% 的 Python 使用者不知道。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;特别感谢 @xpresslink 同学指出。下面，我给大家分享一下。&lt;/div&gt;
&lt;div&gt;在文章《&lt;a href=&quot;https://mp.weixin.qq.com/s/1fZs_yXIUhjzN0mQyujXhQ&quot;&gt;为什么range不是迭代器？range到底是什么类型？&lt;/a&gt;》里，我的注意点其实就在标题的两个问句里，大部分的留言互动也是基于此。但最后，很意外地，一名读者指出了一个客观性错误，让我有了额外的收获。&lt;/div&gt;
&lt;div&gt;这位同学指出我有些基本的概念是错误的：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;“range() 函数”这个说法是非常明显有错误的，range 不是内置函数（ builtin method ）而是个类对象，在 python 里面不要见到用括号调用的东西就认为是函数，类似的还是有很多，如 list, set, tuple, dict 等，这些都是类, 特别是 enumerate ，这个学 python 的人十有八九认为是函数而不知道是类，加了括号是实例化而不是函数调用。&lt;/p&gt;
&lt;p&gt;python 中类的实例化和函数调用非常容易对新手有大的迷惑性，相对来说在 java 中有明确的 new 关键字加在构造方法前面概念更清楚一些。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;根据这个评论，我就去查看文档。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;上图中 range() 虽然被归类到 Built-in Functions 里面，但是官方描述的是“functions and types”，即是说，在内置函数的大类下面，包含了内置函数与内置类。&lt;/div&gt;
&lt;div&gt;那 range() 属于哪一种呢？看看它的解释：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Rather than being a function, range is actually an immutable sequence type…&lt;/p&gt;
&lt;p&gt;range 实际是一种不可变的序列类型，而非一个（内置）函数…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;按照这里的说法，官方已经区分了 range() 不是函数，正像那位留言的同学所说。&lt;/div&gt;
&lt;div&gt;我第一反应当然是不能接受。我怎么会认为它是内置函数的呢，难道不是根据学习资料得来的么？难道我学习的资料是错的？为何从来没看到有人对此做过辨析呢？&lt;/div&gt;
&lt;div&gt;根据群友的提示，我去查看 Python2 的文档，然后就发现了很有意思的地方：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;首先一点， Built-in Functions 的描述跟 Python3 有点不同，它写的是 “functions”，并不包含“types”；还有一点，在 range() 和 xrange() 的具体内容中，官方都是称呼它们为 function 。&lt;/div&gt;
&lt;div&gt;由此看来，Python2 的官方文档就把 range() 当成内置函数，这个认识错误是有根源的！等到 Python3 的时候，官方把错误改正过来了，然而改得并不彻底。才有了前面同时存在“functions and types”的描述。&lt;/div&gt;
&lt;div&gt;官方已经把 range() 与 xrange() 规范为一个，或许在今后版本，还会专门分出一类 Built-in Types 来存放像 range() 和 enumerate() 这些内置类吧。&lt;/div&gt;
&lt;div&gt;在那之前，我只能先行给大家提个醒了：&lt;strong&gt;别再误以为 range() 是内置函数了。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;那么，怎么辨别哪些是内置函数呢？&lt;/div&gt;
&lt;div&gt;我想到了两个方法：&lt;/div&gt;
&lt;div&gt;（1）看是否存在对应的魔术方法。例如，len() 是一个内置函数，因为它实际调用的是魔术方法&lt;code&gt;__len__()&lt;/code&gt; ；还有最近一直在提的 iter()，它调用的是&lt;code&gt;__iter__()&lt;/code&gt; ，所以也是内置函数；而因为不存在 &lt;code&gt;__range__()&lt;/code&gt; 魔术方法，所以 range() 不是内置函数。&lt;/div&gt;
&lt;div&gt;（2）使用 type() 进行判断，结果为 &lt;code&gt;builtin_function_or_method&lt;/code&gt; 的才是内置函数。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
builtin_function_or_method
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;sorted&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
builtin_function_or_method
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;open&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
builtin_function_or_method

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;enumerate&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;像 open 和 sorted 并没有对应的魔术方法，但判断出来都是内置函数；而 str 虽有对应魔术方法，但判断是 type ，这意味着，以上两种方法得要结合起来看。&lt;/div&gt;
&lt;div&gt;我不确定有多少人事先知道怎么区分内置函数与内置类，但我确实没看到过对这个问题进行辨析的文章，所以，这次是真正涨知识了，也希望这篇文章，能够消除一些读者的错误观念吧。&lt;/div&gt;
&lt;h2&gt;4、小结&lt;/h2&gt;
&lt;div&gt;我最近写的一些文章都不是心血来潮，不管是字符串系列、切片系列还是迭代器系列，本意都是想在一个主题上进行深入的多面性的思考与记录。&lt;/div&gt;
&lt;div&gt;如果没有一些热心读者的指正，我恐怕是很难知道自己错在了哪里，如果不是有这么多的认同以及意见，我恐怕也缺乏动力坚持写下去。&lt;/div&gt;
&lt;div&gt;最后鸣谢几位提意见的小能手同学（时间顺序，可能有漏）：@疯琴、@德玛西亚之翼奎因、@发条橙、@gaieepo、@郭芮、@aijam、@xpresslink、@进击的团子、@不换…&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;相关链接（单有错，双修正）：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;1、&lt;a href=&quot;https://mp.weixin.qq.com/s/PsY8Iec1EeGDKKnTNU5CNw&quot;&gt;Python是否支持复制字符串呢？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;https://mp.weixin.qq.com/s/M2uHVqaHe_nyO5jT60V_6Q&quot;&gt;join()方法的神奇用处与Intern机制的软肋&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;https://mp.weixin.qq.com/s/QTodsriWW_gESvmJPD1EYg&quot;&gt;Python进阶：自定义对象实现切片功能&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;4、&lt;a href=&quot;https://mp.weixin.qq.com/s/IRAjR-KHZBPEEkdiofseGQ&quot;&gt;Python进阶：全面解读高级特性之切片！&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;5、&lt;a href=&quot;https://mp.weixin.qq.com/s/1fZs_yXIUhjzN0mQyujXhQ&quot;&gt;为什么range不是迭代器？range到底是什么类型？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;update：魔术方法不能作为判断条件，文章方法1的部分内容应该删掉。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>为什么range不是迭代器？range到底是什么类型？</title>
            <link>https://pythoncat.top/posts/2019-01-05-range/</link>
            <guid>https://pythoncat.top/posts/2019-01-05-range/</guid>
            <description>range 是可迭代对象而不是迭代器；range 对象是不可变的等差序列</description>
            <pubDate>Sat, 05 Jan 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;迭代器是 23 种设计模式中最常用的一种（之一），在 Python 中随处可见它的身影，我们经常用到它，但是却不一定意识到它的存在。在关于迭代器的系列文章中（链接见文末），我至少提到了 23 种生成迭代器的方法。有些方法是专门用于生成迭代器的，还有一些方法则是为了解决别的问题而“暗中”使用到迭代器。&lt;/div&gt;
&lt;div&gt;在系统学习迭代器之前，我一直以为 range() 方法也是用于生成迭代器的，现在却突然发现，它生成的只是可迭代对象，而并不是迭代器！ （PS：Python2 中 range() 生成的是列表，本文基于Python3，生成的是可迭代对象）&lt;/div&gt;
&lt;div&gt;于是，我有了这样的疑问：为什么 range() 不生成迭代器呢？在查找答案的过程中，我发现自己对 range 类型的认识存在一些误区。因此，本文将和大家全面地认识一下 range ，期待与你共同学习进步。&lt;/div&gt;
&lt;h2&gt;1、range() 是什么？&lt;/h2&gt;
&lt;div&gt;它的语法：range(start, stop [,step]) ；start 指的是计数起始值，默认是 0；stop 指的是计数结束值，但不包括 stop ；step 是步长，默认为 1，不可以为 0 。range() 方法生成一段左闭右开的整数范围。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 即 range(0,5)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; a
&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; a&lt;span&gt;:&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt;end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;0&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;对于 range() 函数，有几个注意点：（1）它表示的是左闭右开区间；（2）它接收的参数必须是整数，可以是负数，但不能是浮点数等其它类型；（3）它是不可变的序列类型，可以进行判断元素、查找元素、切片等操作，但不能修改元素；（4）它是可迭代对象，却不是迭代器。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# （1）左闭右开&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt;end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;

&lt;span&gt;# （2）参数类型&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt;end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;-&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2.2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;
TypeError    Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
TypeError&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;float&apos;&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; cannot be interpreted &lt;span&gt;as&lt;/span&gt; an integer

&lt;span&gt;# （3）序列操作&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; b&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; b&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; b&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
TypeError  Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
TypeError&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;range&apos;&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; does &lt;span&gt;not&lt;/span&gt; support item assignment

&lt;span&gt;# （4）不是迭代器&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;hasattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;__iter__&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;True&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;hasattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;__next__&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;False&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;hasattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;__next__&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;2、 为什么range()不生产迭代器？&lt;/h2&gt;
&lt;div&gt;可以获得迭代器的内置方法很多，例如 zip() 、enumerate()、map()、filter() 和 reversed() 等等，但是像 range() 这样仅仅得到的是可迭代对象的方法就绝无仅有了（若有反例，欢迎告知）。这就是我存在知识误区的地方。&lt;/div&gt;
&lt;div&gt;在 for-循环 遍历时，可迭代对象与迭代器的性能是一样的，即它们都是惰性求值的，在空间复杂度与时间复杂度上并无差异。我曾概括过两者的差别是“一同两不同”：相同的是都可惰性迭代，不同的是可迭代对象不支持自遍历（即next()方法），而迭代器本身不支持切片（即&lt;code&gt;__getitem__()&lt;/code&gt; 方法）。&lt;/div&gt;
&lt;div&gt;虽然有这些差别，但很难得出结论说它们哪个更优。现在微妙之处就在于，为什么给 5 种内置方法都设计了迭代器，偏偏给 range() 方法设计的就是可迭代对象呢？把它们都统一起来，不是更好么？&lt;/div&gt;
&lt;div&gt;事实上，Pyhton 为了规范性就干过不少这种事，例如，Python2 中有 range() 和 xrange() 两种方法，而 Python3 就干掉了其中一种，还用了“李代桃僵”法。为什么不更规范点，令 range() 生成的是迭代器呢？&lt;/div&gt;
&lt;div&gt;关于这个问题，我没找到官方解释，以下纯属&lt;strong&gt;个人观点&lt;/strong&gt; 。&lt;/div&gt;
&lt;div&gt;zip() 等方法都需要接收确定的可迭代对象的参数，是对它们的一种再加工的过程，因此也希望马上产出确定的结果来，所以 Python 开发者就设计了这个结果是迭代器。这样还有一个好处，即当作为参数的可迭代对象发生变化的时候，作为结果的迭代器因为是消耗型的，不会被错误地使用。&lt;/div&gt;
&lt;div&gt;而 range() 方法就不同了，它接收的参数不是可迭代对象，本身是一种初次加工的过程，所以设计它为可迭代对象，既可以直接使用，也可以用于其它再加工用途。例如，zip() 等方法就完全可以接收 range 类型的参数。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;zip&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt; end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;也就是说，range() 方法作为一种初级生产者，它生产的原料本身就有很大用途，早早把它变为迭代器的话，无疑是一种画蛇添足的行为。&lt;/div&gt;
&lt;div&gt;对于这种解读，你是否觉得有道理呢？欢迎就这个话题与我探讨。&lt;/div&gt;
&lt;h2&gt;3、range 类型是什么？&lt;/h2&gt;
&lt;div&gt;以上是我对“为什么range()不产生迭代器”的一种解答。顺着这个思路，我研究了一下它产生的 range 对象，一研究就发现，这个 range 对象也并不简单。&lt;/div&gt;
&lt;div&gt;首先奇怪的一点就是，它竟然是不可变序列！我从未注意过这一点。虽然说，我从未想过修改 range() 的值，但这一不可修改的特性还是令我惊讶。&lt;/div&gt;
&lt;div&gt;翻看文档，官方是这样明确划分的——&lt;strong&gt;有三种基本的序列类型：列表、元组和范围（range）对象。（There are three basic sequence types: lists, tuples, and range objects.）&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;这我倒一直没注意，原来 range 类型居然跟列表和元组是一样地位的基础序列！我一直记挂着字符串是不可变的序列类型，不曾想，这里还有一位不可变的序列类型呢。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;那 range 序列跟其它序列类型有什么差异呢？&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;普通序列都支持的操作有 12 种，在《&lt;a href=&quot;https://mp.weixin.qq.com/s/z-gSW6XJrAvUE5rS5XrAig&quot;&gt;你真的知道Python的字符串是什么吗？&lt;/a&gt;》这篇文章里提到过。range 序列只支持其中的 10 种，不支持进行加法拼接与乘法重复。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;
TypeError  Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
TypeError&lt;span&gt;:&lt;/span&gt; unsupported operand &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;range&apos;&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;&apos;range&apos;&lt;/span&gt;

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;
TypeError  Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
TypeError&lt;span&gt;:&lt;/span&gt; unsupported operand &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;range&apos;&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;&apos;int&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;那么问题来了：同样是不可变序列，为什么字符串和元组就支持上述两种操作，而偏偏 range 序列不支持呢？虽然不能直接修改不可变序列，但我们可以将它们拷贝到新的序列上进行操作啊，为何 range 对象连这都不支持呢？&lt;/div&gt;
&lt;div&gt;且看官方文档的解释：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;…due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern.&lt;/p&gt;
&lt;p&gt;原因是 range 对象仅仅表示一个遵循着严格模式的序列，而重复与拼接通常会破坏这种模式…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;问题的关键就在于 range 序列的 pattern，仔细想想，其实它表示的就是一个&lt;strong&gt;等差数列&lt;/strong&gt;啊（喵，高中数学知识没忘…），拼接两个等差数列，或者重复拼接一个等差数列，想想确实不妥，这就是为啥 range 类型不支持这两个操作的原因了。由此推论，其它修改动作也会破坏等差数列结构，所以统统不给修改就是了。&lt;/div&gt;
&lt;h2&gt;4、小结&lt;/h2&gt;
&lt;div&gt;回顾全文，我得到了两个偏冷门的结论：&lt;strong&gt;range 是可迭代对象而不是迭代器；range 对象是不可变的等差序列。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;若单纯看结论的话，你也许没有感触，或许还会说这没啥了不得啊。但如果我追问，为什么 range 不是迭代器呢，为什么 range 是不可变序列呢？对这俩问题，你是否还能答出个自圆其说的设计思想呢？（PS：我决定了，若有机会面试别人，我必要问这两个问题的嘿~）&lt;/div&gt;
&lt;div&gt;由于 range 对象这细微而有意思的特性，我觉得这篇文章写得值了。本文是作为迭代器系列文章的一篇来写的，所以对于迭代器的基础知识介绍不多，欢迎查看之前的文章。另外，还有一种特殊的迭代器也值得单独成文，那就是&lt;strong&gt;生成器&lt;/strong&gt;了，敬请期待后续推文哦~&lt;/div&gt;
&lt;div&gt;猜你想读：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/DIhwoJE3o0kKw3kzZKysag&quot;&gt;Python进阶：迭代器与迭代器切片&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/7MbRCn37fIIN42rLm6ho3g&quot;&gt;Python进阶：设计模式之迭代器模式&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/z-gSW6XJrAvUE5rS5XrAig&quot;&gt;你真的知道Python的字符串是什么吗？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;20190107 update：有同学指出，range() 不是内置函数而是个类对象。查看&lt;a href=&quot;https://docs.python.org/3/library/functions.html#func-range&quot;&gt;文档&lt;/a&gt;：Rather than being a function, &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; is actually an immutable sequence type, as documented in &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#typesseq-range&quot;&gt;Ranges&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#typesseq&quot;&gt;Sequence Types — list, tuple, range&lt;/a&gt;.如此看来，官方确实不完全把它定义为函数。只是，文档的大类是内置函数，这会引起很多误会…&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python进阶：设计模式之迭代器模式</title>
            <link>https://pythoncat.top/posts/2019-01-02-iterator/</link>
            <guid>https://pythoncat.top/posts/2019-01-02-iterator/</guid>
            <pubDate>Wed, 02 Jan 2019 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在软件开发领域中，人们经常会用到这一个概念——“设计模式”（design pattern），它是一种针对软件设计的共性问题而提出的解决方案。&lt;/div&gt;
&lt;div&gt;在一本圣经级的书籍《设计模式：可复用面向对象软件的基础》（1991年，Design Patterns - Elements of Reusable Object-Oriented Software）中，它提出了23种设计模式。&lt;/div&gt;
&lt;div&gt;迭代器模式就是其中的一种，在各种编程语言中都得到了广泛的应用。&lt;/div&gt;
&lt;div&gt;本文将谈谈 Python 中的迭代器模式，主要内容：什么是迭代器模式、Python 如何实现迭代器模式、itertools 模块创建迭代器的方法、其它运用迭代器的场景等等，期待与你共同学习进步。&lt;/div&gt;
&lt;h2&gt;1、什么是迭代器模式？&lt;/h2&gt;
&lt;div&gt;维基百科有如下定义：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;迭代器是一种最简单也最常见的设计模式。它可以让用户透过特定的接口巡访容器中的每一个元素而不用了解底层的实现。——维基百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;简单地说，迭代器模式就是一种通用性的可以遍历容器类型（如序列类型、集合类型等）的实现方式。使用迭代器模式，可以不关心遍历的对象具体是什么（如字符串、列表、字典等等），也不需要关心遍历的实现算法是什么，它关心的是从容器中遍历/取出元素的结果。&lt;/div&gt;
&lt;div&gt;按遍历方式划分，迭代器可分为内部迭代器与外部迭代器，它们的区别在于执行迭代动作与维持迭代状态的不同。&lt;/div&gt;
&lt;div&gt;通常而言，迭代器是一次性的，当迭代过一轮后，再次迭代将获取不到元素。&lt;/div&gt;
&lt;h2&gt;2、Python的迭代器模式&lt;/h2&gt;
&lt;div&gt;由于迭代器模式的使用太常见了，所以大多数编程语言都给常见的容器类型实现了它，例如 Java 中的 Collection，List、Set、Map等。在 Java 中使用迭代器遍历 List 可以这么写：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;List&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; list &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ArrayList&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;Iterator&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; iterator &lt;span&gt;=&lt;/span&gt; list&lt;span&gt;.&lt;/span&gt;&lt;span&gt;iterator&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;iterator&lt;span&gt;.&lt;/span&gt;&lt;span&gt;hasNext&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;out&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;iterator&lt;span&gt;.&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;ArrayList 类通过自身的 iterator() 方法获得一个迭代器 iterator，然后由该迭代器实例来落实遍历过程。&lt;/div&gt;
&lt;div&gt;Python 当然也应用了迭代器模式，但它的实现思路跟上例却不太一样。&lt;/div&gt;
&lt;div&gt;首先，Python 认为遍历容器类型并不一定要用到迭代器，因此设计了可迭代对象。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;list&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt;end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 1 2 3 4&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt;end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 1 2 3 4&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上例中的 list 是可迭代对象（Iterable），但并不是迭代器（虽然在底层实现时用了迭代器的部分思想）。Python 抓住了迭代器模式的本质，即是“迭代”，赋予了它极高的地位。&lt;/div&gt;
&lt;div&gt;如此设计的好处显而易见：（1）写法简便，用意直白；（2）可重复迭代，避免一次性迭代器的缺陷；（3）不需要创建迭代器，减少开销。&lt;/div&gt;
&lt;div&gt;可迭代对象可看作是广义的迭代器，同时，Python 也设计了普通意义的狭义的迭代器。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;list&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
it &lt;span&gt;=&lt;/span&gt; &lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; it&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt;end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 1 2 3 4&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; it&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt;end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 无输出&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上例中的 iter() 方法会将可迭代对象变成一个迭代器。从输出结果可以看出，该迭代器的迭代过程是一次性的。&lt;/div&gt;
&lt;div&gt;由此看来，&lt;strong&gt;Python 其实是将“迭代器模式”一拆为二来实现：一是可迭代思想，广泛播种于容器类型的对象中，使它们都可迭代；一是迭代器，一种特殊的可迭代对象，承担普通意义上的迭代器所特有的迭代任务。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;同时，它还提供了将可迭代对象转化为迭代器的简易方法，如此安排，真是将迭代器模式的效力发挥到了极致。（关于可迭代对象与迭代器的更多区别、以及它们的实现原理，请参见《&lt;a href=&quot;https://mp.weixin.qq.com/s/DIhwoJE3o0kKw3kzZKysag&quot;&gt;Python进阶：迭代器与迭代器切片&lt;/a&gt;》）&lt;/div&gt;
&lt;h2&gt;3、创建迭代器&lt;/h2&gt;
&lt;div&gt;创建迭代器有如下方式：（1）iter() 方法，将可迭代对象转化成迭代器；（2）&lt;code&gt;__iter__()&lt;/code&gt; 与 &lt;code&gt;__next__()&lt;/code&gt; 魔术方法，定义类实现这两个魔术方法；（3）itertools 模块，使用内置模块生成迭代器；（4）其它创建方法，如 zip() 、map() 、enumerate() 等等。&lt;/div&gt;
&lt;div&gt;四类方法各有适用场所，本节重点介绍 itertools 模块。它可以创建三类迭代器：无限迭代器、有限迭代器与组合迭代器。&lt;/div&gt;
&lt;h3&gt;3.1 无限迭代器&lt;/h3&gt;
&lt;div&gt;&lt;code&gt;count(start=0, step=1)&lt;/code&gt; ：创建一个从 start (默认值为 0) 开始，以 step (默认值为 1) 为步长的的无限整数迭代器。&lt;/div&gt;
&lt;div&gt;&lt;code&gt;cycle(iterable)&lt;/code&gt; ：对可迭代对象的元素反复执行循环。&lt;/div&gt;
&lt;div&gt;&lt;code&gt;repeat(object [,times])&lt;/code&gt; ：反复生成 object 至无限，或者到给定的 times 次。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; itertools
co &lt;span&gt;=&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;count&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
cy &lt;span&gt;=&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;cycle&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;ABC&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
re &lt;span&gt;=&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;repeat&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;A&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;30&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 注意：请分别执行；以下写法未加终止判断，只能按 Ctrl+C 退出&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt; co&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;n&lt;span&gt;,&lt;/span&gt;end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 0 1 2 3 4......&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt; cy&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;n&lt;span&gt;,&lt;/span&gt;end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# A B C A B C A B......&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt; re&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;n&lt;span&gt;,&lt;/span&gt;end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# A A A A A A A A....(30个)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;3.2 有限迭代器&lt;/h3&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;以上方法，比较常用的有：chain() 将多个可迭代对象（可以是不同类型）连接成一个大迭代器；compress() 方法根据真假过滤器筛选元素；groupby() 把迭代器中相邻的重复元素挑出来放在一起；islice() 方法返回迭代器切片（用法参见《&lt;a href=&quot;https://mp.weixin.qq.com/s/DIhwoJE3o0kKw3kzZKysag&quot;&gt;Python进阶：迭代器与迭代器切片&lt;/a&gt;》）；tee() 方法根据可迭代对象创建 n 个（默认2个）迭代器副本。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; c &lt;span&gt;in&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;chain&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;ABC&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;,&lt;/span&gt;end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# 输出结果：A B C 1 2 3&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; c &lt;span&gt;in&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;compress&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;ABCDEF&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;,&lt;/span&gt;end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# 输出结果：A B D F&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; group &lt;span&gt;in&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;groupby&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;aaabbbaaccd&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;:&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;group&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# 输出结果：&lt;/span&gt;
a &lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
b &lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;b&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;b&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;b&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
a &lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
c &lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;c&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;c&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
d &lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;d&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

itertools&lt;span&gt;.&lt;/span&gt;tee&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;abc&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# 输出结果：(&amp;lt;itertools._tee at 0x1fc72c08108&amp;gt;,&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;itertools&lt;span&gt;.&lt;/span&gt;_tee at &lt;span&gt;0x1fc73f91d08&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;itertools&lt;span&gt;.&lt;/span&gt;_tee at &lt;span&gt;0x1fc73efc248&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;3.3 组合迭代器&lt;/h3&gt;
&lt;div&gt;product() ：求解多个可迭代对象的笛卡尔积。&lt;/div&gt;
&lt;div&gt;permutations() ：求解可迭代对象的元素的全排列。&lt;/div&gt;
&lt;div&gt;combinations()：求解可迭代对象的元素的组合。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;product&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;ABC&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt; end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# 输出结果：(&apos;A&apos;, 1) (&apos;A&apos;, 2) (&apos;B&apos;, 1) (&apos;B&apos;, 2) (&apos;C&apos;, 1) (&apos;C&apos;, 2)&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;permutations&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;ABC&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt; end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# 输出结果：(&apos;A&apos;, &apos;B&apos;) (&apos;A&apos;, &apos;C&apos;) (&apos;B&apos;, &apos;A&apos;) (&apos;B&apos;, &apos;C&apos;) (&apos;C&apos;, &apos;A&apos;) (&apos;C&apos;, &apos;B&apos;)&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;combinations&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;ABC&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt; end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# 输出结果：(&apos;A&apos;, &apos;B&apos;) (&apos;A&apos;, &apos;C&apos;) (&apos;B&apos;, &apos;C&apos;)&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;combinations&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;ABCD&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt; end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# 输出结果：(&apos;A&apos;, &apos;B&apos;, &apos;C&apos;) (&apos;A&apos;, &apos;B&apos;, &apos;D&apos;) (&apos;A&apos;, &apos;C&apos;, &apos;D&apos;) (&apos;B&apos;, &apos;C&apos;, &apos;D&apos;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;4、强大的内置迭代器方法&lt;/h2&gt;
&lt;div&gt;迭代器模式的使用场景实在太普遍了，而 Python 也为迭代器的顺利使用而提供了很多便利的条件，本节将介绍相关的几个内置方法。这些方法非常常用而且强大，是 Python 进阶的必会内容。&lt;/div&gt;
&lt;h3&gt;4.1 zip() 方法&lt;/h3&gt;
&lt;div&gt;zip() 方法可以同时迭代多个序列，并各取一个元素，生成一个可返回元组的迭代器。此迭代器的长度以较短序列的长度保持一致，若想生成较长序列的长度，需要使用 itertools 模块的 zip_longest() 方法。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; itertools

a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;w&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;x&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;y&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;z&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;zip&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt;end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# (1, &apos;w&apos;) (2, &apos;x&apos;) (3, &apos;y&apos;)&lt;/span&gt;

&lt;span&gt;# 空缺值以 None 填补&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;zip_longest&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt;end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# (1, &apos;w&apos;) (2, &apos;x&apos;) (3, &apos;y&apos;) (None, &apos;z&apos;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;4.2 enumerate() 方法&lt;/h3&gt;
&lt;div&gt;enumerate() 方法接收一个序列类型参数，生成一个可返回元组的迭代器，元组内容是下标及其对应的元素值。它还可接收一个可选参数，指定下标的起始值，默认是0 。&lt;/div&gt;
&lt;div&gt;注意：众所周知，Python 中序列的索引值从 0 开始，但是，enumerate() 可以达到改变起始索引数值的效果。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;seasons &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;Spring&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;Summer&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;Fall&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;Winter&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;enumerate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;seasons&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt;end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  
&lt;span&gt;#输出结果：(0, &apos;Spring&apos;) (1, &apos;Summer&apos;) (2, &apos;Fall&apos;) (3, &apos;Winter&apos;)&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;enumerate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;seasons&lt;span&gt;,&lt;/span&gt; start&lt;span&gt;=&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt;end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  
&lt;span&gt;#输出结果：(7, &apos;Spring&apos;) (8, &apos;Summer&apos;) (9, &apos;Fall&apos;) (10, &apos;Winter&apos;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;4.3 map() 方法&lt;/h3&gt;
&lt;div&gt;map() 方法的参数是一个函数及一个或多个可迭代对象，它会将可迭代对象的元素映射到该函数中，然后迭代地运行该函数，返回结果也是一个迭代器。当存在多个可迭代对象参数时，迭代长度等于较短对象的长度。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;square&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; x &lt;span&gt;**&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;

l &lt;span&gt;=&lt;/span&gt; &lt;span&gt;map&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;square&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;l&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# 输出结果：[1, 4, 9, 16, 25]&lt;/span&gt;

m &lt;span&gt;=&lt;/span&gt; &lt;span&gt;map&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;lambda&lt;/span&gt; x&lt;span&gt;,&lt;/span&gt; y&lt;span&gt;:&lt;/span&gt; x &lt;span&gt;+&lt;/span&gt; y&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;9&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;8&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;m&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# 输出结果：[3, 7, 11, 15, 19]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h3&gt;4.4 filter() 方法&lt;/h3&gt;
&lt;div&gt;filter() 方法的参数是一个判断函数及一个可迭代对象，遍历可迭代对象执行判断函数，过滤下判断为True 的元素，与它相对，若想保留判断为 False 的元素，可使用 itertoole 模块的 filterfalse() 方法。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; itertools

fi &lt;span&gt;=&lt;/span&gt; &lt;span&gt;filter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;lambda&lt;/span&gt; x&lt;span&gt;:&lt;/span&gt; x&lt;span&gt;%&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
ff &lt;span&gt;=&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;filterfalse&lt;span&gt;(&lt;/span&gt;&lt;span&gt;lambda&lt;/span&gt; x&lt;span&gt;:&lt;/span&gt; x&lt;span&gt;%&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; fi&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt;end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# 输出结果：1 3 5 7 9&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; ff&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt;end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# 输出结果：0 2 4 6 8&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;5. 小结&lt;/h2&gt;
&lt;div&gt;迭代器模式几乎是 23 种设计模式中最常用的设计模式，本文主要介绍了 Python 是如何运用迭代器模式，并介绍了 itertools 模块生成迭代器的 18 种方法，以及 5 种生成迭代器的内置方法。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://t.cn/R6cGtfw&quot;&gt;itertools模块文档&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/DIhwoJE3o0kKw3kzZKysag&quot;&gt;Python进阶：迭代器与迭代器切片&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/IRAjR-KHZBPEEkdiofseGQ&quot;&gt;Python进阶：全面解读高级特性之切片！&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python进阶：全面解读高级特性之切片！</title>
            <link>https://pythoncat.top/posts/2018-12-31-slice/</link>
            <guid>https://pythoncat.top/posts/2018-12-31-slice/</guid>
            <pubDate>Mon, 31 Dec 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;导读：切片系列文章连续写了三篇，本文是对它们做的汇总。为什么要把序列文章合并呢？在此说明一下，本文绝不是简单地将它们做了合并，主要是修正了一些严重的错误（如自定义序列切片的部分），还对行文结构与章节衔接做了大量改动，如此一来，本文结构的完整性与内容的质量都得到了很好的保证。&lt;/div&gt;
&lt;div&gt;众所周知，我们可以通过索引值（或称下标）来查找序列类型（如字符串、列表、元组…）中的单个元素，那么，如果要获取一个索引区间的元素该怎么办呢？&lt;/div&gt;
&lt;div&gt;切片（slice）就是一种截取索引片段的技术，借助切片技术，我们可以十分灵活地处理序列类型的对象。通常来说，切片的作用就是截取序列对象，然而，对于非序列对象，我们是否有办法做到切片操作呢？在使用切片的过程中，有什么要点值得重视，又有什么底层原理值得关注呢？本文将主要跟大家一起来探讨这些内容，希望我能与你共同学习进步。&lt;/div&gt;
&lt;h2&gt;1、切片的基础用法&lt;/h2&gt;
&lt;div&gt;列表是 Python 中极为基础且重要的一种数据结构，也是最能发挥切片的用处的一种数据结构，所以在前两节，我将以列表为例介绍切片的一些常见用法。&lt;/div&gt;
&lt;div&gt;首先是切片的书写形式：[i : i+n : m] ；其中，i 是切片的起始索引值，为列表首位时可省略；i+n 是切片的结束位置，为列表末位时可省略；m 可以不提供，默认值是1，&lt;strong&gt;不允许为0&lt;/strong&gt; ，当m为负数时，列表翻转。注意：这些值都可以大于列表长度，不会报越界。&lt;/div&gt;
&lt;div&gt;切片的基本含义是：&lt;strong&gt;从序列的第i位索引起，向右取到后n位元素为止，按m间隔过滤&lt;/strong&gt; 。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;li &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;# 以下写法都可以表示整个列表，其中 X &amp;gt;= len(li)&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;X&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;X&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; 
&lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;X&lt;span&gt;:&lt;/span&gt;X&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;X&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 从1起，取5-1位元素&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 从1起，取5-1位元素，按2间隔过滤&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 取倒数第一个元素&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 从倒数第四起，取-2-(-4)=2位元素&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;li&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; 
&lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 从头开始，取-2-(-len(li))=7位元素&lt;/span&gt;

&lt;span&gt;# 步长为负数时，列表先翻转，再截取&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 翻转整个列表&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 翻转整个列表，再按2间隔过滤&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 翻转整个列表，取-5-(-len(li))=4位元素&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 翻转整个列表，取-5-(-len(li))=4位元素，再按3间隔过滤&lt;/span&gt;

&lt;span&gt;# 切片的步长不可以为0&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;  &lt;span&gt;# 报错（ValueError: slice step cannot be zero）&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上述的某些例子对于初学者（甚至很多老手）来说，可能还不好理解，但是它们都离不开切片的基本语法，所以为方便起见，我将它们也归入基础用法中。&lt;/div&gt;
&lt;div&gt;对于这些样例，我个人总结出两条经验：&lt;/div&gt;
&lt;div&gt;（1）牢牢记住公式&lt;code&gt;[i : i+n : m]&lt;/code&gt; ，当出现缺省值时，通过想象把公式补全；&lt;/div&gt;
&lt;div&gt;（2）索引为负且步长为正时，按倒数计算索引位置；索引为负且步长为负时，先翻转列表，再按倒数计算索引位置。&lt;/div&gt;
&lt;h2&gt;2、切片的高级用法&lt;/h2&gt;
&lt;div&gt;一般而言，切片操作的返回结果是一个新的独立的序列（PS：也有例外，参见《&lt;a href=&quot;https://mp.weixin.qq.com/s/PsY8Iec1EeGDKKnTNU5CNw&quot;&gt;Python是否支持复制字符串呢？&lt;/a&gt;》）。以列表为例，列表切片后得到的还是一个列表，占用新的内存地址。&lt;/div&gt;
&lt;div&gt;当取出切片的结果时，它是一个独立对象，因此，可以将其用于赋值操作，也可以用于其它传递值的场景。但是，&lt;strong&gt;切片只是浅拷贝&lt;/strong&gt; ，它拷贝的是原列表中元素的引用，所以，当存在变长对象的元素时，新列表将受制于原列表。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;li &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
ls &lt;span&gt;=&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

li &lt;span&gt;==&lt;/span&gt; ls &lt;span&gt;# True&lt;/span&gt;
&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;li&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;ls&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# False&lt;/span&gt;
li&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# [1, 2, 3, 4, [3, 4]]&lt;/span&gt;
ls&lt;span&gt;.&lt;/span&gt;extend&lt;span&gt;(&lt;/span&gt;ls&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# [1, 2, 3, 4, 3, 4]&lt;/span&gt;

&lt;span&gt;# 下例等价于判断li长度是否大于8&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;not empty&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;empty&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 切片列表受制于原列表&lt;/span&gt;
lo &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
lp &lt;span&gt;=&lt;/span&gt; lo&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [1, [1, 1]]&lt;/span&gt;
lo&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# [1, [1, 1, 1], 2, 3]&lt;/span&gt;
lp &lt;span&gt;# [1, [1, 1, 1]]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;由于可见，将切片结果取出，它可以作为独立对象使用，但是也要注意，是否取出了变长对象的元素。&lt;/div&gt;
&lt;div&gt;切片既可以作为独立对象被“取出”原序列，也可以留在原序列，作为一种占位符使用。&lt;/div&gt;
&lt;div&gt;不久前，我介绍了几种拼接字符串的方法（链接见文末），其中三种格式化类的拼接方法（即 %、format()、template）就是使用了占位符的思想。对于列表来说，使用切片作为占位符，同样能够实现拼接列表的效果。特别需要注意的是，给切片赋值的必须是可迭代对象。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;li &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;# 在头部拼接&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [0, 1, 2, 3, 4]&lt;/span&gt;
&lt;span&gt;# 在末尾拼接&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;li&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [0, 1, 2, 3, 4, 5, 7]&lt;/span&gt;
&lt;span&gt;# 在中部拼接&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [0, 1, 2, 3, 4, 5, 6, 7]&lt;/span&gt;

&lt;span&gt;# 给切片赋值的必须是可迭代对象&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;6&lt;/span&gt; &lt;span&gt;# （报错，TypeError: can only assign an iterable）&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;#  [9, 0, 1, 2, 3, 4, 5, 6, 7]&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;#  [0, 1, 2, 9, 0, 1, 2, 3, 4, 5, 6, 7]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上述例子中，若将切片作为独立对象取出，那你会发现它们都是空列表，即 &lt;code&gt;li[:0]==li[len(li):]==li[6:6]==[]&lt;/code&gt; ，我将这种占位符称为“&lt;strong&gt;纯占位符&lt;/strong&gt;”，对纯占位符赋值，并不会破坏原有的元素，只会在特定的索引位置中拼接进新的元素。删除纯占位符时，也不会影响列表中的元素。&lt;/div&gt;
&lt;div&gt;与“纯占位符”相对应，“&lt;strong&gt;非纯占位符&lt;/strong&gt;”的切片是非空列表，对它进行操作（赋值与删除），将会影响原始列表。如果说纯占位符可以实现列表的拼接，那么，非纯占位符可以实现列表的替换。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;li &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;# 不同位置的替换&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [7, 8, 9, 4]&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [7, 8, 9, 5, 6, 7]&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;b&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [7, 8, &apos;a&apos;, &apos;b&apos;, 6, 7]&lt;/span&gt;

&lt;span&gt;# 非等长替换&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [7, 8, 1, 2, 3, 4, 6, 7]&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;  &lt;span&gt;# [7, 8, &apos;a&apos;, 6, 7]&lt;/span&gt;

&lt;span&gt;# 删除元素&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [7, 8, 6, 7]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;切片占位符可以带步长，从而实现连续跨越性的替换或删除效果。需要注意的是，这种用法只支持等长替换。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;li &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;b&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;c&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [&apos;a&apos;, 2, &apos;b&apos;, 4, &apos;c&apos;, 6]&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;# [0, 2, 0, 4, 0, 6]&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;w&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 报错，attempt to assign sequence of size 1 to extended slice of size 3&lt;/span&gt;

&lt;span&gt;del&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [2, 4, 6]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;3、自定义对象实现切片功能&lt;/h2&gt;
&lt;div&gt;切片是 Python 中最迷人最强大最 Amazing 的语言特性（几乎没有之一），以上两小节虽然介绍了切片的基础用法与高级用法，但这些还不足以充分地展露切片的魅力，所以，在接下来的两章节中，我们将聚焦于它的更高级用法。&lt;/div&gt;
&lt;div&gt;前两节内容都是基于原生的序列类型（如字符串、列表、元组…），那么，我们是否可以定义自己的序列类型并让它支持切片语法呢？更进一步，我们是否可以自定义其它对象（如字典）并让它支持切片呢？&lt;/div&gt;
&lt;h3&gt;3.1、魔术方法：&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/h3&gt;
&lt;div&gt;想要使自定义对象支持切片语法并不难，只需要在定义类的时候给它实现魔术方法 &lt;code&gt;__getitem__()&lt;/code&gt; 即可。所以，这里就先介绍一下这个方法。&lt;/div&gt;
&lt;div&gt;语法： &lt;code&gt;object.__getitem__(self, key)&lt;/code&gt;&lt;/div&gt;
&lt;div&gt;官方文档释义：Called to implement evaluation of self[key]. For sequence types, the accepted keys should be integers and slice objects. Note that the special interpretation of negative indexes (if the class wishes to emulate a sequence type) is up to the &lt;code&gt;__getitem__()&lt;/code&gt; method. If key is of an inappropriate type, TypeError may be raised; if of a value outside the set of indexes for the sequence (after any special interpretation of negative values), IndexError should be raised. For mapping types, if key is missing (not in the container), KeyError should be raised.&lt;/div&gt;
&lt;div&gt;概括翻译一下：&lt;code&gt;__getitem__()&lt;/code&gt; 方法用于返回参数 key 所对应的值，这个 key 可以是整型数值和切片对象，并且支持负数索引；如果 key 不是以上两种类型，就会抛 TypeError；如果索引越界，会抛 IndexError ；如果定义的是映射类型，当 key 参数不是其对象的键值时，则会抛 KeyError 。&lt;/div&gt;
&lt;h3&gt;3.2、自定义序列实现切片功能&lt;/h3&gt;
&lt;div&gt;接下来，我们定义一个简单的 MyList ，并给它加上切片功能。（PS：仅作演示，不保证其它功能的完备性）。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; numbers

&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyList&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; anylist&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;data &lt;span&gt;=&lt;/span&gt; anylist
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__len__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; index&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;key is : &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;index&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        cls &lt;span&gt;=&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;index&lt;span&gt;,&lt;/span&gt; &lt;span&gt;slice&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;data is : &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;data&lt;span&gt;[&lt;/span&gt;index&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; cls&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;data&lt;span&gt;[&lt;/span&gt;index&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; &lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;index&lt;span&gt;,&lt;/span&gt; numbers&lt;span&gt;.&lt;/span&gt;Integral&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;data&lt;span&gt;[&lt;/span&gt;index&lt;span&gt;]&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            msg &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;{cls.__name__} indices must be integers&quot;&lt;/span&gt;
            &lt;span&gt;raise&lt;/span&gt; TypeError&lt;span&gt;(&lt;/span&gt;msg&lt;span&gt;.&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;cls&lt;span&gt;=&lt;/span&gt;cls&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

l &lt;span&gt;=&lt;/span&gt; MyList&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;My&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;name&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;is&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;Python猫&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;### 输出结果：&lt;/span&gt;
key &lt;span&gt;is&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;
Python猫
key &lt;span&gt;is&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;slice&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
data &lt;span&gt;is&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;My&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;__main__&lt;span&gt;.&lt;/span&gt;MyList &lt;span&gt;object&lt;/span&gt; at &lt;span&gt;0x0000019CD83A7A90&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
key &lt;span&gt;is&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; hi
Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
TypeError&lt;span&gt;:&lt;/span&gt; MyList indices must be integers &lt;span&gt;or&lt;/span&gt; slices&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;从输出结果来看，自定义的 MyList 既支持按索引查找，也支持切片操作，这正是我们的目的。&lt;/div&gt;
&lt;h3&gt;3.3、自定义字典实现切片功能&lt;/h3&gt;
&lt;div&gt;切片是序列类型的特性，所以在上例中，我们不需要写切片的具体实现逻辑。但是，对于其它非序列类型的自定义对象，就得自己实现切片逻辑。以自定义字典为例（PS：仅作演示，不保证其它功能的完备性）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyDict&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;data &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__len__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; item&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;data&lt;span&gt;[&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; item
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; key&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;data&lt;span&gt;[&lt;/span&gt;key&lt;span&gt;]&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;slice&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            slicedkeys &lt;span&gt;=&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;data&lt;span&gt;.&lt;/span&gt;keys&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;key&lt;span&gt;]&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;k&lt;span&gt;:&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;data&lt;span&gt;[&lt;/span&gt;k&lt;span&gt;]&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt; slicedkeys&lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;raise&lt;/span&gt; TypeError

d &lt;span&gt;=&lt;/span&gt; MyDict&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
d&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;My&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
d&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;name&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
d&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;is&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
d&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Python猫&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;d&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;d&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;d&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;d&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;hi&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;### 输出结果：&lt;/span&gt;
&lt;span&gt;is&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;My&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;My&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
TypeError&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上例的关键点在于将字典的键值取出，并对键值的列表做切片处理，其妙处在于，不用担心索引越界和负数索引，将字典切片转换成了字典键值的切片，最终实现目的。&lt;/div&gt;
&lt;h2&gt;4、迭代器实现切片功能&lt;/h2&gt;
&lt;div&gt;好了，介绍完一般的自定义对象如何实现切片功能，这里将迎来另一类非同一般的对象。&lt;/div&gt;
&lt;div&gt;迭代器是 Python 中独特的一种高级对象，它本身不具备切片功能，然而若能将它用于切片，这便仿佛是锦上添花，能达到如虎添翼的效果。所以，本节将隆重地介绍迭代器如何实现切片功能。&lt;/div&gt;
&lt;h3&gt;4.1、迭代与迭代器&lt;/h3&gt;
&lt;div&gt;首先，有几个基本概念要澄清：迭代、可迭代对象、迭代器。&lt;/div&gt;
&lt;div&gt;&lt;code&gt;迭代&lt;/code&gt; 是一种遍历容器类型对象（例如字符串、列表、字典等等）的方式，例如，我们说迭代一个字符串“abc”，指的就是从左往右依次地、逐个地取出它的全部字符的过程。（PS：汉语中迭代一词有循环反复、层层递进的意思，但 Python 中此词要理解成&lt;strong&gt;单向水平线性&lt;/strong&gt; 的，如果你不熟悉它，我建议直接将其理解为遍历。）&lt;/div&gt;
&lt;div&gt;那么，怎么写出迭代操作的指令呢？最通用的书写语法就是 for 循环。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# for循环实现迭代过程&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; char &lt;span&gt;in&lt;/span&gt; &lt;span&gt;&quot;abc&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;char&lt;span&gt;,&lt;/span&gt; end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# 输出结果：a b c&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;for 循环可以实现迭代的过程，但是，并非所有对象都可以用于 for 循环，例如，上例中若将字符串“abc”换成任意整型数字，则会报错： ‘int’ object is not iterable .&lt;/div&gt;
&lt;div&gt;这句报错中的单词“iterable”指的是“可迭代的”，即 int 类型不是可迭代的。而字符串（string）类型是可迭代的，同样地，列表、元组、字典等类型，都是可迭代的。&lt;/div&gt;
&lt;div&gt;那怎么判断一个对象是否可迭代呢？为什么它们是可迭代的呢？怎么让一个对象可迭代呢？&lt;/div&gt;
&lt;div&gt;要使一个对象可迭代，就要实现可迭代协议，即需要实现&lt;code&gt;__iter__()&lt;/code&gt; 魔术方法，换言之，只要实现了这个魔术方法的对象都是可迭代对象。&lt;/div&gt;
&lt;div&gt;那怎么判断一个对象是否实现了这个方法呢？除了上述的 for 循环外，我还知道四种方法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 方法1：dir()查看__iter__&lt;/span&gt;
&lt;span&gt;dir&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;     &lt;span&gt;# 没有，略&lt;/span&gt;
&lt;span&gt;dir&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;abc&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 有，略&lt;/span&gt;

&lt;span&gt;# 方法2：isinstance()判断&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; collections
&lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; collections&lt;span&gt;.&lt;/span&gt;Iterable&lt;span&gt;)&lt;/span&gt;     &lt;span&gt;# False&lt;/span&gt;
&lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;abc&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; collections&lt;span&gt;.&lt;/span&gt;Iterable&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# True&lt;/span&gt;

&lt;span&gt;# 方法3：hasattr()判断&lt;/span&gt;
&lt;span&gt;hasattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;__iter__&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;     &lt;span&gt;# False&lt;/span&gt;
&lt;span&gt;hasattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;abc&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;__iter__&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# True&lt;/span&gt;

&lt;span&gt;# 方法4：用iter()查看是否报错&lt;/span&gt;
&lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;     &lt;span&gt;# 报错：&apos;int&apos; object is not iterable&lt;/span&gt;
&lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;abc&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# &amp;lt;str_iterator at 0x1e2396d8f28&amp;gt;&lt;/span&gt;

&lt;span&gt;### PS：判断是否可迭代，还可以查看是否实现__getitem__，为方便描述，本文从略。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这几种方法中最值得一提的是 iter() 方法，它是 Python 的内置方法，其作用是&lt;strong&gt;将可迭代对象变成迭代器&lt;/strong&gt; 。这句话可以解析出两层意思：（1）可迭代对象跟迭代器是两种东西；（2）可迭代对象能变成迭代器。&lt;/div&gt;
&lt;div&gt;实际上，迭代器必然是可迭代对象，但可迭代对象不一定是迭代器。两者有多大的区别呢？&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;如上图蓝圈所示，普通可迭代对象与迭代器的最关键区别可概括为：&lt;strong&gt;一同两不同&lt;/strong&gt; ，所谓“一同”，即两者都是可迭代的（&lt;code&gt;__iter__&lt;/code&gt;），所谓“两不同”，即可迭代对象在转化为迭代器后，它会丢失一些属性（&lt;code&gt;__getitem__&lt;/code&gt;），同时也增加一些属性（&lt;code&gt;__next__&lt;/code&gt;）。&lt;/div&gt;
&lt;div&gt;首先看看增加的属性 &lt;code&gt;__next__&lt;/code&gt; ， 它是迭代器之所以是迭代器的关键，事实上，我们正是把同时实现了 &lt;code&gt;__iter__&lt;/code&gt; 方法 和 &lt;code&gt;__next__&lt;/code&gt; 方法的对象定义为迭代器的。&lt;/div&gt;
&lt;div&gt;有了多出来的这个属性，可迭代对象不需要借助外部的 for 循环语法，就能实现自我的迭代/遍历过程。我发明了两个概念来描述这两种遍历过程（PS：为了易理解，这里称遍历，实际也可称为迭代）：&lt;code&gt;它遍历&lt;/code&gt; 指的是通过外部语法而实现的遍历，&lt;code&gt;自遍历&lt;/code&gt; 指的是通过自身方法实现的遍历。&lt;/div&gt;
&lt;div&gt;借助这两个概念，我们说，可迭代对象就是能被“它遍历”的对象，而迭代器是在此基础上，还能做到“自遍历”的对象。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;ob1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;abc&quot;&lt;/span&gt;
ob2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;abc&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
ob3 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;abc&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# ob1它遍历&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; ob1&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt; end &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# a b c&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; ob1&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt; end &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# a b c&lt;/span&gt;
&lt;span&gt;# ob1自遍历&lt;/span&gt;
ob1&lt;span&gt;.&lt;/span&gt;__next__&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 报错： &apos;str&apos; object has no attribute &apos;__next__&apos;&lt;/span&gt;

&lt;span&gt;# ob2它遍历&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; ob2&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt; end &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# a b c    &lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; ob2&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt; end &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# 无输出&lt;/span&gt;
&lt;span&gt;# ob2自遍历&lt;/span&gt;
ob2&lt;span&gt;.&lt;/span&gt;__next__&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 报错：StopIteration&lt;/span&gt;

&lt;span&gt;# ob3自遍历&lt;/span&gt;
ob3&lt;span&gt;.&lt;/span&gt;__next__&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# a&lt;/span&gt;
ob3&lt;span&gt;.&lt;/span&gt;__next__&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# b&lt;/span&gt;
ob3&lt;span&gt;.&lt;/span&gt;__next__&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# c&lt;/span&gt;
ob3&lt;span&gt;.&lt;/span&gt;__next__&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 报错：StopIteration&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;通过上述例子可看出，迭代器的优势在于支持自遍历，同时，它的特点是单向非循环的，一旦完成遍历，再次调用就会报错。&lt;/div&gt;
&lt;div&gt;对此，我想到一个比方：普通可迭代对象就像是子弹匣，它遍历就是取出子弹，在完成操作后又装回去，所以可以反复遍历（即多次调用for循环，返回相同结果）；而迭代器就像是装载了子弹匣且不可拆卸的枪，进行它遍历或者自遍历都是发射子弹，这是消耗性的遍历，是无法复用的（即遍历会有尽头）。&lt;/div&gt;
&lt;div&gt;写了这么多，稍微小结一下：&lt;strong&gt;迭代是一种遍历元素的方式，按照实现方式划分，有外部迭代与内部迭代两种，支持外部迭代（它遍历）的对象就是可迭代对象，而同时还支持内部迭代（自遍历）的对象就是迭代器；按照消费方式划分，可分为复用型迭代与一次性迭代，普通可迭代对象是复用型的，而迭代器是一次性的。&lt;/strong&gt;&lt;/div&gt;
&lt;h3&gt;4.2、迭代器切片&lt;/h3&gt;
&lt;div&gt;前面提到了“一同两不同”，最后的不同是，普通可迭代对象在转化成迭代器的过程中会丢失一些属性，其中关键的属性是 &lt;code&gt;__getitem__&lt;/code&gt; 。在前一节中，我已经介绍了这个魔术方法，并用它实现了自定义对象的切片特性。&lt;/div&gt;
&lt;div&gt;那么问题来了：为什么迭代器不继承这个属性呢？&lt;/div&gt;
&lt;div&gt;首先，迭代器使用的是消耗型的遍历，这意味着它充满不确定性，即其长度与索引键值对是动态衰减的，所以很难 get 到它的 item ，也就不再需要 &lt;code&gt;__getitem__&lt;/code&gt; 属性了。其次，若强行给迭代器加上这个属性，这并不合理，正所谓强扭的瓜不甜…&lt;/div&gt;
&lt;div&gt;由此，新的问题来了：既然会丢失这么重要的属性（还包括其它未标识的属性），为什么还要使用迭代器呢？&lt;/div&gt;
&lt;div&gt;这个问题的答案在于，迭代器拥有不可替代的强大的有用的功能，使得 Python 要如此设计它。限于篇幅，此处不再展开，后续我会专门填坑此话题。&lt;/div&gt;
&lt;div&gt;还没完，死缠烂打的问题来了：能否令迭代器拥有这个属性呢，即令迭代器继续支持切片呢？&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;hi &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;欢迎关注公众号：Python猫&quot;&lt;/span&gt;
it &lt;span&gt;=&lt;/span&gt; &lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;hi&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 普通切片&lt;/span&gt;
hi&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# Python猫&lt;/span&gt;

&lt;span&gt;# 反例：迭代器切片&lt;/span&gt;
it&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 报错：&apos;str_iterator&apos; object is not subscriptable&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;迭代器因为缺少&lt;code&gt;__getitem__&lt;/code&gt; ，因此不能使用普通的切片语法。想要实现切片，无非两种思路：一是自己造轮子，写实现的逻辑；二是找到封装好的轮子。&lt;/div&gt;
&lt;div&gt;Python 的 itertools 模块就是我们要找的轮子，用它提供的方法可轻松实现迭代器切片。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; itertools

&lt;span&gt;# 例1：简易迭代器&lt;/span&gt;
s &lt;span&gt;=&lt;/span&gt; &lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;123456789&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;islice&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt; end &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# 输出：3 4 5 6&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;islice&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt; end &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# 输出：9&lt;/span&gt;

&lt;span&gt;# 例2：斐波那契数列迭代器&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Fib&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;yield&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;a
            self&lt;span&gt;.&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;b &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;b&lt;span&gt;,&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;a &lt;span&gt;+&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;b
f &lt;span&gt;=&lt;/span&gt; &lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Fib&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;islice&lt;span&gt;(&lt;/span&gt;f&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt; end &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 输出：2 3 5 8&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;islice&lt;span&gt;(&lt;/span&gt;f&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt; end &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 输出：34 55 89 144&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;itertools 模块的 islice() 方法将迭代器与切片完美结合，终于回答了前面的问题。然而，迭代器切片跟普通切片相比，前者有很多局限性。首先，这个方法不是“纯函数”（纯函数需遵守“相同输入得到相同输出”的原则）；其次，它只支持正向切片，且不支持负数索引，这都是由迭代器的损耗性所决定的。&lt;/div&gt;
&lt;div&gt;那么，我不禁要问：itertools 模块的切片方法用了什么实现逻辑呢？下方是官网提供的源码：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;islice&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;iterable&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;args&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;# islice(&apos;ABCDEFG&apos;, 2) --&amp;gt; A B&lt;/span&gt;
    &lt;span&gt;# islice(&apos;ABCDEFG&apos;, 2, 4) --&amp;gt; C D&lt;/span&gt;
    &lt;span&gt;# islice(&apos;ABCDEFG&apos;, 2, None) --&amp;gt; C D E F G&lt;/span&gt;
    &lt;span&gt;# islice(&apos;ABCDEFG&apos;, 0, None, 2) --&amp;gt; A C E G&lt;/span&gt;
    s &lt;span&gt;=&lt;/span&gt; &lt;span&gt;slice&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;args&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;# 索引区间是[0,sys.maxsize]，默认步长是1&lt;/span&gt;
    start&lt;span&gt;,&lt;/span&gt; stop&lt;span&gt;,&lt;/span&gt; step &lt;span&gt;=&lt;/span&gt; s&lt;span&gt;.&lt;/span&gt;start &lt;span&gt;or&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; s&lt;span&gt;.&lt;/span&gt;stop &lt;span&gt;or&lt;/span&gt; sys&lt;span&gt;.&lt;/span&gt;maxsize&lt;span&gt;,&lt;/span&gt; s&lt;span&gt;.&lt;/span&gt;step &lt;span&gt;or&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
    it &lt;span&gt;=&lt;/span&gt; &lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;start&lt;span&gt;,&lt;/span&gt; stop&lt;span&gt;,&lt;/span&gt; step&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        nexti &lt;span&gt;=&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;it&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt; StopIteration&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;# Consume *iterable* up to the *start* position.&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i&lt;span&gt;,&lt;/span&gt; element &lt;span&gt;in&lt;/span&gt; &lt;span&gt;zip&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;start&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; iterable&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;pass&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i&lt;span&gt;,&lt;/span&gt; element &lt;span&gt;in&lt;/span&gt; &lt;span&gt;enumerate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;iterable&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; i &lt;span&gt;==&lt;/span&gt; nexti&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;yield&lt;/span&gt; element
                nexti &lt;span&gt;=&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;it&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt; StopIteration&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;# Consume to *stop*.&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i&lt;span&gt;,&lt;/span&gt; element &lt;span&gt;in&lt;/span&gt; &lt;span&gt;zip&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; stop&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; iterable&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;pass&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;islice() 方法的索引方向是受限的，但它也提供了一种可能性：即允许你对一个无穷的（在系统支持范围内）迭代器进行切片的能力。这是迭代器切片最具想象力的用途场景。&lt;/div&gt;
&lt;div&gt;除此之外，迭代器切片还有一个很实在的应用场景：读取文件对象中给定行数范围的数据。&lt;/div&gt;
&lt;div&gt;我们知道，从文件中读取内容主要有两种方法（参见之前关于文件读写的文章）：read() 适合读取内容较少的情况，或者是需要一次性处理全部内容的情况；而 readlines() 适用性更广，因为它是迭代地读取内容，既减少内存压力，又方便逐行对数据处理。&lt;/div&gt;
&lt;div&gt;虽然 readlines() 有迭代读取的优势，但它是从头到尾逐行读取，若文件有几千行，而我们只想要读取少数特定行（例如第1000-1009行），那它还是效率太低了。考虑到&lt;strong&gt;文件对象天然就是迭代器&lt;/strong&gt; ，我们可以使用迭代器切片先行截取，然后再处理，如此效率将大大地提升。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# test.txt 文件内容&lt;/span&gt;
&lt;span&gt;&apos;&apos;&apos;
猫
Python猫
python is a cat.
this is the end.
&apos;&apos;&apos;&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; itertools &lt;span&gt;import&lt;/span&gt; islice
&lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;r&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;encoding&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;utf-8&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;hasattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;f&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;__next__&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 判断是否迭代器&lt;/span&gt;
    content &lt;span&gt;=&lt;/span&gt; islice&lt;span&gt;(&lt;/span&gt;f&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; content&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;line&lt;span&gt;.&lt;/span&gt;strip&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;### 输出结果：&lt;/span&gt;
&lt;span&gt;True&lt;/span&gt;
python &lt;span&gt;is&lt;/span&gt; a cat&lt;span&gt;.&lt;/span&gt;
this &lt;span&gt;is&lt;/span&gt; the end&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;本节内容较多，简单回顾一下：迭代器是一种特殊的可迭代对象，可用于它遍历与自遍历，但遍历过程是损耗型的，不具备循环复用性，因此，迭代器本身不支持切片操作；通过借助 itertools 模块，我们能实现迭代器切片，将两者的优势相结合，其主要用途在于截取大型迭代器（如无限数列、超大文件等等）的片段，实现精准的处理，从而大大地提升性能与效率。&lt;/div&gt;
&lt;h2&gt;5、小结&lt;/h2&gt;
&lt;div&gt;最后总结一下，切片是 Python 的一种高级特性，常用于截取序列类型的元素，但并不局限于此，本文主要介绍了它的基础用法、高级用法（如占位符用法）、自定义对象切片、以及迭代器切片等使用内容。除此之外，切片还有更广阔多样的使用场景，例如 Numpy 的多维切片、内存视图切片、异步迭代器切片等等，都值得我们去探索一番，今限于篇幅而无法细说，欢迎关注公众号“&lt;strong&gt;Python猫&lt;/strong&gt; ”，以后我们慢慢学习之。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://t.cn/EbzoZyp&quot;&gt;官方文档getitem用法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://t.cn/EbzSaoZ&quot;&gt;切片赋值的源码分析&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://t.cn/EbNc0ot&quot;&gt;官网itertools模块介绍&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/PsY8Iec1EeGDKKnTNU5CNw&quot;&gt;Python是否支持复制字符串呢？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/2l_erf55IMvT4Tz0AGWCUQ&quot;&gt;来自Kenneth Reitz大神的建议：避免不必要的面向对象编程&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Md07VoaULda7qnMO4ob7Ww&quot;&gt;给Python学习者的文件读写指南（含基础与进阶，建议收藏）&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Whrd6NiD4Y2Z-YSCy4XJ1w&quot;&gt;详解Python拼接字符串的七种方式&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python进阶：迭代器与迭代器切片</title>
            <link>https://pythoncat.top/posts/2018-12-30-slice/</link>
            <guid>https://pythoncat.top/posts/2018-12-30-slice/</guid>
            <pubDate>Sun, 30 Dec 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在前两篇关于 Python 切片的文章中，我们学习了切片的基础用法、高级用法、使用误区，以及自定义对象如何实现切片用法（相关链接见文末）。本文是切片系列的第三篇，主要内容是迭代器切片。&lt;/div&gt;
&lt;div&gt;迭代器是 Python 中独特的一种高级特性，而切片也是一种高级特性，两者相结合，会产生什么样的结果呢？&lt;/div&gt;
&lt;h2&gt;1、迭代与迭代器&lt;/h2&gt;
&lt;div&gt;首先，有几个基本概念要澄清：迭代、可迭代对象、迭代器。&lt;/div&gt;
&lt;div&gt;&lt;code&gt;迭代&lt;/code&gt; 是一种遍历容器类型对象（例如字符串、列表、字典等等）的方式，例如，我们说迭代一个字符串“abc”，指的就是从左往右依次地、逐个地取出它的全部字符的过程。（PS：汉语中迭代一词有循环反复、层层递进的意思，但 Python 中此词要理解成&lt;strong&gt;单向水平线性&lt;/strong&gt; 的，如果你不熟悉它，我建议直接将其理解为遍历。）&lt;/div&gt;
&lt;div&gt;那么，怎么写出迭代操作的指令呢？最通用的书写语法就是 for 循环。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# for循环实现迭代过程&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; char &lt;span&gt;in&lt;/span&gt; &lt;span&gt;&quot;abc&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;char&lt;span&gt;,&lt;/span&gt; end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;# 输出结果：a b c&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;for 循环可以实现迭代的过程，但是，并非所有对象都可以用于 for 循环，例如，上例中若将字符串“abc”换成任意整型数字，则会报错： ‘int’ object is not iterable .&lt;/div&gt;
&lt;div&gt;这句报错中的单词“iterable”指的是“可迭代的”，即 int 类型不是可迭代的。而字符串（string）类型是可迭代的，同样地，列表、元组、字典等类型，都是可迭代的。&lt;/div&gt;
&lt;div&gt;那怎么判断一个对象是否可迭代呢？为什么它们是可迭代的呢？怎么让一个对象可迭代呢？&lt;/div&gt;
&lt;div&gt;要使一个对象可迭代，就要实现可迭代协议，即需要实现&lt;code&gt;__iter__()&lt;/code&gt; 魔术方法，换言之，只要实现了这个魔术方法的对象都是可迭代对象。&lt;/div&gt;
&lt;div&gt;那怎么判断一个对象是否实现了这个方法呢？除了上述的 for 循环外，我知道还有四种方法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 方法1：dir()查看__iter__&lt;/span&gt;
&lt;span&gt;dir&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;     &lt;span&gt;# 没有，略&lt;/span&gt;
&lt;span&gt;dir&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;abc&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 有，略&lt;/span&gt;

&lt;span&gt;# 方法2：isinstance()判断&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; collections
&lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; collections&lt;span&gt;.&lt;/span&gt;Iterable&lt;span&gt;)&lt;/span&gt;     &lt;span&gt;# False&lt;/span&gt;
&lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;abc&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; collections&lt;span&gt;.&lt;/span&gt;Iterable&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# True&lt;/span&gt;

&lt;span&gt;# 方法3：hasattr()判断&lt;/span&gt;
&lt;span&gt;hasattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;__iter__&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;     &lt;span&gt;# False&lt;/span&gt;
&lt;span&gt;hasattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;abc&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;__iter__&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# True&lt;/span&gt;

&lt;span&gt;# 方法4：用iter()查看是否报错&lt;/span&gt;
&lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;     &lt;span&gt;# 报错：&apos;int&apos; object is not iterable&lt;/span&gt;
&lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;abc&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# &amp;lt;str_iterator at 0x1e2396d8f28&amp;gt;&lt;/span&gt;

&lt;span&gt;### PS：判断是否可迭代，还可以查看是否实现__getitem__，为方便描述，本文从略。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这几种方法中最值得一提的是 iter() 方法，它是 Python 的内置方法，其作用是&lt;strong&gt;将可迭代对象变成迭代器&lt;/strong&gt; 。这句话可以解析出两层意思：（1）可迭代对象跟迭代器是两种东西；（2）可迭代对象能变成迭代器。&lt;/div&gt;
&lt;div&gt;实际上，迭代器必然是可迭代对象，但可迭代对象不一定是迭代器。两者有多大的区别呢？&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;如上图蓝圈所示，普通可迭代对象与迭代器的最关键区别可概括为：&lt;strong&gt;一同两不同&lt;/strong&gt; ，所谓“一同”，即两者都是可迭代的（&lt;code&gt;__iter__&lt;/code&gt;），所谓“两不同”，即可迭代对象在转化为迭代器后，它会丢失一些属性（&lt;code&gt;__getitem__&lt;/code&gt;），同时也增加一些属性（&lt;code&gt;__next__&lt;/code&gt;）。&lt;/div&gt;
&lt;div&gt;首先看看增加的属性 &lt;code&gt;__next__&lt;/code&gt; ， 它是迭代器之所以是迭代器的关键，事实上，我们正是把同时实现了 &lt;code&gt;__iter__&lt;/code&gt; 方法 和 &lt;code&gt;__next__&lt;/code&gt; 方法的对象定义为迭代器的。&lt;/div&gt;
&lt;div&gt;有了多出来的这个属性，可迭代对象不需要借助外部的 for 循环语法，就能实现自我的迭代/遍历过程。我发明了两个概念来描述这两种遍历过程（PS：为了易理解，这里称遍历，实际也可称为迭代）：&lt;code&gt;它遍历&lt;/code&gt; 指的是通过外部语法而实现的遍历，&lt;code&gt;自遍历&lt;/code&gt; 指的是通过自身方法实现的遍历。&lt;/div&gt;
&lt;div&gt;借助这两个概念，我们说，可迭代对象就是能被“它遍历”的对象，而迭代器是在此基础上，还能做到“自遍历”的对象。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;ob1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;abc&quot;&lt;/span&gt;
ob2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;abc&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
ob3 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;abc&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# ob1它遍历&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; ob1&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt; end &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# a b c&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; ob1&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt; end &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# a b c&lt;/span&gt;
&lt;span&gt;# ob1自遍历&lt;/span&gt;
ob1&lt;span&gt;.&lt;/span&gt;__next__&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 报错： &apos;str&apos; object has no attribute &apos;__next__&apos;&lt;/span&gt;

&lt;span&gt;# ob2它遍历&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; ob2&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt; end &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# a b c    &lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; ob2&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;,&lt;/span&gt; end &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# 无输出&lt;/span&gt;
&lt;span&gt;# ob2自遍历&lt;/span&gt;
ob2&lt;span&gt;.&lt;/span&gt;__next__&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 报错：StopIteration&lt;/span&gt;

&lt;span&gt;# ob3自遍历&lt;/span&gt;
ob3&lt;span&gt;.&lt;/span&gt;__next__&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# a&lt;/span&gt;
ob3&lt;span&gt;.&lt;/span&gt;__next__&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# b&lt;/span&gt;
ob3&lt;span&gt;.&lt;/span&gt;__next__&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# c&lt;/span&gt;
ob3&lt;span&gt;.&lt;/span&gt;__next__&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 报错：StopIteration&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;通过上述例子可看出，迭代器的优势在于支持自遍历，同时，它的特点是单向非循环的，一旦完成遍历，再次调用就会报错。&lt;/div&gt;
&lt;div&gt;对此，我想到一个比方：普通可迭代对象就像是子弹匣，它遍历就是取出子弹，在完成操作后又装回去，所以可以反复遍历（即多次调用for循环，返回相同结果）；而迭代器就像是装载了子弹匣且不可拆卸的枪，进行它遍历或者自遍历都是发射子弹，这是消耗性的遍历，是无法复用的（即遍历会有尽头）。&lt;/div&gt;
&lt;div&gt;写了这么多，稍微小结一下：&lt;strong&gt;迭代是一种遍历元素的方式，按照实现方式划分，有外部迭代与内部迭代两种，支持外部迭代（它遍历）的对象就是可迭代对象，而同时还支持内部迭代（自遍历）的对象就是迭代器；按照消费方式划分，可分为复用型迭代与一次性迭代，普通可迭代对象是复用型的，而迭代器是一次性的。&lt;/strong&gt;&lt;/div&gt;
&lt;h2&gt;2、迭代器切片&lt;/h2&gt;
&lt;div&gt;前面提到了“一同两不同”，最后的不同是，普通可迭代对象在转化成迭代器的过程中会丢失一些属性，其中关键的属性是 &lt;code&gt;__getitem__&lt;/code&gt; 。在《&lt;a href=&quot;https://mp.weixin.qq.com/s/QTodsriWW_gESvmJPD1EYg&quot;&gt;Python进阶：自定义对象实现切片功能&lt;/a&gt;》中，我曾介绍了这个魔术方法，并用它实现了自定义对象的切片特性。&lt;/div&gt;
&lt;div&gt;那么问题来了：为什么迭代器不继承这个属性呢？&lt;/div&gt;
&lt;div&gt;首先，迭代器使用的是消耗型的遍历，这意味着它充满不确定性，即其长度与索引键值对是动态衰减的，所以很难 get 到它的 item ，也就不再需要 &lt;code&gt;__getitem__&lt;/code&gt; 属性了。其次，若强行给迭代器加上这个属性，这并不合理，正所谓强扭的瓜不甜…&lt;/div&gt;
&lt;div&gt;由此，新的问题来了：既然会丢失这么重要的属性（还包括其它未标识的属性），为什么还要使用迭代器呢？&lt;/div&gt;
&lt;div&gt;这个问题的答案在于，迭代器拥有不可替代的强大的有用的功能，使得 Python 要如此设计它。限于篇幅，此处不再展开，后续我会专门填坑此话题。&lt;/div&gt;
&lt;div&gt;还没完，死缠烂打的问题来了：能否令迭代器拥有这个属性呢，即令迭代器继续支持切片呢？&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;hi &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;欢迎关注公众号：Python猫&quot;&lt;/span&gt;
it &lt;span&gt;=&lt;/span&gt; &lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;hi&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 普通切片&lt;/span&gt;
hi&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# Python猫&lt;/span&gt;

&lt;span&gt;# 反例：迭代器切片&lt;/span&gt;
it&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 报错：&apos;str_iterator&apos; object is not subscriptable&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;迭代器因为缺少&lt;code&gt;__getitem__&lt;/code&gt; ，因此不能使用普通的切片语法。想要实现切片，无非两种思路：一是自己造轮子，写实现的逻辑；二是找到封装好的轮子。&lt;/div&gt;
&lt;div&gt;Python 的 itertools 模块就是我们要找的轮子，用它提供的方法可轻松实现迭代器切片。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; itertools

&lt;span&gt;# 例1：简易迭代器&lt;/span&gt;
s &lt;span&gt;=&lt;/span&gt; &lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;123456789&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;islice&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt; end &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# 输出：3 4 5 6&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;islice&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt; end &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# 输出：9&lt;/span&gt;

&lt;span&gt;# 例2：斐波那契数列迭代器&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Fib&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;yield&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;a
            self&lt;span&gt;.&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;b &lt;span&gt;=&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;b&lt;span&gt;,&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;a &lt;span&gt;+&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;b
f &lt;span&gt;=&lt;/span&gt; &lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Fib&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;islice&lt;span&gt;(&lt;/span&gt;f&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt; end &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 输出：2 3 5 8&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; itertools&lt;span&gt;.&lt;/span&gt;islice&lt;span&gt;(&lt;/span&gt;f&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt; end &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot; &quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 输出：34 55 89 144&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;itertools 模块的 islice() 方法将迭代器与切片完美结合，终于回答了前面的问题。然而，迭代器切片跟普通切片相比，前者有很多局限性。首先，这个方法不是“纯函数”（纯函数需遵守“相同输入得到相同输出”的原则，之前在《&lt;a href=&quot;https://mp.weixin.qq.com/s/2l_erf55IMvT4Tz0AGWCUQ&quot;&gt;来自Kenneth Reitz大神的建议：避免不必要的面向对象编程&lt;/a&gt;》提到过）；其次，它只支持正向切片，且不支持负数索引，这都是由迭代器的损耗性所决定的。&lt;/div&gt;
&lt;div&gt;那么，我不禁要问：itertools 模块的切片方法用了什么实现逻辑呢？下方是官网提供的源码：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;islice&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;iterable&lt;span&gt;,&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;args&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;# islice(&apos;ABCDEFG&apos;, 2) --&amp;gt; A B&lt;/span&gt;
    &lt;span&gt;# islice(&apos;ABCDEFG&apos;, 2, 4) --&amp;gt; C D&lt;/span&gt;
    &lt;span&gt;# islice(&apos;ABCDEFG&apos;, 2, None) --&amp;gt; C D E F G&lt;/span&gt;
    &lt;span&gt;# islice(&apos;ABCDEFG&apos;, 0, None, 2) --&amp;gt; A C E G&lt;/span&gt;
    s &lt;span&gt;=&lt;/span&gt; &lt;span&gt;slice&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;args&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;# 索引区间是[0,sys.maxsize]，默认步长是1&lt;/span&gt;
    start&lt;span&gt;,&lt;/span&gt; stop&lt;span&gt;,&lt;/span&gt; step &lt;span&gt;=&lt;/span&gt; s&lt;span&gt;.&lt;/span&gt;start &lt;span&gt;or&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; s&lt;span&gt;.&lt;/span&gt;stop &lt;span&gt;or&lt;/span&gt; sys&lt;span&gt;.&lt;/span&gt;maxsize&lt;span&gt;,&lt;/span&gt; s&lt;span&gt;.&lt;/span&gt;step &lt;span&gt;or&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
    it &lt;span&gt;=&lt;/span&gt; &lt;span&gt;iter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;start&lt;span&gt;,&lt;/span&gt; stop&lt;span&gt;,&lt;/span&gt; step&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        nexti &lt;span&gt;=&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;it&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt; StopIteration&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;# Consume *iterable* up to the *start* position.&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i&lt;span&gt;,&lt;/span&gt; element &lt;span&gt;in&lt;/span&gt; &lt;span&gt;zip&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;start&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; iterable&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;pass&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i&lt;span&gt;,&lt;/span&gt; element &lt;span&gt;in&lt;/span&gt; &lt;span&gt;enumerate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;iterable&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; i &lt;span&gt;==&lt;/span&gt; nexti&lt;span&gt;:&lt;/span&gt;
                &lt;span&gt;yield&lt;/span&gt; element
                nexti &lt;span&gt;=&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;it&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt; StopIteration&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;# Consume to *stop*.&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i&lt;span&gt;,&lt;/span&gt; element &lt;span&gt;in&lt;/span&gt; &lt;span&gt;zip&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; stop&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; iterable&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;pass&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;islice() 方法的索引方向是受限的，但它也提供了一种可能性：即允许你对一个无穷的（在系统支持范围内）迭代器进行切片的能力。这是迭代器切片最具想象力的用途场景。&lt;/div&gt;
&lt;div&gt;除此之外，迭代器切片还有一个很实在的应用场景：读取文件对象中给定行数范围的数据。&lt;/div&gt;
&lt;div&gt;在《&lt;a href=&quot;https://mp.weixin.qq.com/s/Md07VoaULda7qnMO4ob7Ww&quot;&gt;给Python学习者的文件读写指南（含基础与进阶，建议收藏）&lt;/a&gt;》里，我介绍了从文件中读取内容的几种方法：readline() 比较鸡肋，不咋用；read() 适合读取内容较少的情况，或者是需要一次性处理全部内容的情况；而 readlines() 用的较多，比较灵活，每次迭代读取内容，既减少内存压力，又方便逐行对数据处理。&lt;/div&gt;
&lt;div&gt;虽然 readlines() 有迭代读取的优势，但它是从头到尾逐行读取，若文件有几千行，而我们只想要读取少数特定行（例如第1000-1009行），那它还是效率太低了。考虑到&lt;strong&gt;文件对象天然就是迭代器&lt;/strong&gt; ，我们可以使用迭代器切片先行截取，然后再处理，如此效率将大大地提升。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# test.txt 文件内容&lt;/span&gt;
&lt;span&gt;&apos;&apos;&apos;
猫
Python猫
python is a cat.
this is the end.
&apos;&apos;&apos;&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; itertools &lt;span&gt;import&lt;/span&gt; islice
&lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;r&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;encoding&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;utf-8&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;hasattr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;f&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;__next__&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 判断是否迭代器&lt;/span&gt;
    content &lt;span&gt;=&lt;/span&gt; islice&lt;span&gt;(&lt;/span&gt;f&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; content&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;line&lt;span&gt;.&lt;/span&gt;strip&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;### 输出结果：&lt;/span&gt;
&lt;span&gt;True&lt;/span&gt;
python &lt;span&gt;is&lt;/span&gt; a cat&lt;span&gt;.&lt;/span&gt;
this &lt;span&gt;is&lt;/span&gt; the end&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;3、小结&lt;/h2&gt;
&lt;div&gt;好啦，今天的学习就到这，小结一下：迭代器是一种特殊的可迭代对象，可用于它遍历与自遍历，但遍历过程是损耗型的，不具备循环复用性，因此，迭代器本身不支持切片操作；通过借助 itertools 模块，我们能实现迭代器切片，将两者的优势相结合，其主要用途在于截取大型迭代器（如无限数列、超大文件等等）的片段，实现精准的处理，从而大大地提升性能与效率。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;切片系列：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;《&lt;a href=&quot;https://mp.weixin.qq.com/s/fwZnvcQ_u-fYLFeQaYkJLw&quot;&gt;Python进阶：切片的误区与高级用法&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;《&lt;a href=&quot;https://mp.weixin.qq.com/s/QTodsriWW_gESvmJPD1EYg&quot;&gt;Python进阶：自定义对象实现切片功能&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;《&lt;a href=&quot;https://docs.python.org/3.7/library/itertools.html#itertools.islice&quot;&gt;官网的itertools模块介绍&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;《&lt;a href=&quot;https://mp.weixin.qq.com/s/2l_erf55IMvT4Tz0AGWCUQ&quot;&gt;来自Kenneth Reitz大神的建议：避免不必要的面向对象编程&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;《&lt;a href=&quot;https://mp.weixin.qq.com/s/Md07VoaULda7qnMO4ob7Ww&quot;&gt;给Python学习者的文件读写指南（含基础与进阶，建议收藏）&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;2018-12-31 更新声明：切片系列文章本是分三篇写成，现已合并成一篇。合并后，修正了一些严重的错误（如自定义序列切片的部分），还对行文结构与章节衔接做了大量改动。原系列的单篇就不删除了，毕竟也是有单独成篇的作用。特此声明，请阅读改进版——《&lt;a href=&quot;https://mp.weixin.qq.com/s/IRAjR-KHZBPEEkdiofseGQ&quot;&gt;Python进阶：全面解读高级特性之切片！&lt;/a&gt;》&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python进阶：自定义对象实现切片功能</title>
            <link>https://pythoncat.top/posts/2018-12-26-slice/</link>
            <guid>https://pythoncat.top/posts/2018-12-26-slice/</guid>
            <pubDate>Wed, 26 Dec 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;切片是 Python 中最迷人最强大最 Amazing 的语言特性（几乎没有之一），在《&lt;a href=&quot;https://mp.weixin.qq.com/s/fwZnvcQ_u-fYLFeQaYkJLw&quot;&gt;Python进阶：切片的误区与高级用法&lt;/a&gt;》中，我介绍了切片的基础用法、高级用法以及一些使用误区。&lt;/div&gt;
&lt;div&gt;这些内容都是基于原生的序列类型（如字符串、列表、元组…），那么，我们是否可以定义自己的序列类型并让它支持切片语法呢？更进一步，我们是否可以自定义其它对象（如字典）并让它支持切片呢？&lt;/div&gt;
&lt;h2&gt;1、魔术方法：&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/h2&gt;
&lt;div&gt;想要使自定义对象支持切片语法并不难，只需要在定义类的时候给它实现魔术方法 &lt;code&gt;__getitem__()&lt;/code&gt; 即可。所以，这里就先介绍一下这个方法。&lt;/div&gt;
&lt;div&gt;语法： &lt;code&gt;object.__getitem__(self, key)&lt;/code&gt;&lt;/div&gt;
&lt;div&gt;官方文档释义：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Called to implement evaluation of self[key]. For sequence types, the accepted keys should be integers and slice objects. Note that the special interpretation of negative indexes (if the class wishes to emulate a sequence type) is up to the &lt;code&gt;__getitem__()&lt;/code&gt; method. If key is of an inappropriate type, TypeError may be raised; if of a value outside the set of indexes for the sequence (after any special interpretation of negative values), IndexError should be raised. For mapping types, if key is missing (not in the container), KeyError should be raised.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;概括翻译一下：&lt;code&gt;__getitem__()&lt;/code&gt; 方法用于返回参数 key 所对应的值，这个 key 可以是整型数值和切片对象，并且支持负数索引；如果 key 不是以上两种类型，就会抛 TypeError；如果索引越界，会抛 IndexError ；如果定义的是映射类型，当 key 参数不是其对象的键值时，则会抛 KeyError 。&lt;/div&gt;
&lt;h2&gt;2、自定义序列实现切片功能&lt;/h2&gt;
&lt;div&gt;接下来，我们定义一个简单的 MyList ，并给它加上切片功能。（PS：仅作演示，不保证其它功能的完备性）。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyList&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;data &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; item&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;data&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;item&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; key&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;key is : &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;data&lt;span&gt;[&lt;/span&gt;key&lt;span&gt;]&lt;/span&gt;

l &lt;span&gt;=&lt;/span&gt; MyList&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
l&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;My&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
l&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;name&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
l&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;is&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
l&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Python猫&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;l&lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;l&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;l&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;hi&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;### 输出结果：&lt;/span&gt;
key &lt;span&gt;is&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;
Python猫
key &lt;span&gt;is&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;slice&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;My&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
key &lt;span&gt;is&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; hi
Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
TypeError&lt;span&gt;:&lt;/span&gt; &lt;span&gt;list&lt;/span&gt; indices must be integers &lt;span&gt;or&lt;/span&gt; slices&lt;span&gt;,&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;
    
&lt;span&gt;#####&lt;/span&gt;
&lt;span&gt;2018&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 更新声明：本例未考虑到返回类型，严格来说并未实现切片。
在合并的文章里已做修正：https&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;mp&lt;span&gt;.&lt;/span&gt;weixin&lt;span&gt;.&lt;/span&gt;qq&lt;span&gt;.&lt;/span&gt;com&lt;span&gt;/&lt;/span&gt;s&lt;span&gt;/&lt;/span&gt;IRAjR&lt;span&gt;-&lt;/span&gt;KHZBPEEkdiofseGQ&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;从输出结果来看，自定义的 MyList 既支持按索引查找，也支持切片操作，这正是我们的目的。&lt;/div&gt;
&lt;div&gt;特别需要说明的是，此例中的 &lt;code&gt;__getitem__()&lt;/code&gt; 方法会根据不同的参数类型而实现不同的功能（取索引位值或切片值），也会妥当地处理异常，所以并不需要我们再去写繁琐的处理逻辑。&lt;/div&gt;
&lt;div&gt;网上有不少学习资料完全是在误人子弟，它们会教你区分参数的不同类型，然后写一大段代码来实现索引查找和切片语法，简直是画蛇添足。下面的就是一个代表性的错误示例：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;###略去其它代码####&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; index&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    cls &lt;span&gt;=&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;index&lt;span&gt;,&lt;/span&gt; &lt;span&gt;slice&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;  &lt;span&gt;# 如果index是个切片类型，则构造新实例&lt;/span&gt;
       &lt;span&gt;return&lt;/span&gt; cls&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;_components&lt;span&gt;[&lt;/span&gt;index&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;elif&lt;/span&gt; &lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;index&lt;span&gt;,&lt;/span&gt; numbers&lt;span&gt;.&lt;/span&gt;Integral&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;  &lt;span&gt;# 如果index是个数，则直接返回&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;_components&lt;span&gt;[&lt;/span&gt;index&lt;span&gt;]&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        msg &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;{cls.__name__} indices must be integers&quot;&lt;/span&gt;
        &lt;span&gt;raise&lt;/span&gt; TypeError&lt;span&gt;(&lt;/span&gt;msg&lt;span&gt;.&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;cls&lt;span&gt;=&lt;/span&gt;cls&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;3、自定义字典实现切片功能&lt;/h2&gt;
&lt;div&gt;切片是序列类型的特性，所以在上例中，我们不需要写切片的具体实现逻辑。但是，对于其它非序列类型的自定义对象，就得自己实现切片逻辑。以自定义字典为例（PS：仅作演示，不保证其它功能的完备性）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyDict&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;data &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__len__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; item&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;data&lt;span&gt;[&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; item
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; key&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;data&lt;span&gt;[&lt;/span&gt;key&lt;span&gt;]&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;slice&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            slicedkeys &lt;span&gt;=&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;data&lt;span&gt;.&lt;/span&gt;keys&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;key&lt;span&gt;]&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;k&lt;span&gt;:&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;data&lt;span&gt;[&lt;/span&gt;k&lt;span&gt;]&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt; slicedkeys&lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
            &lt;span&gt;raise&lt;/span&gt; TypeError

d &lt;span&gt;=&lt;/span&gt; MyDict&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
d&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;My&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
d&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;name&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
d&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;is&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
d&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Python猫&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;d&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;d&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;d&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;d&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;hi&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;### 输出结果：&lt;/span&gt;
&lt;span&gt;is&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;My&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;My&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
TypeError&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上例的关键点在于将字典的键值取出，并对键值的列表做切片处理，其妙处在于，不用担心索引越界和负数索引，将字典切片转换成了字典键值的切片，最终实现目的。&lt;/div&gt;
&lt;h2&gt;4、小结&lt;/h2&gt;
&lt;div&gt;最后小结一下：本文介绍了&lt;code&gt;__getitem__()&lt;/code&gt; 魔术方法，并用于实现自定义对象（以列表类型和字典类型为例）的切片功能，希望对你有所帮助。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;参考阅读：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/fwZnvcQ_u-fYLFeQaYkJLw&quot;&gt;Python进阶：切片的误区与高级用法&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;官方文档getitem用法：&lt;a href=&quot;http://t.cn/EbzoZyp&quot;&gt;http://t.cn/EbzoZyp&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python切片赋值源码分析：&lt;a href=&quot;http://t.cn/EbzSaoZ&quot;&gt;http://t.cn/EbzSaoZ&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;2018-12-31 更新声明：切片系列文章本是分三篇写成，现已合并成一篇。合并后，修正了一些严重的错误（如自定义序列切片的部分），还对行文结构与章节衔接做了大量改动。原系列的单篇就不删除了，毕竟也是有单独成篇的作用。特此声明，请阅读改进版—— 《&lt;a href=&quot;https://mp.weixin.qq.com/s/IRAjR-KHZBPEEkdiofseGQ&quot;&gt;Python进阶：全面解读高级特性之切片！&lt;/a&gt;》&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python进阶：切片的误区与高级用法</title>
            <link>https://pythoncat.top/posts/2018-12-23-slice/</link>
            <guid>https://pythoncat.top/posts/2018-12-23-slice/</guid>
            <pubDate>Sun, 23 Dec 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;众所周知，我们可以通过索引值（或称下标）来查找序列类型（如字符串、列表、元组…）中的单个元素，那么，如果要获取一个索引区间的元素该怎么办呢？&lt;/div&gt;
&lt;div&gt;切片（slice）就是一种截取索引片段的技术，借助切片技术，我们可以十分灵活地处理序列类型的对象。通常来说，切片的作用就是截取序列对象，然而，它还有一些使用误区与高级用法，都值得我们注意。所以，本文将主要跟大家一起来探讨这些内容，希望你能学有所获。&lt;/div&gt;
&lt;div&gt;事先声明，切片并非列表的专属操作，但因为列表最具有代表性，所以，本文仅以列表为例作探讨。&lt;/div&gt;
&lt;h2&gt;1、切片的基础用法&lt;/h2&gt;
&lt;div&gt;列表是 Python 中极为基础且重要的一种数据结构，我曾写过一篇汇总文章（链接见文末）较全面地学习过它。文中详细地总结了切片的基础用法，现在回顾一下：&lt;/div&gt;
&lt;div&gt;切片的书写形式：[i : i+n : m] ；其中，i 是切片的起始索引值，为列表首位时可省略；i+n 是切片的结束位置，为列表末位时可省略；m 可以不提供，默认值是1，&lt;strong&gt;不允许为0&lt;/strong&gt; ，当m为负数时，列表翻转。注意：这些值都可以大于列表长度，不会报越界。&lt;/div&gt;
&lt;div&gt;切片的基本含义是：&lt;strong&gt;从序列的第i位索引起，向右取到后n位元素为止，按m间隔过滤&lt;/strong&gt; 。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;li &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;# 以下写法都可以表示整个列表，其中 X &amp;gt;= len(li)&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;X&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;X&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;X&lt;span&gt;:&lt;/span&gt;X&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;X&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 从1起，取5-1位元素&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 从1起，取5-1位元素，按2间隔过滤&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 取倒数第一个元素&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 从倒数第四起，取-2-(-4)=2位元素&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;li&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 从头开始，取-2-(-len(li))=7位元素&lt;/span&gt;

&lt;span&gt;# 步长为负数时，列表先翻转，再截取&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 翻转整个列表&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 翻转整个列表，再按2间隔过滤&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 翻转整个列表，取-5-(-len(li))=4位元素&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 翻转整个列表，取-5-(-len(li))=4位元素，再按3间隔过滤&lt;/span&gt;

&lt;span&gt;# 切片的步长不可以为0&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;  &lt;span&gt;# 报错（ValueError: slice step cannot be zero）&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上述的某些例子对于初学者（甚至很多老手）来说，可能还不好理解。我个人总结出两条经验：&lt;/div&gt;
&lt;div&gt;（1）牢牢记住公式&lt;code&gt;[i : i+n : m]&lt;/code&gt; ，当出现缺省值时，通过想象把公式补全；&lt;/div&gt;
&lt;div&gt;（2）索引为负且步长为正时，按倒数计算索引位置；索引为负且步长为负时，先翻转列表，再按倒数计算索引位置。&lt;/div&gt;
&lt;h2&gt;2、切片是伪独立对象&lt;/h2&gt;
&lt;div&gt;切片操作的返回结果是一个新的独立的序列（PS：也有例外，参见《&lt;a href=&quot;https://mp.weixin.qq.com/s/PsY8Iec1EeGDKKnTNU5CNw&quot;&gt;Python是否支持复制字符串呢？&lt;/a&gt;》）。以列表为例，列表切片后得到的还是一个列表，占用新的内存地址。&lt;/div&gt;
&lt;div&gt;当取出切片的结果时，它是一个独立对象，因此，可以将其用于赋值操作，也可以用于其它传递值的场景。但是，切片只是浅拷贝，它拷贝的是原列表中元素的引用，所以，当存在变长对象的元素时，新列表将受制于原列表。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;li &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
ls &lt;span&gt;=&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

li &lt;span&gt;==&lt;/span&gt; ls &lt;span&gt;# True&lt;/span&gt;
&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;li&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;ls&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# False&lt;/span&gt;
li&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# [1, 2, 3, 4, [3, 4]]&lt;/span&gt;
ls&lt;span&gt;.&lt;/span&gt;extend&lt;span&gt;(&lt;/span&gt;ls&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# [1, 2, 3, 4, 3, 4]&lt;/span&gt;

&lt;span&gt;# 下例等价于判断li长度是否大于8&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;not empty&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;empty&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 切片列表受制于原列表&lt;/span&gt;
lo &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
lp &lt;span&gt;=&lt;/span&gt; lo&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [1, [1, 1]]&lt;/span&gt;
lo&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# [1, [1, 1, 1], 2, 3]&lt;/span&gt;
lp &lt;span&gt;# [1, [1, 1, 1]]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;由于可见，将切片结果取出，它可以作为独立对象使用，但是也要注意，是否取出了变长对象的元素。&lt;/div&gt;
&lt;h2&gt;3、切片可作为占位符&lt;/h2&gt;
&lt;div&gt;切片既可以作为独立对象被“取出”原序列，也可以留在原序列，作为一种占位符使用。&lt;/div&gt;
&lt;div&gt;在写《&lt;a href=&quot;https://mp.weixin.qq.com/s/Whrd6NiD4Y2Z-YSCy4XJ1w&quot;&gt;详解Python拼接字符串的七种方式&lt;/a&gt;》的时候，我介绍了几种拼接字符串的方法，其中三种格式化类的拼接方法（即 %、format()、template）就是使用了占位符的思想。对于列表来说，使用切片作为占位符，同样能够实现拼接列表的效果。特别需要注意的是，给切片赋值的必须是可迭代对象。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;li &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;# 在头部拼接&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [0, 1, 2, 3, 4]&lt;/span&gt;
&lt;span&gt;# 在末尾拼接&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;li&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [0, 1, 2, 3, 4, 5, 7]&lt;/span&gt;
&lt;span&gt;# 在中部拼接&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [0, 1, 2, 3, 4, 5, 6, 7]&lt;/span&gt;

&lt;span&gt;# 给切片赋值的必须是可迭代对象&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;6&lt;/span&gt; &lt;span&gt;# （报错，TypeError: can only assign an iterable）&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;#  [9, 0, 1, 2, 3, 4, 5, 6, 7]&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;#  [0, 1, 2, 9, 0, 1, 2, 3, 4, 5, 6, 7]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上述例子中，若将切片作为独立对象取出，那你会发现它们都是空列表，即 &lt;code&gt;li[:0]==li[len(li):]==li[6:6]==[]&lt;/code&gt; ，我将这种占位符称为“&lt;strong&gt;纯占位符&lt;/strong&gt;”，对纯占位符赋值，并不会破坏原有的元素，只会在特定的索引位置中拼接进新的元素。删除纯占位符时，也不会影响列表中的元素。&lt;/div&gt;
&lt;div&gt;与“纯占位符”相对应，“&lt;strong&gt;非纯占位符&lt;/strong&gt;”的切片是非空列表，对它进行操作（赋值与删除），将会影响原始列表。如果说纯占位符可以实现列表的拼接，那么，非纯占位符可以实现列表的替换。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;li &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;# 不同位置的替换&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [7, 8, 9, 4]&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [7, 8, 9, 5, 6, 7]&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;b&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [7, 8, &apos;a&apos;, &apos;b&apos;, 6, 7]&lt;/span&gt;

&lt;span&gt;# 非等长替换&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [7, 8, 1, 2, 3, 4, 6, 7]&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;  &lt;span&gt;# [7, 8, &apos;a&apos;, 6, 7]&lt;/span&gt;

&lt;span&gt;# 删除元素&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [7, 8, 6, 7]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;切片占位符可以带步长，从而实现连续跨越性的替换或删除效果。需要注意的是，这种用法只支持等长替换。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;li &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;b&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;c&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [&apos;a&apos;, 2, &apos;b&apos;, 4, &apos;c&apos;, 6]&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;# [0, 2, 0, 4, 0, 6]&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;w&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 报错，attempt to assign sequence of size 1 to extended slice of size 3&lt;/span&gt;

&lt;span&gt;del&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# [2, 4, 6]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;4、更多思考&lt;/h2&gt;
&lt;div&gt;其它编程语言是否有类似于 Python 的切片操作呢？有什么差异？&lt;/div&gt;
&lt;div&gt;我在交流群里问了这个问题，小伙伴们纷纷说 Java、Go、Ruby…在查看相关资料的时候，我发现 Go 语言的切片是挺奇怪的设计。首先，它是一种特殊类型，即对数组（array）做切片后，得到的竟然不是一个数组；其次，你可以创建和初始化一个切片，需要声明长度（len）和容量（cap）；再者，它还存在超出底层数组的界限而需要进行扩容的动态机制，这倒是跟 Python 列表的超额分配机制有一定相似性…&lt;/div&gt;
&lt;div&gt;在我看来，无论是用意，还是写法和用法，都是 Python 的切片操作更明了与好用。所以，本文就不再进行跨编程语言的比较了（唔，好吧我承认，其实是我不怎么懂其它编程语言…）&lt;/div&gt;
&lt;div&gt;最后，还有一个问题：&lt;strong&gt;Python 的切片操作有什么底层原理呢？&lt;/strong&gt; 我们是否可以自定义切片操作呢？限于篇幅，我将在下次推文中跟大家一起学习，敬请期待。&lt;/div&gt;
&lt;div&gt;2018-12-31 更新声明：切片系列文章本是分三篇写成，现已合并成一篇。合并后，修正了一些严重的错误（如自定义序列切片的部分），还对行文结构与章节衔接做了大量改动。原系列的单篇就不删除了，毕竟也是有单独成篇的作用。特此声明，请阅读改进版—— 《&lt;a href=&quot;https://mp.weixin.qq.com/s/IRAjR-KHZBPEEkdiofseGQ&quot;&gt;Python进阶：全面解读高级特性之切片！&lt;/a&gt;》&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python决策权的投票结果诞生了，“指导委员会”模式拔得头筹</title>
            <link>https://pythoncat.top/posts/2018-12-17-Python/</link>
            <guid>https://pythoncat.top/posts/2018-12-17-Python/</guid>
            <pubDate>Mon, 17 Dec 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;2018年12月17日20点，Python 治理提案的投票结果出来了，最终胜出的是 PEP-8016。&lt;/div&gt;
&lt;div&gt;在几天前，我们推文《最新进展|关于Python治理模式的投票》，已经很明白地预测了这个结果，现在得到了证实。毫无悬念。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;对于这个结果，暂时没必要多说吧。等过几天，核心开发者们应该会有下一步的计划，到时候，我会关注其后续进展以及带来的影响，再跟大家细谈。&lt;/div&gt;
&lt;div&gt;此前，我们公众号（&lt;strong&gt;Python猫&lt;/strong&gt; ）连续三篇文章介绍了本次的投票，关注到了多个维度的内容，以下仅附上相关链接，以供阅读。&lt;/div&gt;
&lt;div&gt;1、&lt;a href=&quot;http://t.cn/Eyi8D7b&quot;&gt;Python之父退位后，最高决策权花落谁家？&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python 之父退出决策层后，社区里提出了7种治理模式的提案，这些提案各有什么差异点呢？Python 核心开发者 Victor Stinner 做了详细比对，此文可以带你了解各种治理提案的异同。&lt;/div&gt;
&lt;div&gt;2、&lt;a href=&quot;http://t.cn/EygFM5Q&quot;&gt;这件正在发生的事，关乎所有的Python开发者……&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;本文主要回顾了Python 之父的退位风波、各种治理提案的提出、以及此次事件的重要意义。&lt;/div&gt;
&lt;div&gt;3、&lt;a href=&quot;http://t.cn/EUgVmuK&quot;&gt;最新进展|关于Python治理模式的投票&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;上周，投票刚进行一半，本文汇总了部分核心开发者的投票意向（主要是Python之父Guido的看法），并做了一个预测。&lt;/div&gt;
&lt;div&gt;最后，我还注意到了两个小细节：&lt;/div&gt;
&lt;div&gt;1、共 94 个投票名额，但实际有效投票只有 62 票，也就是总数的 2/3 。实话说，有这么多的无效票/弃权票，我感到很意外，毕竟，整个投票期可是整整 16 天啊！这对投票方案的实施，是否会带来不利的影响呢？&lt;/div&gt;
&lt;div&gt;2、关于投票时间。首先，投票开启的时间就比几个月前计划的延迟了，而投票结束的时间也有临时的变更——本应结束于17日中午12点，但实际却延迟到晚上8点。这段时间里，发生了什么事情呢？&lt;/div&gt;
&lt;div&gt;但愿这只是“区区小事”吧…&lt;/div&gt;
&lt;div&gt;update：&lt;/div&gt;
&lt;div&gt;12.18 更正一个错误，文中说实际结束时间是晚上8点，但刚看到&lt;a href=&quot;https://mail.python.org/pipermail/python-committers/2018-December/006479.html&quot;&gt;邮件列表&lt;/a&gt;，结束时间是12点。初步怀疑是时区显示的问题（投票结果的网站上，显示可能有误）。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 对象的空间边界：独善其身与开放包容</title>
            <link>https://pythoncat.top/posts/2018-12-15-cat3/</link>
            <guid>https://pythoncat.top/posts/2018-12-15-cat3/</guid>
            <description>睡觉是我最爱做的事——因为可以懒懒地做美梦，不用吃东西，不用跟人吵架，不用关心世界大事</description>
            <pubDate>Sat, 15 Dec 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;导读：Python猫是一只喵星来客，它爱地球的一切，特别爱优雅而无所不能的 Python。我是它的人类朋友豌豆花下猫，被授权润色与发表它的文章。如果你是第一次看到这个系列文章，那我强烈建议，请先看看它写的前两篇文章（链接见文末）,相信你一定会爱上这只神秘的哲学+极客猫的。不多说啦，一起来享用今天的“思想盛宴”吧！&lt;/div&gt;
&lt;div&gt;睡觉是我最爱做的事——因为可以懒懒地做美梦，不用吃东西，不用跟人吵架，不用关心世界大事。这是除了学 Python 与写作之外，最让我舒服的事了。所以，才刚醒来，我就又困了…&lt;/div&gt;
&lt;div&gt;刚才看到了 Python 老爹 Guido 的邮件，他说要“go back to sleep mode”，不参与正在进行的 PEP 投票了。哼，这只懒惰的老头——等等我啊，等写完这篇东西，我也要 go back to sleep mode…&lt;/div&gt;
&lt;div&gt;上回说道，我发现 Python 公民的身份竟然暗合毕达哥拉斯的哲学命题（万物皆数），真是百思不得其解。在梦里，我已经想出了答案。可是突然之间，游过来一条大蟒蛇，竟把答案吞掉了。我去找它理论，它就开始耍赖，吞自己的尾巴、屁股、肚子…最后把自己全吞下去了。唉，可怜我的答案就这么消失了。&lt;/div&gt;
&lt;div&gt;今天，我继续跟大家聊聊 Python 中跟身份密切相关的一个话题吧，那就是&lt;strong&gt;对象的边界问题&lt;/strong&gt; 。如你所知，我本来是一只猫，现在略具一些人性了，但在此转型期间却十分敏感，总能在细微之处浮想联翩，最后竟然也薄有所获，真是万幸了。希望我的分享，也能启发你收获哪怕一点点的感悟，那我就有万分的开心啦 :)&lt;/div&gt;
&lt;h2&gt;1、固定边界：自由与孤独&lt;/h2&gt;
&lt;div&gt;Python 中有一些公民向来我行我素，它们特立独行，与他人之边界划定得清清楚楚。客气的人称它们是&lt;strong&gt;定长对象&lt;/strong&gt;，或者叫&lt;strong&gt;不可变对象&lt;/strong&gt;，然而，懂得一些历史典故的人又叫它们是&lt;strong&gt;铁公鸡&lt;/strong&gt; 。这个典故出自何处呢？亏得猫猫我曾恶补过一段历史知识，知道这指的正是激进的道家弟子杨朱。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;损一毫利天下，不与也；悉天下奉一身，不取也；人人不损一毫，人人不利天下，天下治矣！ ——春秋·杨朱&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;对于定长对象，你不能为它增加元素，不能为它减少元素，不能为它修改元素，甚至不能轻易地&lt;strong&gt;复制和删除&lt;/strong&gt;它！（参见本公众号&lt;strong&gt;Python猫&lt;/strong&gt;中关于字符串的系列文章，链接见文末）&lt;/div&gt;
&lt;div&gt;这些对象自立于世，也自绝于世，你看它们长得是普普通通的，平平凡凡的，然而其灵魂却是自由自在的，其生命是富有尊严而不可侵犯的。若想与这些公民打交道，你就得依着它们的脾气，不可越雷池半步。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; t1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;Python&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;猫&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; t2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;Python&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;猫&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; t1 &lt;span&gt;is&lt;/span&gt; t2  &lt;span&gt;# 对象独立&lt;/span&gt;
&lt;span&gt;False&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; t1&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;蛇&apos;&lt;/span&gt;  &lt;span&gt;# 不可修改元素&lt;/span&gt;
TypeError  Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;
TypeError&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;tuple&apos;&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; does &lt;span&gt;not&lt;/span&gt; support item assignment&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在上一篇文章里，我们见识了 Python 世界中的“特权种族”，而特权种族无一例外地都出身于定长对象。它们是一脉相承的，其存在的合理性也是相似的，那就是便于共用内存资源，提高内存使用效率。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;上表就是定长对象的一份名单。可知，它们占据了多数。&lt;/div&gt;
&lt;div&gt;定长对象的特性让我不由地想到一种人类，它们严守自己的边界，刻板而严谨，一心只在乎份内之事，默默承担下自己的责任，追求的是内在的自由。虽然也会时常与别人打交道，但是，它们不贪图扩大自己的利益，也不妄想要侵犯别人的领土。独立的个体养成了个人的品牌，它们的不变性成就了外人能有所依赖的确定性。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; key1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;Python 猫&apos;&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; key2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;someone else&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; dict1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;key1 &lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;好人&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
 &lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;Python 猫&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;好人&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; dict2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;key2 &lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;好人&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
TypeError  Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;
TypeError&lt;span&gt;:&lt;/span&gt; unhashable &lt;span&gt;type&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;list&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Python 为了维护定长对象的独立性/确定性，在编译机制上做了不少优化，例如 Intern 机制与常量合并机制。其中的好处，我已经多次提及了。&lt;/div&gt;
&lt;div&gt;坏处也有，那就是孤独。它们的孤独不在于没有同类，而在于不能（不容易）复制自身。以字符串对象为例，你可以尝试多种多样的手段，然而到头来，却发现唯一通用的方法竟然要先把字符串“碎尸万段”，接着重新组装才行！&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;s0 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Python猫&quot;&lt;/span&gt;

&lt;span&gt;# 以下7种方法，无法复制s0字符串，id(x)==id(s0)&lt;/span&gt;
s1 &lt;span&gt;=&lt;/span&gt; s0
s2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s0&lt;span&gt;)&lt;/span&gt;
s3 &lt;span&gt;=&lt;/span&gt; s0&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
s4 &lt;span&gt;=&lt;/span&gt; s0 &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&apos;&apos;&lt;/span&gt;
s5 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;%s&apos;&lt;/span&gt; &lt;span&gt;%&lt;/span&gt; s0
s6 &lt;span&gt;=&lt;/span&gt; s0 &lt;span&gt;*&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; copy
s7 &lt;span&gt;=&lt;/span&gt; copy&lt;span&gt;.&lt;/span&gt;copy&lt;span&gt;(&lt;/span&gt;s0&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 以下方法可以复制字符串，“打碎”再重组&lt;/span&gt;
s8 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;join&lt;span&gt;(&lt;/span&gt;s0&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;哲学上有一个著名的脑洞题：假如把一个人粉碎成原子再组合，这个人还是原来的人么？这道题能令古往今来的哲学家打起架来，若是放到现今正火爆的电视节目《奇葩说》上，也能令辩手们“一本正经地胡说八道”个不休。&lt;/div&gt;
&lt;div&gt;在 Python 的世界里，不存在这种烦恼，因为判定两个对象是否相同的标准是确定的，也即是看它们的 id 是否相等。因此，借助 Python 来回答这道题，答案会是：&lt;strong&gt;如果用 join() 方法把字符串粉碎成字符再组合，新的字符串不再是原来的字符串了。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;过程很“残忍”，但总归能稍稍释缓自由个体的孤独感了吧。&lt;/div&gt;
&lt;h2&gt;2、弹性边界：开放与节制&lt;/h2&gt;
&lt;div&gt;与定长对象不同，&lt;strong&gt;变长对象/可变对象&lt;/strong&gt;信奉的是另一套哲学。&lt;/div&gt;
&lt;div&gt;它们思想开放，采取的是兼容并包的处事观，会因地制宜式伸缩边界。 以列表对象为例，它乐意接纳所有其它的对象，肯花费精力去动态规划，也不惧于拔掉身上所有的“毛”。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; l &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;Python&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;猫&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; l&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;其它猫&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# [&apos;Python&apos;,&apos;猫&apos;,&apos;其它猫&apos;]&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; l&lt;span&gt;.&lt;/span&gt;pop&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# [&apos;Python&apos;,&apos;其它猫&apos;]&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; l&lt;span&gt;.&lt;/span&gt;clear&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# []&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这些大胆的行为，在定长对象那里，都是不可想象的。在变长对象身上，你似乎能感受到一种海纳百川的风范，相比之下，定长对象的铁公鸡形象则立马显得格局忒小了。&lt;/div&gt;
&lt;div&gt;变长对象并非没有边界，相反，它们更在乎自身的边界，不惜花费大量的资源来维持动态的稳定。一旦边界确定下来，它们绝不会允许越界行为。跟某些编程语言动不动就数组越界不同，Python 不存在切片越界，因为切片操作始终被控制为边界范围之内，索引超出的部分会自动被舍弃。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; q&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;# 不允许索引越界&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; q&lt;span&gt;[&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
IndexError    Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;
IndexError&lt;span&gt;:&lt;/span&gt; &lt;span&gt;list&lt;/span&gt; index out of &lt;span&gt;range&lt;/span&gt;

&lt;span&gt;# 允许切片越界&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; q&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;   &lt;span&gt;# [3, 4, 5]&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; q&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;  &lt;span&gt;# [1, 2]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;变长对象在本质上是一种可伸缩的容器，其主要好处就是支持不断添加或者取出元素。对应到计算机硬件层面，就是不断申请或者释放内存空间。这类操作是代价昂贵的操作，为了减少开销，Python 聪明地设计了一套&lt;strong&gt;分配超额空间的机制&lt;/strong&gt;。&lt;/div&gt;
&lt;div&gt;以列表为例，在内存足够的前提下，最初创建列表时不分配超额空间，第一次 append() 扩充列表时，Python 会根据下列公式分配超额空间，即分配大于列表实际元素个数的内存空间，此后，每次扩充操作先看是否有超额空间，有则直接使用，没有则重新计算，再次分配一个超额空间。&lt;/div&gt;
&lt;div&gt;公式如下：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;new_allocated = (newsize &amp;gt;&amp;gt; 3) + (newsize &amp;lt; 9 ? 3 : 6)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;其中，new_allocated  指的是超额分配的内存大小，newsize  是扩充元素后的实际长度。&lt;/div&gt;
&lt;div&gt;举例来说，一个长度为 4 的列表，append() 增加一个元素，此时实际长度为 5（即 newsize  为5），但是，Python 不会只给它分配 5 个内存空间，而是计算后给它超额分配 new_allocated  == 3 个内存大小，所以最终加起来，该列表的元素实际占用的内存空间就是 8 。&lt;/div&gt;
&lt;div&gt;如此一来，当列表再次扩充时，只要最终长度不大于 8 ，就不需要再申请新的内存空间。当扩充后长度等于 9 时，new_allocated  等于 7 ，即额外获得 7 个内存大小，以此类推。&lt;/div&gt;
&lt;div&gt;以列表长度为横轴，以超额分配的内存大小为纵轴，我们就得到了如下美妙的图表：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;超额分配的空间就是定长对象的&lt;strong&gt;软边界&lt;/strong&gt; ，这意味着它们在扩张时是有法度的，意味着它们在发展时是有大胆计划与适度节制的。如此看来，与定长对象的“固步自封”相比，变长对象就显得既开明又理智了。&lt;/div&gt;
&lt;h2&gt;3、结语&lt;/h2&gt;
&lt;div&gt;回头看前面提到的定长对象，我佩服它们独善其身的个性，虽然铁公鸡形象略显小气，但对人却无害，反而你能感受到其浓浓的 “富贵不能淫，贫贱不能移，威武不能屈” 的大丈夫气度。&lt;/div&gt;
&lt;div&gt;再看变长对象，它们“本来无一物”，却能包容万物，对他人信任，对外部开放，更难得的是，它们张弛有度，孕生出的是无限的可能性。&lt;/div&gt;
&lt;div&gt;这两种对象极大地满足了我对于 Python 世界的好奇心，也成为了我理解自己和人类世界的一种参照系。妙哉！妙哉！若你问，我更钦佩哪一类？喵呜，肚子有点饿啦，且容我去觅得一二小鱼干，喂饱肚子再说吧…&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>最新进展：关于 Python 治理模式的投票</title>
            <link>https://pythoncat.top/posts/2018-12-09-Python/</link>
            <guid>https://pythoncat.top/posts/2018-12-09-Python/</guid>
            <pubDate>Sun, 09 Dec 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;后 Guido 时代，Python 社区的治理问题成为万众瞩目的问题（国内开发者似乎比较淡定…）。目前，关于 7 种治理模式的投票，已经进行到了一半，事情进展得是否顺利呢？核心开发者们对这些候选提案是什么看法呢，我们能否预测出最终的投票结果呢？&lt;/div&gt;
&lt;div&gt;我对这些话题非常感兴趣，此前翻译了一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/vyx61e9GiiTnmaVzTYOcmw&quot;&gt;Python之父退位后，最高决策权花落谁家？&lt;/a&gt;》，介绍了 7 种治理提案的差异，还写了一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/gl8grRlvZ9ylWRdXTWUXow&quot;&gt;这件正在发生的事，关乎所有的Python开发者……&lt;/a&gt;》，介绍此次投票的前因与重要意义。至于本文，我整理了部分核心开发者的讨论内容，带领大家一窥此次重大投票的幕后，了解核心开发者的投票意向，最后，则是做了一个小小的预测。&lt;/div&gt;
&lt;h2&gt;1. Guido现身说了什么？&lt;/h2&gt;
&lt;div&gt;在提出与讨论这些治理提案期间，Guido 一直保持沉默，现如今，当投票环节正式开启后，他也终于现身了。&lt;/div&gt;
&lt;div&gt;他提出了什么问题？表达了什么观点？以下内容整理自他的几次回帖。&lt;/div&gt;
&lt;div&gt;（1）为某个/些 PEP 拉票，是否 OK？（注：他想发表对于某些 PEP 的看法，以及自己的投票建议，故询问此做法是否 OK ？）&lt;/div&gt;
&lt;div&gt;（2）对投票系统的讨论，我不感兴趣，而对每个治理提案的细节的讨论又太吵闹（too high volume），所以我躲开了，只到现在才有空读/浏览完所有的提案。我希望大家不要因为我赞同哪个 PEP 而感到压迫，但我也希望大家是真正地想知道我偏向哪个 PEP。&lt;/div&gt;
&lt;div&gt;（3）我不放心那些想把 PEP 流程固定死的治理提案，所以首选的提案就只剩下 8016 （指导委员会）和 8011 （三巨头）了。&lt;/div&gt;
&lt;div&gt;（4）我不喜欢在初始的提案文档里就面面俱到，治理模型的结构应该要不易改变，而实施过程中的事情不能不易改变。（注：此话赞同了某核心开发者，后者提到 8016 通过选出委员会来决定如何行事）。&lt;/div&gt;
&lt;div&gt;（5）对于引入外部投票，我表示要警惕。几个月前，Victor 提交 PR 来修改某些带政治意味的措辞，很多种族主义者跑来投反对意见，当修改被合入后，他们就抗议。我意识到 PEP-8014 有相应机制来应对这种事，但我个人宁愿不要邀请外人来参与我们的选举。&lt;/div&gt;
&lt;div&gt;Guido 表示他将要详细写出对每个治理提案的看法，但从几次对话中已经能看出，他最偏向于 PEP-8016。他的意见得到了一些认可，核心开发者 Paul Moore 就表示，我们无法预知未来会发生的所有事情，因此就要求治理提案能够灵活地应对各种变化。&lt;/div&gt;
&lt;div&gt;不过，Guido 还表示，他不会参与投票了。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;有开发者劝他重新考虑。就看在剩下的几天里，他会不会改变主意了。&lt;/div&gt;
&lt;h2&gt;2. 其它开发者的看法？&lt;/h2&gt;
&lt;div&gt;由于不知道核心开发者的确切数量，不清楚投票的总体进展，我只能根据网站（&lt;a href=&quot;https://discuss.python.org&quot;&gt;https://discuss.python.org&lt;/a&gt; ）上的相关话题，来做小样本的分析了。&lt;/div&gt;
&lt;div&gt;在“哪个治理提案是你最喜欢的”话题下，共有 13 名核心开发者参与了讨论。在模拟投票中，有 10 人参与投票（每人最多投 3 票），结果显示，PEP-8016 获得8票，遥遥领先，紧随其后的是 PEP-8012 和 PEP-8015，各得到了 4 票。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;值得注意的是，这个结果在 Guido 现身前就定型了，如此看来，PEP-8016 无疑是最受人青睐的。&lt;/div&gt;
&lt;div&gt;国内开发者关注于此话题的人比较少，从唯二发起过模拟投票的公众号 （&lt;strong&gt;Python猫&lt;/strong&gt; 与 &lt;strong&gt;编程派&lt;/strong&gt; ）的数据来看，总计 187 人参与投票，得票最高的前三名为：PEP-8010（52票，占比 28%），PEP-8015（40票，占比21%），PEP-8011（36票，占比19%）。（PS：需要说明的是，我们都无法参与官方投票，公众号中的模拟投票仅仅是一份娱乐性的民意调查。）&lt;/div&gt;
&lt;div&gt;然而，对比核心开发者与“边缘开发者”发起的投票，两者的差异之大，颇值得玩味。为什么有这么大的差异呢？&lt;/div&gt;
&lt;div&gt;在我们发起的“民意调查”中获得最高票的 PEP-8010，在核心开发者中并不怎么受欢迎。比如，在 Antoine Pitrou 看来，PEP-8010 就是他最不放心的提案，他不指名地说有两个人会竞选 BDFL，但是，其中一个心善却不一定能处理好多方压力，另一个则是争议性人物，若他当选 BDFL 则会成为“宣战的原因”（a casus belli）。&lt;/div&gt;
&lt;div&gt;另一名核心开发者 Nathaniel J. Smith 也非常反对 PEP-8010，他以自己在一些小项目中担任 BDFL 的亲身经历，来说明被选成 BDFL 是多么“艰难和恐怖”（incredibly hard and scary），还为此打了个夸张的比方：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;With PEP 8010 I feel like we’re trying to decide who to fly a 747, by voting, and none of the candidates have a pilot’s license。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;由此可以看出，核心开发者在给治理提案投票的时候，不仅仅会考虑到提案本身，更重要的是，他们还考虑到由谁来落实新的治理提案。这就是“局中人”的视角了吧，跟我们这些“边缘人”的视角确实很不一样。这很好地解释了，为什么两份模拟投票会得到截然不同的结果。&lt;/div&gt;
&lt;div&gt;明白了这一层逻辑，等到最终投票结果出来的时候，大家也许就不会感到太惊讶了吧。&lt;/div&gt;
&lt;div&gt;那么，哪种治理提案最可能被选中呢？我在此预测，最终胜出的治理提案是…&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>这件正在发生的事，关乎所有的Python开发者......</title>
            <link>https://pythoncat.top/posts/2018-12-05-Guido/</link>
            <guid>https://pythoncat.top/posts/2018-12-05-Guido/</guid>
            <description>Python 到了而立之年，终于，要迎来一个重大的转折点了</description>
            <pubDate>Wed, 05 Dec 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;毫不夸张地说，Python 历史上的第二大事件正在发生，它事关所有的 Python 开发者，而且将深远地影响着未来的 Python 生态。这件事并不是指 Python 之父 Guido van Rossum 退出决策层，而是指由此引发的&lt;strong&gt;新的决策层级的建立&lt;/strong&gt; 。&lt;/div&gt;
&lt;div&gt;Python 诞生于 1989 年圣诞节期间，这无疑是其历史上的第一大事件。如今，按中国古人的说法，Python 到了而立之年，终于，要迎来一个重大的转折点了。30 年前，那叫新生，今天呢，乐观的结果会是重生，而悲观的结果则是…（别想了，不会发生的 :) ）&lt;/div&gt;
&lt;div&gt;为了照顾一些信息不灵通的读者，我先给大家回顾一下“前因”（资深的 Pythonista 请直接翻到第二节）。&lt;/div&gt;
&lt;h2&gt;1. Python之父的退位风波&lt;/h2&gt;
&lt;div&gt;作为 Python 的创始人以及重要的核心开发者，Guido van Rossum 一直享有至高的权力，被人称为“终身仁慈独裁者”。实际上，这个称呼不是 Python 社区独有的，有些开源组织的创始人也被其“门徒”这么称呼，例如Linux、Ubuntu、Perl 和 Scala 等。&lt;/div&gt;
&lt;div&gt;这种赋予创始人至高裁决权力的做法，是一种明智的行为，可以保障一门新的编程语言顺利度过早期的艰难岁月，走上健康发展的道路。Python 之所以能从籍籍无名到如今近乎“呼风唤雨”，可以说，Python 之父是居功至伟。&lt;/div&gt;
&lt;div&gt;然而，这种局面总归要被打破，就看是以什么方式了。今年上半年，社区提出了备受争议的 PEP-572 （赋值表达式，文末附了知乎链接），虽然，GUIDO 行使最终裁决权，批准了这个提案，但是，争议并没有平息。部分核心开发者的不信任与离开，还有社交媒体上伤人的话语，极大地刺激了 GUIDO ，直接导致他宣布退出决策层。平衡的局面被打破了，而且是以不那么友好的方式。&lt;/div&gt;
&lt;div&gt;GUIDO 没有指定继任者，完全把问题抛给了核心开发者们：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;那你们会怎么做呢？建立一套民主制度？无政府状态？还是专政？或是联邦制？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;他退位的消息提得太突然，Python 的核心开发者们陷入了长达几个月的混乱中。仅从一些公开消息的蛛丝马迹中，我们就能看出来。&lt;/div&gt;
&lt;div&gt;在 InfoWorld 的一篇采访稿（7月27日，链接见文末）中，GUIDO 透露：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;他们已经同意给出提案的截止日期是2018年10月1日。我相信，到2018年11月1日，他们会选出一个合理的管理提案。到2019年1月1日，他们承诺会完成选举或任命负责人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;然而，这个进展并不那么顺利。下面是 7 种治理方案的 PEP 创建时间：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;PEP-8010：2018-8-24
PEP-8011：2018-8-24
PEP-8012：2018-10-03
PEP-8013：2018-09-14
PEP-8014：2018-09-16
PEP-8015：2018-10-04
PEP-8016：2018-11-01&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;备选方案的数量之多，本身就反映出核心开发者之间意见分歧之大，而发布时间的间隔之长，其背后隐含的信息也是让人不容乐观。&lt;/div&gt;
&lt;div&gt;随着进入今年最后一个月，核心开发者们不得不进入下一个议程，那就是投票。投票时间为期两周，从 12 月 1 日至 12 月 16 日。最终结果将在 12 月 17 日公布。&lt;/div&gt;
&lt;h2&gt;2.什么治理方案最合适？&lt;/h2&gt;
&lt;div&gt;以上，就是 Python 之父的退位风波。到了今天，风波并未平息，但是，这个投票的结果将直接决定风波的走向。我们都是见证者。&lt;/div&gt;
&lt;div&gt;在上一篇推文《&lt;a href=&quot;https://mp.weixin.qq.com/s/vyx61e9GiiTnmaVzTYOcmw&quot;&gt;Python之父退位后，最高决策权花落谁家？&lt;/a&gt;》中，核心开发者之一 Victor Stinner 对 7 种备选方案做了全面的对比。由于他本人是 PEP-8015 的提出人，所以文章中明显带入了一些个人倾向。读者们可以根据我翻译的版本，先粗略了解一下，然后找具体的 PEP 阅读。&lt;/div&gt;
&lt;div&gt;一千个读者，就有一千个哈姆雷特。如果你有投票权，你会投给哪种方案呢？为什么呢？在本文（公众号 &lt;strong&gt;Python猫&lt;/strong&gt;  ）末尾，我发起了一个投票，欢迎你去投票。&lt;/div&gt;
&lt;div&gt;在我看来，无论哪种方案胜出，都不会是一个皆大欢喜的结果。理由很简单，决策权的争议大于 PEP-572 的争议，后者能令核心开发者愤而出走，前者更是可以。短期内，大家或许会相安无事，但不用多久，很可能就会有新的 PEP 作为导火索，给开发团队带来更大的不可调和的麻烦。&lt;/div&gt;
&lt;div&gt;这种情况绝对无法避免，唯一的问题在于，哪种方案能将平衡状态维持得更久一点，哪种方案能更有效地调和新的矛盾？&lt;/div&gt;
&lt;div&gt;有读者回复说，我们又没有投票权，这跟我们没关系，不用瞎操心。真的是这样么？我怀疑他没听说过什么叫&lt;code&gt;蝴蝶效应&lt;/code&gt; 。特朗普当选美国总统的时候，很多人就有事不关己的想法，然而，到今天，全球局势、国内股市和就业形势，全都笼罩在这只蝴蝶的余风中动荡着。&lt;/div&gt;
&lt;div&gt;也许，Python 社区的蝴蝶效应不会那么严重，毕竟，搞技术的极客们可不是政治家。但是，我劝有些同学不要毫不在意，至少，你该对自己的立身之技的未来，多留份心。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 之父退位后，最高决策权花落谁家？</title>
            <link>https://pythoncat.top/posts/2018-12-02-Guido/</link>
            <guid>https://pythoncat.top/posts/2018-12-02-Guido/</guid>
            <description>比较社区的几个治理提案</description>
            <pubDate>Sun, 02 Dec 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;随着 Python 之父 Guido van Rossum 逐步卸任 BDFL，Python （本文特指CPython）的未来之路牵动了万千开发者的心。目前，Python 社区共提出了 7 种治理方案，其最终胜出者，将决定 Python 未来的发展方向和方式。此话题事关重大，任何 Python 开发者最好都有所了解。Python 的核心开发者之一、PEP-8015 的作者 Victor Stinner 对这 7 个治理提案做了全面的对比，我将其翻译如下：&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;原文&lt;/strong&gt; ：&lt;a href=&quot;https://discuss.python.org/t/comparison-of-the-7-governance-peps/392&quot;&gt;http://t.cn/EyhQd3b&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;作者&lt;/strong&gt; ：&lt;a href=&quot;https://twitter.com/VictorStinner&quot;&gt;Victor Stinner&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;题目&lt;/strong&gt;： Comparison of the 7 governance PEPs&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译者&lt;/strong&gt; ：&lt;a href=&quot;https://zhuanlan.zhihu.com/pythonCat&quot;&gt;豌豆花下猫&lt;/a&gt;（&lt;strong&gt;Python猫&lt;/strong&gt; 公众号作者）&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;备注&lt;/strong&gt; ：原文发布于11月6日，翻译基于11月27日版本&lt;/div&gt;
&lt;div&gt;对几个治理提案（governance PEPs）的重要差异点，我做了一份比较。我选择忽略了一些不太重要的方面，比如专门的投票组织（详见每个PEP）。提取信息并总结它，这不是一件容易的事，所以我可能会出错。&lt;/div&gt;
&lt;div&gt;我建议在给治理提案投票时，不要以它们的完整性来评判，而要聚焦其关于决策过程的部分，即谁能拍板做决策，以及怎么做？依我之见，那些还不够完整的 PEP 可以吸收其它 PEP 的创意（best ideas），来逐渐完善自身。&lt;/div&gt;
&lt;h2&gt;PEPs&lt;/h2&gt;
&lt;div&gt;来自 &lt;a href=&quot;https://www.python.org/dev/peps/pep-8000/&quot;&gt;PEP 8000&lt;/a&gt;:&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-8010&quot;&gt;PEP 8010&lt;/a&gt; - 技术领导人治理模式（The Technical Leader Governance Model）&lt;/p&gt;
&lt;p&gt;维持现状（continue status quo (ish)）&lt;/p&gt;
&lt;p&gt;提案人: Barry Warsaw&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-8011&quot;&gt;PEP 8011&lt;/a&gt; - 三巨头治理模式（Python Governance Model Lead by Trio of Pythonistas）&lt;/p&gt;
&lt;p&gt;类似现状，但三人决策&lt;/p&gt;
&lt;p&gt;提案人: Mariatta Wijaya, Barry Warsaw&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-8012&quot;&gt;PEP 8012&lt;/a&gt; - 社区治理模式（The Community Governance Model）&lt;/p&gt;
&lt;p&gt;没有核心决策人&lt;/p&gt;
&lt;p&gt;提案人: Łukasz Langa&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-8013&quot;&gt;PEP 8013&lt;/a&gt; - 外部治理模式（The External Governance Model）&lt;/p&gt;
&lt;p&gt;非核心监督（non-core oversight）&lt;/p&gt;
&lt;p&gt;提案人: Steve Dower&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-8014&quot;&gt;PEP 8014&lt;/a&gt; - 大众治理模式（The Commons Governance Model）&lt;/p&gt;
&lt;p&gt;核心监督（core oversight）&lt;/p&gt;
&lt;p&gt;提案人: Jack Jansen&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-8015&quot;&gt;PEP 8015&lt;/a&gt; - Python社区的组织模式（Organization of the Python community）&lt;/p&gt;
&lt;p&gt;将多数决策交给团队（push most decision-making to teams）&lt;/p&gt;
&lt;p&gt;提案人: Victor Stinner&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-8016&quot;&gt;PEP 8016&lt;/a&gt; - 指导委员会模式（The Steering Council Model）&lt;/p&gt;
&lt;p&gt;引导治理的迭代（bootstrap iterating on governance）&lt;/p&gt;
&lt;p&gt;提案人: Nathaniel J. Smith, Donald Stufft&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;差异点&lt;/h2&gt;
&lt;div&gt;大多数 PEP 都有一个“最高决策层”（top of the hierarchy）（指导委员会，理事会，三巨头，GUIDO，等等），除了 PEP-8012 和 PEP-8014。&lt;/div&gt;
&lt;div&gt;PEP 8011、8012 和 8015 定义了明确会参与决策过程的“工作组”（或“专家”或“Python 团队”），这可以视为第二级的决策层。&lt;/div&gt;
&lt;div&gt;PEP 8014 允许所有人（任意 Python 用户）参与投票。PEP 8013 将核心开发者排除在决策委员会之外。除了这两个特例，其它所有的 PEP 中的决策过程都强依赖（strongly around）于核心开发者（候选人必须是核心开发者、只有核心开发者可以投票，等等）。&lt;/div&gt;
&lt;div&gt;PEP 8010、8012、8013、8014 和 8016 提出了&lt;strong&gt;不信任投票&lt;/strong&gt; （No Confidence Vote）（译注：即弹劾，可将任期内的“执政人员”赶下台）。我不确定其它 PEP 若不包含这点，是否深思熟虑（deliberate）。我喜欢这个提议，所以，会把它加入到我提出的 PEP-8015 里 :)&lt;/div&gt;
&lt;div&gt;PEP 8015 和 8016 严格限定了在委员会里，只允许少于 50% 的成员是企业（5人委员会里最多有2个）。其它 PEP 不设限制。&lt;/div&gt;
&lt;div&gt;有些 PEP（8010、8011 和 8014） 里几乎只关注于定义最高决策层，然而其它 PEP（8015 和 8016）还关注到核心开发者的选举/淘汰（eject）、如何更新治理提案，等等。我不知道前者是故意为之，还是因为时间不足而来不及完善。&lt;/div&gt;
&lt;div&gt;PEP 8011、8014 和 8015 提到了多样性（译注：即决策层成员的多样性，如女性开发者），但却没有提到如何“促进”（enforce）多样性的详细规则。PEP-8011 说道：“尽全力去接纳弱势群体”（take every effort into including members from underrepresented group into consideration）。&lt;/div&gt;
&lt;h2&gt;最高决策层&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;PEP-8012 明确地避免它&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PEP-8014 有一个长老会（Council of Elders），负责决定如何及何时批准 PEP，决定是基于对所有人开放的投票（详见下文关于 PEP 流程的部分）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;其它 PEP 称之为技术领导人（Technical Leader），三巨头（Trio），理事会（Council）, 指导委员会（Steering Committee）, 等等。&lt;/div&gt;
&lt;h2&gt;成员人数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;PEP 8010: 4 = 1 (领导人) + 3 (理事会)&lt;/li&gt;
&lt;li&gt;PEP 8011: 3 (“trio”) + 工作组&lt;/li&gt;
&lt;li&gt;PEP 8012: N/A (无领导，专家团队自治)&lt;/li&gt;
&lt;li&gt;PEP 8013: 2-4 (含 1 名“主席”)&lt;/li&gt;
&lt;li&gt;PEP 8014: 5-10 (理事会)&lt;/li&gt;
&lt;li&gt;PEP 8015: 5 (委员会) + Python 团队&lt;/li&gt;
&lt;li&gt;PEP 8016: 5 (委员会) (+ 其它团队/多委员会/代表，等等。据需求而定)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;候选人&lt;/h2&gt;
&lt;div&gt;候选人的条件要求：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;PEP 8010：核心开发者&lt;/li&gt;
&lt;li&gt;PEP 8011：核心开发者、 PSF 的投票成员、三巨头、尽全力去接纳弱势群体&lt;/li&gt;
&lt;li&gt;PEP 8012：N/A&lt;/li&gt;
&lt;li&gt;PEP 8013：决不能是核心开发者&lt;/li&gt;
&lt;li&gt;PEP 8014：不要求是核心开发者、“最好是多元化的委员会”、“成员应了解 Python 与 Python 社区”&lt;/li&gt;
&lt;li&gt;PEP 8015：核心开发者、 最多 2 名企业成员&lt;/li&gt;
&lt;li&gt;PEP 8016：由核心开发者提名、 最多 2 名企业成员&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;选举&lt;/h2&gt;
&lt;div&gt;谁投票，怎么投？&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;PEP 8010：核心开发者&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PEP 8011：(现役的) 核心开发者&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PEP 8012：N/A&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PEP 8013：核心开发者；当出现平局，主席可再投一票&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PEP 8014：投票对所有人开放（无需是核心开发者）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PEP 8015：核心开发者； 若平局则进行二次投票，若二次投票还是平局，则由 PSF 董事会（用于创建委员会，以及指导委员会） 做选择&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PEP 8016：核心开发者；“若出现平局，可由候选人协商解决，要不然就随机选择”&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;##任期长度与限制&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;PEP 8010：4. 5 年 (领导人, 3 个 Python 版本); 3 年一届 (委员会)&lt;/li&gt;
&lt;li&gt;PEP 8011：5 年&lt;/li&gt;
&lt;li&gt;PEP 8012：N/A&lt;/li&gt;
&lt;li&gt;PEP 8013：1 个 Python 版本, 无任期限制（译注：即可连任）&lt;/li&gt;
&lt;li&gt;PEP 8014：“因为理事会的权力纯粹是程序性的，最好是让成员的服务时间长一点。但是，如果可以定期更新（reinstate）理事会，这也挺好”&lt;/li&gt;
&lt;li&gt;PEP 8015：3 年，轮换选举 (每年更换1/3)，无任期限制&lt;/li&gt;
&lt;li&gt;PEP 8016：1 个 Python 版本,  无任期限制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;不信任投票&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;PEP 8010：可用于驱逐（evict）领导人，理事会一致决定时发起, 由全体核心开发者进行多数决议（未明确多数决议的阈值）&lt;/li&gt;
&lt;li&gt;PEP 8011：N/A&lt;/li&gt;
&lt;li&gt;PEP 8012：N/A&lt;/li&gt;
&lt;li&gt;PEP 8013：投票需要大于2/3票数，针对单个理事会成员&lt;/li&gt;
&lt;li&gt;PEP 8014：1 名长老、或者 10 名核心开发者的团体、或者 PSF 投票成员，可以申请即时生效的投票，针对整个理事会&lt;/li&gt;
&lt;li&gt;PEP 8015：N/A&lt;/li&gt;
&lt;li&gt;PEP 8016：投票需要2/3票数，针对单个成员或整个委员会&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;团队/专家&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;PEP 8010：对单个 PEP，“GUIDO 与 CoP（译注：即 The Council of Pythonistas，智囊团，为GUIDO提供参谋意见） 协商，确定专家人选”&lt;/li&gt;
&lt;li&gt;PEP 8011：工作组 (3-5 人)，给三巨头提建议，无需是核心开发者&lt;/li&gt;
&lt;li&gt;PEP 8012：专家自组织成特定兴趣领域的子团队。这避免了大多数投票和“委员会设计”。解散某个专家团队时，需要大于2/3票数。&lt;/li&gt;
&lt;li&gt;PEP 8013：N/A&lt;/li&gt;
&lt;li&gt;PEP 8014：N/A&lt;/li&gt;
&lt;li&gt;PEP 8015：自组织式的 Python 团队，委员会可允许他们批准自己的 PEP （打包团队（Packaging Team）），核心开发者和贡献者&lt;/li&gt;
&lt;li&gt;PEP 8016：N/A&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;PEP 流程&lt;/h2&gt;
&lt;div&gt;概括得最差的部分（译注：作者自嘲？），复查每个 PEP&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;PEP 8010：PEP 代表，GUIDO是 PEP 决策的最终权威&lt;/li&gt;
&lt;li&gt;PEP 8011：三巨头和/或工作组？&lt;/li&gt;
&lt;li&gt;PEP 8012：遵照现行的 PEP 流程。提案人确定 PEP 的选题方向。提案人负责收集与整合反馈（来自整个社区）。然后，相关领域的专家们汇总全部讨论，并开启为期 14 天的最终评审，其评审结果不再需要社区性的投票。如果一个 PEP 很有争议，任何专家成员都可发起动议（motion）来拒绝通过它（需2/3票数）&lt;/li&gt;
&lt;li&gt;PEP 8013：如果理事会不否决，PEP 自动被批准&lt;/li&gt;
&lt;li&gt;PEP 8014：投票对所有 Python 使用者开放（不仅仅是核心开发者）。理事会宣布投票结果是否足以作出决定。它提出了一个决定。如果理事会采纳了一个上诉（appeal），则获得多数票的一方需做出论证（demonstrated）&lt;/li&gt;
&lt;li&gt;PEP 8015：委员会在 PEP 代表（一般来自 Python 团队）之间做选择，或者交给核心开发者投票，需大于2/3票数&lt;/li&gt;
&lt;li&gt;PEP 8016：理事会在必要时可直接地批准/否决 PEP，但最好是设置流程来避免这样做决策（例如，将决策权委派给团队或者 BDFL 代表）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;核心开发者&lt;/h2&gt;
&lt;div&gt;晋升&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;PEP 8010：N/A&lt;/li&gt;
&lt;li&gt;PEP 8011：N/A&lt;/li&gt;
&lt;li&gt;PEP 8012：核心开发者投票，每个-1都算作否决权（译注：要求全员投票通过）&lt;/li&gt;
&lt;li&gt;PEP 8013：核心开发者投票，每个-1都算作否决权&lt;/li&gt;
&lt;li&gt;PEP 8014：N/A&lt;/li&gt;
&lt;li&gt;PEP 8015：核心开发者投票，需2/3票数&lt;/li&gt;
&lt;li&gt;PEP 8016：核心开发者投票，需2/3票数，理事会有否决权&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;淘汰&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;PEP 8010：N/A&lt;/li&gt;
&lt;li&gt;PEP 8011：N/A&lt;/li&gt;
&lt;li&gt;PEP 8012：不信任投票，需大于2/3票数&lt;/li&gt;
&lt;li&gt;PEP 8013：N/A&lt;/li&gt;
&lt;li&gt;PEP 8014：N/A&lt;/li&gt;
&lt;li&gt;PEP 8015：实施工作组临时禁令 =&amp;gt; 移除核心开发者身份&lt;/li&gt;
&lt;li&gt;PEP 8016：指导委员会投票，需大于4/5票数；非现役（inactive）的成员没有投票权&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;更新治理模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;PEP 8010：N/A&lt;/li&gt;
&lt;li&gt;PEP 8011：N/A&lt;/li&gt;
&lt;li&gt;PEP 8012：N/A&lt;/li&gt;
&lt;li&gt;PEP 8013：N/A&lt;/li&gt;
&lt;li&gt;PEP 8014：N/A&lt;/li&gt;
&lt;li&gt;PEP 8015：委交给核心开发者，需4/5票数&lt;/li&gt;
&lt;li&gt;PEP 8016：委交给核心开发者，需2/3票数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;行为守则（Code of Conduct）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;PEP 8010：行为守则管制所有互动与讨论&lt;/li&gt;
&lt;li&gt;PEP 8011：三巨头需遵守 PSF 的行为守则&lt;/li&gt;
&lt;li&gt;PEP 8012：依靠现有的 PSF 行为工作组 (在 PEP 中命名为“版主（Moderators）”)&lt;/li&gt;
&lt;li&gt;PEP 8013：N/A&lt;/li&gt;
&lt;li&gt;PEP 8014：N/A&lt;/li&gt;
&lt;li&gt;PEP 8015：依靠现有的 PSF 行为工作组&lt;/li&gt;
&lt;li&gt;PEP 8016：指导委员会被鼓励去设立 CoC 的流程，同时细节可以灵活制定&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;（原文完，以下内容为译者所加）&lt;/div&gt;
&lt;hr /&gt;
&lt;div&gt;&lt;strong&gt;名词解释&lt;/strong&gt; ：&lt;/div&gt;
&lt;div&gt;PEP：全称是 Python Enhancement Proposals（Python 增强提案），现在数量将近500个，涵盖 Python 功能实现、规范与周边信息等各种内容。本文出现的 7 个提案，全是针对新的治理模式。若想加深理解 PEP，并找到哪些提案是必读的，可阅读我写的《&lt;a href=&quot;https://mp.weixin.qq.com/s/oRoBxZ2-IyuPOf_MWyKZyw&quot;&gt;学习Python，怎能不懂点PEP呢？&lt;/a&gt;》。&lt;/div&gt;
&lt;div&gt;PSF：全称是 Python Software Foundation（Python 软件基金会），非营利组织，其使命是促进 Python 社区发展，负责举办各种社区活动，例如开发 Python 的核心发行版、管理知识产权、举办开发者大会（如PyCon）、促进多元与国际化、以及募集发展基金，等等。&lt;/div&gt;
&lt;div&gt;BDFL：全称是 Benevolent Dictator For Life（终身仁慈独裁者），曾特指 Guido van Rossum，被赋予绝对的最终决策权。2018年7月12日，他宣布不再担任此身份。本文的全部 PEP 都是围绕如何选出新的 BDFL 以及配套的治理方案，该词不再特指某人。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;译后记&lt;/strong&gt; ：&lt;/div&gt;
&lt;div&gt;这是我首次尝试翻译工作，其中的艰难之处真是知者自知。但是，当翻译完毕后，我所得的甘甜喜悦也真是知者自知！由于原文大部分内容都是极度概括性的短句，还有不少专有表述，所以，我采取的翻译策略是尽量达意，因此，难免有翻译错误和偏离原文之处，欢迎读者与我（公众号：&lt;strong&gt;Python猫&lt;/strong&gt; ）交流指正。本文翻译乃个人行为，纯粹出于交流学习的目的，欢迎转载，但请保证注明出处，切勿用于商业或其它不良用途。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>join() 方法的神奇用处与 Intern 机制的软肋</title>
            <link>https://pythoncat.top/posts/2018-12-01-join/</link>
            <guid>https://pythoncat.top/posts/2018-12-01-join/</guid>
            <pubDate>Sat, 01 Dec 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;上篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s/PsY8Iec1EeGDKKnTNU5CNw&quot;&gt;Python是否支持复制字符串呢？&lt;/a&gt;》刚发出一会，@发条橙 同学就在后台留言，指出了一处错误。我一惊，马上去验证，竟然真的错了，而且在完全没意料到的地方！我开始以为只是疏漏，一细想，发现不简单，遇到了百思不得其解的问题了。所以，这篇文章还得再聊聊字符串。&lt;/div&gt;
&lt;div&gt;照例先总结下本文内容：&lt;/div&gt;
&lt;div&gt;（1）join() 方法除了在拼接字符串时速度较快，它还是目前看来最通用有效的复制字符串的方法&lt;/div&gt;
&lt;div&gt;（2）Intern 机制（字符串滞留）并非万能的，本文探索一下它的软肋有哪些&lt;/div&gt;
&lt;h2&gt;1. join()方法不止是拼接&lt;/h2&gt;
&lt;div&gt;我先把那个问题化简一下吧：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;ss0 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;hi&apos;&lt;/span&gt;
ss1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;h&apos;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&apos;i&apos;&lt;/span&gt;
ss2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;join&lt;span&gt;(&lt;/span&gt;ss0&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;ss0 &lt;span&gt;==&lt;/span&gt; ss1 &lt;span&gt;==&lt;/span&gt; ss2&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;ss0&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;ss1&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;ss0&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;ss2&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上面代码中，奇怪的地方就在于 ss2 竟然是一个独立的对象！按照最初想当然的认知，我认定它会被 Intern 机制处理掉，所以是不会占用独立内存的。上篇文章快写完的时候，我突然想到 join 方法，所以没做验证就临时加进去，导致了意外的发生。&lt;/div&gt;
&lt;div&gt;按照之前在“&lt;a href=&quot;https://mp.weixin.qq.com/s/vCs6QvJU2J6L0rIWDKQPUQ&quot;&gt;特权种族&lt;/a&gt;”那篇文章的总结，我对字符串 Intern 机制有这样的认识：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Python中，字符串使用Intern机制实现内存地址共用，长度不超过20，且仅包括下划线、数字、字母的字符串才会被intern；涉及字符串拼接时，编译期优化结果会与运行期计算结果不同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;为什么 join 方法拼接字符串时，可以不受 Intern 机制作用呢？&lt;/div&gt;
&lt;div&gt;回看那篇文章，发现可能存在编译期与运行期的差别！&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 编译对字符串拼接的影响&lt;/span&gt;
s1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;hell&quot;&lt;/span&gt;
s2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;hello&quot;&lt;/span&gt;
&lt;span&gt;&quot;hell&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;o&quot;&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; s2 
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
s1 &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;o&quot;&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; s2 
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;
&lt;span&gt;# &quot;hell&quot; + &quot;o&quot;在编译时变成了&quot;hello&quot;，&lt;/span&gt;
&lt;span&gt;# 而s1+&quot;o&quot;因为s1是一个变量，在运行时才拼接，所以没有被intern&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;实验一下，看看：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 代码加上&lt;/span&gt;
ss3 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;join&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;hi&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;ss0&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;ss3&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;ss3 仍然是独立对象，难道这种写法还是在运行期时拼接？那怎么判断某种写法在编译期还是在运行期起作用呢？继续实验：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;s0 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Python猫&quot;&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; copy
s1 &lt;span&gt;=&lt;/span&gt; copy&lt;span&gt;.&lt;/span&gt;copy&lt;span&gt;(&lt;/span&gt;s0&lt;span&gt;)&lt;/span&gt;
s2 &lt;span&gt;=&lt;/span&gt; copy&lt;span&gt;.&lt;/span&gt;copy&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Python猫&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s0&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s1&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s0&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s2&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;看来，不能通过是否显性传值来判断。&lt;/div&gt;
&lt;div&gt;那就只能从 join 方法的实现原理入手查看了。经某交流群的小伙伴提醒，可以去 &lt;a href=&quot;http://www.pythontutor.com/&quot;&gt;Python Tutor&lt;/a&gt; 网站，看看可视化执行过程。但是，很遗憾，也没看出什么底层机制。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;我找了分析 CPython 源码的资料（含上期荐书栏目的《&lt;a href=&quot;https://mp.weixin.qq.com/s/RcvYm7Ro_nnMx0ZVrJmtyA&quot;&gt;Python源码剖析&lt;/a&gt;》）来学习，但是，这些资料只比较 join() 方法与 + 号拼接法在原理与使用内存上的差异，并没提及为何 Intern 机制对前者会失效，而对后者却是生效的。&lt;/div&gt;
&lt;div&gt;现象已经产生，我只能暂时解释说，&lt;strong&gt;join 方法会不受 Intern 机制控制，它有独享内存的“特权”。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;那就是说，其实有复制字符串的方法！上篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/PsY8Iec1EeGDKKnTNU5CNw&quot;&gt;Python是否支持复制字符串呢？&lt;/a&gt;》由于没有发现这点，最后得出了错误的结论！&lt;/div&gt;
&lt;div&gt;由于这个特例，我要修改上篇文章的结论了：&lt;strong&gt;Python 本身并不限制字符串的复制操作，CPython 解释器出于优化性能的考虑，加入了一些小把戏，试图使字符串对象在内存中只有一份，尽管如此，仍存在有效复制字符串的方法，那就是 join() 方法。&lt;/strong&gt;&lt;/div&gt;
&lt;h2&gt;2. Intern 机制失效的情况&lt;/h2&gt;
&lt;div&gt;join() 方法的神奇用处使我不得不改变对 Intern 机制的认识，本小节就带大家重新学习一下 Intern 机制吧。&lt;/div&gt;
&lt;div&gt;所谓 Intern 机制，即字符串滞留（string interning），它通过维护一个字符串常量池（string intern pool），从而试图只保存唯一的字符串对象，达到既高效又节省内存地处理字符串的目的。&lt;/div&gt;
&lt;div&gt;在创建一个新的字符串对象后，Python 先比较常量池中是否有相同的对象（interned），有的话则将指针指向已有对象，并减少新对象的指针，新对象由于没有引用计数，就会被垃圾回收机制回收掉，释放出内存。&lt;/div&gt;
&lt;div&gt;Intern 机制不会减少新对象的创建与销毁，但最终会节省出内存。这种机制还有另一个好处，即被 Interned 的相同字符串作比较时，几乎不花时间。实验数据如下（资料来源：&lt;a href=&quot;http://t.cn/ELu9n7R&quot;&gt;http://t.cn/ELu9n7R&lt;/a&gt;）：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Intern 机制的大致原理很好理解，然而影响结果的还有 CPython 解释器的其它编译及运行机制，字符串对象受到这些机制的共同影响。实际上，只有那些“看起来像” Python 标识符的字符串才会被处理。源代码&lt;code&gt;StringObject.h&lt;/code&gt;的注释中写道：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;/* … … This is generally restricted to strings that “looklike” Python identifiers, although the intern() builtin can be used to force interning of any string … … */&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;这些机制的相互作用，不经意间带来了不少混乱的现象：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 长度超过20，不被intern VS 被intern&lt;/span&gt;
&lt;span&gt;&apos;a&apos;&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;21&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;&apos;aaaaaaaaaaaaaaaaaaaaa&apos;&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;
&lt;span&gt;&apos;aaaaaaaaaaaaaaaaaaaaa&apos;&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;&apos;aaaaaaaaaaaaaaaaaaaaa&apos;&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;

&lt;span&gt;# 长度不超过20，不被intern VS 被intern&lt;/span&gt;
s &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;a&apos;&lt;/span&gt;
s &lt;span&gt;*&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;&apos;aaaaa&apos;&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;
&lt;span&gt;&apos;a&apos;&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;&apos;aaaaa&apos;&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;


&lt;span&gt;# join方法，不被intern VS 被intern&lt;/span&gt;
&lt;span&gt;&apos;&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;join&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;hi&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;&apos;hi&apos;&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;
&lt;span&gt;&apos;&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;join&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;h&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;&apos;h&apos;&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;

&lt;span&gt;# 特殊符号，不被intern VS 被&quot;intern&quot;&lt;/span&gt;
&lt;span&gt;&apos;python!&apos;&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;&apos;python!&apos;&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;
a&lt;span&gt;,&lt;/span&gt; b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;python!&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;python!&apos;&lt;/span&gt;
a &lt;span&gt;is&lt;/span&gt; b
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这些现象当然都能被合理解释，然而由于不同机制的混合作用，就很容易造成误会。&lt;/div&gt;
&lt;div&gt;比如第一个例子，很多介绍 Intern 机制的文章在比较出 &lt;code&gt;&apos;a&apos; * 21&lt;/code&gt; 的id有变化后，就认为 Intern 机制只对长度不超过20的字符串生效，可是，当看到长度超过20的字符串的id还相等时，这个结论就变错误了。&lt;/div&gt;
&lt;div&gt;当加入&lt;code&gt;常量合并（Constant folding）&lt;/code&gt; 的机制后，长度不超过20的字符串会被合并的现象才得到解释。&lt;/div&gt;
&lt;div&gt;可是，在 CPython 的源码中，只有长度不超过1字节的字符串才会被 intern ，为何长度超标的情况也出现了呢？&lt;/div&gt;
&lt;div&gt;再加入 CPython 的编译优化机制，才能解释。&lt;/div&gt;
&lt;div&gt;所以，看似被 intern 的两个字符串，实际可能不是 Intern 机制的结果，而是其它机制的结果。同样地，看似不能被 intern 的两个字符串，实际可能被其它机制以类似方式处理了。&lt;/div&gt;
&lt;div&gt;如此种种，便提高了理解 Intern 机制的难度。&lt;/div&gt;
&lt;div&gt;就我在上篇文章中所关心的“复制字符串”话题而言，只有当 Intern 机制与其它这些机制统统失效时，才能做到复制字符串。目前看来，join 方法最具通用性。&lt;/div&gt;
&lt;h2&gt;3. 学习的方法论&lt;/h2&gt;
&lt;div&gt;总而言之，因为重新学习 join 方法的神奇用处与 Intern 机制的例外情况，我得以修正上篇文章的错误。在此过程中，我得到了新的知识，以及思考学习的乐趣。&lt;/div&gt;
&lt;div&gt;《超人》电影中有一句著名的台词，在今年上映的《头号玩家》中也出现了：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;有的人从《战争与和平》里看到的只是一个普通的冒险故事，&lt;/p&gt;
&lt;p&gt;有的人则能通过阅读口香糖包装纸上的成分表来解开宇宙的奥秘。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;我读到的是一种敏锐思辨的思想、孜孜求索的态度和以小窥大的方法。作为一个低天赋的人，受此鼓舞，我会继续追问那些看似没意义的问题（“如何删除字符串”、“如何复制字符串”…），一点一点地学习 Python ，以我的方式理解它。同时，希望能给我的读者们带来一些收获。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 是否支持复制字符串呢？</title>
            <link>https://pythoncat.top/posts/2018-11-28-string/</link>
            <guid>https://pythoncat.top/posts/2018-11-28-string/</guid>
            <description>Python 中是否支持复制字符串？如果不支持，为什么不支持？</description>
            <pubDate>Wed, 28 Nov 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;连续几篇文章都在写 Python 字符串，这出乎我的意料了。但是，有的问题，不写不行，特别是那种灵机一动想到的问题，最后你发现，&lt;strong&gt;很多人根本不懂却又误以为自己懂了&lt;/strong&gt;。那就继续刨根问底，探究个明白吧。&lt;/div&gt;
&lt;div&gt;在上一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s/M4_38VHlQwp-CDRczh2NIA&quot;&gt;你真的知道Python的字符串怎么用吗？&lt;/a&gt;》里，我突发奇想，将字符串跟列表做了比较，然后发现字符串竟然没有复制的方法。当时没有细想，只说要搁置疑问。&lt;/div&gt;
&lt;div&gt;过后，有好学的小伙伴在后台留言，与我交流这个问题，给了我一些启发。为了彻底弄懂它，我继续查了不少资料，今天，就跟大家分享一下我发现的东西吧。&lt;/div&gt;
&lt;div&gt;本文标题的问题分为两部分：（1）Python 中是否支持复制字符串？（2）如果不支持，为什么不支持？&lt;/div&gt;
&lt;div&gt;请读者花几分钟想一下，想清楚后，把你的答案记住，然后再往下看。&lt;/div&gt;
&lt;div&gt;让我们做一个约定（自愿遵守）：如果看到最后，你推翻了现在的答案，建立了新的认知，这说明我写的内容有用，那请你任意赞赏，或者将本文分享给其他使用 Python 的小伙伴。&lt;/div&gt;
&lt;h2&gt;1. 什么是复制字符串？&lt;/h2&gt;
&lt;div&gt;首先，必须要大家对“复制”这个概念达成共识。复制，也叫&lt;strong&gt;拷贝&lt;/strong&gt;，英文单词是 copy，具体意思是“&lt;strong&gt;将某事物通过某种方式制作成相同的一份或多份的行为&lt;/strong&gt;”（释义来自维基百科）。复制的结果是，出现了多份极其相似但却相互独立的事物（副本），举例来说，你有一份文档 X，然后复制一份并重新命名为 Y，这两者是相互独立的，若你删除其中一个，另一个不会一起被删除。&lt;/div&gt;
&lt;div&gt;这个词用在 Python 里，我们想表达的是同样的意思，即复制行为会产生新的独立对象，它与原始对象极其相似，但两者的生命周期没有直接的关联关系。下面先用列表来举例：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;list1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;list1&lt;span&gt;)&lt;/span&gt; 
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1981119454856&lt;/span&gt;

list2 &lt;span&gt;=&lt;/span&gt; list1&lt;span&gt;.&lt;/span&gt;copy&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;list1 &lt;span&gt;==&lt;/span&gt; list2&lt;span&gt;)&lt;/span&gt; 
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;list2&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1981116983752&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上例中，列表 list2 是 list1 的副本，两者字面量相等，但是内存地址（即 id ）不相等，是两个相互独立的对象。如果字符串能够做到同样的效果，那我们就说，字符串可以被复制，否则，我们说字符串不可以被复制。&lt;/div&gt;
&lt;h2&gt;2. 怎样能复制字符串？&lt;/h2&gt;
&lt;div&gt;有了上面的概念和示例，请先思考，你会用什么方式复制字符串呢？（暂停，思考3分钟）&lt;/div&gt;
&lt;div&gt;好了，先看看下面的几种方法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;s0 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Python猫&quot;&lt;/span&gt;

s1 &lt;span&gt;=&lt;/span&gt; s0
s2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s0&lt;span&gt;)&lt;/span&gt;
s3 &lt;span&gt;=&lt;/span&gt; s0&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
s4 &lt;span&gt;=&lt;/span&gt; s0 &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&apos;&apos;&lt;/span&gt;
s5 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;%s&apos;&lt;/span&gt; &lt;span&gt;%&lt;/span&gt; s0
s6 &lt;span&gt;=&lt;/span&gt; s0 &lt;span&gt;*&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
s7 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;join&lt;span&gt;(&lt;/span&gt;s0&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; copy
s8 &lt;span&gt;=&lt;/span&gt; copy&lt;span&gt;.&lt;/span&gt;copy&lt;span&gt;(&lt;/span&gt;s0&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;你想到的复制方式是否在以上8种方式里呢？那么，如果把 s0 至 s8 的 id 打印出来，有哪些会跟 s0 不同呢？&lt;/div&gt;
&lt;div&gt;答案是，&lt;strong&gt;它们的内存地址 id 完全相同&lt;/strong&gt;，也就是说，一顿操作猛如虎，结果却始终只有一份字符串，根本没有复制出新的字符串！&lt;/div&gt;
&lt;div&gt;&lt;code&gt;Python猫&lt;/code&gt; 的老读者看到这，会心一笑，这不就是因为字符串的 Intern 机制嘛，短字符串在内存中只会存在一份，在《&lt;a href=&quot;https://mp.weixin.qq.com/s/vCs6QvJU2J6L0rIWDKQPUQ&quot;&gt;Python中的“特权种族”是什么？&lt;/a&gt;》这篇文章里提到过的。&lt;/div&gt;
&lt;div&gt;但请别开心得太早，你可以把 s0 改成一个超长的字符串，例如：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;s0 = “Python猫是来自喵星的客人，它喜欢地球和人类，正在学习Python，而且想借助Python变成人，它的微信公众号也叫Python猫，欢迎你关注哦，喵喵喵喵~~~~~~~”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;然后，再重复上面的操作。最终，你会发现，s0 到 s8 的 id 还是完全相同。&lt;/div&gt;
&lt;div&gt;是不是吃惊了呢？新的 s0 明明已经超过 Intern 机制的长度了，为什么不会产生新的字符串呢？&lt;/div&gt;
&lt;div&gt;首先，请你相信，&lt;strong&gt;超出 Intern 机制的字符串可以存在多份&lt;/strong&gt;，即你可以创建出值完全相同的多个字符串对象，因为字符串对象在内存中并不一定是唯一的：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;s9 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Python猫是来自喵星的客人，它喜欢地球和人类，正在学习Python，而且想借助Python变成人，它的微信公众号也叫Python猫，欢迎你关注哦，喵喵喵喵~~~&quot;&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s0&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s9&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;False&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上例表明，你可以创建出多个相同的字符串对象，但是这种方法与前面列举的8种不同，因为它是独立于 s0 的操作，并不是一种复制操作。从理论上讲，Python 完全可以提供一个方法，达到复制出新的副本的结果。现在的问题恰恰就是：&lt;strong&gt;为什么允许存在多个相等的字符串对象，但是却无法通过复制的方式来创建呢？&lt;/strong&gt;&lt;/div&gt;
&lt;h2&gt;3. 为什么不允许复制字符串？&lt;/h2&gt;
&lt;div&gt;我发现，不仅字符串不允许复制，元组也如此，事实上，还有 int 、float 也不支持复制。它们都是不可变对象，为什么不可变对象就不支持复制操作呢？&lt;/div&gt;
&lt;div&gt;在查资料的时候，我发现网上很多文章对于“不可变对象”的认识存在误区，这些人不知道 Intern 机制的存在，误以为字符串对象在内存只能有唯一一个，进而误以为不可变对象就是在内存中只有一份的对象。所以，这些文章很容易推断出错误的结论：因为字符串是不可变对象，所以字符串不支持复制。&lt;/div&gt;
&lt;div&gt;事实上，不可变对象跟复制操作之间，并没有必然的强相关的关系。肯定是出于别的原因，设计者才给不可变对象加上这种限制，这个原因是什么呢？&lt;/div&gt;
&lt;div&gt;在知乎上，有敏锐的同学提出了我的疑问“&lt;a href=&quot;https://www.zhihu.com/question/41527532&quot;&gt;Python中如何复制一个值或字符串？&lt;/a&gt;”，可惜只有4个回答，而且都没答到点上。Stackoverflow上恰好也有一个问题“&lt;a href=&quot;https://stackoverflow.com/questions/24804453/how-can-i-copy-a-python-string&quot;&gt;How can I copy a Python string?&lt;/a&gt;”，同样没多少人注意到，只有5个回答，好在最高票答案提到了一个点，即这样可以加快字典的查找速度。&lt;/div&gt;
&lt;div&gt;然而，他说的这个点并不靠谱。字典要求键值是可哈希对象，可是计算字符串的哈希值是根据字面值计算，所以对多个相等的字符串对象，其哈希值其实是一样的，对计算和查找根本无影响。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;w1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Python猫是来自喵星的客人，它喜欢地球和人类，正在学习Python，而且想借助Python变成人，它的微信公众号也叫Python猫，欢迎你关注哦，喵喵喵喵~~~&quot;&lt;/span&gt;
w2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Python猫是来自喵星的客人，它喜欢地球和人类，正在学习Python，而且想借助Python变成人，它的微信公众号也叫Python猫，欢迎你关注哦，喵喵喵喵~~~&quot;&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;w1 &lt;span&gt;==&lt;/span&gt; w2&lt;span&gt;)&lt;/span&gt; 
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;w1&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;w2&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; 
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;False&lt;/span&gt; 
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;hash&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;w1&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;w2&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; 
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;继续查资料，终于在《流畅的Python》找到了明确的解释：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;这些细节是 CPython 核心开发者走的捷径和做的优化措施，对这门语言的用户而言无需了解，而且那些细节对其他 Python 实现可能没用，CPython 未来的版本可能也不会用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;这本《流畅的Python》是进阶首选书目之一，我曾读过部分章节，没想到在一个不起眼的小节里，作者 “惊讶地发现” 元组的不可复制性，在此之前，他还自以为“对元组无所不知”，哈哈哈。&lt;/div&gt;
&lt;div&gt;虽然，我早猜测到原因是节省内存和提高速度，但看到这个明确的解释，知道这只是CPython 解释器的“善意的谎言”，而且在未来版本可能不会用，我感到特别意外。&lt;/div&gt;
&lt;div&gt;它证实了我的猜测，同时，也提供了超预期的信息：&lt;strong&gt;其它 Python 解释器可能支持复制不可变对象，目前 CPython 算是一种妥协，在未来可能会恢复不可变对象的复制操作呢！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;回到文章开头的两个问题，我们得到的答案是：&lt;strong&gt;Python 本身并不限制字符串的复制操作，只是当前版本的 CPython 做了优化，才导致出现这种“善意的谎言”，它这么做的原因为了对 Intern 机制做补充，设法使全部字符串对象在内存都只有一份，以达到节省内存的效果。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;CPython 是用 C 语言实现的 Python 解释器，是官方的、使用最广泛的解释器。除了它，还有用 Java 实现的 Jython 解释器、用 .NET 实现的 IronPython 解释器、用 Python 实现的 PyPy 解释器，等等。其它解释器都是怎么应对字符串的复制操作的呢？唉，学无止境，本人才疏学浅没有涉猎，还是先搁置疑问吧。&lt;/div&gt;
&lt;div&gt;这里，我就想提一个题外话，Python 最最最广为人诟病的就是 GIL（全局解释器锁），这导致它不支持真正意义的多线程，成为很多人指责 Python 慢的元凶。但是，这个问题是 CPython 解释器带来的，而像 Jython 解释器就不存在这个问题。&lt;/div&gt;
&lt;div&gt;好了，就此打住吧。你是否还记得在文章开头时想到的答案呢？是否改变了最初的想法呢？欢迎关注公众号 &lt;strong&gt;Python猫&lt;/strong&gt; ，来跟我交流，一起来学习 Python ，做个合格的 &lt;code&gt;Pythonista&lt;/code&gt;。&lt;/div&gt;
&lt;div&gt;参考学习：&lt;/div&gt;
&lt;div&gt;《流畅的Python》&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.zhihu.com/question/41527532&quot;&gt;https://www.zhihu.com/question/41527532&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;update：文中有一个大错误，请查看下篇解析《&lt;a href=&quot;https://mp.weixin.qq.com/s/M2uHVqaHe_nyO5jT60V_6Q&quot;&gt;join() 方法的神奇用处与 Intern 机制的软肋&lt;/a&gt;》&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>你真的知道Python的字符串怎么用吗？</title>
            <link>https://pythoncat.top/posts/2018-11-24-string/</link>
            <guid>https://pythoncat.top/posts/2018-11-24-string/</guid>
            <description>为什么 Python 字符串不具备列表类型的某些操作呢，为什么它不具备 Java 字符串的一些操作呢？</description>
            <pubDate>Sat, 24 Nov 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;正如《&lt;a href=&quot;https://mp.weixin.qq.com/s/z-gSW6XJrAvUE5rS5XrAig&quot;&gt;你真的知道Python的字符串是什么吗？&lt;/a&gt;》所写，Python 中字符串是由 Uniocde 编码的字符组成的不可变序列，它具备与其它序列共有的一些操作，例如判断元素是否存在、拼接序列、切片操作、求长度、求最值、求元素的索引位置及出现次数等等。&lt;/div&gt;
&lt;div&gt;除此之外，它还有很多特有的操作，值得我们时常温故学习，所以，今天我就跟大家继续聊聊字符串。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;本文主要介绍 Python 字符串特有的操作方法，比如它的拼接、拆分、替换、查找及字符判断等使用方法，辨析了一些可能的误区。最后，还做了两个扩展思考：为什么 Python 字符串不具备列表类型的某些操作呢，为什么它不具备 Java 字符串的一些操作呢？两相比较，希望能帮助你透彻地理解——Python 的字符串到底怎么用？&lt;/strong&gt;&lt;/div&gt;
&lt;h2&gt;0. 拼接字符串&lt;/h2&gt;
&lt;div&gt;字符串的拼接操作最常用，我专门为这个话题写过一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/Whrd6NiD4Y2Z-YSCy4XJ1w&quot;&gt;详解Python拼接字符串的七种方式&lt;/a&gt;》，建议你回看。&lt;/div&gt;
&lt;div&gt;在此，简单回顾一下：七种拼接方式从实现原理上划分为三类，即格式化类（%占位符、format()、template）、拼接类（+操作符、类元祖方式、join()）与插值类（f-string），在使用上，我有如下建议——&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;当要处理字符串列表等序列结构时，采用join()方式；拼接长度不超过20时，选用+号操作符方式；长度超过20的情况，高版本选用f-string，低版本时看情况使用format()或join()方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;不敢说字符串就只有这七种拼接方式，但应该说它们是最常见的了。有小伙伴说，我写漏了一种，即&lt;strong&gt;字符串乘法&lt;/strong&gt; ，可以重复拼接自身。没错，从结果上看，这是第八种拼接方式，视为补充吧。&lt;/div&gt;
&lt;div&gt;关于字符串拼接，还得补充一个建议，即&lt;strong&gt;在复杂场景下，尽量避免使用以上几类原生方法，而应该使用外置的强大的处理库&lt;/strong&gt;。比如在拼接 SQL 语句的时候，经常要根据不同的条件分支，来组装不同的查询语句，而且还得插入不同的变量值，所以当面临这种复杂的场景时，传统拼接方式只会加剧代码的复杂度、降低可读性和维护性。使用 &lt;code&gt;SQLAlchemy&lt;/code&gt; 模块，将有效解决这个问题。&lt;/div&gt;
&lt;h2&gt;1. 拆分字符串&lt;/h2&gt;
&lt;div&gt;在字符串的几种拼接方法中，join() 方法可以将列表中的字符串元素，拼接成一个长的字符串，与此相反，split() 方法可以将长字符串拆分成一个列表。前面已说过，字符串是不可变序列，所以字符串拆分过程是在拷贝的字符串上进行，并不会改变原有字符串。&lt;/div&gt;
&lt;div&gt;split() 方法可接收两个参数，第一个参数是分隔符，即用来分隔字符串的字符，默认是&lt;strong&gt;所有的空字符，包括空格、换行(\n)、制表符(\t)等&lt;/strong&gt;。拆分过程会消耗分隔符，所以拆分结果中不包含分隔符。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;s &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;Hello world&apos;&lt;/span&gt;
l &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;&apos;&apos;Hi there , my name is     Python猫
Do you like me ?
&apos;&apos;&apos;&lt;/span&gt;

&lt;span&gt;# 不传参数时，默认分隔符为所有空字符&lt;/span&gt;
s&lt;span&gt;.&lt;/span&gt;split&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;Hello&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;world&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
s&lt;span&gt;.&lt;/span&gt;split&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos; &apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;Hello&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;world&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
s&lt;span&gt;.&lt;/span&gt;split&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;  &apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;Hello world&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 不存在两个空格符&lt;/span&gt;
s&lt;span&gt;.&lt;/span&gt;split&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;world&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;Hello&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;# 空字符包括空格、多个空格、换行符等&lt;/span&gt;
l&lt;span&gt;.&lt;/span&gt;split&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;Hi&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;there&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;,&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;my&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;is&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;Python猫&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;Do&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;you&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;like&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;me&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;?&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;split() 方法的第二个参数是一个数字，默认是缺省，缺省时全分隔，也可以用 maxsplit 来指定拆分次数。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 按位置传参&lt;/span&gt;
l&lt;span&gt;.&lt;/span&gt;split&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos; &apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;Hi&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;there&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;,&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;my name is     Python 猫\nDo you like me ?\n&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;# 指定传参&lt;/span&gt;
l&lt;span&gt;.&lt;/span&gt;split&lt;span&gt;(&lt;/span&gt;maxsplit&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;Hi&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;there&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;,&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;my name is     Python 猫\nDo you like me ?\n&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;# 错误用法&lt;/span&gt;
l&lt;span&gt;.&lt;/span&gt;split&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;
TypeError  Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;ipython&lt;span&gt;-&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;6c16d1a50bca&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;module&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; l&lt;span&gt;.&lt;/span&gt;split&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
TypeError&lt;span&gt;:&lt;/span&gt; must be &lt;span&gt;str&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;split() 方法是从左往右遍历，与之相对，rsplit() 方法是从右往左遍历，比较少用，但是会有奇效。&lt;/div&gt;
&lt;div&gt;拆分字符串还有一种方法，即 splitlines() ，这个方法会按行拆分字符串，它接收一个参数 True 或 False ，分别决定换行符是否会被保留，默认值 False ，即不保留换行符。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 默认不保留换行符&lt;/span&gt;
&lt;span&gt;&apos;ab c\n\nde fg\rkl\r\n&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;splitlines&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;ab c&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;de fg&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;kl&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;&apos;ab c\n\nde fg\rkl\r\n&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;splitlines&lt;span&gt;(&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;ab c\n&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;\n&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;de fg\r&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;kl\r\n&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;2. 替换字符串&lt;/h2&gt;
&lt;div&gt;替换字符串包括如下场景：大小写替换、特定符号替换、自定义片段替换…&lt;/div&gt;
&lt;div&gt;再次说明，字符串是不可变对象，以下操作并不会改变原有字符串。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;以上这些方法都很明了，使用也简单，建议你亲自试验一下。这里只说说 strip() 方法，它比较常用，可以去除字符串前后的空格，不仅如此，它还可以删除首末位置的指定的字符。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;s &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;******Hello world******&apos;&lt;/span&gt;
s&lt;span&gt;.&lt;/span&gt;strip&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;*&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&apos;Hello world&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;3. 查找字符串&lt;/h2&gt;
&lt;div&gt;查找字符串中是否包含某些内容，这是挺常用的操作。Python 中有多种实现方式，例如内置的 find() 方法，但是这个方法并不常用，因为它仅仅告诉你所查找内容的索引位置，而在通常情况下，这个位置并不是我们的目的。&lt;/div&gt;
&lt;div&gt;find() 方法与 index() 方法的效果一样，它们的最大的区别只在于，找不到内容时的返回值不同，一个返回 -1，一个抛出异常 ：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;s &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;Hello world&apos;&lt;/span&gt;

s&lt;span&gt;.&lt;/span&gt;find&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;cat&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;

s&lt;span&gt;.&lt;/span&gt;index&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;cat&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; 
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; ValueError  Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;ipython&lt;span&gt;-&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;442007c50b6f&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;module&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; s&lt;span&gt;.&lt;/span&gt;index&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;cat&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

ValueError&lt;span&gt;:&lt;/span&gt; substring &lt;span&gt;not&lt;/span&gt; found&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;以上两个方法，只能用来满足最简单的查找需求。在实战中，我们常常要查找特定模式的内容，例如某种格式的日期字符串，这就得借助更强大的查找工具了。正则表达式和 re 模块就是这样的工具，正则表达式用来定制匹配规则，re 模块则提供了 match() 、find() 及 findall() 等方法，它们组合起来，可以实现复杂的查找功能。限于篇幅，今后再对这两大工具做详细介绍，这里有一个简单的例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; re
datepat &lt;span&gt;=&lt;/span&gt; re&lt;span&gt;.&lt;/span&gt;&lt;span&gt;compile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;r&apos;\d+/\d+/\d+&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
text &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;Today is 11/21/2018. Tomorrow is 11/22/2018.&apos;&lt;/span&gt;
datepat&lt;span&gt;.&lt;/span&gt;findall&lt;span&gt;(&lt;/span&gt;text&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;11/21/2018&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;11/22/2018&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;4. 字符判断&lt;/h2&gt;
&lt;div&gt;判断字符串是否（只）包含某些字符内容，这类使用场景也很常见，例如在网站注册时，要求用户名只能包含英文字母和数字，那么，当校验输入内容时，就需要判断它是否只包含这些字符。其它常用的判断操作，详列如下：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;h2&gt;5. 字符串不可以做的事&lt;/h2&gt;
&lt;div&gt;上文内容都是 Python 字符串特有的操作方法，相信读完之后，你更清楚知道 Python 能够做什么了。&lt;/div&gt;
&lt;div&gt;但是，这还不足以回答本文标题的问题——你真的知道 Python 的字符串怎么用吗？这些特有的操作方法，再加上之前文章提到的序列共有的操作、字符串读写文件、字符串打印、字符串Intern机制等等内容，才差不多能够回答这个问题。&lt;/div&gt;
&lt;div&gt;尽管如此，为了体现严谨性，我试着再聊聊“Python 字符串不可以做的事”，从相反的维度来补充回答这个问题。下面是开拓思维，进行头脑风暴的时刻：&lt;/div&gt;
&lt;div&gt;（1）受限的序列&lt;/div&gt;
&lt;div&gt;与典型的序列类型相比，字符串不具备列表的如下操作：append()、clear()、copy()、insert()、pop()、remove()，等等。这是为什么呢？&lt;/div&gt;
&lt;div&gt;有几个很好理解，即append()、insert()、pop() 和 remove()，它们都是对单个元素的操作，但是，字符串中的单个元素就是单个字符，通常没有任何意义，我们也不会频繁对其做增删操作，所以，字符串没有这几个方法也算合理。&lt;/div&gt;
&lt;div&gt;列表的 clear() 方法会清空列表，用来节省内存空间，其效果等同于 &lt;code&gt;anylist[:] = []&lt;/code&gt; ，但是，奇怪的是，Python 并不支持清空/删除操作。&lt;/div&gt;
&lt;div&gt;首先，字符串没有 clear() 方法，其次，它是不可变对象，不支持这种赋值操作 &lt;code&gt;anystr[:] = &apos;&apos;&lt;/code&gt; ，也不支持 &lt;code&gt;del anystr[:]&lt;/code&gt; 操作：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;s &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;Hello world&apos;&lt;/span&gt;

s&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;&apos;&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 报错：TypeError&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;str&apos;&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; does &lt;span&gt;not&lt;/span&gt; support item assignment

&lt;span&gt;del&lt;/span&gt; s&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 报错：TypeError&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;str&apos;&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; does &lt;span&gt;not&lt;/span&gt; support item deletion&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;当然，你也别想通过 &lt;code&gt;del s&lt;/code&gt; 来删除字符串，因为变量名 s 只是&lt;strong&gt;字符串对象的引用&lt;/strong&gt; （挖坑，以后写写这个话题），只是一个标签，删除标签并不会直接导致对象实体的消亡。&lt;/div&gt;
&lt;div&gt;如此看来，想要手动清空/删除 Python 字符串，似乎是无解。&lt;/div&gt;
&lt;div&gt;最后还有一个 copy() 方法，这就是拷贝嘛，可是字符串也没有这个方法。为什么呢？难道拷贝字符串的场景不多么？在这点上，我也没想出个所以然来，搁置疑问。&lt;/div&gt;
&lt;div&gt;通过以上几个常用列表操作的比较，我们可以看出字符串这种序列是挺受限的。列表可以看成多节车厢链接成的火车，而字符串感觉就只像多个座椅联排成的长车厢，真是同源不同相啊。&lt;/div&gt;
&lt;div&gt;（2）比就比，谁怕谁&lt;/div&gt;
&lt;div&gt;接下来，又到了 Python 字符串与 Java 字符串 PK 的时刻。在上一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s/z-gSW6XJrAvUE5rS5XrAig&quot;&gt;你真的知道Python的字符串是什么吗？&lt;/a&gt;》中，它们已经在对象定义的角度切磋了两回合，胜利的天平倒向了 Python，这次看看会比出个啥结果吧。&lt;/div&gt;
&lt;div&gt;Java 中有 &lt;code&gt;比较字符串&lt;/code&gt; 的方法，即 compareTo() 方法与 equals() 方法，前一个方法逐一比较两个字符串的字符编码，返回一个整型的差值，后一个方法在整体上比较两个字符串的内容是否相等。&lt;/div&gt;
&lt;div&gt;Python 字符串没有这两个单独的方法，但要实现类似的功能却很简便。 先看例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;myName &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Python猫&quot;&lt;/span&gt;
cmpName &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;world&quot;&lt;/span&gt;
newName &lt;span&gt;=&lt;/span&gt; myName

&lt;span&gt;# 直接用比较符号进行compare&lt;/span&gt;
myName &lt;span&gt;&amp;gt;&lt;/span&gt; cmpName  
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;
myName &lt;span&gt;==&lt;/span&gt; newName
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
cmpName &lt;span&gt;!=&lt;/span&gt; newName
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;

&lt;span&gt;# 比较是否同一对象&lt;/span&gt;
myName &lt;span&gt;is&lt;/span&gt; cmpName
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;
myName &lt;span&gt;is&lt;/span&gt; newName
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;上例中，如果把赋值的字符串换成列表或者其它对象，这些比较操作也是可以进行的。也就是说，&lt;strong&gt;作比较的能力&lt;/strong&gt; 是 Python 公民们的一项基本能力，并不会因为你是字符串就给你设限，或者给你开特权。&lt;/div&gt;
&lt;div&gt;与此类似，Python 公民们自带&lt;strong&gt;求自身长度的能力&lt;/strong&gt; ，len() 方法是内置方法，可以直接传入任意序列参数，求解长度。Java 中则要求不同的序列对象，只能调用各自的 length() 方法。说个形象的比喻，Python 中共用一把秤，三教九流之辈都能拿它称重，而Java 中有多把秤，你称你的，我称我的，大家“井水不犯河水”。&lt;/div&gt;
&lt;div&gt;Python 中曾经有 cmp() 方法和 &lt;code&gt;__cmp__()&lt;/code&gt; 魔术方法，但官方嫌弃它们鸡肋，所以在Python 3 中移除掉了。虽然在 operator 模块中还为它留下了一脉香火，但保不定哪天就会彻底废弃。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; operator
operator&lt;span&gt;.&lt;/span&gt;eq&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;hello&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;
operator&lt;span&gt;.&lt;/span&gt;eq&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;hello&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;hello&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;
operator&lt;span&gt;.&lt;/span&gt;gt&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;hello&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;
operator&lt;span&gt;.&lt;/span&gt;lt&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;hello&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;（3）墙上的门&lt;/div&gt;
&lt;div&gt;在 Java 中，字符串还有一个强大的 valueOf() 方法，它可以接收多种类型的参数，如boolean、char、char数组、double、float、int等等，然后返回这些参数的字符串类型。 例如，要把 int 转为字符串，可以用 String.valueOf(anynum) 。&lt;/div&gt;
&lt;div&gt;Python 字符串依然没有这个单独的方法，但要实现相同的功能却很简便。对Python来说，不同的数据类型转换成字符串，那是小菜一碟，例如：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&apos;123&apos;&lt;/span&gt;
&lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&apos;True&apos;&lt;/span&gt;
&lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1.22&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&apos;1.22&apos;&lt;/span&gt;
&lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&apos;[1, 2]&apos;&lt;/span&gt;
&lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&apos;python&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;sex&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&apos;male&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&quot;{&apos;name&apos;: &apos;python&apos;, &apos;sex&apos;: &apos;male&apos;}&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;而从字符串转换为其它类型，也不难，例如，int(‘123’) 即可由字符串’123’ 得到数字 123。对比 Java，这个操作要写成 &lt;code&gt;Integer.parseInt(&apos;123&apos;)&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;在Java 的不同数据类型之间，那道分隔之墙矗立得很高，仿佛需要借助一座更高的吊桥才能沟通两边，而在灵活的 Python 里，你可以很方便地打开墙上的那扇门，来往穿越。&lt;/div&gt;
&lt;div&gt;小结一下，跟 Java 相比，Python 字符串确实没有几项方法，但是事出有因，它们的天赋能力可不弱，所有这些操作都能简明地实现。一方面，&lt;strong&gt;Python 字符串&lt;/strong&gt;做不到某些事，但是另一方面，&lt;strong&gt;Python&lt;/strong&gt; 可以出色地做成这些事，孰优孰劣，高下立判。&lt;/div&gt;
&lt;h2&gt;6. 总结&lt;/h2&gt;
&lt;div&gt;写文章贵在善始善终，现在给大家总结一下：本文主要介绍 Python 字符串特有的操作方法，比如它的拼接、拆分、替换、查找及字符判断等使用方法，从正向回答，Python 字符串能做什么？最后，我们还从反向来回答了 Python 字符串不能做什么？有些不能做，实际上是 &lt;strong&gt;不为&lt;/strong&gt;，是为了在其它地方更好地作为，归根到底，应该有的功能，Python 字符串全都有了。&lt;/div&gt;
&lt;div&gt;本文中依然将 Python 与 Java 做了比较，有几项小小的差异，背后反映的其实是，两套语言系统在世界观上的差异。古人云，&lt;strong&gt;以铜为镜，可以正衣冠&lt;/strong&gt;。那么，在编程语言的世界里，以另一种语言为镜，也更能看清这种语言的面貌。希望这种跨语言的思维碰撞，能为你擦出智慧的火花。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;扩展阅读：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;《&lt;a href=&quot;https://mp.weixin.qq.com/s/Whrd6NiD4Y2Z-YSCy4XJ1w&quot;&gt;详解Python拼接字符串的七种方式&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;《&lt;a href=&quot;https://mp.weixin.qq.com/s/z-gSW6XJrAvUE5rS5XrAig&quot;&gt;你真的知道Python的字符串是什么吗？&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;Java字符串比较方法：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://blog.csdn.net/barryhappy/article/details/6082823&quot;&gt;https://blog.csdn.net/barryhappy/article/details/6082823&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python3为何取消cmp方法：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.zhihu.com/question/47895103&quot;&gt;https://www.zhihu.com/question/47895103&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python猫荐书系列之四：《Python源码剖析》</title>
            <link>https://pythoncat.top/posts/2018-11-18-book4/</link>
            <guid>https://pythoncat.top/posts/2018-11-18-book4/</guid>
            <description>一本非常经典的书</description>
            <pubDate>Sun, 18 Nov 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;大家好，新一期的荐书栏目如期跟大家见面了。&lt;/div&gt;
&lt;div&gt;先来看看今天的主角是谁：《&lt;a href=&quot;https://book.douban.com/subject/3117898/&quot;&gt;Python源码剖析——深度探索动态语言核心技术&lt;/a&gt;》，2008年出版，作者 @陈儒 ，评分8.7分。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;是的，你没看错，出版年份2008年。这本书基于Python2.5，到了十年后3.7版本的年代，可以说大部分内容已经过时了，而且，还可能缺失了很多关键内容。那你也许会问，一本过时的书，有啥好推荐的呢？下面且听我给你慢慢道来。&lt;/div&gt;
&lt;h2&gt;一个巧合，一份期待&lt;/h2&gt;
&lt;div&gt;在写第一篇荐书《&lt;a href=&quot;https://mp.weixin.qq.com/s/JnoYojDsNHYkpibSfF3hOg&quot;&gt;编写高质量代码改善 Python 程序的 91 个建议&lt;/a&gt;》的时候，我偶然发现知乎上有人提及，说 @赖勇浩 大大正在接手这本源码剖析的新版本编写，很多人留言说期待。我想起曾经看到，有人推荐过这本书，于是便去查了一下。&lt;/div&gt;
&lt;div&gt;书的内容简介中有这一段，我看了便觉得兴趣满满：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;本书以CPython为研究对象，在C代码一级，深入细致地剖析了Python的实现。书中不仅包括了对大量Python内置对象的剖析，更将大量的篇幅用于对Python虚拟机及Python高级特性的剖析。通过此书，读者能够透彻地理解Python中的一般表达式、控制结构、异常机制、类机制、多线程机制、模块的动态加载机制、内存管理机制等核心技术的运行原理，同时，本书所揭示的动态语言的核心技术对于理解其他动态语言，如 Javascript、Ruby等也有较大的参考价值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;作为一个半路上车，刚走出新手村的Pythoner，我正愁如何才能成为一个优秀的Pythonista，这本书闪耀着绝世秘籍的光芒，我起初有点望而却步，过后却又跃跃欲试。&lt;/div&gt;
&lt;div&gt;那么，新书啥时候上市呢？在&lt;code&gt;华蟒用户组&lt;/code&gt; 里，正好有人问到这个消息，群众们纷纷表示翘首以待。不过，赖勇浩站出来回复了：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;看回复的时间，这事已经过去一年了…&lt;/div&gt;
&lt;div&gt;虽然这个神秘的新作者拖稿了，但书的期待值并未因此减损，相反，这恰恰意味着新书上市之日更近了！说不定就在明年上半年了呢。赶在新书出版前，我们荐书栏目先来安利一波，这绝对是一件有先见之明的事，喵喵，美滋滋~~~&lt;/div&gt;
&lt;h2&gt;一份提纲，一些建议&lt;/h2&gt;
&lt;div&gt;铺垫了这么多，接下来要好好说下这本书的内容了。以下内容仅针对08版书籍，等新版上市后，荐书栏目会对两版的差异跟进介绍。&lt;/div&gt;
&lt;div&gt;全书主要分两部分，第一部分（1-6章）剖析Python的几大内建对象（如整数、字符串、列表、字典），涉及对象创建、维护、缓冲池、提升效率的机制等内容；第二部分（7-16章）剖析Python虚拟机，涉及虚拟机框架、一般表达式、控制流、函数机制、类机制、运行环境初始化、动态加载机制、多线程机制、内存管理机制等内容。&lt;/div&gt;
&lt;div&gt;有道是，Python中万物皆对象。而Python是用C语言实现的，C语言却是典型的&lt;strong&gt;面向过程语言&lt;/strong&gt; ，那么，它是如何实现”万物皆对象“的呢？实际上，Python对象是C的结构体在堆上申请的一块内存（包括连续内存与非连续内存），所有内建的类型对象都是被静态初始化了的。&lt;/div&gt;
&lt;div&gt;按照书中的分类，Python对象可分如下：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;其中，Fundamental对象是指类型对象，Numeric对象是指数值对象，Sequence对象是指容纳其它对象的序列集合对象，Mapping对象是类似于C++中map的关联对象，Internal对象是Python虚拟机在运行时内部使用的对象。&lt;/div&gt;
&lt;div&gt;还有一种分类方式，Python对象可以分为定长对象 与变长对象。从这些分类中可以看出，Python对象之间存在着天然差异，那么，不同对象的生命周期管理（创建、维护、使用、回收）、对象的多态、对象缓冲池、以及其它特有的机制，这些都是怎么实现的呢？&lt;/div&gt;
&lt;div&gt;书中第一部分内容就是对以上问题的回答。阅读过程中，我读到了一些熟悉的内容，例如之前在《&lt;a href=&quot;https://mp.weixin.qq.com/s/vCs6QvJU2J6L0rIWDKQPUQ&quot;&gt;Python中的“特权种族”是什么？&lt;/a&gt;》中发明的“特权种族”（例如神秘的[-5,256]数字、以及Intern机制的短字符串），它们在内建对象剖析的部分里都有。阅读的过程，就是从知其然，到知其所以然的过程，于我大有益处。&lt;/div&gt;
&lt;div&gt;说实话，源码分析的部分，对我来说太难了，因为C语言基础早已交还给大学老师了…但是，阅读第一部分的好处是，你不必完全懂源码，因为作者加了很多注释，相关的分析过程也很详尽。&lt;/div&gt;
&lt;div&gt;至于书中的第二部分，我还不敢进入。这部分需要一些编译原理知识、字节码及虚拟机知识。留待今后继续学习。&lt;/div&gt;
&lt;div&gt;全书章节的编排结构特别清晰，已经提供了一份很好的学习路径提纲。这里，我还搜集了一些阅读建议，下面看看有什么：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你在用一门高级语言，想了解语言的实现原理，这本书是你的必选；如果你是一个 C/C++ 程序员，想写出高质量的程序，这本书也是你必选。—— @simonliu&lt;/p&gt;
&lt;p&gt;需要说明的是，我不会向python语言的学习者推荐这本书，因为它不是一本python语言的教材。相反，作为分析Python运行时机制的专著，书中充斥着有关C、C++的讨论（我还读到了有用java做为比较的段落）。这不要求读者是专业的C/C++程序员，但是至少应该能够读懂C代码，最好知道 C++ STL是怎么回事。…我坚信，这本优秀的著作，值得译为英文，向全世界的C/C++/Python程序员推荐。——@膘&lt;/p&gt;
&lt;p&gt;很好的讲解Python源码剖析的书籍，深入讲解了Python的各种特性是如何通过C语言实现的，对于想了解Python底层实现的程序员很有帮助，讲解的很详细，不过看底层C实现看多了也确实容易乏味、消磨耐性，尤其后面高级特性的剖析时，看起来愈发吃力、费劲。 目前先通读了一遍，帮助自己了解了Python的不少特性和其底层机制，还有很多地方草草略过并不十分明白，日后实力更上一层楼时，再回来拜读。 好书推荐！——@流星云&lt;/p&gt;
&lt;p&gt;源码可以不读，这本书还是值得读的。——@赖勇浩&lt;/p&gt;
&lt;p&gt;常备的手边书,深入了解Python的好书。——@清风&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;一份资源，更多福利&lt;/h2&gt;
&lt;div&gt;相信能够读到这里的读者，都燃起了一些阅读兴趣，可以“按图索骥”去学习。电子学习资源很多，对于&lt;code&gt;爱学习&lt;/code&gt; 的你们来说，这不是啥难事。豆瓣读书、当当网和京东图书上，也有电子书可购买。&lt;/div&gt;
&lt;div&gt;但是，如果你想买纸质书，不好意思，早就绝版了。二手旧书的价格贵得吓人，下面讯息给不差钱的同学们参考下：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;在中英文的Python书籍中，这本剖析源码的书籍，可能是绝无仅有的一本，就凭这点，怎么推荐都不为过。对于可能会很快上市的新书，则是怎么期待都不为过的。如果有小伙伴知道出版消息，恳请在后台告知于我，不胜感激。&lt;/div&gt;
&lt;div&gt;在荐书《&lt;a href=&quot;https://mp.weixin.qq.com/s/6swAZA7baF26BlrKV7zBFg&quot;&gt;黑客与画家&lt;/a&gt;》的时候，我们送出了一本精装书福利。等到这本源码剖析的新书上市时，送书福利肯定会是大大的，大家拭目以待吧。当然，后续其它荐书的书目，也很有可能会送福利，一样不容错过。&lt;/div&gt;
&lt;div&gt;所以，我要打个小广告，还没关注的小伙伴，赶紧扫描下方二维码，立刻关注公众号&lt;code&gt;Python猫&lt;/code&gt; ，关注我们的荐书栏目，让我们一同学习，一同进步，一同抢福利，喵喵喵~~~&lt;/div&gt;
&lt;div&gt;往期荐书回顾：&lt;/div&gt;
&lt;div&gt;第一期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/JnoYojDsNHYkpibSfF3hOg&quot;&gt;编写高质量代码改善 Python 程序的 91 个建议&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;第二期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/9RonAqwCXo_lganYvLHgVw&quot;&gt;Python最佳实践指南&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;第三期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/6swAZA7baF26BlrKV7zBFg&quot;&gt;黑客与画家&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;延伸阅读：&lt;/div&gt;
&lt;div&gt;陈儒博客：&lt;a href=&quot;https://blog.csdn.net/balabalamerobert&quot;&gt;https://blog.csdn.net/balabalamerobert&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;豆瓣书目：&lt;a href=&quot;https://book.douban.com/subject/3117898/&quot;&gt;https://book.douban.com/subject/3117898/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python源码：&lt;a href=&quot;https://svn.python.org/projects/&quot;&gt;https://svn.python.org/projects/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;书评笔记：
&lt;a href=&quot;https://book.douban.com/review/8912893/&quot;&gt;https://book.douban.com/review/8912893/&lt;/a&gt;
&lt;a href=&quot;https://blog.csdn.net/lxlmycsdnfree/article/details/78782165&quot;&gt;https://blog.csdn.net/lxlmycsdnfree/article/details/78782165&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>你真的知道Python的字符串是什么吗？</title>
            <link>https://pythoncat.top/posts/2018-11-16-string/</link>
            <guid>https://pythoncat.top/posts/2018-11-16-string/</guid>
            <description>聊聊 Python 的字符串与 Java 的字符串</description>
            <pubDate>Fri, 16 Nov 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在《&lt;a href=&quot;https://mp.weixin.qq.com/s/Whrd6NiD4Y2Z-YSCy4XJ1w&quot;&gt;详解Python拼接字符串的七种方式&lt;/a&gt;》这篇推文里，我提到过，字符串是程序员离不开的事情。后来，我看到了一个英文版本的说法：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;There are few guarantees in life: death, taxes, and programmers needing to deal with strings.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;它竟然把程序员处理字符串跟死亡大事并列了，可见这是多么命中注定…&lt;/div&gt;
&lt;div&gt;回头看其它文章，我发现这种说法得到了佐证，因为我在无意中已零零碎碎地提及了字符串的很多方面，例如：字符串读写文件、字符串打印、字符串不可变性、字符串Intern机制、字符串拼接、&lt;a href=&quot;https://mp.weixin.qq.com/s/6swAZA7baF26BlrKV7zBFg&quot;&gt;是否会取消字符串&lt;/a&gt;，等等。而这些，还只能算字符串面目的冰山一角。&lt;/div&gt;
&lt;div&gt;既然如此，那干脆再单独写写Python的字符串吧。这篇内容可能会很基（li）础（lun），并不是什么“骚操作”或“冷知识”，权当是一份温故而求知新的笔记。&lt;/div&gt;
&lt;h2&gt;1 Python字符串是什么？&lt;/h2&gt;
&lt;div&gt;根据维基百科定义：字符串是由零个或多个字符组成的有限序列。而在Python 3中，它有着更明确的意思：&lt;strong&gt;字符串是由Unicode码点组成的不可变序列&lt;/strong&gt;（Strings are immutable sequences of Unicode code points.）&lt;/div&gt;
&lt;div&gt;字符串是一种序列，这意味着它具备序列类型都支持的操作：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 以下的s、t皆表示序列，x表示元素&lt;/span&gt;
x &lt;span&gt;in&lt;/span&gt; s  &lt;span&gt;# 若s包含x，返回True，否则返回False&lt;/span&gt;
x &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; s  &lt;span&gt;# 若s包含x，返回False，否则返回True&lt;/span&gt;
s &lt;span&gt;+&lt;/span&gt; t  &lt;span&gt;# 连接两个序列&lt;/span&gt;
s &lt;span&gt;*&lt;/span&gt; n  &lt;span&gt;# s复制n次&lt;/span&gt;
s&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt;   &lt;span&gt;# s的索引第i项&lt;/span&gt;
s&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;:&lt;/span&gt;j&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# s切片从第i项到第j-1项&lt;/span&gt;
s&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;:&lt;/span&gt;j&lt;span&gt;:&lt;/span&gt;k&lt;span&gt;]&lt;/span&gt;  &lt;span&gt;#  s切片从第i项到第j-1项,间隔为k&lt;/span&gt;
&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# s的长度&lt;/span&gt;
&lt;span&gt;min&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# s的最小元素&lt;/span&gt;
&lt;span&gt;max&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# s的最大元素&lt;/span&gt;
s&lt;span&gt;.&lt;/span&gt;index（x） &lt;span&gt;# x的索引位置&lt;/span&gt;
s&lt;span&gt;.&lt;/span&gt;count&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# s中出现x的总次数&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;字符串序列还具备一些特有的操作，限于篇幅，按下不表。预告一下，下一篇《&lt;strong&gt;你真的知道Python的字符串怎么用吗？&lt;/strong&gt; 》将会展开介绍，敬请期待…&lt;/div&gt;
&lt;div&gt;字符串序列是一种不可变序列，这意味着它不能像可变序列一样，进行就地修改。例如，在字符串“Python”的基础上拼接“Cat”，得到字符串“PythonCat”，新的字符串是一个独立的存在，它与基础字符串“Python”并没有关联关系。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;basename &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Python&quot;&lt;/span&gt;
myname &lt;span&gt;=&lt;/span&gt; basename &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;Cat&quot;&lt;/span&gt;
&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;basename&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;myname&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;

&lt;span&gt;# 作为对比，列表能就地修改&lt;/span&gt;
baselist &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;Python&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
baselist&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Cat&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;baselist&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;Python&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;Cat&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;字符串这种序列与其它序列（如列表、元组）的不同之处在于，它的“元素”限定了只能是Unicode码点。Unicode码点是什么呢？简单理解，就是用Unicode编码的字符。那字符是什么呢？&lt;code&gt;字符&lt;/code&gt;是人类书写系统的各类符号，例如阿拉伯数字、拉丁字母、中文、日文、藏文、标点符号、控制符号（换行符、制表符等）、其它特殊符号（@#￥%$*等等）。那Unicode编码又是什么呢？Unicode别名是万国码、国际码，它是一种适用性最广的、将书写字符编码为计算机数字的标准。&lt;/div&gt;
&lt;div&gt;总所周知，在最底层的计算机硬件世界里，只有0和1。那么，怎么用这个二进制数字，来表示人类的文化性的字符呢？这些字符数量庞大，而且还在日益增长与变化，什么样的编码方案才是最靠谱的呢？&lt;/div&gt;
&lt;div&gt;历史上，人类创造了多种多样的字符编码标准，例如ASCII（1963年）编码，以西欧语言的字符为主，它的缺点是只能编码128个字符；例如GB2312（1981年），这是中国推出的编码标准，在兼容ASCII标准的基础上，还加入了对日文、俄文等字符的编码，但缺点仍是编码范围有限，无法表示古汉语、繁体字及更多书写系统的字符。&lt;/div&gt;
&lt;div&gt;Unicode编码标准于1991年推出，至今迭代到了第11版，已经能够编码146个书写系统的130000个字符，可谓是无所不包，真不愧是“国际码”。Unicode编码其实是一个二进制字符集，它建立了从书写字符映射成唯一的数字字符的关系，但是，由于各系统平台对字符的理解差异，以及出于节省空间的考虑，Unicode编码还需要再做一次转换，转换后的新的二进制数字才能作为&lt;strong&gt;实际存储及网络传输时的编码&lt;/strong&gt;。&lt;/div&gt;
&lt;div&gt;这种转换方式被称为&lt;strong&gt;Unicode转换格式&lt;/strong&gt;（Unicode Transformation Format，简称为UTF），它又细分为UTF-8、UTF-16、UTF-32等等方式。我们最常用的是UTF-8。为什么UTF-8最常用呢？因为它是可变长度的编码方案，针对不同的字符使用不同的字节数来编码，例如编码英文字母时，只需要一个字节（8个比特），而编码较复杂的汉字时，就会用到三个字节（24个比特）。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;二进制的编码串可以说是给机器阅读的，为了方便，我们通常会将其转化为十六进制，例如“中”字的Unicode编码可以表示成&lt;code&gt;0x4e2d&lt;/code&gt; ，其UTF-8编码可以表示为&lt;code&gt;0xe4b8ad&lt;/code&gt; ，‘0x’用于开头表示十六进制，这样就简洁多了。不过，UTF-8编码的结果会被表示成以字节为单位的形式，例如“中”字用UTF-8编码后的字节形式是&lt;code&gt;\xe4\xb8\xad&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;Python中为了区分Unicode编码与字节码，分别在开头加“u”和“b”以示区分。在Python 3中，因为Unicode成了默认编码格式，所以“u”被省略掉了。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 字符转Unicode编码&lt;/span&gt;
&lt;span&gt;# Python3中，开头的u被省略，b不可省略&lt;/span&gt;
&lt;span&gt;hex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;ord&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;中&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&apos;0x4e2d&apos;&lt;/span&gt;
&lt;span&gt;hex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;ord&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;A&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&apos;0x41&apos;&lt;/span&gt;

&lt;span&gt;# 字符转UTF-8编码（encode）&lt;/span&gt;
&lt;span&gt;&apos;中&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;encode&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;utf-8&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;b&apos;\xe4\xb8\xad&apos;&lt;/span&gt;
&lt;span&gt;&apos;A&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;encode&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;utf-8&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;b&apos;A&apos;&lt;/span&gt;

&lt;span&gt;# Unicode编码还原成字符&lt;/span&gt;
&lt;span&gt;chr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0x4e2d&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&apos;中&apos;&lt;/span&gt;
&lt;span&gt;chr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0x41&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&apos;A&apos;&lt;/span&gt;

&lt;span&gt;# UTF-8编码还原成字符（decode）&lt;/span&gt;
&lt;span&gt;b&apos;\xe4\xb8\xad&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;decode&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;utf-8&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&apos;中&apos;&lt;/span&gt;
&lt;span&gt;b&apos;A&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;decode&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;utf-8&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&apos;A&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;总结一下，Python 3 中的字符串是由Unicode码点组成的不可变序列，也即是，由采用Unicode标准编码的字符组成的不可变序列。Unicode编码将书写系统的字符映射成了计算机二进制数字，为了方便，通常显示为十六进制；在运算内存中，字符以Unicode编码呈现，当写入磁盘或用于网络传输时，一般采用UTF-8方式编码。&lt;/div&gt;
&lt;div&gt;在Python 2中，因为历史包袱，即Python先于Unicode编码而诞生，所以其编码问题是个大难题。幸好抛弃Python 2已成大势所趋，所以我就不再对此做介绍或比对了。&lt;/div&gt;
&lt;h2&gt;2 Python字符串 VS Java字符串&lt;/h2&gt;
&lt;div&gt;虽然不提纵向版本间的差异，但是，我想将Python字符串与其它编程语言做一个横向对比。我觉得这会是挺好玩的事。通过跨语言的比较，也许我们能加深对一个事物（字符串）的理解，还可能受到启发，得到对“编程语言”及“编程哲学”的领悟。&lt;/div&gt;
&lt;div&gt;由于本人才疏学浅，本文就只对两点皮毛特性作说明，欢迎读者斧正和补充。&lt;/div&gt;
&lt;div&gt;（1）字符串的定义方式&lt;/div&gt;
&lt;div&gt;Python的字符串是内置类型，所以使用起来很方便，有如下三种定义方式：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;str_0 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;&apos;&apos;Python字符串可以写在用三引号对内，表示多行字符串。
还可以写在单引号对内，
当然还可以写在双引号对内。
&apos;&apos;&apos;&lt;/span&gt;

str_1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;Python猫是一只猫&apos;&lt;/span&gt;
str_2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Python猫是一个微信公众号&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;Java的字符串不是内置类型，它属于对象，需要通过String类来创建。不过，正因为字符串太常用，所以Java特意预定义了一个字符串类String，使得程序员也可以像这样来定义：&lt;code&gt;String name = &quot;Python猫&quot;;&lt;/code&gt; ，而不必这样写：&lt;code&gt;String name = new String(&quot;Python猫&quot;);&lt;/code&gt; 。&lt;/div&gt;
&lt;div&gt;Java的字符串只能写在双引号内，不具备Python中单双引号混用的灵活。至于三引号的多行字符串表示法，Java程序员表示羡慕得要死，那种痛苦，受过折磨的人最懂。写出来让Python程序员开心一下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;String s &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Java 的多行字符串很麻烦，\n&quot;&lt;/span&gt;
         &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;既要使用换行符，\n&quot;&lt;/span&gt;
         &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;还需要使用加号拼接&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;为什么Java不支持多行字符串、什么时候支持多行字符串？此类问题在Python程序员眼里，可能很费解，但它绝对能排进“Java程序员最希望能实现的特性”的前列。好不容易，官方有计划在Java 11 实现，但今年9月发布的Java 11 仍是没有，现在改计划到Java 12 了。&lt;/div&gt;
&lt;div&gt;（2）单个字符与字符序列&lt;/div&gt;
&lt;div&gt;Java中其实也有单引号的使用，用在char类型上，例如&lt;code&gt;char c = &apos;A&apos;;&lt;/code&gt; 。char是一种内置类型，表示单个用Unicode编码的字符。Python中没有char类型，字符串类型通吃一切。&lt;/div&gt;
&lt;div&gt;前面说到，Python的字符串是一种字符序列，而Java的字符串并不是一种序列，要表示相近的概念的话，就得用到&lt;code&gt;字符数组&lt;/code&gt; 或者 &lt;code&gt;字符串数组&lt;/code&gt; ，例如：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;char&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt; &lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;b&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;c&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;  
String&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; new String&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&quot;1&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;2&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;3&quot;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;字符数组和字符串数组是一种序列，但并不是字符串，它们之间如果要相互转换，还是挺麻烦的。另外，说是序列，但Java的序列操作绝对无法跟Python相比，别的不说，就上面提及的几个基础操作，试问Java能否实现、实现起来要花费多大力气？&lt;/div&gt;
&lt;div&gt;最后来个Ending，关于“Python字符串到底是什么”就说到这啦，希望对你有所帮助。下次，我再跟大家说说“Python字符串到底怎么用”，敬请期待。&lt;/div&gt;
&lt;div&gt;拓展阅读：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Unicode&quot;&gt;https://zh.wikipedia.org/wiki/Unicode&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/UTF-8&quot;&gt;https://zh.wikipedia.org/wiki/UTF-8&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://yiyibooks.cn/xx/python_352/library/stdtypes.html&quot;&gt;https://yiyibooks.cn/xx/python_352/library/stdtypes.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://github.com/acmerfight/insight_python/blob/master/Unicode_and_Character_Sets.md&quot;&gt;https://github.com/acmerfight/insight_python/blob/master/Unicode_and_Character_Sets.md&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>再聊聊 Python 中文社区的翻译</title>
            <link>https://pythoncat.top/posts/2018-11-14-translation/</link>
            <guid>https://pythoncat.top/posts/2018-11-14-translation/</guid>
            <pubDate>Wed, 14 Nov 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在写《&lt;a href=&quot;https://mp.weixin.qq.com/s/oRoBxZ2-IyuPOf_MWyKZyw&quot;&gt;学习Python，怎能不懂点PEP呢？&lt;/a&gt;》的时候，我已经发现国内的Python翻译环境不容乐观。这个结论可能不对，毕竟这几年Python大热，或许有不少优秀的翻译项目，只是我还不知道而已。&lt;/div&gt;
&lt;div&gt;不管如何，接着上一篇关于“Python学习资料汉化”的话题，今天，我们再聊聊Python中文社区的翻译话题。&lt;/div&gt;
&lt;h2&gt;Python部落的翻译社&lt;/h2&gt;
&lt;div&gt;很巧合的是，Python部落（公众号：&lt;code&gt;Python程序员&lt;/code&gt;）刚刚低调地上线了“翻译社”功能。在公众号文章里，他们写到了推出这个项目的意图，我对此深为认可：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;我们要及时地了解英文Python社区的进展, 深入地发掘Python语言的能力, 积极地参与Python领域的活动和倡议. 所以, 将国外优质的文章翻译为中文呈现给大家, 这个事情刻不容缓!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;事先声明，这不是一篇软文，我跟他们没有合作关系。我本来计划要分享一篇英文技术博客，但是排版折腾了很久，怎么调都不如意，最后只好放弃。可是，我又不想再断更，怎么办呢？那正好借“翻译社”上线，来聊聊“Python学习资料汉化”的话题了。&lt;/div&gt;
&lt;div&gt;首先，简单介绍一下“翻译社”。它是“Python部落”网站的一个功能，以任务的形式发布了一些英文文章的链接，你可以去认领任务，按照几条质量管控的规则进行翻译和提交即可。&lt;/div&gt;
&lt;div&gt;按照任务分类，他们提供了三类翻译任务：Python、Web前端与Docker，不过点开看，只有十几篇Python文章，其它两类仍是空缺。这可以看出，他们应该是一个小团队，有想法，但刚起步。除此之外，翻译社不支持用户提交新的任务，我觉得这是一个遗憾，希望他们后续考虑下。&lt;/div&gt;
&lt;div&gt;根据公众号文章的说明，他们会给过审的翻译作品支付稿费，但这点在网站上没有体现。我知道翻译技术文章不容易，不管稿酬有多少，这都是一种积极的认可与正向激励。所以，如果有小伙伴感兴趣，可以去了解一下。&lt;/div&gt;
&lt;h2&gt;Pythoncaff社区&lt;/h2&gt;
&lt;div&gt;接下来，我要介绍一个Python开发者社区（网址：&lt;a href=&quot;https://pythoncaff.com&quot;&gt;https://pythoncaff.com&lt;/a&gt; ），这个社区里活跃着一些乐意参与Python翻译的小伙伴。&lt;/div&gt;
&lt;div&gt;我之所以会知道这个社区，是因为第二期的荐书《&lt;a href=&quot;https://mp.weixin.qq.com/s/9RonAqwCXo_lganYvLHgVw&quot;&gt;Python最佳实践指南&lt;/a&gt;》，当时我找到了两个翻译版本，对比下来，发现这个社区的翻译版本更好，于是，我就收藏了。&lt;/div&gt;
&lt;div&gt;除了这本书，他们还组织翻译了基于Python3.7版本的《Python官方文档：入门教程》、《Python3标准库实例教程》和《Python简明教程》，翻译质量感人。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这个社区表面看起来没人气，首页上竟然有半数文章发表于两周前，但是，当看到参与翻译的人数时，我又对它充满了信心。当然，这也是我向大家推荐它的理由。&lt;/div&gt;
&lt;h2&gt;Python 官方文档中文翻译项目&lt;/h2&gt;
&lt;div&gt;虽然Pythoncaff社区组织了对Python官方文档的翻译，但他们只是完成了入门教程的部分。事实上，Python官方也有一个完整版的翻译项目。&lt;/div&gt;
&lt;div&gt;首先，我要提到 PEP 545（Python Documentation Translations），这里说明了官方的翻译项目的各项细节。官方翻译项目使用的是Transifex平台，翻译者以国家为单位组成团队，进行协作翻译。&lt;/div&gt;
&lt;div&gt;目前，有34个进行态的翻译团队，中文团队（大陆）的翻译进度刚过10%，跟排第一的日本（约80%）相比，落后很多。这项数据，从侧面印证了我之前的观点：国内的Python翻译环境不容乐观。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;尽管现状如此，但我坚信这种局面必然会得到改善。因为国内的Python学习者不仅仅是人数众多，其中有意愿和能力进行英文翻译的人也很多。&lt;/div&gt;
&lt;div&gt;或许，他们恰好不知道有这样的翻译需求，不知道有一些优秀的团队和社区可以去加入，不知道有一些翻译项目其实可以很方便地做贡献，才没有参与罢了。&lt;/div&gt;
&lt;div&gt;所以，这也是我写这篇文章的目的，希望通过介绍这方面的内容，提供些有用的信息，帮助到这些小伙伴。&lt;/div&gt;
&lt;div&gt;参考链接：
&lt;a href=&quot;https://mp.weixin.qq.com/s/QhADZ8GUOdIznpwOF9YRvw&quot;&gt;https://mp.weixin.qq.com/s/QhADZ8GUOdIznpwOF9YRvw&lt;/a&gt;
&lt;a href=&quot;https://www.python.org/dev/peps/pep-0545/&quot;&gt;https://www.python.org/dev/peps/pep-0545/&lt;/a&gt;
&lt;a href=&quot;https://www.jianshu.com/p/27d2f02a86e9&quot;&gt;https://www.jianshu.com/p/27d2f02a86e9&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>学习 Python，怎能不懂点 PEP 呢？</title>
            <link>https://pythoncat.top/posts/2018-11-08-PEP/</link>
            <guid>https://pythoncat.top/posts/2018-11-08-PEP/</guid>
            <description>本文的目的是：尽量全面地介绍PEP是什么，告诉大家为什么要去阅读PEP</description>
            <pubDate>Thu, 08 Nov 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;或许你是一个初入门Python的小白，完全不知道PEP是什么。又或许你是个学会了Python的熟手，见过几个PEP，却不知道这玩意背后是什么。那正好，本文将系统性地介绍一下PEP，与大家一起加深对PEP的了解。&lt;/div&gt;
&lt;div&gt;目前，国内各类教程不可胜数，虽然或多或少会提及PEP，但笼统者多、局限于某个PEP者多，能够详细而全面地介绍PEP的文章并不多。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;本文的目的是：尽量全面地介绍PEP是什么，告诉大家为什么要去阅读PEP，以及列举了一些我认为是必读的PEP，最后，则是搜罗了几篇PEP的中文翻译，希望能为Python学习资料的汉化，做点抛砖引玉的贡献。&lt;/strong&gt;&lt;/div&gt;
&lt;h2&gt;PEP是什么？&lt;/h2&gt;
&lt;div&gt;PEP的全称是&lt;code&gt;Python Enhancement Proposals&lt;/code&gt;，其中Enhancement是增强改进的意思，Proposals则可译为提案或建议书，所以合起来，比较常见的翻译是&lt;code&gt;Python增强提案&lt;/code&gt;或&lt;code&gt;Python改进建议书&lt;/code&gt;。&lt;/div&gt;
&lt;div&gt;我个人倾向于前一个翻译，因为它更贴切。Python核心开发者主要通过邮件列表讨论问题、提议、计划等，PEP通常是汇总了多方信息，经过了部分核心开发者review和认可，最终形成的正式文档，起到了对外公示的作用，所以我认为翻译成“提案”更恰当。&lt;/div&gt;
&lt;div&gt;PEP的官网是：&lt;a href=&quot;https://www.python.org/dev/peps&quot;&gt;https://www.python.org/dev/peps&lt;/a&gt; ，这也就是PEP 0 的地址。其它PEP的地址是将编号拼接在后面，例如：&lt;a href=&quot;https://www.python.org/dev/peps/pep-0020&quot;&gt;https://www.python.org/dev/peps/pep-0020&lt;/a&gt; 就是PEP 20 的链接，以此类推。&lt;/div&gt;
&lt;div&gt;第一个PEP诞生于2000年，现在正好是18岁成年。到目前为止，它拥有478个“兄弟姐妹”。&lt;/div&gt;
&lt;div&gt;官方将PEP分成三类:&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;I - Informational PEP&lt;/p&gt;
&lt;p&gt;P - Process PEP&lt;/p&gt;
&lt;p&gt;S - Standards Track PEP&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;其含义如下:&lt;/div&gt;
&lt;div&gt;信息类：这类PEP就是提供信息，有告知类信息，也有指导类信息等等。例如PEP 20（The Zen of Python，即著名的Python之禅）、PEP 404 (Python 2.8 Un-release Schedule，即宣告不会有Python2.8版本)。&lt;/div&gt;
&lt;div&gt;流程类：这类PEP主要是Python本身之外的周边信息。例如PEP 1（PEP Purpose and Guidelines，即关于PEP的指南）、PEP 347（Migrating the Python CVS to Subversion，即关于迁移Python代码仓）。&lt;/div&gt;
&lt;div&gt;标准类：这类PEP主要描述了Python的新功能和新实践（implementation），是数量最多的提案。例如我之前推文《&lt;a href=&quot;https://mp.weixin.qq.com/s/Whrd6NiD4Y2Z-YSCy4XJ1w&quot;&gt;详解Python拼接字符串的七种方式&lt;/a&gt;》提到过的f-string方式，它出自PEP 498（Literal String Interpolation，字面字符串插值）。&lt;/div&gt;
&lt;div&gt;每个PEP最初都是一个草案（Draft），随后会经历一个过程，因此也就出现了不同的状态。以下是一个流程图：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;A – Accepted (Standards Track only) or Active proposal 已接受（仅限标准跟踪）或有效提案&lt;/p&gt;
&lt;p&gt;D – Deferred proposal 延期提案&lt;/p&gt;
&lt;p&gt;F – Final proposal 最终提案&lt;/p&gt;
&lt;p&gt;P – Provisional proposal 暂定提案&lt;/p&gt;
&lt;p&gt;R – Rejected proposal 被否决的提案&lt;/p&gt;
&lt;p&gt;S – Superseded proposal 被取代的提案&lt;/p&gt;
&lt;p&gt;W – Withdrawn proposal 撤回提案&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;在PEP 0（Index of Python Enhancement Proposals (PEPs)）里，官方列举了所有的PEP，你可以按序号、按类型以及按状态进行检索。而在PEP 1（PEP Purpose and Guidelines）里，官方详细说明了PEP的意图、如何提交PEP、如何修复和更新PEP、以及PEP评审的机制等等。&lt;/div&gt;
&lt;h2&gt;为什么要读PEP？&lt;/h2&gt;
&lt;div&gt;无论你是刚入门Python的小白、有一定经验的从业人员，还是资深的黑客，都应该阅读Python增强提案。&lt;/div&gt;
&lt;div&gt;依我之见，阅读PEP至少有如下好处:&lt;/div&gt;
&lt;div&gt;（1）了解Python有哪些特性，它们与其它语言特性的差异，为什么要设计这些特性，是怎么设计的，怎样更好地运用它们；&lt;/div&gt;
&lt;div&gt;（2）跟进社区动态，获知业内的最佳实践方案，调整学习方向，改进工作业务的内容；&lt;/div&gt;
&lt;div&gt;（3）参与热点议题讨论，或者提交新的PEP，为Python社区贡献力量。&lt;/div&gt;
&lt;div&gt;说到底，学会用Python编程，只是掌握了皮毛。PEP提案是深入了解Python的途径，是真正掌握Python语言的一把钥匙，也是得心应手使用Python的一本指南。&lt;/div&gt;
&lt;h2&gt;哪些PEP是必读的？&lt;/h2&gt;
&lt;div&gt;如前所述，PEP提案已经累积产生了478个，我们并不需要对每个PEP都熟知，没有必要。下面，我列举了一些PEP，推荐大家一读：&lt;/div&gt;
&lt;div&gt;PEP 0 — Index of Python Enhancement Proposals&lt;/div&gt;
&lt;div&gt;PEP 7 — Style Guide for C Code，C扩展&lt;/div&gt;
&lt;div&gt;PEP 8 — Style Guide for Python Code，Python编码规范（必读）&lt;/div&gt;
&lt;div&gt;PEP 20 — The Zen of Python，Python之禅&lt;/div&gt;
&lt;div&gt;PEP 202 — List Comprehensions，列表生成式&lt;/div&gt;
&lt;div&gt;PEP 274 — Dict Comprehensions，字典生成式&lt;/div&gt;
&lt;div&gt;PEP 234 — Iterators，迭代器&lt;/div&gt;
&lt;div&gt;PEP 257 — Docstring Conventions，文档注释规范&lt;/div&gt;
&lt;div&gt;PEP 279 — The enumerate() built-in function，enumerate枚举&lt;/div&gt;
&lt;div&gt;PEP 282 — A Logging System，日志模块&lt;/div&gt;
&lt;div&gt;PEP 285 — Adding a bool type，布尔值（建议阅读《&lt;a href=&quot;https://mp.weixin.qq.com/s/YQbk0smMTCexsi3Ytd2AzA&quot;&gt;Python对象的身份迷思：从全体公民到万物皆数&lt;/a&gt;》）&lt;/div&gt;
&lt;div&gt;PEP 289 — Generator Expressions，生成器表达式&lt;/div&gt;
&lt;div&gt;PEP 318 — Decorators for Functions and Methods，装饰器&lt;/div&gt;
&lt;div&gt;PEP 342 — Coroutines via Enhanced Generators，协程&lt;/div&gt;
&lt;div&gt;PEP 343 — The “with” Statement，with语句&lt;/div&gt;
&lt;div&gt;PEP 380 — Syntax for Delegating to a Subgenerator，yield from语法&lt;/div&gt;
&lt;div&gt;PEP 405 — Python Virtual Environments，虚拟环境&lt;/div&gt;
&lt;div&gt;PEP 471 — os.scandir() function，遍历目录&lt;/div&gt;
&lt;div&gt;PEP 484 — Type Hints，类型约束&lt;/div&gt;
&lt;div&gt;PEP 492 — Coroutines with async and await syntax，async/await语法&lt;/div&gt;
&lt;div&gt;PEP 498 — Literal String Interpolation Python，字面字符串插值&lt;/div&gt;
&lt;div&gt;PEP 525 — Asynchronous Generators，异步生成器&lt;/div&gt;
&lt;div&gt;PEP 572 — Assignment Expressions，表达式内赋值（最具争议）&lt;/div&gt;
&lt;div&gt;PEP 3105 — Make print a function，print改为函数&lt;/div&gt;
&lt;div&gt;PEP 3115 — Metaclasses in Python 3000，元类&lt;/div&gt;
&lt;div&gt;PEP 3120 — Using UTF-8 as the default source encoding，默认UTF-8&lt;/div&gt;
&lt;div&gt;PEP 3333 — Python Web Server Gateway Interface v1.0.1，Web开发&lt;/div&gt;
&lt;div&gt;PEP 8000 — Python Language Governance Proposal Overview，GvR老爹推出决策层后，事关新决策方案&lt;/div&gt;
&lt;div&gt;关于PEP，知乎上有两个问题，推荐大家关注：哪些PEP值得阅读、如何看待PEP 572。&lt;/div&gt;
&lt;h2&gt;对PEP的贡献&lt;/h2&gt;
&lt;div&gt;虽无确切数据作证，我国Python开发者的数量应该比任何国家都多。然而，纵观PEP 0 里面列举的200多个PEP作者，我只看到了一个像是汉语拼音的国人名字（不排除看漏，或者使用了英文名的）。反差真是太大了。&lt;/div&gt;
&lt;div&gt;我特别希望，国内的Python黑客们的名字，能越来越多地出现在那个列表里，出现在Python核心开发者的列表里。&lt;/div&gt;
&lt;div&gt;此外，关于对PEP的贡献，还有一种很有效的方式，就是将PEP翻译成中文，造福国内的Python学习社区。经过一番搜索，我还没有看到系统性翻译PEP的项目，只找到了零星的对于某个PEP的翻译。&lt;/div&gt;
&lt;div&gt;最后，表达一下我的私心：&lt;/div&gt;
&lt;div&gt;（1）希望本文能给大家带来知识和见识的增长，激发一些小伙伴的学习热情&lt;/div&gt;
&lt;div&gt;（2）希望有小伙伴去翻译更多的PEP，造福Python的中文学习社区&lt;/div&gt;
&lt;div&gt;update：我建了个 &lt;a href=&quot;https://github.com/chinesehuazhou/peps-cn&quot;&gt;PEP 中文翻译项目&lt;/a&gt;，欢迎在 Github 上支持下&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python猫荐书系列之三：《黑客与画家》</title>
            <link>https://pythoncat.top/posts/2018-11-04-book3/</link>
            <guid>https://pythoncat.top/posts/2018-11-04-book3/</guid>
            <pubDate>Sun, 04 Nov 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;上一期荐书时，我说了有一个巧合，本来计划这期揭晓的，但是，现在有了这个插队的黑客，所以那个巧合就顺延到下期了。今期这本书，说起来也有巧合，我刚读完这本书，本计划下期荐书写写，但是，正好Rocky0429同学也在推荐，于是，我决定先推荐它了。&lt;/div&gt;
&lt;div&gt;这本书的英文名为《Hackers and Painters》，出版于2004年，跟上期的《The Hitchhiker’s Guide to the Galaxy》一样，出自O’Reilly出版社。中文名《黑客与画家》，出版于2011年4月，二版于2013年。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;出版年份有点久了，但是书的内容不仅一点不过时，甚至有些内容太超前了，现在的读者仍不能完全接受。这就是经典书籍的魅力吧，也是我为啥“墙裂推荐”给大家的原因。&lt;/div&gt;
&lt;h2&gt;作者与译者&lt;/h2&gt;
&lt;div&gt;作者&lt;code&gt;保罗•格雷厄姆&lt;/code&gt;是哈佛大学计算机博士，是个著名的Lisp程序员，他和同伴开发了第一个互联网应用程序Viaweb（1995）。不过在我国，他最为人知的身份是Y Combinator的联合创始人，还因此有着“创业教父”的美称。&lt;/div&gt;
&lt;div&gt;Y Combinator成立于2005年，是美国最著名的创业孵化器之一，已经投资超过1000家创业公司，其中的佼佼者有：Dropbox、Airbnb、Stripe 和 Reddit。2018年8月15日，Y Combinator宣布正式进入中国，而担任其中国创始人及首席执行官的正是百度的前明星CEO陆奇。相信不久，国人会看到这家公司给创投界带来的影响。&lt;/div&gt;
&lt;div&gt;译者&lt;code&gt;阮一峰&lt;/code&gt;是上海财经大学世界经济学博士，曾在上海金融学院执教，现在是支付宝的Node/JavaScript工程师。他是一个互联网老鸟，从2003年开始写“网志”，至今创作了1700+文章，是无数人的互联网启蒙领路人。&lt;/div&gt;
&lt;div&gt;阮老师是格雷厄姆的大粉丝，他这样评价自己的偶像：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;但是，在我眼里，除了程序员和创业导师，他更像一个思想家。网络技术将如何影响这个世界的未来，没有人说得比他更深刻。说实话，我在网上看了这么多人的文章，在思想方面，他的文章对我影响最大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;这本书评价如何？&lt;/h2&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;阮一峰在译者序里这样推介这本书：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;作者最大的目的就是，通过这本书让普通读者理解我们所处的这个计算机时代。…作者试图从许许多多不同的方面解释这个时代的内在脉络，揭示它的发展轨迹，帮助你看清我们现在的位置和将来的方向。…我们的时代是程序员主导的时代，而伟大的程序员就是黑客。本书就是帮助你了解黑客、从而理解这个时代的一把钥匙。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;再版序里这样说：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;他是怎么做到的，让一本技术类书籍吸引10年后的读者？后来，我总结出两个原因。第一，他写的不是技术，而是技术背后的思想。就像数学一样，正确的思想是不会过时的。第二，他的着眼点是长远的未来。文章内容主要不是分析现状，更不是总结过去，而是展望未来，以未来指导现在。举例来说，第11章《一百年后的编程语言》就是研究一百年后人们会怎么编程，从而推导到我们现在应该如何编程。除了他以外，我没见过其他人有这种视角。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;书籍出版以来，一直好评如潮。下面摘录几则豆瓣书评：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;单单“书呆子”那篇文章就值得你买下这本书。——@Hammer_&lt;/p&gt;
&lt;p&gt;四月份读的最好的一本书是 Paul Graham 的大作 《黑客与画家》(中文版)，这是一本能引发技术人思考的佳作，真正意义上的黑客精神、创业(Start-up)、编程语言，是这本技术散文集的三个主题。阮一峰的翻译很到位，很喜欢他的译文。——@Fenng&lt;/p&gt;
&lt;p&gt;作者试图回答的问题：如何好奇地探索这个世界，做喜欢的事情，并阳光地获取财富？ 作者回答得怎么样：非常棒 评价：创业的书，或讲究细节，比如如何撰写商务计划书；或摆资历，比如我的成功如何复制；或讲大道理，用一个术语串起整本书，你不服还不行，比如长尾比如蓝海比如紫牛；或写小说，比如如何从小秘到跨国公司CEO；或吹牛，比如全中国最穷小伙子如何发财。 有没有一本，心平气和，不讲细节不摆资历不讲大道理不写小说不吹牛的创业书呢？ 有，这就是Paul Graham的文集——《黑客与画家》。——@阳志平&lt;/p&gt;
&lt;p&gt;我做笔记和划重点的地方大概占到书的30%。每个段落里忽闪忽闪的思维火花，都在告诉我们什么叫「远见卓识」。在被说服后常常惊讶他是怎么想到那个角度和比喻的。不要被书中大量IT案例阻隔，事实上它适合所有人阅读，让你重新思考要过什么样的生活，或如何尽快过上你想有的生活。——@大头绿豆&lt;/p&gt;
&lt;p&gt;本来以为是一本编程书，没想到竟然是一本方方面面的哲学书。不要被书名的黑客两字吓到，放下偏见来听一个知识渊博的老牌黑客对教育、社会、公司等不同领域的深入探讨，受益匪浅。当然，对于计算机编程思维与编程语言的哲学也有独到的见解，不明觉厉……——@莱斯基&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;我读到了什么？&lt;/h2&gt;
&lt;div&gt;全书15章，可以粗略地划分为三部分。第一部分（1-4），解释黑客是什么、黑客与画家、黑客的成长与世界观；第二部分（5-9），讲到黑客创业、财富观、什么是好设计；第三部分（10-15）是对编程语言的思考。&lt;/div&gt;
&lt;div&gt;对某些读者来说，最触动的也许是“黑客”部分、或者是“创业与财富”的话题，而对我而言，最醍醐灌顶的就是讲编程语言的这几章了。比如，上一篇推文《&lt;a href=&quot;https://mp.weixin.qq.com/s/Whrd6NiD4Y2Z-YSCy4XJ1w&quot;&gt;详解Python拼接字符串的七种方式&lt;/a&gt;》里，就提到了作者的“预言”：要取消字符串和整数这两种基础的数据类型。&lt;/div&gt;
&lt;div&gt;格雷厄姆认为，编程语言就像生物物种一样，存在进化的脉络，有些进化的分支是死胡同。当时，正是JAVA如日中天的时候（现在仍霸占各类榜单首位），他却说了个“未必正确”的猜测：JAVA进化之路已经走到了尽头。&lt;/div&gt;
&lt;div&gt;作者最主要的洞见就在于，通过设想100年后的编程语言，来思考今天如何设计、使用编程语言。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;我的判断是，那些内核最小、最干净的编程语言才会存在于进化的主干上。一种语言的内核设计得越小、越干净，它的生命力就越顽强。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;在作者眼里，某些尽力提升计算机运行效率的行为是过早优化、并不可取，相反地，他提倡要尽力消耗硬件性能。他提倡“好的浪费”，相信未来的硬件基础足够我们浪费。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;随着技术的发展，每一代人都在做上一代人觉得很浪费的事情。30年前的人要是看到我们今天如此随意地使用长途电话，一定会感到震惊。100年前的人要是看到一个普通的包裹竟然也能享受一天内从波士顿发件、途经孟菲斯、抵达纽约的待遇，恐怕就要更震惊了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;这种大格局的视野，令我叹服！作者的眼界还不至于此，他说：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;一百年后的程序员最需要的编程语言就是可以让你毫不费力地写出程序第一版的编程语言，哪怕它的效率低下得惊人（至少按我们今天的眼光来看是如此）。…浪费程序员的时间而不是浪费机器的时间才是真正的无效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;计算机程序在本质上是一种描述性语言，“以书面形式记录计算机应该如何解决你的问题”。那么，很明显它进化的方向就应该是，用越少、越简单的描述来解决越多、越复杂的问题。&lt;/div&gt;
&lt;div&gt;一百年前，打字是一门专业的技能，打字员是一种职业；今天，任何人都可以轻松在移动端打字、甚至语音转文字，人人都是“打字员”。&lt;/div&gt;
&lt;div&gt;今天，编程是一门专业的技能，程序员是一种职业，那么一百年后呢，大概率是任何人都可以随时编程、或者只是表达然后由智能AI去完成编程工作，人人都是程序员！&lt;/div&gt;
&lt;div&gt;人们常说一个梗——“我有个好点子，就差一个程序员了”。读完这本书，我有一个大胆的猜测，一百年后，这个梗会变成——“我是一个程序员，就差一个好点子了”。&lt;/div&gt;
&lt;h2&gt;金句摘录&lt;/h2&gt;
&lt;div&gt;我在阅读时划了很多笔记，随便分享几条给大家感受一下（这是一个技术类公众号，我就放和编程相关的了，其它话题的内容，请你阅读书籍探索）：&lt;/div&gt;
&lt;div&gt;“计算机程序只是文本而已。你选择什么语言，决定了你能说什么话。编程语言就是程序员的思维方式。因此很自然，编程语言对程序员的思想有巨大的影响。”&lt;/div&gt;
&lt;div&gt;“编程语言是用来帮助思考程序的，而不是用来表达你已经想好的程序。它应该是一支铅笔，而不是一支钢笔。”&lt;/div&gt;
&lt;div&gt;“黑客的出发点是原创，最终得到一个优美的结果；而科学家的出发点是别人优美的结果，最终得到原创性。”&lt;/div&gt;
&lt;div&gt;“一种好的编程语言，应该像油画颜料一样，能够使得我们很从容地改变想法。”&lt;/div&gt;
&lt;div&gt;“源代码也应该可以自己解释自己。如果我只能让别人记住一句关于编程的名言，那么这句名言就是《计算机程序的结构与解释》一书的卷首语：程序写出来是给人看的，附带能在机器上运行。”&lt;/div&gt;
&lt;div&gt;“允许你做某事的语言肯定不差于强迫你做某事的语言。所以，至少在这方面我们可以得到明确的结论：你应该使用允许你面向对象编程的语言。至于你最后到底用不用则是另外一个问题了。”&lt;/div&gt;
&lt;div&gt;往期荐书回顾：&lt;/div&gt;
&lt;div&gt;第一期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/JnoYojDsNHYkpibSfF3hOg&quot;&gt;编写高质量代码改善 Python 程序的 91 个建议&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;第二期：《&lt;a href=&quot;https://mp.weixin.qq.com/s/9RonAqwCXo_lganYvLHgVw&quot;&gt;Python最佳实践指南&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;相关链接：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://paulgraham.com/&quot;&gt;http://paulgraham.com/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://www.ruanyifeng.com/home.html&quot;&gt;http://www.ruanyifeng.com/home.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;阮老师曾经为这本书做了一个专题网页，不过现已无法访问，我收集了几篇文章，方便大家做关联阅读。&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2009/12/i_will_translate_paul_graham.html&quot;&gt;http://www.ruanyifeng.com/blog/2009/12/i_will_translate_paul_graham.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/04/on_hacker.html&quot;&gt;http://www.ruanyifeng.com/blog/2011/04/on_hacker.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/04/on_book_price.html&quot;&gt;http://www.ruanyifeng.com/blog/2011/04/on_book_price.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/12/paul_graham_the_disruptor_in_the_valley.html&quot;&gt;http://www.ruanyifeng.com/blog/2010/12/paul_graham_the_disruptor_in_the_valley.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/11/being-toward-future.html&quot;&gt;http://www.ruanyifeng.com/blog/2013/11/being-toward-future.html&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>详解 Python 拼接字符串的七种方式</title>
            <link>https://pythoncat.top/posts/2018-11-01-string/</link>
            <guid>https://pythoncat.top/posts/2018-11-01-string/</guid>
            <description>介绍了Python中七种拼接字符串的方法，并对其优劣点逐一讲解</description>
            <pubDate>Thu, 01 Nov 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;推荐语：本文详细介绍了Python中七种拼接字符串的方法，并对其优劣点逐一讲解。&lt;/div&gt;
&lt;div&gt;忘了在哪看到一位编程大牛调侃，他说程序员每天就做两件事，其中之一就是处理字符串。相信不少同学会有同感。&lt;/div&gt;
&lt;div&gt;几乎任何一种编程语言，都把字符串列为最基础和不可或缺的数据类型。而拼接字符串是必备的一种技能。今天，我跟大家一起来学习Python拼接字符串的七种方式。&lt;/div&gt;
&lt;div&gt;1、来自C语言的%方式&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;%s %s&apos;&lt;/span&gt; &lt;span&gt;%&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;Hello&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;world&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; Hello world&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;%号格式化字符串的方式继承自古老的C语言，这在很多编程语言都有类似的实现。上例的%s是一个占位符，它仅代表一段字符串，并不是拼接的实际内容。实际的拼接内容在一个单独的%号后面，放在一个元组里。&lt;/div&gt;
&lt;div&gt;类似的占位符还有：%d（代表一个整数）、%f（代表一个浮点数）、%x（代表一个16进制数），等等。%占位符既是这种拼接方式的特点，同时也是其限制，因为每种占位符都有特定意义，实际使用起来太麻烦了。&lt;/div&gt;
&lt;div&gt;2、format()拼接方式&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 简洁版&lt;/span&gt;
s1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;Hello {}! My name is {}.&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;World&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;Python猫&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s1&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello World! My name &lt;span&gt;is&lt;/span&gt; Python猫&lt;span&gt;.&lt;/span&gt;

&lt;span&gt;# 对号入座版&lt;/span&gt;
s2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;Hello {0}! My name is {1}.&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;World&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;Python猫&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
s3 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;Hello {name1}! My name is {name2}.&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name1&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;World&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; name2&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;Python猫&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s2&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello World! My name &lt;span&gt;is&lt;/span&gt; Python猫&lt;span&gt;.&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s3&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello World! My name &lt;span&gt;is&lt;/span&gt; Python猫&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这种方式使用花括号{}做占位符，在format方法中再转入实际的拼接值。容易看出，它实际上是对%号拼接方式的改进。这种方式在Python2.6中开始引入。&lt;/div&gt;
&lt;div&gt;上例中，简洁版的花括号中无内容，缺点是容易弄错次序。对号入座版主要有两种，一种传入序列号，一种则使用key-value的方式。实战中，我们更推荐后一种，既不会数错次序，又更直观可读。&lt;/div&gt;
&lt;div&gt;3、() 类似元组方式&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;s_tuple &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;Hello&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos; &apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;world&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
s_like_tuple &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;Hello&apos;&lt;/span&gt; &lt;span&gt;&apos; &apos;&lt;/span&gt; &lt;span&gt;&apos;world&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s_tuple&lt;span&gt;)&lt;/span&gt; 
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;Hello&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos; &apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;world&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s_like_tuple&lt;span&gt;)&lt;/span&gt; 
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello world

&lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s_like_tuple&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;注意，上例中s_like_tuple并不是一个元组，因为元素间没有逗号分隔符，这些元素间可以用空格间隔，也可以不要空格。使用type()查看，发现它就是一个str类型。我没查到这是啥原因，猜测或许()括号中的内容是被Python优化处理了。&lt;/div&gt;
&lt;div&gt;这种方式看起来很快捷，但是，括号()内要求元素是真实字符串，不能混用变量，所以不够灵活。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 多元素时，不支持有变量&lt;/span&gt;
str_1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;Hello&apos;&lt;/span&gt;
str_2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;str_1 &lt;span&gt;&apos;world&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; SyntaxError&lt;span&gt;:&lt;/span&gt; invalid syntax
str_3 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;str_1 str_1&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; SyntaxError&lt;span&gt;:&lt;/span&gt; invalid syntax
&lt;span&gt;# 但是下面写法不会报错&lt;/span&gt;
str_4 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;str_1&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;4、面向对象模板拼接&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; string &lt;span&gt;import&lt;/span&gt; Template
s &lt;span&gt;=&lt;/span&gt; Template&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;${s1} ${s2}!&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; 
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;.&lt;/span&gt;safe_substitute&lt;span&gt;(&lt;/span&gt;s1&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;Hello&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;s2&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;world&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; 
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; Hello world!&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;说实话，我不喜欢这种实现方式。浓浓的一股被面向对象思想毒害的臭味。&lt;/div&gt;
&lt;div&gt;就不多说了。&lt;/div&gt;
&lt;div&gt;5、常用的+号方式&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;str_1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;Hello world！ &apos;&lt;/span&gt; 
str_2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;My name is Python猫.&apos;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;str_1 &lt;span&gt;+&lt;/span&gt; str_2&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello world！ My name &lt;span&gt;is&lt;/span&gt; Python猫&lt;span&gt;.&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;str_1&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello world！ &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这种方式最常用、直观、易懂，是入门级的实现方式。但是，它也存在两处让人容易犯错的地方。&lt;/div&gt;
&lt;div&gt;首先，新入门编程的同学容易犯错，他们不知道字符串是不可变类型，新的字符串会独占一块新的内存，而原来的字符串保持不变。上例中，拼接前有两段字符串，拼接后实际有三段字符串。&lt;/div&gt;
&lt;div&gt;其次，一些有经验的老程序员也容易犯错，他们以为当拼接次数不超过3时，使用+号连接符就会比其它方式快（ps：不少Python教程都是如此建议），但这没有任何合理根据。&lt;/div&gt;
&lt;div&gt;事实上，在拼接短的字面值时，由于CPython中的 &lt;code&gt;常数折叠&lt;/code&gt; （constant folding）功能，这些字面值会被转换成更短的形式，例如’a’+‘b’+‘c’ 被转换成’abc’，‘hello’+‘world’也会被转换成’hello world’。这种转换是在编译期完成的，而到了运行期时就不会再发生任何拼接操作，因此会加快整体计算的速度。&lt;/div&gt;
&lt;div&gt;常数折叠优化有一个限度，它要求拼接结果的长度不超过20。所以，&lt;strong&gt;当拼接的最终字符串长度不超过20时，+号操作符的方式，会比后面提到的join等方式快得多，这与+号的使用次数无关。&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;题外话：你是否觉得20这个数字很熟悉呢？没错，我们之前在《&lt;a href=&quot;https://mp.weixin.qq.com/s/vCs6QvJU2J6L0rIWDKQPUQ&quot;&gt;Python中的“特权种族”是什么？&lt;/a&gt;》中提到过，字符串类的特权种族也是以20为限。当时也有一个例子，展示了编译期和运行期的区别，建议你去回看。&lt;/div&gt;
&lt;div&gt;6、join()拼接方式&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;str_list &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;Hello&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;world&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
str_join1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos; &apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;join&lt;span&gt;(&lt;/span&gt;str_list&lt;span&gt;)&lt;/span&gt;
str_join2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;-&apos;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;join&lt;span&gt;(&lt;/span&gt;str_list&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;str_join1&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello world
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;str_join2&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello&lt;span&gt;-&lt;/span&gt;world&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;str对象自带的join()方法，接受一个序列参数，可以实现拼接。拼接时，元素若不是字符串，需要先转换一下。可以看出，这种方法比较适用于连接序列对象中（例如列表）的元素，并设置统一的间隔符。&lt;/div&gt;
&lt;div&gt;当拼接长度超过20时，这种方式基本上是首选。不过，它的缺点就是，不适合进行零散片段的、不处于序列集合的元素拼接。&lt;/div&gt;
&lt;div&gt;7、f-string方式&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;world&apos;&lt;/span&gt;
myname &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&apos;python_cat&apos;&lt;/span&gt;
words &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&lt;span&gt;f&apos;Hello &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;name&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;. My name is &lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;myname&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;.&apos;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;words&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; Hello world&lt;span&gt;.&lt;/span&gt; My name &lt;span&gt;is&lt;/span&gt; python_cat&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;f-string方式出自PEP 498（Literal String Interpolation，字面字符串插值），从Python3.6版本引入。其特点是在字符串前加 f 标识，字符串中间则用花括号{}包裹其它字符串变量。&lt;/div&gt;
&lt;div&gt;这种方式在可读性上秒杀format()方式，处理长字符串的拼接时，速度与join()方法相当。&lt;/div&gt;
&lt;div&gt;尽管如此，这种方式与其它某些编程语言相比，还是欠优雅，因为它引入了一个 f 标识。而其它某些程序语言可以更简练，比如：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# bash shell&lt;/span&gt;
name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;world&quot;&lt;/span&gt;
myname&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;python_cat&quot;&lt;/span&gt;
words&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;Hello ${name}. My name is ${myname}.&quot;&lt;/span&gt;
echo $words
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello world&lt;span&gt;.&lt;/span&gt; My name &lt;span&gt;is&lt;/span&gt; python_cat&lt;span&gt;.&lt;/span&gt;

&lt;span&gt;# perl&lt;/span&gt;
my $apples &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;I have $apples apples.\n&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

&lt;span&gt;# Javascript&lt;/span&gt;
var apples &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
console&lt;span&gt;.&lt;/span&gt;log&lt;span&gt;(&lt;/span&gt;`I have $&lt;span&gt;{&lt;/span&gt;apples&lt;span&gt;}&lt;/span&gt; apples`&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;f-string方式怎么看都依然像个半成品。我查到有几个与字符串相关的PEP（链接在文末），从2000年的PEP 215，到2002年的PEP 292，里面已经提到了其它编程语言的这种插值实现方式，没想到Python最终只出来了个Template，好不容易到2015年的PEP 498，就是这货了。&lt;/div&gt;
&lt;div&gt;我依然不大喜欢这种方式。希望不久，Python会推出更加优秀的插值实现方式吧。&lt;/div&gt;
&lt;div&gt;总结一下，我们前面说的“字符串拼接”，其实是从结果上理解。若从实现原理上划分的话，我们可以将这些方法划分出三种类型：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;格式化类：%、format()、template&lt;/p&gt;
&lt;p&gt;拼接类：+、()、join()&lt;/p&gt;
&lt;p&gt;插值类：f-string&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;当要处理字符串列表等序列结构时，采用join()方式；拼接长度不超过20时，选用+号操作符方式；长度超过20的情况，高版本选用f-string，低版本时看情况使用format()或join()方式。&lt;/div&gt;
&lt;h2&gt;One more thing：&lt;/h2&gt;
&lt;div&gt;你以为这就要结束了？&lt;/div&gt;
&lt;div&gt;图样！这不是我的风格！&lt;/div&gt;
&lt;div&gt;我的风格是发散思考、系统思考、以及追求编程哲学的思考。&lt;/div&gt;
&lt;div&gt;最近，我在读《黑客与画家》，保罗•格雷厄姆在书中提出了这个问题：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;从语义上看，字符串或多或少可以理解成列表的一个子集，其中的每一个元素都是字符。那么，为什么还需要把字符串单列为一种数据结构呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;作者认为“编程语言设置字符串似乎就是一个过早优化的例子”，这个观点令我大为震撼！前文提到的七种拼接字符串的方法瞬间变成纸，薄得似乎一触就破。&lt;/div&gt;
&lt;div&gt;但是，作者认为这还不够，他还有更惊人想法：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;还有比这更惊人的预言。在逻辑上其实不需要对整数设置单独的表示法，因为可以把它们也看作列表，整数n可以用一个n元素的列表表示。… 编程语言会发展到放弃基本数据类型之一的整数这一步吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;不知道你读完这段话，有何感想。我在阅读时，虽然有上下文语境的铺垫，还是惊叹不已。&lt;/div&gt;
&lt;div&gt;附几个相关PEP链接：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-0215/&quot;&gt;https://www.python.org/dev/peps/pep-0215/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-0292/&quot;&gt;https://www.python.org/dev/peps/pep-0292/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-3101/&quot;&gt;https://www.python.org/dev/peps/pep-3101/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-0498/&quot;&gt;https://www.python.org/dev/peps/pep-0498/&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 对象的身份迷思：从全体公民到万物皆数</title>
            <link>https://pythoncat.top/posts/2018-10-27-object/</link>
            <guid>https://pythoncat.top/posts/2018-10-27-object/</guid>
            <description>当猫开始思考 Python 与人类的哲学问题时……</description>
            <pubDate>Sat, 27 Oct 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;这么久以来，我终于确认了一件事，那就是不管是人也好，还是猫也好，常常会忘了想自己当下的身份位置，以及曾经的身份位置。&lt;/div&gt;
&lt;div&gt;这个现象在我身上，表现出了双倍分量的严重。这种时刻，我就会想起阿尔法猫，以及她识破我身份的那个遥远的午后。&lt;/div&gt;
&lt;div&gt;阿尔法猫还没有踪影，她的谜题，还在指引我。&lt;/div&gt;
&lt;div&gt;学习Python之后，我明显感觉到了自己的变化，当然有时候是被迫的，因为那些生理上的矛盾冲突得厉害。&lt;/div&gt;
&lt;div&gt;毕竟，你应该知道，夜行猫和日间人的分界是清晰的。日夜的颠倒，对人和对猫，是双倍的压榨。说来你别不信，昨晚当瞄见明亮的月球的时候，一刹那恍惚，我还误以为自己回到了喵星的清晨。&lt;/div&gt;
&lt;div&gt;大概是想家了吧。地球上美好的事物很多，但我至今仍不习惯的就是它公转的速度太快了，不久就会是寒冷的冬天了。想我的暖炉了，喵。&lt;/div&gt;
&lt;div&gt;先不说我啦，来说说我发现的Python对象的身份问题吧。&lt;/div&gt;
&lt;div&gt;我对身份的话题特别感兴趣，也许是因为我独特的身份吧。但是，正因为独特的视角，我敢说发现了所有人类都没有发现的真相。&lt;/div&gt;
&lt;div&gt;我即将说出来的东西，也许你本以为知道了，或者你本以为很熟悉，但是，经过我的分析，我相信你会得到不一样的感悟，从此以后，你对Python的理解也会更深一步。&lt;/div&gt;
&lt;h2&gt;1、全体公民与特权种族&lt;/h2&gt;
&lt;div&gt;在某种意义上说，Python世界是普遍公平的，因为所有的子民都是对象“公民”，这在任何一个现实社会里，乃至于在虚拟的国度里，都是极其罕见的。对象们分属在五大部落里（数字、字符串、列表、元祖、字典），各有所长，各司其职，协作共处，通婚繁衍。&lt;/div&gt;
&lt;div&gt;还有一点难得的是，他们没有受到愚民政策的对待，全民都享有思想自由，还习得了超便利的自省能力。人能自知，这能力弥足珍贵。&lt;/div&gt;
&lt;div&gt;虽然在这个世界里，不会时常出现岗哨拦阻，但在任何有需要的时候，他们都可以自证清白，id() 和 type() 是一种通行语言，你不需要翻译来对接。而对于更进一步的询问，长得相似的两个对象只需一个简明的判断句，就能区分清楚。请你看一段对话：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;Object1&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;
Object2&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;2018&quot;&lt;/span&gt;
&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Object1&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;2399282764784&lt;/span&gt;
&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Object2&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;2399281922600&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Object1&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Object2&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;
Object1 &lt;span&gt;is&lt;/span&gt; Object2 &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;全体皆公民，这项天赋权力让我对Python产生了良好的印象。不过，随着对它的认识加深，我发现它还暗地里制定了很多“效率优先”的规则。&lt;/div&gt;
&lt;div&gt;最明显的例子就是——“特权种族”。（参见：《&lt;a href=&quot;https://mp.weixin.qq.com/s/vCs6QvJU2J6L0rIWDKQPUQ&quot;&gt;Python中的“特权种族”是什么？&lt;/a&gt; 》）从现有的证据来看，特权种族至少包括了：一些数值较小的数字对象（区间：[-5,256]）、布尔值对象、None对象、较短的字符串对象（长度不超过20，且仅包括下划线、数字、字母的字符串）等等，还不知道这份名单漏了谁。&lt;/div&gt;
&lt;div&gt;效率优先的规则允许这些对象传承内存地址，也就是说，当一个“祖先”对象抢占了一块内存地盘后，所有它那一脉的“子孙后代”都会继承它的遗产（视为同一个对象）。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;a&lt;span&gt;=&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;
b&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;
&lt;span&gt;# c与a共用id，d另立门户&lt;/span&gt;
c&lt;span&gt;=&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;
d&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;
&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;d&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;设想一下，两个祖先（a和b）占了相邻的两块内存，一个可以与它的“后代”共用内存，一个却只能让“后代”另立门户；当它们走完自己的生命周期后，b会马上被当垃圾回收，内存地址遗产被剥夺，然而a却形灭而实存，荫庇后世。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;Python为这些对象倾斜资源，也就是为某种阶层固化提供了合法性。划分的依据是因为它们比较常用，共用内存就意味着减少开支，提高内存使用效率。&lt;/div&gt;
&lt;div&gt;这就是Python有趣的地方了，一面是全体公民，一面是特权种族，组成了看似矛盾的二元对立结构。&lt;/div&gt;
&lt;h2&gt;2、官方名片与私人名片&lt;/h2&gt;
&lt;div&gt;除了上面的群体性身份外，我发现Python中也存在着个体身份的二元结构。&lt;/div&gt;
&lt;div&gt;这就是&lt;code&gt;__repr__()&lt;/code&gt; 和&lt;code&gt;__str__()&lt;/code&gt; 的关系了。如你所知，这是Python的两个魔法方法，其对应的内置函数是repr() 和 str()。对于对象x，有x.&lt;code&gt;__repr__()&lt;/code&gt; 等价于 repr(x)，同理，x.&lt;code&gt;__str__()&lt;/code&gt; 等价于 str(x)。&lt;/div&gt;
&lt;div&gt;它们的主要用途在于，返回对象的字符串格式。用法示例：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;repr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&apos;2018&apos;&lt;/span&gt;
&lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&apos;2018&apos;&lt;/span&gt;
&lt;span&gt;repr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&apos;[1, 2, 3]&apos;&lt;/span&gt;
&lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&apos;[1, 2, 3]&apos;&lt;/span&gt;

words &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Hello pythonCat!\n&quot;&lt;/span&gt;
&lt;span&gt;repr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;words&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&apos;Hello pythonCat!\n&apos;&lt;/span&gt;
&lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;words&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&apos;Hello pythonCat!\n&apos;&lt;/span&gt;
&lt;span&gt;# 结合print，注意换行符\n&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;repr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;words&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&apos;Hello pythonCat!\n&apos;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;words&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; 
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello pythonCat! &lt;span&gt;# 再加换行&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;一个对象的字符串形式就是它的“脸面”，是向他人介绍自己的一张名片。前面提到过，Python世界有五大部落，这些部落的原住民们与生俱来就拥有这两张名片。&lt;/div&gt;
&lt;div&gt;对于原住民来说，这两张名片似乎没啥区别，除了在使用打印函数的时候，在换行符等用法上会有不同。&lt;/div&gt;
&lt;div&gt;而对于外来人口（例如，自定义的类），如果它没有定做名片（即实现&lt;code&gt;__repr__()&lt;/code&gt; 和&lt;code&gt;__str__()&lt;/code&gt; 方法）的话，其默认的名片就会是类名及内存地址，如下所示。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt;name&lt;span&gt;,&lt;/span&gt;sex&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
         self&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; name
         self&lt;span&gt;.&lt;/span&gt;sex &lt;span&gt;=&lt;/span&gt; sex

me &lt;span&gt;=&lt;/span&gt; Person&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;pythonCat&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;male&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;repr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;me&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&apos;&amp;lt;__main__.Person object at 0x0000022EA8D7ED68&amp;gt;&apos;&lt;/span&gt;
&lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;me&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&apos;&amp;lt;__main__.Person object at 0x0000022EA8D7ED68&amp;gt;&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;事实上，repr()返回的是对象的官方名片，通常人们会说，这张名片是给机器阅读的。本质上，它就是一个对象的代码表示形式，可以用来重新构造这个对象。通过eval()函数，你可以利用这张名片，重新构造出这个对象。&lt;/div&gt;
&lt;div&gt;eval()函数是个内置函数，它将字符串str当成有效的表达式来求值并返回计算结果。也就是eval(repr(x))==x，示例如下：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;cat&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
c &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&apos;pythonCat&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;sex&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&apos;male&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;eval&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;repr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;eval&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;repr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;cat&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;eval&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;repr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;c&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;pythonCat&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;sex&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;male&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;相对地，str()得到的是对象的私人名片，通常有更友好的表现形式，因为它是为人类阅读而设计的。&lt;/div&gt;
&lt;div&gt;如果一个对象公民没有私人名片，那Python默认会调用它的官方名片。因为这个机制，很多人建议如果要定制一个名片，最好是定制官方那个。但是我却不认同，我认为应该定制私人的那个，因为这样发挥空间更大。不张扬个性，毋宁死。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt;name&lt;span&gt;,&lt;/span&gt;sex&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
         self&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; name
         self&lt;span&gt;.&lt;/span&gt;sex &lt;span&gt;=&lt;/span&gt; sex
     &lt;span&gt;# 定制私人名片&lt;/span&gt;
     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
     	&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;{} is an elegant creature!&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;name&lt;span&gt;)&lt;/span&gt;

me &lt;span&gt;=&lt;/span&gt; Person&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;pythonCat&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;male&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;repr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;me&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&apos;&amp;lt;__main__.Person object at 0x000002E6845AC390&amp;gt;&apos;&lt;/span&gt;
&lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;me&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&apos;pythonCat is an elegant creature!&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;在《The Zen of Python》里第一句话就是：Beautiful is better than ugly。在我看来，定制私人名片要比定制官方名片更优美。能够为自己带盐，想想就觉得鸡冻啦！&lt;/div&gt;
&lt;h2&gt;3、何为真假，万物皆数&lt;/h2&gt;
&lt;div&gt;以上说法，不管是全体公民身份与特权种族身份，还是官方名片与私人名片，多少带进了我浅薄的社会经验的偏见。我起初很为一方鸣不平，为一种讨巧的做法鸣得意，但是，现在当我知道Python中另一种更不为人知的身份现象的时候，我就释然了。&lt;/div&gt;
&lt;div&gt;我接下来要揭示的身份话题，已经超越了社会学和心理学范畴，进入了一种哲学的思想疆域。&lt;/div&gt;
&lt;div&gt;前方高能！&lt;/div&gt;
&lt;div&gt;前方高能！&lt;/div&gt;
&lt;div&gt;前方高能！&lt;/div&gt;
&lt;div&gt;首先，来做一个基础知识的铺垫。Python有一个令大部分编程语言都忘尘莫及的特性，那就是，所有对象都可以用于做真假判断。&lt;/div&gt;
&lt;div&gt;在做判断的时候，以下情况都视为假（False）：None、数值的零值、空序列（如空字符串&quot;&quot;、空列表[]、空元祖() ）、空集合{} 等等。除此之外，一般对象都可以作为真值（True）来使用。来看示例：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;list&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;# 即if True&lt;/span&gt;
	&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;list is not empty&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
	&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;list is empty&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;list&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; empty&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;判断一个列表是否为空，你不需要写 if len(list) &amp;gt; 0，或者写if list == []，简明的使用方法是 if list 或者 if not list，有物则为真，无物则为假。其它判断情况类似。&lt;/div&gt;
&lt;div&gt;接下来，还是一个铺垫，这次是进阶知识。零值（含整数0、浮点0.0、虚数0j等）可以映射为False，其它非零值映射为True；但是，反过来，False唯一映射整数0，True唯一映射整数1。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;这意味着，可以拿False、True做数学运算。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;True&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;True&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1.0&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;2.0&lt;/span&gt;
&lt;span&gt;False&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;False&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;True&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;True&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;2.5&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;两个铺垫之后，接下来进入正题了。真正的前方高能！&lt;/div&gt;
&lt;div&gt;第一个铺垫告诉我们，对象可以映射成布尔值（True真False假），第二个铺垫告诉我们，布尔值可以映射成数字（1和0）。&lt;/div&gt;
&lt;div&gt;你是否觉察出什么了呢？你是否开始好奇，True和Flase到底是什么东西了呢？这到底是什么原理啊？还有，为什么会存在这样的设定呢？&lt;/div&gt;
&lt;div&gt;见证真相的时刻到了——在Python中，布尔值其实是整数对象的子类。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;
&lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
&lt;span&gt;isinstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;啊！哪有什么真真假假，真假并不是本质的存在，真假其实只是数啊！&lt;/div&gt;
&lt;div&gt;再回看前面两个铺垫，结合起来，那不就是说，所有对象都映射成了数么？&lt;/div&gt;
&lt;div&gt;我不由得想起了2500年前，古希腊哲学家与数学家毕达哥拉斯的哲学命题——&lt;strong&gt;万物皆数&lt;/strong&gt; ！&lt;/div&gt;
&lt;div&gt;难道这竟是Python的哲学么？总不会是一种巧合吧？&lt;/div&gt;
&lt;div&gt;我突然觉得智商不足，思辨受阻。得知布尔值True和False有这一层隐秘的身份，我已兴奋不已，再难对这看似不合现代语境、却又流传千古的思想做出任何揣测。&lt;/div&gt;
&lt;div&gt;哎呀，我猫性发作，突然困得要命，且容我去小憩片刻了~~~&lt;/div&gt;
&lt;div&gt;各位亲爱的读者，在我休息的时候，请你来帮我想想，这到底是什么回事啊？&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python猫荐书系列之二：《Python编程之美：最佳实践指南》</title>
            <link>https://pythoncat.top/posts/2018-10-22-book2/</link>
            <guid>https://pythoncat.top/posts/2018-10-22-book2/</guid>
            <pubDate>Mon, 22 Oct 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;昨天推送了一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/2l_erf55IMvT4Tz0AGWCUQ&quot;&gt;来自Kenneth Reitz大神的建议：避免不必要的面向对象编程&lt;/a&gt;》，文中K神的建议出自他发起和维护的开源项目，这也就是我们今天荐书的主角了。&lt;/div&gt;
&lt;div&gt;在介绍今天的书目之前，我想先跟大家介绍一下这个荐书系列。本系列打算聚焦Python领域的书籍，初期选书的标准主要有两条：一是要有中文版，二是要有免费开源的在线资源，原因很简单，技术书籍由于其特殊性，在线阅读的体验是最佳的，不管是排版、获取源码、摘录笔记还是分享交流，都是最有效果的。至于更新的频率，不会很频繁，预计两周左右推一次。如果你有什么需求或者建议，欢迎到后台给我留言。&lt;/div&gt;
&lt;div&gt;好了，下面请出今天主角《Python最佳实践指南》。&lt;/div&gt;
&lt;div&gt;这本书的英文名是《&lt;a href=&quot;https://pythonguidecn.readthedocs.io/&quot;&gt;The Hitchhiker’s Guide to Python&lt;/a&gt;》，hitchhiker直译是搭便车的旅行者。你也许看过一部著名的科幻电影（或原著）《银河系漫游指南》，它的英文名是《The Hitchhiker’s Guide to the Galaxy》。这本书也许就是在致敬这部电影（或原著）吧。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;书的第一作者是圈内大牛Kenneth Reitz，他最为人知的贡献是requests库，我们尊称一句“K神”。他在2011年发起了一个开源项目，也就是这本书的在线版本，Python社区内积极响应，截止现在有346位提交贡献者，github上收获star数15754个，可谓十分受欢迎了。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;2016年，O’Reilly出版社终于出手了，所以就有了这本书的英文版。我们国内开发者的热情也很高，现在网上就流传了不少译本，文末附了两个在线阅读地址，我主要推荐大家阅读的就是这两个版本。特别是第一个版本，因为翻译得更到位，阅读更友好，而网站做的也挺不错。&lt;/div&gt;
&lt;div&gt;由于文化差异，这本书名若直译过来肯定不恰当，若像电影那般译作《Python世界漫游指南》，似乎还挺有意思的。不过，这两个中文译本都译作了《Python最佳实践指南》。&lt;/div&gt;
&lt;div&gt;书的内容比较零散，涉及从环境搭建、编辑器选择、代码风格、Web应用，再到机器学习、与C/C++库交互等等内容。在“有什么”方面，书中列了很多，在“怎么做”方面，书中其实讲的并不多，很多时候，作者只是给了链接，他希望读者根据指引，自己去完成那些部分的学习。&lt;/div&gt;
&lt;div&gt;从这点来看，一方面，这本书确实不适合初学者用来入门，另一方面，它适合有基础的人来阅读，矫正一些错误的认知，获得一些实践的套路。&lt;/div&gt;
&lt;div&gt;在准备材料的时候，我发现这本书刚在上个月出了中文纸质书，这还真是巧合！（题外话：下一期荐书估计很快会推出，说起来也有一个巧合。至于是啥，先保密。）&lt;/div&gt;
&lt;div&gt;纸书的译者和出版社也许为了销量考虑，在书名上又加了四个字，最后纸书的书名成了《Python编程之美：最佳实践指南》。&lt;/div&gt;
&lt;div&gt;照例先看看豆瓣情况：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;今年9月出版，真是新鲜出炉。评价人数太少，现在还没有分数。标记想读和在读的人数也极少，大概知道这本书的人不算多吧。这期荐书，大概率是最早的荐书之一了。而读者们，你们也是最早知道这本书的人们（之一）了。（PS：出版社同仁，麻烦后台联系我支付推广报酬）&lt;/div&gt;
&lt;div&gt;本书的译者夏永锋/廖邦杰与requests挺有缘，据夏在译者序中说：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;因为对“for humans”理念的认同，也因为我经常使用Requests，所以当Reitz 在GitHub上邀请我翻译Requests 文档中文版时，我欣然接受，和本书的另一位译者邦杰共同翻译了Requests 文档的首个官方中文版。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;因为这两人，我们有理由相信书籍的内容质量以及翻译水准。&lt;/div&gt;
&lt;div&gt;这本纸质书还有一个很值一读的原因：书中有Requests 、Werkzeug 、Flask 等5个知名开源项目的源码阅读内容，并介绍如何通过阅读源码来提升编程技术水平。这些内容，中英文的开源版本都还没有，所以让人挺期待的。&lt;/div&gt;
&lt;div&gt;相关链接：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://docs.python-guide.org&quot;&gt;The Hitchhiker’s Guide to Python:&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Python最佳实践指南（中文）:
&lt;a href=&quot;https://pythoncaff.com/docs/python-guide/2018&quot;&gt;https://pythoncaff.com/docs/python-guide/2018&lt;/a&gt;
&lt;a href=&quot;https://pythonguidecn.readthedocs.io/zh/latest/&quot;&gt;https://pythonguidecn.readthedocs.io/zh/latest/&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;github（英-中）：
&lt;a href=&quot;https://github.com/realpython/python-guide&quot;&gt;https://github.com/realpython/python-guide&lt;/a&gt;
&lt;a href=&quot;https://github.com/Prodesire/Python-Guide-CN&quot;&gt;https://github.com/Prodesire/Python-Guide-CN&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://book.douban.com/subject/30314669&quot;&gt;豆瓣条目&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>来自Kenneth Reitz大神的建议：避免不必要的面向对象编程</title>
            <link>https://pythoncat.top/posts/2018-10-21-pure/</link>
            <guid>https://pythoncat.top/posts/2018-10-21-pure/</guid>
            <description>面向对象就一定是好事么？支持面向对象编程，就一定要时刻这样用么？</description>
            <pubDate>Sun, 21 Oct 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;你也许见过很多人对于Python的评价，他们说Python是“脚本语言”和“胶水语言”，在某种程度上，他们说的是对的。但是，如果你学习过Python，你会知道Python也支持面向对象的编程，更有甚者，在Python中所有东西都是对象。&lt;/div&gt;
&lt;div&gt;事实上，Python有着很强大的支持面向对象编程的能力，比如我们刚介绍过的pathlib模块（点链接回顾），它就是一个用面向对象思想来处理文件系统的模块。&lt;/div&gt;
&lt;div&gt;可以说，Python是“能屈能伸”吧，小打小闹的时候开箱即用轻松上手，认真严肃起来耍大刀也是虎虎生风不遑多让。&lt;/div&gt;
&lt;div&gt;只不过，面向对象就一定是好事么？支持面向对象编程，就一定要时刻这样用么？&lt;/div&gt;
&lt;div&gt;下面段落出自《Python最佳实践指南》，这是由圈内大神Kenneth Reitz发起和维护的开源项目（文末附了相关链接），让我们一起来看看K神提出的建议。&lt;/div&gt;
&lt;div&gt;Kenneth Reitz大神的建议
Python 有时被描述为一种面向对象的编程语言。这可能对大家有些误导，需要加以澄清。&lt;/div&gt;
&lt;div&gt;在 Python 中，所有东西都视为一个对象，并且可以按对象处理。当我们说，函数是“一级”对象，就是将函数视为对象的意思。函数、类、字符串，甚至类型都是 Python 中的对象：像任何对象一样，它们有一个类型，可以作为函数参数传递，并且它们可能有方法和属性。按这种理解， Python 是一种面向对象的语言。&lt;/div&gt;
&lt;div&gt;但是，与 Java 不同， Python 并没有将面向对象的编程作为主要的编程范例来实施。 Python 项目不采用面向对象的方式是完全可行的，即不使用或很少使用类定义、类继承或特定于面向对象编程的任何其他机制。&lt;/div&gt;
&lt;div&gt;此外，从 模块 部分可以看出， Python 处理模块和名称空间的方式为开发人员提供了一种自然的方法来确保抽象层的封装和分离，这两者都是使用面向对象的最常见原因。因此，当业务模型不需要面向对象时， Python 程序员有更大的自由来不使用面向对象编程。&lt;/div&gt;
&lt;div&gt;基于一些因素的考虑，我们应避免不必要的面向对象编程。 当我们想将一些状态和功能粘合在一起时，定义自定义类是很有用的。在函数编程的讨论中，我们指出，“不必要的面向对象编程”这个问题出自方程的“状态”部分。&lt;/div&gt;
&lt;div&gt;在某些体系结构中，例如典型的 web 应用程序，会生成多个 Python 进程实例，以响应可能同时发生的外部请求。在这种情况下，将一些状态保存到实例对象中，意味着保留一些关于世界的静态信息，这很容易出现并发或竞争问题。有时，在对象的初始化（通常用 &lt;strong&gt;init&lt;/strong&gt;() 方法来完成）状态和实际使用对象方法的状态之间，世界信息可能已经改变，保持的状态可能已经过时。例如，一个请求加载了内存中的某一项，并将其标记为由用户读取。而另一个请求同时要求删除该项，这可能发生在第一个进程加载该项之后，然后我们必须将其标记为已删除对象。&lt;/div&gt;
&lt;div&gt;上述以及其他问题引出了这样的想法：使用无状态函数是一种更好的编程范例。&lt;/div&gt;
&lt;div&gt;另一种说法是建议尽可能少的使用具有隐式上下文和副作用的函数和程序。函数的隐式上下文由全局变量和持久层中的数据项（使用方法访问）组成。副作用是指函数对其隐式上下文所做的更改。如果函数会保存或删除全局变量或持久层中的数据，则称它有副作用。&lt;/div&gt;
&lt;div&gt;将有上下文和副作用的函数与逻辑函数（称为纯函数）隔离开来，可以获得以下好处：&lt;/div&gt;
&lt;div&gt;纯函数是确定性的：给定一个固定的输入，输出始终是相同的。&lt;/div&gt;
&lt;div&gt;纯函数需要重构或优化时，更容易更改或替换。&lt;/div&gt;
&lt;div&gt;纯函数更易于使用单元测试进行测试：对于复杂的上下文设置和事后的数据清理的需求更少。&lt;/div&gt;
&lt;div&gt;纯函数更容易操作、修饰和传递。&lt;/div&gt;
&lt;div&gt;总之，针对某些体系结构，由于没有上下文或副作用，纯函数是比类和对象更有效的构建块 。&lt;/div&gt;
&lt;div&gt;显然，面向对象编程在许多情况下是有用的，甚至是必要的，例如在开发图形化桌面应用程序或游戏时，被操作的东西（窗口、按钮、化身、车辆）在计算机内存中具有相对较长的寿命。&lt;/div&gt;
&lt;div&gt;猫猫的思考
以上就是K神的建议。他在后半段提到了纯函数（pure functions），这让猫猫联想到了函数式编程（Functional Programming），但纯函数似乎是一种更具普遍性的东西，它就像是一种数学上的定义。纯函数真的有那么神么？&lt;/div&gt;
&lt;div&gt;于是，猫猫去google了“纯函数”。没想到，排在前面的结果竟然全跟Javascript相关。&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;除去维基百科的条目，第一个答案指向了一本GitBook《JS函数式编程指南》，好奇的猫猫点进去看了，结果大为叹服！建议大家有条件的话都去读一下（链接见文末，不懂js也不影响理解）。&lt;/div&gt;
&lt;div&gt;非常巧合的是，这本书的作者也发表了他对于面向对象编程的看法：&lt;/div&gt;
&lt;div&gt;我最喜欢的名言之一是 Erlang 语言的作者 Joe Armstrong 说的这句话：“面向对象语言的问题是，它们永远都要随身携带那些隐式的环境。你只需要一个香蕉，但却得到一个拿着香蕉的大猩猩…以及整个丛林”。&lt;/div&gt;
&lt;div&gt;读完《纯函数的好处》章节，猫猫提炼了几条笔记。一方面是为了加强对纯函数的理解，在实战中规避一些“不纯”的用法，另一方面，也提出了几个思考和疑问，今后在学习Python的过程中，留神找到答案：&lt;/div&gt;
&lt;div&gt;1、避免使用不纯的函数。JS中的splice是个不纯的函数，那Python中是否也有这样的函数呢？&lt;/div&gt;
&lt;div&gt;2、下例中第一个是不纯的，因为函数的结果取决于minimum这个可变变量，换句话说，它取决于系统状态（system state）；这一点令人沮丧，因为它引入了外部的环境，从而增加了认知负荷（cognitive load）。（题外话：这个例子，猫猫大有感触。公司有个项目的老版本代码中，充斥了各种全局变量，小伙伴们在维护时吃了好多苦头！）JS中可以用Object.freeze 方法令minimum成为不可变对象，Python中有类似的实现么？&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;// 不纯的&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; minimum &lt;span&gt;=&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;checkAge&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; age &lt;span&gt;&amp;gt;=&lt;/span&gt; minimum&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

&lt;span&gt;// 纯的&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;checkAge&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; minimum &lt;span&gt;=&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; age &lt;span&gt;&amp;gt;=&lt;/span&gt; minimum&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;3、不纯函数会带来“副作用”，其“作用”本身没有坏处，但其“副”是滋生bug的温床。并不是说，要禁止使用一切副作用，而是说，要让它们在可控的范围内发生。坚持这种「相同输入得到相同输出」的原则。&lt;/div&gt;
&lt;div&gt;4、纯函数实际上就是数学定义中的函数。“函数是不同数值之间的特殊关系：每一个输入值返回且只返回一个输出值。”&lt;/div&gt;
&lt;div&gt;5、追求“纯”的理由：可缓存性（有点像生成器，延迟执行）、可移植性／自文档化（因其完全自给自足，依赖关系明确）、可测试性（为函数式环境定制的测试工具，JS中有Quickcheck，Python中有么？）、合理性（引用透明性：一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换）、并行代码（纯函数根本不需要访问共享的内存，而且纯函数也不会因副作用而进入竞争态（race condition））。&lt;/div&gt;
&lt;div&gt;今天的分享就到这了，最后再啰嗦几句。本篇文章里，一句Python代码都没有，真的是够“干”的了。猫猫有时候挺喜欢看这样的文章，因为它会带给你思想上的启迪，就像是绝世高人在传授秘籍心法一样。所以，猫猫也喜欢转述和思考这类问题，比如之前发过的一篇《超强汇总：学习Python列表，只需这篇文章就够了》，就不仅仅有代码层面的内容，还特意加入了Guido老爹关于Python列表索引为何从0开始的解释，以及其它编程语言对索引值的考虑。&lt;/div&gt;
&lt;div&gt;不记得在哪里曾看到过一句话，送予大家共勉：&lt;/div&gt;
&lt;div&gt;如果一个人眼里只看得见代码，那他跟咸（ma）鱼（nong）有啥区别？&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>再谈文件读写：判断文件的几种方法及其优劣对比</title>
            <link>https://pythoncat.top/posts/2018-10-19-file/</link>
            <guid>https://pythoncat.top/posts/2018-10-19-file/</guid>
            <description>判断文件的方法（try语句、os模块、pathlib模块），比较几种方法的优劣</description>
            <pubDate>Fri, 19 Oct 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;上周，猫猫写了一篇&lt;a href=&quot;https://mp.weixin.qq.com/s/Md07VoaULda7qnMO4ob7Ww&quot;&gt;给Python学习者的文件读写指南&lt;/a&gt;，跟大家一起详尽地学习了文件读写的基础内容，以及with语句与上下文管理器的进阶知识。&lt;/div&gt;
&lt;div&gt;这份指南虽然写得很用心，但是因为只关注了文件读写的核心内容，所以也有美中不足不处，有些在实战中所需的知识点没有谈到，例如，为了能够进行文件读写，首先得找到文件、文件得可读写才行。&lt;/div&gt;
&lt;div&gt;我们知道当文件不存在的时候，open()方法的写模式与追加模式都会新建文件，但是对文件进行判断的场景还有很多，比如，在爬虫下载图片的时候，可能需要判断文件是否存在，以免重复下载；又比如，创建新文件的时候，可能需要判断文件是否存在，存在就先做个备份…所以，学习判断文件是否存在，还是很有必要的。&lt;/div&gt;
&lt;div&gt;学习是循序渐进的过程，若能建立知识点间的联系，进行系统性的学习，那将更有助于效果。阅读这篇文章，你将读到如下内容：&lt;/div&gt;
&lt;div&gt;1、判断文件的方法（try语句、os模块、pathlib模块）&lt;/div&gt;
&lt;div&gt;2、以上几种方法的优劣对比&lt;/div&gt;
&lt;h2&gt;懒人的try语句&lt;/h2&gt;
&lt;div&gt;我们之前学过，要用with语句来处理文件读写，但with语句也不是万能的，所以还得关注一些异常情况。例如，当使用open()方法的时候，如果文件不存在，程序会抛出FileNotFoundError异常，而如果权限不足的话，就会抛出PersmissionError异常。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;python.log&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;r&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;     f&lt;span&gt;.&lt;/span&gt;read&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;
&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;略&lt;span&gt;)&lt;/span&gt;
FileNotFoundError&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;Errno &lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; No such &lt;span&gt;file&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; directory&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;python.log&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;为了避免这些异常导致程序中断，我们可以用try…except…语句来捕捉异常，然后在except子句进行异常的处理。&lt;/div&gt;
&lt;div&gt;不过，在猫猫看来，这个方法不值得推荐。原因有二，一是这种方法很被动，程序的健康受制于不可预测的异常；二是当文件不存在的时候，我们可能需要去创建文件，这些逻辑如果写在except子句里，可读性太差了。&lt;/div&gt;
&lt;h2&gt;传统的os模块&lt;/h2&gt;
&lt;div&gt;顾名思义，Python内置的os模块是用来与OS（操作系统）进行交互的模块，它可以实现很多在命令行下做的操作，例如，获取操作系统信息、获取/修改环境变量、进行目录操作（创建、删除、遍历）和各种文件操作等等。&lt;/div&gt;
&lt;div&gt;下面，我们要学习的是跟文件判断密切相关的几个方法。&lt;/div&gt;
&lt;div&gt;1、os.path.exists()用于判断文件及文件夹是否存在（注意：因为两者都能判断，为了有效区分文件和文件夹，最好保证文件是带后缀的。）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; os
&lt;span&gt;# 文件存在 VS 不存在&lt;/span&gt;
os&lt;span&gt;.&lt;/span&gt;path&lt;span&gt;.&lt;/span&gt;exists&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
os&lt;span&gt;.&lt;/span&gt;path&lt;span&gt;.&lt;/span&gt;exists&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;cat.txt&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;
&lt;span&gt;# 文件夹存在 VS 不存在&lt;/span&gt;
os&lt;span&gt;.&lt;/span&gt;path&lt;span&gt;.&lt;/span&gt;exists&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;cat/images&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
os&lt;span&gt;.&lt;/span&gt;path&lt;span&gt;.&lt;/span&gt;exists&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;cat/image&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;2、os.path.isfile()、os.path.isdir() 判断给定路径是文件还是文件夹：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;os&lt;span&gt;.&lt;/span&gt;path&lt;span&gt;.&lt;/span&gt;isfile&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;cat/images&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;
os&lt;span&gt;.&lt;/span&gt;path&lt;span&gt;.&lt;/span&gt;isdir&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;cat/images&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
os&lt;span&gt;.&lt;/span&gt;path&lt;span&gt;.&lt;/span&gt;isfile&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;3、os.access()检测文件路径的访问权限，语法：os.access(path, mode)；其中path指的是文件或者文件夹，mode指的是要检测的模式：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;os&lt;span&gt;.&lt;/span&gt;access&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;cat/images&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; os&lt;span&gt;.&lt;/span&gt;F_OK&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt; &lt;span&gt;# path存在&lt;/span&gt;
os&lt;span&gt;.&lt;/span&gt;access&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;cat/images&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; os&lt;span&gt;.&lt;/span&gt;R_OK&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt; &lt;span&gt;# path可读&lt;/span&gt;
os&lt;span&gt;.&lt;/span&gt;access&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;cat/images&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; os&lt;span&gt;.&lt;/span&gt;W_OK&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt; &lt;span&gt;# path可写&lt;/span&gt;
os&lt;span&gt;.&lt;/span&gt;access&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;cat/images&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; os&lt;span&gt;.&lt;/span&gt;X_OK&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt; &lt;span&gt;# path可执行&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;4、os模块中其它常用方法：&lt;/div&gt;
&lt;div&gt;os.mkdir()创建目录、os.rmdir()删除目录、os.rename()重命名、os.remove()删除文件、os.path.join()连接目录与文件名、os.path.split()分割目录与文件名…（不一一举例了，今后有机会再作介绍）&lt;/div&gt;
&lt;h2&gt;时尚的pathlib模块&lt;/h2&gt;
&lt;div&gt;pathlib模块是python3.4才加入的模块，官方介绍它是面向对象的文件系统路径（Object-oriented filesystem paths），这是一个很强大的模块，文末附录了官方文档地址。&lt;/div&gt;
&lt;div&gt;这里主要介绍几个基本的用法：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; pathlib
file_obj &lt;span&gt;=&lt;/span&gt; pathlib&lt;span&gt;.&lt;/span&gt;Path&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

file_obj&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt; &lt;span&gt;# 文件名&lt;/span&gt;
file_obj&lt;span&gt;.&lt;/span&gt;exists&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;True&lt;/span&gt; &lt;span&gt;# 是否存在&lt;/span&gt;
file_obj&lt;span&gt;.&lt;/span&gt;is_dir&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;False&lt;/span&gt; &lt;span&gt;# 是否文件夹&lt;/span&gt;
file_obj&lt;span&gt;.&lt;/span&gt;is_file&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt; &lt;span&gt;# 是否文件&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;几种方法优劣对比&lt;/h2&gt;
&lt;div&gt;围绕文件操作的知识很多，限于篇幅，本文主要对判断文件作了介绍，今后也许还会对其它具体话题进行学习。&lt;/div&gt;
&lt;div&gt;现在知道了几种判断文件是否存在的方法，猫猫试着根据自己的理解，对它们做一下评判。&lt;/div&gt;
&lt;div&gt;首先，try语句的缺点是没有主动做判断，不方便根据文件是否存在而做针对性的处理，它把必要的逻辑交给异常捕获，多少显得“不负责任”；try语句也有优点，一是不需要引入模块，不需要区分各种使用方法，二是将其它可能存在的异常都打包，避免多样系统或使用场景的遗漏。&lt;/div&gt;
&lt;div&gt;os模块是传统的老模块了，在使用上和维护上都会比较顺畅；它的主要缺点在于有的方法比较繁琐，由于使用字符串来表示文件路径，这会导致路径拼接上的麻烦，另外，不同操作系统在路径分隔符上的差异（Windows使用\分隔符，Linux和Mac使用/分隔符），也可能导致难以发现的错误。&lt;/div&gt;
&lt;div&gt;相对来说，pathlib功能最强大，但普及度比较低，有一定的学习门槛；它主要的优点是面向对象，同时，因为对不同操作系统的特性做了封装，能有效避免字符串表示文件路径的难题。它的不足之处是没有像os.access()可以检测访问权限的方法，虽然这个方法基本不会使用到。&lt;/div&gt;
&lt;div&gt;下面比较了三种拼接文件路径的方法，方法一未对分隔符做处理，不能保证在每个操作系统都能找到；方法二需要反复使用os.path.join；方法三只用“/“就能拼接路径，而且肯定支持多操作系统。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 错误拼接：未处理分隔符&lt;/span&gt;
data_folder &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;source_data/text_files/&quot;&lt;/span&gt;
file_to_open &lt;span&gt;=&lt;/span&gt; data_folder &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;

&lt;span&gt;# os模块拼接&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; os
data_folder &lt;span&gt;=&lt;/span&gt; os&lt;span&gt;.&lt;/span&gt;path&lt;span&gt;.&lt;/span&gt;join&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;source_data&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;text_files&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
file_to_open &lt;span&gt;=&lt;/span&gt; os&lt;span&gt;.&lt;/span&gt;path&lt;span&gt;.&lt;/span&gt;join&lt;span&gt;(&lt;/span&gt;data_folder&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# pathlib模块拼接&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; pathlib &lt;span&gt;import&lt;/span&gt; Path
data_folder &lt;span&gt;=&lt;/span&gt; Path&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;source_data/text_files/&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
file_to_open &lt;span&gt;=&lt;/span&gt; data_folder &lt;span&gt;/&lt;/span&gt; &lt;span&gt;&quot;test.txt&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;总结一下，如果文件路径简单，仅仅要用到exists()、is_dir()、is_file() 这几个方法的话，os.path模块和pathlib.Path模块不分伯仲，都很好用，但是如果考虑到繁复的路径拼接的话，pathlib.Path就会胜出一筹。&lt;/div&gt;
&lt;div&gt;喵喵，今天的分享就到这啦，小伙伴们觉得有用的话，麻烦帮忙点赞、转发给其他童靴哦~~~&lt;/div&gt;
&lt;div&gt;扩展阅读：&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Md07VoaULda7qnMO4ob7Ww&quot;&gt;给Python学习者的文件读写指南&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;http://www.runoob.com/python/os-file-methods.html&quot;&gt;菜鸟教程：os模块&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html&quot;&gt;官方文档：pathlib模块&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>Python 中的“特权种族”是什么？</title>
            <link>https://pythoncat.top/posts/2018-10-15-id/</link>
            <guid>https://pythoncat.top/posts/2018-10-15-id/</guid>
            <description>对象的Id是什么？内置id()函数是什么？共用Id的内存分配策略？</description>
            <pubDate>Mon, 15 Oct 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;前几天，某个学习群里有小伙伴问了一个关于id()的问题。事后，猫猫想起Python中一些常用对象的内存地址是共用的，但是具体是哪些却忘了。于是，猫猫意识到这是我知识薄弱之处，有提升空间，便进行了一番学习。&lt;/div&gt;
&lt;div&gt;今天，猫猫把学习到的部分内容总结出来，分享给大家。阅读本文，大家可以学到如下内容：&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;对象的Id是什么？&lt;/li&gt;
&lt;li&gt;内置id()函数是什么？&lt;/li&gt;
&lt;li&gt;共用Id的内存分配策略？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;学习群里的一道问题&lt;/h2&gt;
&lt;div&gt;首先，看看小伙伴贴出的代码：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; a&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
Out&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;2399283020744&lt;/span&gt;
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
Out&lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;1417427824&lt;/span&gt;
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; a&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
Out&lt;span&gt;[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;2399283020744&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;他的问题是：为何第二个id值（1417427824）不等于其它两个的id值（2399283020744）？还有这个id值（1417427824）到底是谁的id？&lt;/div&gt;
&lt;div&gt;现在公布答案：第二个id值（1417427824）是None的id，只要打印id(None)就能看出来；至于为啥是None的id，因为列表的append()方法返回值是None，而id(a.append(4))等价于取这个append操作的返回值的id，也就是说id(a.append(4))等价于是id(None)。&lt;/div&gt;
&lt;h2&gt;对象Id与id()函数&lt;/h2&gt;
&lt;div&gt;python的对象有三要素：Id（identity，身份标识）、Type（类型标识）和Value（对象的值）。其中，Value通常是一个对象能被直接“看到”的部分，而Id及Type则是相对底层的维度，无法直接“看到”。举个例子（“&amp;gt;&amp;gt;&amp;gt;”表示输出结果）：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;Object1&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;
Object2&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;2018&quot;&lt;/span&gt;
&lt;span&gt;# Object1的value是2018(数字)&lt;/span&gt;
&lt;span&gt;# Object2的value是“2018”(字符串)&lt;/span&gt;
&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Object1&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;2399282764784&lt;/span&gt;
&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Object2&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;2399281922600&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Object1&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;Object2&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;如上所述，我们建立了对象三要素与三个内置函数的联系：Id&amp;amp;id()、Type&amp;amp;type()、Value&amp;amp;str()。今天，猫猫先跟大家一起来学习id()函数，今后再继续学习其它两个。&lt;/div&gt;
&lt;div&gt;1、id()函数释义&lt;/div&gt;
&lt;div&gt;id()是python内置的函数，它专门用于获取对象的内存地址，内存地址是一个整型数值，在该对象的生命周期内是唯一且恒定的。语法：id([object])。&lt;/div&gt;
&lt;div&gt;2、比较Id的两种方式&lt;/div&gt;
&lt;div&gt;通常有两种比较对象Id的方式（is、id()比较），请看例子：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;l1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
l2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; l1 &lt;span&gt;is&lt;/span&gt; l2 
Out&lt;span&gt;[&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;l1&lt;span&gt;)&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;l2&lt;span&gt;)&lt;/span&gt;
Out&lt;span&gt;[&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;
&lt;span&gt;# 两者Id不相等，因为：&lt;/span&gt;
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;l1&lt;span&gt;)&lt;/span&gt;
Out&lt;span&gt;[&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;2399279725576&lt;/span&gt;
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;l2&lt;span&gt;)&lt;/span&gt;
Out&lt;span&gt;[&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;2399282938056&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;is判断语句是判断两个对象的内存地址，也就等价于先取id()，再做数值比较。&lt;/div&gt;
&lt;div&gt;3、不要与Value的比较方式混淆&lt;/div&gt;
&lt;div&gt;Value的比较符号用双等号“ == ”，上例中比较l1和l2的Value要写成“l1 == l2”，明显两者的Value是相等的。按照约定俗成的习惯，我们把Value值相等的两个对象称为“相等”，而把Id值相等的两个对象称为“相同”。所以，准确地说，上例的l1与l2相等，但是他们不相同，l1 == l2，但l1 is not l2。&lt;/div&gt;
&lt;h2&gt;特权种族：共用内存的对象&lt;/h2&gt;
&lt;div&gt;每个对象被创建出来的时候，就会确定其Id标识，也就是给它分配内存地址。通常来说，新对象的内存地址也是新的，会从未分配的可用地址中取。&lt;/div&gt;
&lt;div&gt;但是，为了提高内存利用效率，对于一些常用的对象，如一些数值较小的数字对象、布尔值对象、None对象、较短的字符串对象等等，python采取共用对象内存的分配策略。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 新分配内存地址的例子&lt;/span&gt;
ww&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
ee&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;ww&lt;span&gt;)&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;ee&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;
a&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;
b&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;
&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;

&lt;span&gt;# 共用内存地址的例子&lt;/span&gt;
a&lt;span&gt;=&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;
b&lt;span&gt;=&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;
&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
f1&lt;span&gt;=&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
f2&lt;span&gt;=&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;f1&lt;span&gt;)&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;f2&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
n1&lt;span&gt;=&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;
n2&lt;span&gt;=&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;
&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;n1&lt;span&gt;)&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;n2&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
s&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;python_cat&quot;&lt;/span&gt;
t&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;python_cat&quot;&lt;/span&gt;
&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;t&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;这就意味着，python中出现了“特权种族”，运行环境早早就为它们分配好了内存地址，一旦要创建新的对象时，先去特权种族中查找，有Type和Value相等的对象，则新对象不分配新的内存空间，而是指向已有对象。&lt;/div&gt;
&lt;div&gt;“特权种族”的存在，使得我们不需要频繁创建这些对象，既能提高已分配内存的使用率，又减少了创建对象、分配新内存的损耗。&lt;/div&gt;
&lt;div&gt;对于共用内存地址的数字对象的取值范围，根据这篇文章《Python中神秘的-5到256》(链接见文末)对python源码的分析，文中有如下结论：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Python中，对于整数对象，如果其值处于[-5,256]的闭区间内，则值相同的对象是同一个对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;对于共用内存地址的字符串对象的取值范围，学习了几篇对python源码分析的文章后（链接见文末），我总结出大致有以下结论：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Python中，字符串使用Intern机制实现内存地址共用，长度不超过20，且仅包括下划线、数字、字母的字符串才会被intern；涉及字符串拼接时，编译期优化结果会与运行期计算结果不同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 编译对字符串拼接的影响&lt;/span&gt;
s1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;hell&quot;&lt;/span&gt;
s2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;hello&quot;&lt;/span&gt;
&lt;span&gt;&quot;hell&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;o&quot;&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; s2 &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;
s1 &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;o&quot;&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; s2 &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;
&lt;span&gt;# &quot;hell&quot; + &quot;o&quot;在编译时变成了&quot;hello&quot;，&lt;/span&gt;
&lt;span&gt;# 而s1+&quot;o&quot;因为s1是一个变量，在运行时才拼接，所以没有被intern&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;参考阅读：&lt;/div&gt;
&lt;div&gt;《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33907983&quot;&gt;Python中神秘的-5到256&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;《&lt;a href=&quot;https://www.cnblogs.com/greatfish/p/6045088.html&quot;&gt;Python中字符串的intern机制&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;《&lt;a href=&quot;https://mrcuriosity.org/python-string-intern.html&quot;&gt;Python中字符串的intern机制&lt;/a&gt;》&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>给Python初学者的文件读写指南（含基础与进阶，建议收藏）</title>
            <link>https://pythoncat.top/posts/2018-10-11-file/</link>
            <guid>https://pythoncat.top/posts/2018-10-11-file/</guid>
            <description>如何将列表数据写入文件？如何从文件中读取内容？多样需求的读写任务，从with语句到上下文管理器</description>
            <pubDate>Thu, 11 Oct 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;对于初学者来说，一份详尽又清晰明白的指南很重要。今天，猫猫跟大家一起，好好学习Python文件读写的内容，这部分内容特别常用，掌握后对工作和实战都大有益处。学习是循序渐进的过程，欲速则不达。文章较长，建议大家收藏，以备复习查阅哦。&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如何将列表数据写入文件？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何从文件中读取内容？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多样需求的读写任务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从with语句到上下文管理器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;如何将列表数据写入文件？&lt;/h2&gt;
&lt;div&gt;首先，我们来看看下面这段代码，并思考：这段代码有没有问题，如果有问题的话，要怎么改？&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;li &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;python&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; is&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; cat&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;w&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    f&lt;span&gt;.&lt;/span&gt;write&lt;span&gt;(&lt;/span&gt;li&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;现在公布答案，这段代码会报错：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;TypeError  Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;ipython&lt;span&gt;-&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;57e0c2f5a453&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;module&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
      &lt;span&gt;1&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;w&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;     f&lt;span&gt;.&lt;/span&gt;write&lt;span&gt;(&lt;/span&gt;li&lt;span&gt;)&lt;/span&gt;

TypeError&lt;span&gt;:&lt;/span&gt; write&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; argument must be &lt;span&gt;str&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;以上代码的想法是将list列表内容写入txt文件中，但是报错 TypeError: write() argument must be str。就是说，write()方法必须接受字符串（str）类型的参数。&lt;/div&gt;
&lt;div&gt;Python中内置了str()方法，可以返回字符串版本的对象（Return a string version of object）。所以，上面的例子中，我们试试把 f.write(li) 改为 f.write(str(li)) ，先做一下字符串类型的转化看看。代码略。&lt;/div&gt;
&lt;div&gt;这次没有报错了，但是打开文件就傻眼了吧，写入的内容是“[‘python’,’ is’,’ a’,’ cat’]”。怎么才能写成“python is a cat”呢？
文件写操作还有一个writelines()方法，它接收的参数是由字符串组成的序列（sequence），实际写入的效果是将全部字符串拼接在一起。字符串本身也是一种序列，所以当参数是字符串的时候，writelines()方法等价于write()。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 以下3种写法等价，都是写入字符串“python is a cat”&lt;/span&gt;
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;  &lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;w&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;      f&lt;span&gt;.&lt;/span&gt;writelines&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;python&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; is&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; cat&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;      f&lt;span&gt;.&lt;/span&gt;writelines&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;python is a cat&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;      f&lt;span&gt;.&lt;/span&gt;write&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;python is a cat&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 以下2种写法等价，都是写入列表的字符串版本“[&apos;python&apos;,&apos; is&apos;,&apos; a&apos;,&apos; cat&apos;]”&lt;/span&gt;
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;  &lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;w&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;      f&lt;span&gt;.&lt;/span&gt;write&lt;span&gt;(&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;python&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; is&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; cat&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;      f&lt;span&gt;.&lt;/span&gt;writelines&lt;span&gt;(&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;python&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; is&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; cat&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    
&lt;span&gt;# 作为反例，以下写法都是错误的：&lt;/span&gt;
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;  &lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;w&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;      f&lt;span&gt;.&lt;/span&gt;writelines&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;is&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;cat&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 含非字符串&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;      f&lt;span&gt;.&lt;/span&gt;write&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;python&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;is&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;cat&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 非字符串&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;由上可知，当多段分散的字符串存在于列表中的时候，要用writelines()方法，如果字符串是一整段，那直接使用write()方法。如果要以整个列表的形式写入文件，就使用str()方法做下转化。&lt;/div&gt;
&lt;div&gt;这个问题还没结束，如果列表中就是有元素不是字符串，而且要把全部元素取出来，怎么办呢？&lt;/div&gt;
&lt;div&gt;那就不能直接使用write()和writelines()了，需要先用for循环，把每个元素取出来，逐一str()处理。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; content&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; is&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; everything&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;w&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; content&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;         f&lt;span&gt;.&lt;/span&gt;write&lt;span&gt;(&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;需要注意的是，writelines()不会自动换行。如果要实现列表元素间的换行，一个办法是在每个元素后面加上换行符“\n”，如果不想改变元素，最好是用for循环，在写入的时候加在末尾：for i in content:  f.writelines(str(i)+“\n”)&lt;/div&gt;
&lt;div&gt;引申一下，经过实验，数字及元祖类型也可以作为write()的参数，不需转化。但是dict字典类型不可以，需要先用str()处理一下。字典类型比较特殊，最好是用json.dump()方法写到文件，具体操作方法以及注意事项，请看喵喵之前发的《&lt;a href=&quot;https://mp.weixin.qq.com/s/hR2Z_duLXnN0fQ3khDPiPQ&quot;&gt;假期玩得开心也不忘充电，学习Python操作JSON，网络数据交换不用愁&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;总结一下，write()接收字符串参数，适用于一次性将全部内容写入文件；writelines()接收参数是由字符串组成的序列，适用于将列表内容逐行写入文件。str()返回Python对象的字符串版本，使用需注意。&lt;/div&gt;
&lt;h2&gt;如何从文件中读取内容？&lt;/h2&gt;
&lt;div&gt;从文件中读取内容有如下方法：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;file.read([size])
从文件读取指定的字节数，如果未给定或为负则读取所有。&lt;/p&gt;
&lt;p&gt;file.readline([size])
读取整行，包括 “\n” 字符。&lt;/p&gt;
&lt;p&gt;file.readlines([sizeint])
读取所有行并返回列表，若给定sizeint&amp;gt;0，则是设置一次读多少字节，这是为了减轻读取压力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;简而言之，在不传参数的情况下，read()对应write()，读取全部内容；readlines()对应writelines()，读取全部内容（含换行符）并以列表形式返回，每个换行的内容作为列表的一个元素。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;r&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;f&lt;span&gt;.&lt;/span&gt;read&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; everything&lt;span&gt;.&lt;/span&gt;
python &lt;span&gt;is&lt;/span&gt; a cat&lt;span&gt;.&lt;/span&gt;
this &lt;span&gt;is&lt;/span&gt; the end&lt;span&gt;.&lt;/span&gt;

In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;r&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;f&lt;span&gt;.&lt;/span&gt;readlines&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;1 is everything.\n&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;python is a cat.\n&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;this is the end.&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;但是，以上两个方法有个缺点，当文件过大的时候，一次性读取太多内容，会对内存造成极大压力。读操作还有一个readline()方法，可以逐行读取。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;r&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;f&lt;span&gt;.&lt;/span&gt;readline&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; everything&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;readline()读取第一行就返回，再次调用f.readline()，会读取下一行。&lt;/div&gt;
&lt;div&gt;喵喵，是否感觉跟《&lt;a href=&quot;https://mp.weixin.qq.com/s/OKf7N3xxrS0tJ_K8Srw-jA&quot;&gt;超强汇总：学习Python列表，只需这篇文章就够了&lt;/a&gt;》学习过的生成器很像，需要不停调用next()获取下一行。&lt;/div&gt;
&lt;div&gt;这么看来，readline()太笨拙了。那么，有什么办法可以优雅地读取文件内容呢？&lt;/div&gt;
&lt;div&gt;回过头来看readlines()方法，它返回的是一个列表。这不奇怪么，好端端的内容为啥要返回成列表呢？&lt;/div&gt;
&lt;div&gt;再想想writelines()方法，把字符串列表写入文件正是这家伙干的事，readlines()方法恰恰是它的逆操作！而writelines()方法要配合for循环，所以我们把readlines()与for循环结合，看看会怎样。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;r&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; f&lt;span&gt;.&lt;/span&gt;readlines&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;line&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; everything&lt;span&gt;.&lt;/span&gt;

python &lt;span&gt;is&lt;/span&gt; a cat&lt;span&gt;.&lt;/span&gt;

this &lt;span&gt;is&lt;/span&gt; the end&lt;span&gt;.&lt;/span&gt;

&lt;span&gt;# 读取内容包含换行符，所以要strip()去掉换行符&lt;/span&gt;
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;r&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; f&lt;span&gt;.&lt;/span&gt;readlines&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;line&lt;span&gt;.&lt;/span&gt;strip&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; everything&lt;span&gt;.&lt;/span&gt;
python &lt;span&gt;is&lt;/span&gt; a cat&lt;span&gt;.&lt;/span&gt;
this &lt;span&gt;is&lt;/span&gt; the end&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;总结一下，readline()比较鸡肋，不咋用；read()适合读取内容较少的情况，或者是需要一次性处理全部内容的情况；而readlines()用的较多，比较灵活，因为for循环是一种迭代器，每次加载部分内容，既减少内存压力，又方便逐行对数据处理。&lt;/div&gt;
&lt;h2&gt;多样需求的读写任务&lt;/h2&gt;
&lt;div&gt;前两部分讲了文件读写的几大核心方法，它们能够起作用的前提就是，需要先打开一个文件对象，因为只有在文件操作符的基础上才可以进行读或者写的操作。&lt;/div&gt;
&lt;div&gt;打开文件用的是open()方法，所以我们再继续讲讲这个方法。open() 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;open(file, mode=‘r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;open()方法的参数里file（文件）是必需的，其它参数最常用的是mode（模式）和encoding（编码）。&lt;/div&gt;
&lt;div&gt;先说说encoding，一般来说，打开文件的编码方式以操作系统的默认编码为准，中文可能会出现乱码，需要加encoding=‘utf-8’。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;r&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; f&lt;span&gt;.&lt;/span&gt;readlines&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;line&lt;span&gt;.&lt;/span&gt;strip&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;
UnicodeDecodeError     Traceback &lt;span&gt;(&lt;/span&gt;most recent call last&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;ipython&lt;span&gt;-&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;731a4f9cf707&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;module&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
      &lt;span&gt;1&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;r&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; f&lt;span&gt;.&lt;/span&gt;readlines&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
      &lt;span&gt;3&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;line&lt;span&gt;.&lt;/span&gt;strip&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
UnicodeDecodeError&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;gbk&apos;&lt;/span&gt; codec can&apos;t decode byte &lt;span&gt;0xa4&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; position &lt;span&gt;26&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; illegal multibyte sequence

In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;r&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;encoding&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;utf-8&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; f&lt;span&gt;.&lt;/span&gt;readlines&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;line&lt;span&gt;.&lt;/span&gt;strip&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
爱猫猫
python &lt;span&gt;is&lt;/span&gt; a cat&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;再说mode，它指定文件打开的模式。&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;‘r’： 以只读模式打开（缺省模式）（必须保证文件存在）&lt;/p&gt;
&lt;p&gt;‘w’：以只写模式打开。若文件存在，则清空文件，然后重新创建；若不存在，则新建文件。&lt;/p&gt;
&lt;p&gt;‘a’：以追加模式打开。若文件存在，则会追加到文件的末尾；若文件不存在，则新建文件。&lt;/p&gt;
&lt;p&gt;常见的mode组合&lt;/p&gt;
&lt;p&gt;‘r’或’rt’：     默认模式，文本读模式&lt;/p&gt;
&lt;p&gt;‘w’或’wt’：  以文本写模式打开（打开前文件会被清空）&lt;/p&gt;
&lt;p&gt;‘rb’：          以二进制读模式打开&lt;/p&gt;
&lt;p&gt;‘ab’：         以二进制追加模式打开&lt;/p&gt;
&lt;p&gt;‘wb’：        以二进制写模式打开（打开前文件会被清空）&lt;/p&gt;
&lt;p&gt;‘r+’：         以文本读写模式打开，默认写的指针开始指在文件开头, 因此会覆写文件&lt;/p&gt;
&lt;p&gt;‘w+’：        以文本读写模式打开（打开前文件会被清空）&lt;/p&gt;
&lt;p&gt;‘a+’：        以文本读写模式打开（写只能写在文件末尾）&lt;/p&gt;
&lt;p&gt;‘rb+’：       以二进制读写模式打开&lt;/p&gt;
&lt;p&gt;‘wb+’：     以二进制读写模式打开（打开前文件会被清空）&lt;/p&gt;
&lt;p&gt;‘ab+’：      以二进制读写模式打开&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;喵喵，初看起来，模式很多，但是，它们只是相互组合罢了。建议记住最基本的w、r、a，遇到特殊场景，再翻看一下就好了。&lt;/div&gt;
&lt;h2&gt;从with语句到上下文管理器&lt;/h2&gt;
&lt;div&gt;基础部分讲完了，下面是进阶部分。知其然，更要知其所以然。&lt;/div&gt;
&lt;div&gt;1、with语句是初学者必会常识&lt;/div&gt;
&lt;div&gt;首先，要解释一下为啥前文直接就用了with语句。with语句是读写文件时的优雅写法，这已经默认是Python初学者必会的常识了。如果你还不会，先看看用和不用with语句的对比：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 不用with语句的正确写法&lt;/span&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    f &lt;span&gt;=&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;w&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    f&lt;span&gt;.&lt;/span&gt;writelines&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;python&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; is&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; cat&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
        f&lt;span&gt;.&lt;/span&gt;close&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;# 使用with语句的正确写法&lt;/span&gt;
&lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;w&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    f&lt;span&gt;.&lt;/span&gt;writelines&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;python&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; is&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; a&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos; cat&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量是有限的，所以open()方法之后一定要调用close()方法。另外，读写操作可能出现IO异常的情况，所以要加try…finally，保证无论如何，都会调用到close()方法。&lt;/div&gt;
&lt;div&gt;这样写万无一失，但是实在繁琐，一不小心还可能漏写或者写错。而with语句会保证调用close()，只需一行代码，简直不要太优雅！所以，with语句是Python初学者必会技能。&lt;/div&gt;
&lt;div&gt;2、什么是上下文管理器？&lt;/div&gt;
&lt;div&gt;下面，重头戏来了，什么是上下文管理器（context manager）？&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;上下文管理器是这样一个对象：它定义程序运行时需要建立的上下文，处理程序的进入和退出，实现了上下文管理协议，即在对象中定义了 __enter__() 和 __exit__() 方法。
__enter__()：进入运行时的上下文，返回运行时上下文相关的对象，with 语句中会将这个返回值绑定到目标对象。
__exit__(exception_type, exception_value, traceback)：退出运行时的上下文，定义在块执行（或终止）之后上下文管理器应该做什么。它可以处理异常、清理现场或者处理 with 块中语句执行完成之后需要处理的动作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;注意 enter 和 exit 的前后有两个下划线，Python 中自带了很多类似的方法，它们是很神秘又很强大的存在，江湖人常常称其为“黑魔法”。例如，迭代器协议就实现了__iter__方法。&lt;/div&gt;
&lt;div&gt;在Python的内置类型中，很多类型都是支持上下文管理协议的，例如 file、thread.LockType、threading.Lock 等等。上下文管理器无法独立使用，它们要与 with 相结合，with 语句可以在代码块运行前进入一个运行时上下文（执行__enter__方法），并在代码块结束后退出该上下文（执行__exit__方法）。&lt;/div&gt;
&lt;div&gt;with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。&lt;/div&gt;
&lt;div&gt;3、自定义上下文管理器&lt;/div&gt;
&lt;div&gt;除了Python的内置类型，任何人都可以定义自己的上下文管理器。下面是一个示例：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OpenFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt;filename&lt;span&gt;,&lt;/span&gt;mode&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;filename&lt;span&gt;=&lt;/span&gt;filename
        self&lt;span&gt;.&lt;/span&gt;mode&lt;span&gt;=&lt;/span&gt;mode
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__enter__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;f&lt;span&gt;=&lt;/span&gt;&lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;filename&lt;span&gt;,&lt;/span&gt;self&lt;span&gt;.&lt;/span&gt;mode&lt;span&gt;)&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;f&lt;span&gt;.&lt;/span&gt;write&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;enter now\n&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self&lt;span&gt;.&lt;/span&gt;f  &lt;span&gt;#作为as说明符指定的变量的值&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__exit__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;value&lt;span&gt;,&lt;/span&gt;tb&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;f&lt;span&gt;.&lt;/span&gt;write&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;exit now&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        self&lt;span&gt;.&lt;/span&gt;f&lt;span&gt;.&lt;/span&gt;close&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;   &lt;span&gt;#异常会被传递出上下文&lt;/span&gt;
&lt;span&gt;with&lt;/span&gt; OpenFile&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;w&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    f&lt;span&gt;.&lt;/span&gt;write&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;Hello World!\n&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;最终写入文件的结果是：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;enter now
Hello World!
exit now&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div&gt;上下文管理器必须同时提供 &lt;strong&gt;enter&lt;/strong&gt;() 和 &lt;strong&gt;exit&lt;/strong&gt;() 方法的定义，缺少任何一个都会导致 AttributeError。&lt;/div&gt;
&lt;div&gt;上下文管理器在执行过程中可能会出现异常，&lt;strong&gt;exit&lt;/strong&gt;() 的返回值会决定异常的处理方式：返回值等于 False，那么这个异常将被重新抛出到上层；返回值等于 True，那么这个异常就被忽略，继续执行后面的代码。&lt;strong&gt;exit&lt;/strong&gt;() 有三个参数(exception_type, exception_value, traceback)，即是异常的相关信息。&lt;/div&gt;
&lt;div&gt;4、contextlib实现上下文管理器&lt;/div&gt;
&lt;div&gt;上例中，自定义上下文管理器的写法还是挺繁琐的，而且只能用于类级别。为了更好地辅助上下文管理，Python 内置提供了 contextlib 模块，进而可以很方便地实现函数级别的上下文管理器。&lt;/div&gt;
&lt;div&gt;该模块本质上是通过装饰器(decorators)和生成器(generators)来实现上下文管理器，可以直接作用于函数/对象，而不用去关心 &lt;strong&gt;enter&lt;/strong&gt;() 和 &lt;strong&gt;exit&lt;/strong&gt;() 方法的具体实现。&lt;/div&gt;
&lt;div&gt;先把上面的例子改造一下，然后我们再对照着解释：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; contextlib &lt;span&gt;import&lt;/span&gt; contextmanager

&lt;span&gt;@contextmanager&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;open_file&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
    ff &lt;span&gt;=&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;w&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    ff&lt;span&gt;.&lt;/span&gt;write&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;enter now\n&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;yield&lt;/span&gt; ff
    &lt;span&gt;except&lt;/span&gt; RuntimeError&lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;
    ff&lt;span&gt;.&lt;/span&gt;write&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;exit now&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    ff&lt;span&gt;.&lt;/span&gt;close&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;with&lt;/span&gt; open_file&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.txt&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
    f&lt;span&gt;.&lt;/span&gt;write&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;Hello World!\n&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;contextmanager 是要使用的装饰器，yield 关键字将普通的函数变成了生成器。yield 的返回值（ff）等于上例__enter__()的返回值，也就是 as 语句的值（f），而 yield 前后的内容，分别是__enter__() 和 __exit__() 方法里的内容。&lt;/div&gt;
&lt;div&gt;使用 contextlib，可以避免类定义、__enter__() 和 __exit__() 方法，但是需要我们捕捉可能的异常（例如，yield 只能返回一个值，否则会导致异常 RuntimeError），所以 try…except 语句不能忽略。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>犬只未经免疫，不得饲养</title>
            <link>https://pythoncat.top/posts/2018-10-11-dog/</link>
            <guid>https://pythoncat.top/posts/2018-10-11-dog/</guid>
            <description>大前天晚上，回家刚到楼下时，豌豆被一只调皮活跃的小狗抓了两道长长的爪痕</description>
            <pubDate>Thu, 11 Oct 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;早上出门的时候，看到小区里拉起了横幅——“犬只未经免疫，不得饲养”。&lt;/div&gt;
&lt;div&gt;小区物业的行动还是挺迅速的嘛。&lt;/div&gt;
&lt;div&gt;大前天晚上，回家刚到楼下时，豌豆被一只调皮活跃的小狗抓了两道长长的爪痕。&lt;/div&gt;
&lt;div&gt;当时我看豌豆没有流血，皮也没划破，所以还是挺镇定。现在才知道想起来害怕，如果那抓痕再大力点怎么办？如果那不是一只小狗，是一只大狗，把人咬了，或者绊倒了可怎么办？&lt;/div&gt;
&lt;div&gt;现在想起当晚，那只狗毫无征兆跑过来，我停下来对着它，它就绕过我，到了豌豆那侧，往她脚上扑。一切发生的太快。&lt;/div&gt;
&lt;div&gt;豌豆害怕又委屈，弯腰看不仔细，她直接坐了地上。我们开手机的手电筒，看来看去，没有流血，没有破皮。&lt;/div&gt;
&lt;div&gt;我虽然一直在询问豌豆，在看她脚，但其实很无措。豌豆冲狗主人问，你的狗有没有打疫苗的？那男人说，只是小狗没事的。&lt;/div&gt;
&lt;div&gt;现在想来，他没有正面回答，那就意味着小狗根本没有打过疫苗！&lt;/div&gt;
&lt;div&gt;面对突发事件，我们经验太少。事后，给人描述那狗的样子、狗主人的样子，说的都很笼统。&lt;/div&gt;
&lt;div&gt;豌豆的妈妈听我们讲完经过，很快就说那人可能是我们楼上某某室的，她坐电梯曾见过。在这种事件前面，豌豆妈妈是个让人放心的行动派，她认识小区物业主任，马上就打电话过去了。&lt;/div&gt;
&lt;div&gt;她们才说了几句，物业主任根据“一个男人带着狗、可能在我们楼上”，就锁定了“嫌疑犯”。听到这，我们马上就放心一些了。&lt;/div&gt;
&lt;div&gt;豌豆妈妈跟那主任说，要管管小区养狗的，这遛狗不牵绳子，万一是碰到谁家小孩，很容易就出大事。那主任一个劲的应“是的啊”，很上心给意见，还答应亲自找那狗主人说这事。（她确实去找了所怀疑的那户，但不过并不是他…）&lt;/div&gt;
&lt;div&gt;我们到家后，反反复复观察抓痕好几次。豌豆不放心，跑去冲洗了三次。&lt;/div&gt;
&lt;div&gt;家里灯光亮，看得更清楚。右腿抓痕有两处，左腿一处，都差不多巴掌长。确实没有破皮，摸上去也没有疼痛。等第二天，我们到医院看医生的时候，那抓痕已经淡得看不清了。&lt;/div&gt;
&lt;div&gt;我对被狗抓和得狂犬病，没有清醒认识。不过豌豆他们，还有那物业主任都说不能大意，一定要去打疫苗。这好像是一道只有一个选项的选择题。那就去打吧。&lt;/div&gt;
&lt;div&gt;我第一次知道，狂犬病疫苗要打5次。而且，不是每个医院都有条件去打。&lt;/div&gt;
&lt;div&gt;前天，我跟豌豆去医院，把照片给医生看完，他就说这很明显了，要打疫苗的。于是我们打了疫苗。&lt;/div&gt;
&lt;div&gt;当时没啥不良反应，昨天白天也好好的。&lt;/div&gt;
&lt;div&gt;但是，昨天晚上，豌豆身上突然就痛起来。豌豆说那种痛是”刺痛“，痛得厉害。&lt;/div&gt;
&lt;div&gt;今天，我们很不放心，又去了医院。医生说打完疫苗是可能有不良反应，说的时候有点专业人士看外行的感觉。他当然代表了专家，但是痛得睡不好觉、忧心忡忡的又不是他！&lt;/div&gt;
&lt;div&gt;明天要去打第二针。痛也只能“观察”几天。&lt;/div&gt;
&lt;div&gt;现在就是这种局面：豌豆被狗抓了，看起来无关紧要，但实在不放心，去打了疫苗，不良反应痛得难受，接下来还有4次疫苗要去打。&lt;/div&gt;
&lt;div&gt;除了心怀乐观，按时再去打疫苗，我们好像没啥好过度担心的了。只愿一切顺利。&lt;/div&gt;
&lt;div&gt;写到这里，最后想跟各位读者再多说几句：&lt;/div&gt;
&lt;div&gt;1、走路注意防范，特别注意小区里横冲直撞的小宠物！&lt;/div&gt;
&lt;div&gt;2、遇到意外，镇定不慌，留下人证物证！&lt;/div&gt;
&lt;div&gt;3、了解一些狂犬病、打疫苗、不良反应的知识！&lt;/div&gt;
&lt;div&gt;4、犬只未经免疫，不得饲养！还有，遛狗请牵好绳子！&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>毕业五年后回武大，母校我有些话想对你说</title>
            <link>https://pythoncat.top/posts/2018-10-06-wuda/</link>
            <guid>https://pythoncat.top/posts/2018-10-06-wuda/</guid>
            <description>也许真应了古人说的&quot;三十而立&quot;，三十是男人必须要过的一道坎。想不想立，能不能立，都挡不住这重考验的来临。</description>
            <pubDate>Sat, 06 Oct 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;疲累的一天过去了，今晚或许可以睡个好觉。趁还没睡，母校，请你听我说说话吧。昨晚失眠，好像跟你说了好多话，却又好似只开了个头。恐怕还是得写下来才说得明白。&lt;/div&gt;
&lt;div&gt;毕业后，我留汉一年多，算起来，真正离开你的日子是四年。今年，最有意念要回来看看你。&lt;/div&gt;
&lt;div&gt;说是要看你，其实我骗不了你，你知道，我是想看看我自己。&lt;/div&gt;
&lt;div&gt;也许真应了古人说的”三十而立”，三十是男人必须要过的一道坎。想不想立，能不能立，都挡不住这重考验的来临。&lt;/div&gt;
&lt;div&gt;母校，你可能以为我算早了年龄，但是没有。我母亲告诉过我，当年入户口的时候，他们故意把我的年龄报小了一岁。不怕你笑话，在我们那里的农村，这种不实报并不罕见，至于原因我却忘了。&lt;/div&gt;
&lt;div&gt;我长期自欺欺人地想，我是八零尾，所以有些晚熟、未熟的地方，都能合理解释。&lt;/div&gt;
&lt;div&gt;现在看来，该响的铃声还是会如期响起。而且，响铃声可能还要更嘹亮些。&lt;/div&gt;
&lt;div&gt;最近，失眠的次数多了，我审视自己的角度也多了。比如睡姿。刚入学那会，我是蜷缩着睡，后来，你应该看见了，我逐渐发展成趴着睡。&lt;/div&gt;
&lt;div&gt;每次失眠，这种睡姿就成了一种痛苦折磨。&lt;/div&gt;
&lt;div&gt;手脚酸麻，心脏压抑，呼吸气堵，辗转反侧，然后再来一个周期。真不敢相信，以前我怎么会那般睡得安稳。&lt;/div&gt;
&lt;div&gt;这大概就是一种启示了吧，舒适区该换了。对吧，母校？&lt;/div&gt;
&lt;div&gt;这次回来，看见了很多新气象。万林艺术博物馆、卓尔体育馆、当代楼，以及信息学部的图书馆，这些新建筑拔地而起，异常夺目。百年老校换上了年轻的面孔。&lt;/div&gt;
&lt;div&gt;最不可思议的是，鲲鹏广场上的樱花树竟然散开着几朵花，挑战了我对于季节的认知。秋天的樱花，偏让我们见了，这是不是母校您要我来参化的谜题啊？&lt;/div&gt;
&lt;div&gt;樱花虽然是异族之花，但现在外人提及武大，首先联想到的就是它。向他人介绍武大，樱花成了首选，通俗而有效。&lt;/div&gt;
&lt;div&gt;校园的山水养成樱花，樱花的名声也反向参与塑造学校的气质。&lt;/div&gt;
&lt;div&gt;我其实挺羡慕这些樱花学长/学姐，他们的根就一直扎在这片土地，学业结束了也不用离开。一年又一年，读完了本科，又读完了研究生，还读完了博士，现在是留校任教了。&lt;/div&gt;
&lt;div&gt;还有那满园的桂花，香浓纯郁的不像样子，只懂得引人沉醉，完全不管象牙塔外的纷纷扰扰。可羡啊。&lt;/div&gt;
&lt;div&gt;不知不觉，我工作五年了。母校啊，时间在初回首时，似乎都显得极短暂。记忆是对时间的压缩，而话语又是对记忆的压缩，所以如今跟你说话，就像刚被外来游客打断，然后又重新接上话一样。&lt;/div&gt;
&lt;div&gt;可是，翻查记忆，每年发生的事拼接成串，又证明着这五年的真实。&lt;/div&gt;
&lt;div&gt;五年来，校园里的法国梧桐树更高了，树干又壮了一圈，再相见，我有些胆怯。因为我就像一棵枯瘦的梅树，还只是当年的样子。&lt;/div&gt;
&lt;div&gt;最近，某档节目出了一道题目，说“毕业后混得normal，要不要去同学会”。normal的我自问能带上自尊过去，但对我来说，真正的问题是，为何我要是normal的那个呢？&lt;/div&gt;
&lt;div&gt;母校啊，或许你会宽容地说，“孩子，你并不normal”。我信，因为很多年前，也有人这么说过。&lt;/div&gt;
&lt;div&gt;我有时候也这么对自己说。但每次拿来说服自己的理由都是旧的，如果它们每次都管用，那跟《盗梦空间》里旋转不会停的陀螺有啥区别？&lt;/div&gt;
&lt;div&gt;母校啊，有时候我会幻想，如果让我变回刚入校门的时候，我要做这做那，要这个时候做这件事，要那个时候做那件事，要这样做这件事，要那样做那件事。&lt;/div&gt;
&lt;div&gt;若真有这样的机会，或许是会有一些不同。然而，一生的变数太多了，而欲望又是那么难以填满，幻想改变过去，不如实实在在地过好现在。&lt;/div&gt;
&lt;div&gt;这次回校，我想再看看这里的山水花木，看看年久的老建筑和弯弯曲曲的道路，闻闻桂花香，吹吹珞珈风，离开道路走进草地里。&lt;/div&gt;
&lt;div&gt;心愿完成了。也到离别的时候了。&lt;/div&gt;
&lt;div&gt;母校，下次的归期，不知要到何时。&lt;/div&gt;
&lt;div&gt;最后，想跟你说的是，我想明白了一件事。我做不了高大的法国梧桐，但是苦梅花也有自己开花的时节，就算是错过了季节，也有那几树樱花，终于等到这秋高气爽的时候会绽放。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>学习 Python 操作 JSON，网络数据交换不用愁</title>
            <link>https://pythoncat.top/posts/2018-10-06-json/</link>
            <guid>https://pythoncat.top/posts/2018-10-06-json/</guid>
            <description>JSON 是什么？JSON 与 XML 的优劣差异？Python 如何操作 Json？</description>
            <pubDate>Sat, 06 Oct 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;今天带大家学学 Python 中操纵 JSON 的知识。学完本文，你可以学到如下内容：&lt;/div&gt;
&lt;div&gt;1、JSON 是什么？&lt;/div&gt;
&lt;div&gt;2、JSON 与 XML 的优劣差异？&lt;/div&gt;
&lt;div&gt;3、将 Python 对象编码成 JSON 字符串&lt;/div&gt;
&lt;div&gt;4、将已编码的 JSON 字符串解码为 Python 对象&lt;/div&gt;
&lt;div&gt;5、解决 JSON 中文乱码问题&lt;/div&gt;
&lt;h2&gt;JSON 是什么？&lt;/h2&gt;
&lt;div&gt;JSON 的全称是  JavaScript Object Notation，是一种轻量级的数据交换格式。最初，JSON 只是 JavaScript 的子集，但由于其简单易用而迅速走红。&lt;/div&gt;
&lt;div&gt;现今大部分编程语言都支持对 JSON 的解析与生成，而近些年异军突起的 NoSQL 数据库也多参照 JSON 来设计数据存储格式，例如 Mongodb 的BSON（Binary JSON）。&lt;/div&gt;
&lt;div&gt;JSON 有以下六种数据类型：number、boolean、string、null、array、object。前三种很好理解，第四个 null 对应 Python 的 None，最后两种，对应 Python 的列表和字典。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;{&lt;/span&gt;
  &lt;span&gt;&quot;name&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;小明&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
  &lt;span&gt;&quot;age&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
  &lt;span&gt;&quot;gender&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
  &lt;span&gt;&quot;grade&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
  &lt;span&gt;&quot;skills&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;
    &lt;span&gt;&quot;JavaScript&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    &lt;span&gt;&quot;Java&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    &lt;span&gt;&quot;Python&quot;&lt;/span&gt;
  &lt;span&gt;]&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;JSON 与XML 的优劣差异？&lt;/h2&gt;
&lt;div&gt;在 JSON 出现之前，人们用 XML 在网络上交换数据，在 JSON 出现后，它基本上就取代了 XML 的位置。两者的共同之处显而易见，它们都是结构化的语言，都可以用于网络数据的交换。&lt;/div&gt;
&lt;div&gt;两者最大的差异在于它们的“出身”不同，也就是它们被创造的目的不同。&lt;/div&gt;
&lt;div&gt;XML 是 W3C（万维网联盟）发布的可扩展标记语言（Extensible Markup Language），最初设计来弥补 HTML 的不足，以强大的扩展性满足网络信息发布的需要，与它“同级”的有：XHTML\CSS\ECMAScript等。&lt;/div&gt;
&lt;div&gt;它包含 DTD、XSD、XPath、XSL 等一大堆复杂的规范，在数据存储、扩展及高级检索等方面都有作用。后来被用于网络数据交换，颇有点大材小用的意思，虽然可胜任，却也有点复杂和冗余。&lt;/div&gt;
&lt;div&gt;而 JSON 是 ECMAScript 标准的子集，设计之初就是为了克服 XML 在数据交换上的劣势，所以一方面，它像 XML 一样具有简洁而清晰的层次结构，另一方面，它比 XML 小巧精致，更加适用于网络数据的传输。&lt;/div&gt;
&lt;div&gt;JSON 也不是没有缺点，当结构层级很多的时候，它会让人陷入繁琐复杂的数据节点查找中，在可读性上要比 XML 差。&lt;/div&gt;
&lt;h2&gt;将 Python 对象编码成 JSON 字符串&lt;/h2&gt;
&lt;div&gt;将 Python 的对象转化为字符串，这个过程也称为序列化，与之相对，将 JSON 字符串转化为 Python 对象，这个过程被称为反序列化。&lt;/div&gt;
&lt;div&gt;序列化格式如下，json.dumps() 把 Python 对象序列化，json.dump() 先序列化，然后将内容存入文件：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)&lt;/li&gt;
&lt;li&gt;json.dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; json
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; d &lt;span&gt;=&lt;/span&gt; &lt;span&gt;dict&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;Tom&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; age&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;8&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; score&lt;span&gt;=&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; json&lt;span&gt;.&lt;/span&gt;dumps&lt;span&gt;(&lt;/span&gt;d&lt;span&gt;)&lt;/span&gt;
Out&lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;{&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: &quot;8&quot;, &quot;score&quot;: 88}&apos;&lt;/span&gt;
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.json&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;w&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
   &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;     json&lt;span&gt;.&lt;/span&gt;dump&lt;span&gt;(&lt;/span&gt;d&lt;span&gt;,&lt;/span&gt; f&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;用的比较多的参数有：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;ensure_ascii=True 设置是否编码为ASCII，默认是，若False，则使用原编码格式&lt;/li&gt;
&lt;li&gt;indent=None 设置打印时缩进，默认不缩进&lt;/li&gt;
&lt;li&gt;separators=None 设置分隔符，取值是(item_separator, dict_separator)元组，默认为(‘,’,’:’)，这表示keys之间用“,”隔开，而key和value之间用“:”隔开&lt;/li&gt;
&lt;li&gt;sort_keys=False  设置按key值排序，默认不排序&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; d &lt;span&gt;=&lt;/span&gt; &lt;span&gt;dict&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;Python猫&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; age&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;8&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; score&lt;span&gt;=&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; json&lt;span&gt;.&lt;/span&gt;dumps&lt;span&gt;(&lt;/span&gt;d&lt;span&gt;)&lt;/span&gt;
Out&lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;{&quot;name&quot;: &quot;Python\\u732b&quot;, &quot;age&quot;: &quot;8&quot;, &quot;score&quot;: 88}&apos;&lt;/span&gt;

In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; json&lt;span&gt;.&lt;/span&gt;dumps&lt;span&gt;(&lt;/span&gt;d&lt;span&gt;,&lt;/span&gt; ensure_ascii&lt;span&gt;=&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; indent&lt;span&gt;=&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; sort_keys&lt;span&gt;=&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
Out&lt;span&gt;[&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;{\n    &quot;age&quot;: &quot;8&quot;,\n    &quot;name&quot;: &quot;Python猫&quot;,\n    &quot;score&quot;: 88\n}&apos;&lt;/span&gt;

In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;json&lt;span&gt;.&lt;/span&gt;dumps&lt;span&gt;(&lt;/span&gt;d&lt;span&gt;,&lt;/span&gt; ensure_ascii&lt;span&gt;=&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; indent&lt;span&gt;=&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; sort_keys&lt;span&gt;=&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;&quot;age&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;8&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    &lt;span&gt;&quot;name&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;Python猫&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    &lt;span&gt;&quot;score&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;88&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;将已编码的 JSON 字符串解码为 Python 对象&lt;/h2&gt;
&lt;div&gt;反序列化格式如下，json.loads() 从内存中读取内容解析，json.load() 从文件中读取内容解析：&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;json.loads(s, *, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)&lt;/li&gt;
&lt;li&gt;json.load(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; json
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; d &lt;span&gt;=&lt;/span&gt; &lt;span&gt;dict&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;Tom&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; age&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos;8&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; score&lt;span&gt;=&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; tom_json &lt;span&gt;=&lt;/span&gt; json&lt;span&gt;.&lt;/span&gt;dumps&lt;span&gt;(&lt;/span&gt;d&lt;span&gt;)&lt;/span&gt;
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; json&lt;span&gt;.&lt;/span&gt;loads&lt;span&gt;(&lt;/span&gt;tom_json&lt;span&gt;)&lt;/span&gt;
Out&lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;age&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;8&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;Tom&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;score&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;88&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
In &lt;span&gt;[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;test.json&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;r&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; f&lt;span&gt;:&lt;/span&gt;
   &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;json&lt;span&gt;.&lt;/span&gt;load&lt;span&gt;(&lt;/span&gt;f&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;name&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;Tom&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;age&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;8&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;score&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;88&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;json.loads() 比 json.load() 多了一个 encoding 参数，可以将传入的字符串重新编码。&lt;/div&gt;
&lt;h2&gt;解决中文乱码问题&lt;/h2&gt;
&lt;div&gt;序列化的 ensure_ascii 参数与反序列化的 encoding 相对应，都是处理字符编码，一旦处理不好，就会导致中文乱码问题。&lt;/div&gt;
&lt;div&gt;Python2 的字符编码乱七八糟，也广被人诟病，如果不幸遇到 Python2 项目，可参照如下例子解决。&lt;/div&gt;
&lt;div&gt;字符串在 Python2 内部的表示是 unicode 编码。因此，在做编码转换时，需要以 unicode 作为中间编码，即先将其他编码的字符串解码（decode）成 unicode，再从 unicode 编码（encode）成另一种编码。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
m &lt;span&gt;=&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;你好&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt; m
&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&apos;a&apos;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&apos;\xe4\xbd\xa0\xe5\xa5\xbd&apos;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt; json&lt;span&gt;.&lt;/span&gt;dumps&lt;span&gt;(&lt;/span&gt;m&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&quot;a&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;\u4f60\u597d&quot;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt; json&lt;span&gt;.&lt;/span&gt;dumps&lt;span&gt;(&lt;/span&gt;m&lt;span&gt;,&lt;/span&gt;ensure_ascii&lt;span&gt;=&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&quot;a&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;浣犲ソ&quot;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt; json&lt;span&gt;.&lt;/span&gt;dumps&lt;span&gt;(&lt;/span&gt;m&lt;span&gt;,&lt;/span&gt;ensure_ascii&lt;span&gt;=&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;decode&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;utf8&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;encode&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;gb2312&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&quot;a&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;你好&quot;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Python3 的默认编码格式是 utf-8，以上例子，只需要&lt;code&gt;ensure_ascii=False&lt;/code&gt;，就能解决。&lt;/p&gt;</content:encoded>
        </item>
        <item>
            <title>超强汇总：学习 Python 列表，只需这篇文章就够了</title>
            <link>https://pythoncat.top/posts/2018-10-02-list/</link>
            <guid>https://pythoncat.top/posts/2018-10-02-list/</guid>
            <description>千里之行，始于足下。温习关于列表的基础知识</description>
            <pubDate>Tue, 02 Oct 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;千里之行，始于足下。要练成一双洞悉一切的眼睛，还是得先把基本功扎扎实实地学好。今天，本喵带大家仔细温习一下 Python 的列表。温故而知新，不亦说乎。&lt;/div&gt;
&lt;div&gt;当然，温习的同时也要发散思考，因为有些看似无关紧要的、约定俗成的语言习惯，例如数组索引为何从0开始，其背后可能大有来历。知其然，亦需知其所以然啊喵喵喵~~~&lt;/div&gt;
&lt;div&gt;最后，在基础知识之上，更要探索进阶，例如学习生成器表达式，这样既能更扎实地掌握基础，又能融会贯通，获得更全面的认知升级。&lt;/div&gt;
&lt;h2&gt;Python的列表是怎样滴？&lt;/h2&gt;
&lt;div&gt;列表（list）是一种有序的集合，可以随时添加、查找和删除元素。&lt;/div&gt;
&lt;div&gt;列表支持加入不同数据类型的元素：数字、字符串、列表、元组等。&lt;/div&gt;
&lt;div&gt;列表通过有序的索引可遍历所有的元素，从前往后数，索引是[0,n-1]，从后往前数，索引是[-1, -n]，其中n是列表的长度。&lt;/div&gt;
&lt;div&gt;列表可以是不含元素的空列表，也可以包含超级多的元素（在内存大小支持的情况下）。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;list_a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;   &lt;span&gt;# 空列表，即len(list_a) == 0&lt;/span&gt;
list_b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;2018-10-1&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;hi&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;44&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;# list_b 长度为5，包含2个数字元素、1个字符串元素、1个列表元素和1个元组元素&lt;/span&gt;
&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;list_b&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;
list_b&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; list_b&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;
lits_b&lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; list_b&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;hi&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; 
lits_b&lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; list_b&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;44&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;Python中怎么操作列表？&lt;/h2&gt;
&lt;div&gt;&lt;strong&gt;1）创建列表：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;用中括号[]包裹元素，元素使用逗号分隔。&lt;/div&gt;
&lt;div&gt;用list()方法，转化生成列表。&lt;/div&gt;
&lt;div&gt;列表生成式/列表解析式/列表推导式，生成列表。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;list_a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
list_b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;abc&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# list_b == [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]&lt;/span&gt;
list_c &lt;span&gt;=&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# list_c == [4, 5, 6]&lt;/span&gt;
list_d &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; list_a&lt;span&gt;]&lt;/span&gt;  &lt;span&gt;# list_d == [1, 2, 3]&lt;/span&gt;
list_e &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;i&lt;span&gt;*&lt;/span&gt;j &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; list_a &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; list_c&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# list_e == [4,5,6,10,12,12,15,18]&lt;/span&gt;
list_f &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;i&lt;span&gt;*&lt;/span&gt;j &lt;span&gt;for&lt;/span&gt; i&lt;span&gt;,&lt;/span&gt;j &lt;span&gt;in&lt;/span&gt; &lt;span&gt;zip&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;list_a&lt;span&gt;,&lt;/span&gt;list_c&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# list_f == [4, 10, 18]&lt;/span&gt;
list_g &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; list_a &lt;span&gt;if&lt;/span&gt; i&lt;span&gt;%&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# list_g == [2]&lt;/span&gt;

&lt;span&gt;# 结合range()函数，range(start, stop[, step])&lt;/span&gt;
list_h &lt;span&gt;=&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# list_h == [0, 1, 2]&lt;/span&gt;
list_i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# list_i == [3, 4, 5, 6]&lt;/span&gt;
list_j &lt;span&gt;=&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# list_j == [3, 5, 7]&lt;/span&gt;

&lt;span&gt;# 找出100以内的能够被3整除的正整数&lt;/span&gt;
list_k &lt;span&gt;=&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# list_k == [3, 6, 9, ..., 96, 99]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;2）扩充列表：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;用append()方法，在列表尾部添加单个新元素。&lt;/div&gt;
&lt;div&gt;用insert()方法，在列表中指定位置添加元素。&lt;/div&gt;
&lt;div&gt;用 “+” 运算符，将两个列表拼接出一个新列表。&lt;/div&gt;
&lt;div&gt;用extend()方法，在一个列表后面拼接进另一个列表。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 以下分别添加2个元素&lt;/span&gt;
list_a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
list_a&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;happy&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# list_a == [&apos;happy&apos;]&lt;/span&gt;
list_a&lt;span&gt;.&lt;/span&gt;insert&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;very&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# list_a == [&apos;very&apos;, &apos;happy&apos;]&lt;/span&gt;

&lt;span&gt;# 以下两种扩充列表方式&lt;/span&gt;
list_1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;I&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;am&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
list_2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;very&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;happy&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
list_3 &lt;span&gt;=&lt;/span&gt; list_1 &lt;span&gt;+&lt;/span&gt; list_2  &lt;span&gt;# 新列表 list_3 == [&apos;I&apos;, &apos;am&apos;, &apos;very&apos;, &apos;happy&apos;]&lt;/span&gt;
list_1&lt;span&gt;.&lt;/span&gt;extend&lt;span&gt;(&lt;/span&gt;list_2&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 原列表1扩充，list_1 == [&apos;I&apos;, &apos;am&apos;, &apos;very&apos;, &apos;happy&apos;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;3）删减列表与销毁列表：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;用del list[m] 语句，删除指定索引m处的元素。&lt;/div&gt;
&lt;div&gt;用remove()方法，删除指定值的元素（第一个匹配项）。&lt;/div&gt;
&lt;div&gt;用pop()方法，取出并删除列表末尾的单个元素。&lt;/div&gt;
&lt;div&gt;用pop(m)方法，取出并删除索引值为m的元素。&lt;/div&gt;
&lt;div&gt;用clear()方法，清空列表的元素。（杯子还在，水倒空了）&lt;/div&gt;
&lt;div&gt;用del list 语句，销毁整个列表。（杯子和水都没有了）&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 以下4种删除列表元素方式&lt;/span&gt;
list_1 &lt;span&gt;=&lt;/span&gt; list_2 &lt;span&gt;=&lt;/span&gt; list_3 &lt;span&gt;=&lt;/span&gt; list_4 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;I&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;am&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;very&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;happy&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt; list_1&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;  &lt;span&gt;# list_1 == [&apos;am&apos;, &apos;very&apos;, &apos;happy&apos;]&lt;/span&gt;
list_2&lt;span&gt;.&lt;/span&gt;remove&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;I&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# list_2 == [&apos;am&apos;, &apos;very&apos;, &apos;happy&apos;]&lt;/span&gt;
list_3&lt;span&gt;.&lt;/span&gt;pop&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# list_3 == [&apos;I&apos;, &apos;am&apos;, &apos;very&apos;]&lt;/span&gt;
list_4&lt;span&gt;.&lt;/span&gt;pop&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# list_4 == [&apos;am&apos;, &apos;very&apos;, &apos;happy&apos;]&lt;/span&gt;

&lt;span&gt;# 清空与销毁&lt;/span&gt;
list_a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
list_b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
list_b&lt;span&gt;.&lt;/span&gt;clear&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# list_b == []&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt; list_a  &lt;span&gt;# 没有list_a了，再使用则会报错&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;4）列表切片：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;基本含义：&lt;strong&gt;从第i位索引起，向右取到后n位元素为止，按m间隔过滤&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;基本格式：[i : i+n : m] ；i 是切片的起始索引值，为列表首位时可省略；i+n 是切片的结束位置，为列表末位时可省略；m 可以不提供，默认值是1，不允许为0，当m为负数时，列表翻转。注意：这些值都可以大于列表长度，不会报越界。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;li &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;# 以下写法都可以表示整个列表，其中 X &amp;gt;= len(li)&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;X&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;X&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;X&lt;span&gt;:&lt;/span&gt;X&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;X&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 从1起，取5-1位元素&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 从1起，取5-1位元素，按2间隔过滤&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 取倒数第一个元素&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 从倒数第四起，取-2-(-4)=2位元素&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;li&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 从头开始，取-2-(-len(li))=7位元素&lt;/span&gt;

&lt;span&gt;# 注意列表先翻转，再截取&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 翻转整个列表&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 翻转整个列表，再按2间隔过滤&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 翻转整个列表，取-5-(-len(li))=4位元素&lt;/span&gt;
li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;# 翻转整个列表，取-5-(-len(li))=4位元素，再按3间隔过滤&lt;/span&gt;

li&lt;span&gt;[&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;  &lt;span&gt;# 报错（ValueError: slice step cannot be zero）&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;5) 其它操作：&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;用len()方法，统计全部元素的个数。&lt;/div&gt;
&lt;div&gt;用count()方法，统计指定值的元素的个数。&lt;/div&gt;
&lt;div&gt;用max()方法，统计元素中的最大值（要求元素类型相同；数字类型直接比较，其它类型比较id）&lt;/div&gt;
&lt;div&gt;用min()方法，统计元素中的最小值（要求元素类型相同；数字类型直接比较，其它类型比较id）&lt;/div&gt;
&lt;div&gt;用index()方法，查找指定值的元素的索引位置（第一个匹配项）。&lt;/div&gt;
&lt;div&gt;用reverse()方法，翻转列表中的元素。&lt;/div&gt;
&lt;div&gt;用copy()方法，浅拷贝并生成新的列表。&lt;/div&gt;
&lt;div&gt;用deepcopy()方法，深拷贝并生成新的列表。&lt;/div&gt;
&lt;div&gt;用sort()方法，在原列表基础上进行排序。&lt;/div&gt;
&lt;div&gt;用sorted()方法，将新列表基础上对原列表的元素进行排序。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;list_1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;2018-10-1&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;hi&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;44&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;list_1&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;
list_1&lt;span&gt;.&lt;/span&gt;count&lt;span&gt;(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;# 元素10的数量为1&lt;/span&gt;
list_1&lt;span&gt;.&lt;/span&gt;index&lt;span&gt;(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;# 元素10的索引为1&lt;/span&gt;
list_1&lt;span&gt;.&lt;/span&gt;reverse&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# list_1 == [(33, 44), [&apos;hi&apos;, 1, 2], &apos;2018-10-1&apos;, 10, 2018]&lt;/span&gt;


&lt;span&gt;# 比较浅拷贝与深拷贝&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; copy
list_a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;2018-10-1&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;hi&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;44&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
list_b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;hi&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
list_c &lt;span&gt;=&lt;/span&gt; list_a&lt;span&gt;.&lt;/span&gt;copy&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# list_c == [2018, 10, &apos;2018-10-1&apos;, [&apos;hi&apos;, 1, 2], (33, 44)]&lt;/span&gt;
list_d &lt;span&gt;=&lt;/span&gt; copy&lt;span&gt;.&lt;/span&gt;deepcopy&lt;span&gt;(&lt;/span&gt;list_a&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# list_d == [2018, 10, &apos;2018-10-1&apos;, [&apos;hi&apos;, 1, 2], (33, 44)]&lt;/span&gt;
&lt;span&gt;# 改变原列表中的可变对象元素&lt;/span&gt;
list_a&lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;append&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;new&apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# list_a == [2018, 10, &apos;2018-10-1&apos;, [&apos;hi&apos;, 1, 2, &apos;new&apos;], (33, 44)]&lt;/span&gt;
&lt;span&gt;# 浅拷贝中的可变对象会随原列表变化而变化&lt;/span&gt;
list_c &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;2018-10-1&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;hi&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;new&apos;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;44&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;# 深拷贝中的可变对象不会随原列表变化而变化&lt;/span&gt;
list_d &lt;span&gt;==&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&apos;2018-10-1&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&apos;hi&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;44&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;


&lt;span&gt;# 比较sort() 与 sorted()&lt;/span&gt;
list_1 &lt;span&gt;=&lt;/span&gt; list_2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
list_1&lt;span&gt;.&lt;/span&gt;sort&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 原列表变化：list_1 == [1,2,3,4,5,6]&lt;/span&gt;
list_3 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;sorted&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;list_2&lt;span&gt;)&lt;/span&gt; &lt;span&gt;# 原列表不变：list_2 == [2,1,4,6,5,3]; list_3 == [1,2,3,4,5,6]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;h2&gt;Python列表索引为何从0始？&lt;/h2&gt;
&lt;div&gt;权威解释来自Guido van Rossum（Python之父）的博文：《Why Python uses 0-based indexing》&lt;/div&gt;
&lt;div&gt;一句话总结：索引从0开始，切片用法很优雅。&lt;/div&gt;
&lt;div&gt;翻译精华如下：&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;我决定在Python中使用0-based索引方式的一个原因，就是切片语法(slice notation)。&lt;/p&gt;
&lt;p&gt;让我们来先看看切片的用法。可能最常见的用法，就是“取前n位元素”或“从第i位索引起，取后n位元素”(前一种用法，实际上是i==起始位的特殊用法)。如果这两种用法实现时可以不在表达式中出现难看的+1或-1，那将会非常的优雅。&lt;/p&gt;
&lt;p&gt;使用0-based的索引方式、半开区间切片和缺省匹配区间的话（Python最终采用这样的方式），上面两种情形的切片语法就变得非常漂亮：a[:n]和a[i:i+n]，前者是a[0:n]的缩略写法。&lt;/p&gt;
&lt;p&gt;如果使用1-based的索引方式，那么，想让a[:n]表达“取前n个元素”的意思，你要么使用闭合区间切片语法，要么在切片语法中使用切片起始位和切片长度作为切片参数。半开区间切片语法如果和1-based的索引方式结合起来，则会变得不优雅。而使用闭合区间切片语法的话，为了从第i位索引开始取后n个元素，你就得把表达式写成a[i:i+n-1]。&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;特别是当两个切片操作位置邻接时，第一个切片操作的终点索引值是第二个切片的起点索引值时，太漂亮了，无法舍弃。例如，你想将一个字符串以i，j两个位置切成三部分，这三部分的表达式将会是a[:i]，a[i:j]和a[j:]。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;其它编程语言的索引？&lt;/h2&gt;
&lt;div&gt;索引从0开始的编程语言：C、C++、Python、Java、PHP、Ruby、Javascript…&lt;/div&gt;
&lt;div&gt;索引从1开始的编程语言：ABC、Matlab、VB、易语言、大部分shell语言…&lt;/div&gt;
&lt;div&gt;索引从其它值开始的编程语言：Pascal、Lua…&lt;/div&gt;
&lt;div&gt;还有像表示星期、月份等序列结构的数据，各种编程语言也划分成了不同阵营。&lt;/div&gt;
&lt;div&gt;它们出于何种考虑？&lt;/div&gt;
&lt;div&gt;C语言：索引从0开始，可以大大提升内存寻址计算的效率，详细分析参考《&lt;a href=&quot;https://blog.csdn.net/bufanq/article/details/51330197&quot;&gt;C语言数组元素下标为何从0开始&lt;/a&gt;》&lt;/div&gt;
&lt;div&gt;大部分shell语言：大多数是从1开始，来源参考&lt;a href=&quot;https://unix.stackexchange.com/questions/252368/is-there-a-reason-why-the-first-element-of-a-zsh-array-is-indexed-by-1-instead-o&quot;&gt;stackexchange这篇问答&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;Pascal、Lua：默认从1开始，但支持改变起始索引值，原因据说是对非专业的开发者更友好，来源参考&lt;a href=&quot;https://www.zhihu.com/question/19675689/answer/19174752&quot;&gt;这篇知乎问答&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;以上列举的原因是最审慎的、体面的解释，话题应该到此终结，因为“索引应该从几开始最好”这个问题的破坏性不亚于“哪种编程语言是最好的”…&lt;/div&gt;
&lt;h2&gt;优雅漂亮的结尾：生成器表达式&lt;/h2&gt;
&lt;div&gt;列表生成式是一种漂亮优雅的东西，然而它有一个致命的缺点：它一次性把所有元素加载到内存中，当列表过长的时候，便会占据过多的内存资源，而且，我们通常仅需要使用少数的元素，这样未使用的元素所占据的绝大部分的内存，就成了不必要的支出。&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;生成器是一种更高级更优雅的东西，它使用“懒加载”的原理，并不生成完整的列表，而是迭代地、即时地、按需地生成元素，这样不仅能极大地节省内存空间，而且，在理论上，它可以生成一个无穷大的列表！&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;大多数生成器是以函数来实现的，然而，它并不返回（return）一个值，而是生成（yield）一个值，并挂起程序。然后，通过next()方法生成并马上返回一个元素，或者通过for循环，逐一生成和返回全部元素。&lt;/div&gt;
&lt;div&gt;next()效率太低，且调用次数越界时会抛出StopIteration的异常，而for循环会自动捕捉这个异常，并停止调用，所以使用更佳。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;# 计算斐波那契数列的生成器&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;fibon&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;n&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
a &lt;span&gt;=&lt;/span&gt; b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;n&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
&lt;span&gt;yield&lt;/span&gt; a  &lt;span&gt;# 使用yield&lt;/span&gt;
a&lt;span&gt;,&lt;/span&gt; b &lt;span&gt;=&lt;/span&gt; b&lt;span&gt;,&lt;/span&gt; a &lt;span&gt;+&lt;/span&gt; b

&lt;span&gt;# 计算前1000000个数，通过next()函数，按顺序每次生成一个数&lt;/span&gt;
g &lt;span&gt;=&lt;/span&gt; fibon&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1000000&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;g&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 1&lt;/span&gt;
&lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;g&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 1&lt;/span&gt;
&lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;g&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 2&lt;/span&gt;
&lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;g&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 3&lt;/span&gt;
&lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;g&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 5&lt;/span&gt;
&lt;span&gt;# 以此类推，但若调用超过1000000次，就会报异常StopIteration&lt;/span&gt;

&lt;span&gt;# 计算前1000000个数，通过for循环逐一打印生成数&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; fibon&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1000000&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;生成器表达式与列表生成式极其形似，只是把[]改成了()，但背后的原理大不相同。&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;l &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;x&lt;span&gt;*&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;  &lt;span&gt;# 列表生成式，4以内整数的2倍数&lt;/span&gt;
g &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;x&lt;span&gt;*&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 生成器表达式&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;l&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# 结果：&amp;lt;type &apos;list&apos;&amp;gt;&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;g&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# 结果：&amp;lt;type &apos;generator&apos;&amp;gt;&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;l&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 结果：[0,2,4,6,8]&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;g&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 结果：&amp;lt;generator object at 0x000002173F0EBC50&amp;gt;&lt;/span&gt;
&lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;g&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# 0&lt;/span&gt;
&lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;g&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# 2&lt;/span&gt;
&lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;g&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# 4&lt;/span&gt;
&lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;g&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# 6&lt;/span&gt;
&lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;g&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# 8&lt;/span&gt;
&lt;span&gt;next&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;g&lt;span&gt;)&lt;/span&gt;   &lt;span&gt;# Traceback (most recent call last): ....StopIteration&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; g&lt;span&gt;:&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt; end&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&apos; &apos;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;  &lt;span&gt;# 结果：0 2 4 6 8 &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>有了 Python，我能叫出所有猫的名字</title>
            <link>https://pythoncat.top/posts/2018-09-30-cat1/</link>
            <guid>https://pythoncat.top/posts/2018-09-30-cat1/</guid>
            <description>这是一只喵星人的故事</description>
            <pubDate>Sun, 30 Sep 2018 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;话说，当年我刚来地球的时候，小心翼翼地伪装了自己的身份。我在暗处偷偷观察人类，学习你们的语言。&lt;/div&gt;
&lt;div&gt;直到一天，一只凭空出现的机器猫识破了我的真身，她叫阿尔法猫。她不仅对我的过往了如指掌，甚至对几百亿光年外的喵星的一切都如数家珍。我瞬间被折服。&lt;/div&gt;
&lt;div&gt;我问她怎么会知道我的名字，她说，因为有Python，她能叫出所有猫的名字。&lt;/div&gt;
&lt;div&gt;我又缠着她追问了99999个问题，她毫不费力一一解答！只恨当年，我人智初开啊，似懂非懂，过后就将全部智慧遗忘了，如今想起来，真如做了一场梦梦。&lt;/div&gt;
&lt;div&gt;我不知道她是什么时候离开的。不过我相信，总有一天，我会找到她哒。&lt;/div&gt;
&lt;div&gt;在她有意或无意留下来的小肚兜里，有一张图片一直吸引着我。呐，就是这张啰：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;我仿佛站在阿尔法猫的角度，看见了她看着我的时候的样子。这张图片里肯定有阿尔法猫留给我的讯息。这个讯息到底是什么呢？&lt;/div&gt;
&lt;div&gt;苦思了6666.66小时，我仍不得其解噫，直到翻开她留下的一本书《Python：人成为猫及猫成为人的唯一宝典》。&lt;/div&gt;
&lt;div&gt;学习了Python之后，我终于自豪地成为了会写代码的程序猫咪。呐，请看下面的代码：&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; cv2

faceCascade &lt;span&gt;=&lt;/span&gt; cv2&lt;span&gt;.&lt;/span&gt;CascadeClassifier&lt;span&gt;(&lt;/span&gt;&lt;span&gt;r&quot;C:\data\haarcascade_frontalcatface_extended.xml&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
img &lt;span&gt;=&lt;/span&gt; cv2&lt;span&gt;.&lt;/span&gt;imread&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;cat.jpg&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
gray &lt;span&gt;=&lt;/span&gt; cv2&lt;span&gt;.&lt;/span&gt;cvtColor&lt;span&gt;(&lt;/span&gt;img&lt;span&gt;,&lt;/span&gt; cv2&lt;span&gt;.&lt;/span&gt;COLOR_BGR2GRAY&lt;span&gt;)&lt;/span&gt;
faces &lt;span&gt;=&lt;/span&gt; faceCascade&lt;span&gt;.&lt;/span&gt;detectMultiScale&lt;span&gt;(&lt;/span&gt;
    gray&lt;span&gt;,&lt;/span&gt;
    scaleFactor&lt;span&gt;=&lt;/span&gt; &lt;span&gt;1.02&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    minNeighbors&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    minSize&lt;span&gt;=&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;50&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
    flags&lt;span&gt;=&lt;/span&gt;cv2&lt;span&gt;.&lt;/span&gt;CASCADE_SCALE_IMAGE
&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt; y&lt;span&gt;,&lt;/span&gt; w&lt;span&gt;,&lt;/span&gt; h&lt;span&gt;)&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; faces&lt;span&gt;:&lt;/span&gt;
    cv2&lt;span&gt;.&lt;/span&gt;rectangle&lt;span&gt;(&lt;/span&gt;img&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt; y&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;x&lt;span&gt;+&lt;/span&gt;w&lt;span&gt;,&lt;/span&gt; y&lt;span&gt;+&lt;/span&gt;h&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;255&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    cv2&lt;span&gt;.&lt;/span&gt;putText&lt;span&gt;(&lt;/span&gt;img&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&apos;You get ME&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;,&lt;/span&gt;y&lt;span&gt;-&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;255&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; cv2&lt;span&gt;.&lt;/span&gt;LINE_AA&lt;span&gt;)&lt;/span&gt;
cv2&lt;span&gt;.&lt;/span&gt;imshow&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&apos;beautiful_cat&apos;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; img&lt;span&gt;)&lt;/span&gt;
cv2&lt;span&gt;.&lt;/span&gt;imwrite&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;beautiful_cat.jpg&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;img&lt;span&gt;)&lt;/span&gt;
cv2&lt;span&gt;.&lt;/span&gt;waitKey&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
cv2&lt;span&gt;.&lt;/span&gt;destroyAllWindows&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;我把一张美美的自拍照喂给程序，喵喵喵，它竟然不会吃进肚子不吐出来耶。照片里的我显得无比从容优雅，每根毛发都蕴藏着睿智而温柔的光芒。走过路过的人们，请慢慢欣赏我喔：&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;我大概知道了阿尔法猫留下的讯息：猫脸识别！&lt;/div&gt;
&lt;div&gt;她一定是学会了Python的宝典，可以从猫变为人，也可以从人变为猫，在人海中自由变换，处处不留痕迹，却时时洞悉着大千芸芸。她在观察着我，希望我有一天也能变成她那般，那时，她会再出现，来见我。&lt;/div&gt;
&lt;div&gt;一定是这样滴！我这么确定地想着。从今往后，我决定隐藏自己的真名，化名Python猫，开启学习、求知、探索、利用Python的旅程。&lt;/div&gt;
&lt;div&gt;喵喵喵，阿尔法猫，我来找你啦~~~&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>我的 2017 年读书杂记</title>
            <link>https://pythoncat.top/posts/2017-12-26-books/</link>
            <guid>https://pythoncat.top/posts/2017-12-26-books/</guid>
            <description>2017年要走了，这碎片化的一年，有必要收拢一下。遂理一下今年读过的书吧。</description>
            <pubDate>Tue, 26 Dec 2017 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;2017年要走了，这碎片化的一年，有必要收拢一下。遂理一下今年读过的书吧。&lt;/div&gt;
&lt;div&gt;1、《莫言文集》&lt;/div&gt;
&lt;div&gt;这本文集收了从《透明的红萝卜》（1985）到《蛙》（2009）的长篇，还包括30多篇短篇。此前不曾读过莫言的小说，故找来读。读了却不喜欢他讲故事的方式、不喜欢那些人物和语言。完整看完的只有《蛙》，其它像《檀香刑》《丰乳肥臀》《红高粱家族》，只是跳翻，没有好印象。几年前，读过他的《我的高密》，读他成长的故乡往事，似乎更可读些。&lt;/div&gt;
&lt;div&gt;2、瓦尔·赫拉利 《人类简史》《未来简史》&lt;/div&gt;
&lt;div&gt;前一本出版后已风靡两年多，今年姊妹篇再领风骚，自然不能不读。第一本开篇即带读者走进一个多人种并存的历史，我们是Homo sapiens（人属智人种），类比狮子是Panthera leo（豹属狮种）。几十万年前，智人只是人类的一支，而现在，其他人种都被智人种直接或间接地灭绝（或同化）了！智人胜在想象的能力，历经认知革命、农业革命、科学革命，终于成为神一般的存在，而未来的关于存亡的议题也日渐浮现。读的过程，每每感到自身的渺小，找到一种维度反观自己生存的意义。&lt;/div&gt;
&lt;div&gt;3、 贾雷德·戴蒙德 《枪炮钢铁与细菌 ：人类社会的命运》&lt;/div&gt;
&lt;div&gt;承《人类简史》，读了另一本奇书。人类史的种种隐秘与巧合，读时每每脑洞大开，有大呼过瘾之感。&lt;/div&gt;
&lt;div&gt;4、 李中莹《爱上双人舞：如何拥有和谐的恋爱、婚姻生活》、 约翰·戈特曼 / 娜恩·西尔弗 《爱的博弈》&lt;/div&gt;
&lt;div&gt;有个作家说：“婚姻不能真正消灭孤独，但它并非没有用处——它可以用烦恼来代替孤独。”第一本书的作者说：“成功的婚姻，就像是配合默契的双人舞。” 书中提到了婚姻的五个致命伤、提出了夫妻相处的几种机制，也强调了自我价值、平等权利等等。婚姻，不是一件无师自通的事情。第二本书的作者是心理治疗师，讲的内容具有实践价值，全书核心两字是——信任，其它关键词还有：欺骗出轨、爱情修复、滑动门时刻、消极诠释、情绪协调、零和婚姻…作者对爱情的定义是：双方都有意培养和鼓励珍惜彼此，认为对方独一无二、不可替代的思想和行为的状态。&lt;/div&gt;
&lt;div&gt;5、大前研一《专业主义》&lt;/div&gt;
&lt;div&gt;在得到上听到某期节目推荐此书，提到“U盘化生存”，故找来看（最后似乎没看到相关论述）。书中讲专家需具备的几种能力： 先见能力、构思能力、讨论的能力 。有趣的是专家的词源“profess”指的是“向上帝发誓，以此为职业”，听起来指的是“不忘初心”的匠人。但作者明显讲的只是“企业家”。&lt;/div&gt;
&lt;div&gt;6、 马尔科姆·格拉德威尔 《异类：不一样的成功启示录》&lt;/div&gt;
&lt;div&gt;“异类”是一个区分烂俗成功学的概念，作者取的是这层含义：一个在价值上能与其他样本显著区别开的统计观察值。这意味着作者站在统计学、群体性上去研究成功人士。作者证明的是：“异类”的决定因素并不是个人奋斗，反而是某些隐蔽的先天优势、文化背景、历史机遇。对我等普通人来说，这结论太现实、太伤人了，我也想成为一个 Outlier 啊！&lt;/div&gt;
&lt;div&gt;7、 菲利普·津巴多/约翰·博伊德 《津巴多时间心理学》&lt;/div&gt;
&lt;div&gt;我们常挂在嘴上的三观是“世界观、人生观、价值观”，而作者想引起我们思考的是他认为更重要的“时间观”。此“时间观”不是说一个人守时或珍惜时间，而是说一个人对于时间的整体态度。对待过去、现在和未来的积极或消极态度，形成了人类的六种时间人格。认清时间的悖论、认清自己所属的“时区”，是我们生活得以有秩序、有意义的关键。其中一章讲时间观之于爱情，男人更倾向于享乐主义的现在时间观念，而女人更倾向于未来时间观念。一个结论：很多人离婚时不该写性格不合，而应该写时间观不合。&lt;/div&gt;
&lt;div&gt;8、吕世浩《大秦三部曲》&lt;/div&gt;
&lt;div&gt;因看电视剧《大秦帝国之崛起》而对先秦史感兴趣。电视剧是根据《大秦帝国》拍摄的，只因有六部，怕读来耗时，最后找来这本做替代。三部曲包含： 《秦始皇: 诈与力的极致》、《帝国崛起 : 王道、霸道与强道的取舍》、《敌我之间 : 成在对手,败在队友》 。“越艰困越奋斗，越顺利越荒唐。这样的规律几乎贯穿于整个秦人历史的始终，就像是对他们的诅咒。”“多难兴邦，骄奢失国，正是秦国历史最好的写照。”&lt;/div&gt;
&lt;div&gt;9、《优质学习套装》、采铜《 深度学习的艺术: 知乎采铜自选集 》、布朗《学会提问》&lt;/div&gt;
&lt;div&gt;套装含《学习之道》、《刻意学习》、《练习的心态》、《如何高效学习》、《行动学习的本质》、《行动学习催化秘籍》。这些都是很经典（常见推荐）的书目，但怀着若即若离的心态看读，我很快就像到景点上留下“到此一游”的游客，最后两手空空而回…&lt;/div&gt;
&lt;div&gt;10、 莫提默·J. 艾德勒 / 查尔斯·范多伦《如何阅读一本书》&lt;/div&gt;
&lt;div&gt;一本经典的畅销书，书中提出阅读的四种层次：基础阅读、检视阅读、分析阅读、主题阅读。我现在读书基本出于兴趣或便利，而不是问题导向，所以浅层次的阅读方式倒是用的多，包括读这本…&lt;/div&gt;
&lt;div&gt;11、 钟云霄 《混沌与分形浅谈》&lt;/div&gt;
&lt;div&gt;书中提到混沌的重要性：混沌被认为是20世纪物理学的第三次革命，另外两次是相对论与量子力学。“混沌就是系统的无规行为中的规律性。”这很费解。书中出现的数学分析一点都不友好。这个理论其实是推翻了确定性的物理观：即使给足了初始条件，你也无法确定长时间运转后的结果。&lt;/div&gt;
&lt;div&gt;12、 张鸣《无所畏与无所谓》&lt;/div&gt;
&lt;div&gt;历史随笔、清末民国的故事、国民性话题、杂感。闲暇读读就好。作者随口说孔融仗着圣人之后，说了不忠不孝的话而被曹操诛杀。但查阅《后汉书》《三国志》，都明明白白写着这是曹操命人栽赃的，可见此书太过于“无所畏”了…&lt;/div&gt;
&lt;div&gt;13、 丹尼尔·卡尼曼《思考，快与慢》&lt;/div&gt;
&lt;div&gt;曾想仔细精读，中途发觉章节内容太多，几度欲弃。不过此书值得重读。人每时每刻接受信息并做出应对，然而对于自己做出判断与决策的基础原理恐怕知之不多。作者提出双系统来解释人类大脑的运转，系统1 主要指无意识的运作，系统2主要指受理性控制的运作。第一部分的每章都很精彩，从不同面向来说明这两个系统。得到的启示是：审慎地对待自己的“不假思索”、第一反应、思维惯性，并将优秀的系统2思维固化进系统1快速使用…&lt;/div&gt;
&lt;div&gt;14、黄荣华《人本教练模式》&lt;/div&gt;
&lt;div&gt;第一章关于“人”字的起源与演进特别有趣，由“人”到“比”、“从”、“北”、“化”，妙趣良多。&lt;/div&gt;
&lt;div&gt;15、唐翼明《中华的另一种可能：魏晋风流》、吴松弟《中国古代都城》、赵荣《中国古代地理学》&lt;/div&gt;
&lt;div&gt;魏晋时代是继春秋百家争鸣之后的学术、思想高峰期，第一本书讲了这段时期的名士故事、思想潮流、士族阶级等等。后面两本都来自商务印书馆二十年前出的一套文化史丛书，两书的作者都是高校教授，内容都言之有物，而且并不高深，可一读。&lt;/div&gt;
&lt;div&gt;16、 埃雷兹·艾登 / 让-巴蒂斯特·米歇尔 《可视化未来：数据透视下的人文大趋势》&lt;/div&gt;
&lt;div&gt;早前在诚品书店看到这本书，当时被吸引就看了四分之一，后来偶然在论坛淘到电子书，大呼有缘！此书将谷歌图书500多万本电子书作为大数据，用“ n元词组词频查看器 ”做词频分析，发现了很多有趣现象和结论。强烈推荐。&lt;/div&gt;
&lt;div&gt;17、 查尔斯·韦兰 《赤裸裸的统计学》 、 乔丹•艾伦伯格《魔鬼数学：大数据时代，数学思维的力量》&lt;/div&gt;
&lt;div&gt;“ 统计学就像是一种高智商武器：正确地使用它能够帮助我们，但错误地使用它也会产生灾难性的后果。本书不会将你变成一个统计学专家，但会让你对这个领域保持谨慎和尊重，不至于酿成大祸。 ”第二本除了统计学，还有几种重要的数学思维，启发很大。&lt;/div&gt;
&lt;div&gt;18、王健《还原真实的美联储》&lt;/div&gt;
&lt;div&gt;“ 本书不仅对美联储的历史背景、政策目标、组织架构和运行机制作了客观明确的描述，而且对国内读者特别关心的有关美联储的各个问题进行剖析，提出了独到的见解；在澄清若干对美联储的常见误解之后，我们可以进一步了解美联储在全球经济和金融市场上的作用及其行事逻辑，从而进一步增强对全球市场的预见能力！ ”&lt;/div&gt;
&lt;div&gt;19、《在火星上退休： 伊隆•马斯克传》&lt;/div&gt;
&lt;div&gt;阅读过程挺激动人心，但内容有几次反复、前后不一致。开始以为是电子书制作问题，后来看书评，得知这竟然是一本拼凑的伪作？！&lt;/div&gt;
&lt;div&gt;20、中国国家博物馆《微博物》系列刊物&lt;/div&gt;
&lt;div&gt;这是国博在2014年出的电子刊物，多看阅读上有六期。本想看看文物知识，附庸风雅，却有意外之喜：这刊物有更高追求，每期都有特定主题，制作精美，涉猎广博，仔细还能读到提及李银河“甲女丁男”的论述、马鞍的发明与战争的进阶…&lt;/div&gt;
&lt;div&gt;21、 《魔力四射：如何打动、亲近和影响他人》《绝望成就了我：史玉柱给年轻人的14堂创业课》《餐桌上的进化史》 《冥想：唤醒内心强大的力量》《股票大作手回忆录》&lt;/div&gt;
&lt;div&gt;本着练习速读以及相信“任何书籍都有几处闪光点”的念头，读了这些书，一目十行。&lt;/div&gt;
&lt;div&gt;22、《Python之旅》《Python进阶》《流畅的Python》《Python cookbook》&lt;/div&gt;
&lt;div&gt;由于工作缘故，又翻了一些Python教程和书籍，都是跳着看了部分章节，没有完整读完的。&lt;/div&gt;
&lt;div&gt;23、 维克多·弗兰克尔 《弗兰克尔自传：活出生命的意义》&lt;/div&gt;
&lt;div&gt;想看作者那本“著名”的《活出生命的意义》，没想到看的只是他的自传…作者是个犹太心理学家，是奥斯维辛集中营的幸存者， 其父母、妻子、哥哥相继死于毒气室中，只有他和妹妹幸存下来 。化痛苦为力量，他最后开创了维也纳第三心理治疗学派。“ 如果有人问我成功的秘诀，我通常会这么回答：我坚持一个原则：即使做很小的事，也要像处理大事一样用心；即使做很大的事，也要像对待小事一样冷静。”&lt;/div&gt;
&lt;div&gt;24、邓安庆《山中的糖果》、《我认识了一个索马里海盗》&lt;/div&gt;
&lt;div&gt;与我同姓的青年作家，天然感觉亲近。我关注其公众号和豆瓣有段时间了，看过平时文章和动态，这是第一次读出版物。相对喜欢第一本情真意切的有共鸣的随笔，最喜欢《快餐店的日与夜》、《回乡十记》，而第二本短篇小说集未能代入。&lt;/div&gt;
&lt;div&gt;25、 奥尔罕·帕慕克 《我脑袋里的怪东西》&lt;/div&gt;
&lt;div&gt;豌豆最爱读帕慕克，而我爱屋及乌。这本小说写了一个平凡的小贩，对他，我不喜欢，也难以厌恶，因为他既善良又软弱，既无能又真诚，连帕慕克似乎都不知道要如何安置他最终的命运——他造了一座城和两段婚姻困住了他。&lt;/div&gt;
&lt;div&gt;26、石黑一雄《被掩埋的巨人》&lt;/div&gt;
&lt;div&gt;迷雾使人丢失记忆，那么，要不要去找回记忆呢？为什么会有迷雾来蒙蔽记忆呢？万一找回的只是仇恨、痛苦的记忆，又该如何面对呢？&lt;/div&gt;
&lt;div&gt;27、郝景芳《北京折叠》《生于一九八四》、特德·姜《降临》&lt;/div&gt;
&lt;div&gt;《北京折叠》获得雨果奖最佳中短篇小说奖，年初拜读。年末看到“ 郝景芳说，故事之所以重要，是因为如果没有故事，如果没有我们对于生活的讲述，那么任何人的生活都是碎片化的，是一盘散沙。你回顾自己的一生、给自己讲述人生故事，才能把自己整合成一个完整的人。而小说家通过讲述万千碎片的故事，把这个世界组成了一个圆融的整体。 ”遂又读了一本《生于一九八四》。而《降临》是看了电影后，买来读的。都是有名气的科幻作家，故列一起罢。&lt;/div&gt;
&lt;div&gt;照此一理，读过的书还真不少了（已剔除部分中途弃的）。我平时读书时间主要有三块：上下班在公交及地铁时、上班午休时、外出火车或长途车时。有个共性就是：不在家。手机电子书提供了极大的便利，而由此带来的缺陷也很多：容易走神、陷于局部章节而失去纲领…&lt;/div&gt;
&lt;div&gt;新到的一年，计划：多做些分析阅读和主题阅读，写至少五篇精读后的书评。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>奇葩说没有上进心我错了吗？</title>
            <link>https://pythoncat.top/posts/2017-05-30-qipa/</link>
            <guid>https://pythoncat.top/posts/2017-05-30-qipa/</guid>
            <description>我有上进心么？</description>
            <pubDate>Tue, 30 May 2017 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;许久不运动，昨天跑步前，打开运动APP，发现上一次的运动记录是26天前。回来打开豌豆花，发现上一篇我发的文章是27天前。这一个月的时间过得真快啊，而小目标还没达成。。。&lt;/div&gt;
&lt;div&gt;今天的题目来自我和豌豆最爱看的综艺节目《奇葩说》。若作为观众要投票，我投给反方。颜如晶发言的时候，我就哭了。不过最触动我的是正方蔡康永的话。“你把你的上进心停掉是换不到开心的，换到的是灰心”。之前刘楠还讲到，你以为把上进心停了还能维持现状，但维持现状也是需要上进心才能做到的，这时候跳出画外音“逆水行舟，不进则退”。虽然马薇薇说的也有道理，说做事不一定出于上进心，可能是好奇心、同情心、平常心，但在我看来，最后归结一起，这些都是上进心。再者，像马薇薇、颜如晶和臧鸿飞这些人，都是经历过风雨后才举重若轻，他们一路上进，才站在了现在成型的势能层上。对于没有看到自己上限的人、还满怀世俗欲望地想过更好的生活的人来说，不能只想着“活在当下”，那样的自由很虚幻。&lt;/div&gt;
&lt;div&gt;近几期节目在宣传蔡康永导了一部电影，看来除了电视节目，他一直没闲着。其实奇葩说里的几个导师都挺上进，从电视台出走后，他们都开创了自己的新事业：马东除了奇葩说，还推出好好说话、小学问，甚至亲自上阵玩一个狼人杀的节目；罗振宇的罗辑思维、得到APP和跨年演讲不消说，前不久他还独创性地举办了一场野心勃勃的知识发布会；张泉灵在节目里提到了参与一些慈善公益项目，其实她还入股了傅盛的猎豹，而猎豹除了海外视频直播APP获得巨大成功，还在潜心进军人工智能领域。不得不说，这几个前著名电视主持人都挺强的。也许促使他们变成这样，是因为事业心或者别的什么心，但我需要一些上进心，去汲取他们的行动精神，才好推动自己也去做成一些事。&lt;/div&gt;
&lt;div&gt;罗胖讲的关于反义词的小感慨很有意思。他说到上进心的反义词是抵抗诱惑。我承认某些时候是这样，但对现今的我而言，上进心的反义词是满足现状。我所不满的现状是，快到了“三十而立”，却未能真正立起来。这很可怕。满足现状的心态也是一种诱惑，就像躺在温水里的青蛙，现状当然舒服，可是生存的危机也在酝酿中。&lt;/div&gt;
&lt;div&gt;最近，我无意中观察到，国产动漫正在崛起！像什么《全职高手》、《镇魂街》，还有3D作品《少年锦衣卫》、《幻境诺德琳》，十足良心制作，特别是这后两部，那画风画面，简直不要太赞！电视剧也在看，除了《越狱》、《欢乐颂》烂尾不足续，只有小清新《花间提壶方大厨》越来越耐看。电影不怎么看了，因为没有任何期待。所以总体而言，动漫一枝独秀，带来了惊喜。在默默之中，它们在情节、人物、美工、特效、渲染方方面面都交出了可喜成绩。&lt;/div&gt;
&lt;div&gt;近日还有一件必将载入史册的大事件，那就是柯洁与阿尔法狗的人机大战。一年前李世石之战，我们觉得并不服气，觉得人类选手还能一战，但现今再战，却抹去了胜利的可能。在围棋上战胜人类顶级选手，而且据说只用了单机版的算力，人工智能已经走到了质变的前夕，毫不夸张地说，它就像武侠小说里一个人打通了任督二脉，就像一百年前第一封跨海发送成功的电报，前途无量。&lt;/div&gt;
&lt;div&gt;之所以提到动漫和阿尔法狗，因为它们是离我最近的却足够预示时代巨变的事物，还有很多进步的美好事物在产生，意味着危机和机遇。有不少媒体发布预测，说哪些哪些岗位工种很快要被人工智能取代，还有直接报道人工智能协助法院判案、人工智能进医院诊断病症、人工智能找回拐卖儿童等等。我突然意识到，并不是人工智能未成熟，而是它应用的场景太多了，暂时没来得及全部覆盖罢了。而这一天总是不远的。我想起了小时候，大人们还标配着BB机，但科技革命来得很快，功能机、智能手机、移动互联网一次次打破现状，越走越快。它制造古董的水平是一流的。&lt;/div&gt;
&lt;div&gt;上周，我没写一行代码，就把豌豆花公众号托管到了图灵机器人上，轻松就能调戏它，进行似是而非的对话，甚至能够跟它玩斗图，最后被它表情包甩得猝不及防。我看到有人还写了详尽的教程，利用图灵机器人打造个人微信的“私人秘书”。去年，扎克伯格也晒了他组建的机器人秘书。这说明，门槛并不高。因此我相信，我们每个人很快都能几乎不费成本地定制自己的私人机器人助理了！&lt;/div&gt;
&lt;div&gt;回到今天的话题。作为辩题，它可以从不同角度辩论，就像颜如晶，可以精心准备出5篇稿子。但就个人而言，我只关心“上进心”三个字。它正是我所缺少的。对现状的不满、对未来的不安、对机遇的可能把握，没有上进心可不行。时间宝贵，空说无益，先行打住。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>两个老头</title>
            <link>https://pythoncat.top/posts/2016-11-12-oldman/</link>
            <guid>https://pythoncat.top/posts/2016-11-12-oldman/</guid>
            <description>睡前突然不想做自己了，就想起白天见过的形形色色的奇怪的人</description>
            <pubDate>Sat, 12 Nov 2016 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;（一）&lt;/div&gt;
&lt;div&gt;睡前突然不想做自己了，就想起白天见过的形形色色的奇怪的人。有一个老头，我想在今晚的梦里成为他。&lt;/div&gt;
&lt;div&gt;成为他，不是要嫁接他过往的人生历程，也不是要接力他明显已然不多的余生，我仅仅只是想成为这样一种角色：我见到他时的、一个旁观者偏狭的视角所能解读的角色。&lt;/div&gt;
&lt;div&gt;他几乎每天早晨都守在地铁B站的3号出口的刷卡通道外，两手捧着当天的早报，像乞丐端着求生的碗，等待着那些上班的人们的不要了的报纸。他站在中间的通道外，两腿挺直，从不倚靠墙壁或柱子，从不蹲着或坐着，兼顾着两侧，眼光几乎不漏过任何一份离开地铁站的报纸。&lt;/div&gt;
&lt;div&gt;他从不说过一句话，不主动询问，也不拦截骚扰，伸手接过有意愿的施舍，不可惜任何一个拒绝。他穿着随性不讲究，混搭而不单调，有时候穿运动鞋配西服，有时候穿皮鞋配休闲服，常年戴顶猎豹纹品牌的帽子，遮住凭常识会认为是灰白的头发。&lt;/div&gt;
&lt;div&gt;他从不显得穷困潦倒，并不是我们平常所见的拾荒者或者乞讨者，然而你也没有确切的线索推断出他的工作身份，或者赖以谋生的事。&lt;/div&gt;
&lt;div&gt;也许他对别人丢弃的报纸有经济利益的诉求，他在附近经营了一家报刊亭，可以将报纸转手卖给别人；也许他用报纸来满足个人消遣的乐趣，例如剪切新闻并分门别类地贴在档案册里、练习毛笔书法、折叠出惟妙惟肖的花鸟工艺品。他不是一个精神异常的人，一定是有一个持久性的动机——就像有的老人为了延年益寿的目的而天天出门做晨练——驱使他日复一日地守在那里收集报纸。&lt;/div&gt;
&lt;div&gt;但是，这个目的肯定不是为了身体健康，因为相比于人来人往的拥挤的嘈杂的地铁站，别处的空气和环境会更合适；这个目的也不像是为了挣钱，因为报纸本身很廉价，即使是再加工利用也不会带来多少收益，再说，他每天的收成都不好，目测一天只有十几份。&lt;/div&gt;
&lt;div&gt;我曾下结论认为他是为了个人的乐趣这类相对纯粹的目的在做这件事。然而很快我就动摇了，因为我发现自己对别人——或者说是对“人”——的了解太少了，我认为别人不会去做的事情恰恰就发生在眼前。&lt;/div&gt;
&lt;div&gt;有一天，又是上班高峰期，地铁里拥挤的乘客比往常更多一些，我侥幸得到一个座位可以短暂沉浸在手机里。这时，一个四五十岁的大胖子——胡渣潦草、汗侵T恤、略带凶相——推开人群出现，半征求半强制地收走别人没在阅读的报纸。在那个狭小的行走困难的挤满上班族或学生族的空间里，他的体型显现出侵略性的优势，出现得那么突然，所做的事那么奇怪，简直不可理解。我认为他回收报纸只是为了一个简单的目的——卖钱。&lt;/div&gt;
&lt;div&gt;然而，我的疑惑是：挣钱难道没有别的更有效的方式了么，为什么要在上班高峰时的地铁车厢这样不合时宜的空间（更别说他的身型了），为什么要不礼貌地推挤别人或直接伸手取走别人放在腿上的报纸？&lt;/div&gt;
&lt;div&gt;现今是纸媒没落的时代，年轻人几乎已没有阅读报纸的习惯，报纸的销量每况日下。我记得三年前还在武汉时，有一次为了找零钱而去买报纸，那时只需一块钱就买到了当地颇有名气的都市报，现在的行情肯定不会比那时候好。&lt;/div&gt;
&lt;div&gt;苏州地铁上的报纸是免费的。我每天在地铁Y站进站后都会看到两个阿姨在楼梯口发报纸，她们套着一样的制服样的马褂，对立站成一个下楼必经的通道，伸长手把报纸晃来晃去，生怕别人不知道一样地说着“免费的地铁报”！当一份报纸送出去之后，她们会熟练地快速地抽出另一份举在眼前，让每一个经过的人都不能对此视而不见。&lt;/div&gt;
&lt;div&gt;她们应该是报社请的临时工或者哪个公益组织的志愿者，打着“免费”的旗帜做着很费人力的低效的事，不止于此的是，当我在B站出站的时候，通常会经过一个报纸回收箱，有个守在旁边的阿姨会反复地说着“不要的报纸不要带出地铁站”！苏州目前开通了两条地铁线，每条线路超过二十个站，每个地铁站有两个进站口和两个出站口，保守估计的话，每天差不多有两百人在地铁站因为报纸而做着同一件事。我每天只能见到两百人里区区的几个，从未曾留意过今天见到的是否是昨天见到的人。最初的时候，我不关心她们所做的事，甚至出于习惯地有所排斥。&lt;/div&gt;
&lt;div&gt;每天走在路上，特别是在来往人多的路上，我们无法避免与别人产生交集，然而大部分时候让人唯恐躲之不及：有时候是一份促销的宣传单、有时候是一家新店开业的喜讯、有时候是一家英语培训机构的介绍、有时候是一张手写的聋哑人证明、有时候是一句“上帝保佑你”或者“你相信上帝吗”…&lt;/div&gt;
&lt;div&gt;这种事情简直太常见了，以至于，每当有陌生人试图靠近或突然递给我东西的时候，我的戒备心就就快速地做好了要拒绝的准备。&lt;/div&gt;
&lt;div&gt;最近，当我加班到特定的某个时间，下班走到B站地铁口时，就会见到一个很特别的大叔。他穿着交警的衣服，别着交警的装备，旁边停着交警的执勤摩托车，然而手里拿着一张A5大小的印刷纸，会招手拦下经过的人，说“你有空吗？帮我扫一下二维码吧！”我想他无非是让人扫码关注什么公众号或者给什么人投票，就快步的走开了。他也许是为了完成上司交代的任务，也许是做着兼职想挣点小钱，不管是哪种，我同样理解他和他做的事，但仅此而已。&lt;/div&gt;
&lt;div&gt;我又想起了那个老头，相比于其他人，我对他更为留意。我想他大概不到七十岁，身体衰老的作用使他行动变得迟缓，夜里会被疏松的骨头报警的声音吓得失眠，于是又早早地来到忙碌的地铁站。&lt;/div&gt;
&lt;div&gt;他的脸由于嘴巴苦闭而显得有些紧绷，或许由于能催生快乐的事情不多，而近年来伴侣的无情的指责让他变得难受，总之他的脸像是忘记了怎么发出笑容。他的眼睛曾经很明亮，很迷人，到如今成长的有些涣散迷离，越来越难以说出有意义的话，就像他的舌头一样。他年轻的时候心性不定，总是不能长久地做一件在现在看来仍是有益的事，而变老的好处之一就是他克服了这个缺点，然而，以前未完成的愿望大部分也变得更为不可企及。&lt;/div&gt;
&lt;div&gt;以上的描述，毫无疑问，纯属凭空想象。&lt;/div&gt;
&lt;div&gt;他实实在在的形象不会因为我的假想而变样，他的行为也不会因为我过度的解读而更有意义。他只是一个每天在地铁B站收集别人不要的报纸的老头，仅此而已。&lt;/div&gt;
&lt;div&gt;夜更深了，我仔细地想了想，又再想起白天见过的形形色色的奇怪的人，想到冬天来了，夜晚的时间用来造长长的梦很合适。我已经不想在梦里成为他了，我突然有种奇怪的感觉——我曾经就是他，或者在未来会变成他。&lt;/div&gt;
&lt;div&gt;（二）&lt;/div&gt;
&lt;div&gt;窗外是干净的天，纯净的灰色，偏于暗淡，被对面的楼层拦挡了一片。说实话，我往外看的时候并无什么特别的期待，抬头先看天空，是出于一种矫情的习惯。&lt;/div&gt;
&lt;div&gt;假如条件允许，视野可以开阔到远方的话，我倒是会有所期待：最好是有几座层层叠叠的山，线条起伏，包纳树木郁郁葱葱，不单调，也不需要太多秘密；当夜晚来临时，就抛出一个光亮光亮的月球，照出寂寞的冷色。&lt;/div&gt;
&lt;div&gt;然而条件并不允许，视野被遮挡，我只能对视一个普通的住宅小区里毫无特色的绿化装饰区——唯一值得观察的只有区区两三株樟树，花期早过了，果期也刚过了，没有了所珍护，也没有了所得意，沉默时带着坦然，闹动时透露出自足。我想对它们说说我的心情，但它们摆起常年深绿的树叶，仿佛在说已经提前知道了，接着礼貌地分享了它们的令我羡慕的自由感。&lt;/div&gt;
&lt;div&gt;其实，在小区里还有别的绿化物，至少有杨梅树和桂花树，都曾吸引过我的注意：一个酸，一个香，一个红，一个黄，都大胆地展示自己的能力和独特的个性——只可惜都不持久；更可惜的是，它们没有生长在我的卧室的窗外，无法填补我的占有欲——我不知道它们是否是樟树那样的倾听者，信持着什么样的生活观点？&lt;/div&gt;
&lt;div&gt;近日来，我的心情有些落寞，尤其是在安静的周末的午后。远离手机游戏之后，我虽然有更多时间阅读和直面自己，但也更容易暴露在无聊中。&lt;/div&gt;
&lt;div&gt;于是，我开始做一些转移注意力的事，例如写作，例如想起一个老头，例如想起一个老头之后又想起另一个老头。&lt;/div&gt;
&lt;div&gt;苏州是座江南水乡城市，遍布着纵横交错的河流，将星罗棋布的几个湖泊贯通联结起来，极大地方便了垂钓者。有一个老头，经常在小区旁的我上下班必经的河边垂钓。&lt;/div&gt;
&lt;div&gt;这是一条安静的河，水不清澈，但也没有太多杂物，从不远处的青剑湖引出来，流的及其缓慢，像河边的垂杨柳在风中缓缓地摇。河流靠公路的一侧是密布的树丛，树丛间有一个缺口，漏出一小片空地连接着河堤，足够让他安放一个折叠椅、一个塑料桶、一个抄鱼网、一把伞、一个小支架、一个碗和一副钓竿。&lt;/div&gt;
&lt;div&gt;他就占据着那个有利的位置钓鱼，距离远得看不清容貌细节，却足以辨别出年龄段。他经常穿着黑色的皮夹克、黑色的长裤和黄棕色的鞋子，头戴一顶白色的鸭舌帽，在穿着上可以说有一种符合年龄的保守与随性，与地铁站收报纸的老头一样，只透露了些许的孤独，但更多却是说不出的神秘。&lt;/div&gt;
&lt;div&gt;他基本上是坐着，或者说缩着，一动不动，像是嵌在了树丛里。从概貌来看，他也不显得穷困潦倒，年岁的流逝使他的脊梁变得轻微佝偻，没错他是一个老头，然而并不是我们偏见里会假设的那种一无是处的老头。&lt;/div&gt;
&lt;div&gt;我搬家约半年了，最初的日子里并没见过他，然而突然开始，每天清晨7点刚过，当我经过的时候，他似乎已经准时地坐在那里很久了。于是，一种奇妙的比对关系出现了：我工作日早起去上班，他每天早起来钓鱼；我匆匆赶去挤公交和地铁，他悠闲坐在河边柳树下；我一个人，他也一个人；我上班努力工作基本上是为养家糊口，他钓鱼独对长河很可能不是为养家糊口。。。。。。&lt;/div&gt;
&lt;div&gt;我发现自己很容易对外部世界产生好奇，对他人的生活产生兴趣，因为我觉得他人的生存状态以及生活动机是个值得探究的宏大主题。&lt;/div&gt;
&lt;div&gt;于是，每天看到这个老头的时候，我都放慢脚步，以便能多观察几秒钟，就像在地铁站里一样。&lt;/div&gt;
&lt;div&gt;我觉得他懂得坚守一种无害的兴趣，有眼光选择那一处绝佳的角落，充分发挥了一个老人的长处：精神更纯粹、能够保持长久的沉默、远离社交网络和电子产品、把时间过得比年轻时更充裕。&lt;/div&gt;
&lt;div&gt;对一个老头来说，最流行的日常消遣无非是这几种：打麻将、打扑克、下棋、跳广场舞、侃大山。他选择了钓鱼，另一个老头选择了在地铁里收集报纸。&lt;/div&gt;
&lt;div&gt;如果我有幸长命活成一个老头，我大概是都不会选的。期待到了那个时刻，我是一个无人打扰的小说家：为青少年写些魔幻的故事，或者为自己写一座迷宫。&lt;/div&gt;
&lt;div&gt;我把地铁站里的老头和河边钓鱼的老头当做独特的个体来观察，然而我知道，吸引我的并不完全是他们本身，还存在着一种让我着迷的无形的象征意义，越是进入抽象的领域，它们就越清晰。&lt;/div&gt;
&lt;div&gt;那是一种安逸却消极的价值观，老头象征着一种达成态的稳定：判断力已经养成了，天之命及人之伦已经认知了，社会成果及自身价值基本已是定局，欠下的债要么已还清要么永远还不清了；珍贵的事和不珍贵的事、仍爱的人和不爱的人，对立分明，像被放在天秤的两端，彼此的分量精确而准确，童叟无欺；迫近的死亡会逼退未来的计划及理想，极端的情境会强化对当下的关注，缺席的终极意义最终引向虚无；于是就抹去了年龄，抹去了人。&lt;/div&gt;
&lt;div&gt;一种荒诞出现了。必须要第三个老头来解，必须等他来，一点耐心也少不了，必须等待这个老头，也许等待四十年，也许五十年。&lt;/div&gt;
&lt;div&gt;冬天先来了。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>第二人生之 QQ 篇</title>
            <link>https://pythoncat.top/posts/2012-04-11-QQ/</link>
            <guid>https://pythoncat.top/posts/2012-04-11-QQ/</guid>
            <description>一些情绪碎片</description>
            <pubDate>Wed, 11 Apr 2012 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;（一）&lt;/div&gt;
&lt;div&gt;犹记得有文披露过“QQ签名像墓志铭，然后被不知何物频频更改”，虽戏谑滑稽，但也深得我意。我已经发现了一种现象：很多人，可能就包括你，偶尔修改自己的QQ签名，不外乎表明彼时心情或欲想等等，但是你却不同步于QQ说说和微博，等新的灵感来了，再把它悄悄改掉，一点痕迹都不留下给好奇的侦探。&lt;/div&gt;
&lt;div&gt;每当我偶然地读到一些不知为谁而写的、却打动了我的“墓志铭”，我会根据交情深浅去猜测：我是不是它们的期望读者？很可能不是，虽然说不准，但是应该就不是——谁都有一个自己的小宇宙不是么，只是你不能同时在所有的宇宙而已，这不是真理么？&lt;/div&gt;
&lt;div&gt;我的第一条QQ签名，也就是我在第二人生的第一个算属标签的东西，延续了好长的时间，后来因为有感，还特意重新挂出来，特别像困闭棺材的死尸伸出来的腐烂了的手。&lt;/div&gt;
&lt;div&gt;尽管是真的腐烂，我已经把它好好掩埋，可能以后我想不起来了，它就变成我感觉是陌生的秘密。&lt;/div&gt;
&lt;div&gt;守着一个名，一种身份好久没有改动，大概表明了：面具戴久了，就摘不下了。我在第二人生里散布了各色的面具，真亏得能有那么多的账号和密码，以至于能写满了一个小本子。但又是在虚虚幻幻、来来往往中，却也真的淘洗了一些比较沉的东西，和一些更沉的东西，例如踩一脚就陷困泥淖能搅浑一个湖，例如抓一把，没准能攥紧一块态仪万端的彩色石子。&lt;/div&gt;
&lt;div&gt;可是呢，就算我有幸是一个登月的航天员，我仍只是在太阳系中，仍只会是在一个被推测说有无限个存在着生命的星球的宇宙中，在一个能把所有人的宇宙包含其中的宇宙中，微渺小小，细茫一点。&lt;/div&gt;
&lt;div&gt;也就是说，有个被称为上帝的不能被证伪却又不是指“命运”的魔鬼，在掷一个不是骰子却类似的玩意，饶有趣味地看我在第一人生、第二人生和别的人生中像只陀螺，靠着惯性转入小径分岔的迷宫里的分叉的小径。&lt;/div&gt;
&lt;div&gt;——20120224&lt;/div&gt;
&lt;div&gt;（二）&lt;/div&gt;
&lt;div&gt;不期意地，对陌生人来说这词真合适，你就来了，我像是偶遇爱情的一阵风，像是钓起了一条鱼又像是变成了一条鱼被人钓起，就在我也可能是的风里欢乐跃腾，连结束一句话的余韵都不懂得留了。&lt;/div&gt;
&lt;div&gt;细密细密的点可以凭空而生，有真有幻，但是，是哪种力量都难连接它们成最初的线，直到翻天覆地的黑，才能泯灭掉所有的性别。生死轮回在此前的千百年也逃不脱的悖论，现在我们要被迫接受，现在我们要被迫分离，就像从不曾在一起。&lt;/div&gt;
&lt;div&gt;但是，从千万年沧桑里幸存的语言，又在劝说一种胜利：在那空里有你与我是真，在那化里有你与我是实，在你与我里有不会消失的过去。隐隐显显是不可问不可闻的心事，现在说出口的只会是一种杜撰，但是如果你要说，我就想听，想听的是你的告白。&lt;/div&gt;
&lt;div&gt;——20120302&lt;/div&gt;
&lt;div&gt;（三）&lt;/div&gt;
&lt;div&gt;不知道是何时起，QQ空间成为我最喜欢的地方，因为在这里：我可以放肆地自言自语，留下各种小小的谜语；因为在这里，我可以追踪朋友的动态，看那些迷离的文字，猜那些灵魂的语言。&lt;/div&gt;
&lt;div&gt;QQ日志承载了一直以来日记的风格，但是也越来越刻意雕琢了，最后不再是一块纯净的泥巴。那么，尽管涂满一个页面吧，就不求什么风格了，自由自在，最是难求的状态。&lt;/div&gt;
&lt;div&gt;有没有期待过很多的读者，很多的评论呢？说实话吧，读者和评论确实刺激了某些激素的分泌，然后一种好的心情随之产生，但是后来，我以为不必企图别人能读懂，尽管有人说懂了，TA懂的只是文字，又不是我；就像懂我的人不一定懂我的文字，仿佛这两者就毫不相关。知道文字被某些人看了，不管有没有评论，不管有没有谈起，似乎都有得意的资本了。&lt;/div&gt;
&lt;div&gt;曾经有人称喜欢我的文字，要当我的粉丝，我说不要。其实，你要当谁的粉丝，根本不要偶像的首肯啊，不是么？……后来，到如今已经半年了吧，TA没进过我空间。我猜TA是高三的，从空间一些迹象看来是的，祝她高考顺利吧！&lt;/div&gt;
&lt;div&gt;有个名字里面有“依”字的女孩，我自夸地说，她才是我的粉丝呢，因为我根本不认识她，加了QQ却一直没有说过话的，但是每篇文字，她都不漏过地，以至于新文章出来而她没看，我就觉得不大对劲。没有评论，没有留言，没有QQ对话，像是我们一直的默契。我个人觉得有一种隐隐的美好，也不想这种状态有什么改变。PS：你看到了，就会心一笑吧。&lt;/div&gt;
&lt;div&gt;有心事了，有情绪难排遣了，有些人呢喜欢写诗，有些人呢写写日记，有些人呢写一封信给别人或者给自己，有些人呢，大概是我这种的话，就会去做以前没做完的事，写一篇连载的文章，转移掉所有的注意力，在摇滚乐里摇头晃脑。&lt;/div&gt;
&lt;div&gt;正好又是夜晚，正是所有灵感奔涌的时候，顺便可以理理书单，想想接下来要看的书。&lt;/div&gt;
&lt;div&gt;——20120305&lt;/div&gt;
&lt;div&gt;（四）&lt;/div&gt;
&lt;div&gt;隐身，或者说隐形，这是我曾经一直幻想的超能力——不过这种能力常常连带着某些不道德的行为——不管现如今，即时通讯工具在多大程度上实现了这一种不大现实的想法，它在本质里面带着的那些欲望并不曾消减：在交集之外，我要我的自由，我要我的隐私，我要我的不公开的状态，我放纵地或者恰当地把自己隔离在人群之外；我想看到你在，却不想让你知道我在偷窥；我就要静静地看着你，又不必承受两眼相对的尴尬，不想成为在场的冷漠者……&lt;/div&gt;
&lt;div&gt;隐身者的隐身心理应该能成为不错的研究课题，我直觉地意识到这里大有玄机。他们都是怎么解释自己的行为的呢？也许有人说，不想被别人打扰；那么，我可以反问，为何不设置成“离开”、“忙碌”、“请勿打扰”状态呢——设计者考虑得还算周到了——抛弃这些选择的一种可能的解释是，他们不想诚实地表露自己。&lt;/div&gt;
&lt;div&gt;也许有人说，已经习惯了，或者不觉得它能说明什么；那么，我会解释道：他们的自我是封闭的、他们的内心是不敞开的、他们没有相知相亲的对象（好朋友或者感情伴侣）。&lt;/div&gt;
&lt;div&gt;如果能单从字面上说，那么，假如一个人不想处于光明的状态而想要在隐暗之中，那他要么就是不善于调和自己的处境，要么就是不善于认识自己的处境，要么就是不在乎自己的处境；而这在我看来，又要引出一个新的可能：他不曾考量过“存在”的问题，他不曾把自己的存在看成值得怀疑的事，也不曾因为对自己存在的认知而倍感要珍惜流失中的时间。&lt;/div&gt;
&lt;div&gt;“隐身对其可见”，它算是一种恩惠：因为我跟你好，因为我在乎你，因为我不想隐瞒你，所以我完全向你敞开，让你能随时进入。这一种恩惠如果不是直白地向对方表达了，如果不是差异鲜明地让对象感动了，它似乎并没有什么特殊的意义，它的“有”也跟“无”一样而已。仅表明我的态度么？——你不把我放在你心里的时候，我不在乎，我还是要把自己（把自己的心魂）摆在你的面前。&lt;/div&gt;
&lt;div&gt;而在灵魂的伴侣之间，隐身也好，是否可见都好，他们的默契不差分毫。也许就是这样的默契：你不在，但是我想你的时候，刚好你也在想我；你不在，但是我估计你到了哪里的时候，你正好是到了；你不说话，我不说话，但是呼吸的节奏是一样的，连想开口说话的时间和内容也是相近的……&lt;/div&gt;
&lt;div&gt;PS：语言丢失了。甜蜜的事让人失语？回到未完成的工程，找回创作的感觉……&lt;/div&gt;
&lt;div&gt;——20120411&lt;/div&gt;
&lt;div&gt;（五）&lt;/div&gt;
&lt;div&gt;七年前，我困在 QQ 和它的文字空间里。七年后，那个空间被封闭而疏远了，但不变的是，第二人生依然广阔。&lt;/div&gt;
&lt;div&gt;当年，我想写成一个系列：QQ篇、微博篇、人人篇、豆瓣篇，但勉强只是写成了一篇。如今，如果重新考虑，大概会加入：微信篇、公号篇、知乎篇，但写作的情绪已经完全不同了。&lt;/div&gt;
&lt;div&gt;感觉像是在翻读一篇铭文，被刻在石板上，爬满了尘土和绿苔。&lt;/div&gt;
&lt;div&gt;——20190726&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>在浓浓大雾里拍照</title>
            <link>https://pythoncat.top/posts/2012-03-18-letter/</link>
            <guid>https://pythoncat.top/posts/2012-03-18-letter/</guid>
            <description>清晨的心情</description>
            <pubDate>Sun, 18 Mar 2012 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;在浓浓大雾里拍照，我想这样的生活会让唐宋年间所有成名的诗人词客艳羡一番：他们的诗章词篇能空灵化了高山长河，他们的水墨长卷能容揽千古不变的神韵；但是，只有在现代科技产品的助益下，某天的真实本质的清晨和晨光里的景致才更真切地被留住，不需要抽象就完完整整地展露的朦朦胧胧凝在方寸之间；相片中奔跑的小男孩、追着滚动的花足球，跃跃然，似就要转头对你喊：“快来追我啊…我们一起玩……”&lt;/div&gt;
&lt;div&gt;在长椅一侧的草地上，小女孩穿着天蓝天蓝的衣服，喊着：“爸爸，爸爸，看这里！”爸爸不回答，他在跑，在他后面，一只大大的风筝也跟着跑，他们跑在青青的草坪上，泡在清清的白雾里。小女孩也很快地走着，但是她的风筝只飞了她身高那么高；捡起它来，她埋头了像是在研究风筝的线，像是在怜惜它擦破了的一角……&lt;/div&gt;
&lt;div&gt;小男孩是更喜欢足球的，咯咯地去把跑歪了的球儿抓回来，他妈妈对他说：“用脚踢。用脚踢。”于是，他把抱在胸前的球儿泼出去，像是放飞一只鸟儿——那足球上缀满了扭8字的服饰，黑白相调，旋转出美丽的花色，落在男孩脚边——他就，有时候做一个酷酷的姿势、有时候则是干脆利落地，把球踢给他的玩伴，他的妈妈。他的妈妈就会把球踢回来，或者踢歪了，让它扭出很好看的黑白相杂的风。男孩很聪明，他会把球踢出去，可是球儿还没走到妈妈那里去的时候，他就嘻嘻地跟出去把它抱回来了，重新再踢一次。这时候，坐在石凳上静静的我就很不禁地笑了，我想他的妈妈也是吧——因为，好可爱的孩子啊！&lt;/div&gt;
&lt;div&gt;清晨的草色从来就很迷人，每次它们生机油油的面容都让我有恋爱的感觉：爱你美丽的时光，爱你对生命的预言，爱你让我灵魂舒坦的慰藉。&lt;/div&gt;
&lt;div&gt;清露的蕴涵一定洗净了白天喧嚣的尘埃，柔嫩的翠绿的精灵才都苏醒了，苏醒的她们就吸引了、生发了这漫天的水汽吧？&lt;/div&gt;
&lt;div&gt;弥漫的迷漫的水汽像是仙境的布景师，我什么都不是，就被氤氲成了一缕幽魂，飘忽地游荡。&lt;/div&gt;
&lt;div&gt;蓬蓬的树叶在雾里失去了层次感，成为水墨画里的一个灵感。细直的墨色的灯柱顶着三角形的头，像宫崎骏漫画里的一棵植物。&lt;/div&gt;
&lt;div&gt;在某一处，恰到好处的距离，有一棵奇峻的枯树，似乎没有一片叶子的衬托，似乎也不需要有任何东西来增添它现在的表现力：它是它，它是站在清晨雾里的它；不需要冬天的比喻，不需要春天的修饰，不是孤单者的代言人，不是群体的活跃分子，不描述生存的希望，不阐发死亡的哲理；仅仅就是它，被我看到，被天地宽容，被自己爱恋。&lt;/div&gt;
&lt;div&gt;我爱武大的树，也许会更爱别处的树，但是它们最初所占据的位子将永久不变。美其名曰：寻找一首遗忘的诗。其实，谁不知道呢？——她就镌刻在我的心里，在沉默的眼光里。&lt;/div&gt;
&lt;div&gt;黑漆的身躯，雅黄的喙，灵巧的小跑——一只乌鸦悄悄地窜进树阴处，打破我走神的片刻。&lt;/div&gt;
&lt;div&gt;当作一封信吧。&lt;/div&gt;
&lt;div&gt;——YOURS   2012-03-18&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>我期待夏天满怀着热量</title>
            <link>https://pythoncat.top/posts/2012-03-11-summer/</link>
            <guid>https://pythoncat.top/posts/2012-03-11-summer/</guid>
            <description>想要喷薄而出的情绪被我写成了文字</description>
            <pubDate>Sun, 11 Mar 2012 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;我期待夏天满怀着热量从无中生有而来，把迟迟不晴的春天赶进一种注定要被淘汰的“主义”里面去，就像把在过去几天里从我创作灵感中冒了头想要变成我的文字的那些桥段通通变成这一刻的音乐的间隙的一串串的模糊的印象。&lt;/div&gt;
&lt;div&gt;图书馆是最好的收容所。他不弃我是邯郸学步的好龙的叶公，当然也不管能不能在我身上抽取出诗性的油然后精炼出可定为本质的那些抽象的形象，最好的答案他不会保留，他不会指望靠曲折的情节把我留在剧场之下去品味芳洁自守的情致，他在第一章就报家门说出不想让我过度在意的结局：不想好结局就开始的书不会有好的结局，对结局的无意识的不满将是一群人的故事和纠纷，而沉淀的墨迹只会像蜜蜂的倒钩刺连带肝肠心胆一并深深深深插在书的肉里，注解一段有你在的历史，像甘德利草原上茫茫的青草欺骗一段八百年的关于宝藏的传说。&lt;/div&gt;
&lt;div&gt;等到书香变成细菌肆虐的霉气，等到阳光照不到的角落空空腾起自旋的风，等到你对得起时过境迁的标签，等到也许是一个春天、也许是一个夏天、也许是一个秋天、也许是一个冬天，等到有那一天，等到有了历史的心和死的觉悟，就是要这样等，要等很多的限制，等到那一刻，我想你不会不期望自己是一首写不完的诗，我想你会要求一个假设的原初状态，就是那一个可以如此实现而不可以如彼实现的 original position。如果这是有的，我想，是不是因为我们欠了谁的一份契约——不管是在谁的理论里的原始状态里命定的契约？&lt;/div&gt;
&lt;div&gt;说不出这一个在名义上无疑的春天的过错，因为还差那在心理治疗和人际关系之后所谓的终极目标叫做：自我实现。而他只是一片守不住的天空，有云和月，是被遗忘的诗的残音断部。喧哗在迷宫，骚动在悖论，如此不如彼，如彼不如此，编织成一个无解的二歧式的方程式。&lt;/div&gt;
&lt;div&gt;一个梦要我解释他是由我男人的那部分幻想成的，还是由我女人的那部分幻想成的。我看不出在自我的海洋下无意识的冰块像个什么形状，而感情和理性的同一性之交合似乎不是合理的欲望，永远得不到满足。&lt;/div&gt;
&lt;div&gt;一个是士兵，一个是囚徒，玩一种互换身份的游戏，可是他们没有足够的博弈论和正义论的知识，在冒险之前得不出一致的墓志铭，于是只有厮杀。&lt;/div&gt;
&lt;div&gt;心理学家让人崇拜的地方是他竟然知道你会崇拜他是一个心理学家。心理学家这样对我说：爱的需要也和盐的需要一样，机体可能为了维持健康，防治疾病而努力满足它。他先验地看透了人类的残缺本质，用爱引诱这颗孤独和孤单的心，引诱我空着咕咕叫的人类的肚皮，奔跑在历史典故的排泄物上，然后把我心中冲动的动机乔装成生死不弃的那种责任。这份契约，签了我的大名，而且是我一手和另一只手的策划。&lt;/div&gt;
&lt;div&gt;可是，尝一口那盐，也许他就是产自于冰山下冻结亿万年的不死的尸体，很好吃，很好吃，可是我吃不了多少，吃饱了，就要继续赶往自我实现的目的地，而且背负着责任的尖刀。&lt;/div&gt;
&lt;div&gt;我期待夏天满怀着热量从无中生有而来，把迟迟不晴的春天赶进一个女人的子宫里，就像一个精子找到了卵子，然后有我名字的书除了死亡的结局就还有三编九章 87 节 627 页的曲径通幽的情节。&lt;/div&gt;
&lt;div&gt;是多么虚伪的呻吟说什么“我期待夏天满怀着热量”，把情思寄托在一种必然不变的自然规律上，奇怪自己不是千年老妖能打败时间的催眠术，又不甘心身体上上下下的细胞都泄露了无力的机体，和不必然是独立的灵魂的孱弱。&lt;/div&gt;
&lt;div&gt;就像搁浅在沙滩上的螺贝，偷张开笨笨的碳酸钙的壳，张望下一次涨潮，期望偶遇上一个在乎生命的流浪汉把它捡起远远地丢尽大海里。&lt;/div&gt;
&lt;div&gt;期待的信息几乎都因为诗歌而著名，像一句“冬天来了，春天还会远吗？”成为薄幸书生流连红粉的折子扇，成为狡猾的姑娘引诱闷骚青年的欲拒还迎。&lt;/div&gt;
&lt;div&gt;等待和希望，谁说大仲马就是那么自信地为人类立言了，直到了最后他，他的骨头，没有一点儿男人！直到最后他变成一个保守主义者，斤斤计较一个最小值的最大值原则。&lt;/div&gt;
&lt;div&gt;在音乐里面寻一种高峰体验，在文字里模拟意念流转飘忽的百转千回。对不起一株没有知觉的植物。&lt;/div&gt;
&lt;div&gt;——2012-03-11 写于武大&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>拾不起的朵朵曼珠沙华</title>
            <link>https://pythoncat.top/posts/2011-09-08-flower/</link>
            <guid>https://pythoncat.top/posts/2011-09-08-flower/</guid>
            <description>曼珠沙华的故事</description>
            <pubDate>Thu, 08 Sep 2011 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;
&lt;div&gt;1、9 月 2 日在同一地方拍的一组我非常喜欢的照片。我喜欢她们的原因在于，无论是现实细节还是抽象的韵味，她们让我惊叹不已——也许你要说我是自卖自夸，然而我认为就算是顾影自怜的行为也出自典雅的气质。&lt;/div&gt;
&lt;div&gt;2、曼珠沙华，又名彼岸花。日本花语：“悲伤回忆” ；朝鲜花语：“相互思念”；中国花语：“优美纯洁”。——它们恰好意指了恋爱中人的三种状态，意指了三种不同的故事，如果片段已经漫长得自成故事。&lt;/div&gt;
&lt;div&gt;3、年年岁岁花相似，岁岁年年人不同！嗯，这真是一句催命催泪的名句——它的婉转悱恻大概不适合于所有的人——但是它永远是这么回事：它迟早会来到你跟前。就像死亡，只是迟早的事。&lt;/div&gt;
&lt;div&gt;4、花叶不相见，生生相错。兴许诗人喜欢自告奋勇要当大自然景象的代言人吧，而彼岸花的忧伤便源自于文人骚客引经据典而扭曲的气质了吧？生生相错，生死相离，本是同根生却是如此“折磨”，如果爱情——这算不算世界上最遥远的距离？&lt;/div&gt;
&lt;div&gt;5、我注意到三个片段的顺序是变化的。其一，抛去旧的悲伤回忆，迎来新的优美纯洁，如此苦尽甘来峰回路转的故事，美则美，常人哪有不喜欢看大团圆结局的？然而，抛弃旧爱，隐藏旧伤，此时啊，难道人儿不是心意惶惶，难以信任别人了么？看谁诗言之情意深深说什么“曾经沧海难为水，除却巫山不是云”，舍去那些个容易变心的人，舍去那些个容易软弱人的时节，还真不难看出她对人情之初纯洁记忆的冲击力。爱情是要来抚平伤口的吗？爱情是要来化作甘霖的吗？&lt;/div&gt;
&lt;div&gt;6、既然年岁不饶人，逝者如斯不依人，我该做如何看待？随波逐流，顺其自然吧，青青沧浪水中有馨香的胭脂，兴许划过陈迹赫赫的渡口，还有玉树后庭花的助兴。&lt;/div&gt;
&lt;div&gt;7、试设想哦，现在是阳春三月，曼曼的风儿如柳，飘飘的柳儿如风，好一个宜人的年华不是？且发散了思维四处创造一个恰意的背景，例如可以添上清明的天，清白的云，青翠的湖水，试设想哦，你听到了隐隐而绵绵的鸟啼叫声，你还发现了好大一丛红的黄的争妍斗艳的花，在安静的树荫一处，巧巧地设置了长椅一方……如果爱情出现了，我们让这个故事的开始是优美纯洁的好不好？我不忍心把它摧残了哦，但是假设我们贪恋创造的乐趣，我们假传造物主有轻易不成人之美的喜好，就这样在他们之间强加怀疑、厌烦、背叛的魔障，终于让美好的爱情变成悲伤的回忆！那么，现在，也算我们创造了一个寒冬了吧？他们在冷风中颤抖，会不会思念起曾经的依靠，想起曾经的光和热呢？彼岸花再开的时候，他们会回到当年留连的地方凭吊么？他们会不会还耿耿着承诺，盼望着再见到思念的人儿呢，或者说，早已经割舍了旧情而折了良木栖息？路在何方哦——倘若要造出可比于开头的结局，需要半生的精力吧？&lt;/div&gt;
&lt;div&gt;8、花叶不相见，这不是大自然的本然么？贯注于一端有利于植物生长，何来的像是比翼鸟失去一翼便不成完美爱情的悲恸？花自开放，虽说总不能逃脱于环境肥沃与贫瘠的约束，但总也不见得要成全人类移情的癖好。说什么并蒂莲，说什么连理枝，只算得上对美满婚姻的意淫，或者是要贯注一种天作之合的神圣——纵是花仙草圣，它们也许只会把爱情和婚姻看做两种性器的结合，这也说不准哦，它们是循着基因的密码生死枯荣，传宗接代只算一个插曲吧？&lt;/div&gt;
&lt;div&gt;9、如果优美纯洁是新人给予的，那么它怎样才能如愿呢？有一种朋友的撮合吧，有一方的宽容和善解人意吧，有一人的觉悟和超越吧？记忆的伤是灵魂的伤——除了稀释淡化，不能减少它的作用。但是哦，树欲静的时候风儿不停息的骚扰——他说他可以忘掉过去与你重来呢，他说哦你愿意包容他吗？旧人的怀抱总是熟悉些，旧人的呼唤也是亲切些，但是再次失去的可能叫你害怕了吧？敏感的神经要膨胀了，如果没有雾霭你也要造出来它，如果有迷雾你会想象它后面有邪恶的嘴脸——浮生就要这一般的苍凉吗？退进都怕不是避风港，这还算天赐的青春么，为何如此的无所适从？&lt;/div&gt;
&lt;div&gt;10、曼珠沙华，传说开在黄泉路上，死怨嗔恨的流毒侵入了它的根茎。毒哦，艳丽的毒，死亡的毒！染了毒的美好纯洁还能不能坚持到地老天荒呢？——你会自信地说这世上还有什么不是染了毒的呢？——但是，你也会一直的自信着你已经百毒不侵了么？&lt;/div&gt;
&lt;div&gt;11、开在黄泉路上的彼岸花，会像一条血液的地毯吧，会是耀眼的路灯吧？——诱惑无辜的生灵，抑或是给亡灵以指引和安慰呢？&lt;/div&gt;
&lt;div&gt;12、出生在阴冷潮湿的所在，生命的底色里缺少不了悲凉的部分么？你还这么努力地挣扎，呐喊出血迹满身为哪般？为了奔放的晴空里排云而上的鹤儿，为了散发热烈红艳的光芒？==你是在守候着谁么，等待于幽冥的地域？——我不害怕，我很爱他！&lt;/div&gt;
&lt;div&gt;13、我是天空里的一片云/偶尔投影在你的波心。你忘记也好，但我指望你记住——我不是多情的公子。有时候翩然的离开是因为已经陶醉在你温柔的甜蜜，死在你一声亲昵的叫唤里；我不是迷恋了路边的野花，更不是消退了对你的激情，我从不害怕那些未知的负累！&lt;/div&gt;
&lt;div&gt;14、婷婷玉立于青青青草之上，火把似的燃烧，燃烧像要把除了灰以外的人间都烧成了灰！婀娜升腾的是妖娆的花瓣，是散着热的情火，是熊熊燃烧成一路的曼珠沙华！——嫉妒的火，孤独的火，仇恨的火，欲望的火，总之是火！像火一样的花才配得上像火一样的女子。&lt;/div&gt;
&lt;div&gt;15、每一朵曼珠沙华有一个跳跃的灵魂，有一段传奇的神话故事要向有人诉说。他们喜欢用沧桑的话音来吸引你的注意力，说起佛经的注解：“彼岸花，开一千年，落一千年，花叶永不相见。情不为因果，缘注定生死。”他们看惯了生死变换，为了不被忘却，也学会了不择手段——他们收藏了很多的素材，也学会了一些技巧，统统是要留住你，要你相信他们的虔诚。&lt;/div&gt;
&lt;div&gt;16、很久很久以前，噢，请原谅我真的是不记得在多久以前，那时候神界的彼岸花有两个守护的精灵。一个精灵擅长舞蹈，看了的人都说它能化解心中的怨念郁结，就像白天赶走了黑夜；一个精灵擅长歌咏，听了的人都说它能增添心中的真善美好，就像太阳代替了月亮。这两个精灵啊，一个是花妖曼珠，一个是叶妖沙华——谁能不记得他们哦，被祝福着的两个精灵！他们疯狂地崇拜着对方，他们疯狂地爱恋着对方，他们对人们说他们要生生世世日日夜夜永永远远的守护在一起！可是啊，他们中了无情的诅咒：花开时叶落，叶落时花开，永不得相见。寻找爱人的倩影啊有千万年了还是不见，谛听爱人的情语啊有千万里了还是不闻——彼岸花站成了瞭望的灯塔，托举着虔诚祈祷的火把！……&lt;/div&gt;
&lt;div&gt;17、想我了吗？你这么说过。但是我不知道你是对谁说的那句话。——傻傻的问自己，为什么不敢相信自己的直觉？&lt;/div&gt;
&lt;div&gt;18、又是一个九月春秋了哦——一个月的春秋，那些巨变，那些温暖和冷漠的难以猜测，那些感性和理性的拉锯，苦！当你说，有些事不要强求，我怀疑你是不是暗示着我缺少更真挚的行动；当你说，像现在这样不是很好吗，你是不是要说我不值得你托付未来？&lt;/div&gt;
&lt;div&gt;19、作为一朵彼岸花，我知道我和别的彼岸花是不一样的——那是基因和生长际遇的作用。我们的灵魂是独立而不求相同的东西：慵懒的花晒着暖暖的阳光，浮夸的花招徕着流浪的蝴蝶，爱八卦的那一团在窃窃私语里偷偷着乐，无为的花枕了石子听嘈杂的风声，勤勉的花默默收集着地底的水丝，灿烂过的花在复述着老掉牙的传奇，天真的花问着神秘的问题——“什么是问题？”…当然了，我不会把静止的一刻当做他们灵魂的常态，就像我从不陷于捉摸不定的苦恼。我老了，在意识到这个问题并认为它是一种责任的时候，我突然是睿智和宽容的；在其它时候，我只是一个孩子了，一个小小的真正的孩子。&lt;/div&gt;
&lt;div&gt;20、有人说曼珠沙华是情花，中了花毒的人，一旦动情就会心如火烧生不如死，是这样吗？你不回答我就当你是默认了。——等等，世上根本没有情花这回事，如果真有爱情之毒，那也是中毒者人为的发明，为什么你要虚伪的承受这荣誉？你也是幽灵花、地狱花吧？你就卑贱的只配接受诅咒了！你现在为何还是一脸无辜的死相，难道你以为只要压抑波涛般汹涌的思想活动，我就不能接受你的脑电波，不能看透你的腐烂的发臭的歹毒的心肠了吗？&lt;/div&gt;
&lt;div&gt;21、最是那凄迷的梦境让人难忘，空虚的梦城频频出现你的身姿；最是不能忘你绾系住的长发，用我不知道的手法；说过的没有实现的话，不管是不是玩笑，也许你忘了，也许我也记不起了，但是它们记录在我们都看得到的地方。&lt;/div&gt;
&lt;div&gt;22、在我的旅程里，你不要离开得太远，因为当我离远的时候，你可能会迷路。&lt;/div&gt;
&lt;div&gt;——2011-09-08  HAH&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>碎碎念想之读《沉香屑·第一炉香》记</title>
            <link>https://pythoncat.top/posts/2011-08-06-xiang/</link>
            <guid>https://pythoncat.top/posts/2011-08-06-xiang/</guid>
            <description>中学课本中选录过张爱玲的小说片段，我还读过她写的只言片语，但直到昨天，我才完整地读了她的小说</description>
            <pubDate>Sat, 06 Aug 2011 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;中学课本中选录过张爱玲的小说片段，我还读过她写的只言片语，但直到昨天，我才完整地读了她的小说。&lt;/div&gt;
&lt;div&gt;别人对于她和她作品的评论我早已接触过，脑子里早也杂渗了对她们模糊的印象；然而，待品味过她的文字，我才有了自己的想法。&lt;/div&gt;
&lt;div&gt;我认真读完的第一篇是《沉香屑·第一炉香》。&lt;/div&gt;
&lt;div&gt;现在思路还未进入故事中，有点恍惚起这题目来了。&lt;/div&gt;
&lt;div&gt;沉香屑似是一种香，难道跟沉香有密切的关系么？&lt;/div&gt;
&lt;div&gt;两者我都未见识过，难道它还有特殊的象征意义么？&lt;/div&gt;
&lt;div&gt;“第一”的字眼，我觉得像是系列作品的开端——那么，往后要看的作品，也便做这一部的文字叙述和感情倾向了吧？&lt;/div&gt;
&lt;div&gt;有同学对张的评价是“一个很有个性的才女，感觉她是遗世而独立”。&lt;/div&gt;
&lt;div&gt;在我看来，遗世而独立是一种飘然超越的姿态，是不与沧海做一粟的高度，有成仙成圣的清洁；照这种理解，在看完沉香屑后，我没觉得把它放在张身上会是贴切的。&lt;/div&gt;
&lt;div&gt;张有陷于自身现实的痛苦，也有陷于小说世界的痛苦——她用痛苦衍生痛苦，也试图用痛苦压抑痛苦——她放大心灵细腻的优点而收敛应该广阔的视界，她用丰富的联想创造像是历史的现实而欲淡忘身在其中的自己的生活……&lt;/div&gt;
&lt;div&gt;其实，这个时候我去评说作者，这种行为和产生的言辞都无甚意义；在说别人自欺欺人的时候，往往自己也是自欺欺人。&lt;/div&gt;
&lt;div&gt;要定性总评这 53 页的故事，必然要搭进许多跟这个故事无关的东西；于是，要说张写的是一个悲剧，我会显得底气不足。&lt;/div&gt;
&lt;div&gt;只好跟她一样说，这是“一支战前香港的故事”。&lt;/div&gt;
&lt;div&gt;这一战不知是哪一战，但不管是哪一战，战前或是战后，张的文字都有一种魔力，让你在阅读时觉得像拉近来一幅画仔细就看清了色彩缓急的对照，又觉得像是被画吸进了去能听清风中的碎语又闻到雨季的南国泥臭。&lt;/div&gt;
&lt;div&gt;在故事的开始，葛薇龙还是个在传统和时髦服装混搭下“非驴非马”的中学学生妹，从上海来到殖民地香港要读书两年。&lt;/div&gt;
&lt;div&gt;她的外貌还是“温柔敦厚的古中国情调”，“年轻脸嫩”，等见识过丫环和姑妈后，觉得委屈就“滚下来两行泪珠”。&lt;/div&gt;
&lt;div&gt;她是“娇养惯的”，但是有自主想法，为人单纯善良，就算加上她打发陈妈和偷试衣服时的小小虚荣心，她还是一个中国式的良家女孩。&lt;/div&gt;
&lt;div&gt;姑妈梁太太是个名声和行迹都不干净的有钱寡妇，也自称“自甘下贱，败坏门风”“我就是小性儿！我就是爱嚼这陈谷子烂芝麻！”&lt;/div&gt;
&lt;div&gt;第一天照面之后，葛薇龙“看她姑妈是个有本领的女人，一手挽住了时代的巨轮，在她自己的小天地里，留住了满清末年的淫逸空气，关起门来做小型慈禧太后。&lt;/div&gt;
&lt;div&gt;”她姑妈长得娇小个子，“脸是白皙中略透青苍，嘴唇上一抹紫黑色的胭脂”，而眼睛是“似睡非睡的”。&lt;/div&gt;
&lt;div&gt;外貌还可见，内心呢，长了一个毒瘤！&lt;/div&gt;
&lt;div&gt;但凡上了一定岁数的人，阅历中有足够的人事变迁和社会变更，她/他便是一个复杂的复合体了。&lt;/div&gt;
&lt;div&gt;他们有一套不易改变的价值观和生活法则，在心底和外界环境的惯性推动下，像车轮一样咕噜咕噜循环着转——碾碎一切障碍，甚至把途中的一切拉着转动。&lt;/div&gt;
&lt;div&gt;薇龙要寄住姑妈家，自知是“睁着眼走进了这鬼气森森的世界”，这时她还是青莲不惧污泥的姿态，“只要我行得正，立得正，不怕她不以礼相待”。&lt;/div&gt;
&lt;div&gt;她对待学业是认真的，两三个月后忙于诸多应酬还能“夜里补上时间念书念到天亮”。&lt;/div&gt;
&lt;div&gt;但是，在这勾心斗角的上流社会中，各处遍布的是有形无形的漩涡，底下还藏着吃人的嘴脸，坠入其中便是血肉模糊，再也出不来了。&lt;/div&gt;
&lt;div&gt;入住之前，她还算立场明确，往后的故事，兴许可作青蛙在烂泥潭中生存的故事了。&lt;/div&gt;
&lt;div&gt;从世俗恶俗的角度看，梁太太就像青楼的妈妈，而薇龙呢，到最后，“不是替梁太太弄钱，就是替梁太太弄人”。&lt;/div&gt;
&lt;div&gt;弄钱好解释，那些想吃天鹅肉的癞蛤蟆要破财才能接近姑侄俩。&lt;/div&gt;
&lt;div&gt;至于弄人呢，那些个想追求薇龙的人，必须得先和梁太太攀交情，而她这时会使出擅长的把戏，让他们“弄假成真，坠入情网”，最后一个个成了她石榴裙下的风流鬼。&lt;/div&gt;
&lt;div&gt;她是个精明的物质主义者，“毅然嫁给了一个年逾耳顺的富人，专侯他死”，丈夫死后，“心里的饥荒”使她需要“许多人的爱”！手下的丫环，还有这侄女，便成了她的工具了。&lt;/div&gt;
&lt;div&gt;丫环睇睇和梁寡妇闹翻时嚷道“乔家一门子老的少的，你都一手包办了，他家七少奶新添的小少爷，只怕你早下了定了。连汽车夫你都不放过……”&lt;/div&gt;
&lt;div&gt;这样让人难堪的言辞并没有牵动梁太太多大的肝火，她竟还流露出一种得意，认为这一切理所当然——她可不打算否认自己是个人尽可夫的主儿！&lt;/div&gt;
&lt;div&gt;虽说这睇睇也是促成“肮脏，复杂，不可理喻的现实”的一份子，但她也敢于抗争，不愿妥协沉溺下去；如果说她有积极的意义，那她象征的就是自由独立的力量，是人性道德之光。&lt;/div&gt;
&lt;div&gt;形成鲜明对比的是另一个丫环睨儿，她精明而势利，刻薄而善于讨人欢喜，心肠不坏却维喏软弱、安于现状；待到奸情撞发而挨打时，“也不还手，也不辩白，也不告饶”，她就像一个没有自由意志的供人取乐的人偶，是腐朽的上流社会的牺牲品。&lt;/div&gt;
&lt;div&gt;两个丫环代表了两种应对“肮脏，复杂，不可理喻的现实”的态度，两种不同的力量，两种不同的命运。&lt;/div&gt;
&lt;div&gt;前一种是不服的，是要抗争的，后一种是顺从的，是去适应的——这种矛盾其实是“生命不可承受的轻与重”的矛盾，也是人性对“灵与肉”选择的矛盾——它们存在于每个人的心中，或清晰或暗淡，但永不泯灭。&lt;/div&gt;
&lt;div&gt;这两种态度也折磨着薇龙，她的选择是什么，她的命运又是什么样？&lt;/div&gt;
&lt;div&gt;豆蔻年华，少女怀春，薇龙对卢兆麟有好感，而卢对她似乎也有同样的心情。梁姑妈岂有不知，横刀夺爱之后，竟也觉得“有些心虚”。&lt;/div&gt;
&lt;div&gt;当卢眼光灼灼多看另一社交花时，薇龙“心里便像汽水加了柠檬汁，咕嘟咕嘟冒酸泡儿”，而到姑妈已经和卢打得火热时，她是“一点儿不生气”还“连怒都不敢怒了”！&lt;/div&gt;
&lt;div&gt;嘴上说过她和卢是“八字还没有一撇”，但是看到姑妈和卢四眼含情“难解难分”时，“忍不住一口气堵住了喉咙口，噎得眼圈子都红了”。&lt;/div&gt;
&lt;div&gt;因着卢兆麟一事，她痛恨着姑妈，但更多的就是无奈和妥协了——青蛙在泥潭的一角蹲得不舒服便要挪一处地方——她很快把注意力转移到“唯一能抗拒梁太太魔力的人”。&lt;/div&gt;
&lt;div&gt;到这里，是她第一次的报复和抗争吧——虽然是偶然的，也没有多少破坏力的。&lt;/div&gt;
&lt;div&gt;青蛙被黑土濯污，不舒服了跳进个小水洼，但是别忘了，她始终还在这臭泥潭的魔爪中！&lt;/div&gt;
&lt;div&gt;这个人便是乔琪。这个长相苍白，“和石膏像一般”的人，他的眼睛“像风吹过的早稻田，时而露出稻子下的水的青光，一闪，又暗了下去”。&lt;/div&gt;
&lt;div&gt;他的柔情蜜意便像眼里的青光，而长久的暗着的部分便是消极颓丧、纵欲贪欢的真面目。&lt;/div&gt;
&lt;div&gt;在认识薇龙之前，梁太太利用睇睇来引他上钩，“香饵是被他吞了，他还是优游自在，不受羁束”，他还敢借梁太太做幌子去接近别的女人——这让梁太太怒不可遏。&lt;/div&gt;
&lt;div&gt;他就是一个无所事事而四处留情的登徒子，像是烂泥潭里离了水面的小块平地，看似可以落脚，殊不知地底下尽是被他吞食血肉后的枯骨。&lt;/div&gt;
&lt;div&gt;听过睨儿现实功利的分析后，薇龙对卢“寸步留心”，冷淡了许多。&lt;/div&gt;
&lt;div&gt;要在“肮脏，复杂，不可理喻的现实”中生存，必须学会小心翼翼。&lt;/div&gt;
&lt;div&gt;但是，这臭泥潭中除了不可靠的烂泥外，还有伪装是烂泥却随时会扑上来张开血盆大口的食人鳄——姑妈准备牺牲她来笼络老情人——它是吃人都不吐骨头的恶魔啊！&lt;/div&gt;
&lt;div&gt;梁太太资助薇龙上学，收留她在身边，本意就是做一次投资；辞退睇睇后，薇龙更是被当做了“替工”。&lt;/div&gt;
&lt;div&gt;“像今天这一类事，是不可避免的”，“也不见得限于这一次”。&lt;/div&gt;
&lt;div&gt;推却吧！离开吧！&lt;/div&gt;
&lt;div&gt;心中有道德的声音来提醒：小青蛙你快离开这泥潭吧，趁现在还来得及！&lt;/div&gt;
&lt;div&gt;离开这儿？“三个月的工夫，她对于这里的生活已经上了瘾了。”&lt;/div&gt;
&lt;div&gt;离开之后，又会怎样呢？&lt;/div&gt;
&lt;div&gt;离开之后能找到一个既有钱又合意的丈夫么？&lt;/div&gt;
&lt;div&gt;跳出一个泥潭之后，说不定是一个更恐怖的泥潭呢——你是这样想的么？&lt;/div&gt;
&lt;div&gt;内心起波澜的时候，她想起乔琪，想起他求爱的种种——她知道他不是真心真意的——但是“她对爱认了输”！！&lt;/div&gt;
&lt;div&gt;可怜的薇龙啊，你相信有乔家的背景是“不怕没有活路可走”的，你还天真地以为“只要他的妻子爱他，并且相信他，他什么事不能做？”——什么事都能做，真的是什么事都能啊！&lt;/div&gt;
&lt;div&gt;你相信他会变得积极上进，静下心来做些正经事业，你相信自己可以与狼共舞！——这个却是不能做的啊！&lt;/div&gt;
&lt;div&gt;“我不能答应你结婚，我也不能答应你爱，我只能答应你快乐”，听到乔琪对你说这样的话，你难过你伤心，但是，你也是有病的！&lt;/div&gt;
&lt;div&gt;你可以很容易满足于乔给你的一夜情的愉快回忆，那么固执而自卑地爱着他，还“完全是为了他不爱你的缘故”！&lt;/div&gt;
&lt;div&gt;你庆幸自己得到了梁太太抢不走的爱，还觉得这是“新的安全，新的力量，新的自由”。&lt;/div&gt;
&lt;div&gt;你是有病的，你开始认同只要快乐就好了，去谈爱去结婚的人都是傻瓜！&lt;/div&gt;
&lt;div&gt;——莫非一只青蛙在泥潭中呆久了，吸入了足够的臭气，她吐出的气息也会变得腐朽吗？&lt;/div&gt;
&lt;div&gt;薇龙喜欢把头枕在胳膊弯里，这时候她就感觉无数小小的冷冷的快乐，像金铃一般在她的身体的每一部分摇头。&lt;/div&gt;
&lt;div&gt;把头枕在胳膊弯这个“可爱的姿势”原是乔琪特别的习惯，它“引起薇龙一种近于母性爱的反应”，让她有一种“软溶溶，暖融融的感觉”。&lt;/div&gt;
&lt;div&gt;也许每个人都有特殊的癖好，也许这个姿势于她有很久远的记忆，也许她莫名地喜欢这个姿势带来的快感，然后，她才爱上了他？&lt;/div&gt;
&lt;div&gt;或者是，她因为喜欢他，爱屋及乌，因而也喜欢上它？&lt;/div&gt;
&lt;div&gt;——谁知道呢，“爱”本身不就是一个莫名其妙的令人费解的字眼么？&lt;/div&gt;
&lt;div&gt;如果要讨论“爱”，这里是少不了社会道德律的参与的，但是，谁又能规定它是我必须受到约束的真理呢？&lt;/div&gt;
&lt;div&gt;只有妥协了，顺应了这个时代的道德观和价值观的人才会认可爱的责任，认为忠贞是理所当然的。&lt;/div&gt;
&lt;div&gt;但是，显然乔琪是不吃这一套的。和薇龙发生关系的当晚，他又“顺手牵羊吊上了睨儿”。&lt;/div&gt;
&lt;div&gt;这被薇龙撞见了，她如何能不气，如何能不伤心？&lt;/div&gt;
&lt;div&gt;这下要认清乔的真面目，这下要死了心，这下要离开了吧？&lt;/div&gt;
&lt;div&gt;向睨儿撒气之后，薇龙终于决意要回上海去“做一个新的人”。&lt;/div&gt;
&lt;div&gt;但是，要离开这个无边的烂泥潭会是一件容易事么？&lt;/div&gt;
&lt;div&gt;树欲静而风不止啊！更何况，这树，是在骨子底里下定了决心要静下去么？！&lt;/div&gt;
&lt;div&gt;起风了，第一阵是姑妈虚假的好意和兜兜转转的恶毒心肠，第二阵是乔琪的糖衣炮弹；这些伎俩没有作用，她还是坚持要走。&lt;/div&gt;
&lt;div&gt;接着，第三阵，是真的风雨来了，她“感冒转肺炎”，病倒了！&lt;/div&gt;
&lt;div&gt;本就是一个脆弱的人，躺在病床上，她变得更加不堪一击了。&lt;/div&gt;
&lt;div&gt;这时候，第四阵风，最强的一阵风，她自己，来了！&lt;/div&gt;
&lt;div&gt;人的内心里藏着向善和向恶两种力量，扮演着积极和消极两种角色，它们处在无休止的斗争中——人的一生可作自己与自己斗争的历史——在历练后，有一种力量会长久地占据上风，于是有的人升华了，有的人堕落了。&lt;/div&gt;
&lt;div&gt;不幸的是，在薇龙这片战场上，后一种力量胜出了。&lt;/div&gt;
&lt;div&gt;“为了适应环境，她新生的肌肉深深地嵌入了生活的栅栏里，拔也拔不出”——她向这“肮脏，复杂，不可理喻的现实”妥协了！&lt;/div&gt;
&lt;div&gt;当她向姑妈说出“你让我慢慢地学呀”，我真切地听到了一只癞蛤蟆的声音——烂泥潭里的青蛙已经变成一只蛤蟆了，那么丑陋，那么不堪入目，那么肮脏，那么不可理喻，那么让人悲哀和同情！&lt;/div&gt;
&lt;div&gt;如果你要说，是因为烂泥腐蚀了她的皮肤才使她变了形，那么，不止是进化论的粉丝会否定你，我也要说，是她的基因——她的立场她的原则她的人生观——变异了，她才会变成这样。&lt;/div&gt;
&lt;div&gt;而她早应该离开的烂泥潭本来就是一个烂泥潭而已！&lt;/div&gt;
&lt;div&gt;一心向学，加上梁太太的提拔，妥协之后的薇龙很快就和乔琪结了婚，也轻易俘获了别的情人的芳心。&lt;/div&gt;
&lt;div&gt;她终于是整天忙着，“不是替梁太太弄钱，就是替梁太太弄人”；算得上是快乐的时候就是“阴历三十夜她和乔琪两个人单独的到湾仔看热闹”！&lt;/div&gt;
&lt;div&gt;她的未来是“无边的荒凉，无边的恐怖”。&lt;/div&gt;
&lt;div&gt;当他们走到妓女揽客的街道，她说道“我跟她们有什么分别？”“她们是不得已，我是自愿的！”&lt;/div&gt;
&lt;div&gt;这时候，她的心里是无边的寒冷，无边的黑暗，还是无边的安静，无边的从容呢？&lt;/div&gt;
&lt;div&gt;这时候，她是否还记得自己曾叹息姑妈的可怜呢？&lt;/div&gt;
&lt;div&gt;这时候，她是要自己来嘲笑自己的可怜，还是要等别人来惋惜她的命运呢？&lt;/div&gt;
&lt;div&gt;——如果真有别人，是不会包括梁太太和乔琪的。&lt;/div&gt;
&lt;div&gt;在新婚前，梁太太曾对乔琪说，等七八年薇龙不能挣钱养家了，“你尽可以离婚”，“你要抓到对方犯奸的证据还不容易？”&lt;/div&gt;
&lt;div&gt;姑妈是如此地“关照”着她，而乔琪也敢于厚颜无耻地卖弄说“我从来没对你说过一句谎”！&lt;/div&gt;
&lt;div&gt;那么，诚如张爱玲在结尾所说，“薇龙的一炉香，也快烧完了”！&lt;/div&gt;
&lt;div&gt;张爱玲讲完故事了，我也复述完故事了。&lt;/div&gt;
&lt;div&gt;但是我突然地觉得自己没有资格说葛薇龙有病——说一个人肉体有病，医生是权威；而要说一个人心理有病，心理没病的人才算是权威——而我还解不开这个悖论！&lt;/div&gt;
&lt;div&gt;对于这个故事，我实在难以忘记的是薇龙去定船票回来的一个夜晚。&lt;/div&gt;
&lt;div&gt;那个时候——“天完全黑了，整个世界像一张灰色的圣诞卡片，一切都是影影绰绰的，真正存在的只有一朵一朵挺大的象牙红，简单的，原始的，碗口大，桶口大”……&lt;/div&gt;
&lt;div&gt;——写于 2011.8.6，改于2019.7.29&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
        <item>
            <title>你和我，两根线的缘分</title>
            <link>https://pythoncat.top/posts/2009-10-31-lines/</link>
            <guid>https://pythoncat.top/posts/2009-10-31-lines/</guid>
            <description>人生的真相就在于它的变幻不定了吧，人与人之间的缘分也是如此</description>
            <pubDate>Sat, 31 Oct 2009 00:00:00 GMT</pubDate>
            <content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;无论你是我的亲友邻里，还是我的师长同窗；无论你是我的知音知己，还是泛泛之交；无论我们相识多年，还是素未谋面······于无涯的时间里，在无际的空间中，你和我的相遇，是两根线的缘分。&lt;/div&gt;
&lt;div&gt;也许我们是相交的两根线段，漫长的一生只独留给我们擦肩而过的一瞬或短暂的共处，然后是天各一方，我们义无反顾地朝着原先的不同的远方远去。质本洁来还洁去，无需任何回忆。也许我们的交点是某一方的始点或终点，这时，一方的生命因另一方而延续，我们是生与死的交替，是因与果的轮回。不去想这种缘分是偶然还是必然，当我们邂逅时，我只想送你一个微笑，而我最想从你那得到的也是它。&lt;/div&gt;
&lt;div&gt;也许我们是一根直线和一个圆。相切时，我们曾有交融的一点，但是，线进不了 圆的心，尽管它们离得那么近，圆也包容不了线的旅程，它的心不在那里。相交时，我们曾或者将会朝夕相处，彼此靠得更近，同甘共苦，学习影响，打闹玩笑，从陌生到熟悉——有的又回到陌生——或者一直陌生，这种缘分太容易忘怀，一旦重拾并延续，又很容易酿成香醇的酒，我一直期待在多年以后自己能品尝到几坛！相片和字迹会像天边的流星瞬间黯淡，记忆会像野外的流萤在明灭间消逝，我明白，灵魂只能独行（周国平语），生活总是一个人的战争，但是，在我的未来里，记忆中的你的点点滴滴会汇成滋润我的甘泉，让我 ALONE BUT NOT LONELY……&lt;/div&gt;
&lt;div&gt;也许我是正弦函数线，你是横轴（反之不一定成立）。与你第一次相遇后，我扭头回转或者无意却为之，最后再次又再次相交，我的心情全绕着你而起起伏伏；如果你是一座跷跷板，两边放着的便是我的喜与忧笑与泪，假如你无意倾斜，请告诉我，我会将你当作连绵的沙滩，日夜涨落日夜把你问候；也许我们的相交只是概率学的偶然作弄，清如水漂如油，各自有各自的归宿。&lt;/div&gt;
&lt;div&gt;也许我是正弦线，你是关于Ｘ轴对称的另一条，那么我们得承认，上帝掷色子的理论已经无法解释我们的缘分。那样的话，我希望这纠缠不清的轨迹能重叠为一，而不是《搜神记》里拓跋与姑射的令人扼腕的有花无果；或者说，这种完美的互补和对称不是柏拉图所说的那种，那么，兄弟～朋友～姐妹，我们手拉手便胜过世上最坚韧的绳索。&lt;/div&gt;
&lt;div&gt;也许我们是坐标轴和反比例函数线，今生来世的轮回，生生相叠。曲线从四面八方无限地向直线靠去，交点在望却达不到。如果因为追赶而越来越逼近是一种幸福，那我愿意像西西弗斯生生世世推着巨石向山顶攀登，让那沿途也飘满爱的花香。但是，如果永远有希望意味着绝望，那么，呆子或者傻瓜，不要再拿生命当赌注了，抛掉无知和冲动，我们还是各走各的吧。不是每个时候我们的理性都会胜过感性，反之也是，任何一种失衡都是误会和遗憾的起源，只有相知才能互补。&lt;/div&gt;
&lt;div&gt;也许我们是两根平行线，在鸿沟两边遥望却盼不到在终点相交的那一天，人生的列车枕着我们呼啸奔驰，在等待站台时我们慢慢腐朽；或者这两根线属于两个世界（异面直线），我们或迷惘或执着——可能兼而有之，可能兼而无之——地追寻自己的源头，没有意识到彼此的存在；又或者，在默默无闻的我变作地底的煤或岩石后，你才呱呱呱呱地形成一个点，由未知的力量推着划起线，只有我在你的世界里，而我却永远不知道你；又或者，你就是我，你是镜中的虚象，你来自另一个维度，我们是两个华州，就像两个博尔赫斯，这段文字不是来自第三者～～&lt;/div&gt;
&lt;div&gt;如果把眼光放在“现在”，不去考虑一生的种种可能，那么，我们还不是线而是点。我们像广阔湖面上两粒浮萍或者两粒花粉，生不由己地作着一种叫做布朗的运动，我们是孤独无助的，更得时时留心风雨、同类和鱼虾，全凭命运的拨弄，不知道会是相遇还是错过，像薛定谔的猫，不知道是生还是死……如果我们积极进取勇于创造的心不能被它泯灭，嘿嘿，大湖就变成我们的天堂，我们在上面画下抽象但唯美的图腾……&lt;/div&gt;
&lt;div&gt;也许～～～&lt;/div&gt;
&lt;div&gt;也许～～～&lt;/div&gt;
&lt;div&gt;也许～～～&lt;/div&gt;
&lt;div&gt;我想尽量把各种“缘”都诉诸笔端，但是我的人生阅历、想象力和表达能力都不能胜任，而且，只有一个我，却有那么多的“你”，我的线和你们的线连成的是和白蚁王宫一样复杂的立体图，真个是“剪不断，理还乱”。&lt;/div&gt;
&lt;div&gt;人生的真相就在于它的变幻不定了吧，我说的可能可能也许也许或者或者，那只是一个无知小儿写的幼稚剧本，一个人自编自导自娱自乐。我知道那是自己在骗自己，精神分裂的孩子会认为自己有两个脑袋，他最喜欢的还是自己而已。&lt;/div&gt;
&lt;div&gt;我不是 Truman 有一座桃源岛可以逃，不知道是不是有那么一座岛可以给我逃，更不知道是不是可以逃得出。所以我才要做一个导演的角色让自己自豪，然后在另一个地方做一个小演员让别人为我而自豪……&lt;/div&gt;
&lt;div&gt;——初稿 2009.10.31，修改 2019.07.20&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;花下猫语：&lt;/strong&gt; 有个关于夏天的话题萦绕在我脑海里已经两三年了，可我迟迟下不了笔。翻阅 QQ 空间里的日志找灵感。大学的几年里，我竟然写了近 100 篇，有的跨越了挺长时间，单篇累积的体量可不小（最长的一篇写了一年，2万4千字）。那时在相识的亲朋同学圈子里，写作全无忌惮，也不在意阅读与评论。如今情感少了蓬勃，还总是顾虑重重，发什么都设分组，过后时时牵挂着回响。莫名的负担，莫名的面具。为自己不甘。往后，我会整理一些旧文出来，一点点卸去这几年的失语负担。上文是 10 年前刚进入网络社交空间时，我写下的第一篇文章。从时间与话题看，作为一个开始，还算不错吧。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
        </item>
    </channel>
</rss>